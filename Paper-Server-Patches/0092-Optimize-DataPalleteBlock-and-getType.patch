From 5e9bba461b67e82895d4d968fb902f62e16ec3a6 Mon Sep 17 00:00:00 2001
From: SotrForgotten <i@omc.hk>
Date: Sat, 2 Jul 2016 19:31:34 +0800
Subject: [PATCH] Optimize DataPalleteBlock and getType


diff --git a/src/main/java/net/minecraft/server/DataPaletteBlock.java b/src/main/java/net/minecraft/server/DataPaletteBlock.java
index b395221..109f877 100644
--- a/src/main/java/net/minecraft/server/DataPaletteBlock.java
+++ b/src/main/java/net/minecraft/server/DataPaletteBlock.java
@@ -6,7 +6,8 @@ public class DataPaletteBlock implements DataPaletteExpandable {
 
     private static final DataPalette d = new DataPaletteGlobal();
     protected static final IBlockData a = Blocks.AIR.getBlockData();
-    protected DataBits b;
+    // protected DataBits b; // Paper - nope
+	private final short[] data = new short[4096]; // Paper
     protected DataPalette c;
     private int e = 0;
 
@@ -32,18 +33,20 @@ public class DataPaletteBlock implements DataPaletteExpandable {
             }
 
             this.c.a(DataPaletteBlock.a);
-            this.b = new DataBits(this.e, 4096);
+            // this.b = new DataBits(this.e, 4096); // Paper
         }
     }
 
     public int a(int i, IBlockData iblockdata) {
-        DataBits databits = this.b;
+        // DataBits databits = this.b; // Paper - nope
         DataPalette datapalette = this.c;
 
         this.b(i);
 
-        for (int j = 0; j < databits.b(); ++j) {
-            IBlockData iblockdata1 = datapalette.a(databits.a(j));
+        // Paper start - DataBits -> data
+        for (int j = 0; j < 4096; ++j) {
+            IBlockData iblockdata1 = datapalette.a(data[j]);
+            // Paper end
 
             if (iblockdata1 != null) {
                 this.setBlockIndex(j, iblockdata1);
@@ -58,9 +61,14 @@ public class DataPaletteBlock implements DataPaletteExpandable {
     }
 
     protected void setBlockIndex(int i, IBlockData iblockdata) {
-        int j = this.c.a(iblockdata);
-
-        this.b.a(i, j);
+		// Paper start - performance sanity
+        /*
+         int j = this.c.a(iblockdata);
+ 
+         this.b.a(i, j);
+        */
+        data[i] = (short) Block.REGISTRY_ID.getId(iblockdata);
+        // Paper end
     }
 
     public IBlockData a(int i, int j, int k) {
@@ -68,15 +76,25 @@ public class DataPaletteBlock implements DataPaletteExpandable {
     }
 
     protected IBlockData a(int i) {
-        IBlockData iblockdata = this.c.a(this.b.a(i));
+        IBlockData iblockdata = Block.REGISTRY_ID.fromId(data[i]); // Paper - performance sanity
 
         return iblockdata == null ? DataPaletteBlock.a : iblockdata;
     }
+	
+	// Paper start - serialization method
+    public DataBits toMojangBits() {
+        DataBits bits = new DataBits(this.e, 4096);
+        for (int i = 0; i < 4096; i++) {
+            bits.a(i, this.c.a(Block.REGISTRY_ID.fromId(data[i])));
+        }
+        return bits;
+    }
+    // Paper end
 
     public void b(PacketDataSerializer packetdataserializer) {
         packetdataserializer.writeByte(this.e);
         this.c.b(packetdataserializer);
-        packetdataserializer.a(this.b.a());
+        packetdataserializer.a(toMojangBits().a()); // Paper - serialize
     }
 
     @Nullable
@@ -132,6 +150,7 @@ public class DataPaletteBlock implements DataPaletteExpandable {
     }
 
     public int a() {
-        return 1 + this.c.a() + PacketDataSerializer.a(this.b.b()) + this.b.a().length * 8;
+        return 1 + this.c.a() + PacketDataSerializer.a(this.toMojangBits().b()) + this.toMojangBits().a().length * 8;
+        // Paper end
     }
 }
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index 8d43d95..73fe093 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -805,17 +805,7 @@ public abstract class World implements IBlockAccess {
 
     // Paper start - reduces need to do isLoaded before getType
     public IBlockData getTypeIfLoaded(BlockPosition blockposition) {
-        // CraftBukkit start - tree generation
-		final int x = blockposition.getX();
-        final int y = blockposition.getY();
-        final int z = blockposition.getZ();
-        if (captureTreeGeneration) {
-            final IBlockData previous = getCapturedBlockType(x, y, z);
-            if (previous != null) {
-                return previous;
-            }
-        }
-        // CraftBukkit end
+        if (captureTreeGeneration) return findCaptured(blockposition); // use seperate findCaptured() method
         Chunk chunk = ((ChunkProviderServer) this.chunkProvider).getChunkIfLoaded(x >> 4, z >> 4);
         if (chunk != null) {
             return chunk.getBlockData(x, y, z);
@@ -824,24 +814,46 @@ public abstract class World implements IBlockAccess {
     }
     // Paper end
 
-    public IBlockData getType(BlockPosition blockposition) {
+    // Paper start - optimize getType
+    // hoist tree generation into a seperate method to assist inlining
+    public IBlockData getType(BlockPosition pos) {
+        return getType(pos, this.captureTreeGeneration);
+    }
+
+    private IBlockData findCaptured(BlockPosition blockposition) {
         // CraftBukkit start - tree generation
 		// Paper start - optimize getType lookup to reduce instructions - getBlockData already enforces valid Y, move tree out
         final int x = blockposition.getX();
         final int y = blockposition.getY();
         final int z = blockposition.getZ();
-        if (captureTreeGeneration) {
-            Iterator<BlockState> it = capturedBlockStates.iterator();
+		Iterator<BlockState> it = capturedBlockStates.iterator();
+        while (it.hasNext()) {
+			Iterator<BlockState> it = capturedBlockStates.iterator();
             final IBlockData previous = getCapturedBlockType(x, y, z);
             if (previous != null) {
                 return previous;
             }
-        }
+		}
         // CraftBukkit end
-        return this.chunkProvider.getChunkAt(x >> 4, z >> 4).getBlockData(x, y, z);
-        // Paper end
+        return getType(blockposition, captureTreeGeneration);
     }
 	
+	public IBlockData getType(BlockPosition blockposition, boolean captureTreeGeneration) {
+        if (captureTreeGeneration) {
+            // CraftBukkit end
+            return findCaptured(blockposition); // Move into seperate method to assist inlining
+         }
+        if (blockposition.isValidLocation()) { // Paper
+            Chunk chunk = this.getChunkAtWorldCoords(blockposition);
+            ChunkSection chunksection = chunk.getSections()[blockposition.getY() >> 4];
+            if (chunksection != null) {
+                return chunksection.getType(blockposition.getX() & 15, blockposition.getY() & 15, blockposition.getZ() & 15);
+            }
+        }
+        return Blocks.AIR.getBlockData();
+     }
+    // Paper end
+	
 	// Paper start
     private IBlockData getCapturedBlockType(int x, int y, int z) {
         Iterator<BlockState> it = capturedBlockStates.iterator();
-- 
2.8.2.windows.1

