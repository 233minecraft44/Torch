From 6d3e2cbd692067677ba3c8bdda4b060b387461c1 Mon Sep 17 00:00:00 2001
From: SotrForgotten <i@omc.hk>
Date: Sat, 2 Jul 2016 07:43:37 +0800
Subject: [PATCH] SPIGOT-2439: Consistently fire Chunk(Load|Unload)Event, miscs


diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java
index 39ac84f..3bb2d73 100644
--- a/src/main/java/net/minecraft/server/Chunk.java
+++ b/src/main/java/net/minecraft/server/Chunk.java
@@ -63,6 +63,7 @@ public class Chunk {
 
     // CraftBukkit start - Neighbor loaded cache for chunk lighting and entity ticking
     private int neighbors = 0x1 << 12;
+	public long chunkKey;
 
     public boolean areNeighborsLoaded(final int radius) {
         switch (radius) {
@@ -114,6 +115,7 @@ public class Chunk {
         Arrays.fill(this.g, (byte) -1);
         // CraftBukkit start
         this.bukkitChunk = new org.bukkit.craftbukkit.CraftChunk(this);
+		this.chunkKey = ChunkCoordIntPair.a(this.locX, this.locZ);
     }
 
     public org.bukkit.Chunk bukkitChunk;
@@ -905,7 +907,8 @@ public class Chunk {
                 }
             }
 
-            this.world.c((Collection) newList);
+            // this.world.c((Collection) newList);
+			this.world.c(newList);
             // CraftBukkit end
         }
 
@@ -1012,7 +1015,33 @@ public class Chunk {
         return false;
     }
 
-    public void loadNearby(IChunkProvider ichunkprovider, ChunkGenerator chunkgenerator) {
+    // CraftBukkit start
+    public void loadNearby(IChunkProvider ichunkprovider, ChunkGenerator chunkgenerator, boolean newChunk) {
+        Server server = world.getServer();
+        if (server != null) {
+            /*
+             * If it's a new world, the first few chunks are generated inside
+             * the World constructor. We can't reliably alter that, so we have
+             * no way of creating a CraftWorld/CraftServer at that point.
+             */
+            server.getPluginManager().callEvent(new org.bukkit.event.world.ChunkLoadEvent(bukkitChunk, newChunk));
+        }
+
+        // Update neighbor counts
+        for (int x = -2; x < 3; x++) {
+            for (int z = -2; z < 3; z++) {
+                if (x == 0 && z == 0) {
+                    continue;
+                }
+
+                Chunk neighbor = getWorld().getChunkIfLoaded(locX + x, locZ + z);
+                if (neighbor != null) {
+                    neighbor.setNeighborLoaded(-x, -z);
+                    setNeighborLoaded(x, z);
+                }
+            }
+        }
+        // CraftBukkit end
         world.timings.syncChunkLoadPostTimer.startTiming(); // Spigot
         Chunk chunk = MCUtil.getLoadedChunkWithoutMarkingActive(ichunkprovider,this.locX, this.locZ - 1); // Paper
         Chunk chunk1 = MCUtil.getLoadedChunkWithoutMarkingActive(ichunkprovider,this.locX + 1, this.locZ); // Paper
diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java
index 3dc17e8..1eaf02d 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java
@@ -120,7 +120,7 @@ public class ChunkProviderServer implements IChunkProvider {
             if (chunk != null) {
                 this.chunks.put(ChunkCoordIntPair.a(i, j), chunk);
                 chunk.addEntities();
-                chunk.loadNearby(this, this.chunkGenerator);
+                chunk.loadNearby(this, this.chunkGenerator, false); // CraftBukkit
             }
         }
 
@@ -189,38 +189,11 @@ public class ChunkProviderServer implements IChunkProvider {
                 crashreportsystemdetails.a("Generator", (Object) this.chunkGenerator);
                 throw new ReportedException(crashreport);
             }
-            newChunk = true; // CraftBukkit
 
             this.chunks.put(k, chunk);
             chunk.addEntities();
 
-            // CraftBukkit start
-            Server server = world.getServer();
-            if (server != null) {
-                /*
-                 * If it's a new world, the first few chunks are generated inside
-                 * the World constructor. We can't reliably alter that, so we have
-                 * no way of creating a CraftWorld/CraftServer at that point.
-                 */
-                server.getPluginManager().callEvent(new org.bukkit.event.world.ChunkLoadEvent(chunk.bukkitChunk, newChunk));
-            }
-
-            // Update neighbor counts
-            for (int x = -2; x < 3; x++) {
-                for (int z = -2; z < 3; z++) {
-                    if (x == 0 && z == 0) {
-                        continue;
-                    }
-
-                    Chunk neighbor = MCUtil.getLoadedChunkWithoutMarkingActive(this, chunk.locX + x, chunk.locZ + z); // Paper
-                    if (neighbor != null) {
-                        neighbor.setNeighborLoaded(-x, -z);
-                        chunk.setNeighborLoaded(x, z);
-                    }
-                }
-            }
-            // CraftBukkit end
-            chunk.loadNearby(this, this.chunkGenerator);
+            chunk.loadNearby(this, this.chunkGenerator, true); // CraftBukkit
             world.timings.syncChunkLoadTimer.stopTiming(); // Spigot
         }
 
@@ -319,34 +292,11 @@ public class ChunkProviderServer implements IChunkProvider {
 
                     if (chunk != null && chunk.d) {
                         chunk.setShouldUnload(false); // Paper
-                        // CraftBukkit start
-                        ChunkUnloadEvent event = new ChunkUnloadEvent(chunk.bukkitChunk);
-                        this.world.getServer().getPluginManager().callEvent(event);
-                        if (event.isCancelled()) {
+                         // CraftBukkit start - move unload logic to own method
+                        if (!unloadChunk(chunk, true)) {
                             continue;
                         }
                         chunk.lightingQueue.processUnload(); // Paper
-
-                        // Update neighbor counts
-                        for (int x = -2; x < 3; x++) {
-                            for (int z = -2; z < 3; z++) {
-                                if (x == 0 && z == 0) {
-                                    continue;
-                                }
-
-                                Chunk neighbor = MCUtil.getLoadedChunkWithoutMarkingActive(this, chunk.locX + x, chunk.locZ + z); // Paper
-                                if (neighbor != null) {
-                                    neighbor.setNeighborUnloaded(-x, -z);
-                                    chunk.setNeighborUnloaded(x, z);
-                                }
-                            }
-                        }
-                        // CraftBukkit end
-
-                        chunk.removeEntities();
-                        this.saveChunk(chunk);
-                        this.saveChunkNOP(chunk);
-                        this.chunks.remove(olong);
                         ++i;
                     }
                 }
@@ -370,6 +320,39 @@ public class ChunkProviderServer implements IChunkProvider {
 
         return false;
     }
+	
+	// CraftBukkit start
+    public boolean unloadChunk(Chunk chunk, boolean save) {
+        ChunkUnloadEvent event = new ChunkUnloadEvent(chunk.bukkitChunk);
+        this.world.getServer().getPluginManager().callEvent(event);
+        if (event.isCancelled()) {
+            return false;
+        }
+
+        // Update neighbor counts
+        for (int x = -2; x < 3; x++) {
+            for (int z = -2; z < 3; z++) {
+                if (x == 0 && z == 0) {
+                    continue;
+                }
+
+                Chunk neighbor = this.getChunkIfLoaded(chunk.locX + x, chunk.locZ + z);
+                if (neighbor != null) {
+                    neighbor.setNeighborUnloaded(-x, -z);
+                    chunk.setNeighborUnloaded(x, z);
+                }
+            }
+        }
+        // Moved from unloadChunks above
+        chunk.removeEntities();
+        if (save) {
+            this.saveChunk(chunk);
+            this.saveChunkNOP(chunk);
+        }
+        this.chunks.remove(chunk.chunkKey);
+        return true;
+    }
+    // CraftBukkit end
 
     public boolean e() {
         return !this.world.savingDisabled;
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index 71da852..ebdb03b 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -209,53 +209,25 @@ public class CraftWorld implements World {
             return false;
         }
 
-        return unloadChunk0(x, z, save, safe);
+        return unloadChunk0(x, z, save);
     }
 
-    private boolean unloadChunk0(int x, int z, boolean save, boolean safe) {
-        // Paper start - Don't create a chunk just to unload it
+    private boolean unloadChunk0(int x, int z, boolean save) {
         net.minecraft.server.Chunk chunk = world.getChunkProviderServer().getChunkIfLoaded(x, z);
         if (chunk == null) {
-            return false;
-        }
-        // Paper end
-
-        if (chunk.mustSave) {   // If chunk had previously been queued to save, must do save to avoid loss of that data
-            save = true;
-        }
-
-        chunk.removeEntities(); // Always remove entities - even if discarding, need to get them out of world table
-
-        if (save) {
-            world.getChunkProviderServer().saveChunk(chunk);
-            world.getChunkProviderServer().saveChunkNOP(chunk);
-        }
-
-        world.getChunkProviderServer().unloadQueue.remove(ChunkCoordIntPair.a(x, z));
-        world.getChunkProviderServer().chunks.remove(ChunkCoordIntPair.a(x, z));
-
-        // Update neighbor counts
-        for (int xx = -2; xx < 3; xx++) {
-            for (int zz = -2; zz < 3; zz++) {
-                if (xx == 0 && zz == 0) {
-                    continue;
-                }
-
-                net.minecraft.server.Chunk neighbor = net.minecraft.server.MCUtil.getLoadedChunkWithoutMarkingActive(world, chunk.locX + x, chunk.locZ + z); // Paper
-                if (neighbor != null) {
-                    neighbor.setNeighborUnloaded(-xx, -zz);
-                    chunk.setNeighborUnloaded(xx, zz);
-                }
-            }
-        }
-
-        return true;
+			return true;
+		}
+		// If chunk had previously been queued to save, must do save to avoid loss of that data
+        return world.getChunkProviderServer().unloadChunk(chunk, chunk.mustSave || save);
     }
 
     public boolean regenerateChunk(int x, int z) {
-        unloadChunk0(x, z, false, false);
+        if (!unloadChunk0(x, z, false)) {
+            return false;
+        }
 
-        world.getChunkProviderServer().unloadQueue.remove(ChunkCoordIntPair.a(x, z));
+        final long chunkKey = ChunkCoordIntPair.a(x, z);
+        world.getChunkProviderServer().unloadQueue.remove(chunkKey);
 
         net.minecraft.server.Chunk chunk = null;
 
@@ -265,9 +237,14 @@ public class CraftWorld implements World {
             playerChunk.chunk = chunk;
         }
 
-        chunkLoadPostProcess(chunk, x, z);
+         if (chunk != null) {
+            world.getChunkProviderServer().chunks.put(chunkKey, chunk);
+
+			chunk.addEntities();
+            chunk.loadNearby(world.getChunkProviderServer(), world.getChunkProviderServer().chunkGenerator, true);
 
-        refreshChunk(x, z);
+            refreshChunk(x, z);
+        }
 
         return chunk != null;
     }
@@ -305,42 +282,6 @@ public class CraftWorld implements World {
         }
         // Paper start - below is not updated for the new unload queue logic.
         return world.getChunkProviderServer().getOrLoadChunkAt(x, z) != null;
-        /*
-
-        world.getChunkProviderServer().unloadQueue.remove(ChunkCoordIntPair.a(x, z));
-        net.minecraft.server.Chunk chunk = world.getChunkProviderServer().chunks.get(ChunkCoordIntPair.a(x, z));
-
-        if (chunk == null) {
-            world.timings.syncChunkLoadTimer.startTiming(); // Spigot
-            chunk = world.getChunkProviderServer().getOrLoadChunkAt(x, z);
-            world.timings.syncChunkLoadTimer.stopTiming(); // Spigot
-        }
-        return chunk != null;*/ // Paper end
-    }
-
-    private void chunkLoadPostProcess(net.minecraft.server.Chunk chunk, int cx, int cz) {
-        if (chunk != null) {
-            world.getChunkProviderServer().chunks.put(ChunkCoordIntPair.a(cx, cz), chunk);
-
-            chunk.addEntities();
-
-            // Update neighbor counts
-            for (int x = -2; x < 3; x++) {
-                for (int z = -2; z < 3; z++) {
-                    if (x == 0 && z == 0) {
-                        continue;
-                    }
-
-                    net.minecraft.server.Chunk neighbor = net.minecraft.server.MCUtil.getLoadedChunkWithoutMarkingActive(world, chunk.locX + x, chunk.locZ + z); // Paper
-                    if (neighbor != null) {
-                        neighbor.setNeighborLoaded(-x, -z);
-                        chunk.setNeighborLoaded(x, z);
-                    }
-                }
-            }
-            // CraftBukkit end
-
-            chunk.loadNearby(world.getChunkProviderServer(), world.getChunkProviderServer().chunkGenerator);
         }
     }
 
@@ -362,7 +303,7 @@ public class CraftWorld implements World {
         Validate.isTrue(item.getTypeId() != 0, "Cannot drop AIR.");
         EntityItem entity = new EntityItem(world, loc.getX(), loc.getY(), loc.getZ(), CraftItemStack.asNMSCopy(item));
         entity.pickupDelay = 10;
-        world.addEntity(entity);
+        world.addEntity(entity, SpawnReason.CUSTOM); // Torch
         // TODO this is inconsistent with how Entity.getBukkitEntity() works.
         // However, this entity is not at the moment backed by a server entity class so it may be left.
         return new CraftItem(world.getServer(), entity);
diff --git a/src/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOProvider.java b/src/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOProvider.java
index 4d2b371..e5c6a1e 100644
--- a/src/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOProvider.java
+++ b/src/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOProvider.java
@@ -49,27 +49,7 @@ class ChunkIOProvider implements AsynchronousExecutor.CallBackProvider<QueuedChu
             queuedChunk.provider.world.timings.syncChunkLoadStructuresTimer.stopTiming(); // Spigot
         }
 
-        Server server = queuedChunk.provider.world.getServer();
-        if (server != null) {
-            server.getPluginManager().callEvent(new org.bukkit.event.world.ChunkLoadEvent(chunk.bukkitChunk, false));
-        }
-
-        // Update neighbor counts
-        for (int x = -2; x < 3; x++) {
-            for (int z = -2; z < 3; z++) {
-                if (x == 0 && z == 0) {
-                    continue;
-                }
-
-                Chunk neighbor = net.minecraft.server.MCUtil.getLoadedChunkWithoutMarkingActive(queuedChunk.provider, chunk.locX + x, chunk.locZ + z); // Paper
-                if (neighbor != null) {
-                    neighbor.setNeighborLoaded(-x, -z);
-                    chunk.setNeighborLoaded(x, z);
-                }
-            }
-        }
-
-        chunk.loadNearby(queuedChunk.provider, queuedChunk.provider.chunkGenerator);
+        chunk.loadNearby(queuedChunk.provider, queuedChunk.provider.chunkGenerator, false);
     }
 
     public void callStage3(QueuedChunk queuedChunk, Chunk chunk, Runnable runnable) throws RuntimeException {
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index bac36e7..12bf4e6 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -405,12 +405,10 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         getHandle().playerConnection.sendPacket(packet);
     }
 	
-	@Override
     public void stopSound(Sound sound) {
         stopSound(CraftSound.getSound(sound));
     }
 
-    @Override
     public void stopSound(String sound) {
         if (getHandle().playerConnection == null) return;
         PacketDataSerializer packetdataserializer = new PacketDataSerializer(Unpooled.buffer());
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftVillager.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftVillager.java
index 0329c26..16fe364 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftVillager.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftVillager.java
@@ -43,7 +43,7 @@ public class CraftVillager extends CraftAgeable implements Villager, InventoryHo
     }
 
     public void setProfession(Profession profession) {
-		Validate.isTrue(0 < profession.ordinal() && profession.ordinal() < Profession.HUSK.ordinal(), "This profession is reserved for Zombies: ", profession);
+		Validate.isTrue(0 < profession.getId() && profession.getId() < Profession.HUSK.getId(), "This profession is reserved for Zombies: ", profession);
         getHandle().setProfession(profession.getId() - 1);
     }
 
-- 
2.8.2.windows.1

