From 1b958563b71fa79aebe32ad6652eb29f395e0868 Mon Sep 17 00:00:00 2001
From: SotrForgotten <i@omc.hk>
Date: Sat, 2 Jul 2016 16:17:15 +0800
Subject: [PATCH] Go deeper multi threaded


diff --git a/src/main/java/net/minecraft/server/Block.java b/src/main/java/net/minecraft/server/Block.java
index 3d6f803..998622a 100644
--- a/src/main/java/net/minecraft/server/Block.java
+++ b/src/main/java/net/minecraft/server/Block.java
@@ -308,11 +308,18 @@ public class Block {
     }
 
     public void onPlace(World world, BlockPosition blockposition, IBlockData iblockdata) {
-        org.spigotmc.AsyncCatcher.catchOp( "block onPlace"); // Spigot
+        // org.spigotmc.AsyncCatcher.catchOp( "block onPlace"); // Spigot
+		if (org.spigotmc.AsyncCatcher.catchOp_flag()) { // Hose
+            System.out.println("AsyncCatcher: block onPlace " + this.getName());
+        }
     }
 
     public void remove(World world, BlockPosition blockposition, IBlockData iblockdata) {
-        org.spigotmc.AsyncCatcher.catchOp( "block remove"); // Spigot
+        // org.spigotmc.AsyncCatcher.catchOp( "block remove"); // Spigot
+		if (org.spigotmc.AsyncCatcher.catchOp_flag()) { // Hose
+            System.out.println("AsyncCatcher: block remove " + this.getName());
+            // world.addEntity(new EntityExperienceOrb(world, (double) blockposition.getX() + 0.5D, (double) blockposition.getY() + 0.5D, (double) blockposition.getZ() + 0.5D, 1));
+        }
     }
 
     public int a(Random random) {
diff --git a/src/main/java/net/minecraft/server/BlockCactus.java b/src/main/java/net/minecraft/server/BlockCactus.java
index fec2f0a..cdd5ec6 100644
--- a/src/main/java/net/minecraft/server/BlockCactus.java
+++ b/src/main/java/net/minecraft/server/BlockCactus.java
@@ -89,7 +89,7 @@ public class BlockCactus extends Block {
         return false;
     }
 
-    public void a(World world, BlockPosition blockposition, IBlockData iblockdata, Entity entity) {
+    public synchronized void a(World world, BlockPosition blockposition, IBlockData iblockdata, Entity entity) {
         CraftEventFactory.blockDamage = world.getWorld().getBlockAt(blockposition.getX(), blockposition.getY(), blockposition.getZ()); // CraftBukkit
         entity.damageEntity(DamageSource.CACTUS, 1.0F);
         CraftEventFactory.blockDamage = null; // CraftBukkit
diff --git a/src/main/java/net/minecraft/server/BlockMinecartDetector.java b/src/main/java/net/minecraft/server/BlockMinecartDetector.java
index ffa26fc..1c25171 100644
--- a/src/main/java/net/minecraft/server/BlockMinecartDetector.java
+++ b/src/main/java/net/minecraft/server/BlockMinecartDetector.java
@@ -6,6 +6,8 @@ import java.util.List;
 import java.util.Random;
 import javax.annotation.Nullable;
 
+import java.util.Queue;
+
 import org.bukkit.event.block.BlockRedstoneEvent; // CraftBukkit
 
 public class BlockMinecartDetector extends BlockMinecartTrackAbstract {
@@ -136,13 +138,15 @@ public class BlockMinecartDetector extends BlockMinecartTrackAbstract {
             List list = this.a(world, blockposition, EntityMinecartCommandBlock.class, new Predicate[0]);
 
             if (!list.isEmpty()) {
-                return ((EntityMinecartCommandBlock) list.get(0)).getCommandBlock().k();
+                Iterator it = list.iterator();
+                return ((EntityMinecartCommandBlock) it.next()).getCommandBlock().k();
             }
 
             List list1 = this.a(world, blockposition, EntityMinecartAbstract.class, new Predicate[] { IEntitySelector.c});
 
             if (!list1.isEmpty()) {
-                return Container.b((IInventory) list1.get(0));
+                Iterator it1 = list1.iterator();
+                return Container.b((IInventory) it1.next());
             }
         }
 
diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java
index 907c02d..ea8d420 100644
--- a/src/main/java/net/minecraft/server/Chunk.java
+++ b/src/main/java/net/minecraft/server/Chunk.java
@@ -20,6 +20,8 @@ import org.bukkit.Server; // CraftBukkit
 import org.bukkit.Bukkit; // Torch
 import org.bukkit.craftbukkit.util.CraftMagicNumbers;
 
+import org.hose.ChunkPopulate_Pool;
+import org.spigotmc.SpigotWorldConfig;
 import java.util.Queue;
 
 public class Chunk {
@@ -1092,7 +1094,8 @@ public class Chunk {
                 this.world.populating = true;
                 try {
                     for (org.bukkit.generator.BlockPopulator populator : world.getPopulators()) {
-                        populator.populate(world, random, bukkitChunk);
+                        ChunkPopulate_Pool task = new ChunkPopulate_Pool(world, random, bukkitChunk, populator);
+                        task.fork();
                     }
                 } finally {
                     this.world.populating = false;
diff --git a/src/main/java/net/minecraft/server/ChunkProviderHell.java b/src/main/java/net/minecraft/server/ChunkProviderHell.java
index 1420b14..e523afa 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderHell.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderHell.java
@@ -6,36 +6,36 @@ import javax.annotation.Nullable;
 
 public class ChunkProviderHell implements ChunkGenerator {
 
-    protected static final IBlockData a = Blocks.AIR.getBlockData();
-    protected static final IBlockData b = Blocks.NETHERRACK.getBlockData();
-    protected static final IBlockData c = Blocks.BEDROCK.getBlockData();
-    protected static final IBlockData d = Blocks.LAVA.getBlockData();
-    protected static final IBlockData e = Blocks.GRAVEL.getBlockData();
-    protected static final IBlockData f = Blocks.SOUL_SAND.getBlockData();
-    private final World n;
-    private final boolean o;
-    private final Random p;
-    private double[] q = new double[256];
-    private double[] r = new double[256];
-    private double[] s = new double[256];
-    private double[] t;
-    private final NoiseGeneratorOctaves u;
-    private final NoiseGeneratorOctaves v;
-    private final NoiseGeneratorOctaves w;
-    private final NoiseGeneratorOctaves x;
-    private final NoiseGeneratorOctaves y;
+     protected static final IBlockData a = Blocks.AIR.getBlockData();
+     protected static final IBlockData b = Blocks.NETHERRACK.getBlockData();
+     protected static final IBlockData c = Blocks.BEDROCK.getBlockData();
+     protected static final IBlockData d = Blocks.LAVA.getBlockData();
+     protected static final IBlockData e = Blocks.GRAVEL.getBlockData();
+     protected static final IBlockData f = Blocks.SOUL_SAND.getBlockData();
+     private final World n;
+     private final boolean o;
+     private final Random p;
+     private double[] q = new double[256];
+     private double[] r = new double[256];
+     private double[] s = new double[256];
+     private double[] t;
+     private final NoiseGeneratorOctaves u;
+     private final NoiseGeneratorOctaves v;
+     private final NoiseGeneratorOctaves w;
+     private final NoiseGeneratorOctaves x;
+     private final NoiseGeneratorOctaves y;
     public final NoiseGeneratorOctaves g;
     public final NoiseGeneratorOctaves h;
-    private final WorldGenFire z = new WorldGenFire();
-    private final WorldGenLightStone1 A = new WorldGenLightStone1();
-    private final WorldGenLightStone2 B = new WorldGenLightStone2();
-    private final WorldGenerator C;
-    private final WorldGenHellLava D;
-    private final WorldGenHellLava E;
-    private final WorldGenMushrooms F;
-    private final WorldGenMushrooms G;
-    private final WorldGenNether H;
-    private final WorldGenBase I;
+     private final WorldGenFire z = new WorldGenFire();
+     private final WorldGenLightStone1 A = new WorldGenLightStone1();
+     private final WorldGenLightStone2 B = new WorldGenLightStone2();
+     private final WorldGenerator C;
+     private final WorldGenHellLava D;
+     private final WorldGenHellLava E;
+     private final WorldGenMushrooms F;
+     private final WorldGenMushrooms G;
+     private final WorldGenNether H;
+     private final WorldGenBase I;
     double[] i;
     double[] j;
     double[] k;
@@ -149,10 +149,7 @@ public class ChunkProviderHell implements ChunkGenerator {
                 IBlockData iblockdata1 = ChunkProviderHell.b;
 
                 for (int l1 = 127; l1 >= 0; --l1) {
-                    // Paper start - Configurable flat bedrock worldgen
-                    if (l1 < 127 - (n.paperConfig.generateFlatBedrock ? 0 : this.p.nextInt(5)) &&
-                            l1 > (n.paperConfig.generateFlatBedrock ? 0 : this.p.nextInt(5))) {
-                        // Paper end
+                    if (l1 < 127 - this.p.nextInt(5) && l1 > this.p.nextInt(5)) {
                         IBlockData iblockdata2 = chunksnapshot.a(i1, l1, l);
 
                         if (iblockdata2.getBlock() != null && iblockdata2.getMaterial() != Material.AIR) {
diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java
index 3627ac0..0aca107 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java
@@ -15,15 +15,18 @@ import com.destroystokyo.paper.exception.ServerInternalException;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
-import com.google.common.collect.Maps;
-import java.util.Map;
-
 // CraftBukkit start
 import org.bukkit.Server;
 import org.bukkit.craftbukkit.chunkio.ChunkIOExecutor;
 import org.bukkit.event.world.ChunkUnloadEvent;
 // CraftBukkit end
 
+import com.google.common.collect.Maps;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.RecursiveTask;
+
 public class ChunkProviderServer implements IChunkProvider {
 
     private static final Logger a = LogManager.getLogger();
diff --git a/src/main/java/net/minecraft/server/DataWatcher.java b/src/main/java/net/minecraft/server/DataWatcher.java
index f94e9d6..56a7749 100644
--- a/src/main/java/net/minecraft/server/DataWatcher.java
+++ b/src/main/java/net/minecraft/server/DataWatcher.java
@@ -20,11 +20,11 @@ import net.techcable.tacospigot.ArrayMap;
 import net.techcable.tacospigot.NoOpReadWriteLock;
 import net.techcable.tacospigot.TacoSpigotConfig;
 import net.techcable.tacospigot.function.FunctionalMaps;
-
+import com.google.common.base.Optional;
 
 public class DataWatcher {
 
-    private static final Map<Class<? extends Entity>, Integer> a = Maps.newHashMap();
+    private static final Map<Class<? extends Entity>, Integer> a = Maps.newConcurrentMap();
     private final Entity b;
     private final Int2ObjectMap<Item<?>> c = TacoSpigotConfig.useArraysForDatawatcher ? new ArrayMap<>() : new Int2ObjectOpenHashMap<>(); // Paper // TacoSpigot - use 'Int2ObjectMap' and use 'ArrayMap' if useArraysForDatawatcher
     private final ReadWriteLock d = TacoSpigotConfig.disableDataWatcherReadLocking && TacoSpigotConfig.useArraysForDatawatcher ? NoOpReadWriteLock.INSTANCE : new ReentrantReadWriteLock(); // TacoSpigot - don't lock if we're using ArrayMap
diff --git a/src/main/java/net/minecraft/server/Entity.java b/src/main/java/net/minecraft/server/Entity.java
index 64e8b09..b28caa8 100644
--- a/src/main/java/net/minecraft/server/Entity.java
+++ b/src/main/java/net/minecraft/server/Entity.java
@@ -332,7 +332,8 @@ public abstract class Entity implements ICommandListener {
         return this.world.paperConfig.netherVoidTopDamage && this.world.getWorld().getEnvironment() == org.bukkit.World.Environment.NETHER && this.locY >= 128.0D;
     }
 
-    public void U() {
+    // public void U() {
+	public void U_hose() {
         this.world.methodProfiler.a("entityBaseTick");
         if (this.isPassenger() && this.bz().dead) {
             this.stopRiding();
@@ -430,6 +431,13 @@ public abstract class Entity implements ICommandListener {
         this.world.methodProfiler.b();
     }
 	
+	// Hose start
+	public void U() {
+        U u_task = new U();
+        u_task.fork();
+    }
+	// Hose end
+	
 	protected void checkAndDoHeightDamage() {
         if (this.locY < -64.0D || paperNetherCheck()) {
             this.kill();
@@ -1981,6 +1989,7 @@ public abstract class Entity implements ICommandListener {
         } else {
             BlockPosition.PooledBlockPosition blockposition_pooledblockposition = BlockPosition.PooledBlockPosition.s();
 
+			bp bp_task = new bp(blockposition_pooledblockposition);
             for (int i = 0; i < 8; ++i) {
                 int j = MathHelper.floor(this.locY + (double) (((float) ((i >> 0) % 2) - 0.5F) * 0.1F) + (double) this.getHeadHeight());
                 int k = MathHelper.floor(this.locX + (double) (((float) ((i >> 1) % 2) - 0.5F) * this.width * 0.8F));
@@ -1989,13 +1998,15 @@ public abstract class Entity implements ICommandListener {
                 if (blockposition_pooledblockposition.getX() != k || blockposition_pooledblockposition.getY() != j || blockposition_pooledblockposition.getZ() != l) {
                     blockposition_pooledblockposition.f(k, j, l);
                     if (this.world.getType(blockposition_pooledblockposition).getBlock().j()) {
-                        blockposition_pooledblockposition.t();
+                        // blockposition_pooledblockposition.t();
+						bp_task.fork();
                         return true;
                     }
                 }
             }
 
-            blockposition_pooledblockposition.t();
+            // blockposition_pooledblockposition.t();
+			bp_task.fork();
             return false;
         }
     }
@@ -3083,4 +3094,30 @@ public abstract class Entity implements ICommandListener {
         }
                  
     }
+	
+	class U extends RecursiveAction {
+                
+        U() {
+			
+        }
+        
+        @Override
+        protected void compute() {
+            U_hose();
+        }
+                 
+    }
+	
+	class bp extends RecursiveAction {
+        BlockPosition.PooledBlockPosition blockposition_pooledblockposition;
+        bp(BlockPosition.PooledBlockPosition blockposition_pooledblockposition) {
+            this.blockposition_pooledblockposition = blockposition_pooledblockposition;
+        }
+        
+        @Override
+        protected void compute() {
+            blockposition_pooledblockposition.t();
+        }
+                 
+    }
 }
diff --git a/src/main/java/net/minecraft/server/EntityArmorStand.java b/src/main/java/net/minecraft/server/EntityArmorStand.java
index 1691841..6059629 100644
--- a/src/main/java/net/minecraft/server/EntityArmorStand.java
+++ b/src/main/java/net/minecraft/server/EntityArmorStand.java
@@ -5,6 +5,9 @@ import java.util.Arrays;
 import java.util.List;
 import javax.annotation.Nullable;
 
+import java.util.Iterator;
+import java.util.Queue;
+
 // CraftBukkit start
 import org.bukkit.inventory.EquipmentSlot;
 import org.bukkit.craftbukkit.CraftEquipmentSlot;
@@ -292,9 +295,10 @@ public class EntityArmorStand extends EntityLiving {
     protected void co() {
         List list = this.world.getEntities(this, this.getBoundingBox(), EntityArmorStand.bw);
 
-        for (int i = 0; i < list.size(); ++i) {
-            Entity entity = (Entity) list.get(i);
-
+		Iterator it = list.iterator();
+        while (it.hasNext()) {
+            Entity entity = (Entity) it.next();
+ 
             if (this.h(entity) <= 0.2D) {
                 entity.collide(this);
             }
diff --git a/src/main/java/net/minecraft/server/EntityArrow.java b/src/main/java/net/minecraft/server/EntityArrow.java
index e298b30..5b195e9 100644
--- a/src/main/java/net/minecraft/server/EntityArrow.java
+++ b/src/main/java/net/minecraft/server/EntityArrow.java
@@ -5,6 +5,9 @@ import com.google.common.base.Predicates;
 import java.util.List;
 import javax.annotation.Nullable;
 
+import java.util.Iterator;
+import java.util.Queue;
+
 // CraftBukkit start
 import org.bukkit.entity.LivingEntity;
 import org.bukkit.event.entity.EntityCombustByEntityEvent;
@@ -380,10 +383,11 @@ public abstract class EntityArrow extends Entity implements IProjectile {
         Entity entity = null;
         List list = this.world.getEntities(this, this.getBoundingBox().a(this.motX, this.motY, this.motZ).g(1.0D), EntityArrow.f);
         double d0 = 0.0D;
-
-        for (int i = 0; i < list.size(); ++i) {
-            Entity entity1 = (Entity) list.get(i);
-
+		
+		Iterator it = list.iterator();
+        while (it.hasNext()) {
+            Entity entity1 = (Entity) it.next();
+ 
             if (entity1 != this.shooter || this.ay >= 5) {
                 AxisAlignedBB axisalignedbb = entity1.getBoundingBox().g(0.30000001192092896D);
                 MovingObjectPosition movingobjectposition = axisalignedbb.a(vec3d, vec3d1);
diff --git a/src/main/java/net/minecraft/server/EntityBoat.java b/src/main/java/net/minecraft/server/EntityBoat.java
index 4a140be..bd14f1f 100644
--- a/src/main/java/net/minecraft/server/EntityBoat.java
+++ b/src/main/java/net/minecraft/server/EntityBoat.java
@@ -5,6 +5,9 @@ import java.util.ArrayList;
 import java.util.List;
 import javax.annotation.Nullable;
 
+import java.util.Iterator;
+import java.util.Queue;
+
 // CraftBukkit start
 import org.bukkit.Location;
 import org.bukkit.entity.Vehicle;
@@ -294,9 +297,10 @@ public class EntityBoat extends Entity {
         if (!list.isEmpty()) {
             boolean flag = !this.world.isClientSide && !(this.bu() instanceof EntityHuman);
 
-            for (int j = 0; j < list.size(); ++j) {
-                Entity entity = (Entity) list.get(j);
-
+            Iterator it = list.iterator();
+            while (it.hasNext()) {
+                Entity entity = (Entity) it.next();
+ 
                 if (!entity.w(this)) {
                     if (flag && this.bv().size() < 2 && !entity.isPassenger() && entity.width < this.width && entity instanceof EntityLiving && !(entity instanceof EntityWaterAnimal) && !(entity instanceof EntityHuman)) {
                         entity.startRiding(this);
diff --git a/src/main/java/net/minecraft/server/EntityEnderDragon.java b/src/main/java/net/minecraft/server/EntityEnderDragon.java
index 86eddc8..9bbaf59 100644
--- a/src/main/java/net/minecraft/server/EntityEnderDragon.java
+++ b/src/main/java/net/minecraft/server/EntityEnderDragon.java
@@ -5,6 +5,7 @@ import java.util.List;
 import javax.annotation.Nullable;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import java.util.Queue;
 // CraftBukkit start
 import org.bukkit.event.entity.EntityExplodeEvent;
 import org.bukkit.event.entity.EntityRegainHealthEvent;
@@ -371,8 +372,9 @@ public class EntityEnderDragon extends EntityInsentient implements IComplex, IMo
     }
 
     private void b(List<Entity> list) {
-        for (int i = 0; i < list.size(); ++i) {
-            Entity entity = (Entity) list.get(i);
+        Iterator it = list.iterator();
+        while (it.hasNext()) {
+            Entity entity = (Entity) it.next();
 
             if (entity instanceof EntityLiving) {
                 entity.damageEntity(DamageSource.mobAttack(this), 10.0F);
diff --git a/src/main/java/net/minecraft/server/EntityFishingHook.java b/src/main/java/net/minecraft/server/EntityFishingHook.java
index 0e135ce..1227fe5 100644
--- a/src/main/java/net/minecraft/server/EntityFishingHook.java
+++ b/src/main/java/net/minecraft/server/EntityFishingHook.java
@@ -3,6 +3,8 @@ package net.minecraft.server;
 import java.util.Iterator;
 import java.util.List;
 
+import java.util.Queue;
+
 // CraftBukkit start
 import org.bukkit.entity.Player;
 import org.bukkit.entity.Fish;
@@ -176,9 +178,10 @@ public class EntityFishingHook extends Entity {
                 List list = this.world.getEntities(this, this.getBoundingBox().a(this.motX, this.motY, this.motZ).g(1.0D));
 
                 d5 = 0.0D;
-
-                for (int j = 0; j < list.size(); ++j) {
-                    Entity entity1 = (Entity) list.get(j);
+				
+				Iterator it = list.iterator();
+                while (it.hasNext()) {
+                    Entity entity1 = (Entity) it.next();
 
                     if (entity1.isInteractable() && (entity1 != this.owner || this.au >= 5)) {
                         AxisAlignedBB axisalignedbb = entity1.getBoundingBox().g(0.30000001192092896D);
diff --git a/src/main/java/net/minecraft/server/EntityHuman.java b/src/main/java/net/minecraft/server/EntityHuman.java
index e24c2c5..78ccaa2 100644
--- a/src/main/java/net/minecraft/server/EntityHuman.java
+++ b/src/main/java/net/minecraft/server/EntityHuman.java
@@ -11,6 +11,8 @@ import java.util.List;
 import java.util.UUID;
 import javax.annotation.Nullable;
 
+import java.util.Queue;
+
 // CraftBukkit start
 import org.bukkit.craftbukkit.entity.CraftHumanEntity;
 import org.bukkit.craftbukkit.entity.CraftItem;
@@ -395,16 +397,16 @@ public abstract class EntityHuman extends EntityLiving {
             }
 
             List list = this.world.getEntities(this, axisalignedbb);
-
-            for (int i = 0; i < list.size(); ++i) {
-                Entity entity = (Entity) list.get(i);
-
+			
+			Iterator it = list.iterator();
+            while (it.hasNext()) {
+                Entity entity = (Entity) it.next();
+ 
                 if (!entity.dead) {
                     this.c(entity);
                 }
             }
-        }
-
+		}
     }
 
     private void c(Entity entity) {
diff --git a/src/main/java/net/minecraft/server/EntityLightning.java b/src/main/java/net/minecraft/server/EntityLightning.java
index 47928d9..006f579 100644
--- a/src/main/java/net/minecraft/server/EntityLightning.java
+++ b/src/main/java/net/minecraft/server/EntityLightning.java
@@ -1,6 +1,8 @@
 package net.minecraft.server;
 
 import java.util.List;
+import java.util.Iterator;
+import java.util.Queue;
 
 import org.bukkit.craftbukkit.event.CraftEventFactory; // CraftBukkit
 
@@ -112,8 +114,9 @@ public class EntityLightning extends EntityWeather {
                 double d0 = 3.0D;
                 List list = this.world.getEntities(this, new AxisAlignedBB(this.locX - d0, this.locY - d0, this.locZ - d0, this.locX + d0, this.locY + 6.0D + d0, this.locZ + d0));
 
-                for (int i = 0; i < list.size(); ++i) {
-                    Entity entity = (Entity) list.get(i);
+                Iterator it = list.iterator();
+                while (it.hasNext()) {
+                    Entity entity = (Entity) it.next();
 
                     entity.onLightningStrike(this);
                 }
diff --git a/src/main/java/net/minecraft/server/EntityLiving.java b/src/main/java/net/minecraft/server/EntityLiving.java
index 5e77f08..d50c4b3 100644
--- a/src/main/java/net/minecraft/server/EntityLiving.java
+++ b/src/main/java/net/minecraft/server/EntityLiving.java
@@ -12,6 +12,7 @@ import javax.annotation.Nullable;
 
 import java.util.concurrent.RecursiveAction;
 import org.hose.GE_Pool;
+import java.util.Queue;
 
 // CraftBukkit start
 import java.util.ArrayList;
@@ -647,7 +648,11 @@ public abstract class EntityLiving extends Entity {
     }
 
     public void addEffect(MobEffect mobeffect) {
-        org.spigotmc.AsyncCatcher.catchOp( "effect add"); // Spigot
+        // org.spigotmc.AsyncCatcher.catchOp( "effect add"); // Spigot
+		if (org.spigotmc.AsyncCatcher.catchOp_flag()) { // HOSE
+            System.out.println("AsyncCatcher: effect add.");
+            return;
+        }
         // CraftBukkit start
         if (isTickingEffects) {
             effectsToProcess.add(mobeffect);
@@ -2020,8 +2025,9 @@ public abstract class EntityLiving extends Entity {
 
         if (!list.isEmpty()) {
             numCollisions = Math.max(0, numCollisions - world.spigotConfig.maxCollisionsPerEntity); // Spigot
-            for (int i = 0; i < list.size() && numCollisions < world.spigotConfig.maxCollisionsPerEntity; ++i) {
-                Entity entity = (Entity) list.get(i);
+            Iterator it = list.iterator();
+            while (it.hasNext()) {
+                Entity entity = (Entity) it.next();
                 // TODO better check now?
                 // CraftBukkit start - Only handle mob (non-player) collisions every other tick
                 if (entity instanceof EntityLiving && !(this instanceof EntityPlayer) && this.ticksLived % 2 == 0) {
diff --git a/src/main/java/net/minecraft/server/EntityProjectile.java b/src/main/java/net/minecraft/server/EntityProjectile.java
index 0c36bad..d2bca8a 100644
--- a/src/main/java/net/minecraft/server/EntityProjectile.java
+++ b/src/main/java/net/minecraft/server/EntityProjectile.java
@@ -3,6 +3,8 @@ package net.minecraft.server;
 import java.util.List;
 import java.util.UUID;
 import javax.annotation.Nullable;
+import java.util.Iterator;
+import java.util.Queue;
 
 public abstract class EntityProjectile extends Entity implements IProjectile {
 
@@ -120,9 +122,10 @@ public abstract class EntityProjectile extends Entity implements IProjectile {
         double d0 = 0.0D;
         boolean flag = false;
 
-        for (int i = 0; i < list.size(); ++i) {
-            Entity entity1 = (Entity) list.get(i);
-
+        Iterator it = list.iterator();
+        while (it.hasNext()) {
+            Entity entity1 = (Entity) it.next();
+ 
             if (entity1.isInteractable()) {
                 if (entity1 == this.c) {
                     flag = true;
diff --git a/src/main/java/net/minecraft/server/EntityTracker.java b/src/main/java/net/minecraft/server/EntityTracker.java
index b107f72..0973c50 100644
--- a/src/main/java/net/minecraft/server/EntityTracker.java
+++ b/src/main/java/net/minecraft/server/EntityTracker.java
@@ -101,7 +101,11 @@ public class EntityTracker {
     }
 
     public void addEntity(Entity entity, int i, final int j, boolean flag) {
-        org.spigotmc.AsyncCatcher.catchOp( "entity track"); // Spigot
+        // org.spigotmc.AsyncCatcher.catchOp( "entity track"); // Spigot
+		if (org.spigotmc.AsyncCatcher.catchOp_flag()) { // HOSE
+            System.out.println("AsyncCatcher: entity track.");
+            return;
+        }
         i = org.spigotmc.TrackingRange.getEntityTrackingRange(entity, i); // Spigot
         try {
             if (this.trackedEntities.b(entity.getId())) {
diff --git a/src/main/java/net/minecraft/server/EntityZombie.java b/src/main/java/net/minecraft/server/EntityZombie.java
index 0aeda93..09b1902 100644
--- a/src/main/java/net/minecraft/server/EntityZombie.java
+++ b/src/main/java/net/minecraft/server/EntityZombie.java
@@ -5,6 +5,9 @@ import java.util.List;
 import java.util.UUID;
 import javax.annotation.Nullable;
 
+import java.util.Iterator;
+import java.util.Queue;
+
 //CraftBukkit start
 import org.bukkit.event.entity.CreatureSpawnEvent;
 import org.bukkit.event.entity.EntityCombustByEntityEvent;
@@ -392,8 +395,10 @@ public class EntityZombie extends EntityMonster {
                 if ((double) this.world.random.nextFloat() < 0.05D) {
                     List list = this.world.a(EntityChicken.class, this.getBoundingBox().grow(5.0D, 3.0D, 5.0D), IEntitySelector.b);
 
+					Iterator it = list.iterator();
                     if (!list.isEmpty()) {
-                        EntityChicken entitychicken = (EntityChicken) list.get(0);
+                        // EntityChicken entitychicken = (EntityChicken) list.get(0);
+						EntityChicken entitychicken = (EntityChicken) it.next();
 
                         entitychicken.o(true);
                         this.startRiding(entitychicken);
diff --git a/src/main/java/net/minecraft/server/Explosion.java b/src/main/java/net/minecraft/server/Explosion.java
index 275e044..e551f33 100644
--- a/src/main/java/net/minecraft/server/Explosion.java
+++ b/src/main/java/net/minecraft/server/Explosion.java
@@ -9,6 +9,8 @@ import java.util.List;
 import java.util.Map;
 import java.util.Random;
 
+import java.util.Queue;
+
 // CraftBukkit start
 import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.event.entity.EntityExplodeEvent;
@@ -112,9 +114,10 @@ public class Explosion {
         });
         // Paper end
         Vec3D vec3d = new Vec3D(this.posX, this.posY, this.posZ);
-
-        for (int l1 = 0; l1 < list.size(); ++l1) {
-            Entity entity = (Entity) list.get(l1);
+		
+		Iterator it = list.iterator();
+        while (it.hasNext()) {
+            Entity entity = (Entity) it.next();
 
             if (!entity.br()) {
                 double d7 = entity.f(this.posX, this.posY, this.posZ) / (double) f3;
@@ -129,7 +132,7 @@ public class Explosion {
                         d8 /= d11;
                         d9 /= d11;
                         d10 /= d11;
-                        double d12 = this.getBlockDensity(vec3d, entity.getBoundingBox()); // Paper - Optimize explosions
+                        double d12 = (double) this.world.a(vec3d, entity.getBoundingBox());
                         double d13 = (1.0D - d7) * d12;
 
                         // CraftBukkit start
@@ -145,22 +148,16 @@ public class Explosion {
                         double d14 = 1.0D;
 
                         if (entity instanceof EntityLiving) {
-                            d14 = entity instanceof EntityHuman && world.paperConfig.disableExplosionKnockback ? 0 : EnchantmentProtection.a((EntityLiving) entity, d13); // Paper - Disable explosion knockback
+                            d14 = EnchantmentProtection.a((EntityLiving) entity, d13);
                         }
 
-                        // Paper start - Fix cannons
-                        /*
-                         entity.motX += d8 * d14;
-                         entity.motY += d9 * d14;
-                         entity.motZ += d10 * d14;
-                          */
-                        // This impulse method sets the dirty flag, so clients will get an immediate velocity update
-                        entity.addVelocity(d8 * d14, d9 * d14, d10 * d14);
-                        // Paper end
+                        entity.motX += d8 * d14;
+                        entity.motY += d9 * d14;
+                        entity.motZ += d10 * d14;
                         if (entity instanceof EntityHuman) {
                             EntityHuman entityhuman = (EntityHuman) entity;
 
-                            if (!entityhuman.isSpectator() && (!entityhuman.l_() && !world.paperConfig.disableExplosionKnockback|| !entityhuman.abilities.isFlying)) { // Paper - Disable explosion knockback
+                            if (!entityhuman.isSpectator() && (!entityhuman.l_() || !entityhuman.abilities.isFlying)) {
                                 this.k.put(entityhuman, new Vec3D(d8 * d13, d9 * d13, d10 * d13));
                             }
                         }
diff --git a/src/main/java/net/minecraft/server/ItemArmor.java b/src/main/java/net/minecraft/server/ItemArmor.java
index 352adfb..edf20b5 100644
--- a/src/main/java/net/minecraft/server/ItemArmor.java
+++ b/src/main/java/net/minecraft/server/ItemArmor.java
@@ -5,6 +5,9 @@ import com.google.common.collect.Multimap;
 import java.util.List;
 import java.util.UUID;
 
+import java.util.Iterator;
+import java.util.Queue;
+
 // CraftBukkit start
 import org.bukkit.craftbukkit.inventory.CraftItemStack;
 import org.bukkit.event.block.BlockDispenseEvent;
@@ -36,10 +39,12 @@ public class ItemArmor extends Item {
         AxisAlignedBB axisalignedbb = new AxisAlignedBB((double) i, (double) j, (double) k, (double) (i + 1), (double) (j + 1), (double) (k + 1));
         List list = isourceblock.getWorld().a(EntityLiving.class, axisalignedbb, Predicates.and(IEntitySelector.e, new IEntitySelector.EntitySelectorEquipable(itemstack)));
 
+		Iterator it = list.iterator();
         if (list.isEmpty()) {
             return null;
         } else {
-            EntityLiving entityliving = (EntityLiving) list.get(0);
+            // EntityLiving entityliving = (EntityLiving) list.get(0);
+			EntityLiving entityliving = (EntityLiving) it.next();
             EnumItemSlot enumitemslot = EntityInsentient.d(itemstack);
             // CraftBukkit start
             ItemStack itemstack1 = itemstack.cloneAndSubtract(1);
diff --git a/src/main/java/net/minecraft/server/ItemBoat.java b/src/main/java/net/minecraft/server/ItemBoat.java
index 166aa5c..54d18b1 100644
--- a/src/main/java/net/minecraft/server/ItemBoat.java
+++ b/src/main/java/net/minecraft/server/ItemBoat.java
@@ -1,6 +1,8 @@
 package net.minecraft.server;
 
+import java.util.Iterator;
 import java.util.List;
+import java.util.Queue;
 
 public class ItemBoat extends Item {
 
@@ -38,8 +40,9 @@ public class ItemBoat extends Item {
             boolean flag = false;
             List list = world.getEntities(entityhuman, entityhuman.getBoundingBox().a(vec3d2.x * d3, vec3d2.y * d3, vec3d2.z * d3).g(1.0D));
 
-            for (int i = 0; i < list.size(); ++i) {
-                Entity entity = (Entity) list.get(i);
+			Iterator it = list.iterator();
+            while (it.hasNext()) {
+                 Entity entity = (Entity) it.next();
 
                 if (entity.isInteractable()) {
                     AxisAlignedBB axisalignedbb = entity.getBoundingBox().g((double) entity.aA());
diff --git a/src/main/java/net/minecraft/server/PathEntity.java b/src/main/java/net/minecraft/server/PathEntity.java
new file mode 100644
index 0000000..0ea5506
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PathEntity.java
@@ -0,0 +1,91 @@
+package net.minecraft.server;
+
+public class PathEntity {
+
+    private final PathPoint[] a;
+    private PathPoint[] b = new PathPoint[0];
+    private PathPoint[] c = new PathPoint[0];
+    private int e;
+    private int f;
+
+    public PathEntity(PathPoint[] apathpoint) {
+        this.a = apathpoint;
+        this.f = apathpoint.length;
+    }
+
+    public void a() {
+        ++this.e;
+    }
+
+    public boolean b() {
+        return this.e >= this.f;
+    }
+
+    public PathPoint c() {
+        return this.f > 0 ? this.a[this.f - 1] : null;
+    }
+
+    public PathPoint a(int i) {
+        return this.a[i];
+    }
+
+    public void a(int i, PathPoint pathpoint) {
+        this.a[i] = pathpoint;
+    }
+
+    public int d() {
+        return this.f;
+    }
+
+    public void b(int i) {
+        this.f = i;
+    }
+
+    public int e() {
+        return this.e;
+    }
+
+    public void c(int i) {
+        this.e = i;
+    }
+
+    public Vec3D a(Entity entity, int i) {
+        double d0 = (double) this.a[i].a + (double) ((int) (entity.width + 1.0F)) * 0.5D;
+        double d1 = (double) this.a[i].b;
+        double d2 = (double) this.a[i].c + (double) ((int) (entity.width + 1.0F)) * 0.5D;
+
+        return new Vec3D(d0, d1, d2);
+    }
+
+    public Vec3D a(Entity entity) {
+        return this.a(entity, this.e);
+    }
+
+    public Vec3D f() {
+        PathPoint pathpoint = this.a[this.e];
+
+        return new Vec3D((double) pathpoint.a, (double) pathpoint.b, (double) pathpoint.c);
+    }
+
+    public boolean a(PathEntity pathentity) {
+        if (pathentity == null) {
+            return false;
+        } else if (pathentity.a.length != this.a.length) {
+            return false;
+        } else {
+            for (int i = 0; i < this.a.length; ++i) {
+                if (this.a[i].a != pathentity.a[i].a || this.a[i].b != pathentity.a[i].b || this.a[i].c != pathentity.a[i].c) {
+                    return false;
+                }
+            }
+
+            return true;
+        }
+    }
+
+    public boolean b(Vec3D vec3d) {
+        PathPoint pathpoint = this.c();
+
+        return pathpoint == null ? false : pathpoint.a == (int) vec3d.x && pathpoint.c == (int) vec3d.z;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/net/minecraft/server/StructureGenerator.java b/src/main/java/net/minecraft/server/StructureGenerator.java
index 4b7e34c..8b6294e 100644
--- a/src/main/java/net/minecraft/server/StructureGenerator.java
+++ b/src/main/java/net/minecraft/server/StructureGenerator.java
@@ -6,6 +6,8 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.Random;
 
+import java.util.concurrent.RecursiveAction;
+
 public abstract class StructureGenerator extends WorldGenBase {
 
     private PersistentStructure a;
@@ -81,7 +83,9 @@ public abstract class StructureGenerator extends WorldGenBase {
                 structurestart.a(world, random, new StructureBoundingBox(i, j, i + 15, j + 15));
                 structurestart.b(chunkcoordintpair);
                 flag = true;
-                this.a(structurestart.e(), structurestart.f(), structurestart);
+                // this.a(structurestart.e(), structurestart.f(), structurestart);
+				structure str_task = new structure(this, structurestart.e(), structurestart.f(), structurestart);
+                str_task.fork();
             }
         }
 
@@ -243,4 +247,23 @@ public abstract class StructureGenerator extends WorldGenBase {
     protected abstract boolean a(int i, int j);
 
     protected abstract StructureStart b(int i, int j);
+	
+	class structure extends RecursiveAction {
+        int i, j;
+        StructureStart structurestart;
+        StructureGenerator sg;
+        
+        structure(StructureGenerator sg, int i, int j, StructureStart structurestart) {
+            this.sg = sg;
+            this.i = i;
+            this.j = j;
+            this.structurestart = structurestart;
+        }
+        
+        @Override
+        protected void compute() {
+            sg.a(structurestart.e(), structurestart.f(), structurestart);
+        }
+                 
+    }
 }
diff --git a/src/main/java/net/minecraft/server/SystemUtils.java b/src/main/java/net/minecraft/server/SystemUtils.java
new file mode 100644
index 0000000..aa3645f
--- /dev/null
+++ b/src/main/java/net/minecraft/server/SystemUtils.java
@@ -0,0 +1,28 @@
+package net.minecraft.server;
+
+import java.util.List;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.FutureTask;
+import javax.annotation.Nullable;
+import org.apache.logging.log4j.Logger;
+
+public class SystemUtils {
+
+    @Nullable
+    public static <V> V a(FutureTask<V> futuretask, Logger logger) {
+        try {
+            futuretask.run();
+            return futuretask.get();
+        } catch (ExecutionException executionexception) {
+            logger.fatal("Error executing task", executionexception);
+        } catch (InterruptedException interruptedexception) {
+            logger.fatal("Error executing task", interruptedexception);
+        }
+
+        return null;
+    }
+
+    public static <T> T a(List<T> list) {
+        return list.get(list.size() - 1);
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index 5541fe7..b11d273 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -15,6 +15,7 @@ import java.util.List;
 import java.util.Random;
 import java.util.UUID;
 import javax.annotation.Nullable;
+import java.util.concurrent.RecursiveTask;
 
 // CraftBukkit start
 import com.google.common.collect.Maps;
@@ -328,6 +329,10 @@ public abstract class World implements IBlockAccess {
     }
 
     private boolean isAreaLoaded(int i, int j, int k, int l, int i1, int j1, boolean flag) {
+		area_load ar_task = new area_load(this, i, j, k, l, i1, j1, flag);
+        ar_task.fork();
+        return ar_task.join();
+		/*
         if (i1 >= 0 && j < 256) {
             i >>= 4;
             k >>= 4;
@@ -346,6 +351,7 @@ public abstract class World implements IBlockAccess {
         } else {
             return false;
         }
+		*/
     }
 
     protected abstract boolean isChunkLoaded(int i, int j, boolean flag);
@@ -1042,8 +1048,11 @@ public abstract class World implements IBlockAccess {
         return addEntity(entity, SpawnReason.DEFAULT);
     }
 
-    public boolean addEntity(Entity entity, SpawnReason spawnReason) { // Changed signature, added SpawnReason
+    public synchronized boolean addEntity(Entity entity, SpawnReason spawnReason) { // Changed signature, added SpawnReason
         // org.spigotmc.AsyncCatcher.catchOp( "entity add"); // Spigot
+		if (org.spigotmc.AsyncCatcher.catchOp_flag()) { // HOSE
+            entity = null;
+        }
         if (entity == null) return false;
 		if (entity.valid) { MinecraftServer.LOGGER.error("Attempted Double World add on " + entity, new Throwable()); return true; } // Paper
         // CraftBukkit end
@@ -1261,8 +1270,9 @@ public abstract class World implements IBlockAccess {
             if (entity instanceof EntityArmorStand) return arraylist; // TacoSpigot - Optimize armor stand movement
             List list = this.getEntities(entity, axisalignedbb.g(0.25D));
 
-            for (k1 = 0; k1 < list.size(); ++k1) {
-                Entity entity1 = (Entity) list.get(k1);
+            Iterator it = list.iterator();
+            while (it.hasNext()) {
+                Entity entity1 = (Entity) it.next();
 
                 if (!entity.x(entity1)) {
                     AxisAlignedBB axisalignedbb1 = entity1.af();
@@ -1872,6 +1882,24 @@ public abstract class World implements IBlockAccess {
     public boolean a(AxisAlignedBB axisalignedbb, @Nullable Entity entity) {
         List list = this.getEntities((Entity) null, axisalignedbb);
 
+		Iterator it = list.iterator();
+        while (it.hasNext()) {
+            Entity entity1 = (Entity) it.next();
+ 
+            // Paper start - Allow block placement if the placer cannot see the vanished blocker
+            if (entity instanceof EntityPlayer && entity1 instanceof EntityPlayer) {
+                if (!((EntityPlayer) entity).getBukkitEntity().canSee(((EntityPlayer) entity1).getBukkitEntity())) {
+                    continue;
+                }
+            }
+            // Paper end
+
+            if (!entity1.dead && entity1.i && entity1 != entity && (entity == null || entity1.x(entity))) {
+                return false;
+            }
+        }
+		
+		/*
         for (int i = 0; i < list.size(); ++i) {
             Entity entity1 = (Entity) list.get(i);
 
@@ -1887,6 +1915,7 @@ public abstract class World implements IBlockAccess {
                 return false;
             }
         }
+		*/
 
         return true;
     }
@@ -2675,7 +2704,10 @@ public abstract class World implements IBlockAccess {
         for (int i1 = i; i1 <= j; ++i1) {
             for (int j1 = k; j1 <= l; ++j1) {
                 if (this.isChunkLoaded(i1, j1, true)) {
-                    this.getChunkAt(i1, j1).a(entity, axisalignedbb, arraylist, predicate);
+                    // this.getChunkAt(i1, j1).a(entity, axisalignedbb, arraylist, predicate);
+					get_en en_task = new get_en(this, entity, axisalignedbb, predicate, i1, j1, arraylist);
+                    en_task.fork();
+                    en_task.join();
                 }
             }
         }
@@ -2741,12 +2773,13 @@ public abstract class World implements IBlockAccess {
         Entity entity = null;
         double d0 = Double.MAX_VALUE;
 
-        for (int i = 0; i < list.size(); ++i) {
-            Entity entity1 = (Entity) list.get(i);
+        Iterator it = list.iterator();
+        while (it.hasNext()) {
+            Entity entity1 = (Entity) it.next();
 
             if (entity1 != t0 && IEntitySelector.e.apply(entity1)) {
                 double d1 = t0.h(entity1);
-
+ 
                 if (d1 <= d0) {
                     entity = entity1;
                     d0 = d1;
@@ -3378,4 +3411,69 @@ public abstract class World implements IBlockAccess {
         }
     }
 	
+	class get_en extends RecursiveAction {
+        World world;
+        @Nullable Entity entity;
+        AxisAlignedBB axisalignedbb;
+        @Nullable Predicate<? super Entity> predicate;
+        int i1, j1;
+        ArrayList arraylist;
+        
+        get_en(World world, @Nullable Entity entity, AxisAlignedBB axisalignedbb, @Nullable Predicate<? super Entity> predicate, int i1, int j1, ArrayList arraylist) {
+            this.world = world;
+            this.entity = entity;
+            this.axisalignedbb = axisalignedbb;
+            this.predicate = predicate;
+            this.i1 = i1;
+            this.j1 = j1;
+            this.arraylist = arraylist;
+        }
+        
+        @Override
+        protected void compute() {
+            world.getChunkAt(i1, j1).a(entity, axisalignedbb, arraylist, predicate);
+        }
+                 
+    }
+    
+    class area_load extends RecursiveTask<Boolean> {
+        World world;
+        int i, j, k, l, i1, j1;
+        boolean flag;
+                
+        area_load(World world, int i, int j, int k, int l, int i1, int j1, boolean flag) {
+            this.i = i;
+            this.j = j;
+            this.k = k;
+            this.l = l;
+            this.i1 = i1;
+            this.j1 = j1;
+            this.flag = flag;
+            this.world = world;
+        }
+        
+        @Override
+        protected Boolean compute() {
+            if (i1 >= 0 && j < 256) {
+                i >>= 4;
+                k >>= 4;
+                l >>= 4;
+                j1 >>= 4;
+
+                for (int k1 = i; k1 <= l; ++k1) {
+                    for (int l1 = k; l1 <= j1; ++l1) {
+                        if (!world.isChunkLoaded(k1, l1, flag)) {
+                            return false;
+                        }
+                    }
+                }
+
+                return true;
+            } else {
+                return false;
+            }
+        }
+                 
+    }
+	
 }
diff --git a/src/main/java/net/minecraft/server/WorldServer.java b/src/main/java/net/minecraft/server/WorldServer.java
index c5cecc9..11c4913 100644
--- a/src/main/java/net/minecraft/server/WorldServer.java
+++ b/src/main/java/net/minecraft/server/WorldServer.java
@@ -22,6 +22,7 @@ import org.apache.logging.log4j.Logger;
 import com.google.common.collect.Queues;
 import java.util.Queue;
 import java.util.concurrent.RecursiveAction;
+import java.util.concurrent.ConcurrentLinkedQueue;
 
 // CraftBukkit start
 import java.util.logging.Level;
@@ -555,7 +556,9 @@ public class WorldServer extends World implements IAsyncTaskHandler {
         });
 
         if (!list.isEmpty()) {
-            return ((EntityLiving) list.get(this.random.nextInt(list.size()))).getChunkCoordinates();
+            // return ((EntityLiving) list.get(this.random.nextInt(list.size()))).getChunkCoordinates();
+			List llll = new ArrayList(list);
+            return ((EntityLiving) llll.get(this.random.nextInt(list.size()))).getChunkCoordinates();
         } else {
             if (blockposition1.getY() == -1) {
                 blockposition1 = blockposition1.up(2);
diff --git a/src/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java b/src/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java
index d338740..6aad6d6 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java
@@ -123,7 +123,7 @@ public class HashTreeSet<V> implements Set<V> {
         tree.clear();
     }
 
-    public V first() {
+    public synchronized V first() { // Hose
         return tree.first();
     }
 	
diff --git a/src/main/java/org/spigotmc/ActivationRange.java b/src/main/java/org/spigotmc/ActivationRange.java
index d767f7e..0907a69 100644
--- a/src/main/java/org/spigotmc/ActivationRange.java
+++ b/src/main/java/org/spigotmc/ActivationRange.java
@@ -2,6 +2,7 @@ package org.spigotmc;
 
 import java.util.List;
 import java.util.Set;
+import java.util.concurrent.RecursiveAction;
 
 import co.aikar.timings.MinecraftTimings;
 import net.minecraft.server.AxisAlignedBB;
@@ -132,7 +133,9 @@ public class ActivationRange
                 {
                     if ( (chunk = MCUtil.getLoadedChunkWithoutMarkingActive(world, i1, j1 )) != null ) // Paper
                     {
-                        activateChunkEntities( chunk ); // Paper
+                        // activateChunkEntities( chunk ); // Paper
+						active_en en_task = new active_en( chunk );
+                        en_task.fork();
                     }
                 }
             }
@@ -287,4 +290,19 @@ public class ActivationRange
         }
         return isActive;
     }
+	
+	static class active_en extends RecursiveAction {
+        Chunk chunk;
+                
+        active_en (Chunk chunk) {
+            //this.chunks = chunks;
+            this.chunk = chunk;
+        }
+        
+        @Override
+        protected void compute() {
+            activateChunkEntities(chunk);
+        }
+                 
+    }
 }
diff --git a/src/main/java/org/spigotmc/AsyncCatcher.java b/src/main/java/org/spigotmc/AsyncCatcher.java
index 8475d3d..2c68cd1 100644
--- a/src/main/java/org/spigotmc/AsyncCatcher.java
+++ b/src/main/java/org/spigotmc/AsyncCatcher.java
@@ -45,4 +45,16 @@ public class AsyncCatcher
         };
     }
     // TacoSpigot end
+	
+	// Hose
+    public static boolean catchOp_flag()
+    {
+        if ( enabled && Thread.currentThread() != MinecraftServer.getServer().primaryThread )
+        {
+            //return true;
+            MinecraftServer.getServer().postToMainThread(Thread.currentThread());
+            System.out.println("post to main thread");
+        }
+        return false;
+    }
 }
-- 
2.8.2.windows.1

