From 7dd215b6150bfb7ab90756f2aee9404a532d0684 Mon Sep 17 00:00:00 2001
From: SotrForgotten <i@omc.hk>
Date: Wed, 24 Aug 2016 13:15:14 +0800
Subject: [PATCH] Anti corrupt chunks


diff --git a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
index 6713f74..c9bc5ab 100644
--- a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
+++ b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
@@ -452,41 +452,26 @@ public class PaperWorldConfig {
 	}
 
 	public boolean antiXray;
-	public int engineMode;
-	public List<Object> hiddenBlocks;
-	public List<Object> replaceBlocks;
-	public int maxChunkY;
-	public boolean asynchronous;
-	public int neighborsMode;
-	public AntiXray antiXrayInstance;
-
-	private void antiXray() {
-		antiXray = getBoolean("anti-xray.enabled", false);
-		log("Anti X-Ray: " + antiXray);
-		engineMode = getInt("anti-xray.engine-mode", 3);
-		log("\tEngine Mode: " + engineMode + " ("
-				+ (engineMode == 1 ? "hidden ores"
-						: engineMode == 2 ? "fake ores" : engineMode == 3 ? "fake ores every third block" : "unknown")
-				+ ")");
-		hiddenBlocks = getList("anti-xray.hide-blocks",
-				Arrays.asList(new Object[] { "gold_ore", "iron_ore", "coal_ore", "lapis_ore", "mossy_cobblestone",
-						"obsidian", "chest", "diamond_ore", "redstone_ore", "lit_redstone_ore", "clay", "emerald_ore",
-						"ender_chest" }));
-		log("\tHidden Blocks: " + hiddenBlocks);
-		replaceBlocks = getList("anti-xray.replace-blocks", Arrays.asList(new Object[] { "stone", "planks" }));
-		log("\tReplace Blocks: " + replaceBlocks + " (for engine mode 2 and 3)");
-		maxChunkY = getInt("anti-xray.max-chunk-y", 3);
-		log("\tMax Chunk Y: " + maxChunkY + " (obfuscate up to " + ((maxChunkY + 1) * 16) + " blocks)");
-		asynchronous = getBoolean("anti-xray.asynchronous", false);
-		log("\tAsynchronous: " + asynchronous);
-		neighborsMode = getInt("anti-xray.neighbors-mode", 2);
-		log("\tNeighbors Mode: " + neighborsMode + " ("
-				+ (neighborsMode == 1 ? "MC default, sometimes the edges of chunks can't be obfuscated"
-						: neighborsMode == 2 ? "wait until neighbor chunks are loaded"
-								: neighborsMode == 3 ? "load neighbor chunks" : "unknown")
-				+ ")");
-		antiXrayInstance = new AntiXray(this);
-	}
+    public boolean asynchronous;
+    public int engineMode;
+    public int neighborsMode;
+    public int maxChunkY;
+    public List<Object> hiddenBlocks;
+    public List<Object> replaceBlocks;
+    private void antiXray() {
+        antiXray = getBoolean("anti-xray.enabled", false);
+        asynchronous = getBoolean("anti-xray.asynchronous", false);
+        engineMode = getInt("anti-xray.engine-mode", 3);
+        neighborsMode = getInt("anti-xray.neighbors-mode", 1);
+        maxChunkY = getInt("anti-xray.max-chunk-y", 3);
+        hiddenBlocks = getList("anti-xray.hide-blocks", Arrays.asList(new Object[] {
+            "gold_ore", "iron_ore", "coal_ore", "lapis_ore", "mossy_cobblestone", "obsidian", "chest", "diamond_ore", "redstone_ore", "lit_redstone_ore", "clay", "emerald_ore", "ender_chest"
+        }));
+        replaceBlocks = getList("anti-xray.replace-blocks", Arrays.asList(new Object[] {
+            "stone", "planks"
+        }));
+        log("Anti-Xray: " + (antiXray ? "enabled" : "disabled") + " / Engine Mode: " + engineMode + " / Neighbors Mode: " + neighborsMode + " / Obfuscating up to " + ((maxChunkY + 1) * 16) + " blocks");
+    }
 
 	public boolean isHopperPushBased;
 
diff --git a/src/main/java/com/destroystokyo/paper/antixray/BlockPacketController.java b/src/main/java/com/destroystokyo/paper/antixray/BlockPacketController.java
new file mode 100644
index 0000000..8a0f154
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/antixray/BlockPacketController.java
@@ -0,0 +1,152 @@
+package com.destroystokyo.paper.antixray;
+
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.Chunk;
+import net.minecraft.server.DataBits;
+import net.minecraft.server.DataPaletteBlock;
+import net.minecraft.server.IBlockData;
+import net.minecraft.server.PacketPlayOutMapChunk;
+import net.minecraft.server.PacketDataSerializer;
+import net.minecraft.server.World;
+
+/**
+ * BlockPacketController is the default (vanilla) implementation of the interface IBlockPacketController.
+ * The singleton instance should be used.
+ */
+public class BlockPacketController implements IBlockPacketController {
+
+    private static BlockPacketController instance = null;
+    private final Lock noOpLock;
+
+    /**
+     * Protected constructor for invocation by subclass constructors.
+     * Direct invocation is prevented because of the singleton pattern.
+     */
+    protected BlockPacketController() {
+        noOpLock = Lock.getNoOpInstance();
+    }
+
+    /**
+     * Protected constructor for invocation by subclass constructors.
+     * Direct invocation is prevented because of the singleton pattern.
+     * Use this constructor to prevent unnecessary intantiation of the Lock singleton
+     * incase of overriding getChunkBlocksLock(Chunk chunk) and getChunkDataLock(Chunk chunk).
+     *
+     * @param lock The lock instance used by this instance
+     */
+    protected BlockPacketController(Lock lock) {
+        noOpLock = lock;
+    }
+
+    /**
+     * Thread-safe (synchronized) singleton getter.
+     *
+     * @return The singleton instance of this implementation of IBlockPacketController
+     */
+    public static synchronized BlockPacketController getInstance() {
+        if (instance == null) {
+            instance = new BlockPacketController();
+        }
+
+        return instance;
+    }
+
+    /**
+     * Returns an instance of a Lock implementation used by the specified chunk to lock blocks or chunk sections from modification.
+     * This implementation returns the singleton Lock.getNoOpInstance().
+     *
+     * @param chunk The chunk which needs the lock
+     * @return The singleton Lock.getNoOpInstance()
+     */
+    @Override
+    public Lock getChunkBlocksLock(Chunk chunk) {
+        return noOpLock;
+    }
+
+    /**
+     * Returns an instance of a Lock implementation used by the specified chunk to lock chunk data (everything that is needed to create the packet) from modification.
+     * This implementation returns the singleton Lock.getNoOpInstance().
+     *
+     * @param chunk The chunk which needs the lock
+     * @return The singleton Lock.getNoOpInstance()
+     */
+    @Override
+    public Lock getChunkDataLock(Chunk chunk) {
+        return noOpLock;
+    }
+
+    /**
+     * Called when a new chunk section is created.
+     * Returns an array of predefined block data for the DataPaletteBlock of the specified chunk section or null if there is no block data.
+     * This implementation does nothing and will always return null.
+     *
+     * @param chunk The chunk which contains the chunk section
+     * @param chunkY The y-coordinate of the chunk section from 0 to 15
+     * @return null
+     */
+    @Override
+    public IBlockData[] getPredefinedBlockData(Chunk chunk, int chunkY) {
+        return null;
+    }
+
+    /**
+     * Called before the server attempts to create and send a PacketPlayOutMapChunk for the specified chunk (not for chunk updates).
+     * Returns false if and only if the packet should not be created now.
+     * In this case the chunk remains in the PlayerChunkMap and this method is called again later until this method returns true or the chunk is unloaded.
+     * This implementation does nothing and will always return true.
+     *
+     * @param chunk The chunk which the packet is created for
+     * @param chunkSectionSelector The chunk sections which should be sent (each bit represents for one chunk section, the LSB represents the lowest chunk section, 0 = don't send, 1 = send)
+     * @return true
+     */
+    @Override
+    public boolean onPacketCreate(Chunk chunk, int chunkSectionSelector) {
+        return true;
+    }
+
+    /**
+     * Called when packetPlayOutMapChunk is created and the data of chunk should be written to packetDataSerializer.
+     * This method is called instead of packetPlayOutMapChunk.a(packetDataSerializer, chunk, writeSkyLightArray, chunkSectionSelector, nearbyChunks).
+     * This implementation is equal to the vanilla code.
+     *
+     * @param packetPlayOutMapChunk The packet which is created
+     * @param packetDataSerializer The data serializer of the specified packet
+     * @param chunk The chunk which the packet is created for and should be written to the data serializer
+     * @param writeSkyLightArray Whether or not the sky light array should be written to the data serializer
+     * @param chunkSectionSelector The chunk sections which should be sent (each bit represents for one chunk section, the LSB represents the lowest chunk section, 0 = don't send, 1 = send)
+     */
+    @Override
+    public void createPacket(PacketPlayOutMapChunk packetPlayOutMapChunk, PacketDataSerializer packetDataSerializer, Chunk chunk, boolean writeSkyLightArray, int chunkSectionSelector) {
+        packetPlayOutMapChunk.setWrittenChunkSections(packetPlayOutMapChunk.a(packetDataSerializer, chunk, writeSkyLightArray, chunkSectionSelector, null));
+        packetPlayOutMapChunk.setReady(true);
+    }
+
+    /**
+     * Called when a PacketPlayOutMapChunk is created and the blocks of the specified chunk section should be written to packetDataSerializer.
+     * This method is called instead of packetDataSerializer.a(dataBits.a()).
+     * This implementation is equal to the vanilla code.
+     *
+     * @param packetDataSerializer The data serializer of the created packet
+     * @param chunk The chunk which the packet is created for and contains the chunk section
+     * @param chunkY The y-coordinate of the chunk section from 0 to 15
+     * @param dataPaletteBlock The data palette for the blocks of the specified chunk section
+     * @param dataBits The dataBits of the blocks
+     * @param nearbyChunks An array with the length of 4 containing the chunks around the specified chunk or null if not loaded used for thread-safe chunk access (index 0 = x--, 1 = x++, 2 = z--, 3 = z++)
+     */
+    @Override
+    public void writeBlocks(PacketDataSerializer packetDataSerializer, Chunk chunk, int chunkY, DataPaletteBlock dataPaletteBlock, DataBits dataBits, Chunk[] nearbyChunks) {
+        packetDataSerializer.a(dataBits.a());
+    }
+
+    /**
+     * Called when the block at the specified block position in the specified world changes and nearby blocks become visible for players.
+     * This implementation does nothing.
+     *
+     * @param world The world of the changed block
+     * @param blockPosition The block position of the changed block
+     */
+    @Override
+    public void updateNearbyBlocks(World world, BlockPosition blockPosition) {
+
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/com/destroystokyo/paper/antixray/BlockPacketControllerObfuscate.java b/src/main/java/com/destroystokyo/paper/antixray/BlockPacketControllerObfuscate.java
new file mode 100644
index 0000000..49a56c5
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/antixray/BlockPacketControllerObfuscate.java
@@ -0,0 +1,386 @@
+package com.destroystokyo.paper.antixray;
+
+import java.util.HashSet;
+import java.util.Set;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ExecutorService;
+
+import com.destroystokyo.paper.PaperWorldConfig;
+
+import net.minecraft.server.Block;
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.Blocks;
+import net.minecraft.server.Chunk;
+import net.minecraft.server.ChunkSection;
+import net.minecraft.server.DataBits;
+import net.minecraft.server.DataPaletteBlock;
+import net.minecraft.server.IBlockData;
+import net.minecraft.server.PacketPlayOutMapChunk;
+import net.minecraft.server.PacketDataSerializer;
+import net.minecraft.server.World;
+
+ /**
+  * BlockPacketControllerObfuscate is an implementation of the interface IBlockPacketController which aims to obfuscate blocks which are sent with chunk packets.
+  */
+ public class BlockPacketControllerObfuscate implements IBlockPacketController {
+ 
+    private static ExecutorService executorServiceInstance = null;
+    protected ExecutorService executorService = null;
+    protected Lock noOpLock = null;
+    protected boolean asynchronous = true;
+    protected int engineMode = 3;
+    protected int neighborsMode = 1;
+    protected int maxChunkY = 3;
+    protected final boolean[] obfuscateBlocks = new boolean[Short.MAX_VALUE];
+    protected IBlockData[] replacementOres = null;
+
+    /**
+     * Protected constructor for invocation by subclass constructors.
+     * Use this constructor to prevent unnecessary intantiation of the Lock and ExecutorService singletons
+     * incase of overriding for example getChunkBlocksLock(Chunk chunk) and getChunkDataLock(Chunk chunk).
+     */
+    protected BlockPacketControllerObfuscate() {
+
+    }
+
+    /**
+     * Public (normal) constructor.
+     *
+     * @param config The config for for this instance
+     */
+    public BlockPacketControllerObfuscate(PaperWorldConfig config) {
+        asynchronous = config.asynchronous;
+        engineMode = config.engineMode;
+        neighborsMode = config.neighborsMode;
+        maxChunkY = config.maxChunkY;
+
+        if (asynchronous) {
+            executorService = getExecutorServiceInstance();
+        } else {
+            noOpLock = Lock.getNoOpInstance();
+        }
+
+        for (Object id : (engineMode == 1) ? config.hiddenBlocks : config.replaceBlocks) {
+            Block block = Block.getByName(String.valueOf(id));
+
+            if (block != null) {
+                int intId = Block.getId(block);
+                obfuscateBlocks[intId] = true;
+            }
+        }
+
+        Set<IBlockData> replacementOreList = new HashSet<IBlockData>();
+
+        for (Object id : config.hiddenBlocks) {
+            Block block = Block.getByName(String.valueOf(id));
+
+            if (block != null && !block.isTileEntity()) {
+                replacementOreList.add(block.getBlockData());
+            }
+        }
+
+        replacementOres = replacementOreList.toArray(new IBlockData[replacementOreList.size()]);
+    }
+
+    /**
+     * Thread-safe (synchronized) singleton getter.
+     *
+     * @return The singleton instance of the executor service (Executors.newSingleThreadExecutor())
+     */
+    public static synchronized ExecutorService getExecutorServiceInstance() {
+        if (executorServiceInstance == null) {
+            executorServiceInstance = Executors.newSingleThreadExecutor();
+        }
+
+        return executorServiceInstance;
+    }
+
+    /**
+     * Returns an instance of a Lock implementation used by the specified chunk to lock blocks or chunk sections from modification.
+     * This implementation returns a new instance of Lock in asynchronous mode and the singleton Lock.getNoOpInstance() else.
+     *
+     * @param chunk The chunk which needs the lock
+     * @return An instance of a Lock implementation
+     */
+    @Override
+    public Lock getChunkBlocksLock(Chunk chunk) {
+        return asynchronous ? new Lock() : noOpLock;
+    }
+
+    /**
+     * Returns an instance of a Lock implementation used by the specified chunk to lock chunk data (everything that is needed to create the packet) from modification.
+     * This implementation returns a new instance of Lock in asynchronous mode and the singleton Lock.getNoOpInstance() else.
+     *
+     * @param chunk The chunk which needs the lock
+     * @return An instance of a Lock implementation
+     */
+    @Override
+    public Lock getChunkDataLock(Chunk chunk) {
+        return asynchronous ? new Lock() : noOpLock;
+    }
+
+    /**
+     * Called when a new chunk section is created.
+     * Returns an array of predefined block data for the DataPaletteBlock of the specified chunk section or null if there is no block data.
+     * This implementation returns the blocks which are used to obfuscate the original blocks.
+     *
+     * @param chunk The chunk which contains the chunk section
+     * @param chunkY The y-coordinate of the chunk section from 0 to 15
+     * @return The array of predefined block data or null
+     */
+    @Override
+    public IBlockData[] getPredefinedBlockData(Chunk chunk, int chunkY) {
+        if (chunkY <= maxChunkY) {
+            switch (engineMode) {
+                case 1:
+                    switch (chunk.world.getWorld().getEnvironment()) {
+                        case NETHER:
+                            return new IBlockData[] {Blocks.NETHERRACK.getBlockData()};
+                        case THE_END:
+                            return new IBlockData[] {Blocks.END_STONE.getBlockData()};
+                        default:
+                            return new IBlockData[] {Blocks.STONE.getBlockData()};
+                    }
+                case 2:
+                case 3:
+                    return replacementOres;
+            }
+        }
+
+        return null;
+    }
+
+    /**
+     * Called before the server attempts to create and send a PacketPlayOutMapChunk for the specified chunk (not for chunk updates).
+     * Returns false if and only if the packet should not be created now.
+     * In this case the chunk remains in the PlayerChunkMap and this method is called again later until this method returns true or the chunk is unloaded.
+     * This implementation returns false in neighbors mode 2 if and only if not all neighbors of the specified chunk are loaded or loads all neighbors in mode 3.
+     *
+     * @param chunk The chunk which the packet is created for
+     * @param chunkSectionSelector The chunk sections which should be sent (each bit represents for one chunk section, the LSB represents the lowest chunk section, 0 = don't send, 1 = send)
+     * @return <code>false</code> in neighbors mode 2 if and only if not all neighbors of the specified chunk are loaded
+     */
+    @Override
+    public boolean onPacketCreate(Chunk chunk, int chunkSectionSelector) {
+        if (neighborsMode == 2) {
+            if (chunk.world.getChunkIfLoaded(chunk.locX - 1, chunk.locZ) == null || chunk.world.getChunkIfLoaded(chunk.locX + 1, chunk.locZ) == null || chunk.world.getChunkIfLoaded(chunk.locX, chunk.locZ - 1) == null || chunk.world.getChunkIfLoaded(chunk.locX, chunk.locZ + 1) == null) {
+                return false;
+            }
+        } else if (neighborsMode == 3) {
+            chunk.world.getChunkAt(chunk.locX - 1, chunk.locZ);
+            chunk.world.getChunkAt(chunk.locX + 1, chunk.locZ);
+            chunk.world.getChunkAt(chunk.locX, chunk.locZ - 1);
+            chunk.world.getChunkAt(chunk.locX, chunk.locZ + 1);
+        }
+
+        return true;
+    }
+
+    /**
+     * Called when packetPlayOutMapChunk is created and the data of chunk should be written to packetDataSerializer.
+     * This method is called instead of packetPlayOutMapChunk.a(packetDataSerializer, chunk, writeSkyLightArray, chunkSectionSelector, nearbyChunks).
+     * This implementation tries to get the nearby chunks synchronously (if loaded) and executes the code asynchronously in asynchronous mode.
+     *
+     * @param packetPlayOutMapChunk The packet which is created
+     * @param packetDataSerializer The data serializer of the specified packet
+     * @param chunk The chunk which the packet is created for and should be written to the data serializer
+     * @param writeSkyLightArray Whether or not the sky light array should be written to the data serializer
+     * @param chunkSectionSelector The chunk sections which should be sent (each bit represents for one chunk section, the LSB represents the lowest chunk section, 0 = don't send, 1 = send)
+     */
+    @Override
+    public void createPacket(PacketPlayOutMapChunk packetPlayOutMapChunk, PacketDataSerializer packetDataSerializer, Chunk chunk, boolean writeSkyLightArray, int chunkSectionSelector) {
+        Chunk[] nearbyChunks = {chunk.world.getChunkIfLoaded(chunk.locX - 1, chunk.locZ), chunk.world.getChunkIfLoaded(chunk.locX + 1, chunk.locZ), chunk.world.getChunkIfLoaded(chunk.locX, chunk.locZ - 1), chunk.world.getChunkIfLoaded(chunk.locX, chunk.locZ + 1)};
+
+        if (asynchronous) {
+            executorService.execute(new ObfuscatorRunnable(packetPlayOutMapChunk, packetDataSerializer, chunk, writeSkyLightArray, chunkSectionSelector, nearbyChunks));
+        } else {
+            packetPlayOutMapChunk.setWrittenChunkSections(packetPlayOutMapChunk.a(packetDataSerializer, chunk, writeSkyLightArray, chunkSectionSelector, nearbyChunks));
+            packetPlayOutMapChunk.setReady(true);
+        }
+    }
+
+    /**
+     * Called when a PacketPlayOutMapChunk is created and the blocks of the specified chunk section should be written to packetDataSerializer.
+     * This method is called instead of packetDataSerializer.a(dataBits.a()).
+     * This implementation obfuscates the data bits depending on the settings.
+     *
+     * @param packetDataSerializer The data serializer of the created packet
+     * @param chunk The chunk which the packet is created for and contains the chunk section
+     * @param chunkY The y-coordinate of the chunk section from 0 to 15
+     * @param dataPaletteBlock The data palette for the blocks of the specified chunk section
+     * @param dataBits The dataBits of the blocks
+     * @param nearbyChunks An array with the length of 4 containing the chunks around the specified chunk or null if not loaded used for thread-safe chunk access (index 0 = x--, 1 = x++, 2 = z--, 3 = z++)
+     */
+    @Override
+    public void writeBlocks(PacketDataSerializer packetDataSerializer, Chunk chunk, int chunkY, DataPaletteBlock dataPaletteBlock, DataBits dataBits, Chunk[] nearbyChunks) {
+        long[] dataBitsArray = dataBits.a();
+
+        if (chunkY <= maxChunkY && dataPaletteBlock.getCurrentPredefinedBlockData() != null && dataPaletteBlock.getCurrentPredefinedBlockData().length > 0 && nearbyChunks != null) {
+            // The iterator marking which random ore we should use next
+            int randomOre = 0;
+            // Boolean used to check if the engine mode is 3 (used for the initial value of x in the inner loop)
+            boolean engineMode3 = engineMode == 3;
+            // Increment the inner loop by 3 in engine mode 3 for more efficiency
+            int increment = engineMode3 ? 3 : 1;
+            // Stores the last array index of the data bits array which was obfuscated
+            int dataBitsIndex = 0;
+            // Stores the last data which was obfuscated but not written to the packet
+            long currentData = dataBitsArray[0];
+            // Write the length of the data bits array to the packet as it is in vanilla
+            packetDataSerializer.d(dataBitsArray.length);
+            // Optimization: Don't try to obfuscate edge blocks of this section if neighbor sections are not loaded or don't exist
+            // We can also add a check for ChunkSection#nonEmptyBlockCount == 0 here
+            int xMin = nearbyChunks[0] == null || nearbyChunks[0].getSections()[chunkY] == Chunk.a ? 1 : 0;
+            int xMax = nearbyChunks[1] == null || nearbyChunks[1].getSections()[chunkY] == Chunk.a ? 15 : 16;
+            int zMin = nearbyChunks[2] == null || nearbyChunks[2].getSections()[chunkY] == Chunk.a ? 1 : 0;
+            int zMax = nearbyChunks[3] == null || nearbyChunks[3].getSections()[chunkY] == Chunk.a ? 15 : 16;
+            int yMin = chunkY == 0 || chunk.getSections()[chunkY - 1] == Chunk.a ? 1 : 0;
+            int yMax = chunkY == chunk.getSections().length - 1 || chunk.getSections()[chunkY + 1] == Chunk.a ? 15 : 16;
+            // Work through the blocks and write the obfuscated data bits array to the packet
+            for (int y = yMin; y < yMax; y++) {
+                for (int z = zMin; z < zMax; z++) {
+                    // Shift the initial value of x and increment by 3 in engine mode 3
+                    int x;
+
+                    if (engineMode3) {
+                        x = (y + z) % 3;
+
+                        if (x < xMin) {
+                            x += 3;
+                        }
+                    } else {
+                        x = xMin;
+                    }
+
+                    for (; x < xMax; x += increment) {
+                        // Calculate the blockIndex from y, z, x and get the blockData from dataPaletteBlock
+                        // More efficient because we may use the blockIndex again later
+                        int blockIndex = y << 8 | z << 4 | x;
+                        IBlockData blockData = dataPaletteBlock.a(blockIndex);
+                        // Check if the block should be obfuscated
+                        if (obfuscateBlocks[Block.getId(blockData.getBlock())]) {
+                            // Check if the nearby blocks are not transparent, we can obfuscate
+                            if (isHiddenBlock(x, y, z, chunk, chunkY, nearbyChunks)) {
+                                // Get one of the predefined blocks which can be used for obfuscation
+                                if (randomOre >= dataPaletteBlock.getCurrentPredefinedBlockData().length) {
+                                    randomOre = 0;
+                                }
+
+                                int newBlockData = dataPaletteBlock.getCurrentPredefinedBlockData()[randomOre++];
+                                // Get the current index of the block in the data bits array
+                                int currentDataBitsIndex = dataBits.getArrayIndex(blockIndex);
+                                // Check if it has been changed
+                                if (currentDataBitsIndex != dataBitsIndex) {
+                                    // If so, we can write the last obfuscated data to the packet because it is finished with the obfuscation
+                                    packetDataSerializer.writeLong(currentData);
+                                    dataBitsIndex++;
+                                    // We can also write all further content of the data bits array to the packet (until currentDataBitsIndex is reached) because it didn't change
+                                    while (dataBitsIndex < currentDataBitsIndex) {
+                                        packetDataSerializer.writeLong(dataBitsArray[dataBitsIndex]);
+                                        dataBitsIndex++;
+                                    }
+                                    // Now we get the data which has to be obfuscated
+                                    currentData = dataBitsArray[dataBitsIndex];
+                                }
+                                // Obfuscate currentData
+                                currentData = dataBits.obfuscate(blockIndex, newBlockData, currentData);
+                                // Check if the data of the current block is splitted to the next index of the data bits array
+                                if (dataBits.isSplitted(blockIndex, dataBitsIndex)) {
+                                    // If so, we can write currentData to the packet because it is finished with the obfuscation
+                                    packetDataSerializer.writeLong(currentData);
+                                    dataBitsIndex++;
+                                    // Get the data at the next index
+                                    currentData = dataBitsArray[dataBitsIndex];
+                                    // And obfuscate it
+                                    currentData = dataBits.obfuscateSplittedPart(blockIndex, newBlockData, currentData);
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+            // Write the rest of the data bits array to the packet
+            packetDataSerializer.writeLong(currentData);
+            dataBitsIndex++;
+
+            while (dataBitsIndex < dataBitsArray.length) {
+                packetDataSerializer.writeLong(dataBitsArray[dataBitsIndex]);
+                dataBitsIndex++;
+            }
+        } else {
+            packetDataSerializer.a(dataBitsArray);
+        }
+    }
+
+    /**
+     * Called when the block at the specified block position in the specified world changes and nearby blocks become visible for players.
+     * This implementation marks the blocks arround the specified block position as dirty so that a block update is forced.
+     *
+     * @param world The world of the changed block
+     * @param blockPosition The block position of the changed block
+     */
+    @Override
+    public void updateNearbyBlocks(World world, BlockPosition blockPosition) {
+        // 2 is the radius, we shouldn't change it as that would make it exponentially slower
+        updateNearbyBlocks(world, blockPosition, 2, false);
+    }
+
+    private void updateNearbyBlocks(World world, BlockPosition blockPosition, int radius, boolean updateSelf) {
+        // If the block in question is loaded
+        if (world.isLoaded(blockPosition)) {
+            // Get block id
+            Block block = world.getType(blockPosition).getBlock();
+            // See if it needs update
+            if (updateSelf && obfuscateBlocks[Block.getId(block)]) {
+                // Send the update
+                world.notify(blockPosition);
+            }
+            // Check other blocks for updates
+            if (radius > 0) {
+                updateNearbyBlocks(world, blockPosition.east(), radius - 1, true);
+                updateNearbyBlocks(world, blockPosition.west(), radius - 1, true);
+                updateNearbyBlocks(world, blockPosition.up(), radius - 1, true);
+                updateNearbyBlocks(world, blockPosition.down(), radius - 1, true);
+                updateNearbyBlocks(world, blockPosition.south(), radius - 1, true);
+                updateNearbyBlocks(world, blockPosition.north(), radius - 1, true);
+            }
+        }
+    }
+
+    private static boolean isHiddenBlock(int x, int y, int z, Chunk chunk, int chunkY, Chunk[] nearbyChunks) {
+        return isSolidBlock(getType(x, y + 1, z, chunk, chunkY, nearbyChunks).getBlock())
+            && isSolidBlock(getType(x + 1, y, z, chunk, chunkY, nearbyChunks).getBlock())
+            && isSolidBlock(getType(x - 1, y, z, chunk, chunkY, nearbyChunks).getBlock())
+            && isSolidBlock(getType(x, y, z + 1, chunk, chunkY, nearbyChunks).getBlock())
+            && isSolidBlock(getType(x, y, z - 1, chunk, chunkY, nearbyChunks).getBlock())
+            && isSolidBlock(getType(x, y - 1, z, chunk, chunkY, nearbyChunks).getBlock());
+    }
+
+    private static IBlockData getType(int x, int y, int z, Chunk chunk, int chunkY, Chunk[] nearbyChunks) {
+        if (x < 0) {
+            chunk = nearbyChunks[0];
+        } else if (x > 15) {
+            chunk = nearbyChunks[1];
+        } else if (z < 0) {
+            chunk = nearbyChunks[2];
+        } else if (z > 15) {
+            chunk = nearbyChunks[3];
+        }
+
+        int blockY = (chunkY << 4) + y;
+
+        if (blockY >= 0 && blockY >> 4 < chunk.getSections().length) {
+            ChunkSection chunkSection = chunk.getSections()[blockY >> 4];
+
+            if (chunkSection != Chunk.a) {
+                return chunkSection.getType(x & 15, y & 15, z & 15);
+            }
+        }
+
+        return Blocks.AIR.getBlockData();
+    }
+
+    private static boolean isSolidBlock(Block block) {
+        return block.isOccluding(block.getBlockData()) && block != Blocks.MOB_SPAWNER && block != Blocks.BARRIER;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/com/destroystokyo/paper/antixray/IBlockPacketController.java b/src/main/java/com/destroystokyo/paper/antixray/IBlockPacketController.java
new file mode 100644
index 0000000..ab0ab12
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/antixray/IBlockPacketController.java
@@ -0,0 +1,86 @@
+package com.destroystokyo.paper.antixray;
+
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.Chunk;
+import net.minecraft.server.DataBits;
+import net.minecraft.server.DataPaletteBlock;
+import net.minecraft.server.IBlockData;
+import net.minecraft.server.PacketPlayOutMapChunk;
+import net.minecraft.server.PacketDataSerializer;
+import net.minecraft.server.World;
+
+/**
+ * IBlockPacketController is an interface which defines methods used to control which and how blocks are sent to the client.
+ */
+public interface IBlockPacketController {
+
+    /**
+     * Returns an instance of a Lock implementation used by the specified chunk to lock blocks or chunk sections from modification.
+     *
+     * @param chunk The chunk which needs the lock
+     * @return An instance of a Lock implementation
+     */
+    public Lock getChunkBlocksLock(Chunk chunk);
+
+    /**
+     * Returns an instance of a Lock implementation used by the specified chunk to lock chunk data (everything that is needed to create the packet) from modification.
+     *
+     * @param chunk The chunk which needs the lock
+     * @return An instance of a Lock implementation
+     */
+    public Lock getChunkDataLock(Chunk chunk);
+
+    /**
+     * Called when a new chunk section is created.
+     * Returns an array of predefined block data for the DataPaletteBlock of the specified chunk section or null if there is no block data.
+     *
+     * @param chunk The chunk which contains the chunk section
+     * @param chunkY The y-coordinate of the chunk section from 0 to 15
+     * @return The array of predefined block data or null
+     */
+    public IBlockData[] getPredefinedBlockData(Chunk chunk, int chunkY);
+
+    /**
+     * Called before the server attempts to create and send a PacketPlayOutMapChunk for the specified chunk (not for chunk updates).
+     * Returns false if and only if the packet should not be created now.
+     * In this case the chunk remains in the PlayerChunkMap and this method is called again later until this method returns true or the chunk is unloaded.
+     *
+     * @param chunk The chunk which the packet is created for
+     * @param chunkSectionSelector The chunk sections which should be sent (each bit represents for one chunk section, the LSB represents the lowest chunk section, 0 = don't send, 1 = send)
+     * @return <code>true</code> if the packet should be sent now, or <code>false</code> if the packet should be sent later
+     */
+    public boolean onPacketCreate(Chunk chunk, int chunkSectionSelector);
+
+    /**
+     * Called when packetPlayOutMapChunk is created and the data of chunk should be written to packetDataSerializer.
+     * This method is called instead of packetPlayOutMapChunk.a(packetDataSerializer, chunk, writeSkyLightArray, chunkSectionSelector, nearbyChunks).
+     *
+     * @param packetPlayOutMapChunk The packet which is created
+     * @param packetDataSerializer The data serializer of the specified packet
+     * @param chunk The chunk which the packet is created for and should be written to the data serializer
+     * @param writeSkyLightArray Whether or not the sky light array should be written to the data serializer
+     * @param chunkSectionSelector The chunk sections which should be sent (each bit represents for one chunk section, the LSB represents the lowest chunk section, 0 = don't send, 1 = send)
+     */
+    public void createPacket(PacketPlayOutMapChunk packetPlayOutMapChunk, PacketDataSerializer packetDataSerializer, Chunk chunk, boolean writeSkyLightArray, int chunkSectionSelector);
+
+    /**
+     * Called when a PacketPlayOutMapChunk is created and the blocks of the specified chunk section should be written to packetDataSerializer.
+     * This method is called instead of packetDataSerializer.a(dataBits.a()).
+     *
+     * @param packetDataSerializer The data serializer of the created packet
+     * @param chunk The chunk which the packet is created for and contains the chunk section
+     * @param chunkY The y-coordinate of the chunk section from 0 to 15
+     * @param dataPaletteBlock The data palette for the blocks of the specified chunk section
+     * @param dataBits The dataBits of the blocks
+     * @param nearbyChunks An array with the length of 4 containing the chunks around the specified chunk or null if not loaded used for thread-safe chunk access (index 0 = x--, 1 = x++, 2 = z--, 3 = z++)
+     */
+    public void writeBlocks(PacketDataSerializer packetDataSerializer, Chunk chunk, int chunkY, DataPaletteBlock dataPaletteBlock, DataBits dataBits, Chunk[] nearbyChunks);
+
+    /**
+     * Called when the block at the specified block position in the specified world changes and nearby blocks become visible for players.
+     *
+     * @param world The world of the changed block
+     * @param blockPosition The block position of the changed block
+     */
+    public void updateNearbyBlocks(World world, BlockPosition blockPosition);
+}
\ No newline at end of file
diff --git a/src/main/java/com/destroystokyo/paper/antixray/Lock.java b/src/main/java/com/destroystokyo/paper/antixray/Lock.java
index 3e55782..15f305d 100644
--- a/src/main/java/com/destroystokyo/paper/antixray/Lock.java
+++ b/src/main/java/com/destroystokyo/paper/antixray/Lock.java
@@ -1,26 +1,117 @@
 package com.destroystokyo.paper.antixray;
 
-import java.util.concurrent.atomic.AtomicInteger;
+ import java.util.concurrent.atomic.AtomicInteger;
 
+/**
+ * Example use case of this Lock class:
+ * <pre><code>String[] lines;
+ *void setLine(int i, String line) { //only invoked by main thread
+ *    lines[i] = line;
+ *}
+ *void printLines() { //only invoked by main thread
+ *    for (String line : lines) {System.out.println(line);}
+ *}</code></pre>
+ * Make printLines() async:
+ * <pre><code>String[] lines;
+ *void setLine(int i, String line) { //only invoked by main thread
+ *    //lock
+ *    lines[i] = line;
+ *    //unlock
+ *}
+ *void printLines() { //only invoked by main thread
+ *    //this state of the array should be printed
+ *    new Thread() {@Override public void run() {
+ *        //here is a race condition because the main thread moved on
+ *        //and can invoke setLine()
+ *        //lock
+ *        for (String line : lines) {System.out.println(line);}
+ *        //unlock
+ *    }}.start();
+ *}</code></pre>
+ * The goal is to ensure that the correct state of the array is printed
+ * (-> the state when printLines() is invoked).
+ * As shown with the //lock and //unlock comments a normal locking system
+ * can't help here.
+ * Possible solutions:
+ * <ul>
+ * <li>Copy the array before starting the new thread and print the copy
+ * <li>Or use this Lock implementation (if setLine() is invoked infrequently)
+ * </ul>
+ * Code:
+ * <pre><code>Lock lock = new Lock();
+ *String[] lines;
+ *void setLine(int i, String line) { //only invoked by main thread
+ *    lock.waitUntilUnlock();
+ *    //no race condition possible here because
+ *    //lock.lock() is invoked on the same thread
+ *    lines[i] = line;
+ *}
+ *void printLines() { //only invoked by main thread
+ *    lock.lock();
+ *    new Thread() {@Override public void run() {
+ *        for (String line : lines) {System.out.println(line);}
+ *        lock.unlock();
+ *    }}.start();
+ *}</code></pre>
+ */
 public class Lock {
-	private final AtomicInteger lockCount = new AtomicInteger();
-
-	public void lock() {
-		lockCount.incrementAndGet();
-	}
-
-	public synchronized void unlock() {
-		lockCount.decrementAndGet();
-		notifyAll();
-	}
-
-	public synchronized void waitUntilUnlock() {
-		try {
-			while (lockCount.get() > 0) {
-				wait();
-			}
-		} catch (InterruptedException e) {
-			Thread.currentThread().interrupt();
-		}
-	}
+
+    private static Lock noOpInstance = null;
+    private final AtomicInteger lockCount = new AtomicInteger();
+
+    /**
+     * Thread-safe (synchronized) singleton getter.
+     *
+     * @return The singleton instance of a no operation implementation of this class
+     */
+    public static synchronized Lock getNoOpInstance() {
+        if (noOpInstance == null) {
+            noOpInstance = new Lock() {
+                @Override
+                public void lock() {
+
+                }
+
+                @Override
+                public void unlock() {
+
+                }
+
+                @Override
+                public void waitUntilUnlock() {
+
+                }
+            };
+        }
+
+        return noOpInstance;
+    }
+
+    /**
+     * See example use case in class doc.
+     */
+    public void lock() {
+        lockCount.incrementAndGet();
+    }
+
+    /**
+     * See example use case in class doc.
+     */
+    public synchronized void unlock() {
+        lockCount.decrementAndGet();
+        notifyAll();
+    }
+
+    /**
+     * See example use case in class doc.
+     */
+    public synchronized void waitUntilUnlock() {
+        try {
+            while (lockCount.get() > 0) {
+                wait();
+            }
+        } catch (InterruptedException e) {
+            Thread.currentThread().interrupt();
+        }
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/de/minetick/MigotConfig.java b/src/main/java/de/minetick/MigotConfig.java
index b34c583..5a76adc 100644
--- a/src/main/java/de/minetick/MigotConfig.java
+++ b/src/main/java/de/minetick/MigotConfig.java
@@ -45,18 +45,20 @@ public class MigotConfig {
 
 	// Settings - load
 	private void loadConfigContent() {
+		// Overall settings
 		enabledAutoSave = configuration.getBoolean("settings.auto-save", false);
 		enabledForkPing = configuration.getBoolean("settings.fork-ping", false);
 		bungeeForwardingCompatible = configuration.getBoolean("settings.bungee-redirect-compatible", false);
-		
+		deleteCorruptChunk = configuration.getBoolean("settings.delete-corrupt-chunk", false);
+		enableVelocityWarning = configuration.getBoolean("settings.enable-velocity-warn", true);
+		// World settings
 		disableSleepChecking = configuration.getBoolean("world-settings.disable-sleep-checking", false);
-		
+		disableSpawnerModify = configuration.getBoolean("world-settings.disable-mob-spanwer-modify", false);
+		// FML settings
 		enabledFMLMonitor = configuration.getBoolean("fml.enable-fml-monitor", false);
 		disableMods = configuration.getStringList("fml.disabled-mods");
 		requisiteMods = configuration.getStringList("fml.requisite-mods");
 		kickInfo = configuration.getString("fml.kick-info", "Mod {MOD} is not allwoed in the server!");
-		enableVelocityWarning = configuration.getBoolean("settings.enable-velocity-warn", true);
-		disableSpawnerModify = configuration.getBoolean("world-settings.disable-mob-spanwer-modify", false);
 	}
 
 	private FileConfiguration loadConfig(File file) throws IOException, InvalidConfigurationException {
@@ -96,5 +98,7 @@ public class MigotConfig {
 	public static boolean enableVelocityWarning;
 	// Spawner modify
 	public static boolean disableSpawnerModify;
+	// Chunk guard
+	public static boolean deleteCorruptChunk;
 
 }
\ No newline at end of file
diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java
index 96aefd6..c899cbb 100644
--- a/src/main/java/net/minecraft/server/Chunk.java
+++ b/src/main/java/net/minecraft/server/Chunk.java
@@ -28,8 +28,8 @@ import com.mrpowergamerbr.utils.LightRandom;
 
 public class Chunk {
 
-	public final Lock blocksLock = new Lock(); // Paper - Async-Anti-Xray - Locks blocks and sections and is applied before a packet of this chunk or a neighbor-chunk is added to the obfuscation-executor-service on the main-thread until the obfuscator-thread is finished to ensure "single-thread-behavior" and thread-safety
-	public final Lock dataLock = new Lock(); // Paper - Async-Anti-Xray - Locks sky light, emitted light and biome index and is applied before a packet of this chunk is added to the obfuscation-executor-service on the main-thread until the obfuscator-thread is finished to ensure "single-thread-behavior" and thread-safety
+	public final Lock blocksLock; // Paper - Async-Anti-Xray - Locks blocks and sections and is applied before a packet of this chunk or a neighbor-chunk is added to the obfuscation-executor-service on the main-thread until the obfuscator-thread is finished to ensure "single-thread-behavior" and thread-safety
+	public final Lock dataLock; // Paper - Async-Anti-Xray - Locks sky light, emitted light and biome index and is applied before a packet of this chunk is added to the obfuscation-executor-service on the main-thread until the obfuscator-thread is finished to ensure "single-thread-behavior" and thread-safety
 	private static final Logger e = LogManager.getLogger();
 	public static final ChunkSection a = null;
 	private final ChunkSection[] sections;
@@ -120,6 +120,8 @@ public class Chunk {
 		// this.entitySlices = (Queue[]) (new ConcurrentLinkedQueue[16]); //
 		// Hose
 		this.world = world;
+		this.blocksLock = this.world.blockPacketController.getChunkBlocksLock(this); // Paper - Async-Anti-Xray
+		this.dataLock = this.world.blockPacketController.getChunkDataLock(this); // Paper - Async-Anti-Xray
 		this.locX = i;
 		this.locZ = j;
 		this.chunkKey = org.bukkit.craftbukkit.util.LongHash.toLong(this.locX, this.locZ); // Paper
@@ -155,7 +157,7 @@ public class Chunk {
 
 						if (this.sections[j1] == Chunk.a) {
 							///
-                            this.sections[j1] = new ChunkSection(j1 << 4, flag, world.paperConfig.antiXrayInstance.getPredefinedBlockData(this, j1));
+                            this.sections[j1] = new ChunkSection(j1 << 4, flag, world.blockPacketController.getPredefinedBlockData(this, j1)); // Paper - Anti-Xray - Add blocks used for obfuscation to the DataPalette
 							///
 						}
 
@@ -542,7 +544,7 @@ public class Chunk {
 				}
 
 				///
-                chunksection = this.sections[j >> 4] = new ChunkSection(j >> 4 << 4, !this.world.worldProvider.m(), this.world.paperConfig.antiXrayInstance.getPredefinedBlockData(this, j >> 4));
+				chunksection = this.sections[j >> 4] = new ChunkSection(j >> 4 << 4, !this.world.worldProvider.m(), this.world.blockPacketController.getPredefinedBlockData(this, j >> 4)); // Paper - Anti-Xray - Add blocks used for obfuscation to the DataPalette
                 this.blocksLock.waitUntilUnlock();
 				///
 				flag = j >= i1;
@@ -637,7 +639,7 @@ public class Chunk {
 
 		if (chunksection == Chunk.a) {
 			///
-            chunksection = this.sections[k >> 4] = new ChunkSection(k >> 4 << 4, !this.world.worldProvider.m(), this.world.paperConfig.antiXrayInstance.getPredefinedBlockData(this, k >> 4));
+            chunksection = this.sections[k >> 4] = new ChunkSection(k >> 4 << 4, !this.world.worldProvider.m(), this.world.blockPacketController.getPredefinedBlockData(this, k >> 4)); // Paper - Anti-Xray - Add blocks used for obfuscation to the DataPalette
 			this.blocksLock.waitUntilUnlock();
 			///
 			this.initLighting();
diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java
index 8c7ea17..4058fc5 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java
@@ -17,8 +17,6 @@ import org.bukkit.event.world.ChunkUnloadEvent;
 
 import com.destroystokyo.paper.exception.ServerInternalException;
 
-import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
-
 public class ChunkProviderServer implements IChunkProvider {
 
 	private static final Logger a = LogManager.getLogger();
@@ -28,12 +26,13 @@ public class ChunkProviderServer implements IChunkProvider {
 																													// public
 																													// //
 																													// Paper
-	// public final Map<Long, Chunk> chunks = Maps.newConcurrentMap(); // Hose
+	public final Map<Long, Chunk> chunks = new ConcurrentHashMap(); // Hose
 	public final ChunkGenerator chunkGenerator;
 	private final IChunkLoader chunkLoader;
 	// Paper start
 	protected Chunk lastChunkByPos = null;
 
+	/*
 	public Long2ObjectOpenHashMap<Chunk> chunks = new Long2ObjectOpenHashMap<Chunk>(8192) {
 
 		@Override
@@ -52,6 +51,7 @@ public class ChunkProviderServer implements IChunkProvider {
 			return super.remove(key);
 		}
 	}; // CraftBukkit
+	*/
 
 	// Paper end
 	public final WorldServer world;
@@ -154,7 +154,7 @@ public class ChunkProviderServer implements IChunkProvider {
 		if (chunk == null) {
 			chunk = this.loadChunk(i, j);
 			if (chunk != null) {
-				this.chunks.put(ChunkCoordIntPair.a(i, j), chunk);
+				synchronized(this) { this.chunks.put(ChunkCoordIntPair.a(i, j), chunk); }
 				chunk.addEntities();
 				chunk.loadNearby(this, this.chunkGenerator, false); // CraftBukkit
 			}
@@ -223,7 +223,7 @@ public class ChunkProviderServer implements IChunkProvider {
 				throw new ReportedException(crashreport);
 			}
 
-			this.chunks.put(k, chunk);
+			synchronized(this) { this.chunks.put(k, chunk); }
 			chunk.addEntities();
 
 			chunk.loadNearby(this, this.chunkGenerator, true); // CraftBukkit
@@ -383,7 +383,7 @@ public class ChunkProviderServer implements IChunkProvider {
 			this.saveChunk(chunk);
 			this.saveChunkNOP(chunk);
 		}
-		this.chunks.remove(chunk.chunkKey);
+		synchronized(this) { this.chunks.remove(chunk.chunkKey); }
 		return true;
 	}
 	// CraftBukkit end
diff --git a/src/main/java/net/minecraft/server/ChunkRegionLoader.java b/src/main/java/net/minecraft/server/ChunkRegionLoader.java
index 454657b..8eea856 100644
--- a/src/main/java/net/minecraft/server/ChunkRegionLoader.java
+++ b/src/main/java/net/minecraft/server/ChunkRegionLoader.java
@@ -418,7 +418,7 @@ public class ChunkRegionLoader implements IChunkLoader, IAsyncChunkSaver {
 			NBTTagCompound nbttagcompound1 = nbttaglist.get(k);
 			byte b1 = nbttagcompound1.getByte("Y");
 			///
-			ChunkSection chunksection = new ChunkSection(b1 << 4, flag, world.paperConfig.antiXrayInstance.getPredefinedBlockData(chunk, b1));
+			ChunkSection chunksection = new ChunkSection(b1 << 4, flag, world.blockPacketController.getPredefinedBlockData(chunk, b1)); // Paper - Anti-Xray - Add blocks used for obfuscation to the DataPalette
 			///
 			byte[] abyte = nbttagcompound1.getByteArray("Blocks");
 			NibbleArray nibblearray = new NibbleArray(nbttagcompound1.getByteArray("Data"));
diff --git a/src/main/java/net/minecraft/server/DataPaletteBlock.java b/src/main/java/net/minecraft/server/DataPaletteBlock.java
index 0f67cb3..3b113b2 100644
--- a/src/main/java/net/minecraft/server/DataPaletteBlock.java
+++ b/src/main/java/net/minecraft/server/DataPaletteBlock.java
@@ -121,12 +121,10 @@ public class DataPaletteBlock implements DataPaletteExpandable {
 	// Paper start - (Async-)Anti-Xray - Called instead of
 	// this.b(PacketDataSerializer packetdataserializer) (with nearbyChunks as
 	// parameter for the async part)
-	public void serializeOrObfuscate(PacketDataSerializer packetdataserializer, Chunk chunk, int y,
-			Chunk[] nearbyChunks) {
+	public void writeBlocks(PacketDataSerializer packetdataserializer, Chunk chunk, int y, Chunk[] nearbyChunks) {
 		packetdataserializer.writeByte(this.e);
 		this.c.b(packetdataserializer);
-		chunk.world.paperConfig.antiXrayInstance.serializeOrObfuscate(packetdataserializer, chunk, y, this, this.b,
-				nearbyChunks);
+		chunk.world.blockPacketController.writeBlocks(packetdataserializer, chunk, y, this, this.b, nearbyChunks);
 	}
 	// Paper end
 
diff --git a/src/main/java/net/minecraft/server/EntityFallingBlock.java b/src/main/java/net/minecraft/server/EntityFallingBlock.java
index 3821b8b..b5069df 100644
--- a/src/main/java/net/minecraft/server/EntityFallingBlock.java
+++ b/src/main/java/net/minecraft/server/EntityFallingBlock.java
@@ -79,9 +79,7 @@ public class EntityFallingBlock extends Entity {
 				if (this.world.getType(blockposition).getBlock() == block && !CraftEventFactory
 						.callEntityChangeBlockEvent(this, blockposition, Blocks.AIR, 0).isCancelled()) {
 					this.world.setAir(blockposition);
-					this.world.paperConfig.antiXrayInstance.updateNearbyBlocks(this.world, blockposition); // Paper
-																											// -
-																											// Anti-Xray
+					this.world.blockPacketController.updateNearbyBlocks(this.world, blockposition); // Paper - Anti-Xray
 				} else if (!this.world.isClientSide) {
 					this.die();
 					return;
@@ -131,9 +129,7 @@ public class EntityFallingBlock extends Entity {
 									return;
 								}
 								this.world.setTypeAndData(blockposition, this.block, 3);
-								this.world.paperConfig.antiXrayInstance.updateNearbyBlocks(this.world, blockposition); // Paper
-																														// -
-																														// Anti-Xray
+								this.world.blockPacketController.updateNearbyBlocks(this.world, blockposition); // Paper - Anti-Xray
 								// CraftBukkit end
 								if (block instanceof BlockFalling) {
 									((BlockFalling) block).a_(this.world, blockposition);
diff --git a/src/main/java/net/minecraft/server/Explosion.java b/src/main/java/net/minecraft/server/Explosion.java
index f8dbae8..9d8b65d 100644
--- a/src/main/java/net/minecraft/server/Explosion.java
+++ b/src/main/java/net/minecraft/server/Explosion.java
@@ -251,9 +251,7 @@ public class Explosion {
 				blockposition = (BlockPosition) iterator.next();
 				IBlockData iblockdata = this.world.getType(blockposition);
 				Block block = iblockdata.getBlock();
-				this.world.paperConfig.antiXrayInstance.updateNearbyBlocks(this.world, blockposition); // Paper
-																										// -
-																										// Anti-Xray
+				this.world.blockPacketController.updateNearbyBlocks(this.world, blockposition);
 
 				if (flag) {
 					double d0 = blockposition.getX() + this.world.random.nextFloat();
diff --git a/src/main/java/net/minecraft/server/NBTCompressedStreamTools.java b/src/main/java/net/minecraft/server/NBTCompressedStreamTools.java
index e026a20..0dca353 100644
--- a/src/main/java/net/minecraft/server/NBTCompressedStreamTools.java
+++ b/src/main/java/net/minecraft/server/NBTCompressedStreamTools.java
@@ -4,6 +4,7 @@ import java.io.DataInput;
 import java.io.DataInputStream;
 import java.io.DataOutput;
 import java.io.DataOutputStream;
+import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -72,7 +73,7 @@ public class NBTCompressedStreamTools {
 			nbtbase.write(dataoutput);
 		}
 	}
-
+	
 	private static NBTBase a(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) throws IOException {
 		byte b0 = datainput.readByte();
 
diff --git a/src/main/java/net/minecraft/server/NBTTagByteArray.java b/src/main/java/net/minecraft/server/NBTTagByteArray.java
index b70ba93..b6f0377 100644
--- a/src/main/java/net/minecraft/server/NBTTagByteArray.java
+++ b/src/main/java/net/minecraft/server/NBTTagByteArray.java
@@ -23,7 +23,7 @@ public class NBTTagByteArray extends NBTBase {
 	}
 
 	@Override
-	void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) throws IOException {
+	synchronized void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) throws IOException {
 		nbtreadlimiter.a(192L);
 		int j = datainput.readInt();
 		com.google.common.base.Preconditions.checkArgument(j < 1 << 24);
diff --git a/src/main/java/net/minecraft/server/NBTTagCompound.java b/src/main/java/net/minecraft/server/NBTTagCompound.java
index 327c8fd..c02941f 100644
--- a/src/main/java/net/minecraft/server/NBTTagCompound.java
+++ b/src/main/java/net/minecraft/server/NBTTagCompound.java
@@ -2,6 +2,7 @@ package net.minecraft.server;
 
 import java.io.DataInput;
 import java.io.DataOutput;
+import java.io.File;
 import java.io.IOException;
 import java.util.Iterator;
 import java.util.Map;
@@ -34,7 +35,7 @@ public class NBTTagCompound extends NBTBase {
 	}
 
 	@Override
-	void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) throws IOException {
+	synchronized void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) throws IOException {
 		nbtreadlimiter.a(384L);
 		if (i > 512) {
 			throw new RuntimeException("Tried to read NBT tag with too high complexity, depth > 512");
@@ -249,7 +250,7 @@ public class NBTTagCompound extends NBTBase {
 			throw new ReportedException(this.a(s, 7, classcastexception));
 		}
 
-		return new byte[0];
+		return new byte[2048]; // Torch
 	}
 
 	public int[] getIntArray(String s) {
@@ -397,7 +398,7 @@ public class NBTTagCompound extends NBTBase {
 	private static String b(DataInput datainput, NBTReadLimiter nbtreadlimiter) throws IOException {
 		return datainput.readUTF();
 	}
-
+	
 	static NBTBase a(byte b0, String s, DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) throws IOException {
 		NBTBase nbtbase = NBTBase.createTag(b0);
 
diff --git a/src/main/java/net/minecraft/server/NBTTagIntArray.java b/src/main/java/net/minecraft/server/NBTTagIntArray.java
index b7de564..1d4e917 100644
--- a/src/main/java/net/minecraft/server/NBTTagIntArray.java
+++ b/src/main/java/net/minecraft/server/NBTTagIntArray.java
@@ -27,7 +27,7 @@ public class NBTTagIntArray extends NBTBase {
 	}
 
 	@Override
-	void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) throws IOException {
+	synchronized void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) throws IOException {
 		nbtreadlimiter.a(192L);
 		int j = datainput.readInt();
 		com.google.common.base.Preconditions.checkArgument(j < 1 << 24);
diff --git a/src/main/java/net/minecraft/server/NBTTagList.java b/src/main/java/net/minecraft/server/NBTTagList.java
index 00117e9..28a8ba6 100644
--- a/src/main/java/net/minecraft/server/NBTTagList.java
+++ b/src/main/java/net/minecraft/server/NBTTagList.java
@@ -14,7 +14,7 @@ import com.google.common.collect.Lists;
 public class NBTTagList extends NBTBase {
 
 	private static final Logger b = LogManager.getLogger();
-	public List<NBTBase> list = Lists.newArrayList(); // Paper
+	public List<NBTBase> list = new org.torch.util.ConcurrentIterableArrayList(); // Paper
 	private byte type = 0;
 
 	public NBTTagList() {
@@ -38,7 +38,7 @@ public class NBTTagList extends NBTBase {
 	}
 
 	@Override
-	void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) throws IOException {
+	synchronized void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) throws IOException {
 		nbtreadlimiter.a(296L);
 		if (i > 512) {
 			throw new RuntimeException("Tried to read NBT tag with too high complexity, depth > 512");
diff --git a/src/main/java/net/minecraft/server/NBTTagString.java b/src/main/java/net/minecraft/server/NBTTagString.java
index 61ca25a..369bb65 100644
--- a/src/main/java/net/minecraft/server/NBTTagString.java
+++ b/src/main/java/net/minecraft/server/NBTTagString.java
@@ -25,7 +25,7 @@ public class NBTTagString extends NBTBase {
 	}
 
 	@Override
-	void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) throws IOException {
+	synchronized void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) throws IOException {
 		nbtreadlimiter.a(288L);
 		this.data = getStoredString(datainput.readUTF(), true); // Migot
 		nbtreadlimiter.a(16 * this.data.length());
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutMapChunk.java b/src/main/java/net/minecraft/server/PacketPlayOutMapChunk.java
index ff04c60..f797800 100644
--- a/src/main/java/net/minecraft/server/PacketPlayOutMapChunk.java
+++ b/src/main/java/net/minecraft/server/PacketPlayOutMapChunk.java
@@ -38,9 +38,7 @@ public class PacketPlayOutMapChunk implements Packet<PacketListenerPlayOut> {
 
 		this.d = new byte[this.a(chunk, flag, i)];
 		// this.c = this.a(new PacketDataSerializer(this.g()), chunk, flag, i);
-		chunk.world.paperConfig.antiXrayInstance.createPacket(this, new PacketDataSerializer(this.g()), chunk, flag, i); // Paper
-																															// -
-																															// Async-Anti-Xray
+		chunk.world.blockPacketController.createPacket(this, new PacketDataSerializer(this.g()), chunk, flag, i); // Paper - Async-Anti-Xray
 		this.e = Lists.newArrayList();
 		Iterator iterator = chunk.getTileEntities().entrySet().iterator();
 
@@ -191,23 +189,8 @@ public class PacketPlayOutMapChunk implements Packet<PacketListenerPlayOut> {
 
 			if (chunksection != Chunk.a && (!this.e() || !chunksection.a()) && (i & 1 << k) != 0) {
 				j |= 1 << k;
-				// chunksection.getBlocks().b(packetdataserializer);
-				chunksection.getBlocks().serializeOrObfuscate(packetdataserializer, chunk, k, nearbyChunks); // Paper
-																												// -
-																												// (Async-)Anti-Xray
-																												// -
-																												// Call
-																												// this
-																												// method
-																												// instead
-																												// (with
-																												// nearbyChunks
-																												// as
-																												// parameter
-																												// for
-																												// the
-																												// async
-																												// part)
+				// chunksection.getBlocks().b(packetdataserializer); // Paper - Anti-Xray - Call writeBlocks instead
+                chunksection.getBlocks().writeBlocks(packetdataserializer, chunk, k, nearbyChunks); // Paper - (Async-)Anti-Xray - Call this method instead (with nearbyChunks as parameter for the async part)
 				packetdataserializer.writeBytes(chunksection.getEmittedLightArray().asBytes());
 				if (flag) {
 					packetdataserializer.writeBytes(chunksection.getSkyLightArray().asBytes());
diff --git a/src/main/java/net/minecraft/server/PlayerChunk.java b/src/main/java/net/minecraft/server/PlayerChunk.java
index e05b2b0..2bdb18e 100644
--- a/src/main/java/net/minecraft/server/PlayerChunk.java
+++ b/src/main/java/net/minecraft/server/PlayerChunk.java
@@ -147,31 +147,7 @@ public class PlayerChunk {
 			return false;
 		} else if (!this.chunk.isReady()) {
 			return false;
-		} else if (!this.chunk.world.paperConfig.antiXrayInstance.onPacketCreate(this.chunk, '\uffff')) { // Paper
-																											// -
-																											// Anti-Xray
-																											// -
-																											// Nearby
-																											// chunks
-																											// should
-																											// be
-																											// loaded
-																											// before
-																											// creating
-																											// the
-																											// packet
-																											// to
-																											// make
-																											// the
-																											// obfuscation
-																											// of
-																											// the
-																											// chunk-edges
-																											// possible
-																											// (depending
-																											// on
-																											// anti-xray
-																											// settings)
+		} else if (!this.chunk.world.blockPacketController.onPacketCreate(this.chunk, '\uffff')) { // Paper - Anti-Xray - Nearby chunks should be loaded before creating the packet to make the obfuscation of the chunk-edges possible (depending on anti-xray settings)
 			return false; // Paper - Anti-Xray - If the nearby chunks are not
 							// loaded and should be loaded first, return false
 							// so that this method is called again
diff --git a/src/main/java/net/minecraft/server/PlayerInteractManager.java b/src/main/java/net/minecraft/server/PlayerInteractManager.java
index c4d969f..d139107 100644
--- a/src/main/java/net/minecraft/server/PlayerInteractManager.java
+++ b/src/main/java/net/minecraft/server/PlayerInteractManager.java
@@ -213,9 +213,7 @@ public class PlayerInteractManager {
 			}
 
 		}
-		this.world.paperConfig.antiXrayInstance.updateNearbyBlocks(this.world, blockposition); // Paper
-																								// -
-																								// Anti-Xray
+		this.world.blockPacketController.updateNearbyBlocks(this.world, blockposition); // Paper - Anti-Xray
 	}
 
 	public void a(BlockPosition blockposition) {
diff --git a/src/main/java/net/minecraft/server/RegionFile.java b/src/main/java/net/minecraft/server/RegionFile.java
index 2f1072a..889ed6f 100644
--- a/src/main/java/net/minecraft/server/RegionFile.java
+++ b/src/main/java/net/minecraft/server/RegionFile.java
@@ -12,6 +12,7 @@ import java.util.List;
 import java.util.zip.DeflaterOutputStream;
 import java.util.zip.GZIPInputStream;
 import java.util.zip.InflaterInputStream;
+import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.atomic.AtomicIntegerArray;
 
 // Torch start
@@ -22,7 +23,6 @@ import org.torch.util.io.FastByteArrayOutputStream;
 // Torch end
 
 import com.destroystokyo.paper.exception.ServerInternalException;
-import com.google.common.collect.Lists;
 
 public class RegionFile {
 
@@ -77,16 +77,16 @@ public class RegionFile {
 			}
 
 			i = (int) this.c.length() / 4096;
-			synchronized(this) { this.f = Lists.newArrayListWithCapacity(i); }
+			this.f = new org.torch.util.ConcurrentIterableArrayList();
 
 			int j;
 
 			for (j = 0; j < i; ++j) {
-				synchronized(this) { this.f.add(Boolean.valueOf(true)); }
+				this.f.add(Boolean.valueOf(true));
 			}
 
-			synchronized(this) { this.f.set(0, Boolean.valueOf(false));
-			this.f.set(1, Boolean.valueOf(false)); }
+			this.f.set(0, Boolean.valueOf(false));
+			this.f.set(1, Boolean.valueOf(false));
 			this.c.seek(0L);
 
 			int k;
@@ -110,7 +110,7 @@ public class RegionFile {
 					for (int l = 0; l < (k & 255); ++l) {
 						// System.out.println("k3: " + k);
 						// System.out.println("l: " + l);
-						synchronized(this) { this.f.set((k >> 8) + l, Boolean.valueOf(false)); }
+						this.f.set((k >> 8) + l, Boolean.valueOf(false));
 					}
 				}
 			}
@@ -246,7 +246,7 @@ public class RegionFile {
 				int l1;
 
 				for (l1 = 0; l1 < j1; ++l1) {
-					synchronized(this) { this.f.set(i1 + l1, Boolean.valueOf(true)); }
+					this.f.set(i1 + l1, Boolean.valueOf(true));
 				}
 
 				l1 = this.f.indexOf(Boolean.valueOf(true));
@@ -277,7 +277,7 @@ public class RegionFile {
 					this.a(i, j, l1 << 8 | k1);
 
 					for (j2 = 0; j2 < k1; ++j2) {
-						synchronized(this) { this.f.set(i1 + j2, Boolean.valueOf(false)); }
+						this.f.set(i1 + j2, Boolean.valueOf(false));
 					}
 
 					this.a(i1, abyte, k);
@@ -287,7 +287,7 @@ public class RegionFile {
 
 					for (j2 = 0; j2 < k1; ++j2) {
 						this.c.write(RegionFile.a);
-						synchronized(this) { this.f.add(Boolean.valueOf(false)); }
+						this.f.add(Boolean.valueOf(false));
 					}
 
 					this.g += 4096 * k1;
diff --git a/src/main/java/net/minecraft/server/RegionFileCache.java b/src/main/java/net/minecraft/server/RegionFileCache.java
index 02a895c..f23a5ca 100644
--- a/src/main/java/net/minecraft/server/RegionFileCache.java
+++ b/src/main/java/net/minecraft/server/RegionFileCache.java
@@ -97,7 +97,15 @@ public class RegionFileCache {
 			return null;
 		}
 
-		return NBTCompressedStreamTools.a(datainputstream);
+		try {
+			return NBTCompressedStreamTools.a(datainputstream);
+		} catch(ReportedException exception) {
+			if (de.minetick.MigotConfig.deleteCorruptChunk) {
+				file.delete();
+				return null;
+			}
+			return NBTCompressedStreamTools.a(datainputstream);
+		}
 	}
 
 	public static DataOutputStream d(File file, int i, int j) {
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index f2ce689..1e4ab90 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -10,6 +10,9 @@ import java.util.Queue;
 import java.util.Random;
 // Paper start
 import java.util.Set;
+import com.destroystokyo.paper.antixray.BlockPacketController; // Paper - Anti-Xray - Default singleton implementation for vanilla
+import com.destroystokyo.paper.antixray.BlockPacketControllerObfuscate; // Paper - Anti-Xray - Anti-Xray implementation
+import com.destroystokyo.paper.antixray.IBlockPacketController; // Paper - Anti-Xray - Interface with methods used to control which and how blocks are sent
 import java.util.UUID;
 // Paper end
 import java.util.concurrent.RecursiveAction;
@@ -121,6 +124,7 @@ public abstract class World implements IBlockAccess {
 	public final org.spigotmc.SpigotWorldConfig spigotConfig; // Spigot
 
 	public final com.destroystokyo.paper.PaperWorldConfig paperConfig; // Paper
+	public final IBlockPacketController blockPacketController; // Paper - Anti-Xray - This per world instance handles all tasks related with Anti-Xray depending on the configuration
 	public final net.techcable.tacospigot.TacoSpigotWorldConfig tacoSpigotConfig; // TacoSpigot
 
 	public final co.aikar.timings.WorldTimingsHandler timings; // Paper
@@ -163,6 +167,7 @@ public abstract class World implements IBlockAccess {
 			MethodProfiler methodprofiler, boolean flag, ChunkGenerator gen, org.bukkit.World.Environment env) {
 		this.spigotConfig = new org.spigotmc.SpigotWorldConfig(worlddata.getName()); // Spigot
 		this.paperConfig = new com.destroystokyo.paper.PaperWorldConfig(worlddata.getName(), this.spigotConfig); // Paper
+		this.blockPacketController = this.paperConfig.antiXray ? new BlockPacketControllerObfuscate(paperConfig) : BlockPacketController.getInstance(); // Paper - Anti-Xray - If enabled use the obfuscate implementation else use the default singleton implementation for vanilla
 		this.dragonConfig = new com.domnian.paperdragon.DragonWorldConfig(worlddata.getName(), this.spigotConfig,
 				this.paperConfig); // PaperDragon
 		this.tacoSpigotConfig = new net.techcable.tacospigot.TacoSpigotWorldConfig(worlddata.getName()); // TacoSpigot
@@ -586,9 +591,7 @@ public abstract class World implements IBlockAccess {
 	}
 
 	public void applyPhysics(BlockPosition blockposition, Block block) {
-		this.paperConfig.antiXrayInstance.updateNearbyBlocks(this, blockposition); // Paper
-																					// -
-																					// Anti-Xray
+		this.blockPacketController.updateNearbyBlocks(this, blockposition); // Paper - Anti-Xray
 		if (captureBlockStates) {
 			return;
 		} // Paper - Cancel all physics during placement
diff --git a/src/main/java/org/bukkit/craftbukkit/generator/CustomChunkGenerator.java b/src/main/java/org/bukkit/craftbukkit/generator/CustomChunkGenerator.java
index d2565d3..c166991 100644
--- a/src/main/java/org/bukkit/craftbukkit/generator/CustomChunkGenerator.java
+++ b/src/main/java/org/bukkit/craftbukkit/generator/CustomChunkGenerator.java
@@ -84,7 +84,7 @@ public class CustomChunkGenerator extends InternalChunkGenerator {
 				// Build chunk section
 				if (emptyTest != 0) {
 					csect[sec] = new ChunkSection(sec << 4, true, section,
-					this.world.paperConfig.antiXrayInstance.getPredefinedBlockData(chunk, sec)); // Paper
+					this.world.blockPacketController.getPredefinedBlockData(chunk, sec)); // Paper
 				}
 			}
 		} else {
@@ -109,7 +109,7 @@ public class CustomChunkGenerator extends InternalChunkGenerator {
 					}
 					// Build chunk section
 					csect[sec] = new ChunkSection(sec << 4, true, secBlkID,
-					this.world.paperConfig.antiXrayInstance.getPredefinedBlockData(chunk, sec)); // Paper
+					this.world.blockPacketController.getPredefinedBlockData(chunk, sec)); // Paper
 				}
 			} else { // Else check for byte-per-block section data
 				byte[][] btypes = generator.generateBlockSections(this.world.getWorld(), this.random, x, z, biomegrid);
@@ -131,7 +131,7 @@ public class CustomChunkGenerator extends InternalChunkGenerator {
 							Block b = Block.getById(btypes[sec][i] & 0xFF);
                             secBlkID[i] = (char) Block.REGISTRY_ID.getId(b.getBlockData());
 						}
-						csect[sec] = new ChunkSection(sec << 4, true, secBlkID, this.world.paperConfig.antiXrayInstance.getPredefinedBlockData(chunk, sec)); // Paper
+						csect[sec] = new ChunkSection(sec << 4, true, secBlkID, this.world.blockPacketController.getPredefinedBlockData(chunk, sec)); // Paper
 					}
 				} else { // Else, fall back to pre 1.2 method
 					@SuppressWarnings("deprecation")
@@ -173,7 +173,7 @@ public class CustomChunkGenerator extends InternalChunkGenerator {
 						// If section built, finish prepping its state
 						if (csbytes != null) {
 							ChunkSection cs = csect[sec] = new ChunkSection(sec << 4, true, csbytes,
-							this.world.paperConfig.antiXrayInstance.getPredefinedBlockData(chunk, sec)); // Paper
+							this.world.blockPacketController.getPredefinedBlockData(chunk, sec)); // Paper
 							cs.recalcBlockCounts();
 						}
 					}
diff --git a/src/main/java/org/torch/util/AtomicByteArray.java b/src/main/java/org/torch/util/AtomicByteArray.java
new file mode 100644
index 0000000..7415fd9
--- /dev/null
+++ b/src/main/java/org/torch/util/AtomicByteArray.java
@@ -0,0 +1,182 @@
+package org.torch.util;
+
+/**
+ * From wikibrain project.
+ * @Link: https://github.com/shilad/wikibrain
+ */
+
+import java.util.concurrent.atomic.AtomicIntegerArray;
+
+/**
+ *
+ *
+ * A {@code byte} array in which elements may be updated atomically.
+ * See the {@link java.util.concurrent.atomic} package
+ * specification for description of the properties of atomic
+ * variables.
+ *
+ * This is an adaptation of Java's AtomicIntegerArray for bytes.
+ *
+ * Four bytes are packed into each int.
+ * Only a few methods are implemented for now.
+ *
+ * @author Shilad Sen
+ */
+public class AtomicByteArray {
+    private final AtomicIntegerArray array;
+    private final int length;
+
+    /**
+     * Creates a new AtomicByteArray of the given length, with all
+     * elements initially zero.
+     *
+     * @param length the length of the array
+     */
+    public AtomicByteArray(final int length) {
+        this.length = length;
+        this.array = new AtomicIntegerArray((length + 3) / 4);
+    }
+
+    /**
+     * Sets the element at position {@code i} to the given value.
+     *
+     * @param i the index
+     * @param newValue the new value
+     */
+    public void set(int i, byte newValue) {
+        int idx = i >>> 2;
+        int shift = (i & 3) << 3;
+        int mask = 0xFF << shift;
+        int val2 = (newValue & 0xff) << shift;
+
+        while (true) {
+            final int num = this.array.get(idx);
+            final int num2 = (num & ~mask) | val2;
+            if ((num == num2) || this.array.compareAndSet(idx, num, num2)) {
+                return;
+            }
+        }
+    }
+
+    /**
+     * Atomically sets the element at position {@code i} to the given
+     * updated value if the current value {@code ==} the expected value.
+     *
+     * @param i the index
+     * @param expect the expected value
+     * @param update the new value
+     * @return true if successful. False return indicates that
+     * the actual value was not equal to the expected value.
+     */
+    public boolean compareAndSet(int i, byte expect, byte update) {
+        int idx = i >>> 2;
+        int shift = (i & 3) << 3;
+        int mask = 0xFF << shift;
+        int expected2 = (expect & 0xff) << shift;
+        int val2 = (update & 0xff) << shift;
+
+        while (true) {
+            final int num = this.array.get(idx);
+            // Check that the read byte is what we expected
+            if ((num & mask) != expected2) return false;
+
+            // If we complete successfully, all is good
+            final int num2 = (num & ~mask) | val2;
+            if ((num == num2) || this.array.compareAndSet(idx, num, num2)) {
+                return true;
+            }
+        }
+    }
+
+
+    /**
+     * Atomically increments by one the element at index {@code i}.
+     *
+     * @param i the index
+     * @return the previous value
+     */
+    public final byte getAndIncrement(int i) {
+        return getAndAdd(i, 1);
+    }
+
+    /**
+     * Atomically decrements by one the element at index {@code i}.
+     *
+     * @param i the index
+     * @return the previous value
+     */
+    public final byte getAndDecrement(int i) {
+        return getAndAdd(i, -1);
+    }
+
+    /**
+     * Atomically adds the given value to the element at index {@code i}.
+     *
+     * @param i the index
+     * @param delta the value to add
+     * @return the previous value
+     */
+    public final byte getAndAdd(int i, int delta) {
+        while (true) {
+            byte current = get(i);
+            byte next = (byte) (current + delta);
+            if (compareAndSet(i, current, next))
+                return current;
+        }
+    }
+
+    /**
+     * Atomically increments by one the element at index {@code i}.
+     *
+     * @param i the index
+     * @return the updated value
+     */
+    public final byte incrementAndGet(int i) {
+        return addAndGet(i, 1);
+    }
+
+    /**
+     * Atomically decrements by one the element at index {@code i}.
+     *
+     * @param i the index
+     * @return the updated value
+     */
+    public final byte decrementAndGet(int i) {
+        return addAndGet(i, -1);
+    }
+
+    /**
+     * Atomically adds the given value to the element at index {@code i}.
+     *
+     * @param i the index
+     * @param delta the value to add
+     * @return the updated value
+     */
+    public final byte addAndGet(int i, int delta) {
+        while (true) {
+            byte current = get(i);
+            byte next = (byte) (current + delta);
+            if (compareAndSet(i, current, next))
+                return next;
+        }
+    }
+
+    /**
+     * Gets the current value at position {@code i}.
+     *
+     * @param i the index
+     * @return the current value
+     */
+    public byte get(final int i) {
+        return (byte) (this.array.get(i >>> 2) >> ((i & 3) << 3));
+    }
+
+    /**
+     * Returns the length of the array.
+     *
+     * @return the length of the array
+     */
+    public int length() {
+        return this.length;
+    }
+}
\ No newline at end of file
diff --git a/src/main/resources/configurations/migot.yml b/src/main/resources/configurations/migot.yml
index 82f76f5..6ed9e33 100644
--- a/src/main/resources/configurations/migot.yml
+++ b/src/main/resources/configurations/migot.yml
@@ -8,6 +8,7 @@ settings:
   fork-ping: false
   bungee-redirect-compatible: false
   enable-velocity-warn: true
+  delete-corrupt-chunk: false
 world-settings:
   disable-sleep-checking: false
   disable-mob-spanwer-modify: false
-- 
2.8.2.windows.1

