From 3a690cfdb719cce9eef492fd69087217577c96f1 Mon Sep 17 00:00:00 2001
From: SotrForgotten <i@omc.hk>
Date: Mon, 15 Aug 2016 22:44:42 +0800
Subject: [PATCH] SPIGOT-2603: Fix inventory update code that got broken in
 update


diff --git a/pom.xml b/pom.xml
index 49b692b..56297c6 100644
--- a/pom.xml
+++ b/pom.xml
@@ -91,24 +91,6 @@
             <artifactId>trove4j</artifactId>
             <version>3.0.3</version>
         </dependency>
-		 <dependency>
-            <groupId>com.google.guava</groupId>
-            <artifactId>guava</artifactId>
-            <version>19.0-rc3</version>
-        </dependency>
-        <dependency>
-            <groupId>org.projectlombok</groupId>
-            <artifactId>lombok</artifactId>
-            <version>1.16.10</version>
-            <scope>provided</scope>
-            <!-- They aren't required to use lombok -->
-            <optional>true</optional>
-        </dependency>
-        <dependency>
-            <groupId>com.google.code.findbugs</groupId>
-            <artifactId>jsr305</artifactId>
-            <version>3.0.1</version>
-        </dependency>
         <!-- testing -->
         <dependency>
             <groupId>junit</groupId>
@@ -256,15 +238,6 @@
                     </excludes>
                 </configuration>
             </plugin>
-			  <!-- Torch - Do not deploy the server -->
-            <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-deploy-plugin</artifactId>
-                <version>2.8.2</version>
-                <configuration>
-                    <skip>true</skip>
-                </configuration>
-            </plugin>
         </plugins>
     </build>
 </project>
diff --git a/src/main/java/net/minecraft/server/BlockMinecartTrackAbstract.java b/src/main/java/net/minecraft/server/BlockMinecartTrackAbstract.java
index d2516a5..12ad0c3 100644
--- a/src/main/java/net/minecraft/server/BlockMinecartTrackAbstract.java
+++ b/src/main/java/net/minecraft/server/BlockMinecartTrackAbstract.java
@@ -235,7 +235,7 @@ public abstract class BlockMinecartTrackAbstract extends Block {
 		private final BlockMinecartTrackAbstract d;
 		private IBlockData e;
 		private final boolean f;
-		private final List<BlockPosition> g = new java.util.concurrent.CopyOnWriteArrayList<BlockPosition>();
+		private final List<BlockPosition> g = new org.torch.util.ConcurrentIterableArrayList<BlockPosition>();
 
 		public MinecartTrackLogic(World world, BlockPosition blockposition, IBlockData iblockdata) {
 			this.b = world;
diff --git a/src/main/java/net/minecraft/server/BlockPosition.java b/src/main/java/net/minecraft/server/BlockPosition.java
index d99e66d..04b8ac6 100644
--- a/src/main/java/net/minecraft/server/BlockPosition.java
+++ b/src/main/java/net/minecraft/server/BlockPosition.java
@@ -315,7 +315,7 @@ public class BlockPosition extends BaseBlockPosition {
 	public static final class PooledBlockPosition extends BlockPosition.MutableBlockPosition {
 
 		private boolean f;
-		private static final List<BlockPosition.PooledBlockPosition> g = new java.util.concurrent.CopyOnWriteArrayList<BlockPosition.PooledBlockPosition>();
+		private static final List<BlockPosition.PooledBlockPosition> g = new org.torch.util.ConcurrentIterableArrayList<BlockPosition.PooledBlockPosition>();
 
 		private PooledBlockPosition(int i, int j, int k) {
 			super(i, j, k);
diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java
index c573276..8631004 100644
--- a/src/main/java/net/minecraft/server/Chunk.java
+++ b/src/main/java/net/minecraft/server/Chunk.java
@@ -15,6 +15,7 @@ import org.apache.logging.log4j.Logger;
 import org.bukkit.Server; // CraftBukkit
 import org.bukkit.craftbukkit.util.CraftMagicNumbers;
 import org.hose.ChunkPopulate_Pool;
+import org.torch.util.ConcurrentIterableArrayList;
 
 import com.destroystokyo.paper.antixray.Lock; // Paper - Async-Anti-Xray - Used to lock data which is used while creating chunk-packets asynchronously (those locks freeze the main thread but they occur very rare, worst case is "synchonous-anti-xray-behavior")
 import com.destroystokyo.paper.exception.ServerInternalException;
@@ -23,7 +24,6 @@ import com.google.common.collect.Lists; // CraftBukkit
 import com.google.common.collect.Queues;
 import com.mrpowergamerbr.utils.LightRandom;
 
-import net.techcable.pineapple.collect.CopyOnWriteMap;
 
 public class Chunk {
 
@@ -133,7 +133,7 @@ public class Chunk {
 		this.g = new byte[256];
 		this.h = new int[256];
 		this.i = new boolean[256];
-		this.tileEntities = new CopyOnWriteMap();
+		this.tileEntities = new java.util.concurrent.ConcurrentHashMap();
 		this.x = 4096;
 		this.y = Queues.newConcurrentLinkedQueue();
 		this.entitySlices = (new CopyOnWriteArrayList[16]); // Spigot
diff --git a/src/main/java/net/minecraft/server/ChunkProviderFlat.java b/src/main/java/net/minecraft/server/ChunkProviderFlat.java
index 6b006ba..bd3f8f0 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderFlat.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderFlat.java
@@ -13,7 +13,7 @@ public class ChunkProviderFlat implements ChunkGenerator {
 	private final Random b;
 	private final IBlockData[] c = new IBlockData[256];
 	private final WorldGenFlatInfo d;
-	private final List<StructureGenerator> e = new java.util.concurrent.CopyOnWriteArrayList<StructureGenerator>();
+	private final List<StructureGenerator> e = new org.torch.util.ConcurrentIterableArrayList<StructureGenerator>();
 	private final boolean f;
 	private final boolean g;
 	private WorldGenLakes h;
diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java
index ee9313c..ed7ab0e 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java
@@ -26,7 +26,7 @@ public class ChunkProviderServer implements IChunkProvider {
 																													// //
 																													// Paper
 	// public final Map<Long, Chunk> chunks = Maps.newConcurrentHMap(); // Hose
-	public final Map<Long, Chunk> chunks = new net.techcable.pineapple.collect.CopyOnWriteMap(); // Torch
+	public final Map<Long, Chunk> chunks = new java.util.concurrent.ConcurrentHashMap(); // Torch
 	public final ChunkGenerator chunkGenerator;
 	private final IChunkLoader chunkLoader;
 	// Paper start
diff --git a/src/main/java/net/minecraft/server/Container.java b/src/main/java/net/minecraft/server/Container.java
index bc1c125..a6449a1 100644
--- a/src/main/java/net/minecraft/server/Container.java
+++ b/src/main/java/net/minecraft/server/Container.java
@@ -89,9 +89,7 @@ public abstract class Container {
 			ItemStack itemstack = this.c.get(i).getItem();
 			ItemStack itemstack1 = this.b.get(i);
 
-			if (!ItemStack.fastMatches(itemstack1, itemstack)
-					|| (tickCount++ % org.spigotmc.SpigotConfig.itemDirtyTicks == 0
-							&& !ItemStack.matches(itemstack1, itemstack))) { // Spigot
+			if (!ItemStack.fastMatches(itemstack1, itemstack) || (tickCount % org.spigotmc.SpigotConfig.itemDirtyTicks == 0 && !ItemStack.matches(itemstack1, itemstack))) { // Spigot
 				itemstack1 = itemstack == null ? null : itemstack.cloneItemStack();
 				this.b.set(i, itemstack1);
 
@@ -101,6 +99,7 @@ public abstract class Container {
 			}
 		}
 
+	tickCount++; // Spigot
 	}
 
 	public boolean a(EntityHuman entityhuman, int i) {
diff --git a/src/main/java/net/minecraft/server/CrashReport.java b/src/main/java/net/minecraft/server/CrashReport.java
index 42cf109..cfde9ec 100644
--- a/src/main/java/net/minecraft/server/CrashReport.java
+++ b/src/main/java/net/minecraft/server/CrashReport.java
@@ -22,7 +22,7 @@ public class CrashReport {
 	private final String b;
 	private final Throwable c;
 	private final CrashReportSystemDetails d = new CrashReportSystemDetails(this, "System Details");
-	private final List<CrashReportSystemDetails> e = new java.util.concurrent.CopyOnWriteArrayList<CrashReportSystemDetails>();
+	private final List<CrashReportSystemDetails> e = new org.torch.util.ConcurrentIterableArrayList<CrashReportSystemDetails>();
 	private File f;
 	private boolean g = true;
 	private StackTraceElement[] h = new StackTraceElement[0];
diff --git a/src/main/java/net/minecraft/server/DataWatcher.java b/src/main/java/net/minecraft/server/DataWatcher.java
index 2a48653..4679aa0 100644
--- a/src/main/java/net/minecraft/server/DataWatcher.java
+++ b/src/main/java/net/minecraft/server/DataWatcher.java
@@ -24,7 +24,7 @@ import net.techcable.tacospigot.TacoSpigotConfig;
 
 public class DataWatcher {
 
-	private static final Map<Class<? extends Entity>, Integer> a = new net.techcable.pineapple.collect.CopyOnWriteMap();
+	private static final Map<Class<? extends Entity>, Integer> a = new java.util.concurrent.ConcurrentHashMap();
 	private final Entity b;
 	private final Int2ObjectMap<Item<?>> c = TacoSpigotConfig.useArraysForDatawatcher ? new ArrayMap<>()
 			: new Int2ObjectOpenHashMap<>(); // Paper // TacoSpigot - use
diff --git a/src/main/java/net/minecraft/server/EnderDragonBattle.java b/src/main/java/net/minecraft/server/EnderDragonBattle.java
index 8727302..037fa1f 100644
--- a/src/main/java/net/minecraft/server/EnderDragonBattle.java
+++ b/src/main/java/net/minecraft/server/EnderDragonBattle.java
@@ -46,7 +46,7 @@ public class EnderDragonBattle {
 	public EnderDragonBattle(WorldServer worldserver, NBTTagCompound nbttagcompound) {
 		this.c = (BossBattleServer) (new BossBattleServer(new ChatMessage("entity.EnderDragon.name", new Object[0]),
 				BossBattle.BarColor.PINK, BossBattle.BarStyle.PROGRESS)).setPlayMusic(true).c(true);
-		this.e = new java.util.concurrent.CopyOnWriteArrayList<Integer>();
+		this.e = new org.torch.util.ConcurrentIterableArrayList<Integer>();
 		this.g = 0;
 		this.h = 0;
 		this.i = 0;
diff --git a/src/main/java/net/minecraft/server/Entity.java b/src/main/java/net/minecraft/server/Entity.java
index 5f9b9e8..0a843fc 100644
--- a/src/main/java/net/minecraft/server/Entity.java
+++ b/src/main/java/net/minecraft/server/Entity.java
@@ -229,7 +229,7 @@ public abstract class Entity implements ICommandListener, org.spigotmc.Optimized
 
 	public Entity(World world) {
 		this.id = Entity.entityCount++;
-		this.passengers = new java.util.concurrent.CopyOnWriteArrayList<Entity>();
+		this.passengers = new org.torch.util.ConcurrentIterableArrayList<Entity>();
 		this.boundingBox = Entity.b;
 		this.width = 0.6F;
 		this.length = 1.8F;
diff --git a/src/main/java/net/minecraft/server/EntityFallingBlock.java b/src/main/java/net/minecraft/server/EntityFallingBlock.java
index e867fe5..3821b8b 100644
--- a/src/main/java/net/minecraft/server/EntityFallingBlock.java
+++ b/src/main/java/net/minecraft/server/EntityFallingBlock.java
@@ -218,7 +218,7 @@ public class EntityFallingBlock extends Entity {
 			int i = MathHelper.f(f - 1.0F);
 
 			if (i > 0) {
-				List arraylist = Lists.newCopyOnWriteArrayList(this.world.getEntities(this, this.getBoundingBox()));
+				List arraylist = Lists.newArrayList(this.world.getEntities(this, this.getBoundingBox()));
 				boolean flag = block == Blocks.ANVIL;
 				DamageSource damagesource = flag ? DamageSource.ANVIL : DamageSource.FALLING_BLOCK;
 				Iterator iterator = arraylist.iterator();
diff --git a/src/main/java/net/minecraft/server/EntitySlice.java b/src/main/java/net/minecraft/server/EntitySlice.java
index 801c362..773d4fc 100644
--- a/src/main/java/net/minecraft/server/EntitySlice.java
+++ b/src/main/java/net/minecraft/server/EntitySlice.java
@@ -17,7 +17,7 @@ public class EntitySlice<T> extends AbstractSet<T> {
 	private final Map<Class<?>, List<T>> b = Maps.newHashMap();
 	private final Set<Class<?>> c = Sets.newIdentityHashSet();
 	private final Class<T> d;
-	private final List<T> e = new java.util.concurrent.CopyOnWriteArrayList<T>();
+	private final List<T> e = new org.torch.util.ConcurrentIterableArrayList<T>();
 
 	public EntitySlice(Class<T> oclass) {
 		this.d = oclass;
diff --git a/src/main/java/net/minecraft/server/Explosion.java b/src/main/java/net/minecraft/server/Explosion.java
index 105ee7c..f8dbae8 100644
--- a/src/main/java/net/minecraft/server/Explosion.java
+++ b/src/main/java/net/minecraft/server/Explosion.java
@@ -4,7 +4,6 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
 import java.util.concurrent.ConcurrentMap;
-import java.util.concurrent.CopyOnWriteArrayList;
 
 import org.bukkit.Location;
 // CraftBukkit start
@@ -28,8 +27,8 @@ public class Explosion {
 	private final double posZ;
 	public final Entity source;
 	private final float size;
-	private final List<BlockPosition> blocks = new CopyOnWriteArrayList<BlockPosition>(); // Torch
-	private final net.techcable.pineapple.collect.CopyOnWriteMap<EntityHuman, Vec3D> k = new net.techcable.pineapple.collect.CopyOnWriteMap<EntityHuman, Vec3D>(); // Hose
+	private final List<BlockPosition> blocks = new org.torch.util.ConcurrentIterableArrayList<BlockPosition>(); // Torch
+	private final java.util.concurrent.ConcurrentHashMap<EntityHuman, Vec3D> k = new java.util.concurrent.ConcurrentHashMap<EntityHuman, Vec3D>(); // Hose
 	public boolean wasCanceled = false; // CraftBukkit - add field
 
 	public Explosion(World world, Entity entity, double d0, double d1, double d2, float f, boolean flag,
diff --git a/src/main/java/net/minecraft/server/HandshakeListener.java b/src/main/java/net/minecraft/server/HandshakeListener.java
index 6abee8f..55d401d 100644
--- a/src/main/java/net/minecraft/server/HandshakeListener.java
+++ b/src/main/java/net/minecraft/server/HandshakeListener.java
@@ -18,7 +18,7 @@ public class HandshakeListener implements PacketHandshakingInListener {
 																					// legacy
 																					// name
 	// CraftBukkit start - add fields
-	private static final net.techcable.pineapple.collect.CopyOnWriteMap<InetAddress, Long> throttleTracker = new net.techcable.pineapple.collect.CopyOnWriteMap<InetAddress, Long>();
+	private static final java.util.concurrent.ConcurrentHashMap<InetAddress, Long> throttleTracker = new java.util.concurrent.ConcurrentHashMap<InetAddress, Long>();
 	private static int throttleCounter = 0;
 	// CraftBukkit end
 
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 7fd311c..27af288 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -906,10 +906,10 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
 		this.server.getScheduler().mainThreadHeartbeat(this.ticks); // CraftBukkit
 		this.methodProfiler.a("jobs");
 		// Spigot start
-		FutureTask<?> entry;
-		int count = this.j.size();
-		while (count-- > 0 && (entry = this.j.poll()) != null) {
-			synchronized (this) {
+		synchronized(this) {
+			FutureTask<?> entry;
+			int count = this.j.size();
+			while (count-- > 0 && (entry = this.j.poll()) != null) {
 				SystemUtils.a(entry, MinecraftServer.LOGGER);
 			}
 		}
diff --git a/src/main/java/net/minecraft/server/NameReferencingFileConverter.java b/src/main/java/net/minecraft/server/NameReferencingFileConverter.java
index f83be8f..1938b0f 100644
--- a/src/main/java/net/minecraft/server/NameReferencingFileConverter.java
+++ b/src/main/java/net/minecraft/server/NameReferencingFileConverter.java
@@ -333,7 +333,7 @@ public class NameReferencingFileConverter {
 			if (gameprofile != null && gameprofile.getId() != null) {
 				return gameprofile.getId().toString();
 			} else if (!minecraftserver.R() && minecraftserver.getOnlineMode()) {
-				final List arraylist = new java.util.concurrent.CopyOnWriteArrayList();
+				final ArrayList arraylist = Lists.newArrayList();
 				ProfileLookupCallback profilelookupcallback = new ProfileLookupCallback() {
 					@Override
 					public void onProfileLookupSucceeded(GameProfile gameprofile) {
diff --git a/src/main/java/net/minecraft/server/NavigationListener.java b/src/main/java/net/minecraft/server/NavigationListener.java
index e8bc6a0..3c08385 100644
--- a/src/main/java/net/minecraft/server/NavigationListener.java
+++ b/src/main/java/net/minecraft/server/NavigationListener.java
@@ -9,7 +9,7 @@ import com.googlecode.concurrentlinkedhashmap.ConcurrentLinkedHashMap; // Torch
 
 public class NavigationListener implements IWorldAccess {
 
-	private final List<NavigationAbstract> a = new java.util.concurrent.CopyOnWriteArrayList<NavigationAbstract>();
+	private final List<NavigationAbstract> a = new org.torch.util.ConcurrentIterableArrayList<NavigationAbstract>();
 
 	public NavigationListener() {
 	}
diff --git a/src/main/java/net/minecraft/server/PacketStatusInPing.java b/src/main/java/net/minecraft/server/PacketStatusInPing.java
deleted file mode 100644
index a638cc8..0000000
--- a/src/main/java/net/minecraft/server/PacketStatusInPing.java
+++ /dev/null
@@ -1,54 +0,0 @@
-package net.minecraft.server;
-
-import java.io.IOException;
-import java.util.concurrent.RecursiveAction;
-
-public class PacketStatusInPing implements Packet<PacketStatusInListener> {
-
-	private long a;
-
-	public PacketStatusInPing() {
-	}
-
-	@Override
-	public void a(PacketDataSerializer packetdataserializer) throws IOException {
-		this.a = packetdataserializer.readLong();
-	}
-
-	@Override
-	public void b(PacketDataSerializer packetdataserializer) throws IOException {
-		packetdataserializer.writeLong(this.a);
-	}
-
-	class InTask extends RecursiveAction {
-		PacketStatusInListener packetstatusinlistener;
-
-		InTask(PacketStatusInListener packetstatusinlistener) {
-			this.packetstatusinlistener = packetstatusinlistener;
-		}
-
-		@Override
-		protected void compute() {
-			a_task(packetstatusinlistener);
-		}
-
-	}
-
-	@Override
-	public void a(PacketStatusInListener packetstatusinlistener) {
-		if (de.minetick.MigotConfig.enabledForkPing) {
-			InTask a_task = new InTask(packetstatusinlistener);
-			a_task.fork();
-		} else {
-			packetstatusinlistener.a(this);
-		}
-	}
-
-	public void a_task(PacketStatusInListener packetstatusinlistener) {
-		packetstatusinlistener.a(this);
-	}
-
-	public long a() {
-		return this.a;
-	}
-}
diff --git a/src/main/java/net/minecraft/server/PacketStatusInStart.java b/src/main/java/net/minecraft/server/PacketStatusInStart.java
deleted file mode 100644
index 887923a..0000000
--- a/src/main/java/net/minecraft/server/PacketStatusInStart.java
+++ /dev/null
@@ -1,47 +0,0 @@
-package net.minecraft.server;
-
-import java.io.IOException;
-import java.util.concurrent.RecursiveAction;
-
-public class PacketStatusInStart implements Packet<PacketStatusInListener> {
-
-	public PacketStatusInStart() {
-	}
-
-	@Override
-	public void a(PacketDataSerializer packetdataserializer) throws IOException {
-	}
-
-	@Override
-	public void b(PacketDataSerializer packetdataserializer) throws IOException {
-	}
-
-	class InTask extends RecursiveAction {
-		PacketStatusInListener packetstatusinlistener;
-
-		InTask(PacketStatusInListener packetstatusinlistener) {
-			this.packetstatusinlistener = packetstatusinlistener;
-		}
-
-		@Override
-		protected void compute() {
-			a_task(packetstatusinlistener);
-		}
-
-	}
-
-	@Override
-	public void a(PacketStatusInListener packetstatusinlistener) {
-		if (de.minetick.MigotConfig.enabledForkPing) {
-			InTask a_task = new InTask(packetstatusinlistener);
-			a_task.fork();
-		} else {
-			packetstatusinlistener.a(this);
-		}
-	}
-
-	public void a_task(PacketStatusInListener packetstatusinlistener) {
-		packetstatusinlistener.a(this);
-	}
-
-}
diff --git a/src/main/java/net/minecraft/server/PacketStatusListener.java b/src/main/java/net/minecraft/server/PacketStatusListener.java
index 0cf92e1..3fc0b0c 100644
--- a/src/main/java/net/minecraft/server/PacketStatusListener.java
+++ b/src/main/java/net/minecraft/server/PacketStatusListener.java
@@ -2,6 +2,7 @@ package net.minecraft.server;
 
 import java.net.InetSocketAddress;
 import java.util.Iterator;
+import java.util.concurrent.RecursiveAction;
 
 import org.bukkit.craftbukkit.util.CraftIconCache;
 import org.bukkit.entity.Player;
@@ -22,13 +23,36 @@ public class PacketStatusListener implements PacketStatusInListener {
 		this.minecraftServer = minecraftserver;
 		this.networkManager = networkmanager;
 	}
-
+	
 	@Override
 	public void a(IChatBaseComponent ichatbasecomponent) {
 	}
+	
+	class StatusTask extends RecursiveAction {
+		PacketStatusInStart packetstatusinstart;
+
+		StatusTask(PacketStatusInStart packetstatusinstart) {
+			this.packetstatusinstart = packetstatusinstart;
+		}
+
+		@Override
+		protected void compute() {
+			a_task(packetstatusinstart);
+		}
+
+	}
 
 	@Override
 	public void a(PacketStatusInStart packetstatusinstart) {
+		if (de.minetick.MigotConfig.enabledForkPing) {
+			StatusTask a_task = new StatusTask(packetstatusinstart);
+			a_task.fork();
+		} else {
+			a_task(packetstatusinstart);
+		}
+	}
+	
+	public void a_task(PacketStatusInStart packetstatusinstart) {
 		if (this.d) {
 			this.networkManager.close(PacketStatusListener.a);
 		} else {
diff --git a/src/main/java/net/minecraft/server/PlayerChunk.java b/src/main/java/net/minecraft/server/PlayerChunk.java
index dfe703a..e05b2b0 100644
--- a/src/main/java/net/minecraft/server/PlayerChunk.java
+++ b/src/main/java/net/minecraft/server/PlayerChunk.java
@@ -18,7 +18,7 @@ public class PlayerChunk {
 
 	private static final Logger a = LogManager.getLogger();
 	private final PlayerChunkMap playerChunkMap;
-	public final List<EntityPlayer> c = new java.util.concurrent.CopyOnWriteArrayList<EntityPlayer>(); // CraftBukkit
+	public final List<EntityPlayer> c = new org.torch.util.ConcurrentIterableArrayList<EntityPlayer>(); // CraftBukkit
 																										// -
 																										// public
 	private final ChunkCoordIntPair location;
diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java
index 4322ff8..ed5ed4f 100644
--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java
@@ -25,7 +25,6 @@ import com.google.common.collect.Queues;
 import com.google.common.collect.Sets;
 
 import co.aikar.timings.Timing;
-import net.techcable.pineapple.collect.CopyOnWriteMap;
 
 public class PlayerChunkMap {
 
@@ -53,11 +52,10 @@ public class PlayerChunkMap {
 
 	private final WorldServer world;
 	// TacoSpigot start - catch async access
-	private final List<EntityPlayer> managedPlayers = AsyncCatcher.catchAsyncUsage(
-			new java.util.concurrent.CopyOnWriteArrayList(), "list access PlayerChunkMap.managedPlayers");
+	private final List<EntityPlayer> managedPlayers = new org.torch.util.ConcurrentIterableArrayList();
 	// private final Long2ObjectMap<PlayerChunk> e = new
 	// Long2ObjectOpenHashMap(4096);
-	private final Map<Long, PlayerChunk> e = new CopyOnWriteMap();
+	private final Map<Long, PlayerChunk> e = new java.util.concurrent.ConcurrentHashMap();
 	// private final Set<PlayerChunk> f =
 	// AsyncCatcher.catchAsyncUsage(Sets.newHashSet(), "set access
 	// PlayerChunkMap.f");
diff --git a/src/main/java/net/minecraft/server/PlayerConnection.java b/src/main/java/net/minecraft/server/PlayerConnection.java
index 2bf92cd..4d67ba9 100644
--- a/src/main/java/net/minecraft/server/PlayerConnection.java
+++ b/src/main/java/net/minecraft/server/PlayerConnection.java
@@ -1231,8 +1231,8 @@ public class PlayerConnection implements PacketListenerPlayIn, ITickable {
 		}
 
 	}
-
-	/*
+	
+	// Torch start
 	class SendTask extends RecursiveAction {
 		Packet<?> packet;
 
@@ -1246,13 +1246,20 @@ public class PlayerConnection implements PacketListenerPlayIn, ITickable {
 		}
 	}
 
-	public void sendPacket(Packet<?> packet) {
+	public void sendPacket(final Packet<?> packet) {
+		if (packet == null || this.processedDisconnect) { // Spigot
+			return;
+		}
+		if (packet instanceof PacketPlayOutRespawn) {
+			this.networkManager.sendPacket(packet);
+			return;
+		}
+		
 		SendTask task = new SendTask(packet);
 		task.fork();
 	}
-	*/
-
-	public void sendPacket(final Packet<?> packet) {
+	
+	public void sendPacket_sub(final Packet<?> packet) {
 		if (packet instanceof PacketPlayOutChat) {
 			PacketPlayOutChat packetplayoutchat = (PacketPlayOutChat) packet;
 			EntityHuman.EnumChatVisibility entityhuman_enumchatvisibility = this.player.getChatFlags();
@@ -1267,12 +1274,10 @@ public class PlayerConnection implements PacketListenerPlayIn, ITickable {
 		}
 
 		// CraftBukkit start
-		if (packet == null || this.processedDisconnect) { // Spigot
-			return;
-		} else if (packet instanceof PacketPlayOutSpawnPosition) {
+		// Torch end
+		if (packet instanceof PacketPlayOutSpawnPosition) {
 			PacketPlayOutSpawnPosition packet6 = (PacketPlayOutSpawnPosition) packet;
-			this.player.compassTarget = new Location(this.getPlayer().getWorld(), packet6.position.getX(),
-					packet6.position.getY(), packet6.position.getZ());
+			this.player.compassTarget = new Location(this.getPlayer().getWorld(), packet6.position.getX(), packet6.position.getY(), packet6.position.getZ());
 		}
 		// CraftBukkit end
 
diff --git a/src/main/java/net/minecraft/server/PlayerList.java b/src/main/java/net/minecraft/server/PlayerList.java
index af20910..d3e8bda 100644
--- a/src/main/java/net/minecraft/server/PlayerList.java
+++ b/src/main/java/net/minecraft/server/PlayerList.java
@@ -50,7 +50,7 @@ public abstract class PlayerList {
 	private static final Logger f = LogManager.getLogger();
 	private static final SimpleDateFormat g = new SimpleDateFormat("yyyy-MM-dd \'at\' HH:mm:ss z");
 	private final MinecraftServer server;
-	public final List<EntityPlayer> players = new java.util.concurrent.CopyOnWriteArrayList(); // CraftBukkit
+	public final List<EntityPlayer> players = new org.torch.util.ConcurrentIterableArrayList(); // CraftBukkit
 																								// -
 																								// ArrayList
 																								// ->
@@ -88,7 +88,7 @@ public abstract class PlayerList {
 		this.operators = new OpList(PlayerList.c);
 		this.whitelist = new WhiteList(PlayerList.d);
 		// this.o = Maps.newHashMap();
-		this.o = new net.techcable.pineapple.collect.CopyOnWriteMap();
+		this.o = new java.util.concurrent.ConcurrentHashMap();
 		this.server = minecraftserver;
 		this.k.a(false);
 		this.l.a(false);
diff --git a/src/main/java/net/minecraft/server/RegionFile.java b/src/main/java/net/minecraft/server/RegionFile.java
index 67b2555..b9b32d2 100644
--- a/src/main/java/net/minecraft/server/RegionFile.java
+++ b/src/main/java/net/minecraft/server/RegionFile.java
@@ -303,18 +303,7 @@ public class RegionFile {
 
 			this.b(i, j, (int) (MinecraftServer.av() / 1000L));
 		} catch (IOException ioexception) {
-			net.techcable.pineapple.SneakyThrow.sneakyThrow(ioexception); // Paper
-																			// -
-																			// we
-																			// want
-																			// the
-																			// upper
-																			// try/catch
-																			// to
-																			// retry
-																			// this
-																			// //
-																			// Torch
+			org.spigotmc.SneakyThrow.sneaky(ioexception); // Paper - we want the upper try/catch to retry this
 		}
 
 	}
diff --git a/src/main/java/net/minecraft/server/StatisticManager.java b/src/main/java/net/minecraft/server/StatisticManager.java
index 7ff0117..9c1174d 100644
--- a/src/main/java/net/minecraft/server/StatisticManager.java
+++ b/src/main/java/net/minecraft/server/StatisticManager.java
@@ -2,11 +2,9 @@ package net.minecraft.server;
 
 import java.util.Map;
 
-import net.techcable.pineapple.collect.CopyOnWriteMap;
-
 public class StatisticManager {
 
-	protected final Map<Statistic, StatisticWrapper> a = new CopyOnWriteMap();
+	protected final Map<Statistic, StatisticWrapper> a = new java.util.concurrent.ConcurrentHashMap();
 
 	public StatisticManager() {
 	}
diff --git a/src/main/java/net/minecraft/server/SystemUtils.java b/src/main/java/net/minecraft/server/SystemUtils.java
deleted file mode 100644
index 8de936d..0000000
--- a/src/main/java/net/minecraft/server/SystemUtils.java
+++ /dev/null
@@ -1,30 +0,0 @@
-package net.minecraft.server;
-
-import java.util.List;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.FutureTask;
-
-import javax.annotation.Nullable;
-
-import org.apache.logging.log4j.Logger;
-
-public class SystemUtils {
-
-	@Nullable
-	public static synchronized <V> V a(FutureTask<V> futuretask, Logger logger) {
-		try {
-			futuretask.run();
-			return futuretask.get();
-		} catch (ExecutionException executionexception) {
-			logger.fatal("Error executing task", executionexception);
-		} catch (InterruptedException interruptedexception) {
-			logger.fatal("Error executing task", interruptedexception);
-		}
-
-		return null;
-	}
-
-	public static <T> T a(List<T> list) {
-		return list.get(list.size() - 1);
-	}
-}
\ No newline at end of file
diff --git a/src/main/java/net/minecraft/server/TileEntityBeacon.java b/src/main/java/net/minecraft/server/TileEntityBeacon.java
index 0acc231..6e42157 100644
--- a/src/main/java/net/minecraft/server/TileEntityBeacon.java
+++ b/src/main/java/net/minecraft/server/TileEntityBeacon.java
@@ -28,7 +28,7 @@ public class TileEntityBeacon extends TileEntityContainer implements ITickable,
 			{ MobEffects.FASTER_MOVEMENT, MobEffects.FASTER_DIG }, { MobEffects.RESISTANCE, MobEffects.JUMP },
 			{ MobEffects.INCREASE_DAMAGE }, { MobEffects.REGENERATION } };
 	private static final Set<MobEffectList> f = Sets.newConcurrentHashSet();
-	private final List<TileEntityBeacon.BeaconColorTracker> g = new java.util.concurrent.CopyOnWriteArrayList<TileEntityBeacon.BeaconColorTracker>();
+	private final List<TileEntityBeacon.BeaconColorTracker> g = new org.torch.util.ConcurrentIterableArrayList<TileEntityBeacon.BeaconColorTracker>();
 	private boolean j;
 	public int k = -1; // PAIL: private -> public
 	private int levels = 0;
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index 87d1f5f..1dc6c28 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -11,7 +11,6 @@ import java.util.Random;
 // Paper start
 import java.util.Set;
 import java.util.UUID;
-import java.util.concurrent.CopyOnWriteArrayList;
 // Paper end
 import java.util.concurrent.RecursiveAction;
 import java.util.concurrent.RecursiveTask;
@@ -52,7 +51,7 @@ public abstract class World implements IBlockAccess {
 	// Spigot start - guard entity list from removals
 	protected boolean cancelHeavyCalculations = false;
 
-	public final List<Entity> entityList = Lists.newCopyOnWriteArrayList(); // Hose
+	public final List<Entity> entityList = new org.torch.util.ConcurrentIterableArrayList(); // Hose
 	/*
 	 * public final List<Entity> entityList = new java.util.ArrayList<Entity>()
 	 * {
@@ -70,12 +69,12 @@ public abstract class World implements IBlockAccess {
 	protected final Queue<Entity> f = Queues.newConcurrentLinkedQueue();
 	// public final List<TileEntity> tileEntityList = Lists.newArrayList(); //
 	// Paper - remove unused list
-	public final List<TileEntity> tileEntityListTick = new CopyOnWriteArrayList<TileEntity>();
+	public final List<TileEntity> tileEntityListTick = new org.torch.util.ConcurrentIterableArrayList<TileEntity>();
 	private final Queue<TileEntity> b = Queues.newConcurrentLinkedQueue();
 	private final Set<TileEntity> tileEntityListUnload = Sets.newConcurrentHashSet(); // Paper
-	public final List<EntityHuman> players = new CopyOnWriteArrayList<EntityHuman>();
+	public final List<EntityHuman> players = new org.torch.util.ConcurrentIterableArrayList<EntityHuman>();
 	public final Queue<Entity> j = Queues.newConcurrentLinkedQueue();
-	protected final Map<Integer, Entity> entitiesById = new net.techcable.pineapple.collect.CopyOnWriteMap();
+	protected final Map<Integer, Entity> entitiesById = new java.util.concurrent.ConcurrentHashMap();
 	private long I = 16777215L;
 	private int J;
 	protected int l = com.mrpowergamerbr.parappatown.utils.LightStatic.random.nextInt();
@@ -146,7 +145,7 @@ public abstract class World implements IBlockAccess {
 	private org.spigotmc.TickLimiter entityLimiter;
 	private org.spigotmc.TickLimiter tileLimiter;
 	private int tileTickPosition;
-	public final Map<Explosion.CacheKey, Float> explosionDensityCache = new net.techcable.pineapple.collect.CopyOnWriteMap<>(); // Paper
+	public final Map<Explosion.CacheKey, Float> explosionDensityCache = new java.util.concurrent.ConcurrentHashMap<>(); // Paper
 																																// -
 																																// Optimize
 																																// explosions
diff --git a/src/main/java/net/minecraft/server/WorldBorder.java b/src/main/java/net/minecraft/server/WorldBorder.java
index 13f6f2e..8d3c40c 100644
--- a/src/main/java/net/minecraft/server/WorldBorder.java
+++ b/src/main/java/net/minecraft/server/WorldBorder.java
@@ -7,7 +7,7 @@ import com.google.common.collect.Lists;
 
 public class WorldBorder {
 
-	private final List<IWorldBorderListener> a = new java.util.concurrent.CopyOnWriteArrayList<IWorldBorderListener>();
+	private final List<IWorldBorderListener> a = new org.torch.util.ConcurrentIterableArrayList<IWorldBorderListener>();
 	private double b = 0.0D;
 	private double c = 0.0D;
 	private double d = 6.0E7D;
diff --git a/src/main/java/net/minecraft/server/WorldMap.java b/src/main/java/net/minecraft/server/WorldMap.java
index 4c5455c..e9d535c 100644
--- a/src/main/java/net/minecraft/server/WorldMap.java
+++ b/src/main/java/net/minecraft/server/WorldMap.java
@@ -28,7 +28,7 @@ public class WorldMap extends PersistentBase {
 	public List<WorldMap.WorldMapHumanTracker> h = Lists.newArrayList();
 	// public Map<EntityHuman, WorldMap.WorldMapHumanTracker> j =
 	// Maps.newHashMap(); // Spigot
-	public final Map<EntityHuman, WorldMap.WorldMapHumanTracker> j = new net.techcable.pineapple.collect.CopyOnWriteMap();
+	public final Map<EntityHuman, WorldMap.WorldMapHumanTracker> j = new java.util.concurrent.ConcurrentHashMap();
 	// public Map<UUID, MapIcon> decorations = Maps.newLinkedHashMap(); //
 	// Spigot
 	public ConcurrentLinkedHashMap<UUID, MapIcon> decorations = new ConcurrentLinkedHashMap.Builder<UUID, MapIcon>()
diff --git a/src/main/java/net/techcable/pineapple/SneakyThrow.java b/src/main/java/net/techcable/pineapple/SneakyThrow.java
deleted file mode 100644
index 09dbdbc..0000000
--- a/src/main/java/net/techcable/pineapple/SneakyThrow.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/**
- * The MIT License
- * Copyright (c) 2016 Techcable
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- */
-package net.techcable.pineapple;
-
-public class SneakyThrow {
-	public static AssertionError sneakyThrow(Throwable t) {
-		return sneakyThrow0(t);
-	}
-
-	@SuppressWarnings("unchecked")
-	private static <T extends Throwable> AssertionError sneakyThrow0(Throwable t) throws T {
-		throw (T) t;
-	}
-}
diff --git a/src/main/java/net/techcable/pineapple/collect/CopyOnWriteMap.java b/src/main/java/net/techcable/pineapple/collect/CopyOnWriteMap.java
deleted file mode 100644
index 513cd58..0000000
--- a/src/main/java/net/techcable/pineapple/collect/CopyOnWriteMap.java
+++ /dev/null
@@ -1,284 +0,0 @@
-/**
- * The MIT License
- * Copyright (c) 2016 Techcable
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- */
-package net.techcable.pineapple.collect;
-
-import static com.google.common.base.Preconditions.checkNotNull;
-
-import java.util.AbstractMap;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.concurrent.ConcurrentMap;
-import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
-import java.util.function.BiConsumer;
-import java.util.function.BiFunction;
-import java.util.function.Function;
-
-import javax.annotation.Nonnull;
-import javax.annotation.Nullable;
-import javax.annotation.ParametersAreNonnullByDefault;
-
-import com.google.common.collect.ImmutableCollection;
-import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.ImmutableSet;
-
-@ParametersAreNonnullByDefault
-public class CopyOnWriteMap<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V> {
-	@SuppressWarnings("AtomicFieldUpdaterIssues") // Generic.......
-	private static final AtomicReferenceFieldUpdater<CopyOnWriteMap, ImmutableMap> MAP_UPDATER = AtomicReferenceFieldUpdater
-			.newUpdater(CopyOnWriteMap.class, ImmutableMap.class, "bakedMap");
-	private final Map<K, V> map = Collections.synchronizedMap(new HashMap<K, V>());
-	@Nullable
-	private volatile ImmutableMap<K, V> bakedMap = null;
-
-	@Nonnull
-	private ImmutableMap<K, V> bakedMap() {
-		ImmutableMap<K, V> bakedMap = this.bakedMap;
-		if (bakedMap == null) {
-			return bakeMap();
-		} else {
-			return bakedMap;
-		}
-	}
-
-	private ImmutableMap<K, V> bakeMap() {
-		synchronized (map) {
-			return this.bakedMap = ImmutableMap.copyOf(map);
-		}
-	}
-
-	@Override
-	public int size() {
-		return bakedMap().size();
-	}
-
-	@Override
-	public boolean containsKey(Object key) {
-		return bakedMap().containsKey(key);
-	}
-
-	@Override
-	public boolean containsValue(Object value) {
-		return bakedMap().containsValue(value);
-	}
-
-	@Override
-	@Nullable
-	public V get(Object key) {
-		return bakedMap().get(key);
-	}
-
-	@Override
-	@Nullable
-	public V put(K key, V value) {
-		checkNotNull(key, "Null key");
-		checkNotNull(value, "Null value");
-		synchronized (map) {
-			bakedMap = null;
-			return map.put(key, value);
-		}
-	}
-
-	@Override
-	@Nullable
-	public V remove(Object key) {
-		checkNotNull(key, "Null key");
-		synchronized (map) {
-			bakedMap = null;
-			return map.remove(key);
-		}
-	}
-
-	@Override
-	public void putAll(Map<? extends K, ? extends V> m) {
-		checkNotNull(m, "Null bakedMap");
-		synchronized (map) {
-			bakedMap = null;
-			map.putAll(m);
-		}
-	}
-
-	@Override
-	public void clear() {
-		synchronized (map) {
-			bakedMap = ImmutableMap.of();
-		}
-	}
-
-	@Override
-	@Nonnull
-	public ImmutableSet<K> keySet() {
-		return bakedMap().keySet();
-	}
-
-	@Override
-	@Nonnull
-	public ImmutableCollection<V> values() {
-		return bakedMap().values();
-	}
-
-	@Override
-	@Nonnull
-	public ImmutableSet<Entry<K, V>> entrySet() {
-		return bakedMap().entrySet();
-	}
-
-	@Override
-	@Nullable
-	public V getOrDefault(Object key, V defaultValue) {
-		return bakedMap().getOrDefault(checkNotNull(key, "Null key"), defaultValue);
-	}
-
-	@Override
-	public void forEach(BiConsumer<? super K, ? super V> action) {
-		checkNotNull(action, "Null action");
-		ImmutableMaps.forEach(bakedMap(), action);
-	}
-
-	@Override
-	public V putIfAbsent(K key, V value) {
-		checkNotNull(key, "Null key");
-		checkNotNull(value, "Null value");
-		Map<K, V> bakedMap = this.bakedMap;
-		V oldValue;
-		if (bakedMap == null || (oldValue = bakedMap.get(key)) == null) {
-			return putIfAbsent0(key, value);
-		} else {
-			return oldValue;
-		}
-	}
-
-	private V putIfAbsent0(K key, V value) {
-		synchronized (map) {
-			bakedMap = null;
-			return map.putIfAbsent(key, value);
-		}
-	}
-
-	@Override
-	public boolean remove(Object key, Object value) {
-		checkNotNull(key, "Null key");
-		checkNotNull(value, "Null value");
-		synchronized (map) {
-			bakedMap = null;
-			return map.remove(key, value);
-		}
-	}
-
-	@Override
-	public boolean replace(K key, V oldValue, V newValue) {
-		checkNotNull(key, "Null key");
-		checkNotNull(oldValue, "Null old value");
-		checkNotNull(newValue, "Null new value");
-		synchronized (map) {
-			bakedMap = null;
-			return map.replace(key, oldValue, newValue);
-		}
-	}
-
-	@Override
-	@Nullable
-	public V replace(K key, V value) {
-		checkNotNull(key, "Null key");
-		checkNotNull(value, "Null value");
-		synchronized (map) {
-			bakedMap = null;
-			return map.replace(key, value);
-		}
-	}
-
-	@Override
-	public void replaceAll(BiFunction<? super K, ? super V, ? extends V> function) {
-		checkNotNull(function, "Null function");
-		synchronized (map) {
-			bakedMap = null;
-			map.replaceAll(function);
-		}
-	}
-
-	@Override
-	@Nonnull
-	public V computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction) {
-		checkNotNull(key, "Null key");
-		checkNotNull(mappingFunction, "Null function");
-		Map<K, V> bakedMap = this.bakedMap;
-		V value;
-		if (bakedMap == null || (value = bakedMap.get(key)) == null) {
-			return computeIfAbsent0(key, mappingFunction);
-		} else {
-			return value;
-		}
-	}
-
-	@Nonnull
-	private V computeIfAbsent0(K key, Function<? super K, ? extends V> mappingFunction) {
-		synchronized (map) {
-			this.bakedMap = null;
-			V value = map.get(key);
-			if (value == null) {
-				value = mappingFunction.apply(key);
-				if (value == null) {
-					throw new IllegalArgumentException("Mapping function " + mappingFunction.getClass().getTypeName()
-							+ " returned null value for key " + key);
-				}
-			}
-			return value;
-		}
-	}
-
-	@Override
-	@Nullable
-	public V computeIfPresent(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction) {
-		checkNotNull(remappingFunction, "Null remapping function");
-		Map<K, V> bakedMap = this.bakedMap;
-		if (bakedMap == null || bakedMap.get(key) != null) {
-			synchronized (map) {
-				this.bakedMap = null;
-				return map.computeIfPresent(key, remappingFunction);
-			}
-		} else {
-			return null;
-		}
-	}
-
-	@Override
-	public V compute(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction) {
-		checkNotNull(key, "Null key");
-		checkNotNull(remappingFunction, "Null remapping function");
-		synchronized (map) {
-			bakedMap = null;
-			return map.compute(key, remappingFunction);
-		}
-	}
-
-	@Override
-	public V merge(K key, V value, BiFunction<? super V, ? super V, ? extends V> remappingFunction) {
-		checkNotNull(key, "Null key");
-		checkNotNull(value, "Null value");
-		checkNotNull(remappingFunction, "Null remapping function");
-		synchronized (map) {
-			bakedMap = null;
-			return map.merge(key, value, remappingFunction);
-		}
-	}
-}
diff --git a/src/main/java/net/techcable/pineapple/collect/ImmutableLists.java b/src/main/java/net/techcable/pineapple/collect/ImmutableLists.java
deleted file mode 100644
index 01d2fca..0000000
--- a/src/main/java/net/techcable/pineapple/collect/ImmutableLists.java
+++ /dev/null
@@ -1,86 +0,0 @@
-/**
- * The MIT License
- * Copyright (c) 2016 Techcable
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- */
-package net.techcable.pineapple.collect;
-
-import lombok.*;
-
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
-
-import java.lang.invoke.MethodHandle;
-import java.util.List;
-import java.util.function.Function;
-
-import javax.annotation.Nonnull;
-import javax.annotation.ParametersAreNonnullByDefault;
-
-import com.google.common.collect.ImmutableList;
-
-import net.techcable.pineapple.reflection.Reflection;
-
-@ParametersAreNonnullByDefault
-public class ImmutableLists {
-	@Nonnull
-	public static <T, U> ImmutableList<U> transform(List<T> list, Function<T, U> transformer) {
-		ImmutableList.Builder<U> resultBuilder = builder(checkNotNull(list, "Null list").size());
-		list.forEach((oldElement) -> {
-			U newElement = checkNotNull(transformer, "Null transformer").apply(oldElement);
-			if (newElement == null) {
-				throw new NullPointerException(
-						"Transformer  " + transformer.getClass().getTypeName() + " returned null.");
-			}
-			resultBuilder.add(newElement);
-		});
-		return resultBuilder.build();
-	}
-
-	@Nonnull
-	public static <T, U> ImmutableList<U> transform(ImmutableList<T> list, Function<T, U> transformer) {
-		ImmutableList.Builder<U> resultBuilder = builder(checkNotNull(list, "Null list").size());
-		for (int i = 0; i < list.size(); i++) {
-			T oldElement = list.get(i);
-			U newElement = checkNotNull(transformer, "Null transformer").apply(oldElement);
-			if (newElement == null) {
-				throw new NullPointerException(
-						"Transformer  " + transformer.getClass().getTypeName() + " returned null.");
-			}
-			resultBuilder.add(newElement);
-		}
-		return resultBuilder.build();
-	}
-
-	//
-	// Reflection and dark magic
-	//
-
-	private static final MethodHandle BUILDER_CONSTRUCTOR = Reflection.getConstructor(ImmutableList.Builder.class,
-			int.class);
-
-	@SneakyThrows
-	@SuppressWarnings("unchecked")
-	@Nonnull
-    public static <T> ImmutableList.Builder<T> builder(int size) {
-        checkArgument(size >= 0, "Negative size %s", size);
-        return BUILDER_CONSTRUCTOR != null ? (ImmutableList.Builder<T>) BUILDER_CONSTRUCTOR.invokeExact(size) : ImmutableList.builder();
-    }
-}
diff --git a/src/main/java/net/techcable/pineapple/collect/ImmutableMaps.java b/src/main/java/net/techcable/pineapple/collect/ImmutableMaps.java
deleted file mode 100644
index 67552d1..0000000
--- a/src/main/java/net/techcable/pineapple/collect/ImmutableMaps.java
+++ /dev/null
@@ -1,114 +0,0 @@
-/**
- * The MIT License
- * Copyright (c) 2016 Techcable
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- */
-package net.techcable.pineapple.collect;
-
-import lombok.*;
-import lombok.experimental.*;
-
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
-
-import java.lang.invoke.MethodHandle;
-import java.util.Map;
-import java.util.function.BiConsumer;
-import java.util.function.Function;
-
-import javax.annotation.Nonnull;
-import javax.annotation.ParametersAreNonnullByDefault;
-
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap;
-
-import net.techcable.pineapple.reflection.FastField;
-import net.techcable.pineapple.reflection.Reflection;
-
-@ParametersAreNonnullByDefault
-public class ImmutableMaps {
-
-	public static <K1, K2, V> ImmutableMap<K2, V> transformKeys(ImmutableMap<K1, V> original,
-			Function<K1, K2> keyTransformer) {
-		return transform(original, keyTransformer, Function.identity());
-	}
-
-	@Nonnull
-    public static <K1, K2, V1, V2> ImmutableMap<K2, V2> transform(ImmutableMap<K1, V1> original, Function<K1, K2> keyTransformer, Function<V1, V2> valueTransformer) {
-        ImmutableMap.Builder<K2, V2> resultBuilder = builder(checkNotNull(original, "Null map").size());
-        forEach(original, (originalKey, originalValue) -> {
-            K2 newKey = checkNotNull(keyTransformer, "Null key transformer").apply(originalKey);
-            V2 newValue = checkNotNull(valueTransformer, "Null value transformer").apply(originalValue);
-            resultBuilder.put(newKey, newValue);
-        });
-        return resultBuilder.build();
-    }
-
-	//
-	// Dark Magic
-	//
-
-	private static final Class<? extends ImmutableMap> REGULAR_IMMUTABLE_MAP_CLASS = Reflection
-			.getClass("com.google.common.collect.RegularImmutableMap", ImmutableMap.class);
-	private static final MethodHandle BUILDER_CONSTRUCTOR = Reflection.getConstructor(ImmutableMap.Builder.class,
-			int.class);
-	@SuppressWarnings("unchecked")
-	private static final FastField<ImmutableMap, Map.Entry[]> ENTRIES_ARRAY_FIELD = REGULAR_IMMUTABLE_MAP_CLASS != null
-			? FastField.create("entries", (Class<ImmutableMap>) REGULAR_IMMUTABLE_MAP_CLASS, Map.Entry[].class) : null;
-
-	@SneakyThrows
-	@SuppressWarnings("unchecked") // Generics are a lie
-	@Nonnull
-	public static <K, V> ImmutableMap.Builder<K, V> builder(int initialCapacity) {
-		checkArgument(initialCapacity >= 0, "Negative initial capacity %s");
-		return BUILDER_CONSTRUCTOR != null
-				? (ImmutableMap.Builder<K, V>) BUILDER_CONSTRUCTOR.invokeExact(initialCapacity)
-				: ImmutableMap.builder();
-	}
-
-	@SuppressWarnings("unchecked")
-	public static <K, V> void forEach(ImmutableMap<K, V> map, BiConsumer<? super K, ? super V> action) {
-		checkNotNull(map, "Null map");
-		if (ENTRIES_ARRAY_FIELD != null && ENTRIES_ARRAY_FIELD.getDeclaringType().isInstance(map)) {
-			for (Map.Entry<K, V> entry : ENTRIES_ARRAY_FIELD.get(map)) {
-				K key = entry.getKey();
-				V value = entry.getValue();
-				checkNotNull(action, "Null action").accept(key, value);
-			}
-		} else {
-			ImmutableList<Map.Entry<K, V>> entryList = map.entrySet().asList(); // Since
-																				// they
-																				// don't
-																				// support
-																				// forEach
-																				// this
-																				// is
-																				// the
-																				// fastest
-																				// way
-																				// to
-																				// iterate
-			for (int i = 0; i < entryList.size(); i++) {
-				Map.Entry<K, V> entry = entryList.get(i);
-				action.accept(entry.getKey(), entry.getValue());
-			}
-		}
-	}
-}
diff --git a/src/main/java/net/techcable/pineapple/reflection/FastField.java b/src/main/java/net/techcable/pineapple/reflection/FastField.java
deleted file mode 100644
index c97ad98..0000000
--- a/src/main/java/net/techcable/pineapple/reflection/FastField.java
+++ /dev/null
@@ -1,116 +0,0 @@
-/**
- * The MIT License
- * Copyright (c) 2016 Techcable
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- */
-package net.techcable.pineapple.reflection;
-
-import lombok.*;
-
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
-
-import java.lang.reflect.Field;
-import java.lang.reflect.Modifier;
-
-import com.google.common.base.Verify;
-import com.google.common.primitives.Primitives;
-
-import sun.misc.Unsafe;
-
-@Getter
-public class FastField<T, V> {
-	private final Field field;
-	private final Class<T> declaringType;
-	private final Class<V> fieldType;
-
-	private FastField(Field field, Class<T> declaringType, Class<V> fieldType) {
-		this.field = checkNotNull(field, "Null field");
-		this.declaringType = checkNotNull(declaringType, "Null declaring type");
-		this.fieldType = checkNotNull(fieldType, "Null field type");
-		field.setAccessible(true);
-		checkArgument(fieldType.isAssignableFrom(Primitives.wrap(field.getType())));
-		checkArgument(declaringType == field.getDeclaringClass());
-	}
-
-	private static final Unsafe UNSAFE;
-	static {
-		Unsafe u;
-		try {
-			Class.forName("sun.misc.Unsafe");
-			Field field = Unsafe.class.getDeclaredField("theUnsafe");
-			field.setAccessible(true);
-			u = (Unsafe) field.get(null);
-		} catch (ClassNotFoundException | NoSuchFieldException | SecurityException | IllegalAccessException e) {
-			u = null;
-		}
-		UNSAFE = u;
-	}
-
-	public static <T> FastField<T, ?> create(String name, Class<T> declaringType) {
-		return create(name, declaringType, Object.class);
-	}
-
-	public static <T, V> FastField<T, V> create(String name, Class<T> declaringType, Class<V> fieldType) {
-		Field field;
-		try {
-			field = checkNotNull(declaringType, "Null declaring type")
-					.getDeclaredField(checkNotNull(name, "Null fieldName"));
-		} catch (NoSuchFieldException e) {
-			return null;
-		}
-		checkArgument(checkNotNull(fieldType, "Null field type").isAssignableFrom(Primitives.wrap(field.getType())),
-				"Field type %s doesn't equal expected field type %s", fieldType);
-		if (!fieldType.isPrimitive() && UNSAFE != null) {
-			return new UnsafeFastField<>(field, declaringType, fieldType);
-		} else {
-			return new FastField<>(field, declaringType, fieldType);
-		}
-	}
-
-	@SuppressWarnings("unchecked") // The caller will check ;)
-	public V get(T instance) {
-		try {
-			return (V) field.get(instance);
-		} catch (IllegalAccessException e) {
-			throw new AssertionError("Field " + field + " should've been set accessible!");
-		}
-	}
-
-	public static class UnsafeFastField<T, V> extends FastField<T, V> {
-
-		private long fieldOffset;
-
-		private UnsafeFastField(Field field, Class<T> declaringType, Class<V> fieldType) {
-			super(field, declaringType, fieldType);
-			checkArgument(!field.getType().isPrimitive(), "Field is a primitive type %s", field.getType());
-			checkArgument(!Modifier.isStatic(field.getType().getModifiers()), "Static field %s", field);
-			fieldOffset = UNSAFE.objectFieldOffset(field);
-			Verify.verify(fieldOffset >= 0);
-		}
-
-		@Override
-		@SuppressWarnings("unchecked")
-		public V get(T instance) {
-			getDeclaringType().cast(checkNotNull(instance, "Null instance"));
-			return (V) UNSAFE.getObject(instance, fieldOffset);
-		}
-	}
-}
diff --git a/src/main/java/net/techcable/pineapple/reflection/Reflection.java b/src/main/java/net/techcable/pineapple/reflection/Reflection.java
deleted file mode 100644
index b1c5e24..0000000
--- a/src/main/java/net/techcable/pineapple/reflection/Reflection.java
+++ /dev/null
@@ -1,61 +0,0 @@
-/**
- * The MIT License
- * Copyright (c) 2016 Techcable
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- */
-package net.techcable.pineapple.reflection;
-
-import static com.google.common.base.Preconditions.checkNotNull;
-
-import java.lang.invoke.MethodHandle;
-import java.lang.invoke.MethodHandles;
-import java.lang.reflect.Constructor;
-
-import javax.annotation.ParametersAreNonnullByDefault;
-
-@ParametersAreNonnullByDefault
-public class Reflection {
-	public static MethodHandle getConstructor(Class<?> declaringType, Class<?>... parameterTypes) {
-		try {
-			checkNotNull(parameterTypes, "Null parameters");
-			Constructor<?> constructor = checkNotNull(declaringType, "Null declaring type")
-					.getConstructor(parameterTypes);
-			constructor.setAccessible(true);
-			return MethodHandles.lookup().unreflectConstructor(constructor);
-		} catch (NoSuchMethodException e) {
-			return null;
-		} catch (IllegalAccessException e) {
-			throw new AssertionError(e);
-		}
-	}
-
-	public static <T> Class<? extends T> getClass(String name, Class<T> superclass) {
-		Class<?> raw = getClass(name);
-		return raw == null ? null : raw.asSubclass(checkNotNull(superclass, "Null superclass"));
-	}
-
-	public static Class<?> getClass(String name) {
-		try {
-			return Class.forName(checkNotNull(name, "Null name"));
-		} catch (ClassNotFoundException e) {
-			return null;
-		}
-	}
-}
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftZombie.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftZombie.java
index 9dd904a..6c44dee 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftZombie.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftZombie.java
@@ -63,8 +63,7 @@ public class CraftZombie extends CraftMonster implements Zombie {
 
 	@Override
 	public Villager.Profession getVillagerProfession() {
-		// if (!isVillager()) return null; // Torch - better map Zombie/Villager
-		// professions.
-		return Villager.Profession.getProfession(getHandle().getVillagerType());
+		if (!isVillager()) return null;
+        return Villager.Profession.getProfession(getHandle().getVillagerType());
 	}
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/potion/CraftPotionBrewer.java b/src/main/java/org/bukkit/craftbukkit/potion/CraftPotionBrewer.java
index ee34a9e..23d4355 100644
--- a/src/main/java/org/bukkit/craftbukkit/potion/CraftPotionBrewer.java
+++ b/src/main/java/org/bukkit/craftbukkit/potion/CraftPotionBrewer.java
@@ -14,7 +14,6 @@ import com.google.common.collect.ImmutableList;
 
 import net.minecraft.server.MobEffect;
 import net.minecraft.server.PotionRegistry;
-import net.techcable.pineapple.collect.CopyOnWriteMap;
 
 public class CraftPotionBrewer implements PotionBrewer {
 	// private static final Map<PotionType, Collection<PotionEffect>> cache =
@@ -22,7 +21,7 @@ public class CraftPotionBrewer implements PotionBrewer {
 	// pivate static final ConcurrentMap<PotionType, Collection<PotionEffect>>
 	// cache = new ConcurrentHashMap<PotionType, Collection<PotionEffect>>(); //
 	// Hose
-	private static final CopyOnWriteMap<PotionType, Collection<PotionEffect>> cache = new CopyOnWriteMap<PotionType, Collection<PotionEffect>>(); // Torch
+	private static final java.util.concurrent.ConcurrentHashMap<PotionType, Collection<PotionEffect>> cache = new java.util.concurrent.ConcurrentHashMap<PotionType, Collection<PotionEffect>>(); // Torch
 
 	@Override
 	public Collection<PotionEffect> getEffects(PotionType damage, boolean upgraded, boolean extended) {
diff --git a/src/main/java/org/bukkit/craftbukkit/scheduler/CraftScheduler.java b/src/main/java/org/bukkit/craftbukkit/scheduler/CraftScheduler.java
index 6cbb5a9..8bb8ceb 100644
--- a/src/main/java/org/bukkit/craftbukkit/scheduler/CraftScheduler.java
+++ b/src/main/java/org/bukkit/craftbukkit/scheduler/CraftScheduler.java
@@ -83,7 +83,7 @@ public class CraftScheduler implements BukkitScheduler {
 	 * These are tasks that are currently active. It's provided for 'viewing'
 	 * the current state.
 	 */
-	private final net.techcable.pineapple.collect.CopyOnWriteMap<Integer, CraftTask> runners = new net.techcable.pineapple.collect.CopyOnWriteMap<Integer, CraftTask>();
+	private final java.util.concurrent.ConcurrentHashMap<Integer, CraftTask> runners = new java.util.concurrent.ConcurrentHashMap<Integer, CraftTask>();
 	private volatile int currentTick = -1;
 	private final Executor executor = Executors
 			.newCachedThreadPool(new com.google.common.util.concurrent.ThreadFactoryBuilder()
diff --git a/src/main/java/org/bukkit/permissions/PermissibleBase.java b/src/main/java/org/bukkit/permissions/PermissibleBase.java
index 35632ae..82c4bc7 100644
--- a/src/main/java/org/bukkit/permissions/PermissibleBase.java
+++ b/src/main/java/org/bukkit/permissions/PermissibleBase.java
@@ -10,8 +10,6 @@ import java.util.logging.Level;
 import org.bukkit.Bukkit;
 import org.bukkit.plugin.Plugin;
 
-import net.techcable.pineapple.collect.CopyOnWriteMap;
-
 /**
  * Base Permissible for use in any Permissible object via proxy or extension
  */
@@ -19,7 +17,7 @@ public class PermissibleBase implements Permissible {
 	private ServerOperator opable = null;
 	private Permissible parent = this;
 	private final List<PermissionAttachment> attachments = new LinkedList<PermissionAttachment>();
-	private final Map<String, PermissionAttachmentInfo> permissions = new CopyOnWriteMap<String, PermissionAttachmentInfo>();
+	private final Map<String, PermissionAttachmentInfo> permissions = new java.util.concurrent.ConcurrentHashMap<String, PermissionAttachmentInfo>();
 	// private final Map<String, PermissionAttachmentInfo> permissions = new
 	// HashMap<String, PermissionAttachmentInfo>();
 
diff --git a/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java b/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java
index 4e60654..db813aa 100644
--- a/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java
+++ b/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java
@@ -45,7 +45,7 @@ import org.yaml.snakeyaml.error.YAMLException;
 public final class JavaPluginLoader implements PluginLoader {
 	final Server server;
 	private final Pattern[] fileFilters = new Pattern[] { Pattern.compile("\\.jar$"), };
-	private final Map<String, Class<?>> classes = new net.techcable.pineapple.collect.CopyOnWriteMap<String, Class<?>>(); // Spigot
+	private final Map<String, Class<?>> classes = new java.util.concurrent.ConcurrentHashMap<String, Class<?>>(); // Spigot
 	private final Map<String, PluginClassLoader> loaders = new LinkedHashMap<String, PluginClassLoader>();
 
 	/**
diff --git a/src/main/java/org/bukkit/plugin/java/PluginClassLoader.java b/src/main/java/org/bukkit/plugin/java/PluginClassLoader.java
index 80dcae5..17e4d62 100644
--- a/src/main/java/org/bukkit/plugin/java/PluginClassLoader.java
+++ b/src/main/java/org/bukkit/plugin/java/PluginClassLoader.java
@@ -20,7 +20,7 @@ public final class PluginClassLoader extends URLClassLoader { // Spigot
 	} // Spigot
 
 	private final JavaPluginLoader loader;
-	private final Map<String, Class<?>> classes = new net.techcable.pineapple.collect.CopyOnWriteMap<String, Class<?>>(); // Spigot
+	private final Map<String, Class<?>> classes = new  java.util.concurrent.ConcurrentHashMap<String, Class<?>>(); // Spigot
 	private final PluginDescriptionFile description;
 	private final File dataFolder;
 	private final File file;
diff --git a/src/main/java/org/torch/util/ConcurrentIterableArrayList.java b/src/main/java/org/torch/util/ConcurrentIterableArrayList.java
new file mode 100644
index 0000000..e2fd90d
--- /dev/null
+++ b/src/main/java/org/torch/util/ConcurrentIterableArrayList.java
@@ -0,0 +1,40 @@
+package org.torch.util;
+
+/**
+ * From TickThreading project.
+ * @Link: https://github.com/nallar/TickThreading
+ */
+
+import java.util.*;
+
+public class ConcurrentIterableArrayList<T> extends ArrayList<T> {
+	private static final long serialVersionUID = 0;
+	private int index;
+
+	public synchronized void reset() {
+		index = 0;
+	}
+
+	public synchronized T next() {
+		return index < size() ? this.get(index++) : null;
+	}
+
+	@Override
+	public synchronized T remove(int index) {
+		if (index < this.index) {
+			this.index--;
+		}
+		return super.remove(index);
+	}
+
+	@Override
+	public boolean remove(Object o) {
+		for (int index = 0; index < size(); index++) {
+			if (o.equals(get(index))) {
+				remove(index);
+				return true;
+			}
+		}
+		return false;
+	}
+}
\ No newline at end of file
-- 
2.8.2.windows.1

