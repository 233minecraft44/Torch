From b4045946681e0092c0e0417216377f8a929c7356 Mon Sep 17 00:00:00 2001
From: Techcable <Techcable@outlook.com>
Date: Thu, 19 Mar 2015 19:41:15 -0500
Subject: [PATCH] TacoSpigot changes

Sometimes fernflower makes mistakes too

Every tick hoppers try and find an block-inventory to extract from.
If no tile entity is above the hopper (which there often isn't) it will do a bounding box search for minecart chests and minecart hoppers.
If it can't find an inventory, it will then look for a dropped item, which is another bounding box search.
This patch eliminates that expensive check by having dropped items and minecart hoppers/chests look for hoppers instead.
Hoppers are tile entities meaning you can do a simple tile entity lookup to find the nearest hopper in range.
Pushing out of hoppers causes a bouding box lookup, which this patch replaces with a tile entity lookup.

This patch may causes a decrease in the performance of dropped items, which is why it can be disabled in the configuration.

Armor stands try and move() every tick, which can add up fast on creative servers with a lot of armor stands.
This patch adds an option to prevent armor stands from moving.
This patch also avoids armor stands looking up entities, which provides
most of the benefits of avoiding move() while keeping gravity.

Even with no listeners, InventoryMoveItemEvent hurts performance.
This patch prevents the event from firing if there are no listeners
Some plugins offer no way to disable their IMIE listeners. (See WorldGuard-3520)
This patch adds a per-world flag to disable InventoryMoveItemEvent for hoppers.

Async catching for PlayerChunkMap

It uses a special data structure that is a combination of a lookup table and a binary search. Most blockstates have sequental ids, so they can go in a lookup table. However, there are some blockstates that are not sequental, which are stuffed into a seperate sorted array, and then do a binary search over that.
This data structure is usualy faster than a hashmap (especially when using the lookup table), and since the array we binary search over is so small.

Should help with redstone.

diff --git a/pom.xml b/pom.xml
index 79d2171..927418f 100644
--- a/pom.xml
+++ b/pom.xml
@@ -1,12 +1,12 @@
 <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
     <modelVersion>4.0.0</modelVersion>
-    <groupId>com.destroystokyo.paper</groupId>
-    <artifactId>paper</artifactId>
+    <groupId>net.techcable.tacospigot</groupId>
+    <artifactId>server</artifactId>
     <packaging>jar</packaging>
-    <version>1.9.4-R0.1-SNAPSHOT</version>
-    <name>Paper</name>
-    <url>https://github.com/PaperSpigot/Paper</url>
+    <version>1.9.4-R0.1</version>
+    <name>TacoSpigot</name>
+    <url>https://github.com/TacoSpigot/TacoSpigot</url>
 
     <properties>
         <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
@@ -21,16 +21,16 @@
     </properties>
 
     <parent>
-        <groupId>com.destroystokyo.paper</groupId>
-        <artifactId>paper-parent</artifactId>
+        <groupId>net.techcable.tacospigot</groupId>
+        <artifactId>parent</artifactId>
         <version>dev-SNAPSHOT</version>
         <relativePath>../pom.xml</relativePath>
     </parent>
 
     <dependencies>
         <dependency>
-            <groupId>com.destroystokyo.paper</groupId>
-            <artifactId>paper-api</artifactId>
+            <groupId>net.techcable.tacospigot</groupId>
+            <artifactId>tacospigot-api</artifactId>
             <version>${project.version}</version>
             <scope>compile</scope>
         </dependency>
@@ -108,7 +108,7 @@
                 <artifactId>gitdescribe-maven-plugin</artifactId>
                 <version>1.3</version>
                 <configuration>
-                    <outputPrefix>git-Paper-</outputPrefix>
+                    <outputPrefix>git-TacoSpigot-</outputPrefix>
                     <scmDirectory>..</scmDirectory>
                 </configuration>
                 <executions>
@@ -119,7 +119,7 @@
                         </goals>
                     </execution>
                 </executions>
-            </plugin>  
+            </plugin>
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-jar-plugin</artifactId>
diff --git a/src/main/java/net/minecraft/server/BlockState.java b/src/main/java/net/minecraft/server/BlockState.java
index e1261f5..5ea4b36 100644
--- a/src/main/java/net/minecraft/server/BlockState.java
+++ b/src/main/java/net/minecraft/server/BlockState.java
@@ -2,14 +2,44 @@ package net.minecraft.server;
 
 import com.google.common.base.Objects;
 
+// TacoSpigot start
+import java.util.Arrays;
+// TacoSpigot end
+
 public abstract class BlockState<T extends Comparable<T>> implements IBlockState<T> {
 
     private final Class<T> a;
     private final String b;
+    // TacoSpigot start
+    private static int nextId = 0;
+    private final int id;
+
+    @Override
+    public int getId() {
+        return id;
+    }
+
+    private static BlockState[] byId = new BlockState[0];
+
+    public static BlockState getById(int id) {
+        if (id < 0) {
+            throw new IllegalArgumentException("Negative id: " + id);
+        } else if (id < byId.length) {
+            return byId[id];
+        } else {
+            return null;
+        }
+    }
+    // TacoSpigot end
 
     protected BlockState(String s, Class<T> oclass) {
         this.a = oclass;
         this.b = s;
+        // TacoSpigot start
+        id = nextId++;
+        if (id >= byId.length) byId = Arrays.copyOf(byId, id + 1);
+        byId[id] = this;
+        // TacoSpigot end
     }
 
     public String a() {
diff --git a/src/main/java/net/minecraft/server/BlockStateBoolean.java b/src/main/java/net/minecraft/server/BlockStateBoolean.java
index 6c4b26b..fc4490f 100644
--- a/src/main/java/net/minecraft/server/BlockStateBoolean.java
+++ b/src/main/java/net/minecraft/server/BlockStateBoolean.java
@@ -35,6 +35,25 @@ public class BlockStateBoolean extends BlockState<Boolean> {
         }
     }
 
+    // TacoSpigot start
+    @Override
+    public int getValueId(Boolean value) {
+        return value ? 1 : 0;
+    }
+
+    @Override
+    public Boolean getByValueId(int id) {
+        switch (id) {
+            case 0:
+                return false;
+            case 1:
+                return true;
+            default:
+                throw new IllegalArgumentException("Invalid id: " + id);
+        }
+    }
+    // TacoSpigot end
+
     public int hashCode() {
         return 31 * super.hashCode() + this.a.hashCode();
     }
diff --git a/src/main/java/net/minecraft/server/BlockStateEnum.java b/src/main/java/net/minecraft/server/BlockStateEnum.java
index d708a7e..c6c18f1 100644
--- a/src/main/java/net/minecraft/server/BlockStateEnum.java
+++ b/src/main/java/net/minecraft/server/BlockStateEnum.java
@@ -21,7 +21,7 @@ public class BlockStateEnum<T extends Enum<T> & INamable> extends BlockState<T>
         Iterator iterator = collection.iterator();
 
         while (iterator.hasNext()) {
-            Enum oenum = (Enum) iterator.next();
+            T oenum = (T) iterator.next(); // TacoSpigot - fix decompile error
             String s1 = ((INamable) oenum).getName();
 
             if (this.b.containsKey(s1)) {
@@ -36,11 +36,28 @@ public class BlockStateEnum<T extends Enum<T> & INamable> extends BlockState<T>
     public Collection<T> c() {
         return this.a;
     }
-
     public String a(T t0) {
         return ((INamable) t0).getName();
     }
 
+    // TacoSpigot start
+    @Override
+    public int
+getValueId(T value) {
+        return value.ordinal();
+    }
+
+    @Override
+    public T getByValueId(int id) {
+        T[] values = this.b().getEnumConstants();
+        if (id >= 0 && id < values.length) {
+            return values[id];
+        } else {
+            throw new IllegalArgumentException("Invalid id: " + id);
+        }
+    }
+    // TacoSpigot end
+
     public boolean equals(Object object) {
         if (this == object) {
             return true;
diff --git a/src/main/java/net/minecraft/server/BlockStateInteger.java b/src/main/java/net/minecraft/server/BlockStateInteger.java
index 66a1496..835b5d6 100644
--- a/src/main/java/net/minecraft/server/BlockStateInteger.java
+++ b/src/main/java/net/minecraft/server/BlockStateInteger.java
@@ -8,9 +8,40 @@ import java.util.HashSet;
 public class BlockStateInteger extends BlockState<Integer> {
 
     private final ImmutableSet<Integer> a;
+    // TacoSpigot start
+    private final int min, max;
+    private final int range;
+
+    @Override
+    public int getValueId(Integer value) {
+        if (value < min) {
+            throw new IllegalArgumentException("Too small: " + value);
+        } else if (value > max) {
+            throw new IllegalArgumentException("Too large: " + value);
+        } else {
+            return value - min;
+        }
+    }
+
+    @Override
+    public Integer getByValueId(int id) {
+        if (id < 0) {
+            throw new IllegalArgumentException("Negative id: " + id);
+        } else if (id > range) {
+            throw new IllegalArgumentException("Id is out of range: " + id);
+        } else {
+            return id;
+        }
+    }
+    // TacoSpigot end
 
     protected BlockStateInteger(String s, int i, int j) {
         super(s, Integer.class);
+        // TacoSpigot start
+        this.min = i;
+        this.max = j;
+        this.range = (max - min); // min and max are _both_ inclusive (there's a reason you're not supposed to do this :p)
+        // TacoSpigot end
         if (i < 0) {
             throw new IllegalArgumentException("Min value of " + s + " must be 0 or greater");
         } else if (j <= i) {
diff --git a/src/main/java/net/minecraft/server/BlockStateList.java b/src/main/java/net/minecraft/server/BlockStateList.java
index 4082cff..874592b 100644
--- a/src/main/java/net/minecraft/server/BlockStateList.java
+++ b/src/main/java/net/minecraft/server/BlockStateList.java
@@ -23,6 +23,16 @@ import java.util.Map.Entry;
 import java.util.regex.Pattern;
 import javax.annotation.Nullable;
 
+// TacoSpigot start
+import com.google.common.collect.Table;
+
+import java.util.function.ToIntBiFunction;
+
+import net.techcable.tacospigot.ImmutableArrayMap;
+import net.techcable.tacospigot.ImmutableArrayTable;
+import net.techcable.tacospigot.TacoSpigotConfig;
+// TacoSpigot end
+
 public class BlockStateList {
 
     private static final Pattern a = Pattern.compile("^[a-z0-9_]+$");
@@ -85,7 +95,7 @@ public class BlockStateList {
         if (!BlockStateList.a.matcher(s).matches()) {
             throw new IllegalArgumentException("Block: " + block.getClass() + " has invalidly named property: " + s);
         } else {
-            Iterator iterator = iblockstate.c().iterator();
+            Iterator<T> iterator = iblockstate.c().iterator(); // TacoSpigot - generic iterator
 
             String s1;
 
@@ -94,7 +104,7 @@ public class BlockStateList {
                     return s;
                 }
 
-                Comparable comparable = (Comparable) iterator.next();
+                T comparable = iterator.next(); // TacoSpigot - fix fernflower error
 
                 s1 = iblockstate.a(comparable);
             } while (BlockStateList.a.matcher(s1).matches());
@@ -140,12 +150,22 @@ public class BlockStateList {
     static class BlockData extends BlockDataAbstract {
 
         private final Block a;
-        private final ImmutableMap<IBlockState<?>, Comparable<?>> b;
-        private ImmutableTable<IBlockState<?>, Comparable<?>, IBlockData> c;
+        // TacoSpigot start
+        private final ImmutableMap<IBlockState<?>, Comparable<?>> bAsImmutableMap;
+        private final Map<IBlockState<?>, Comparable<?>> b;
+        private Table<IBlockState<?>, Comparable<?>, IBlockData> c;
+        // TacoSpigot end
 
         private BlockData(Block block, ImmutableMap<IBlockState<?>, Comparable<?>> immutablemap) {
             this.a = block;
-            this.b = immutablemap;
+            // TacoSpigot start
+            this.bAsImmutableMap = immutablemap;
+            if (TacoSpigotConfig.useArraysForBlockStates) {
+                b = new ImmutableArrayMap<>(IBlockState.INDEXER, BlockState::getById, immutablemap);
+            } else {
+                b = immutablemap;
+            }
+            // TacoSpigot end
         }
 
         public Collection<IBlockState<?>> r() {
@@ -158,7 +178,7 @@ public class BlockStateList {
             if (comparable == null) {
                 throw new IllegalArgumentException("Cannot get property " + iblockstate + " as it does not exist in " + this.a.t());
             } else {
-                return (Comparable) iblockstate.b().cast(comparable);
+                return iblockstate.b().cast(comparable); // TacoSpigot - fix fernflower error
             }
         }
 
@@ -181,7 +201,7 @@ public class BlockStateList {
         }
 
         public ImmutableMap<IBlockState<?>, Comparable<?>> s() {
-            return this.b;
+            return this.bAsImmutableMap; // TacoSpigot
         }
 
         public Block getBlock() {
@@ -211,19 +231,33 @@ public class BlockStateList {
                     while (iterator1.hasNext()) {
                         Comparable comparable = (Comparable) iterator1.next();
 
-                        if (comparable != entry.getValue()) {
+                        if (true) { // TacoSpigot - include everything in the table
                             hashbasedtable.put(iblockstate, comparable, map.get(this.b(iblockstate, comparable)));
                         }
                     }
                 }
 
-                this.c = ImmutableTable.copyOf(hashbasedtable);
+                // TacoSpigot start
+                if (TacoSpigotConfig.useArraysForBlockStates) {
+                    // I had some 'fun' getting this to work >:(
+                    this.c = new ImmutableArrayTable<IBlockState<?>, Comparable<?>, IBlockData> (
+                            IBlockState.INDEXER,
+                            BlockState::getById,
+                            (ToIntBiFunction) ((ToIntBiFunction<IBlockState, Comparable>) ((IBlockState state, Comparable value) -> state.getValueId(value))),
+                            IBlockState::getByValueId,
+                            hashbasedtable
+                    );
+                } else {
+                    this.c = ImmutableTable.copyOf(hashbasedtable);
+                }
+                // TacoSpigot end
             }
         }
 
         private Map<IBlockState<?>, Comparable<?>> b(IBlockState<?> iblockstate, Comparable<?> comparable) {
             HashMap hashmap = Maps.newHashMap(this.b);
 
+
             hashmap.put(iblockstate, comparable);
             return hashmap;
         }
diff --git a/src/main/java/net/minecraft/server/Container.java b/src/main/java/net/minecraft/server/Container.java
index fd226f1..2757f58 100644
--- a/src/main/java/net/minecraft/server/Container.java
+++ b/src/main/java/net/minecraft/server/Container.java
@@ -22,7 +22,14 @@ import org.bukkit.inventory.InventoryView;
 public abstract class Container {
 
     public List<ItemStack> b = Lists.newArrayList();
-    public List<Slot> c = Lists.newArrayList();
+    // TacoSpigot start - A lot of code expects get() to return null rather than throwing ArrayIndexOutOfBoundsException
+    public List<Slot> c = new ArrayList<Slot>() {
+        @Override
+        public Slot get(int index) {
+            return index < size() ? super.get(index) : null;
+        }
+    };
+    // TacoSpigot end
     public int windowId;
     private int dragType = -1;
     private int g;
diff --git a/src/main/java/net/minecraft/server/EntityArmorStand.java b/src/main/java/net/minecraft/server/EntityArmorStand.java
index fcd73e1..1691841 100644
--- a/src/main/java/net/minecraft/server/EntityArmorStand.java
+++ b/src/main/java/net/minecraft/server/EntityArmorStand.java
@@ -751,6 +751,14 @@ public class EntityArmorStand extends EntityLiving {
         return false;
     }
 
+    // TacoSpigot start - add an option to make armor stands not move
+    @Override
+    public void move(double motX, double motY, double motZ) {
+        if (getWorld().tacoSpigotConfig.optimizeArmorStandMovement) return;
+        super.move(motX, motY, motZ);
+    }
+    // TacoSpigot end
+
     static class SyntheticClass_1 {
 
         static final int[] a = new int[EnumItemSlot.Function.values().length];
diff --git a/src/main/java/net/minecraft/server/EntityArrow.java b/src/main/java/net/minecraft/server/EntityArrow.java
index 069a1b7..e298b30 100644
--- a/src/main/java/net/minecraft/server/EntityArrow.java
+++ b/src/main/java/net/minecraft/server/EntityArrow.java
@@ -10,6 +10,11 @@ import org.bukkit.entity.LivingEntity;
 import org.bukkit.event.entity.EntityCombustByEntityEvent;
 import org.bukkit.event.player.PlayerPickupArrowEvent;
 // CraftBukkit end
+// TacoSpigot start
+import net.techcable.tacospigot.event.entity.ArrowCollideEvent;
+import org.bukkit.entity.Arrow;
+// TacoSpigot end
+
 
 public abstract class EntityArrow extends Entity implements IProjectile {
 
@@ -193,6 +198,16 @@ public abstract class EntityArrow extends Entity implements IProjectile {
             }
             // Paper end
 
+            // TacoSpigot start - fire collide event
+            if (movingobjectposition != null && movingobjectposition.entity != null) {
+                ArrowCollideEvent event = new ArrowCollideEvent((Arrow) this.getBukkitEntity(), movingobjectposition.entity.getBukkitEntity());
+                this.world.getServer().getPluginManager().callEvent(event);
+                if (event.isCancelled()) {
+                    movingobjectposition = null;
+                }
+            }
+            // TacoSpigot end
+
             if (movingobjectposition != null) {
                 this.a(movingobjectposition);
             }
diff --git a/src/main/java/net/minecraft/server/EntityHuman.java b/src/main/java/net/minecraft/server/EntityHuman.java
index 696f21f..e24c2c5 100644
--- a/src/main/java/net/minecraft/server/EntityHuman.java
+++ b/src/main/java/net/minecraft/server/EntityHuman.java
@@ -24,6 +24,8 @@ import org.bukkit.event.player.PlayerVelocityEvent;
 import org.bukkit.util.Vector;
 // CraftBukkit end
 
+import static net.techcable.tacospigot.TacoSpigotConfig.betterPvp; // TacoSpigot
+
 public abstract class EntityHuman extends EntityLiving {
 
     private static final DataWatcherObject<Float> a = DataWatcher.a(EntityHuman.class, DataWatcherRegistry.c);
@@ -67,6 +69,8 @@ public abstract class EntityHuman extends EntityLiving {
     private final ItemCooldown bV = this.l();
     public EntityFishingHook hookedFish;
 
+    public int clientTicksSinceLastAttack; // TacoSpigot
+
     // Paper start - affectsSpawning API
     public boolean affectsSpawning = true;
 
@@ -1897,11 +1901,12 @@ public abstract class EntityHuman extends EntityLiving {
     }
 
     public float o(float f) {
-        return MathHelper.a(((float) this.aE + f) / this.cZ(), 0.0F, 1.0F);
+        return MathHelper.a(((float) (betterPvp ? Math.max(this.aE, this.clientTicksSinceLastAttack) : this.aE) + f) / this.cZ(), 0.0F, 1.0F); // TacoSpigot - check client and server ticks
     }
 
     public void da() {
         this.aE = 0;
+        this.clientTicksSinceLastAttack = 0; // TacoSpigot
     }
 
     public ItemCooldown db() {
diff --git a/src/main/java/net/minecraft/server/EntityItem.java b/src/main/java/net/minecraft/server/EntityItem.java
index 0b11fd7..26f7f6c 100644
--- a/src/main/java/net/minecraft/server/EntityItem.java
+++ b/src/main/java/net/minecraft/server/EntityItem.java
@@ -6,8 +6,15 @@ import javax.annotation.Nullable;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import org.bukkit.event.player.PlayerPickupItemEvent; // CraftBukkit
+import net.techcable.tacospigot.HopperPusher; // TacoSpigot
 
-public class EntityItem extends Entity {
+// TacoSpigot start - implement HopperPusher
+public class EntityItem extends Entity implements HopperPusher {
+    @Override
+    public boolean acceptItem(TileEntityHopper hopper) {
+        return TileEntityHopper.a(hopper, this);
+    }
+// TacoSpigot end
 
     private static final Logger b = LogManager.getLogger();
     private static final DataWatcherObject<Optional<ItemStack>> c = DataWatcher.a(EntityItem.class, DataWatcherRegistry.f);
@@ -63,6 +70,7 @@ public class EntityItem extends Entity {
             this.die();
         } else {
             super.m();
+            if (tryPutInHopper()) return; // TacoSpigot
             // CraftBukkit start - Use wall time for pickup and despawn timers
             int elapsedTicks = MinecraftServer.currentTick - this.lastTick;
             if (this.pickupDelay != 32767) this.pickupDelay -= elapsedTicks;
@@ -127,6 +135,7 @@ public class EntityItem extends Entity {
     // Spigot start - copied from above
     @Override
     public void inactiveTick() {
+        if (tryPutInHopper()) return; // TacoSpigot
         // CraftBukkit start - Use wall time for pickup and despawn timers
         int elapsedTicks = MinecraftServer.currentTick - this.lastTick;
         if (this.pickupDelay != 32767) this.pickupDelay -= elapsedTicks;
diff --git a/src/main/java/net/minecraft/server/EntityLiving.java b/src/main/java/net/minecraft/server/EntityLiving.java
index c4c0308..c1b98cf 100644
--- a/src/main/java/net/minecraft/server/EntityLiving.java
+++ b/src/main/java/net/minecraft/server/EntityLiving.java
@@ -1131,7 +1131,7 @@ public abstract class EntityLiving extends Entity {
     protected float applyArmorModifier(DamageSource damagesource, float f) {
         if (!damagesource.ignoresArmor()) {
             // this.damageArmor(f); // CraftBukkit - Moved into damageEntity0(DamageSource, float)
-            f = CombatMath.a(f, (float) this.getArmorStrength());
+            f = CombatMath.a(f, (float) this.getArmorStrength(), (float) this.getAttributeInstance(GenericAttributes.h).getValue()); // TacoSpigot - take armor toughness into account
         }
 
         return f;
diff --git a/src/main/java/net/minecraft/server/EntityMinecartContainer.java b/src/main/java/net/minecraft/server/EntityMinecartContainer.java
index 9162348..c5bac00 100644
--- a/src/main/java/net/minecraft/server/EntityMinecartContainer.java
+++ b/src/main/java/net/minecraft/server/EntityMinecartContainer.java
@@ -13,8 +13,27 @@ import org.bukkit.craftbukkit.entity.CraftHumanEntity;
 import org.bukkit.entity.HumanEntity;
 import org.bukkit.inventory.InventoryHolder;
 // CraftBukkit end
+import net.techcable.tacospigot.HopperPusher; // TacoSpigot
 
-public abstract class EntityMinecartContainer extends EntityMinecartAbstract implements ITileInventory, ILootable, CraftLootableInventory { // Paper
+// TacoSpigot start - push into hoppers
+public abstract class EntityMinecartContainer extends EntityMinecartAbstract implements ITileInventory, ILootable, CraftLootableInventory, HopperPusher { // Paper - CraftLootableInventory
+    @Override
+    public boolean acceptItem(TileEntityHopper hopper) {
+        return TileEntityHopper.acceptItem(hopper, this);
+    }
+
+    @Override
+    public void m() {
+        super.m();
+        tryPutInHopper();
+    }
+
+    @Override
+    public void inactiveTick() {
+        super.inactiveTick();
+        tryPutInHopper();
+    }
+    // TacoSpigot end
 
     private ItemStack[] items = new ItemStack[27]; // CraftBukkit - 36 -> 27
     private boolean b = true;
diff --git a/src/main/java/net/minecraft/server/IBlockState.java b/src/main/java/net/minecraft/server/IBlockState.java
index 7e35d33..67e12b6 100644
--- a/src/main/java/net/minecraft/server/IBlockState.java
+++ b/src/main/java/net/minecraft/server/IBlockState.java
@@ -2,6 +2,10 @@ package net.minecraft.server;
 
 import java.util.Collection;
 
+// TacoSpigot start
+import net.techcable.tacospigot.Indexer;
+// TacoSpigot end
+
 public interface IBlockState<T extends Comparable<T>> {
 
     String a();
@@ -11,4 +15,20 @@ public interface IBlockState<T extends Comparable<T>> {
     Class<T> b();
 
     String a(T t0);
+
+    // TacoSpigot start
+    @SuppressWarnings("Convert2Lambda") // We have to use anon for performance reasons :/
+    public static final Indexer<IBlockState<?>> INDEXER = new Indexer<IBlockState<?>>() {
+        @Override
+        public int getId(IBlockState<?> state) {
+            return state.getId();
+        }
+    };
+
+    public int getId();
+
+    public int getValueId(T value);
+
+    public T getByValueId(int id);
+    // TacoSpigot end
 }
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 8df9f38..15cabf2 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -567,7 +567,7 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
         }
     }
     // Paper End
- 
+
     public void run() {
         try {
             if (this.init()) {
@@ -1087,7 +1087,7 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
     }
 
     public String getServerModName() {
-        return "Paper"; //Paper - Paper > // Spigot - Spigot > // CraftBukkit - cb > vanilla!
+        return "TacoSpigot"; // TacoSpigot - TacoSpigot > //Paper - Paper > // Spigot - Spigot > // CraftBukkit - cb > vanilla!
     }
 
     public CrashReport b(CrashReport crashreport) {
diff --git a/src/main/java/net/minecraft/server/PacketEncoder.java b/src/main/java/net/minecraft/server/PacketEncoder.java
index a79fa01..a21743d 100644
--- a/src/main/java/net/minecraft/server/PacketEncoder.java
+++ b/src/main/java/net/minecraft/server/PacketEncoder.java
@@ -19,7 +19,7 @@ public class PacketEncoder extends MessageToByteEncoder<Packet<?>> {
         this.c = enumprotocoldirection;
     }
 
-    protected void a(ChannelHandlerContext channelhandlercontext, Packet<?> packet, ByteBuf bytebuf) throws Exception {
+    protected void encode(ChannelHandlerContext channelhandlercontext, Packet<?> packet, ByteBuf bytebuf) throws Exception { // TacoSpigot - fix decompiler issue
         Integer integer = ((EnumProtocol) channelhandlercontext.channel().attr(NetworkManager.c).get()).a(this.c, packet);
 
         if (PacketEncoder.a.isDebugEnabled()) {
@@ -42,7 +42,11 @@ public class PacketEncoder extends MessageToByteEncoder<Packet<?>> {
         }
     }
 
+    // TacoSpigot start - remove decompiler error
+    /*
     protected void encode(ChannelHandlerContext channelhandlercontext, Object object, ByteBuf bytebuf) throws Exception {
         this.a(channelhandlercontext, (Packet) object, bytebuf);
     }
+    */
+    // TacoSpigot end
 }
diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java
index 20a8a80..1bd4173 100644
--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java
@@ -19,6 +19,9 @@ import javax.annotation.Nullable;
 // CraftBukkit start
 import java.util.LinkedList;
 // CraftBukkit end
+// TacoSpigot start
+import org.spigotmc.AsyncCatcher;
+// TacoSpigot end
 
 public class PlayerChunkMap {
 
@@ -41,12 +44,14 @@ public class PlayerChunkMap {
         }
     };
     private final WorldServer world;
-    private final List<EntityPlayer> managedPlayers = Lists.newArrayList();
+    // TacoSpigot start - catch async access
+    private final List<EntityPlayer> managedPlayers = AsyncCatcher.catchAsyncUsage(Lists.newArrayList(), "list access PlayerChunkMap.managedPlayers");
     private final Long2ObjectMap<PlayerChunk> e = new Long2ObjectOpenHashMap(4096);
-    private final Set<PlayerChunk> f = Sets.newHashSet();
-    private final List<PlayerChunk> g = Lists.newLinkedList();
-    private final List<PlayerChunk> h = Lists.newLinkedList();
-    private final List<PlayerChunk> i = Lists.newArrayList();
+    private final Set<PlayerChunk> f = AsyncCatcher.catchAsyncUsage(Sets.newHashSet(), "set access PlayerChunkMap.f");
+    private final List<PlayerChunk> g = AsyncCatcher.catchAsyncUsage(Lists.newLinkedList(), "list access PlayerChunkMap.g");
+    private final List<PlayerChunk> h = AsyncCatcher.catchAsyncUsage(Lists.newLinkedList(), "list access PlayerChunkMap.h");
+    private final List<PlayerChunk> i = AsyncCatcher.catchAsyncUsage(Lists.newArrayList(), "list access PlayerChunkMap.i");
+    // TacoSpigot end
     private int j;public int getViewDistance() { return j; } // Paper OBFHELPER
     private long k;
     private boolean l = true;
diff --git a/src/main/java/net/minecraft/server/PlayerConnection.java b/src/main/java/net/minecraft/server/PlayerConnection.java
index 16db36e..623ebf8 100644
--- a/src/main/java/net/minecraft/server/PlayerConnection.java
+++ b/src/main/java/net/minecraft/server/PlayerConnection.java
@@ -459,6 +459,8 @@ public class PlayerConnection implements PacketListenerPlayIn, ITickable {
                     this.d();
                 }
 
+                this.player.clientTicksSinceLastAttack++; // TacoSpigot
+
                 if (this.teleportPos != null) {
                     if (this.e - this.A > 20) {
                         this.A = this.e;
@@ -1680,6 +1682,7 @@ public class PlayerConnection implements PacketListenerPlayIn, ITickable {
     public void a(PacketPlayInWindowClick packetplayinwindowclick) {
         PlayerConnectionUtils.ensureMainThread(packetplayinwindowclick, this, this.player.x());
         if (this.player.dead) return; // CraftBukkit
+        if (packetplayinwindowclick.b() < 0 || this.player.activeContainer.getSlot(packetplayinwindowclick.b()) == null) return; // TacoSpigot - ignore packets with invalid slot
         this.player.resetIdleTimer();
         if (this.player.activeContainer.windowId == packetplayinwindowclick.a() && this.player.activeContainer.c(this.player)) {
             boolean cancelled = this.player.isSpectator(); // CraftBukkit - see below if
diff --git a/src/main/java/net/minecraft/server/TileEntityHopper.java b/src/main/java/net/minecraft/server/TileEntityHopper.java
index a695207..f1800f3 100644
--- a/src/main/java/net/minecraft/server/TileEntityHopper.java
+++ b/src/main/java/net/minecraft/server/TileEntityHopper.java
@@ -12,6 +12,10 @@ import org.bukkit.event.inventory.InventoryMoveItemEvent;
 import org.bukkit.event.inventory.InventoryPickupItemEvent;
 import org.bukkit.inventory.Inventory;
 // CraftBukkit end
+// TacoSpigot start
+import org.bukkit.craftbukkit.entity.CraftItem;
+import net.techcable.tacospigot.HopperHelper;
+// TacoSpigot end
 
 public class TileEntityHopper extends TileEntityLootable implements IHopper, ITickable {
 
@@ -155,6 +159,7 @@ public class TileEntityHopper extends TileEntityLootable implements IHopper, ITi
     }
 
     public void c() {
+        mayAcceptItems = false; // TacoSpigot - at the beginning of a tick, assume we can't accept items
         if (this.world != null && !this.world.isClientSide) {
             --this.g;
             if (!this.o()) {
@@ -175,6 +180,7 @@ public class TileEntityHopper extends TileEntityLootable implements IHopper, ITi
                 }
 
                 if (!this.r()) {
+                    mayAcceptItems = true; // TacoSpigot - flag this hopper to be able to accept items
                     flag = a((IHopper) this) || flag;
                 }
 
@@ -197,6 +203,14 @@ public class TileEntityHopper extends TileEntityLootable implements IHopper, ITi
         }
     }
 
+    // TacoSpigot start
+    private boolean mayAcceptItems = true;
+
+    public boolean canAcceptItems() {
+        return mayAcceptItems;
+    }
+    // TacoSpigot end
+
     private boolean q() {
         ItemStack[] aitemstack = this.items;
         int i = aitemstack.length;
@@ -228,7 +242,7 @@ public class TileEntityHopper extends TileEntityLootable implements IHopper, ITi
     }
 
     private boolean H() {
-        IInventory iinventory = this.I();
+        IInventory iinventory = HopperHelper.getInventory(getWorld(), getPosition().shift(BlockHopper.e(this.u()))); // TacoSpigot - avoid bounding box search
 
         if (iinventory == null) {
             return false;
@@ -245,7 +259,10 @@ public class TileEntityHopper extends TileEntityLootable implements IHopper, ITi
 
                         // CraftBukkit start - Call event when pushing items into other inventories
                         CraftItemStack oitemstack = CraftItemStack.asCraftMirror(this.splitStack(i, world.spigotConfig.hopperAmount)); // Spigot
-
+                        // TacoSpigot start - option to disable event
+                        final org.bukkit.inventory.ItemStack stack;
+                        if (HopperHelper.isFireInventoryMoveItemEvent(this)) {
+                            // TacoSpigot end
                         Inventory destinationInventory;
                         // Have to special case large chests as they work oddly
                         if (iinventory instanceof InventoryLargeChest) {
@@ -261,11 +278,17 @@ public class TileEntityHopper extends TileEntityLootable implements IHopper, ITi
                             this.setCooldown(world.spigotConfig.hopperTransfer); // Spigot
                             return false;
                         }
-                        int origCount = event.getItem().getAmount(); // Spigot
-                        ItemStack itemstack1 = addItem(iinventory, CraftItemStack.asNMSCopy(event.getItem()), enumdirection);
+                            // TacoSpigot start
+                            stack = event.getItem();
+                        } else {
+                            stack = oitemstack;
+                        }
+                        int origCount = stack.getAmount(); // Spigot
+                        ItemStack itemstack1 = addItem(iinventory, CraftItemStack.asNMSCopy(stack), enumdirection);
+                        // TacoSpigot end
 
                         if (itemstack1 == null || itemstack1.count == 0) {
-                            if (event.getItem().equals(oitemstack)) {
+                            if (stack.equals(oitemstack)) { // TacoSpigot - 'event.getItem' -> stack
                                 iinventory.update();
                             } else {
                                 this.setItem(i, itemstack);
@@ -333,8 +356,20 @@ public class TileEntityHopper extends TileEntityLootable implements IHopper, ITi
         return true;
     }
 
+    // TacoSpigot start - split methods, and only do entity lookup if in pull mode
     public static boolean a(IHopper ihopper) {
-        IInventory iinventory = b(ihopper);
+        IInventory iinventory;
+        if (ihopper.getWorld().tacoSpigotConfig.isHopperPushBased && ihopper instanceof TileEntityHopper) {
+            BlockPosition pos = ((TileEntityHopper) ihopper).getPosition().up(); // Only pull from above, as everything else is pushed into the hopper
+            iinventory = HopperHelper.getInventory(ihopper.getWorld(), pos);
+        } else {
+            iinventory = b(ihopper);
+        }
+        return acceptItem(ihopper, iinventory);
+    }
+
+    public static boolean acceptItem(IHopper ihopper, IInventory iinventory) {
+        // TacoSpigot end
 
         if (iinventory != null) {
             EnumDirection enumdirection = EnumDirection.DOWN;
@@ -361,7 +396,7 @@ public class TileEntityHopper extends TileEntityLootable implements IHopper, ITi
                     }
                 }
             }
-        } else {
+        } else if (!ihopper.getWorld().tacoSpigotConfig.isHopperPushBased || !(ihopper instanceof TileEntityHopper)) { // TacoSpigot - only search for entities in 'pull mode'
             Iterator iterator = a(ihopper.getWorld(), ihopper.E(), ihopper.F(), ihopper.G()).iterator();
 
             while (iterator.hasNext()) {
@@ -384,6 +419,10 @@ public class TileEntityHopper extends TileEntityLootable implements IHopper, ITi
             // ItemStack itemstack2 = addItem(ihopper, iinventory.splitStack(i, 1), (EnumDirection) null);
             // CraftBukkit start - Call event on collection of items from inventories into the hopper
             CraftItemStack oitemstack = CraftItemStack.asCraftMirror(iinventory.splitStack(i, ihopper.getWorld().spigotConfig.hopperAmount)); // Spigot
+            // TacoSpigot start - option to disable event
+            final org.bukkit.inventory.ItemStack stack;
+            if (HopperHelper.isFireInventoryMoveItemEvent(ihopper)) {
+                // TacoSpigot end
 
             Inventory sourceInventory;
             // Have to special case large chests as they work oddly
@@ -406,11 +445,17 @@ public class TileEntityHopper extends TileEntityLootable implements IHopper, ITi
                 }
                 return false;
             }
-            int origCount = event.getItem().getAmount(); // Spigot
-            ItemStack itemstack2 = addItem(ihopper, CraftItemStack.asNMSCopy(event.getItem()), null);
+                // TacoSpigot start
+                stack = event.getItem();
+            } else {
+                stack = oitemstack;
+            }
+            int origCount = stack.getAmount(); // Spigot
+            ItemStack itemstack2 = addItem(ihopper, CraftItemStack.asNMSCopy(stack), null);
+            // TacoSpigot end
 
             if (itemstack2 == null || itemstack2.count == 0) {
-                if (event.getItem().equals(oitemstack)) {
+                if (stack.equals(oitemstack)) { // TacoSpigot - 'event.getItem()' -> stack
                     iinventory.update();
                 } else {
                     iinventory.setItem(i, itemstack1);
@@ -537,6 +582,18 @@ public class TileEntityHopper extends TileEntityLootable implements IHopper, ITi
         return world.a(EntityItem.class, new AxisAlignedBB(d0 - 0.5D, d1, d2 - 0.5D, d0 + 0.5D, d1 + 1.5D, d2 + 0.5D), IEntitySelector.a);
     }
 
+    // TacoSpigot start
+    public AxisAlignedBB getHopperLookupBoundingBox() {
+        // Change this if b(IHopper) ever changes
+        return getHopperLookupBoundingBox(this.E(), this.F(), this.G());
+    }
+
+    private static AxisAlignedBB getHopperLookupBoundingBox(double d0, double d1, double d2) {
+        // Change this if a(World, double, double, double) above ever changes
+        return new AxisAlignedBB(d0 - 0.5D, d1, d2 - 0.5D, d0 + 0.5D, d1 + 1.5D, d2 + 0.5D);
+    }
+    // TacoSpigot end
+
     public static IInventory b(World world, double d0, double d1, double d2) {
         Object object = null;
         int i = MathHelper.floor(d0);
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index e70aa8e..b94255a 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -135,6 +135,7 @@ public abstract class World implements IBlockAccess {
     public final org.spigotmc.SpigotWorldConfig spigotConfig; // Spigot
 
     public final com.destroystokyo.paper.PaperWorldConfig paperConfig; // Paper
+    public final net.techcable.tacospigot.TacoSpigotWorldConfig tacoSpigotConfig; // TacoSpigot
 
     public final co.aikar.timings.WorldTimingsHandler timings; // Paper
     private boolean guardEntityList; // Spigot
@@ -166,6 +167,7 @@ public abstract class World implements IBlockAccess {
     protected World(IDataManager idatamanager, WorldData worlddata, WorldProvider worldprovider, MethodProfiler methodprofiler, boolean flag, ChunkGenerator gen, org.bukkit.World.Environment env) {
         this.spigotConfig = new org.spigotmc.SpigotWorldConfig( worlddata.getName() ); // Spigot
         this.paperConfig = new com.destroystokyo.paper.PaperWorldConfig(worlddata.getName(), this.spigotConfig); // Paper
+        this.tacoSpigotConfig = new net.techcable.tacospigot.TacoSpigotWorldConfig(worlddata.getName()); // TacoSpigot
         this.generator = gen;
         this.world = new CraftWorld((WorldServer) this, gen, env);
         this.ticksPerAnimalSpawns = this.getServer().getTicksPerAnimalSpawns(); // CraftBukkit
@@ -1238,6 +1240,7 @@ public abstract class World implements IBlockAccess {
 
         blockposition_pooledblockposition.t();
         if (entity != null) {
+            if (entity instanceof EntityArmorStand) return arraylist; // TacoSpigot - Optimize armor stand movement
             List list = this.getEntities(entity, axisalignedbb.g(0.25D));
 
             for (k1 = 0; k1 < list.size(); ++k1) {
diff --git a/src/main/java/net/techcable/tacospigot/HopperHelper.java b/src/main/java/net/techcable/tacospigot/HopperHelper.java
new file mode 100644
index 0000000..5dad71c
--- /dev/null
+++ b/src/main/java/net/techcable/tacospigot/HopperHelper.java
@@ -0,0 +1,44 @@
+package net.techcable.tacospigot;
+
+import net.minecraft.server.Block;
+import net.minecraft.server.BlockChest;
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.Blocks;
+import net.minecraft.server.Chunk;
+import net.minecraft.server.IHopper;
+import net.minecraft.server.IInventory;
+import net.minecraft.server.TileEntity;
+import net.minecraft.server.TileEntityHopper;
+import net.minecraft.server.World;
+
+import org.bukkit.event.inventory.InventoryMoveItemEvent;
+
+public class HopperHelper {
+
+    public static TileEntityHopper getHopper(World world, BlockPosition pos) {
+        Chunk chunk = world.getChunkIfLoaded(pos);
+        if (chunk != null && chunk.getBlockData(pos).getBlock() == Blocks.HOPPER) {
+            TileEntity tileEntity = chunk.a(pos, Chunk.EnumTileEntityState.IMMEDIATE);
+            if (tileEntity instanceof TileEntityHopper) {
+                return (TileEntityHopper) tileEntity;
+            }
+        }
+        return null;
+    }
+
+    public static IInventory getInventory(World world, BlockPosition position) {
+        Block block = world.getType(position).getBlock();
+        if (block instanceof BlockChest) {
+            return ((BlockChest) block).c(world, position);
+        }
+        if (block.isTileEntity()) {
+            TileEntity tile = world.getTileEntity(position);
+            if (tile instanceof IInventory) return (IInventory) tile;
+        }
+        return null;
+    }
+
+    public static boolean isFireInventoryMoveItemEvent(IHopper hopper) {
+        return hopper.getWorld().tacoSpigotConfig.isHopperFireIMIE && InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length > 0;
+    }
+}
diff --git a/src/main/java/net/techcable/tacospigot/HopperPusher.java b/src/main/java/net/techcable/tacospigot/HopperPusher.java
new file mode 100644
index 0000000..cd2232d
--- /dev/null
+++ b/src/main/java/net/techcable/tacospigot/HopperPusher.java
@@ -0,0 +1,67 @@
+package net.techcable.tacospigot;
+
+import net.minecraft.server.AxisAlignedBB;
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.Entity;
+import net.minecraft.server.IHopper;
+import net.minecraft.server.TileEntityHopper;
+import net.minecraft.server.World;
+
+public interface HopperPusher {
+
+    public default TileEntityHopper findHopper() {
+        BlockPosition pos = new BlockPosition(getX(), getY(), getZ());
+        int startX = pos.getX() - 1;
+        int endX = pos.getX() + 1;
+        int startY = Math.max(0, pos.getY() - 1);
+        int endY = Math.min(255, pos.getY() + 1);
+        int startZ = pos.getZ() - 1;
+        int endZ = pos.getZ() + 1;
+        for (int x = startX; x <= endX; x++) {
+            for (int y = startY; y <= endY; y++) {
+                for (int z = startZ; z <= endZ; z++) {
+                    BlockPosition adjacentPos = new BlockPosition(x, y, z);
+                    TileEntityHopper hopper = HopperHelper.getHopper(getWorld(), adjacentPos);
+                    if (hopper == null) continue; // Avoid playing with the bounding boxes, if at all possible
+                    AxisAlignedBB hopperBoundingBox = hopper.getHopperLookupBoundingBox();
+                    /*
+                     * Check if the entity's bounding box intersects with the hopper's lookup box.
+                     * This operation doesn't work both ways!
+                     * Make sure you check if the entity's box intersects the hopper's box, not vice versa!
+                     */
+                    if (this.getBoundingBox().b(hopperBoundingBox)) {
+                        return hopper;
+                    }
+                }
+            }
+        }
+        return null;
+    }
+
+    public boolean acceptItem(TileEntityHopper hopper);
+
+    public default boolean tryPutInHopper() {
+        if (!getWorld().tacoSpigotConfig.isHopperPushBased) return false;
+        TileEntityHopper hopper = findHopper();
+        return hopper != null && hopper.canAcceptItems() && acceptItem(hopper);
+    }
+
+    public AxisAlignedBB getBoundingBox();
+
+    public World getWorld();
+
+    // Default implementations for entities
+
+    public default double getX() {
+        return ((Entity) this).locX;
+    }
+
+    public default double getY() {
+        return ((Entity) this).locY;
+    }
+
+    public default double getZ() {
+        return ((Entity) this).locZ;
+    }
+
+}
diff --git a/src/main/java/net/techcable/tacospigot/ImmutableArrayMap.java b/src/main/java/net/techcable/tacospigot/ImmutableArrayMap.java
new file mode 100644
index 0000000..b62beb3
--- /dev/null
+++ b/src/main/java/net/techcable/tacospigot/ImmutableArrayMap.java
@@ -0,0 +1,221 @@
+package net.techcable.tacospigot;
+
+import java.util.AbstractMap;
+import java.util.AbstractSet;
+import java.util.Arrays;
+import java.util.Comparator;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.NoSuchElementException;
+import java.util.Set;
+import java.util.function.BiConsumer;
+import java.util.function.IntFunction;
+import java.util.function.ToIntFunction;
+
+import com.google.common.base.Preconditions;
+
+import org.apache.commons.lang3.tuple.Pair;
+
+public class ImmutableArrayMap<K, V> extends AbstractMap<K, V> implements Map<K, V> {
+    private final Indexer<K> indexer;
+    private final IntFunction<K> byIndex;
+    private final int offset;
+    private final Object[] data;
+    private final Object[] outlyingData;
+    private final int[] outlyingIds;
+
+    private final int size;
+
+    @SuppressWarnings("Convert2Lambda") // The comparator is anonomous for performance reasons
+    public ImmutableArrayMap(Indexer<K> getId, IntFunction<K> byIndex, Map<K, V> map) {
+        Preconditions.checkNotNull(getId, "Null getId function");
+        Preconditions.checkNotNull(byIndex, "Null byIndex function");
+        Preconditions.checkNotNull(map, "Null map");
+        this.indexer = getId;
+        this.byIndex = byIndex;
+        this.size = map.size();
+        this.keyComparator = new Comparator<K>() {
+            @Override
+            public int compare(K o1, K o2) {
+                return Integer.compare(indexer.getId(o1), indexer.getId(o2));
+            }
+        };
+        @SuppressWarnings("unchecked")
+        Entry<K, V>[] entries = new Entry[size];
+        Iterator<Entry<K, V>> iterator = map.entrySet().iterator();
+        for (int i = 0; i < entries.length; i++) {
+            Preconditions.checkArgument(iterator.hasNext(), "Expected %s entries but only got %s", size, i + 1);
+            entries[i] = iterator.next();
+        }
+        Arrays.sort(entries, (entry1, entry2) -> keyComparator.compare(entry1.getKey(), entry2.getKey()));
+        Preconditions.checkArgument(!iterator.hasNext(), "Got more than expected %s entries", size);
+        int[] ids = Arrays.stream(entries).map(Entry::getKey).mapToInt(indexer::getId).toArray(); // Don't worry, its sorted by key id ;)
+        int[] largestRangeOfSequentialValues = calculateLargestRangeOfSequentialValues(ids);
+        int minIndex = largestRangeOfSequentialValues == null ? -1 : largestRangeOfSequentialValues[0];
+        int maxIndex = largestRangeOfSequentialValues == null ? -1 : largestRangeOfSequentialValues[1];
+        int sequentalRangeSize = largestRangeOfSequentialValues == null ? 0 : largestRangeOfSequentialValues[2];
+        if (sequentalRangeSize < size / 2) {
+            System.err.println("Less than 50% of values are sequential");
+            System.err.print(sequentalRangeSize);
+            System.err.print(" out of ");
+            System.err.println(size);
+            System.err.println("Expect reduced performance");
+        }
+        this.data = new Object[sequentalRangeSize];
+        this.outlyingIds = new int[size - sequentalRangeSize];
+        this.outlyingData = new Object[size - sequentalRangeSize];
+        this.offset = sequentalRangeSize == 0 ? 0 : ids[minIndex];
+        int outlyingIndex = 0;
+        for (int i = 0; i < entries.length; i++) {
+            Entry<K, V> entry = entries[i];
+            K key = entry.getKey();
+            V value = entry.getValue();
+            int id = indexer.getId(key);
+            Preconditions.checkArgument(id >= 0, "Negative id for %s: %s", key, id);
+            if (i >= minIndex && i < maxIndex) {
+                int index = id - offset;
+                data[index] = value;
+            } else {
+                int index = outlyingIndex++;
+                outlyingIds[index] = id;
+                outlyingData[index] = value;
+            }
+        }
+    }
+    private final Comparator<K> keyComparator;
+
+    @Override
+    public int size() {
+        return size;
+    }
+
+    @Override
+    public boolean containsKey(Object key) {
+        return get(key) != null;
+    }
+
+    @Override
+    @SuppressWarnings("unchecked")
+    public V get(Object key) {
+        int id = indexer.getId((K) key);
+        int index = id - offset;
+        if (index >= 0 && index < data.length) {
+            return (V) data[index];
+        }
+        int outlyingIndex = Arrays.binarySearch(outlyingIds, id);
+        if (outlyingIndex >= 0 && outlyingIndex < outlyingData.length) {
+            return (V) outlyingData[outlyingIndex];
+        } else {
+            return null;
+        }
+    }
+
+    @Override
+    public Set<Entry<K, V>> entrySet() {
+        return new AbstractSet<Entry<K,V>>() {
+            @Override
+            public int size() {
+                return ImmutableArrayMap.this.size();
+            }
+
+            @Override
+            public boolean contains(Object o) {
+                if (!(o instanceof Entry)) return false;
+                Entry<?, ?> e = (Entry) o;
+                Object key = e.getKey();
+                if (key == null) return false;
+                Object value = get(key);
+                return value != null && value.equals(e.getValue());
+            }
+
+            @Override
+            public Iterator<Entry<K, V>> iterator() {
+                return new Iterator<Entry<K, V>>() {
+                    private int index, outlyingIndex;
+
+                    @Override
+                    public boolean hasNext() {
+                        while (index < data.length) {
+                            if (data[index] != null) {
+                                return true;
+                            } else {
+                                index++;
+                            }
+                        }
+                        return outlyingIndex < outlyingIds.length;
+                    }
+
+                    @Override
+                    @SuppressWarnings("unchecked")
+                    public Entry<K, V> next() {
+                        int index = this.index++;
+                        int outlyingIndex;
+                        if (index < data.length) {
+                            while (data[index] == null) index = this.index++;
+                            int id = index + offset;
+                            return Pair.of(byIndex.apply(id), (V) data[index]);
+                        } else if ((outlyingIndex = this.outlyingIndex++) < outlyingIds.length) {
+                            int id = outlyingIds[outlyingIndex];
+                            return Pair.of(byIndex.apply(id), (V) outlyingData[outlyingIndex]);
+                        } else {
+                            throw new NoSuchElementException();
+                        }
+                    }
+                };
+            }
+        };
+    }
+
+    @Override
+    public void forEach(BiConsumer<? super K, ? super V> action) {
+        for (int index = 0, id = offset; index < data.length; index++, id++) {
+            K key = byIndex.apply(id);
+            V value = (V) data[index];
+            action.accept(key, value);
+        }
+        for (int index = 0; index < outlyingIds.length; index++) {
+            int id = outlyingIds[index];
+            K key = byIndex.apply(id);
+            V value = (V) outlyingData[index];
+            action.accept(key, value);
+        }
+    }
+
+    @Override
+    public void clear() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public V put(K key, V value) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public V remove(Object key) {
+        throw new UnsupportedOperationException();
+    }
+
+    private static int[] calculateLargestRangeOfSequentialValues(int[] ids) {
+        int largestRangeSize = 0;
+        int[] largestRange = new int[3];
+        for (int minIndex = 0; minIndex < ids.length; minIndex++) {
+            final int min = ids[minIndex];
+            int lastNum = min;
+            int maxIndex;
+            for (maxIndex = minIndex + 1; maxIndex < ids.length; maxIndex++) {
+                final int max = ids[maxIndex];
+                if (lastNum + 1 != max) break; // The number is not sequential
+                lastNum = max;
+            }
+            int rangeSize = maxIndex - minIndex;
+            if (rangeSize > largestRangeSize) {
+                largestRange[0] = minIndex;
+                largestRange[1] = maxIndex;
+                largestRange[2] = rangeSize;
+                largestRangeSize = rangeSize;
+            }
+        }
+        return largestRangeSize == 0 ? null : largestRange;
+    }
+}
diff --git a/src/main/java/net/techcable/tacospigot/ImmutableArrayTable.java b/src/main/java/net/techcable/tacospigot/ImmutableArrayTable.java
new file mode 100644
index 0000000..3090e39
--- /dev/null
+++ b/src/main/java/net/techcable/tacospigot/ImmutableArrayTable.java
@@ -0,0 +1,259 @@
+package net.techcable.tacospigot;
+
+import java.util.AbstractCollection;
+import java.util.AbstractSet;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.NoSuchElementException;
+import java.util.Set;
+import java.util.function.IntFunction;
+import java.util.function.ToIntBiFunction;
+import java.util.function.ToIntFunction;
+import javax.annotation.Nullable;
+
+import com.google.common.base.Preconditions;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.Table;
+
+import net.techcable.tacospigot.function.ObjIntFunction;
+
+public class ImmutableArrayTable<R, C, V> implements Table<R, C, V> {
+    private final Indexer<R> rowIndexer;
+    private final IntFunction<R> rowById;
+    private final ToIntBiFunction<R, C> columnGetId;
+    private final ObjIntFunction<R, C> columnById;
+    private final ImmutableArrayMap<R, Map<C, V>> rowMap;
+    private final ImmutableMap<C, Map<R, V>> columnMap;
+    private final int size;
+
+    public ImmutableArrayTable(Indexer<R> rowIndexer, IntFunction<R> rowById, ToIntBiFunction<R, C> columnGetId, ObjIntFunction<R, C> columnById, Table<R, C, V> table) {
+        this.rowIndexer = Preconditions.checkNotNull(rowIndexer, "Null indexer for row");
+        this.rowById = Preconditions.checkNotNull(rowById, "Null byId function for row");
+        this.columnGetId = Preconditions.checkNotNull(columnGetId, "Null getId function for column");
+        this.columnById = Preconditions.checkNotNull(columnById, "Null byId function for column");
+        Preconditions.checkNotNull(table, "Null table");
+        ImmutableMap.Builder<R, Map<C, V>> rowMapBuilder = ImmutableMap.builder();
+        for (Map.Entry<R, Map<C, V>> rowEntry : table.rowMap().entrySet()) {
+            R row = rowEntry.getKey();
+            Preconditions.checkNotNull(row, "Null row");
+            ImmutableMap.Builder<C, V> rowMapEntryBuilder = ImmutableMap.builder();
+            for (Map.Entry<C, V> rowEntryEntry : rowEntry.getValue().entrySet()) {
+                rowMapEntryBuilder.put(rowEntryEntry);
+            }
+            rowMapBuilder.put(row, new ImmutableArrayMap<>((c) -> columnGetId.applyAsInt(row, c), (id) -> columnById.apply(row, id), rowMapEntryBuilder.build()));
+        }
+        this.rowMap = new ImmutableArrayMap<>(rowIndexer, rowById, rowMapBuilder.build());
+        Map<C, Map<R, V>> columnMapBuilder = new HashMap<>();
+        int size = 0;
+        for (Cell<R, C, V> cell : cellSet()) {
+            R row = cell.getRowKey();
+            C column = cell.getColumnKey();
+            V value = cell.getValue();
+            Preconditions.checkNotNull(column, "Null column");
+            Preconditions.checkNotNull(value, "Null value");
+            Map<R, V> columnEntry = columnMapBuilder.computeIfAbsent(column, (c) -> new HashMap<>());
+            columnEntry.put(cell.getRowKey(), cell.getValue());
+            size++;
+        }
+        this.size = size;
+        this.columnMap = ImmutableMap.copyOf(columnMapBuilder);
+    }
+
+    @Override
+    public boolean contains(@Nullable Object rowKey, @Nullable Object columnKey) {
+        Map<C, V> rowEntry = rowMap.get(rowKey);
+        return rowEntry != null && rowEntry.containsKey(columnKey);
+    }
+
+    @Override
+    public boolean containsRow(@Nullable Object rowKey) {
+        return rowMap.containsKey(rowKey);
+    }
+
+    @Override
+    public boolean containsColumn(@Nullable Object columnKey) {
+        return columnMap.containsKey(columnKey);
+    }
+
+    @Override
+    public boolean containsValue(@Nullable Object value) {
+        Preconditions.checkNotNull(value, "Null value");
+        for (V v : values()) {
+            if (v.equals(value)) return true;
+        }
+        return false;
+    }
+
+    @Override
+    public V get(@Nullable Object rowKey, @Nullable Object columnKey) {
+        Map<C, V> rowEntry = rowMap.get(rowKey);
+        return rowEntry != null ? rowEntry.get(columnKey) : null;
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return size() == 0;
+    }
+
+    @Override
+    public int size() {
+        return size;
+    }
+
+    @Override
+    public Map<C, V> row(R rowKey) {
+        return rowMap.get(rowKey);
+    }
+
+    @Override
+    public Map<R, V> column(C columnKey) {
+        return columnMap.get(columnKey);
+    }
+
+    @Override
+    public Set<Cell<R, C, V>> cellSet() {
+        return new AbstractSet<Cell<R, C, V>>() {
+            @Override
+            public Iterator<Cell<R, C, V>> iterator() {
+                Iterator<Map.Entry<R, Map<C, V>>> rowMapIterator = rowMap().entrySet().iterator();
+                if (!rowMapIterator.hasNext()) return Collections.emptyIterator();
+                return new Iterator<Cell<R, C, V>>() {
+                    private R row;
+                    private Iterator<Map.Entry<C, V>> rowMapEntryIterator;
+
+                    {
+                        Map.Entry<R, Map<C, V>> firstEntry = rowMapIterator.next();
+                        row = firstEntry.getKey();
+                        rowMapEntryIterator = firstEntry.getValue().entrySet().iterator();
+                    }
+
+                    @Override
+                    public boolean hasNext() {
+                        if (rowMapEntryIterator.hasNext()) {
+                            return true;
+                        } else {
+                            while (rowMapIterator.hasNext()) {
+                                Map.Entry<R, Map<C, V>> rowMapEntry = rowMapIterator.next();
+                                row = rowMapEntry.getKey();
+                                rowMapEntryIterator = rowMapEntry.getValue().entrySet().iterator();
+                                if (rowMapEntryIterator.hasNext()) return true;
+                            }
+                            return false;
+                        }
+                    }
+
+                    @Override
+                    public Cell<R, C, V> next() {
+                        if (!hasNext()) throw new NoSuchElementException();
+                        Map.Entry<C, V> rowMapEntryEntry = rowMapEntryIterator.next();
+                        return new SimpleCell<>(row, rowMapEntryEntry.getKey(), rowMapEntryEntry.getValue());
+                    }
+                };
+            }
+
+            @Override
+            public int size() {
+                return size;
+            }
+        };
+    }
+
+    @Override
+    public Set<R> rowKeySet() {
+        return rowMap.keySet();
+    }
+
+    @Override
+    public Set<C> columnKeySet() {
+        return columnMap.keySet();
+    }
+
+    @Override
+    public Collection<V> values() {
+        return new AbstractCollection<V>() {
+            @Override
+            public Iterator<V> iterator() {
+
+                Iterator<Cell<R, C, V>> cellIterator = cellSet().iterator();
+                return new Iterator<V>() {
+                    @Override
+                    public boolean hasNext() {
+                        return cellIterator.hasNext();
+                    }
+
+                    @Override
+                    public V next() {
+                        return cellIterator.next().getValue();
+                    }
+                };
+            }
+
+            @Override
+            public int size() {
+                return size;
+            }
+        };
+    }
+
+    @Override
+    public Map<R, Map<C, V>> rowMap() {
+        return rowMap;
+    }
+
+    @Override
+    public Map<C, Map<R, V>> columnMap() {
+        return columnMap;
+    }
+
+    private static class SimpleCell<R, C, V> implements Cell<R, C, V> {
+        private final R row;
+        private final C column;
+        private final V value;
+
+        private SimpleCell(R row, C column, V value) {
+            this.row = row;
+            this.column = column;
+            this.value = value;
+        }
+
+        @Override
+        public R getRowKey() {
+            return row;
+        }
+
+        @Override
+        public C getColumnKey() {
+            return column;
+        }
+
+        @Override
+        public V getValue() {
+            return value;
+        }
+    }
+
+    // Mutators
+    @Override
+    public void clear() {
+        throw new UnsupportedOperationException();
+    }
+
+
+    @Override
+    public V put(R rowKey, C columnKey, V value) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void putAll(Table<? extends R, ? extends C, ? extends V> table) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public V remove(@Nullable Object rowKey, @Nullable Object columnKey) {
+        throw new UnsupportedOperationException();
+    }
+}
diff --git a/src/main/java/net/techcable/tacospigot/Indexer.java b/src/main/java/net/techcable/tacospigot/Indexer.java
new file mode 100644
index 0000000..f6fec82
--- /dev/null
+++ b/src/main/java/net/techcable/tacospigot/Indexer.java
@@ -0,0 +1,5 @@
+package net.techcable.tacospigot;
+
+public interface Indexer<T> {
+    public int getId(T t);
+}
diff --git a/src/main/java/net/techcable/tacospigot/TacoSpigotConfig.java b/src/main/java/net/techcable/tacospigot/TacoSpigotConfig.java
new file mode 100644
index 0000000..22c6009
--- /dev/null
+++ b/src/main/java/net/techcable/tacospigot/TacoSpigotConfig.java
@@ -0,0 +1,115 @@
+package net.techcable.tacospigot;
+
+import java.io.File;
+import java.io.IOException;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.logging.Level;
+
+import net.minecraft.server.MinecraftServer;
+
+import org.bukkit.Bukkit;
+import org.bukkit.command.Command;
+import org.bukkit.configuration.InvalidConfigurationException;
+import org.bukkit.configuration.file.YamlConfiguration;
+
+import com.google.common.base.Throwables;
+
+public class TacoSpigotConfig {
+
+    private static File CONFIG_FILE;
+    private static final String HEADER = "This is the main configuration file for TacoSpigot.\n" + "As you can see, there's tons to configure. Some options may impact gameplay, so use\n" + "with caution, and make sure you know what each option does before configuring.\n" + "\n" + "If you need help with the configuration or have any questions related to TacoSpigot,\n" + "join us at the IRC.\n" + "\n" + "IRC: #techcable @ irc.spi.gt ( http://irc.spi.gt/iris/?channels=taco )\n";
+    /*========================================================================*/
+    static YamlConfiguration config;
+    static int version;
+    /*========================================================================*/
+
+    public static void init(File configFile) {
+        CONFIG_FILE = configFile;
+        config = new YamlConfiguration();
+        try {
+            System.out.println("Loading TacoSpigot configuration from: " + configFile.getName());
+            config.load(CONFIG_FILE);
+        } catch (IOException ex) {
+        } catch (InvalidConfigurationException ex) {
+            Bukkit.getLogger().log(Level.SEVERE, "Could not load taco.yml, please correct your syntax errors", ex);
+            throw Throwables.propagate(ex);
+        }
+        config.options().header(HEADER);
+        config.options().copyDefaults(true);
+
+        version = getInt("config-version", 1);
+        set("config-version", 1);
+        readConfig(TacoSpigotConfig.class, null);
+    }
+
+    static void readConfig(Class<?> clazz, Object instance) {
+        for (Method method : clazz.getDeclaredMethods()) {
+            if (Modifier.isPrivate(method.getModifiers())) {
+                if (method.getParameterTypes().length == 0 && method.getReturnType() == Void.TYPE) {
+                    try {
+                        method.setAccessible(true);
+                        method.invoke(instance);
+                    } catch (InvocationTargetException ex) {
+                        throw Throwables.propagate(ex.getCause());
+                    } catch (Exception ex) {
+                        Bukkit.getLogger().log(Level.SEVERE, "Error invoking " + method, ex);
+                    }
+                }
+            }
+        }
+
+        try {
+            config.save(CONFIG_FILE);
+        } catch (IOException ex) {
+            Bukkit.getLogger().log(Level.SEVERE, "Could not save " + CONFIG_FILE, ex);
+        }
+    }
+
+    private static void set(String path, Object val) {
+        config.set(path, val);
+    }
+
+    private static boolean getBoolean(String path, boolean def) {
+        config.addDefault(path, def);
+        return config.getBoolean(path, config.getBoolean(path));
+    }
+
+    private static double getDouble(String path, double def) {
+        config.addDefault(path, def);
+        return config.getDouble(path, config.getDouble(path));
+    }
+
+    private static float getFloat(String path, float def) {
+        return (float) getDouble(path, (double) def);
+    }
+
+    private static int getInt(String path, int def) {
+        config.addDefault(path, def);
+        return config.getInt(path, config.getInt(path));
+    }
+
+    private static <T> List getList(String path, T def) {
+        config.addDefault(path, def);
+        return (List<T>) config.getList(path, config.getList(path));
+    }
+
+    private static String getString(String path, String def) {
+        config.addDefault(path, def);
+        return config.getString(path, config.getString(path));
+    }
+
+    public static boolean useArraysForBlockStates;
+    private static void useArraysForBlockStates() {
+        useArraysForBlockStates = getBoolean("useArraysForBlockStates", false);
+    }
+
+    public static boolean betterPvp;
+    private static void betterPvp() {
+        betterPvp = getBoolean("betterPvp", false);
+    }
+}
diff --git a/src/main/java/net/techcable/tacospigot/TacoSpigotWorldConfig.java b/src/main/java/net/techcable/tacospigot/TacoSpigotWorldConfig.java
new file mode 100644
index 0000000..3f18f79
--- /dev/null
+++ b/src/main/java/net/techcable/tacospigot/TacoSpigotWorldConfig.java
@@ -0,0 +1,80 @@
+package net.techcable.tacospigot;
+
+import java.util.List;
+
+import org.bukkit.Bukkit;
+import org.bukkit.configuration.file.YamlConfiguration;
+
+public class TacoSpigotWorldConfig {
+
+    private final String worldName;
+    private final YamlConfiguration config;
+    private boolean verbose;
+
+    public TacoSpigotWorldConfig(String worldName) {
+        this.worldName = worldName;
+        this.config = TacoSpigotConfig.config;
+        init();
+    }
+
+    public void init() {
+        this.verbose = getBoolean("verbose", true);
+
+        log("-------- World Settings For [" + worldName + "] --------");
+        TacoSpigotConfig.readConfig(TacoSpigotWorldConfig.class, this);
+    }
+
+    private void log(String s) {
+        if (verbose) {
+            Bukkit.getLogger().info(s);
+        }
+    }
+
+    private void set(String path, Object val) {
+        config.set("world-settings.default." + path, val);
+    }
+
+    private boolean getBoolean(String path, boolean def) {
+        config.addDefault("world-settings.default." + path, def);
+        return config.getBoolean("world-settings." + worldName + "." + path, config.getBoolean("world-settings.default." + path));
+    }
+
+    private double getDouble(String path, double def) {
+        config.addDefault("world-settings.default." + path, def);
+        return config.getDouble("world-settings." + worldName + "." + path, config.getDouble("world-settings.default." + path));
+    }
+
+    private int getInt(String path, int def) {
+        config.addDefault("world-settings.default." + path, def);
+        return config.getInt("world-settings." + worldName + "." + path, config.getInt("world-settings.default." + path));
+    }
+
+    private float getFloat(String path, float def) {
+        return (float) getDouble(path, (double) def);
+    }
+
+    private <T> List getList(String path, T def) {
+        config.addDefault("world-settings.default." + path, def);
+        return (List<T>) config.getList("world-settings." + worldName + "." + path, config.getList("world-settings.default." + path));
+    }
+
+    private String getString(String path, String def) {
+        config.addDefault("world-settings.default." + path, def);
+        return config.getString("world-settings." + worldName + "." + path, config.getString("world-settings.default." + path));
+    }
+
+    public boolean isHopperPushBased;
+    private void isHopperPushBased() {
+        isHopperPushBased = getBoolean("hopper.push-based", true);
+    }
+
+    public boolean optimizeArmorStandMovement;
+    private void isArmorStandMoveWithoutGravity() {
+        optimizeArmorStandMovement = getBoolean("armor-stand.optimize-movement", false); // Doesn't fully emulate vanilla behavior, see issue #1
+    }
+
+    public boolean isHopperFireIMIE;
+    private void isHopperFireIMIE() {
+        isHopperFireIMIE = getBoolean("hopper.fire-InventoryMoveItemEvent", true);
+    }
+}
diff --git a/src/main/java/net/techcable/tacospigot/function/ObjIntFunction.java b/src/main/java/net/techcable/tacospigot/function/ObjIntFunction.java
new file mode 100644
index 0000000..b5adb4e
--- /dev/null
+++ b/src/main/java/net/techcable/tacospigot/function/ObjIntFunction.java
@@ -0,0 +1,6 @@
+package net.techcable.tacospigot.function;
+
+@FunctionalInterface
+public interface ObjIntFunction<T, R> {
+    public R apply(T t, int i);
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index 975a036..44acbea 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -713,6 +713,7 @@ public final class CraftServer implements Server {
 
         org.spigotmc.SpigotConfig.init((File) console.options.valueOf("spigot-settings")); // Spigot
         com.destroystokyo.paper.PaperConfig.init((File) console.options.valueOf("paper-settings")); // Paper
+        net.techcable.tacospigot.TacoSpigotConfig.init((File) console.options.valueOf("taco-settings")); // TacoSpigot
         for (WorldServer world : console.worlds) {
             world.worldData.setDifficulty(difficulty);
             world.setSpawnFlags(monsters, animals);
@@ -729,6 +730,7 @@ public final class CraftServer implements Server {
             }
             world.spigotConfig.init(); // Spigot
             world.paperConfig.init(); // Paper
+            world.tacoSpigotConfig.init(); // TacoSpigot
         }
 
         // Paper start
@@ -1416,7 +1418,7 @@ public final class CraftServer implements Server {
 
         for (JsonListEntry entry : playerList.getProfileBans().getValues()) {
             result.add(getOfflinePlayer((GameProfile) entry.getKey()));
-        }        
+        }
 
         return result;
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/Main.java b/src/main/java/org/bukkit/craftbukkit/Main.java
index 2aad1e8..2bc89d6 100644
--- a/src/main/java/org/bukkit/craftbukkit/Main.java
+++ b/src/main/java/org/bukkit/craftbukkit/Main.java
@@ -138,6 +138,14 @@ public class Main {
                         .defaultsTo("Unknown Server")
                         .describedAs("Name");
                 // Paper end
+
+                // TacoSpigot start
+                acceptsAll(asList("taco", "taco-settings"), "File for tacospigot settings")
+                        .withRequiredArg()
+                        .ofType(File.class)
+                        .defaultsTo(new File("taco.yml"))
+                        .describedAs("Yml file");
+                // TacoSpigot end
             }
         };
 
@@ -205,6 +213,7 @@ public class Main {
                     System.out.println( "Please see http://www.spigotmc.org/wiki/changing-permgen-size/ for more details and more in-depth instructions." );
                 }
                 // Spigot End
+                net.techcable.tacospigot.TacoSpigotConfig.init((File) options.valueOf("taco-settings")); // TacoSpigot - initalize before library loading so we can access while loading
                 System.out.println("Loading libraries, please wait...");
                 MinecraftServer.main(options);
             } catch (Throwable t) {
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index d23cade..a9654be 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -1273,11 +1273,16 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
 
     @Override
     public int getNoDamageTicks() {
+        // TacoSpigot start - fix incorrect calculation of getNoDamageTicks
+        /*
         if (getHandle().invulnerableTicks > 0) {
             return Math.max(getHandle().invulnerableTicks, getHandle().noDamageTicks);
         } else {
             return getHandle().noDamageTicks;
         }
+        */
+        return Math.max(getHandle().invulnerableTicks, Math.max(0, getHandle().noDamageTicks - getHandle().maxNoDamageTicks / 2));
+        // TacoSpigot end
     }
 
     @Override
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventoryView.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventoryView.java
index b6c2f73..0ab254e 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventoryView.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventoryView.java
@@ -10,6 +10,9 @@ import org.bukkit.inventory.InventoryView;
 import org.bukkit.inventory.ItemStack;
 
 import net.minecraft.server.Container;
+// TacoSpigot start
+import com.google.common.base.Preconditions;
+// TacoSpigot end
 
 public class CraftInventoryView extends InventoryView {
     private final Container container;
@@ -62,6 +65,7 @@ public class CraftInventoryView extends InventoryView {
         if (slot == -999) {
             return null;
         }
+        Preconditions.checkElementIndex(slot, container.c.size(), "slot"); // TacoSpigot - bounds check
         return CraftItemStack.asCraftMirror(container.getSlot(slot).getItem());
     }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/util/Versioning.java b/src/main/java/org/bukkit/craftbukkit/util/Versioning.java
index 674096c..4135e72 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/Versioning.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/Versioning.java
@@ -11,7 +11,7 @@ public final class Versioning {
     public static String getBukkitVersion() {
         String result = "Unknown-Version";
 
-        InputStream stream = Bukkit.class.getClassLoader().getResourceAsStream("META-INF/maven/com.destroystokyo.paper/paper-api/pom.properties");
+        InputStream stream = Bukkit.class.getClassLoader().getResourceAsStream("META-INF/maven/net.techcable.tacospigot/tacospigot-api/pom.properties"); // TacoSpigot - fix pom location
         Properties properties = new Properties();
 
         if (stream != null) {
diff --git a/src/main/java/org/spigotmc/AsyncCatcher.java b/src/main/java/org/spigotmc/AsyncCatcher.java
index 4b3aa85..c2e0271 100644
--- a/src/main/java/org/spigotmc/AsyncCatcher.java
+++ b/src/main/java/org/spigotmc/AsyncCatcher.java
@@ -1,17 +1,47 @@
 package org.spigotmc;
 
 import net.minecraft.server.MinecraftServer;
+// TacoSpigot start
+import java.util.List;
+import java.util.Set;
+
+import com.google.common.collect.ForwardingList;
+import com.google.common.collect.ForwardingSet;
+// TacoSpigot end
 
 public class AsyncCatcher
 {
 
-    public static boolean enabled = true;
+    public static final boolean enabled = true; // TacoSpigot - final (never disable)
 
     public static void catchOp(String reason)
     {
         if ( enabled && Thread.currentThread() != MinecraftServer.getServer().primaryThread )
         {
-            throw new IllegalStateException( "Asynchronous " + reason + "!" );
+            MinecraftServer.LOGGER.warn(reason + " called async on " + Thread.currentThread().getName()); // TacoSpigot - log
+            throw new IllegalStateException( "Asynchronous " + reason + " on thread " + Thread.currentThread().getName() + "!" ); // TacoSpigot - give thread
         }
     }
+
+    // TacoSpigot start - safety wrappers
+    public static <E> List<E> catchAsyncUsage(List<E> list, String msg) {
+        return new ForwardingList<E>() {
+            @Override
+            protected List<E> delegate() {
+                AsyncCatcher.catchOp(msg);
+                return list;
+            }
+        };
+    }
+
+    public static <E> Set<E> catchAsyncUsage(Set<E> set, String msg) {
+        return new ForwardingSet<E>() {
+            @Override
+            protected Set<E> delegate() {
+                AsyncCatcher.catchOp(msg);
+                return set;
+            }
+        };
+    }
+    // TacoSpigot end
 }
diff --git a/src/main/java/org/spigotmc/Metrics.java b/src/main/java/org/spigotmc/Metrics.java
index 680283c..f0b24dc 100644
--- a/src/main/java/org/spigotmc/Metrics.java
+++ b/src/main/java/org/spigotmc/Metrics.java
@@ -344,7 +344,7 @@ public class Metrics {
      */
     private void postPlugin(final boolean isPing) throws IOException {
         // Server software specific section
-        String pluginName = "PaperSpigot"; // Paper - Keep old name for legacy data
+        String pluginName = "TacoSpigot"; // Paper - Keep old name for legacy data // TacoSpigot - Its *my* usage data
         boolean onlineMode = Bukkit.getServer().getOnlineMode(); // TRUE if online mode is enabled
         String pluginVersion = (Metrics.class.getPackage().getImplementationVersion() != null) ? Metrics.class.getPackage().getImplementationVersion() : "unknown";
         String serverVersion = Bukkit.getVersion();
diff --git a/src/main/java/org/spigotmc/RestartCommand.java b/src/main/java/org/spigotmc/RestartCommand.java
index 429c258..86c8bf6 100644
--- a/src/main/java/org/spigotmc/RestartCommand.java
+++ b/src/main/java/org/spigotmc/RestartCommand.java
@@ -42,7 +42,7 @@ public class RestartCommand extends Command
 
     public static void restart(final File script)
     {
-        AsyncCatcher.enabled = false; // Disable async catcher incase it interferes with us
+        // AsyncCatcher.enabled = false; // Disable async catcher incase it interferes with us // TacoSpigot - remove, its all on the main thread
         try
         {
             if ( script.isFile() )
-- 
2.8.2.windows.1

