From 2b7b94195e6c79f6c9fd209a8093be0a194aa703 Mon Sep 17 00:00:00 2001
From: SotrForgotten <i@omc.hk>
Date: Mon, 11 Jul 2016 16:26:35 +0800
Subject: [PATCH] Threaded entity, misc io fix


diff --git a/src/main/java/com/destroystokyo/paper/PaperConfig.java b/src/main/java/com/destroystokyo/paper/PaperConfig.java
index 058720f..6518b43 100644
--- a/src/main/java/com/destroystokyo/paper/PaperConfig.java
+++ b/src/main/java/com/destroystokyo/paper/PaperConfig.java
@@ -193,10 +193,12 @@ public class PaperConfig {
         }
     }
 
+	/*
     public static int minChunkLoadThreads = 2;
     private static void chunkLoadThreads() {
         minChunkLoadThreads = Math.min(6, getInt("settings.min-chunk-load-threads", 2)); // Keep people from doing stupid things with max of 6
     }
+	*/
 
     public static boolean enableFileIOThreadSleep;
     private static void enableFileIOThreadSleep() {
diff --git a/src/main/java/net/minecraft/server/Entity.java b/src/main/java/net/minecraft/server/Entity.java
index b28caa8..d164ece 100644
--- a/src/main/java/net/minecraft/server/Entity.java
+++ b/src/main/java/net/minecraft/server/Entity.java
@@ -389,6 +389,10 @@ public abstract class Entity implements ICommandListener {
             this.world.methodProfiler.b();
         }
 
+		us_task = new U_sub();
+        us_task.fork();
+		// Hose start
+		/*
         this.al();
         this.aj();
         if (this.world.isClientSide) {
@@ -407,6 +411,8 @@ public abstract class Entity implements ICommandListener {
                 --this.fireTicks;
             }
         }
+		*/
+		// Hose end
 
         if (this.an()) {
             this.burnFromLava();
@@ -1554,7 +1560,7 @@ public abstract class Entity implements ICommandListener {
 
     public void d(EntityHuman entityhuman) {}
 
-    public void collide(Entity entity) {
+    public void collide_hose(Entity entity) { // Hose
         if (!this.x(entity)) {
             if (!entity.noclip && !this.noclip) {
                 double d0 = entity.locX - this.locX;
@@ -1589,6 +1595,12 @@ public abstract class Entity implements ICommandListener {
             }
         }
     }
+	
+    collide c_task;
+    public void collide(Entity entity) { // Hose - fork it
+        c_task = new collide(entity);
+        c_task.fork();
+    }
 
     public void g(double d0, double d1, double d2) {
         // Paper start - OBFHELPER
@@ -3079,6 +3091,19 @@ public abstract class Entity implements ICommandListener {
         }
     }
 	
+    class collide extends RecursiveAction {
+        Entity entity;
+        
+        public collide(Entity entity) {
+            this.entity = entity;
+        }
+
+        @Override
+        protected void compute() {
+            collide_hose(entity);
+        }
+
+	
 	class move extends RecursiveAction {
         double d0, d1, d2;
         
@@ -3120,4 +3145,32 @@ public abstract class Entity implements ICommandListener {
         }
                  
     }
+	
+	class U_sub extends RecursiveAction {
+        
+        public U_sub() {}
+
+        @Override
+        protected void compute() {
+            am();
+            ak();
+            if (world.isClientSide) {
+                fireTicks = 0;
+            } else if (fireTicks > 0) {
+                if (fireProof) {
+                    fireTicks -= 4;
+                    if (fireTicks < 0) {
+                        fireTicks = 0;
+                    }
+                } else {
+                    if (fireTicks % 20 == 0) {
+                        damageEntity(DamageSource.BURN, 1.0F);
+                    }
+
+                    --fireTicks;
+                }
+            }
+        }
+    }
+	
 }
diff --git a/src/main/java/net/minecraft/server/PlayerList.java b/src/main/java/net/minecraft/server/PlayerList.java
index 89756fa..07426c3 100644
--- a/src/main/java/net/minecraft/server/PlayerList.java
+++ b/src/main/java/net/minecraft/server/PlayerList.java
@@ -358,7 +358,7 @@ public abstract class PlayerList {
             }
         }
 
-        ChunkIOExecutor.adjustPoolSize(getPlayerCount());
+        // ChunkIOExecutor.adjustPoolSize(getPlayerCount());
         // CraftBukkit end
 
         // CraftBukkit start - sendAll above replaced with this loop
@@ -454,7 +454,7 @@ public abstract class PlayerList {
         cserver.getScoreboardManager().removePlayer(entityplayer.getBukkitEntity());
         // CraftBukkit end
 
-        ChunkIOExecutor.adjustPoolSize(this.getPlayerCount()); // CraftBukkit
+        // ChunkIOExecutor.adjustPoolSize(this.getPlayerCount()); // CraftBukkit
 
         return playerQuitEvent.getQuitMessage(); // CraftBukkit
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOExecutor.java b/src/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOExecutor.java
index 3a3b0b0..4e458bc 100644
--- a/src/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOExecutor.java
+++ b/src/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOExecutor.java
@@ -1,6 +1,5 @@
 package org.bukkit.craftbukkit.chunkio;
 
-import com.destroystokyo.paper.PaperConfig;
 import net.minecraft.server.Chunk;
 import net.minecraft.server.ChunkProviderServer;
 import net.minecraft.server.ChunkRegionLoader;
@@ -9,8 +8,9 @@ import net.minecraft.server.World;
 import org.bukkit.craftbukkit.util.AsynchronousExecutor;
 
 public class ChunkIOExecutor {
-    static final int BASE_THREADS = PaperConfig.minChunkLoadThreads; // Paper
-    static final int PLAYERS_PER_THREAD = 50;
+    // static final int BASE_THREADS = PaperConfig.minChunkLoadThreads; // Paper
+    // static final int PLAYERS_PER_THREAD = 50;
+	static final int BASE_THREADS =  Runtime.getRuntime().availableProcessors(); // Paper // Hose - threaded
 
     private static final AsynchronousExecutor<QueuedChunk, Chunk, Runnable, RuntimeException> instance = new AsynchronousExecutor<QueuedChunk, Chunk, Runnable, RuntimeException>(new ChunkIOProvider(), BASE_THREADS);
 
@@ -27,10 +27,12 @@ public class ChunkIOExecutor {
         instance.drop(new QueuedChunk(x, z, null, world, null), runnable);
     }
 
+	/*
     public static void adjustPoolSize(int players) {
         int size = Math.max(BASE_THREADS, (int) Math.ceil(players / PLAYERS_PER_THREAD));
         instance.setActiveThreads(size);
     }
+	*/
 
     public static void tick() {
         instance.finishActive();
-- 
2.8.2.windows.1

