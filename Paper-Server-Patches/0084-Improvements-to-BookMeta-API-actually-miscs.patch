From ebbf45fd5a63ec67bc3cf4324e9c589f762754fd Mon Sep 17 00:00:00 2001
From: SotrForgotten <i@omc.hk>
Date: Mon, 11 Jul 2016 18:08:11 +0800
Subject: [PATCH] Improvements to BookMeta API actually, miscs


diff --git a/src/main/java/org/bukkit/Player.java b/src/main/java/org/bukkit/Player.java
deleted file mode 100644
index 9436cc7..0000000
--- a/src/main/java/org/bukkit/Player.java
+++ /dev/null
@@ -1,1622 +0,0 @@
-package org.bukkit.entity;
-
-import java.net.InetSocketAddress;
-
-import com.destroystokyo.paper.Title;
-import org.bukkit.Achievement;
-import org.bukkit.ChatColor;
-import org.bukkit.Effect;
-import org.bukkit.GameMode;
-import org.bukkit.Instrument;
-import org.bukkit.Location;
-import org.bukkit.Material;
-import org.bukkit.Note;
-import org.bukkit.OfflinePlayer;
-import org.bukkit.Particle;
-import org.bukkit.Sound;
-import org.bukkit.Statistic;
-import org.bukkit.WeatherType;
-import org.bukkit.command.CommandSender;
-import org.bukkit.conversations.Conversable;
-import org.bukkit.map.MapView;
-import org.bukkit.plugin.messaging.PluginMessageRecipient;
-import org.bukkit.scoreboard.Scoreboard;
-
-import com.destroystokyo.paper.profile.AccountProfile; // Paper
-
-/**
- * Represents a player, connected or not
- */
-public interface Player extends HumanEntity, Conversable, CommandSender, OfflinePlayer, PluginMessageRecipient {
-
-    /**
-     * Gets the "friendly" name to display of this player. This may include
-     * color.
-     * <p>
-     * Note that this name will not be displayed in game, only in chat and
-     * places defined by plugins.
-     *
-     * @return the friendly name
-     */
-    public String getDisplayName();
-
-    /**
-     * Sets the "friendly" name to display of this player. This may include
-     * color.
-     * <p>
-     * Note that this name will not be displayed in game, only in chat and
-     * places defined by plugins.
-     *
-     * @param name The new display name.
-     */
-    public void setDisplayName(String name);
-
-    /**
-     * Gets the name that is shown on the player list.
-     *
-     * @return the player list name
-     */
-    public String getPlayerListName();
-
-    /**
-     * Sets the name that is shown on the in-game player list.
-     * <p>
-     * The name cannot be longer than 16 characters, but {@link ChatColor} is
-     * supported.
-     * <p>
-     * If the value is null, the name will be identical to {@link #getName()}.
-     * <p>
-     * This name is case sensitive and unique, two names with different casing
-     * will appear as two different people. If a player joins afterwards with
-     * a name that conflicts with a player's custom list name, the joining
-     * player's player list name will have a random number appended to it (1-2
-     * characters long in the default implementation). If the joining player's
-     * name is 15 or 16 characters long, part of the name will be truncated at
-     * the end to allow the addition of the two digits.
-     *
-     * @param name new player list name
-     * @throws IllegalArgumentException if the name is already used by someone
-     *     else
-     * @throws IllegalArgumentException if the length of the name is too long
-     */
-    public void setPlayerListName(String name);
-
-    /**
-     * Set the target of the player's compass.
-     *
-     * @param loc Location to point to
-     */
-    public void setCompassTarget(Location loc);
-
-    /**
-     * Get the previously set compass target.
-     *
-     * @return location of the target
-     */
-    public Location getCompassTarget();
-
-    /**
-     * Gets the socket address of this player
-     *
-     * @return the player's address
-     */
-    public InetSocketAddress getAddress();
-
-    /**
-     * Sends this sender a message raw
-     *
-     * @param message Message to be displayed
-     */
-    public void sendRawMessage(String message);
-
-    /**
-     * Kicks player with custom kick message.
-     *
-     * @param message kick message
-     */
-    public void kickPlayer(String message);
-
-    /**
-     * Says a message (or runs a command).
-     *
-     * @param msg message to print
-     */
-    public void chat(String msg);
-
-    /**
-     * Makes the player perform the given command
-     *
-     * @param command Command to perform
-     * @return true if the command was successful, otherwise false
-     */
-    public boolean performCommand(String command);
-
-    /**
-     * Returns if the player is in sneak mode
-     *
-     * @return true if player is in sneak mode
-     */
-    public boolean isSneaking();
-
-    /**
-     * Sets the sneak mode the player
-     *
-     * @param sneak true if player should appear sneaking
-     */
-    public void setSneaking(boolean sneak);
-
-    /**
-     * Gets whether the player is sprinting or not.
-     *
-     * @return true if player is sprinting.
-     */
-    public boolean isSprinting();
-
-    /**
-     * Sets whether the player is sprinting or not.
-     *
-     * @param sprinting true if the player should be sprinting
-     */
-    public void setSprinting(boolean sprinting);
-
-    /**
-     * Saves the players current location, health, inventory, motion, and
-     * other information into the username.dat file, in the world/player
-     * folder
-     */
-    public void saveData();
-
-    /**
-     * Loads the players current location, health, inventory, motion, and
-     * other information from the username.dat file, in the world/player
-     * folder.
-     * <p>
-     * Note: This will overwrite the players current inventory, health,
-     * motion, etc, with the state from the saved dat file.
-     */
-    public void loadData();
-
-    /**
-     * Sets whether the player is ignored as not sleeping. If everyone is
-     * either sleeping or has this flag set, then time will advance to the
-     * next day. If everyone has this flag set but no one is actually in bed,
-     * then nothing will happen.
-     *
-     * @param isSleeping Whether to ignore.
-     */
-    public void setSleepingIgnored(boolean isSleeping);
-
-    /**
-     * Returns whether the player is sleeping ignored.
-     *
-     * @return Whether player is ignoring sleep.
-     */
-    public boolean isSleepingIgnored();
-
-    /**
-     * Play a note for a player at a location. This requires a note block
-     * at the particular location (as far as the client is concerned). This
-     * will not work without a note block. This will not work with cake.
-     *
-     * @param loc The location of a note block.
-     * @param instrument The instrument ID.
-     * @param note The note ID.
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public void playNote(Location loc, byte instrument, byte note);
-
-    /**
-     * Play a note for a player at a location. This requires a note block
-     * at the particular location (as far as the client is concerned). This
-     * will not work without a note block. This will not work with cake.
-     *
-     * @param loc The location of a note block
-     * @param instrument The instrument
-     * @param note The note
-     */
-    public void playNote(Location loc, Instrument instrument, Note note);
-
-
-    /**
-     * Play a sound for a player at the location.
-     * <p>
-     * This function will fail silently if Location or Sound are null.
-     *
-     * @param location The location to play the sound
-     * @param sound The sound to play
-     * @param volume The volume of the sound
-     * @param pitch The pitch of the sound
-     */
-    public void playSound(Location location, Sound sound, float volume, float pitch);
-
-    /**
-     * Play a sound for a player at the location.
-     * <p>
-     * This function will fail silently if Location or Sound are null. No
-     * sound will be heard by the player if their client does not have the
-     * respective sound for the value passed.
-     *
-     * @param location the location to play the sound
-     * @param sound the internal sound name to play
-     * @param volume the volume of the sound
-     * @param pitch the pitch of the sound
-     */
-    public void playSound(Location location, String sound, float volume, float pitch);
-
-    /**
-     * Plays an effect to just this player.
-     *
-     * @param loc the location to play the effect at
-     * @param effect the {@link Effect}
-     * @param data a data bit needed for some effects
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public void playEffect(Location loc, Effect effect, int data);
-
-    /**
-     * Plays an effect to just this player.
-     *
-     * @param <T> the data based based on the type of the effect
-     * @param loc the location to play the effect at
-     * @param effect the {@link Effect}
-     * @param data a data bit needed for some effects
-     */
-    public <T> void playEffect(Location loc, Effect effect, T data);
-
-    /**
-     * Send a block change. This fakes a block change packet for a user at a
-     * certain location. This will not actually change the world in any way.
-     *
-     * @param loc The location of the changed block
-     * @param material The new block
-     * @param data The block data
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public void sendBlockChange(Location loc, Material material, byte data);
-
-    /**
-     * Send a chunk change. This fakes a chunk change packet for a user at a
-     * certain location. The updated cuboid must be entirely within a single
-     * chunk. This will not actually change the world in any way.
-     * <p>
-     * At least one of the dimensions of the cuboid must be even. The size of
-     * the data buffer must be 2.5*sx*sy*sz and formatted in accordance with
-     * the Packet51 format.
-     *
-     * @param loc The location of the cuboid
-     * @param sx The x size of the cuboid
-     * @param sy The y size of the cuboid
-     * @param sz The z size of the cuboid
-     * @param data The data to be sent
-     * @return true if the chunk change packet was sent
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public boolean sendChunkChange(Location loc, int sx, int sy, int sz, byte[] data);
-
-    /**
-     * Send a block change. This fakes a block change packet for a user at a
-     * certain location. This will not actually change the world in any way.
-     *
-     * @param loc The location of the changed block
-     * @param material The new block ID
-     * @param data The block data
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public void sendBlockChange(Location loc, int material, byte data);
-
-    /**
-     * Send a sign change. This fakes a sign change packet for a user at
-     * a certain location. This will not actually change the world in any way.
-     * This method will use a sign at the location's block or a faked sign
-     * sent via {@link #sendBlockChange(org.bukkit.Location, int, byte)} or
-     * {@link #sendBlockChange(org.bukkit.Location, org.bukkit.Material, byte)}.
-     * <p>
-     * If the client does not have a sign at the given location it will
-     * display an error message to the user.
-     *
-     * @param loc the location of the sign
-     * @param lines the new text on the sign or null to clear it
-     * @throws IllegalArgumentException if location is null
-     * @throws IllegalArgumentException if lines is non-null and has a length less than 4
-     */
-    public void sendSignChange(Location loc, String[] lines) throws IllegalArgumentException;
-
-    /**
-     * Render a map and send it to the player in its entirety. This may be
-     * used when streaming the map in the normal manner is not desirable.
-     *
-     * @param map The map to be sent
-     */
-    public void sendMap(MapView map);
-
-    // Paper start
-    /**
-     * Sends the component to the player
-     *
-     * @param component the components to send
-     */
-    @Override
-    public void sendMessage(net.md_5.bungee.api.chat.BaseComponent component);
-
-    /**
-     * Sends an array of components as a single message to the player
-     *
-     * @param components the components to send
-     */
-    @Override
-    public void sendMessage(net.md_5.bungee.api.chat.BaseComponent... components);
-
-    /**
-     * Sends an array of components as a single message to the specified screen position of this player
-     *
-     * @param position the screen position
-     * @param components the components to send
-     */
-    public void sendMessage(net.md_5.bungee.api.ChatMessageType position, net.md_5.bungee.api.chat.BaseComponent... components);
-
-    /**
-     * Set the text displayed in the player list header and footer for this player
-     *
-     * @param header content for the top of the player list
-     * @param footer content for the bottom of the player list
-     */
-    public void setPlayerListHeaderFooter(net.md_5.bungee.api.chat.BaseComponent[] header, net.md_5.bungee.api.chat.BaseComponent[] footer);
-
-    /**
-     * Set the text displayed in the player list header and footer for this player
-     *
-     * @param header content for the top of the player list
-     * @param footer content for the bottom of the player list
-     */
-    public void setPlayerListHeaderFooter(net.md_5.bungee.api.chat.BaseComponent header, net.md_5.bungee.api.chat.BaseComponent footer);
-
-    /**
-     * Update the times for titles displayed to the player
-     *
-     * @param fadeInTicks  ticks to fade-in
-     * @param stayTicks    ticks to stay visible
-     * @param fadeOutTicks ticks to fade-out
-     * @deprecated Use {@link #updateTitle(Title)}
-     */
-    @Deprecated
-    public void setTitleTimes(int fadeInTicks, int stayTicks, int fadeOutTicks);
-
-    /**
-     * Update the subtitle of titles displayed to the player
-     *
-     * @deprecated Use {@link #updateTitle(Title)}
-     */
-    @Deprecated
-    public void setSubtitle(net.md_5.bungee.api.chat.BaseComponent[] subtitle);
-
-    /**
-     * Update the subtitle of titles displayed to the player
-     *
-     * @deprecated Use {@link #updateTitle(Title)}
-     */
-    @Deprecated
-    public void setSubtitle(net.md_5.bungee.api.chat.BaseComponent subtitle);
-
-    /**
-     * Show the given title to the player, along with the last subtitle set, using the last set times
-     *
-     * @deprecated Use {@link #sendTitle(Title)} or {@link #updateTitle(Title)}
-     */
-    @Deprecated
-    public void showTitle(net.md_5.bungee.api.chat.BaseComponent[] title);
-
-    /**
-     * Show the given title to the player, along with the last subtitle set, using the last set times
-     *
-     * @deprecated Use {@link #sendTitle(Title)} or {@link #updateTitle(Title)}
-     */
-    @Deprecated
-    public void showTitle(net.md_5.bungee.api.chat.BaseComponent title);
-
-    /**
-     * Show the given title and subtitle to the player using the given times
-     *
-     * @param title        big text
-     * @param subtitle     little text under it
-     * @param fadeInTicks  ticks to fade-in
-     * @param stayTicks    ticks to stay visible
-     * @param fadeOutTicks ticks to fade-out
-     * @deprecated Use {@link #sendTitle(Title)} or {@link #updateTitle(Title)}
-     */
-    @Deprecated
-    public void showTitle(net.md_5.bungee.api.chat.BaseComponent[] title, net.md_5.bungee.api.chat.BaseComponent[] subtitle, int fadeInTicks, int stayTicks, int fadeOutTicks);
-
-    /**
-     * Show the given title and subtitle to the player using the given times
-     *
-     * @param title        big text
-     * @param subtitle     little text under it
-     * @param fadeInTicks  ticks to fade-in
-     * @param stayTicks    ticks to stay visible
-     * @param fadeOutTicks ticks to fade-out
-     * @deprecated Use {@link #sendTitle(Title)} or {@link #updateTitle(Title)}
-     */
-    @Deprecated
-    public void showTitle(net.md_5.bungee.api.chat.BaseComponent title, net.md_5.bungee.api.chat.BaseComponent subtitle, int fadeInTicks, int stayTicks, int fadeOutTicks);
-
-    /**
-     * Show the title to the player, overriding any previously displayed title.
-     * <p>
-     * <p>This method overrides any previous title, use {@link #updateTitle(Title)} to change the existing one.</p>
-     *
-     * @param title the title to send
-     * @throws NullPointerException if the title is null
-     */
-    void sendTitle(Title title);
-
-    /**
-     * Show the title to the player, overriding any previously displayed title.
-     * <p>
-     * <p>This method doesn't override previous titles, but changes their values.</p>
-     *
-     * @param title the title to send
-     * @throws NullPointerException if title is null
-     */
-    void updateTitle(Title title);
-
-    /**
-     * Hide any title that is currently visible to the player
-     */
-    public void hideTitle();
-    // Paper end
-
-    /**
-     * Forces an update of the player's entire inventory.
-     *
-     */
-    //@Deprecated // Spigot - undeprecate
-    public void updateInventory();
-
-    /**
-     * Awards the given achievement and any parent achievements that the
-     * player does not have.
-     *
-     * @param achievement Achievement to award
-     * @throws IllegalArgumentException if achievement is null
-     */
-    public void awardAchievement(Achievement achievement);
-
-    /**
-     * Removes the given achievement and any children achievements that the
-     * player has.
-     *
-     * @param achievement Achievement to remove
-     * @throws IllegalArgumentException if achievement is null
-     */
-    public void removeAchievement(Achievement achievement);
-
-    /**
-     * Gets whether this player has the given achievement.
-     *
-     * @param achievement the achievement to check
-     * @return whether the player has the achievement
-     * @throws IllegalArgumentException if achievement is null
-     */
-    public boolean hasAchievement(Achievement achievement);
-
-    /**
-     * Increments the given statistic for this player.
-     * <p>
-     * This is equivalent to the following code:
-     * <code>incrementStatistic(Statistic, 1)</code>
-     *
-     * @param statistic Statistic to increment
-     * @throws IllegalArgumentException if statistic is null
-     * @throws IllegalArgumentException if the statistic requires an
-     *     additional parameter
-     */
-    public void incrementStatistic(Statistic statistic) throws IllegalArgumentException;
-
-    /**
-     * Decrements the given statistic for this player.
-     * <p>
-     * This is equivalent to the following code:
-     * <code>decrementStatistic(Statistic, 1)</code>
-     *
-     * @param statistic Statistic to decrement
-     * @throws IllegalArgumentException if statistic is null
-     * @throws IllegalArgumentException if the statistic requires an
-     *     additional parameter
-     */
-    public void decrementStatistic(Statistic statistic) throws IllegalArgumentException;
-
-    /**
-     * Increments the given statistic for this player.
-     *
-     * @param statistic Statistic to increment
-     * @param amount Amount to increment this statistic by
-     * @throws IllegalArgumentException if statistic is null
-     * @throws IllegalArgumentException if amount is negative
-     * @throws IllegalArgumentException if the statistic requires an
-     *     additional parameter
-     */
-    public void incrementStatistic(Statistic statistic, int amount) throws IllegalArgumentException;
-
-    /**
-     * Decrements the given statistic for this player.
-     *
-     * @param statistic Statistic to decrement
-     * @param amount Amount to decrement this statistic by
-     * @throws IllegalArgumentException if statistic is null
-     * @throws IllegalArgumentException if amount is negative
-     * @throws IllegalArgumentException if the statistic requires an
-     *     additional parameter
-     */
-    public void decrementStatistic(Statistic statistic, int amount) throws IllegalArgumentException;
-
-    /**
-     * Sets the given statistic for this player.
-     *
-     * @param statistic Statistic to set
-     * @param newValue The value to set this statistic to
-     * @throws IllegalArgumentException if statistic is null
-     * @throws IllegalArgumentException if newValue is negative
-     * @throws IllegalArgumentException if the statistic requires an
-     *     additional parameter
-     */
-    public void setStatistic(Statistic statistic, int newValue) throws IllegalArgumentException;
-
-    /**
-     * Gets the value of the given statistic for this player.
-     *
-     * @param statistic Statistic to check
-     * @return the value of the given statistic
-     * @throws IllegalArgumentException if statistic is null
-     * @throws IllegalArgumentException if the statistic requires an
-     *     additional parameter
-     */
-    public int getStatistic(Statistic statistic) throws IllegalArgumentException;
-
-    /**
-     * Increments the given statistic for this player for the given material.
-     * <p>
-     * This is equivalent to the following code:
-     * <code>incrementStatistic(Statistic, Material, 1)</code>
-     *
-     * @param statistic Statistic to increment
-     * @param material Material to offset the statistic with
-     * @throws IllegalArgumentException if statistic is null
-     * @throws IllegalArgumentException if material is null
-     * @throws IllegalArgumentException if the given parameter is not valid
-     *     for the statistic
-     */
-    public void incrementStatistic(Statistic statistic, Material material) throws IllegalArgumentException;
-
-    /**
-     * Decrements the given statistic for this player for the given material.
-     * <p>
-     * This is equivalent to the following code:
-     * <code>decrementStatistic(Statistic, Material, 1)</code>
-     *
-     * @param statistic Statistic to decrement
-     * @param material Material to offset the statistic with
-     * @throws IllegalArgumentException if statistic is null
-     * @throws IllegalArgumentException if material is null
-     * @throws IllegalArgumentException if the given parameter is not valid
-     *     for the statistic
-     */
-    public void decrementStatistic(Statistic statistic, Material material) throws IllegalArgumentException;
-
-    /**
-     * Gets the value of the given statistic for this player.
-     *
-     * @param statistic Statistic to check
-     * @param material Material offset of the statistic
-     * @return the value of the given statistic
-     * @throws IllegalArgumentException if statistic is null
-     * @throws IllegalArgumentException if material is null
-     * @throws IllegalArgumentException if the given parameter is not valid
-     *     for the statistic
-     */
-    public int getStatistic(Statistic statistic, Material material) throws IllegalArgumentException;
-
-    /**
-     * Increments the given statistic for this player for the given material.
-     *
-     * @param statistic Statistic to increment
-     * @param material Material to offset the statistic with
-     * @param amount Amount to increment this statistic by
-     * @throws IllegalArgumentException if statistic is null
-     * @throws IllegalArgumentException if material is null
-     * @throws IllegalArgumentException if amount is negative
-     * @throws IllegalArgumentException if the given parameter is not valid
-     *     for the statistic
-     */
-    public void incrementStatistic(Statistic statistic, Material material, int amount) throws IllegalArgumentException;
-
-    /**
-     * Decrements the given statistic for this player for the given material.
-     *
-     * @param statistic Statistic to decrement
-     * @param material Material to offset the statistic with
-     * @param amount Amount to decrement this statistic by
-     * @throws IllegalArgumentException if statistic is null
-     * @throws IllegalArgumentException if material is null
-     * @throws IllegalArgumentException if amount is negative
-     * @throws IllegalArgumentException if the given parameter is not valid
-     *     for the statistic
-     */
-    public void decrementStatistic(Statistic statistic, Material material, int amount) throws IllegalArgumentException;
-
-    /**
-     * Sets the given statistic for this player for the given material.
-     *
-     * @param statistic Statistic to set
-     * @param material Material to offset the statistic with
-     * @param newValue The value to set this statistic to
-     * @throws IllegalArgumentException if statistic is null
-     * @throws IllegalArgumentException if material is null
-     * @throws IllegalArgumentException if newValue is negative
-     * @throws IllegalArgumentException if the given parameter is not valid
-     *     for the statistic
-     */
-    public void setStatistic(Statistic statistic, Material material, int newValue) throws IllegalArgumentException;
-
-    /**
-     * Increments the given statistic for this player for the given entity.
-     * <p>
-     * This is equivalent to the following code:
-     * <code>incrementStatistic(Statistic, EntityType, 1)</code>
-     *
-     * @param statistic Statistic to increment
-     * @param entityType EntityType to offset the statistic with
-     * @throws IllegalArgumentException if statistic is null
-     * @throws IllegalArgumentException if entityType is null
-     * @throws IllegalArgumentException if the given parameter is not valid
-     *     for the statistic
-     */
-    public void incrementStatistic(Statistic statistic, EntityType entityType) throws IllegalArgumentException;
-
-    /**
-     * Decrements the given statistic for this player for the given entity.
-     * <p>
-     * This is equivalent to the following code:
-     * <code>decrementStatistic(Statistic, EntityType, 1)</code>
-     *
-     * @param statistic Statistic to decrement
-     * @param entityType EntityType to offset the statistic with
-     * @throws IllegalArgumentException if statistic is null
-     * @throws IllegalArgumentException if entityType is null
-     * @throws IllegalArgumentException if the given parameter is not valid
-     *     for the statistic
-     */
-    public void decrementStatistic(Statistic statistic, EntityType entityType) throws IllegalArgumentException;
-
-    /**
-     * Gets the value of the given statistic for this player.
-     *
-     * @param statistic Statistic to check
-     * @param entityType EntityType offset of the statistic
-     * @return the value of the given statistic
-     * @throws IllegalArgumentException if statistic is null
-     * @throws IllegalArgumentException if entityType is null
-     * @throws IllegalArgumentException if the given parameter is not valid
-     *     for the statistic
-     */
-    public int getStatistic(Statistic statistic, EntityType entityType) throws IllegalArgumentException;
-
-    /**
-     * Increments the given statistic for this player for the given entity.
-     *
-     * @param statistic Statistic to increment
-     * @param entityType EntityType to offset the statistic with
-     * @param amount Amount to increment this statistic by
-     * @throws IllegalArgumentException if statistic is null
-     * @throws IllegalArgumentException if entityType is null
-     * @throws IllegalArgumentException if amount is negative
-     * @throws IllegalArgumentException if the given parameter is not valid
-     *     for the statistic
-     */
-    public void incrementStatistic(Statistic statistic, EntityType entityType, int amount) throws IllegalArgumentException;
-
-    /**
-     * Decrements the given statistic for this player for the given entity.
-     *
-     * @param statistic Statistic to decrement
-     * @param entityType EntityType to offset the statistic with
-     * @param amount Amount to decrement this statistic by
-     * @throws IllegalArgumentException if statistic is null
-     * @throws IllegalArgumentException if entityType is null
-     * @throws IllegalArgumentException if amount is negative
-     * @throws IllegalArgumentException if the given parameter is not valid
-     *     for the statistic
-     */
-    public void decrementStatistic(Statistic statistic, EntityType entityType, int amount);
-
-    /**
-     * Sets the given statistic for this player for the given entity.
-     *
-     * @param statistic Statistic to set
-     * @param entityType EntityType to offset the statistic with
-     * @param newValue The value to set this statistic to
-     * @throws IllegalArgumentException if statistic is null
-     * @throws IllegalArgumentException if entityType is null
-     * @throws IllegalArgumentException if newValue is negative
-     * @throws IllegalArgumentException if the given parameter is not valid
-     *     for the statistic
-     */
-    public void setStatistic(Statistic statistic, EntityType entityType, int newValue);
-
-    /**
-     * Sets the current time on the player's client. When relative is true the
-     * player's time will be kept synchronized to its world time with the
-     * specified offset.
-     * <p>
-     * When using non relative time the player's time will stay fixed at the
-     * specified time parameter. It's up to the caller to continue updating
-     * the player's time. To restore player time to normal use
-     * resetPlayerTime().
-     *
-     * @param time The current player's perceived time or the player's time
-     *     offset from the server time.
-     * @param relative When true the player time is kept relative to its world
-     *     time.
-     */
-    public void setPlayerTime(long time, boolean relative);
-
-    /**
-     * Returns the player's current timestamp.
-     *
-     * @return The player's time
-     */
-    public long getPlayerTime();
-
-    /**
-     * Returns the player's current time offset relative to server time, or
-     * the current player's fixed time if the player's time is absolute.
-     *
-     * @return The player's time
-     */
-    public long getPlayerTimeOffset();
-
-    /**
-     * Returns true if the player's time is relative to the server time,
-     * otherwise the player's time is absolute and will not change its current
-     * time unless done so with setPlayerTime().
-     *
-     * @return true if the player's time is relative to the server time.
-     */
-    public boolean isPlayerTimeRelative();
-
-    /**
-     * Restores the normal condition where the player's time is synchronized
-     * with the server time.
-     * <p>
-     * Equivalent to calling setPlayerTime(0, true).
-     */
-    public void resetPlayerTime();
-
-    /**
-     * Sets the type of weather the player will see.  When used, the weather
-     * status of the player is locked until {@link #resetPlayerWeather()} is
-     * used.
-     *
-     * @param type The WeatherType enum type the player should experience
-     */
-    public void setPlayerWeather(WeatherType type);
-
-    /**
-     * Returns the type of weather the player is currently experiencing.
-     *
-     * @return The WeatherType that the player is currently experiencing or
-     *     null if player is seeing server weather.
-     */
-    public WeatherType getPlayerWeather();
-
-    /**
-     * Restores the normal condition where the player's weather is controlled
-     * by server conditions.
-     */
-    public void resetPlayerWeather();
-
-    /**
-     * Gives the player the amount of experience specified.
-     *
-     * @param amount Exp amount to give
-     */
-    public void giveExp(int amount);
-
-    /**
-     * Gives the player the amount of experience levels specified. Levels can
-     * be taken by specifying a negative amount.
-     *
-     * @param amount amount of experience levels to give or take
-     */
-    public void giveExpLevels(int amount);
-
-    /**
-     * Gets the players current experience points towards the next level.
-     * <p>
-     * This is a percentage value. 0 is "no progress" and 1 is "next level".
-     *
-     * @return Current experience points
-     */
-    public float getExp();
-
-    /**
-     * Sets the players current experience points towards the next level
-     * <p>
-     * This is a percentage value. 0 is "no progress" and 1 is "next level".
-     *
-     * @param exp New experience points
-     */
-    public void setExp(float exp);
-
-    /**
-     * Gets the players current experience level
-     *
-     * @return Current experience level
-     */
-    public int getLevel();
-
-    /**
-     * Sets the players current experience level
-     *
-     * @param level New experience level
-     */
-    public void setLevel(int level);
-
-    /**
-     * Gets the players total experience points
-     *
-     * @return Current total experience points
-     */
-    public int getTotalExperience();
-
-    /**
-     * Sets the players current experience level
-     *
-     * @param exp New experience level
-     */
-    public void setTotalExperience(int exp);
-
-    /**
-     * Gets the players current exhaustion level.
-     * <p>
-     * Exhaustion controls how fast the food level drops. While you have a
-     * certain amount of exhaustion, your saturation will drop to zero, and
-     * then your food will drop to zero.
-     *
-     * @return Exhaustion level
-     */
-    public float getExhaustion();
-
-    /**
-     * Sets the players current exhaustion level
-     *
-     * @param value Exhaustion level
-     */
-    public void setExhaustion(float value);
-
-    /**
-     * Gets the players current saturation level.
-     * <p>
-     * Saturation is a buffer for food level. Your food level will not drop if
-     * you are saturated {@literal >} 0.
-     *
-     * @return Saturation level
-     */
-    public float getSaturation();
-
-    /**
-     * Sets the players current saturation level
-     *
-     * @param value Saturation level
-     */
-    public void setSaturation(float value);
-
-    /**
-     * Gets the players current food level
-     *
-     * @return Food level
-     */
-    public int getFoodLevel();
-
-    /**
-     * Sets the players current food level
-     *
-     * @param value New food level
-     */
-    public void setFoodLevel(int value);
-
-    /**
-     * Gets the Location where the player will spawn at their bed, null if
-     * they have not slept in one or their current bed spawn is invalid.
-     *
-     * @return Bed Spawn Location if bed exists, otherwise null.
-     */
-    public Location getBedSpawnLocation();
-
-    /**
-     * Sets the Location where the player will spawn at their bed.
-     *
-     * @param location where to set the respawn location
-     */
-    public void setBedSpawnLocation(Location location);
-
-    /**
-     * Sets the Location where the player will spawn at their bed.
-     *
-     * @param location where to set the respawn location
-     * @param force whether to forcefully set the respawn location even if a
-     *     valid bed is not present
-     */
-    public void setBedSpawnLocation(Location location, boolean force);
-
-    /**
-     * Determines if the Player is allowed to fly via jump key double-tap like
-     * in creative mode.
-     *
-     * @return True if the player is allowed to fly.
-     */
-    public boolean getAllowFlight();
-
-    /**
-     * Sets if the Player is allowed to fly via jump key double-tap like in
-     * creative mode.
-     *
-     * @param flight If flight should be allowed.
-     */
-    public void setAllowFlight(boolean flight);
-
-    /**
-     * Hides a player from this player
-     *
-     * @param player Player to hide
-     */
-    public void hidePlayer(Player player);
-
-    /**
-     * Allows this player to see a player that was previously hidden
-     *
-     * @param player Player to show
-     */
-    public void showPlayer(Player player);
-
-    /**
-     * Checks to see if a player has been hidden from this player
-     *
-     * @param player Player to check
-     * @return True if the provided player is not being hidden from this
-     *     player
-     */
-    public boolean canSee(Player player);
-
-    /**
-     * Checks to see if this player is currently standing on a block. This
-     * information may not be reliable, as it is a state provided by the
-     * client, and may therefore not be accurate.
-     *
-     * @return True if the player standing on a solid block, else false.
-     * @deprecated Inconsistent with {@link
-     *     org.bukkit.entity.Entity#isOnGround()}
-     */
-    @Deprecated
-    public boolean isOnGround();
-
-    /**
-     * Checks to see if this player is currently flying or not.
-     *
-     * @return True if the player is flying, else false.
-     */
-    public boolean isFlying();
-
-    /**
-     * Makes this player start or stop flying.
-     *
-     * @param value True to fly.
-     */
-    public void setFlying(boolean value);
-
-    /**
-     * Sets the speed at which a client will fly. Negative values indicate
-     * reverse directions.
-     *
-     * @param value The new speed, from -1 to 1.
-     * @throws IllegalArgumentException If new speed is less than -1 or
-     *     greater than 1
-     */
-    public void setFlySpeed(float value) throws IllegalArgumentException;
-
-    /**
-     * Sets the speed at which a client will walk. Negative values indicate
-     * reverse directions.
-     *
-     * @param value The new speed, from -1 to 1.
-     * @throws IllegalArgumentException If new speed is less than -1 or
-     *     greater than 1
-     */
-    public void setWalkSpeed(float value) throws IllegalArgumentException;
-
-    /**
-     * Gets the current allowed speed that a client can fly.
-     *
-     * @return The current allowed speed, from -1 to 1
-     */
-    public float getFlySpeed();
-
-    /**
-     * Gets the current allowed speed that a client can walk.
-     *
-     * @return The current allowed speed, from -1 to 1
-     */
-    public float getWalkSpeed();
-
-    /**
-     * Request that the player's client download and switch texture packs.
-     * <p>
-     * The player's client will download the new texture pack asynchronously
-     * in the background, and will automatically switch to it once the
-     * download is complete. If the client has downloaded and cached the same
-     * texture pack in the past, it will perform a quick timestamp check over
-     * the network to determine if the texture pack has changed and needs to
-     * be downloaded again. When this request is sent for the very first time
-     * from a given server, the client will first display a confirmation GUI
-     * to the player before proceeding with the download.
-     * <p>
-     * Notes:
-     * <ul>
-     * <li>Players can disable server textures on their client, in which
-     *     case this method will have no affect on them.
-     * <li>There is no concept of resetting texture packs back to default
-     *     within Minecraft, so players will have to relog to do so.
-     * </ul>
-     *
-     * @param url The URL from which the client will download the texture
-     *     pack. The string must contain only US-ASCII characters and should
-     *     be encoded as per RFC 1738.
-     * @throws IllegalArgumentException Thrown if the URL is null.
-     * @throws IllegalArgumentException Thrown if the URL is too long.
-     * @deprecated Minecraft no longer uses textures packs. Instead you
-     *     should use {@link #setResourcePack(String)}.
-     */
-    @Deprecated
-    public void setTexturePack(String url);
-
-    /**
-     * Request that the player's client download and switch resource packs.
-     * <p>
-     * The player's client will download the new resource pack asynchronously
-     * in the background, and will automatically switch to it once the
-     * download is complete. If the client has downloaded and cached the same
-     * resource pack in the past, it will perform a quick timestamp check
-     * over the network to determine if the resource pack has changed and
-     * needs to be downloaded again. When this request is sent for the very
-     * first time from a given server, the client will first display a
-     * confirmation GUI to the player before proceeding with the download.
-     * <p>
-     * Notes:
-     * <ul>
-     * <li>Players can disable server resources on their client, in which
-     *     case this method will have no affect on them.
-     * <li>There is no concept of resetting resource packs back to default
-     *     within Minecraft, so players will have to relog to do so.
-     * </ul>
-     *
-     * @param url The URL from which the client will download the resource
-     *     pack. The string must contain only US-ASCII characters and should
-     *     be encoded as per RFC 1738.
-     * @throws IllegalArgumentException Thrown if the URL is null.
-     * @throws IllegalArgumentException Thrown if the URL is too long. The
-     *     length restriction is an implementation specific arbitrary value.
-     * @deprecated use {@link #setResourcePack(String, String)}
-     */
-    @Deprecated // Paper
-    public void setResourcePack(String url);
-
-    /**
-     * Gets the Scoreboard displayed to this player
-     *
-     * @return The current scoreboard seen by this player
-     */
-    public Scoreboard getScoreboard();
-
-    /**
-     * Sets the player's visible Scoreboard.
-     *
-     * @param scoreboard New Scoreboard for the player
-     * @throws IllegalArgumentException if scoreboard is null
-     * @throws IllegalArgumentException if scoreboard was not created by the
-     *     {@link org.bukkit.scoreboard.ScoreboardManager scoreboard manager}
-     * @throws IllegalStateException if this is a player that is not logged
-     *     yet or has logged out
-     */
-    public void setScoreboard(Scoreboard scoreboard) throws IllegalArgumentException, IllegalStateException;
-
-    /**
-     * Gets if the client is displayed a 'scaled' health, that is, health on a
-     * scale from 0-{@link #getHealthScale()}.
-     *
-     * @return if client health display is scaled
-     * @see Player#setHealthScaled(boolean)
-     */
-    public boolean isHealthScaled();
-
-    /**
-     * Sets if the client is displayed a 'scaled' health, that is, health on a
-     * scale from 0-{@link #getHealthScale()}.
-     * <p>
-     * Displayed health follows a simple formula <code>displayedHealth =
-     * getHealth() / getMaxHealth() * getHealthScale()</code>.
-     *
-     * @param scale if the client health display is scaled
-     */
-    public void setHealthScaled(boolean scale);
-
-    /**
-     * Sets the number to scale health to for the client; this will also
-     * {@link #setHealthScaled(boolean) setHealthScaled(true)}.
-     * <p>
-     * Displayed health follows a simple formula <code>displayedHealth =
-     * getHealth() / getMaxHealth() * getHealthScale()</code>.
-     *
-     * @param scale the number to scale health to
-     * @throws IllegalArgumentException if scale is &lt;0
-     * @throws IllegalArgumentException if scale is {@link Double#NaN}
-     * @throws IllegalArgumentException if scale is too high
-     */
-    public void setHealthScale(double scale) throws IllegalArgumentException;
-
-    /**
-     * Gets the number that health is scaled to for the client.
-     *
-     * @return the number that health would be scaled to for the client if
-     *     HealthScaling is set to true
-     * @see Player#setHealthScale(double)
-     * @see Player#setHealthScaled(boolean)
-     */
-    public double getHealthScale();
-
-    /**
-     * Gets the entity which is followed by the camera when in
-     * {@link GameMode#SPECTATOR}.
-     *
-     * @return the followed entity, or null if not in spectator mode or not
-     * following a specific entity.
-     */
-    public Entity getSpectatorTarget();
-
-    /**
-     * Sets the entity which is followed by the camera when in
-     * {@link GameMode#SPECTATOR}.
-     *
-     * @param entity the entity to follow or null to reset
-     * @throws IllegalStateException if the player is not in
-     * {@link GameMode#SPECTATOR}
-     */
-    public void setSpectatorTarget(Entity entity);
-
-    /**
-     * Sends a title and a subtitle message to the player. If either of these
-     * values are null, they will not be sent and the display will remain
-     * unchanged. If they are empty strings, the display will be updated as
-     * such. If the strings contain a new line, only the first line will be
-     * sent.
-     *
-     * @param title Title text
-     * @param subtitle Subtitle text
-     * @deprecated API subject to change
-     */
-    @Deprecated
-    public void sendTitle(String title, String subtitle);
-
-    /**
-     * Resets the title displayed to the player.
-     * @deprecated API subject to change.
-     */
-    // Paper - undeprecate
-    public void resetTitle();
-
-
-    /**
-     * Spawns the particle (the number of times specified by count)
-     * at the target location.
-     *
-     * @param particle the particle to spawn
-     * @param location the location to spawn at
-     * @param count the number of particles
-     */
-    public void spawnParticle(Particle particle, Location location, int count);
-
-    /**
-     * Spawns the particle (the number of times specified by count)
-     * at the target location.
-     *
-     * @param particle the particle to spawn
-     * @param x the position on the x axis to spawn at
-     * @param y the position on the y axis to spawn at
-     * @param z the position on the z axis to spawn at
-     * @param count the number of particles
-     */
-    public void spawnParticle(Particle particle, double x, double y, double z, int count);
-
-    /**
-     * Spawns the particle (the number of times specified by count)
-     * at the target location.
-     *
-     * @param particle the particle to spawn
-     * @param location the location to spawn at
-     * @param count the number of particles
-     * @param data the data to use for the particle or null,
-     *             the type of this depends on {@link Particle#getDataType()}
-     */
-    public <T> void spawnParticle(Particle particle, Location location, int count, T data);
-
-
-    /**
-     * Spawns the particle (the number of times specified by count)
-     * at the target location.
-     *
-     * @param particle the particle to spawn
-     * @param x the position on the x axis to spawn at
-     * @param y the position on the y axis to spawn at
-     * @param z the position on the z axis to spawn at
-     * @param count the number of particles
-     * @param data the data to use for the particle or null,
-     *             the type of this depends on {@link Particle#getDataType()}
-     */
-    public <T> void spawnParticle(Particle particle, double x, double y, double z, int count, T data);
-
-    /**
-     * Spawns the particle (the number of times specified by count)
-     * at the target location. The position of each particle will be
-     * randomized positively and negatively by the offset parameters
-     * on each axis.
-     *
-     * @param particle the particle to spawn
-     * @param location the location to spawn at
-     * @param count the number of particles
-     * @param offsetX the maximum random offset on the X axis
-     * @param offsetY the maximum random offset on the Y axis
-     * @param offsetZ the maximum random offset on the Z axis
-     */
-    public void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ);
-
-    /**
-     * Spawns the particle (the number of times specified by count)
-     * at the target location. The position of each particle will be
-     * randomized positively and negatively by the offset parameters
-     * on each axis.
-     *
-     * @param particle the particle to spawn
-     * @param x the position on the x axis to spawn at
-     * @param y the position on the y axis to spawn at
-     * @param z the position on the z axis to spawn at
-     * @param count the number of particles
-     * @param offsetX the maximum random offset on the X axis
-     * @param offsetY the maximum random offset on the Y axis
-     * @param offsetZ the maximum random offset on the Z axis
-     */
-    public void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ);
-
-    /**
-     * Spawns the particle (the number of times specified by count)
-     * at the target location. The position of each particle will be
-     * randomized positively and negatively by the offset parameters
-     * on each axis.
-     *
-     * @param particle the particle to spawn
-     * @param location the location to spawn at
-     * @param count the number of particles
-     * @param offsetX the maximum random offset on the X axis
-     * @param offsetY the maximum random offset on the Y axis
-     * @param offsetZ the maximum random offset on the Z axis
-     * @param data the data to use for the particle or null,
-     *             the type of this depends on {@link Particle#getDataType()}
-     */
-    public <T> void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ, T data);
-
-    /**
-     * Spawns the particle (the number of times specified by count)
-     * at the target location. The position of each particle will be
-     * randomized positively and negatively by the offset parameters
-     * on each axis.
-     *
-     * @param particle the particle to spawn
-     * @param x the position on the x axis to spawn at
-     * @param y the position on the y axis to spawn at
-     * @param z the position on the z axis to spawn at
-     * @param count the number of particles
-     * @param offsetX the maximum random offset on the X axis
-     * @param offsetY the maximum random offset on the Y axis
-     * @param offsetZ the maximum random offset on the Z axis
-     * @param data the data to use for the particle or null,
-     *             the type of this depends on {@link Particle#getDataType()}
-     */
-    public <T> void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ, T data);
-
-    /**
-     * Spawns the particle (the number of times specified by count)
-     * at the target location. The position of each particle will be
-     * randomized positively and negatively by the offset parameters
-     * on each axis.
-     *
-     * @param particle the particle to spawn
-     * @param location the location to spawn at
-     * @param count the number of particles
-     * @param offsetX the maximum random offset on the X axis
-     * @param offsetY the maximum random offset on the Y axis
-     * @param offsetZ the maximum random offset on the Z axis
-     * @param extra the extra data for this particle, depends on the
-     *              particle used (normally speed)
-     */
-    public void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ, double extra);
-
-    /**
-     * Spawns the particle (the number of times specified by count)
-     * at the target location. The position of each particle will be
-     * randomized positively and negatively by the offset parameters
-     * on each axis.
-     *
-     * @param particle the particle to spawn
-     * @param x the position on the x axis to spawn at
-     * @param y the position on the y axis to spawn at
-     * @param z the position on the z axis to spawn at
-     * @param count the number of particles
-     * @param offsetX the maximum random offset on the X axis
-     * @param offsetY the maximum random offset on the Y axis
-     * @param offsetZ the maximum random offset on the Z axis
-     * @param extra the extra data for this particle, depends on the
-     *              particle used (normally speed)
-     */
-    public void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ, double extra);
-
-    /**
-     * Spawns the particle (the number of times specified by count)
-     * at the target location. The position of each particle will be
-     * randomized positively and negatively by the offset parameters
-     * on each axis.
-     *
-     * @param particle the particle to spawn
-     * @param location the location to spawn at
-     * @param count the number of particles
-     * @param offsetX the maximum random offset on the X axis
-     * @param offsetY the maximum random offset on the Y axis
-     * @param offsetZ the maximum random offset on the Z axis
-     * @param extra the extra data for this particle, depends on the
-     *              particle used (normally speed)
-     * @param data the data to use for the particle or null,
-     *             the type of this depends on {@link Particle#getDataType()}
-     */
-    public <T> void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ, double extra, T data);
-
-    /**
-     * Spawns the particle (the number of times specified by count)
-     * at the target location. The position of each particle will be
-     * randomized positively and negatively by the offset parameters
-     * on each axis.
-     *
-     * @param particle the particle to spawn
-     * @param x the position on the x axis to spawn at
-     * @param y the position on the y axis to spawn at
-     * @param z the position on the z axis to spawn at
-     * @param count the number of particles
-     * @param offsetX the maximum random offset on the X axis
-     * @param offsetY the maximum random offset on the Y axis
-     * @param offsetZ the maximum random offset on the Z axis
-     * @param extra the extra data for this particle, depends on the
-     *              particle used (normally speed)
-     * @param data the data to use for the particle or null,
-     *             the type of this depends on {@link Particle#getDataType()}
-     */
-    public <T> void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ, double extra, T data);
-
-    /**
-     * Get whether the player can affect mob spawning
-     *
-     * @return if the player can affect mob spawning
-     */
-    public boolean getAffectsSpawning();
-
-    /**
-     * Set whether the player can affect mob spawning
-     *
-     * @param affects Whether the player can affect mob spawning
-     */
-    public void setAffectsSpawning(boolean affects);
-
-    /**
-     * Gets the view distance for this player
-     *
-     * @return the player's view distance
-     */
-    public int getViewDistance();
-
-    /**
-     * Sets the view distance for this player
-     *
-     * @param viewDistance the player's view distance
-     */
-    public void setViewDistance(int viewDistance);
-
-    // Paper start
-    /**
-     * Request that the player's client download and switch resource packs.
-     * <p>
-     * The player's client will download the new resource pack asynchronously
-     * in the background, and will automatically switch to it once the
-     * download is complete. If the client has downloaded and cached the same
-     * resource pack in the past, it will perform a quick timestamp check
-     * over the network to determine if the resource pack has changed and
-     * needs to be downloaded again. When this request is sent for the very
-     * first time from a given server, the client will first display a
-     * confirmation GUI to the player before proceeding with the download.
-     * <p>
-     * Notes:
-     * <ul>
-     * <li>Players can disable server resources on their client, in which
-     *     case this method will have no affect on them.
-     * <li>There is no concept of resetting resource packs back to default
-     *     within Minecraft, so players will have to relog to do so.
-     * </ul>
-     *
-     * @param url The URL from which the client will download the resource
-     *     pack. The string must contain only US-ASCII characters and should
-     *     be encoded as per RFC 1738.
-     * @param hash A 40 character hexadecimal and lowercase SHA-1 digest of
-     *     the resource pack file.
-     * @throws IllegalArgumentException Thrown if the URL is null.
-     * @throws IllegalArgumentException Thrown if the URL is too long. The
-     *     length restriction is an implementation specific arbitrary value.
-     */
-    void setResourcePack(String url, String hash);
-
-    /**
-     * @return the most recent resource pack status received from the player,
-     *         or null if no status has ever been received from this player.
-     */
-    org.bukkit.event.player.PlayerResourcePackStatusEvent.Status getResourcePackStatus();
-
-    /**
-     * @return the most recent resource pack hash received from the player,
-     *         or null if no hash has ever been received from this player.
-     */
-    String getResourcePackHash();
-
-    /**
-     * @return true if the last resource pack status received from this player
-     *         was {@link org.bukkit.event.player.PlayerResourcePackStatusEvent.Status#SUCCESSFULLY_LOADED}
-     */
-    boolean hasResourcePack();
-    // Paper end
-
-    // Spigot start
-    public class Spigot extends Entity.Spigot
-    {
-
-        /**
-         * Gets the connection address of this player, regardless of whether it
-         * has been spoofed or not.
-         *
-         * @return the player's connection address
-         */
-        public InetSocketAddress getRawAddress()
-        {
-            throw new UnsupportedOperationException( "Not supported yet." );
-        }
-
-        public void playEffect(Location location, Effect effect, int id, int data, float offsetX, float offsetY, float offsetZ, float speed, int particleCount, int radius)
-        {
-            throw new UnsupportedOperationException( "Not supported yet." );
-        }
-
-        /**
-         * Gets whether the player collides with entities
-         *
-         * @return the player's collision toggle state
-         * @deprecated see {@link LivingEntity#isCollidable()}
-         */
-        @Deprecated
-        public boolean getCollidesWithEntities()
-        {
-            throw new UnsupportedOperationException( "Not supported yet." );
-        }
-
-        /**
-         * Sets whether the player collides with entities
-         *
-         * @param collides whether the player should collide with entities or
-         * not.
-         * @deprecated {@link LivingEntity#setCollidable(boolean)}
-         */
-        @Deprecated
-        public void setCollidesWithEntities(boolean collides)
-        {
-            throw new UnsupportedOperationException( "Not supported yet." );
-        }
-
-        /**
-         * Respawns the player if dead.
-         */
-        public void respawn()
-        {
-            throw new UnsupportedOperationException( "Not supported yet." );
-        }
-
-        /**
-         * Gets player locale language.
-         *
-         * @return the player's client language settings
-         */
-        public String getLocale()
-        {
-            throw new UnsupportedOperationException( "Not supported yet." );
-        }
-
-        /**
-         * Gets all players hidden with {@link #hidePlayer(org.bukkit.entity.Player)}.
-         *
-         * @return a Set with all hidden players
-         */
-        public java.util.Set<Player> getHiddenPlayers()
-        {
-            throw new UnsupportedOperationException( "Not supported yet." );
-        }
-
-        /**
-         * Sends the component to the player
-         *
-         * @param component the components to send
-         */
-        public void sendMessage(net.md_5.bungee.api.chat.BaseComponent component) {
-            throw new UnsupportedOperationException("Not supported yet.");
-        }
-
-        /**
-         * Sends an array of components as a single message to the player
-         *
-         * @param components the components to send
-         */
-        public void sendMessage(net.md_5.bungee.api.chat.BaseComponent... components) {
-            throw new UnsupportedOperationException("Not supported yet.");
-        }
-
-        /**
-         * Sends the component to the specified screen position of this player
-         *
-         * @param position the screen position
-         * @param component the components to send
-         */
-        public void sendMessage(net.md_5.bungee.api.ChatMessageType position, net.md_5.bungee.api.chat.BaseComponent component) {
-            throw new UnsupportedOperationException("Not supported yet.");
-        }
-
-        /**
-         * Sends an array of components as a single message to the specified screen position of this player
-         *
-         * @param position the screen position
-         * @param component the components to send
-         */
-        public void sendMessage(net.md_5.bungee.api.ChatMessageType position, net.md_5.bungee.api.chat.BaseComponent... components) {
-            throw new UnsupportedOperationException("Not supported yet.");
-        }
-
-        public int getPing()
-        {
-            throw new UnsupportedOperationException( "Not supported yet." );
-        }
-    }
-
-    Spigot spigot();
-    // Spigot end
-	
-	// Paper start
-    /**
-     * Return this player's profile
-     *
-     * @return this player's profile
-     */
-    @Override
-    public AccountProfile getAccount();
-    // Paper end
-}
diff --git a/src/main/java/org/bukkit/block/DoubleChest.java b/src/main/java/org/bukkit/block/DoubleChest.java
new file mode 100644
index 0000000..663fcbb
--- /dev/null
+++ b/src/main/java/org/bukkit/block/DoubleChest.java
@@ -0,0 +1,50 @@
+package org.bukkit.block;
+
+import org.bukkit.Location;
+import org.bukkit.World;
+import org.bukkit.inventory.DoubleChestInventory;
+import org.bukkit.inventory.Inventory;
+import org.bukkit.inventory.InventoryHolder;
+
+/**
+ * Represents a double chest.
+ */
+public class DoubleChest implements InventoryHolder {
+    private DoubleChestInventory inventory;
+
+    public DoubleChest(DoubleChestInventory chest) {
+        inventory = chest;
+    }
+
+    public Inventory getInventory() {
+        return inventory;
+    }
+
+    public InventoryHolder getLeftSide() {
+        return inventory.getLeftSide().getHolder();
+    }
+
+    public InventoryHolder getRightSide() {
+        return inventory.getRightSide().getHolder();
+    }
+
+    public Location getLocation() {
+        return getInventory().getLocation();
+    }
+
+    public World getWorld() {
+        return getLocation().getWorld();
+    }
+
+    public double getX() {
+        return getLocation().getX();
+    }
+
+    public double getY() {
+        return getLocation().getY();
+    }
+
+    public double getZ() {
+        return getLocation().getZ();
+    }
+}
diff --git a/src/main/java/org/bukkit/bukkit/block/DoubleChest.java b/src/main/java/org/bukkit/bukkit/block/DoubleChest.java
deleted file mode 100644
index 663fcbb..0000000
--- a/src/main/java/org/bukkit/bukkit/block/DoubleChest.java
+++ /dev/null
@@ -1,50 +0,0 @@
-package org.bukkit.block;
-
-import org.bukkit.Location;
-import org.bukkit.World;
-import org.bukkit.inventory.DoubleChestInventory;
-import org.bukkit.inventory.Inventory;
-import org.bukkit.inventory.InventoryHolder;
-
-/**
- * Represents a double chest.
- */
-public class DoubleChest implements InventoryHolder {
-    private DoubleChestInventory inventory;
-
-    public DoubleChest(DoubleChestInventory chest) {
-        inventory = chest;
-    }
-
-    public Inventory getInventory() {
-        return inventory;
-    }
-
-    public InventoryHolder getLeftSide() {
-        return inventory.getLeftSide().getHolder();
-    }
-
-    public InventoryHolder getRightSide() {
-        return inventory.getRightSide().getHolder();
-    }
-
-    public Location getLocation() {
-        return getInventory().getLocation();
-    }
-
-    public World getWorld() {
-        return getLocation().getWorld();
-    }
-
-    public double getX() {
-        return getLocation().getX();
-    }
-
-    public double getY() {
-        return getLocation().getY();
-    }
-
-    public double getZ() {
-        return getLocation().getZ();
-    }
-}
diff --git a/src/main/java/org/bukkit/bukkit/command/SimpleCommandMap.java b/src/main/java/org/bukkit/bukkit/command/SimpleCommandMap.java
deleted file mode 100644
index 9326b8d..0000000
--- a/src/main/java/org/bukkit/bukkit/command/SimpleCommandMap.java
+++ /dev/null
@@ -1,261 +0,0 @@
-package org.bukkit.command;
-
-import static org.bukkit.util.Java15Compat.Arrays_copyOfRange;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.regex.Pattern;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.Server;
-import org.bukkit.command.defaults.*;
-import org.bukkit.entity.Player;
-import org.bukkit.util.StringUtil;
-
-public class SimpleCommandMap implements CommandMap {
-    private static final Pattern PATTERN_ON_SPACE = Pattern.compile(" ", Pattern.LITERAL);
-    protected final Map<String, Command> knownCommands = new HashMap<String, Command>();
-    private final Server server;
-
-    public SimpleCommandMap(final Server server) {
-        this.server = server;
-        setDefaultCommands();
-    }
-
-    private void setDefaultCommands() {
-        register("bukkit", new VersionCommand("version"));
-        register("bukkit", new ReloadCommand("reload"));
-        register("bukkit", new PluginsCommand("plugins"));
-        register("bukkit", new TimingsCommand("timings"));
-    }
-
-    public void setFallbackCommands() {
-        register("bukkit", new HelpCommand());
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public void registerAll(String fallbackPrefix, List<Command> commands) {
-        if (commands != null) {
-            for (Command c : commands) {
-                register(fallbackPrefix, c);
-            }
-        }
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public boolean register(String fallbackPrefix, Command command) {
-        return register(command.getName(), fallbackPrefix, command);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public boolean register(String label, String fallbackPrefix, Command command) {
-        label = label.toLowerCase().trim();
-        fallbackPrefix = fallbackPrefix.toLowerCase().trim();
-        boolean registered = register(label, command, false, fallbackPrefix);
-
-        Iterator<String> iterator = command.getAliases().iterator();
-        while (iterator.hasNext()) {
-            if (!register(iterator.next(), command, true, fallbackPrefix)) {
-                iterator.remove();
-            }
-        }
-
-        // If we failed to register under the real name, we need to set the command label to the direct address
-        if (!registered) {
-            command.setLabel(fallbackPrefix + ":" + label);
-        }
-
-        // Register to us so further updates of the commands label and aliases are postponed until its reregistered
-        command.register(this);
-
-        return registered;
-    }
-
-    /**
-     * Registers a command with the given name is possible. Also uses
-     * fallbackPrefix to create a unique name.
-     *
-     * @param label the name of the command, without the '/'-prefix.
-     * @param command the command to register
-     * @param isAlias whether the command is an alias
-     * @param fallbackPrefix a prefix which is prepended to the command for a
-     *     unique address
-     * @return true if command was registered, false otherwise.
-     */
-    private synchronized boolean register(String label, Command command, boolean isAlias, String fallbackPrefix) {
-        knownCommands.put(fallbackPrefix + ":" + label, command);
-        if ((command instanceof VanillaCommand || isAlias) && knownCommands.containsKey(label)) {
-            // Request is for an alias/fallback command and it conflicts with
-            // a existing command or previous alias ignore it
-            // Note: This will mean it gets removed from the commands list of active aliases
-            return false;
-        }
-
-        boolean registered = true;
-
-        // If the command exists but is an alias we overwrite it, otherwise we return
-        Command conflict = knownCommands.get(label);
-        if (conflict != null && conflict.getLabel().equals(label)) {
-            return false;
-        }
-
-        if (!isAlias) {
-            command.setLabel(label);
-        }
-        knownCommands.put(label, command);
-
-        return registered;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public boolean dispatch(CommandSender sender, String commandLine) throws CommandException {
-        String[] args = PATTERN_ON_SPACE.split(commandLine);
-
-        if (args.length == 0) {
-            return false;
-        }
-
-        String sentCommandLabel = args[0].toLowerCase();
-        Command target = getCommand(sentCommandLabel);
-
-        if (target == null) {
-            return false;
-        }
-
-        try {
-            // Note: we don't return the result of target.execute as thats success / failure, we return handled (true) or not handled (false)
-            target.execute(sender, sentCommandLabel, Arrays_copyOfRange(args, 1, args.length));
-        } catch (CommandException ex) {
-            throw ex;
-        } catch (Throwable ex) {
-            throw new CommandException("Unhandled exception executing '" + commandLine + "' in " + target, ex);
-        }
-
-        // return true as command was handled
-        return true;
-    }
-
-    public synchronized void clearCommands() {
-        for (Map.Entry<String, Command> entry : knownCommands.entrySet()) {
-            entry.getValue().unregister(this);
-        }
-        knownCommands.clear();
-        setDefaultCommands();
-    }
-
-    public Command getCommand(String name) {
-        Command target = knownCommands.get(name.toLowerCase());
-        return target;
-    }
-
-    public List<String> tabComplete(CommandSender sender, String cmdLine) {
-        Validate.notNull(sender, "Sender cannot be null");
-        Validate.notNull(cmdLine, "Command line cannot null");
-
-        int spaceIndex = cmdLine.indexOf(' ');
-
-        if (spaceIndex == -1) {
-            ArrayList<String> completions = new ArrayList<String>();
-            Map<String, Command> knownCommands = this.knownCommands;
-
-            final String prefix = (sender instanceof Player ? "/" : "");
-
-            for (Map.Entry<String, Command> commandEntry : knownCommands.entrySet()) {
-                Command command = commandEntry.getValue();
-
-                if (!command.testPermissionSilent(sender)) {
-                    continue;
-                }
-
-                String name = commandEntry.getKey(); // Use the alias, not command name
-
-                if (StringUtil.startsWithIgnoreCase(name, cmdLine)) {
-                    completions.add(prefix + name);
-                }
-            }
-
-            Collections.sort(completions, String.CASE_INSENSITIVE_ORDER);
-            return completions;
-        }
-
-        String commandName = cmdLine.substring(0, spaceIndex);
-        Command target = getCommand(commandName);
-
-        if (target == null) {
-            return null;
-        }
-
-        if (!target.testPermissionSilent(sender)) {
-            return null;
-        }
-
-        String argLine = cmdLine.substring(spaceIndex + 1, cmdLine.length());
-        String[] args = PATTERN_ON_SPACE.split(argLine, -1);
-
-        try {
-            return target.tabComplete(sender, commandName, args);
-        } catch (CommandException ex) {
-            throw ex;
-        } catch (Throwable ex) {
-            throw new CommandException("Unhandled exception executing tab-completer for '" + cmdLine + "' in " + target, ex);
-        }
-    }
-
-    public Collection<Command> getCommands() {
-        return Collections.unmodifiableCollection(knownCommands.values());
-    }
-
-    public void registerServerAliases() {
-        Map<String, String[]> values = server.getCommandAliases();
-
-        for (String alias : values.keySet()) {
-            if (alias.contains(" ")) { // Torch
-                server.getLogger().warning("Could not register alias " + alias + " because it contains illegal characters");
-                continue;
-            }
-
-            String[] commandStrings = values.get(alias);
-            List<String> targets = new ArrayList<String>();
-            StringBuilder bad = new StringBuilder();
-
-            for (String commandString : commandStrings) {
-                String[] commandArgs = commandString.split(" ");
-                Command command = getCommand(commandArgs[0]);
-
-                if (command == null) {
-                    if (bad.length() > 0) {
-                        bad.append(", ");
-                    }
-                    bad.append(commandString);
-                } else {
-                    targets.add(commandString);
-                }
-            }
-
-            if (bad.length() > 0) {
-                server.getLogger().warning("Could not register alias " + alias + " because it contains commands that do not exist: " + bad);
-                continue;
-            }
-
-            // We register these as commands so they have absolute priority.
-            if (targets.size() > 0) {
-                knownCommands.put(alias.toLowerCase(), new FormattedCommandAlias(alias.toLowerCase(), targets.toArray(new String[targets.size()])));
-            } else {
-                knownCommands.remove(alias.toLowerCase());
-            }
-        }
-    }
-}
diff --git a/src/main/java/org/bukkit/bukkit/enchantments/EnchantmentTarget.java b/src/main/java/org/bukkit/bukkit/enchantments/EnchantmentTarget.java
deleted file mode 100644
index dee2350..0000000
--- a/src/main/java/org/bukkit/bukkit/enchantments/EnchantmentTarget.java
+++ /dev/null
@@ -1,182 +0,0 @@
-package org.bukkit.enchantments;
-
-import org.bukkit.Material;
-import org.bukkit.inventory.ItemStack;
-
-/**
- * Represents the applicable target for a {@link Enchantment}
- */
-public enum EnchantmentTarget {
-    /**
-     * Allows the Enchantment to be placed on all items
-     */
-    ALL {
-        @Override
-        public boolean includes(Material item) {
-            return true;
-        }
-    },
-
-    /**
-     * Allows the Enchantment to be placed on armor
-     */
-    ARMOR {
-        @Override
-        public boolean includes(Material item) {
-            return ARMOR_FEET.includes(item)
-                || ARMOR_LEGS.includes(item)
-                || ARMOR_HEAD.includes(item)
-                || ARMOR_TORSO.includes(item);
-        }
-    },
-
-    /**
-     * Allows the Enchantment to be placed on feet slot armor
-     */
-    ARMOR_FEET {
-        @Override
-        public boolean includes(Material item) {
-            return item.equals(Material.LEATHER_BOOTS)
-                || item.equals(Material.CHAINMAIL_BOOTS)
-                || item.equals(Material.IRON_BOOTS)
-                || item.equals(Material.DIAMOND_BOOTS)
-                || item.equals(Material.GOLD_BOOTS);
-        }
-    },
-
-    /**
-     * Allows the Enchantment to be placed on leg slot armor
-     */
-    ARMOR_LEGS {
-        @Override
-        public boolean includes(Material item) {
-            return item.equals(Material.LEATHER_LEGGINGS)
-                || item.equals(Material.CHAINMAIL_LEGGINGS)
-                || item.equals(Material.IRON_LEGGINGS)
-                || item.equals(Material.DIAMOND_LEGGINGS)
-                || item.equals(Material.GOLD_LEGGINGS);
-        }
-    },
-
-    /**
-     * Allows the Enchantment to be placed on torso slot armor
-     */
-    ARMOR_TORSO {
-        @Override
-        public boolean includes(Material item) {
-            return item.equals(Material.LEATHER_CHESTPLATE)
-                || item.equals(Material.CHAINMAIL_CHESTPLATE)
-                || item.equals(Material.IRON_CHESTPLATE)
-                || item.equals(Material.DIAMOND_CHESTPLATE)
-                || item.equals(Material.GOLD_CHESTPLATE);
-        }
-    },
-
-    /**
-     * Allows the Enchantment to be placed on head slot armor
-     */
-    ARMOR_HEAD {
-        @Override
-        public boolean includes(Material item) {
-            return item.equals(Material.LEATHER_HELMET)
-                || item.equals(Material.CHAINMAIL_HELMET)
-                || item.equals(Material.DIAMOND_HELMET)
-                || item.equals(Material.IRON_HELMET)
-                || item.equals(Material.GOLD_HELMET);
-        }
-    },
-
-    /**
-     * Allows the Enchantment to be placed on weapons (swords)
-     */
-    WEAPON {
-        @Override
-        public boolean includes(Material item) {
-            return item.equals(Material.WOOD_SWORD)
-                || item.equals(Material.STONE_SWORD)
-                || item.equals(Material.IRON_SWORD)
-                || item.equals(Material.DIAMOND_SWORD)
-                || item.equals(Material.GOLD_SWORD);
-        }
-    },
-
-    /**
-     * Allows the Enchantment to be placed on tools (spades, pickaxe, hoes,
-     * axes)
-     */
-    TOOL {
-        @Override
-        public boolean includes(Material item) {
-            return item.equals(Material.WOOD_SPADE)
-                || item.equals(Material.STONE_SPADE)
-                || item.equals(Material.IRON_SPADE)
-                || item.equals(Material.DIAMOND_SPADE)
-                || item.equals(Material.GOLD_SPADE)
-                || item.equals(Material.WOOD_PICKAXE)
-                || item.equals(Material.STONE_PICKAXE)
-                || item.equals(Material.IRON_PICKAXE)
-                || item.equals(Material.DIAMOND_PICKAXE)
-                || item.equals(Material.GOLD_PICKAXE)
-                || item.equals(Material.WOOD_HOE)         // NOTE: No vanilla enchantments for this
-                || item.equals(Material.STONE_HOE)        // NOTE: No vanilla enchantments for this
-                || item.equals(Material.IRON_HOE)         // NOTE: No vanilla enchantments for this
-                || item.equals(Material.DIAMOND_HOE)      // NOTE: No vanilla enchantments for this
-                || item.equals(Material.GOLD_HOE)         // NOTE: No vanilla enchantments for this
-                || item.equals(Material.WOOD_AXE)
-                || item.equals(Material.STONE_AXE)
-                || item.equals(Material.IRON_AXE)
-                || item.equals(Material.DIAMOND_AXE)
-                || item.equals(Material.GOLD_AXE)
-                || item.equals(Material.SHEARS)           // NOTE: No vanilla enchantments for this
-                || item.equals(Material.FLINT_AND_STEEL); // NOTE: No vanilla enchantments for this
-        }
-    },
-
-    /**
-     * Allows the Enchantment to be placed on bows.
-     */
-    BOW {
-        @Override
-        public boolean includes(Material item) {
-            return item.equals(Material.BOW);
-        }
-    },
-
-    /**
-     * Allows the Enchantment to be placed on fishing rods.
-     */
-    FISHING_ROD {
-        @Override
-        public boolean includes(Material item) {
-            return item.equals(Material.FISHING_ROD);
-        }
-    },
-
-    /**
-     * Allows the enchantment to be placed on items with durability.
-     */
-    BREAKABLE {
-        @Override
-        public boolean includes(Material item) {
-            return item.getMaxDurability() > 0 && item.getMaxStackSize() == 1;
-        }
-    };
-
-    /**
-     * Check whether this target includes the specified item.
-     *
-     * @param item The item to check
-     * @return True if the target includes the item
-     */
-    public abstract boolean includes(Material item);
-
-    /**
-     * Check whether this target includes the specified item.
-     *
-     * @param item The item to check
-     * @return True if the target includes the item
-     */
-    public boolean includes(ItemStack item) {
-        return includes(item.getType());
-    }
-}
diff --git a/src/main/java/org/bukkit/bukkit/entity/Player.java b/src/main/java/org/bukkit/bukkit/entity/Player.java
deleted file mode 100644
index 73816a0..0000000
--- a/src/main/java/org/bukkit/bukkit/entity/Player.java
+++ /dev/null
@@ -1,1289 +0,0 @@
-package org.bukkit.entity;
-
-import java.net.InetSocketAddress;
-
-import org.bukkit.Achievement;
-import org.bukkit.ChatColor;
-import org.bukkit.Effect;
-import org.bukkit.GameMode;
-import org.bukkit.Instrument;
-import org.bukkit.Location;
-import org.bukkit.Material;
-import org.bukkit.Note;
-import org.bukkit.OfflinePlayer;
-import org.bukkit.Particle;
-import org.bukkit.Sound;
-import org.bukkit.Statistic;
-import org.bukkit.WeatherType;
-import org.bukkit.command.CommandSender;
-import org.bukkit.conversations.Conversable;
-import org.bukkit.map.MapView;
-import org.bukkit.plugin.messaging.PluginMessageRecipient;
-import org.bukkit.scoreboard.Scoreboard;
-
-/**
- * Represents a player, connected or not
- */
-public interface Player extends HumanEntity, Conversable, CommandSender, OfflinePlayer, PluginMessageRecipient {
-
-    /**
-     * Gets the "friendly" name to display of this player. This may include
-     * color.
-     * <p>
-     * Note that this name will not be displayed in game, only in chat and
-     * places defined by plugins.
-     *
-     * @return the friendly name
-     */
-    public String getDisplayName();
-
-    /**
-     * Sets the "friendly" name to display of this player. This may include
-     * color.
-     * <p>
-     * Note that this name will not be displayed in game, only in chat and
-     * places defined by plugins.
-     *
-     * @param name The new display name.
-     */
-    public void setDisplayName(String name);
-
-    /**
-     * Gets the name that is shown on the player list.
-     *
-     * @return the player list name
-     */
-    public String getPlayerListName();
-
-    /**
-     * Sets the name that is shown on the in-game player list.
-     * <p>
-     * The name cannot be longer than 16 characters, but {@link ChatColor} is
-     * supported.
-     * <p>
-     * If the value is null, the name will be identical to {@link #getName()}.
-     * <p>
-     * This name is case sensitive and unique, two names with different casing
-     * will appear as two different people. If a player joins afterwards with
-     * a name that conflicts with a player's custom list name, the joining
-     * player's player list name will have a random number appended to it (1-2
-     * characters long in the default implementation). If the joining player's
-     * name is 15 or 16 characters long, part of the name will be truncated at
-     * the end to allow the addition of the two digits.
-     *
-     * @param name new player list name
-     * @throws IllegalArgumentException if the name is already used by someone
-     *     else
-     * @throws IllegalArgumentException if the length of the name is too long
-     */
-    public void setPlayerListName(String name);
-
-    /**
-     * Set the target of the player's compass.
-     *
-     * @param loc Location to point to
-     */
-    public void setCompassTarget(Location loc);
-
-    /**
-     * Get the previously set compass target.
-     *
-     * @return location of the target
-     */
-    public Location getCompassTarget();
-
-    /**
-     * Gets the socket address of this player
-     *
-     * @return the player's address
-     */
-    public InetSocketAddress getAddress();
-
-    /**
-     * Sends this sender a message raw
-     *
-     * @param message Message to be displayed
-     */
-    public void sendRawMessage(String message);
-
-    /**
-     * Kicks player with custom kick message.
-     *
-     * @param message kick message
-     */
-    public void kickPlayer(String message);
-
-    /**
-     * Says a message (or runs a command).
-     *
-     * @param msg message to print
-     */
-    public void chat(String msg);
-
-    /**
-     * Makes the player perform the given command
-     *
-     * @param command Command to perform
-     * @return true if the command was successful, otherwise false
-     */
-    public boolean performCommand(String command);
-
-    /**
-     * Returns if the player is in sneak mode
-     *
-     * @return true if player is in sneak mode
-     */
-    public boolean isSneaking();
-
-    /**
-     * Sets the sneak mode the player
-     *
-     * @param sneak true if player should appear sneaking
-     */
-    public void setSneaking(boolean sneak);
-
-    /**
-     * Gets whether the player is sprinting or not.
-     *
-     * @return true if player is sprinting.
-     */
-    public boolean isSprinting();
-
-    /**
-     * Sets whether the player is sprinting or not.
-     *
-     * @param sprinting true if the player should be sprinting
-     */
-    public void setSprinting(boolean sprinting);
-
-    /**
-     * Saves the players current location, health, inventory, motion, and
-     * other information into the username.dat file, in the world/player
-     * folder
-     */
-    public void saveData();
-
-    /**
-     * Loads the players current location, health, inventory, motion, and
-     * other information from the username.dat file, in the world/player
-     * folder.
-     * <p>
-     * Note: This will overwrite the players current inventory, health,
-     * motion, etc, with the state from the saved dat file.
-     */
-    public void loadData();
-
-    /**
-     * Sets whether the player is ignored as not sleeping. If everyone is
-     * either sleeping or has this flag set, then time will advance to the
-     * next day. If everyone has this flag set but no one is actually in bed,
-     * then nothing will happen.
-     *
-     * @param isSleeping Whether to ignore.
-     */
-    public void setSleepingIgnored(boolean isSleeping);
-
-    /**
-     * Returns whether the player is sleeping ignored.
-     *
-     * @return Whether player is ignoring sleep.
-     */
-    public boolean isSleepingIgnored();
-
-    /**
-     * Play a note for a player at a location. This requires a note block
-     * at the particular location (as far as the client is concerned). This
-     * will not work without a note block. This will not work with cake.
-     *
-     * @param loc The location of a note block.
-     * @param instrument The instrument ID.
-     * @param note The note ID.
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public void playNote(Location loc, byte instrument, byte note);
-
-    /**
-     * Play a note for a player at a location. This requires a note block
-     * at the particular location (as far as the client is concerned). This
-     * will not work without a note block. This will not work with cake.
-     *
-     * @param loc The location of a note block
-     * @param instrument The instrument
-     * @param note The note
-     */
-    public void playNote(Location loc, Instrument instrument, Note note);
-
-
-    /**
-     * Play a sound for a player at the location.
-     * <p>
-     * This function will fail silently if Location or Sound are null.
-     *
-     * @param location The location to play the sound
-     * @param sound The sound to play
-     * @param volume The volume of the sound
-     * @param pitch The pitch of the sound
-     */
-    public void playSound(Location location, Sound sound, float volume, float pitch);
-
-    /**
-     * Play a sound for a player at the location.
-     * <p>
-     * This function will fail silently if Location or Sound are null. No
-     * sound will be heard by the player if their client does not have the
-     * respective sound for the value passed.
-     *
-     * @param location the location to play the sound
-     * @param sound the internal sound name to play
-     * @param volume the volume of the sound
-     * @param pitch the pitch of the sound
-     */
-    public void playSound(Location location, String sound, float volume, float pitch);
-
-    /**
-     * Stop the specified sound from playing.
-     *
-     * @param sound the sound to stop
-     */
-    public void stopSound(Sound sound);
-
-    /**
-     * Stop the specified sound from playing.
-     *
-     * @param sound the sound to stop
-     */
-    public void stopSound(String sound);
-
-    /**
-     * Plays an effect to just this player.
-     *
-     * @param loc the location to play the effect at
-     * @param effect the {@link Effect}
-     * @param data a data bit needed for some effects
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public void playEffect(Location loc, Effect effect, int data);
-
-    /**
-     * Plays an effect to just this player.
-     *
-     * @param <T> the data based based on the type of the effect
-     * @param loc the location to play the effect at
-     * @param effect the {@link Effect}
-     * @param data a data bit needed for some effects
-     */
-    public <T> void playEffect(Location loc, Effect effect, T data);
-
-    /**
-     * Send a block change. This fakes a block change packet for a user at a
-     * certain location. This will not actually change the world in any way.
-     *
-     * @param loc The location of the changed block
-     * @param material The new block
-     * @param data The block data
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public void sendBlockChange(Location loc, Material material, byte data);
-
-    /**
-     * Send a chunk change. This fakes a chunk change packet for a user at a
-     * certain location. The updated cuboid must be entirely within a single
-     * chunk. This will not actually change the world in any way.
-     * <p>
-     * At least one of the dimensions of the cuboid must be even. The size of
-     * the data buffer must be 2.5*sx*sy*sz and formatted in accordance with
-     * the Packet51 format.
-     *
-     * @param loc The location of the cuboid
-     * @param sx The x size of the cuboid
-     * @param sy The y size of the cuboid
-     * @param sz The z size of the cuboid
-     * @param data The data to be sent
-     * @return true if the chunk change packet was sent
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public boolean sendChunkChange(Location loc, int sx, int sy, int sz, byte[] data);
-
-    /**
-     * Send a block change. This fakes a block change packet for a user at a
-     * certain location. This will not actually change the world in any way.
-     *
-     * @param loc The location of the changed block
-     * @param material The new block ID
-     * @param data The block data
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public void sendBlockChange(Location loc, int material, byte data);
-
-    /**
-     * Send a sign change. This fakes a sign change packet for a user at
-     * a certain location. This will not actually change the world in any way.
-     * This method will use a sign at the location's block or a faked sign
-     * sent via {@link #sendBlockChange(org.bukkit.Location, int, byte)} or
-     * {@link #sendBlockChange(org.bukkit.Location, org.bukkit.Material, byte)}.
-     * <p>
-     * If the client does not have a sign at the given location it will
-     * display an error message to the user.
-     *
-     * @param loc the location of the sign
-     * @param lines the new text on the sign or null to clear it
-     * @throws IllegalArgumentException if location is null
-     * @throws IllegalArgumentException if lines is non-null and has a length less than 4
-     */
-    public void sendSignChange(Location loc, String[] lines) throws IllegalArgumentException;
-
-    /**
-     * Render a map and send it to the player in its entirety. This may be
-     * used when streaming the map in the normal manner is not desirable.
-     *
-     * @param map The map to be sent
-     */
-    public void sendMap(MapView map);
-
-    /**
-     * Forces an update of the player's entire inventory.
-     *
-     * @deprecated This method should not be relied upon as it is a temporary
-     *     work-around for a larger, more complicated issue.
-     */
-    @Deprecated
-    public void updateInventory();
-
-    /**
-     * Awards the given achievement and any parent achievements that the
-     * player does not have.
-     *
-     * @param achievement Achievement to award
-     * @throws IllegalArgumentException if achievement is null
-     */
-    public void awardAchievement(Achievement achievement);
-
-    /**
-     * Removes the given achievement and any children achievements that the
-     * player has.
-     *
-     * @param achievement Achievement to remove
-     * @throws IllegalArgumentException if achievement is null
-     */
-    public void removeAchievement(Achievement achievement);
-
-    /**
-     * Gets whether this player has the given achievement.
-     *
-     * @param achievement the achievement to check
-     * @return whether the player has the achievement
-     * @throws IllegalArgumentException if achievement is null
-     */
-    public boolean hasAchievement(Achievement achievement);
-
-    /**
-     * Increments the given statistic for this player.
-     * <p>
-     * This is equivalent to the following code:
-     * <code>incrementStatistic(Statistic, 1)</code>
-     *
-     * @param statistic Statistic to increment
-     * @throws IllegalArgumentException if statistic is null
-     * @throws IllegalArgumentException if the statistic requires an
-     *     additional parameter
-     */
-    public void incrementStatistic(Statistic statistic) throws IllegalArgumentException;
-
-    /**
-     * Decrements the given statistic for this player.
-     * <p>
-     * This is equivalent to the following code:
-     * <code>decrementStatistic(Statistic, 1)</code>
-     *
-     * @param statistic Statistic to decrement
-     * @throws IllegalArgumentException if statistic is null
-     * @throws IllegalArgumentException if the statistic requires an
-     *     additional parameter
-     */
-    public void decrementStatistic(Statistic statistic) throws IllegalArgumentException;
-
-    /**
-     * Increments the given statistic for this player.
-     *
-     * @param statistic Statistic to increment
-     * @param amount Amount to increment this statistic by
-     * @throws IllegalArgumentException if statistic is null
-     * @throws IllegalArgumentException if amount is negative
-     * @throws IllegalArgumentException if the statistic requires an
-     *     additional parameter
-     */
-    public void incrementStatistic(Statistic statistic, int amount) throws IllegalArgumentException;
-
-    /**
-     * Decrements the given statistic for this player.
-     *
-     * @param statistic Statistic to decrement
-     * @param amount Amount to decrement this statistic by
-     * @throws IllegalArgumentException if statistic is null
-     * @throws IllegalArgumentException if amount is negative
-     * @throws IllegalArgumentException if the statistic requires an
-     *     additional parameter
-     */
-    public void decrementStatistic(Statistic statistic, int amount) throws IllegalArgumentException;
-
-    /**
-     * Sets the given statistic for this player.
-     *
-     * @param statistic Statistic to set
-     * @param newValue The value to set this statistic to
-     * @throws IllegalArgumentException if statistic is null
-     * @throws IllegalArgumentException if newValue is negative
-     * @throws IllegalArgumentException if the statistic requires an
-     *     additional parameter
-     */
-    public void setStatistic(Statistic statistic, int newValue) throws IllegalArgumentException;
-
-    /**
-     * Gets the value of the given statistic for this player.
-     *
-     * @param statistic Statistic to check
-     * @return the value of the given statistic
-     * @throws IllegalArgumentException if statistic is null
-     * @throws IllegalArgumentException if the statistic requires an
-     *     additional parameter
-     */
-    public int getStatistic(Statistic statistic) throws IllegalArgumentException;
-
-    /**
-     * Increments the given statistic for this player for the given material.
-     * <p>
-     * This is equivalent to the following code:
-     * <code>incrementStatistic(Statistic, Material, 1)</code>
-     *
-     * @param statistic Statistic to increment
-     * @param material Material to offset the statistic with
-     * @throws IllegalArgumentException if statistic is null
-     * @throws IllegalArgumentException if material is null
-     * @throws IllegalArgumentException if the given parameter is not valid
-     *     for the statistic
-     */
-    public void incrementStatistic(Statistic statistic, Material material) throws IllegalArgumentException;
-
-    /**
-     * Decrements the given statistic for this player for the given material.
-     * <p>
-     * This is equivalent to the following code:
-     * <code>decrementStatistic(Statistic, Material, 1)</code>
-     *
-     * @param statistic Statistic to decrement
-     * @param material Material to offset the statistic with
-     * @throws IllegalArgumentException if statistic is null
-     * @throws IllegalArgumentException if material is null
-     * @throws IllegalArgumentException if the given parameter is not valid
-     *     for the statistic
-     */
-    public void decrementStatistic(Statistic statistic, Material material) throws IllegalArgumentException;
-
-    /**
-     * Gets the value of the given statistic for this player.
-     *
-     * @param statistic Statistic to check
-     * @param material Material offset of the statistic
-     * @return the value of the given statistic
-     * @throws IllegalArgumentException if statistic is null
-     * @throws IllegalArgumentException if material is null
-     * @throws IllegalArgumentException if the given parameter is not valid
-     *     for the statistic
-     */
-    public int getStatistic(Statistic statistic, Material material) throws IllegalArgumentException;
-
-    /**
-     * Increments the given statistic for this player for the given material.
-     *
-     * @param statistic Statistic to increment
-     * @param material Material to offset the statistic with
-     * @param amount Amount to increment this statistic by
-     * @throws IllegalArgumentException if statistic is null
-     * @throws IllegalArgumentException if material is null
-     * @throws IllegalArgumentException if amount is negative
-     * @throws IllegalArgumentException if the given parameter is not valid
-     *     for the statistic
-     */
-    public void incrementStatistic(Statistic statistic, Material material, int amount) throws IllegalArgumentException;
-
-    /**
-     * Decrements the given statistic for this player for the given material.
-     *
-     * @param statistic Statistic to decrement
-     * @param material Material to offset the statistic with
-     * @param amount Amount to decrement this statistic by
-     * @throws IllegalArgumentException if statistic is null
-     * @throws IllegalArgumentException if material is null
-     * @throws IllegalArgumentException if amount is negative
-     * @throws IllegalArgumentException if the given parameter is not valid
-     *     for the statistic
-     */
-    public void decrementStatistic(Statistic statistic, Material material, int amount) throws IllegalArgumentException;
-
-    /**
-     * Sets the given statistic for this player for the given material.
-     *
-     * @param statistic Statistic to set
-     * @param material Material to offset the statistic with
-     * @param newValue The value to set this statistic to
-     * @throws IllegalArgumentException if statistic is null
-     * @throws IllegalArgumentException if material is null
-     * @throws IllegalArgumentException if newValue is negative
-     * @throws IllegalArgumentException if the given parameter is not valid
-     *     for the statistic
-     */
-    public void setStatistic(Statistic statistic, Material material, int newValue) throws IllegalArgumentException;
-
-    /**
-     * Increments the given statistic for this player for the given entity.
-     * <p>
-     * This is equivalent to the following code:
-     * <code>incrementStatistic(Statistic, EntityType, 1)</code>
-     *
-     * @param statistic Statistic to increment
-     * @param entityType EntityType to offset the statistic with
-     * @throws IllegalArgumentException if statistic is null
-     * @throws IllegalArgumentException if entityType is null
-     * @throws IllegalArgumentException if the given parameter is not valid
-     *     for the statistic
-     */
-    public void incrementStatistic(Statistic statistic, EntityType entityType) throws IllegalArgumentException;
-
-    /**
-     * Decrements the given statistic for this player for the given entity.
-     * <p>
-     * This is equivalent to the following code:
-     * <code>decrementStatistic(Statistic, EntityType, 1)</code>
-     *
-     * @param statistic Statistic to decrement
-     * @param entityType EntityType to offset the statistic with
-     * @throws IllegalArgumentException if statistic is null
-     * @throws IllegalArgumentException if entityType is null
-     * @throws IllegalArgumentException if the given parameter is not valid
-     *     for the statistic
-     */
-    public void decrementStatistic(Statistic statistic, EntityType entityType) throws IllegalArgumentException;
-
-    /**
-     * Gets the value of the given statistic for this player.
-     *
-     * @param statistic Statistic to check
-     * @param entityType EntityType offset of the statistic
-     * @return the value of the given statistic
-     * @throws IllegalArgumentException if statistic is null
-     * @throws IllegalArgumentException if entityType is null
-     * @throws IllegalArgumentException if the given parameter is not valid
-     *     for the statistic
-     */
-    public int getStatistic(Statistic statistic, EntityType entityType) throws IllegalArgumentException;
-
-    /**
-     * Increments the given statistic for this player for the given entity.
-     *
-     * @param statistic Statistic to increment
-     * @param entityType EntityType to offset the statistic with
-     * @param amount Amount to increment this statistic by
-     * @throws IllegalArgumentException if statistic is null
-     * @throws IllegalArgumentException if entityType is null
-     * @throws IllegalArgumentException if amount is negative
-     * @throws IllegalArgumentException if the given parameter is not valid
-     *     for the statistic
-     */
-    public void incrementStatistic(Statistic statistic, EntityType entityType, int amount) throws IllegalArgumentException;
-
-    /**
-     * Decrements the given statistic for this player for the given entity.
-     *
-     * @param statistic Statistic to decrement
-     * @param entityType EntityType to offset the statistic with
-     * @param amount Amount to decrement this statistic by
-     * @throws IllegalArgumentException if statistic is null
-     * @throws IllegalArgumentException if entityType is null
-     * @throws IllegalArgumentException if amount is negative
-     * @throws IllegalArgumentException if the given parameter is not valid
-     *     for the statistic
-     */
-    public void decrementStatistic(Statistic statistic, EntityType entityType, int amount);
-
-    /**
-     * Sets the given statistic for this player for the given entity.
-     *
-     * @param statistic Statistic to set
-     * @param entityType EntityType to offset the statistic with
-     * @param newValue The value to set this statistic to
-     * @throws IllegalArgumentException if statistic is null
-     * @throws IllegalArgumentException if entityType is null
-     * @throws IllegalArgumentException if newValue is negative
-     * @throws IllegalArgumentException if the given parameter is not valid
-     *     for the statistic
-     */
-    public void setStatistic(Statistic statistic, EntityType entityType, int newValue);
-
-    /**
-     * Sets the current time on the player's client. When relative is true the
-     * player's time will be kept synchronized to its world time with the
-     * specified offset.
-     * <p>
-     * When using non relative time the player's time will stay fixed at the
-     * specified time parameter. It's up to the caller to continue updating
-     * the player's time. To restore player time to normal use
-     * resetPlayerTime().
-     *
-     * @param time The current player's perceived time or the player's time
-     *     offset from the server time.
-     * @param relative When true the player time is kept relative to its world
-     *     time.
-     */
-    public void setPlayerTime(long time, boolean relative);
-
-    /**
-     * Returns the player's current timestamp.
-     *
-     * @return The player's time
-     */
-    public long getPlayerTime();
-
-    /**
-     * Returns the player's current time offset relative to server time, or
-     * the current player's fixed time if the player's time is absolute.
-     *
-     * @return The player's time
-     */
-    public long getPlayerTimeOffset();
-
-    /**
-     * Returns true if the player's time is relative to the server time,
-     * otherwise the player's time is absolute and will not change its current
-     * time unless done so with setPlayerTime().
-     *
-     * @return true if the player's time is relative to the server time.
-     */
-    public boolean isPlayerTimeRelative();
-
-    /**
-     * Restores the normal condition where the player's time is synchronized
-     * with the server time.
-     * <p>
-     * Equivalent to calling setPlayerTime(0, true).
-     */
-    public void resetPlayerTime();
-
-    /**
-     * Sets the type of weather the player will see.  When used, the weather
-     * status of the player is locked until {@link #resetPlayerWeather()} is
-     * used.
-     *
-     * @param type The WeatherType enum type the player should experience
-     */
-    public void setPlayerWeather(WeatherType type);
-
-    /**
-     * Returns the type of weather the player is currently experiencing.
-     *
-     * @return The WeatherType that the player is currently experiencing or
-     *     null if player is seeing server weather.
-     */
-    public WeatherType getPlayerWeather();
-
-    /**
-     * Restores the normal condition where the player's weather is controlled
-     * by server conditions.
-     */
-    public void resetPlayerWeather();
-
-    /**
-     * Gives the player the amount of experience specified.
-     *
-     * @param amount Exp amount to give
-     */
-    public void giveExp(int amount);
-
-    /**
-     * Gives the player the amount of experience levels specified. Levels can
-     * be taken by specifying a negative amount.
-     *
-     * @param amount amount of experience levels to give or take
-     */
-    public void giveExpLevels(int amount);
-
-    /**
-     * Gets the players current experience points towards the next level.
-     * <p>
-     * This is a percentage value. 0 is "no progress" and 1 is "next level".
-     *
-     * @return Current experience points
-     */
-    public float getExp();
-
-    /**
-     * Sets the players current experience points towards the next level
-     * <p>
-     * This is a percentage value. 0 is "no progress" and 1 is "next level".
-     *
-     * @param exp New experience points
-     */
-    public void setExp(float exp);
-
-    /**
-     * Gets the players current experience level
-     *
-     * @return Current experience level
-     */
-    public int getLevel();
-
-    /**
-     * Sets the players current experience level
-     *
-     * @param level New experience level
-     */
-    public void setLevel(int level);
-
-    /**
-     * Gets the players total experience points
-     *
-     * @return Current total experience points
-     */
-    public int getTotalExperience();
-
-    /**
-     * Sets the players current experience level
-     *
-     * @param exp New experience level
-     */
-    public void setTotalExperience(int exp);
-
-    /**
-     * Gets the players current exhaustion level.
-     * <p>
-     * Exhaustion controls how fast the food level drops. While you have a
-     * certain amount of exhaustion, your saturation will drop to zero, and
-     * then your food will drop to zero.
-     *
-     * @return Exhaustion level
-     */
-    public float getExhaustion();
-
-    /**
-     * Sets the players current exhaustion level
-     *
-     * @param value Exhaustion level
-     */
-    public void setExhaustion(float value);
-
-    /**
-     * Gets the players current saturation level.
-     * <p>
-     * Saturation is a buffer for food level. Your food level will not drop if
-     * you are saturated {@literal >} 0.
-     *
-     * @return Saturation level
-     */
-    public float getSaturation();
-
-    /**
-     * Sets the players current saturation level
-     *
-     * @param value Saturation level
-     */
-    public void setSaturation(float value);
-
-    /**
-     * Gets the players current food level
-     *
-     * @return Food level
-     */
-    public int getFoodLevel();
-
-    /**
-     * Sets the players current food level
-     *
-     * @param value New food level
-     */
-    public void setFoodLevel(int value);
-
-    /**
-     * Gets the Location where the player will spawn at their bed, null if
-     * they have not slept in one or their current bed spawn is invalid.
-     *
-     * @return Bed Spawn Location if bed exists, otherwise null.
-     */
-    public Location getBedSpawnLocation();
-
-    /**
-     * Sets the Location where the player will spawn at their bed.
-     *
-     * @param location where to set the respawn location
-     */
-    public void setBedSpawnLocation(Location location);
-
-    /**
-     * Sets the Location where the player will spawn at their bed.
-     *
-     * @param location where to set the respawn location
-     * @param force whether to forcefully set the respawn location even if a
-     *     valid bed is not present
-     */
-    public void setBedSpawnLocation(Location location, boolean force);
-
-    /**
-     * Determines if the Player is allowed to fly via jump key double-tap like
-     * in creative mode.
-     *
-     * @return True if the player is allowed to fly.
-     */
-    public boolean getAllowFlight();
-
-    /**
-     * Sets if the Player is allowed to fly via jump key double-tap like in
-     * creative mode.
-     *
-     * @param flight If flight should be allowed.
-     */
-    public void setAllowFlight(boolean flight);
-
-    /**
-     * Hides a player from this player
-     *
-     * @param player Player to hide
-     */
-    public void hidePlayer(Player player);
-
-    /**
-     * Allows this player to see a player that was previously hidden
-     *
-     * @param player Player to show
-     */
-    public void showPlayer(Player player);
-
-    /**
-     * Checks to see if a player has been hidden from this player
-     *
-     * @param player Player to check
-     * @return True if the provided player is not being hidden from this
-     *     player
-     */
-    public boolean canSee(Player player);
-
-    /**
-     * Checks to see if this player is currently standing on a block. This
-     * information may not be reliable, as it is a state provided by the
-     * client, and may therefore not be accurate.
-     *
-     * @return True if the player standing on a solid block, else false.
-     * @deprecated Inconsistent with {@link
-     *     org.bukkit.entity.Entity#isOnGround()}
-     */
-    @Deprecated
-    public boolean isOnGround();
-
-    /**
-     * Checks to see if this player is currently flying or not.
-     *
-     * @return True if the player is flying, else false.
-     */
-    public boolean isFlying();
-
-    /**
-     * Makes this player start or stop flying.
-     *
-     * @param value True to fly.
-     */
-    public void setFlying(boolean value);
-
-    /**
-     * Sets the speed at which a client will fly. Negative values indicate
-     * reverse directions.
-     *
-     * @param value The new speed, from -1 to 1.
-     * @throws IllegalArgumentException If new speed is less than -1 or
-     *     greater than 1
-     */
-    public void setFlySpeed(float value) throws IllegalArgumentException;
-
-    /**
-     * Sets the speed at which a client will walk. Negative values indicate
-     * reverse directions.
-     *
-     * @param value The new speed, from -1 to 1.
-     * @throws IllegalArgumentException If new speed is less than -1 or
-     *     greater than 1
-     */
-    public void setWalkSpeed(float value) throws IllegalArgumentException;
-
-    /**
-     * Gets the current allowed speed that a client can fly.
-     *
-     * @return The current allowed speed, from -1 to 1
-     */
-    public float getFlySpeed();
-
-    /**
-     * Gets the current allowed speed that a client can walk.
-     *
-     * @return The current allowed speed, from -1 to 1
-     */
-    public float getWalkSpeed();
-
-    /**
-     * Request that the player's client download and switch texture packs.
-     * <p>
-     * The player's client will download the new texture pack asynchronously
-     * in the background, and will automatically switch to it once the
-     * download is complete. If the client has downloaded and cached the same
-     * texture pack in the past, it will perform a quick timestamp check over
-     * the network to determine if the texture pack has changed and needs to
-     * be downloaded again. When this request is sent for the very first time
-     * from a given server, the client will first display a confirmation GUI
-     * to the player before proceeding with the download.
-     * <p>
-     * Notes:
-     * <ul>
-     * <li>Players can disable server textures on their client, in which
-     *     case this method will have no affect on them.
-     * <li>There is no concept of resetting texture packs back to default
-     *     within Minecraft, so players will have to relog to do so.
-     * </ul>
-     *
-     * @param url The URL from which the client will download the texture
-     *     pack. The string must contain only US-ASCII characters and should
-     *     be encoded as per RFC 1738.
-     * @throws IllegalArgumentException Thrown if the URL is null.
-     * @throws IllegalArgumentException Thrown if the URL is too long.
-     * @deprecated Minecraft no longer uses textures packs. Instead you
-     *     should use {@link #setResourcePack(String)}.
-     */
-    @Deprecated
-    public void setTexturePack(String url);
-
-    /**
-     * Request that the player's client download and switch resource packs.
-     * <p>
-     * The player's client will download the new resource pack asynchronously
-     * in the background, and will automatically switch to it once the
-     * download is complete. If the client has downloaded and cached the same
-     * resource pack in the past, it will perform a quick timestamp check
-     * over the network to determine if the resource pack has changed and
-     * needs to be downloaded again. When this request is sent for the very
-     * first time from a given server, the client will first display a
-     * confirmation GUI to the player before proceeding with the download.
-     * <p>
-     * Notes:
-     * <ul>
-     * <li>Players can disable server resources on their client, in which
-     *     case this method will have no affect on them.
-     * <li>There is no concept of resetting resource packs back to default
-     *     within Minecraft, so players will have to relog to do so.
-     * </ul>
-     *
-     * @param url The URL from which the client will download the resource
-     *     pack. The string must contain only US-ASCII characters and should
-     *     be encoded as per RFC 1738.
-     * @throws IllegalArgumentException Thrown if the URL is null.
-     * @throws IllegalArgumentException Thrown if the URL is too long. The
-     *     length restriction is an implementation specific arbitrary value.
-     */
-    public void setResourcePack(String url);
-
-    /**
-     * Gets the Scoreboard displayed to this player
-     *
-     * @return The current scoreboard seen by this player
-     */
-    public Scoreboard getScoreboard();
-
-    /**
-     * Sets the player's visible Scoreboard.
-     *
-     * @param scoreboard New Scoreboard for the player
-     * @throws IllegalArgumentException if scoreboard is null
-     * @throws IllegalArgumentException if scoreboard was not created by the
-     *     {@link org.bukkit.scoreboard.ScoreboardManager scoreboard manager}
-     * @throws IllegalStateException if this is a player that is not logged
-     *     yet or has logged out
-     */
-    public void setScoreboard(Scoreboard scoreboard) throws IllegalArgumentException, IllegalStateException;
-
-    /**
-     * Gets if the client is displayed a 'scaled' health, that is, health on a
-     * scale from 0-{@link #getHealthScale()}.
-     *
-     * @return if client health display is scaled
-     * @see Player#setHealthScaled(boolean)
-     */
-    public boolean isHealthScaled();
-
-    /**
-     * Sets if the client is displayed a 'scaled' health, that is, health on a
-     * scale from 0-{@link #getHealthScale()}.
-     * <p>
-     * Displayed health follows a simple formula <code>displayedHealth =
-     * getHealth() / getMaxHealth() * getHealthScale()</code>.
-     *
-     * @param scale if the client health display is scaled
-     */
-    public void setHealthScaled(boolean scale);
-
-    /**
-     * Sets the number to scale health to for the client; this will also
-     * {@link #setHealthScaled(boolean) setHealthScaled(true)}.
-     * <p>
-     * Displayed health follows a simple formula <code>displayedHealth =
-     * getHealth() / getMaxHealth() * getHealthScale()</code>.
-     *
-     * @param scale the number to scale health to
-     * @throws IllegalArgumentException if scale is &lt;0
-     * @throws IllegalArgumentException if scale is {@link Double#NaN}
-     * @throws IllegalArgumentException if scale is too high
-     */
-    public void setHealthScale(double scale) throws IllegalArgumentException;
-
-    /**
-     * Gets the number that health is scaled to for the client.
-     *
-     * @return the number that health would be scaled to for the client if
-     *     HealthScaling is set to true
-     * @see Player#setHealthScale(double)
-     * @see Player#setHealthScaled(boolean)
-     */
-    public double getHealthScale();
-
-    /**
-     * Gets the entity which is followed by the camera when in
-     * {@link GameMode#SPECTATOR}.
-     *
-     * @return the followed entity, or null if not in spectator mode or not
-     * following a specific entity.
-     */
-    public Entity getSpectatorTarget();
-
-    /**
-     * Sets the entity which is followed by the camera when in
-     * {@link GameMode#SPECTATOR}.
-     *
-     * @param entity the entity to follow or null to reset
-     * @throws IllegalStateException if the player is not in
-     * {@link GameMode#SPECTATOR}
-     */
-    public void setSpectatorTarget(Entity entity);
-
-    /**
-     * Sends a title and a subtitle message to the player. If either of these
-     * values are null, they will not be sent and the display will remain
-     * unchanged. If they are empty strings, the display will be updated as
-     * such. If the strings contain a new line, only the first line will be
-     * sent.
-     *
-     * @param title Title text
-     * @param subtitle Subtitle text
-     * @deprecated API subject to change
-     */
-    @Deprecated
-    public void sendTitle(String title, String subtitle);
-
-    /**
-     * Resets the title displayed to the player.
-     * @deprecated API subject to change.
-     */
-    @Deprecated
-    public void resetTitle();
-
-
-    /**
-     * Spawns the particle (the number of times specified by count)
-     * at the target location.
-     *
-     * @param particle the particle to spawn
-     * @param location the location to spawn at
-     * @param count the number of particles
-     */
-    public void spawnParticle(Particle particle, Location location, int count);
-
-    /**
-     * Spawns the particle (the number of times specified by count)
-     * at the target location.
-     *
-     * @param particle the particle to spawn
-     * @param x the position on the x axis to spawn at
-     * @param y the position on the y axis to spawn at
-     * @param z the position on the z axis to spawn at
-     * @param count the number of particles
-     */
-    public void spawnParticle(Particle particle, double x, double y, double z, int count);
-
-    /**
-     * Spawns the particle (the number of times specified by count)
-     * at the target location.
-     *
-     * @param particle the particle to spawn
-     * @param location the location to spawn at
-     * @param count the number of particles
-     * @param data the data to use for the particle or null,
-     *             the type of this depends on {@link Particle#getDataType()}
-     */
-    public <T> void spawnParticle(Particle particle, Location location, int count, T data);
-
-
-    /**
-     * Spawns the particle (the number of times specified by count)
-     * at the target location.
-     *
-     * @param particle the particle to spawn
-     * @param x the position on the x axis to spawn at
-     * @param y the position on the y axis to spawn at
-     * @param z the position on the z axis to spawn at
-     * @param count the number of particles
-     * @param data the data to use for the particle or null,
-     *             the type of this depends on {@link Particle#getDataType()}
-     */
-    public <T> void spawnParticle(Particle particle, double x, double y, double z, int count, T data);
-
-    /**
-     * Spawns the particle (the number of times specified by count)
-     * at the target location. The position of each particle will be
-     * randomized positively and negatively by the offset parameters
-     * on each axis.
-     *
-     * @param particle the particle to spawn
-     * @param location the location to spawn at
-     * @param count the number of particles
-     * @param offsetX the maximum random offset on the X axis
-     * @param offsetY the maximum random offset on the Y axis
-     * @param offsetZ the maximum random offset on the Z axis
-     */
-    public void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ);
-
-    /**
-     * Spawns the particle (the number of times specified by count)
-     * at the target location. The position of each particle will be
-     * randomized positively and negatively by the offset parameters
-     * on each axis.
-     *
-     * @param particle the particle to spawn
-     * @param x the position on the x axis to spawn at
-     * @param y the position on the y axis to spawn at
-     * @param z the position on the z axis to spawn at
-     * @param count the number of particles
-     * @param offsetX the maximum random offset on the X axis
-     * @param offsetY the maximum random offset on the Y axis
-     * @param offsetZ the maximum random offset on the Z axis
-     */
-    public void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ);
-
-    /**
-     * Spawns the particle (the number of times specified by count)
-     * at the target location. The position of each particle will be
-     * randomized positively and negatively by the offset parameters
-     * on each axis.
-     *
-     * @param particle the particle to spawn
-     * @param location the location to spawn at
-     * @param count the number of particles
-     * @param offsetX the maximum random offset on the X axis
-     * @param offsetY the maximum random offset on the Y axis
-     * @param offsetZ the maximum random offset on the Z axis
-     * @param data the data to use for the particle or null,
-     *             the type of this depends on {@link Particle#getDataType()}
-     */
-    public <T> void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ, T data);
-
-    /**
-     * Spawns the particle (the number of times specified by count)
-     * at the target location. The position of each particle will be
-     * randomized positively and negatively by the offset parameters
-     * on each axis.
-     *
-     * @param particle the particle to spawn
-     * @param x the position on the x axis to spawn at
-     * @param y the position on the y axis to spawn at
-     * @param z the position on the z axis to spawn at
-     * @param count the number of particles
-     * @param offsetX the maximum random offset on the X axis
-     * @param offsetY the maximum random offset on the Y axis
-     * @param offsetZ the maximum random offset on the Z axis
-     * @param data the data to use for the particle or null,
-     *             the type of this depends on {@link Particle#getDataType()}
-     */
-    public <T> void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ, T data);
-
-    /**
-     * Spawns the particle (the number of times specified by count)
-     * at the target location. The position of each particle will be
-     * randomized positively and negatively by the offset parameters
-     * on each axis.
-     *
-     * @param particle the particle to spawn
-     * @param location the location to spawn at
-     * @param count the number of particles
-     * @param offsetX the maximum random offset on the X axis
-     * @param offsetY the maximum random offset on the Y axis
-     * @param offsetZ the maximum random offset on the Z axis
-     * @param extra the extra data for this particle, depends on the
-     *              particle used (normally speed)
-     */
-    public void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ, double extra);
-
-    /**
-     * Spawns the particle (the number of times specified by count)
-     * at the target location. The position of each particle will be
-     * randomized positively and negatively by the offset parameters
-     * on each axis.
-     *
-     * @param particle the particle to spawn
-     * @param x the position on the x axis to spawn at
-     * @param y the position on the y axis to spawn at
-     * @param z the position on the z axis to spawn at
-     * @param count the number of particles
-     * @param offsetX the maximum random offset on the X axis
-     * @param offsetY the maximum random offset on the Y axis
-     * @param offsetZ the maximum random offset on the Z axis
-     * @param extra the extra data for this particle, depends on the
-     *              particle used (normally speed)
-     */
-    public void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ, double extra);
-
-    /**
-     * Spawns the particle (the number of times specified by count)
-     * at the target location. The position of each particle will be
-     * randomized positively and negatively by the offset parameters
-     * on each axis.
-     *
-     * @param particle the particle to spawn
-     * @param location the location to spawn at
-     * @param count the number of particles
-     * @param offsetX the maximum random offset on the X axis
-     * @param offsetY the maximum random offset on the Y axis
-     * @param offsetZ the maximum random offset on the Z axis
-     * @param extra the extra data for this particle, depends on the
-     *              particle used (normally speed)
-     * @param data the data to use for the particle or null,
-     *             the type of this depends on {@link Particle#getDataType()}
-     */
-    public <T> void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ, double extra, T data);
-
-    /**
-     * Spawns the particle (the number of times specified by count)
-     * at the target location. The position of each particle will be
-     * randomized positively and negatively by the offset parameters
-     * on each axis.
-     *
-     * @param particle the particle to spawn
-     * @param x the position on the x axis to spawn at
-     * @param y the position on the y axis to spawn at
-     * @param z the position on the z axis to spawn at
-     * @param count the number of particles
-     * @param offsetX the maximum random offset on the X axis
-     * @param offsetY the maximum random offset on the Y axis
-     * @param offsetZ the maximum random offset on the Z axis
-     * @param extra the extra data for this particle, depends on the
-     *              particle used (normally speed)
-     * @param data the data to use for the particle or null,
-     *             the type of this depends on {@link Particle#getDataType()}
-     */
-    public <T> void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ, double extra, T data);
-
-}
diff --git a/src/main/java/org/bukkit/bukkit/entity/Villager.java b/src/main/java/org/bukkit/bukkit/entity/Villager.java
deleted file mode 100644
index 2be0cb0..0000000
--- a/src/main/java/org/bukkit/bukkit/entity/Villager.java
+++ /dev/null
@@ -1,174 +0,0 @@
-package org.bukkit.entity;
-
-import java.util.List;
-import org.bukkit.inventory.Inventory;
-import org.bukkit.inventory.InventoryHolder;
-import org.bukkit.inventory.MerchantRecipe;
-
-/**
- * Represents a villager NPC
- */
-public interface Villager extends Ageable, NPC, InventoryHolder {
-
-    /**
-     * Gets the current profession of this villager.
-     *
-     * @return Current profession.
-     */
-    public Profession getProfession();
-
-    /**
-     * Sets the new profession of this villager.
-     *
-     * @param profession New profession.
-     */
-    public void setProfession(Profession profession);
-
-    /**
-     * Get a list of trades currently available from this villager.
-     *
-     * @return an immutable list of trades
-     */
-    List<MerchantRecipe> getRecipes();
-
-    /**
-     * Set the list of trades currently available from this villager.
-     * <br>
-     * This will not change the selected trades of players currently trading
-     * with this villager.
-     *
-     * @param recipes a list of recipes
-     */
-    void setRecipes(List<MerchantRecipe> recipes);
-
-    /**
-     * Get the recipe at a certain index of this villager's trade list.
-     *
-     * @param i the index
-     * @return the recipe
-     * @throws IndexOutOfBoundsException
-     */
-    MerchantRecipe getRecipe(int i) throws IndexOutOfBoundsException;
-
-    /**
-     * Set the recipe at a certain index of this villager's trade list.
-     *
-     * @param i the index
-     * @param recipe the recipe
-     * @throws IndexOutOfBoundsException
-     */
-    void setRecipe(int i, MerchantRecipe recipe) throws IndexOutOfBoundsException;
-
-    /**
-     * Get the number of trades this villager currently has available.
-     *
-     * @return the recipe count
-     */
-    int getRecipeCount();
-
-    /**
-     * Gets this villager's inventory.
-     * <br>
-     * Note that this inventory is not the Merchant inventory, rather, it is the
-     * items that a villager might have collected (from harvesting crops, etc.)
-     *
-     * {@inheritDoc}
-     */
-    @Override
-    Inventory getInventory();
-
-    /**
-     * Gets whether this villager is currently trading.
-     *
-     * @return whether the villager is trading
-     */
-    boolean isTrading();
-
-    /**
-     * Gets the player this villager is trading with, or null if it is not
-     * currently trading.
-     *
-     * @return the trader, or null
-     */
-    HumanEntity getTrader();
-
-    /**
-     * Gets this villager's riches, the number of emeralds this villager has
-     * been given.
-     *
-     * @return the villager's riches
-     */
-    int getRiches();
-
-    /**
-     * Sets this villager's riches.
-     *
-     * @see Villager#getRiches()
-     *
-     * @param riches the new riches
-     */
-    void setRiches(int riches);
-
-    /**
-     * Represents the various different Villager professions there may be.
-     */
-    public enum Profession {
-        FARMER(0),
-        LIBRARIAN(1),
-        PRIEST(2),
-        BLACKSMITH(3),
-        BUTCHER(4),
-		HUSK(5);
-		
-		private final boolean zombie;
-
-        private Profession(boolean zombie) {
-            this.zombie = zombie;
-        }
-
-        /**
-         * Returns if this profession can only be used by zombies.
-         *
-         * @return zombie profession status
-         */
-        public boolean isZombie() {
-            return zombie;
-        }
-
-        private static final Profession[] professions = new Profession[Profession.values().length];
-        private final int id;
-
-        static {
-            for (Profession type : values()) {
-                professions[type.getId()] = type;
-            }
-        }
-
-        private Profession(int id) {
-            this.id = id;
-        }
-
-        /**
-         * Gets the ID of this profession.
-         *
-         * @return Profession ID.
-         * @deprecated Magic value
-         */
-        @Deprecated
-        public int getId() {
-            return id;
-        }
-
-        /**
-         * Gets a profession by its ID.
-         *
-         * @param id ID of the profession to get.
-         * @return Resulting profession, or null if not found.
-         * @deprecated Magic value
-         */
-        @Deprecated
-        public static Profession getProfession(int id) {
-            return (id >= professions.length) ? null : professions[id];
-        }
-    }
-}
diff --git a/src/main/java/org/bukkit/bukkit/event/entity/CreatureSpawnEvent.java b/src/main/java/org/bukkit/bukkit/event/entity/CreatureSpawnEvent.java
deleted file mode 100644
index 54dd901..0000000
--- a/src/main/java/org/bukkit/bukkit/event/entity/CreatureSpawnEvent.java
+++ /dev/null
@@ -1,184 +0,0 @@
-package org.bukkit.event.entity;
-
-import org.bukkit.Location;
-import org.bukkit.entity.Entity;
-import org.bukkit.entity.LivingEntity;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a creature is spawned into a world.
- * <p>
- * If a Creature Spawn event is cancelled, the creature will not spawn.
- */
-public class CreatureSpawnEvent extends EntityEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private boolean canceled;
-    private final SpawnReason spawnReason;
-
-    public CreatureSpawnEvent(final LivingEntity spawnee, final SpawnReason spawnReason) {
-        super(spawnee);
-        this.spawnReason = spawnReason;
-    }
-
-    public boolean isCancelled() {
-        return canceled;
-    }
-
-    public void setCancelled(boolean cancel) {
-        canceled = cancel;
-    }
-
-    @Override
-    public LivingEntity getEntity() {
-        return (LivingEntity) entity;
-    }
-
-    /**
-     * Gets the location at which the creature is spawning.
-     *
-     * @return The location at which the creature is spawning
-     */
-    public Location getLocation() {
-        return getEntity().getLocation();
-    }
-
-    /**
-     * Gets the reason for why the creature is being spawned.
-     *
-     * @return A SpawnReason value detailing the reason for the creature being
-     *     spawned
-     */
-    public SpawnReason getSpawnReason() {
-        return spawnReason;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-
-    /**
-     * An enum to specify the type of spawning
-     */
-    public enum SpawnReason {
-
-        /**
-         * When something spawns from natural means
-         */
-        NATURAL,
-        /**
-         * When an entity spawns as a jockey of another entity (mostly spider
-         * jockeys)
-         */
-        JOCKEY,
-        /**
-         * When a creature spawns due to chunk generation
-         */
-        CHUNK_GEN,
-        /**
-         * When a creature spawns from a spawner
-         */
-        SPAWNER,
-        /**
-         * When a creature spawns from an egg
-         */
-        EGG,
-        /**
-         * When a creature spawns from a Spawner Egg
-         */
-        SPAWNER_EGG,
-        /**
-         * When a creature spawns because of a lightning strike
-         */
-        LIGHTNING,
-        /**
-         * When a creature is spawned by a player that is sleeping
-         *
-         * @deprecated No longer used
-         */
-        @Deprecated
-        BED,
-        /**
-         * When a snowman is spawned by being built
-         */
-        BUILD_SNOWMAN,
-        /**
-         * When an iron golem is spawned by being built
-         */
-        BUILD_IRONGOLEM,
-        /**
-         * When a wither boss is spawned by being built
-         */
-        BUILD_WITHER,
-        /**
-         * When an iron golem is spawned to defend a village
-         */
-        VILLAGE_DEFENSE,
-        /**
-         * When a zombie is spawned to invade a village
-         */
-        VILLAGE_INVASION,
-        /**
-         * When an animal breeds to create a child
-         */
-        BREEDING,
-        /**
-         * When a slime splits
-         */
-        SLIME_SPLIT,
-        /**
-         * When an entity calls for reinforcements
-         */
-        REINFORCEMENTS,
-        /**
-         * When a creature is spawned by nether portal
-         */
-        NETHER_PORTAL,
-        /**
-         * When a creature is spawned by a dispenser dispensing an egg
-         */
-        DISPENSE_EGG,
-        /**
-         * When a zombie infects a villager
-         */
-        INFECTION,
-        /**
-         * When a villager is cured from infection
-         */
-        CURED,
-        /**
-         * When an ocelot has a baby spawned along with them
-         */
-        OCELOT_BABY,
-        /**
-         * When a silverfish spawns from a block
-         */
-        SILVERFISH_BLOCK,
-        /**
-         * When an entity spawns as a mount of another entity (mostly chicken
-         * jockeys)
-         */
-        MOUNT,
-        /**
-         * When an entity spawns as a trap for players approaching
-         */
-        TRAP,
-		/**
-         * When an entity is spawned as a result of ender pearl usage
-         */
-        ENDER_PEARL,
-        /**
-         * When a creature is spawned by plugins
-         */
-        CUSTOM,
-        /**
-         * When an entity is missing a SpawnReason
-         */
-        DEFAULT
-    }
-}
diff --git a/src/main/java/org/bukkit/bukkit/event/entity/EntityBreedEvent.java b/src/main/java/org/bukkit/bukkit/event/entity/EntityBreedEvent.java
deleted file mode 100644
index ce0973b..0000000
--- a/src/main/java/org/bukkit/bukkit/event/entity/EntityBreedEvent.java
+++ /dev/null
@@ -1,119 +0,0 @@
-package org.bukkit.event.entity;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.entity.LivingEntity;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-import org.bukkit.inventory.ItemStack;
-
-/**
- * Called when one Entity breeds with another Entity.
- */
-public class EntityBreedEvent extends EntityEvent implements Cancellable {
-
-    private static final HandlerList handlers = new HandlerList();
-    //
-    private final LivingEntity mother;
-    private final LivingEntity father;
-    private final LivingEntity breeder;
-    private final ItemStack bredWith;
-    private int experience;
-    //
-    private boolean cancel;
-
-    public EntityBreedEvent(LivingEntity child, LivingEntity mother, LivingEntity father, LivingEntity breeder, ItemStack bredWith, int experience) {
-        super(child);
-
-        Validate.notNull(child, "Cannot have null child");
-        Validate.notNull(mother, "Cannot have null mother");
-        Validate.notNull(father, "Cannot have null father");
-
-        // Breeder can be null in the case of spontaneous conception
-        this.mother = mother;
-        this.father = father;
-        this.breeder = breeder;
-        this.bredWith = bredWith;
-
-        setExperience(experience);
-    }
-
-    @Override
-    public LivingEntity getEntity() {
-        return (LivingEntity) entity;
-    }
-
-    /**
-     * Gets the parent creating this entity.
-     *
-     * @return The "birth" parent
-     */
-    public LivingEntity getMother() {
-        return mother;
-    }
-
-    /**
-     * Gets the other parent of the newly born entity.
-     *
-     * @return the other parent
-     */
-    public LivingEntity getFather() {
-        return father;
-    }
-
-    /**
-     * Gets the Entity responsible for breeding. Breeder is null for spontaneous
-     * conception.
-     *
-     * @return The Entity who initiated breeding.
-     */
-    public LivingEntity getBreeder() {
-        return breeder;
-    }
-
-    /**
-     * The ItemStack that was used to initiate breeding, if present.
-     *
-     * @return ItemStack used to initiate breeding.
-     */
-    public ItemStack getBredWith() {
-        return bredWith;
-    }
-
-    /**
-     * Get the amount of experience granted by breeding.
-     *
-     * @return experience amount
-     */
-    public int getExperience() {
-        return experience;
-    }
-
-    /**
-     * Set the amount of experience granted by breeding.
-     *
-     * @param experience experience amount
-     */
-    public void setExperience(int experience) {
-        Validate.isTrue(experience >= 0, "Experience cannot be negative");
-        this.experience = experience;
-    }
-
-    @Override
-    public boolean isCancelled() {
-        return cancel;
-    }
-
-    @Override
-    public void setCancelled(boolean cancel) {
-        this.cancel = cancel;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
\ No newline at end of file
diff --git a/src/main/java/org/bukkit/bukkit/event/entity/EntityDamageEvent.java b/src/main/java/org/bukkit/bukkit/event/entity/EntityDamageEvent.java
deleted file mode 100644
index 09ce0ae..0000000
--- a/src/main/java/org/bukkit/bukkit/event/entity/EntityDamageEvent.java
+++ /dev/null
@@ -1,436 +0,0 @@
-package org.bukkit.event.entity;
-
-import java.util.EnumMap;
-import java.util.Map;
-import org.bukkit.Material;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.entity.Entity;
-import org.bukkit.entity.Player;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-import org.bukkit.util.NumberConversions;
-
-import com.google.common.base.Function;
-import com.google.common.base.Functions;
-import com.google.common.collect.ImmutableMap;
-
-/**
- * Stores data for damage events
- */
-public class EntityDamageEvent extends EntityEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private static final DamageModifier[] MODIFIERS = DamageModifier.values();
-    private static final Function<? super Double, Double> ZERO = Functions.constant(-0.0);
-    private final Map<DamageModifier, Double> modifiers;
-    private final Map<DamageModifier, ? extends Function<? super Double, Double>> modifierFunctions;
-    private final Map<DamageModifier, Double> originals;
-    private boolean cancelled;
-    private final DamageCause cause;
-
-    @Deprecated
-    public EntityDamageEvent(final Entity damagee, final DamageCause cause, final int damage) {
-        this(damagee, cause, (double) damage);
-    }
-
-    @Deprecated
-    public EntityDamageEvent(final Entity damagee, final DamageCause cause, final double damage) {
-        this(damagee, cause, new EnumMap<DamageModifier, Double>(ImmutableMap.of(DamageModifier.BASE, damage)), new EnumMap<DamageModifier, Function<? super Double, Double>>(ImmutableMap.of(DamageModifier.BASE, ZERO)));
-    }
-
-    public EntityDamageEvent(final Entity damagee, final DamageCause cause, final Map<DamageModifier, Double> modifiers, final Map<DamageModifier, ? extends Function<? super Double, Double>> modifierFunctions) {
-        super(damagee);
-        Validate.isTrue(modifiers.containsKey(DamageModifier.BASE), "BASE DamageModifier missing");
-        Validate.isTrue(!modifiers.containsKey(null), "Cannot have null DamageModifier");
-        Validate.noNullElements(modifiers.values(), "Cannot have null modifier values");
-        Validate.isTrue(modifiers.keySet().equals(modifierFunctions.keySet()), "Must have a modifier function for each DamageModifier");
-        Validate.noNullElements(modifierFunctions.values(), "Cannot have null modifier function");
-        this.originals = new EnumMap<DamageModifier, Double>(modifiers);
-        this.cause = cause;
-        this.modifiers = modifiers;
-        this.modifierFunctions = modifierFunctions;
-    }
-
-    public boolean isCancelled() {
-        return cancelled;
-    }
-
-    public void setCancelled(boolean cancel) {
-        cancelled = cancel;
-    }
-
-    /**
-     * Gets the original damage for the specified modifier, as defined at this
-     * event's construction.
-     *
-     * @param type the modifier
-     * @return the original damage
-     * @throws IllegalArgumentException if type is null
-     */
-    public double getOriginalDamage(DamageModifier type) throws IllegalArgumentException {
-        final Double damage = originals.get(type);
-        if (damage != null) {
-            return damage;
-        }
-        if (type == null) {
-            throw new IllegalArgumentException("Cannot have null DamageModifier");
-        }
-        return 0;
-    }
-
-    /**
-     * Sets the damage for the specified modifier.
-     *
-     * @param type the damage modifier
-     * @param damage the scalar value of the damage's modifier
-     * @see #getFinalDamage()
-     * @throws IllegalArgumentException if type is null
-     * @throws UnsupportedOperationException if the caller does not support
-     *     the particular DamageModifier, or to rephrase, when {@link
-     *     #isApplicable(DamageModifier)} returns false
-     */
-    public void setDamage(DamageModifier type, double damage) throws IllegalArgumentException, UnsupportedOperationException {
-        if (!modifiers.containsKey(type)) {
-            throw type == null ? new IllegalArgumentException("Cannot have null DamageModifier") : new UnsupportedOperationException(type + " is not applicable to " + getEntity());
-        }
-        modifiers.put(type, damage);
-    }
-
-    /**
-     * Gets the damage change for some modifier
-     *
-     * @param type the damage modifier
-     * @return The raw amount of damage caused by the event
-     * @throws IllegalArgumentException if type is null
-     * @see DamageModifier#BASE
-     */
-    public double getDamage(DamageModifier type) throws IllegalArgumentException {
-        Validate.notNull(type, "Cannot have null DamageModifier");
-        final Double damage = modifiers.get(type);
-        return damage == null ? 0 : damage;
-    }
-
-    /**
-     * This checks to see if a particular modifier is valid for this event's
-     * caller, such that, {@link #setDamage(DamageModifier, double)} will not
-     * throw an {@link UnsupportedOperationException}.
-     * <p>
-     * {@link DamageModifier#BASE} is always applicable.
-     *
-     * @param type the modifier
-     * @return true if the modifier is supported by the caller, false otherwise
-     * @throws IllegalArgumentException if type is null
-     */
-    public boolean isApplicable(DamageModifier type) throws IllegalArgumentException {
-        Validate.notNull(type, "Cannot have null DamageModifier");
-        return modifiers.containsKey(type);
-    }
-
-    /**
-     * Gets the raw amount of damage caused by the event
-     *
-     * @return The raw amount of damage caused by the event
-     * @see DamageModifier#BASE
-     */
-    public double getDamage() {
-        return getDamage(DamageModifier.BASE);
-    }
-
-    /**
-     * Gets the amount of damage caused by the event after all damage
-     * reduction is applied.
-     *
-     * @return the amount of damage caused by the event
-     */
-    public final double getFinalDamage() {
-        double damage = 0;
-        for (DamageModifier modifier : MODIFIERS) {
-            damage += getDamage(modifier);
-        }
-        return damage;
-    }
-
-    /**
-     * This method exists for legacy reasons to provide backwards
-     * compatibility. It will not exist at runtime and should not be used
-     * under any circumstances.
-     * 
-     * @return the (rounded) damage
-     */
-    @Deprecated
-    public int _INVALID_getDamage() {
-        return NumberConversions.ceil(getDamage());
-    }
-
-    /**
-     * Sets the raw amount of damage caused by the event.
-     * <p>
-     * For compatibility this also recalculates the modifiers and scales
-     * them by the difference between the modifier for the previous damage
-     * value and the new one.
-     *
-     * @param damage The raw amount of damage caused by the event
-     */
-    public void setDamage(double damage) {
-        // These have to happen in the same order as the server calculates them, keep the enum sorted
-        double remaining = damage;
-        double oldRemaining = getDamage(DamageModifier.BASE);
-        for (DamageModifier modifier : MODIFIERS) {
-            if (!isApplicable(modifier)) {
-                continue;
-            }
-
-            Function<? super Double, Double> modifierFunction = modifierFunctions.get(modifier);
-            double newVanilla = modifierFunction.apply(remaining);
-            double oldVanilla = modifierFunction.apply(oldRemaining);
-            double difference = oldVanilla - newVanilla;
-
-            // Don't allow value to cross zero, assume zero values should be negative
-            double old = getDamage(modifier);
-            if (old > 0) {
-                setDamage(modifier, Math.max(0, old - difference));
-            } else {
-                setDamage(modifier, Math.min(0, old - difference));
-            }
-            remaining += newVanilla;
-            oldRemaining += oldVanilla;
-        }
-
-        setDamage(DamageModifier.BASE, damage);
-    }
-
-    /**
-     * This method exists for legacy reasons to provide backwards
-     * compatibility. It will not exist at runtime and should not be used
-     * under any circumstances.
-     * 
-     * @param damage the new damage value
-     */
-    @Deprecated
-    public void _INVALID_setDamage(int damage) {
-        setDamage(damage);
-    }
-
-    /**
-     * Gets the cause of the damage.
-     *
-     * @return A DamageCause value detailing the cause of the damage.
-     */
-    public DamageCause getCause() {
-        return cause;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-
-    /**
-     * An enum to specify the types of modifier
-     */
-    public enum DamageModifier {
-        /**
-         * This represents the amount of damage being done, also known as the
-         * raw {@link EntityDamageEvent#getDamage()}.
-         */
-        BASE,
-        /**
-         * This represents the damage reduced by a wearing a helmet when hit
-         * by a falling block.
-         */
-        HARD_HAT,
-        /**
-         * This represents  the damage reduction caused by blocking, only present for
-         * {@link Player Players}.
-         */
-        BLOCKING,
-        /**
-         * This represents the damage reduction caused by wearing armor.
-         */
-        ARMOR,
-        /**
-         * This represents the damage reduction caused by the Resistance potion effect.
-         */
-        RESISTANCE,
-        /**
-         * This represents the damage reduction caused by the combination of:
-         * <ul>
-         * <li>
-         *     Armor enchantments
-         * </li><li>
-         *     Witch's potion resistance
-         * </li>
-         * </ul>
-         */
-        MAGIC,
-        /**
-         * This represents the damage reduction caused by the absorption potion
-         * effect.
-         */
-        ABSORPTION,
-        ;
-    }
-
-    /**
-     * An enum to specify the cause of the damage
-     */
-    public enum DamageCause {
-
-        /**
-         * Damage caused when an entity contacts a block such as a Cactus.
-         * <p>
-         * Damage: 1 (Cactus)
-         */
-        CONTACT,
-        /**
-         * Damage caused when an entity attacks another entity.
-         * <p>
-         * Damage: variable
-         */
-        ENTITY_ATTACK,
-        /**
-         * Damage caused when attacked by a projectile.
-         * <p>
-         * Damage: variable
-         */
-        PROJECTILE,
-        /**
-         * Damage caused by being put in a block
-         * <p>
-         * Damage: 1
-         */
-        SUFFOCATION,
-        /**
-         * Damage caused when an entity falls a distance greater than 3 blocks
-         * <p>
-         * Damage: fall height - 3.0
-         */
-        FALL,
-        /**
-         * Damage caused by direct exposure to fire
-         * <p>
-         * Damage: 1
-         */
-        FIRE,
-        /**
-         * Damage caused due to burns caused by fire
-         * <p>
-         * Damage: 1
-         */
-        FIRE_TICK,
-        /**
-         * Damage caused due to a snowman melting
-         * <p>
-         * Damage: 1
-         */
-        MELTING,
-        /**
-         * Damage caused by direct exposure to lava
-         * <p>
-         * Damage: 4
-         */
-        LAVA,
-        /**
-         * Damage caused by running out of air while in water
-         * <p>
-         * Damage: 2
-         */
-        DROWNING,
-        /**
-         * Damage caused by being in the area when a block explodes.
-         * <p>
-         * Damage: variable
-         */
-        BLOCK_EXPLOSION,
-        /**
-         * Damage caused by being in the area when an entity, such as a
-         * Creeper, explodes.
-         * <p>
-         * Damage: variable
-         */
-        ENTITY_EXPLOSION,
-        /**
-         * Damage caused by falling into the void
-         * <p>
-         * Damage: 4 for players
-         */
-        VOID,
-        /**
-         * Damage caused by being struck by lightning
-         * <p>
-         * Damage: 5
-         */
-        LIGHTNING,
-        /**
-         * Damage caused by committing suicide using the command "/kill"
-         * <p>
-         * Damage: 1000
-         */
-        SUICIDE,
-        /**
-         * Damage caused by starving due to having an empty hunger bar
-         * <p>
-         * Damage: 1
-         */
-        STARVATION,
-        /**
-         * Damage caused due to an ongoing poison effect
-         * <p>
-         * Damage: 1
-         */
-        POISON,
-        /**
-         * Damage caused by being hit by a damage potion or spell
-         * <p>
-         * Damage: variable
-         */
-        MAGIC,
-        /**
-         * Damage caused by Wither potion effect
-         */
-        WITHER,
-        /**
-         * Damage caused by being hit by a falling block which deals damage
-         * <p>
-         * <b>Note:</b> Not every block deals damage
-         * <p>
-         * Damage: variable
-         */
-        FALLING_BLOCK,
-        /**
-         * Damage caused in retaliation to another attack by the Thorns
-         * enchantment.
-         * <p>
-         * Damage: 1-4 (Thorns)
-         */
-        THORNS,
-        /**
-         * Damage caused by a dragon breathing fire.
-         * <p>
-         * Damage: variable
-         */
-        DRAGON_BREATH,
-        /**
-         * Custom damage.
-         * <p>
-         * Damage: variable
-         */
-        CUSTOM,
-        /**
-         * Damage caused when an entity runs into a wall.
-         * <p>
-         * Damage: variable
-         */
-        FLY_INTO_WALL,
-        /**
-         * Damage caused when an entity steps on {@link Material#MAGMA}.
-         * <p>
-         * Damage: 1
-         */
-        HOT_FLOOR
-    }
-}
diff --git a/src/main/java/org/bukkit/bukkit/event/entity/EntityTargetEvent.java b/src/main/java/org/bukkit/bukkit/event/entity/EntityTargetEvent.java
deleted file mode 100644
index 9447197..0000000
--- a/src/main/java/org/bukkit/bukkit/event/entity/EntityTargetEvent.java
+++ /dev/null
@@ -1,156 +0,0 @@
-package org.bukkit.event.entity;
-
-import org.bukkit.entity.Entity;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a creature targets or untargets another entity
- */
-public class EntityTargetEvent extends EntityEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private boolean cancel = false;
-    private Entity target;
-    private final TargetReason reason;
-
-    public EntityTargetEvent(final Entity entity, final Entity target, final TargetReason reason) {
-        super(entity);
-        this.target = target;
-        this.reason = reason;
-    }
-
-    public boolean isCancelled() {
-        return cancel;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancel = cancel;
-    }
-
-    /**
-     * Returns the reason for the targeting
-     *
-     * @return The reason
-     */
-    public TargetReason getReason() {
-        return reason;
-    }
-
-    /**
-     * Get the entity that this is targeting.
-     * <p>
-     * This will be null in the case that the event is called when the mob
-     * forgets its target.
-     *
-     * @return The entity
-     */
-    public Entity getTarget() {
-        return target;
-    }
-
-    /**
-     * Set the entity that you want the mob to target instead.
-     * <p>
-     * It is possible to be null, null will cause the entity to be
-     * target-less.
-     * <p>
-     * This is different from cancelling the event. Cancelling the event will
-     * cause the entity to keep an original target, while setting to be null
-     * will cause the entity to be reset.
-     *
-     * @param target The entity to target
-     */
-    public void setTarget(Entity target) {
-        this.target = target;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-
-    /**
-     * An enum to specify the reason for the targeting
-     */
-    public enum TargetReason {
-
-        /**
-         * When the entity's target has died, and so it no longer targets it
-         */
-        TARGET_DIED,
-        /**
-         * When the entity doesn't have a target, so it attacks the nearest
-         * player
-         */
-        CLOSEST_PLAYER,
-        /**
-         * When the target attacks the entity, so entity targets it
-         */
-        TARGET_ATTACKED_ENTITY,
-        /**
-         * When the target attacks a fellow pig zombie, so the whole group
-         * will target him with this reason.
-         */
-        PIG_ZOMBIE_TARGET,
-        /**
-         * When the target is forgotten for whatever reason.
-         * <p>
-         * Currently only occurs in with spiders when there is a high
-         * brightness.
-         */
-        FORGOT_TARGET,
-        /**
-         * When the target attacks the owner of the entity, so the entity
-         * targets it.
-         */
-        TARGET_ATTACKED_OWNER,
-        /**
-         * When the owner of the entity attacks the target attacks, so the
-         * entity targets it.
-         */
-        OWNER_ATTACKED_TARGET,
-        /**
-         * When the entity has no target, so the entity randomly chooses one.
-         */
-        RANDOM_TARGET,
-        /**
-         * When an entity selects a target while defending a village.
-         */
-        DEFEND_VILLAGE,
-        /**
-         * When the target attacks a nearby entity of the same type, so the entity targets it
-         */
-        TARGET_ATTACKED_NEARBY_ENTITY,
-        /**
-         * When a zombie targeting an entity summons reinforcements, so the reinforcements target the same entity
-         */
-        REINFORCEMENT_TARGET,
-        /**
-         * When an entity targets another entity after colliding with it.
-         */
-        COLLISION,
-        /**
-         * For custom calls to the event.
-         */
-        CUSTOM,
-        /**
-         * When the entity doesn't have a target, so it attacks the nearest
-         * entity
-         */
-        CLOSEST_ENTITY,
-		/**
-         * When another entity tempts this entity by having a desired item such
-         * as wheat in it's hand.
-         */
-        TEMPT,
-        /**
-        /**
-         * A currently unknown reason for the entity changing target.
-         */
-        UNKNOWN;
-    }
-}
diff --git a/src/main/java/org/bukkit/bukkit/inventory/ItemStack.java b/src/main/java/org/bukkit/bukkit/inventory/ItemStack.java
deleted file mode 100644
index c412224..0000000
--- a/src/main/java/org/bukkit/bukkit/inventory/ItemStack.java
+++ /dev/null
@@ -1,611 +0,0 @@
-package org.bukkit.inventory;
-
-import com.google.common.collect.ImmutableMap;
-import java.util.LinkedHashMap;
-import java.util.Map;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.Bukkit;
-import org.bukkit.Material;
-import org.bukkit.Utility;
-import org.bukkit.configuration.serialization.ConfigurationSerializable;
-import org.bukkit.enchantments.Enchantment;
-import org.bukkit.inventory.meta.ItemMeta;
-import org.bukkit.material.MaterialData;
-
-/**
- * Represents a stack of items
- */
-public class ItemStack implements Cloneable, ConfigurationSerializable {
-    private int type = 0;
-    private int amount = 0;
-    private MaterialData data = null;
-    private short durability = 0;
-    private ItemMeta meta;
-
-    @Utility
-    protected ItemStack() {}
-
-    /**
-     * Defaults stack size to 1, with no extra data
-     *
-     * @param type item material id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public ItemStack(final int type) {
-        this(type, 1);
-    }
-
-    /**
-     * Defaults stack size to 1, with no extra data
-     *
-     * @param type item material
-     */
-    public ItemStack(final Material type) {
-        this(type, 1);
-    }
-
-    /**
-     * An item stack with no extra data
-     *
-     * @param type item material id
-     * @param amount stack size
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public ItemStack(final int type, final int amount) {
-        this(type, amount, (short) 0);
-    }
-
-    /**
-     * An item stack with no extra data
-     *
-     * @param type item material
-     * @param amount stack size
-     */
-    public ItemStack(final Material type, final int amount) {
-        this(type.getId(), amount);
-    }
-
-    /**
-     * An item stack with the specified damage / durability
-     *
-     * @param type item material id
-     * @param amount stack size
-     * @param damage durability / damage
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public ItemStack(final int type, final int amount, final short damage) {
-        this.type = type;
-        this.amount = amount;
-        this.durability = damage;
-    }
-
-    /**
-     * An item stack with the specified damage / durabiltiy
-     *
-     * @param type item material
-     * @param amount stack size
-     * @param damage durability / damage
-     */
-    public ItemStack(final Material type, final int amount, final short damage) {
-        this(type.getId(), amount, damage);
-    }
-
-    /**
-     * @param type the raw type id
-     * @param amount the amount in the stack
-     * @param damage the damage value of the item
-     * @param data the data value or null
-     * @deprecated this method uses an ambiguous data byte object
-     */
-    @Deprecated
-    public ItemStack(final int type, final int amount, final short damage, final Byte data) {
-        this.type = type;
-        this.amount = amount;
-        this.durability = damage;
-        if (data != null) {
-            createData(data);
-            this.durability = data;
-        }
-    }
-
-    /**
-     * @param type the type
-     * @param amount the amount in the stack
-     * @param damage the damage value of the item
-     * @param data the data value or null
-     * @deprecated this method uses an ambiguous data byte object
-     */
-    @Deprecated
-    public ItemStack(final Material type, final int amount, final short damage, final Byte data) {
-        this(type.getId(), amount, damage, data);
-    }
-
-    /**
-     * Creates a new item stack derived from the specified stack
-     *
-     * @param stack the stack to copy
-     * @throws IllegalArgumentException if the specified stack is null or
-     *     returns an item meta not created by the item factory
-     */
-    public ItemStack(final ItemStack stack) throws IllegalArgumentException {
-        Validate.notNull(stack, "Cannot copy null stack");
-        this.type = stack.getTypeId();
-        this.amount = stack.getAmount();
-        this.durability = stack.getDurability();
-        this.data = stack.getData();
-        if (stack.hasItemMeta()) {
-            setItemMeta0(stack.getItemMeta(), getType0());
-        }
-    }
-
-    /**
-     * Gets the type of this item
-     *
-     * @return Type of the items in this stack
-     */
-    @Utility
-    public Material getType() {
-        return getType0(getTypeId());
-    }
-
-    private Material getType0() {
-        return getType0(this.type);
-    }
-
-    private static Material getType0(int id) {
-        Material material = Material.getMaterial(id);
-        return material == null ? Material.AIR : material;
-    }
-
-    /**
-     * Sets the type of this item
-     * <p>
-     * Note that in doing so you will reset the MaterialData for this stack
-     *
-     * @param type New type to set the items in this stack to
-     */
-    @Utility
-    public void setType(Material type) {
-        Validate.notNull(type, "Material cannot be null");
-        setTypeId(type.getId());
-    }
-
-    /**
-     * Gets the type id of this item
-     *
-     * @return Type Id of the items in this stack
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public int getTypeId() {
-        return type;
-    }
-
-    /**
-     * Sets the type id of this item
-     * <p>
-     * Note that in doing so you will reset the MaterialData for this stack
-     *
-     * @param type New type id to set the items in this stack to
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public void setTypeId(int type) {
-        this.type = type;
-        if (this.meta != null) {
-            this.meta = Bukkit.getItemFactory().asMetaFor(meta, getType0());
-        }
-        createData((byte) 0);
-    }
-
-    /**
-     * Gets the amount of items in this stack
-     *
-     * @return Amount of items in this stick
-     */
-    public int getAmount() {
-        return amount;
-    }
-
-    /**
-     * Sets the amount of items in this stack
-     *
-     * @param amount New amount of items in this stack
-     */
-    public void setAmount(int amount) {
-        this.amount = amount;
-    }
-
-    /**
-     * Gets the MaterialData for this stack of items
-     *
-     * @return MaterialData for this item
-     */
-    public MaterialData getData() {
-        Material mat = getType();
-        if (data == null && mat != null && mat.getData() != null) {
-            data = mat.getNewData((byte) this.getDurability());
-        }
-
-        return data;
-    }
-
-    /**
-     * Sets the MaterialData for this stack of items
-     *
-     * @param data New MaterialData for this item
-     */
-    public void setData(MaterialData data) {
-        Material mat = getType();
-
-        if (data == null || mat == null || mat.getData() == null) {
-            this.data = data;
-        } else {
-            if ((data.getClass() == mat.getData()) || (data.getClass() == MaterialData.class)) {
-                this.data = data;
-            } else {
-                throw new IllegalArgumentException("Provided data is not of type " + mat.getData().getName() + ", found " + data.getClass().getName());
-            }
-        }
-    }
-
-    /**
-     * Sets the durability of this item
-     *
-     * @param durability Durability of this item
-     */
-    public void setDurability(final short durability) {
-        this.durability = durability;
-    }
-
-    /**
-     * Gets the durability of this item
-     *
-     * @return Durability of this item
-     */
-    public short getDurability() {
-        return durability;
-    }
-
-    /**
-     * Get the maximum stacksize for the material hold in this ItemStack.
-     * (Returns -1 if it has no idea)
-     *
-     * @return The maximum you can stack this material to.
-     */
-    @Utility
-    public int getMaxStackSize() {
-        Material material = getType();
-        if (material != null) {
-            return material.getMaxStackSize();
-        }
-        return -1;
-    }
-
-    private void createData(final byte data) {
-        Material mat = Material.getMaterial(type);
-
-        if (mat == null) {
-            this.data = new MaterialData(type, data);
-        } else {
-            this.data = mat.getNewData(data);
-        }
-    }
-
-    @Override
-    @Utility
-    public String toString() {
-        StringBuilder toString = new StringBuilder("ItemStack{").append(getType().name()).append(" x ").append(getAmount());
-        if (hasItemMeta()) {
-            toString.append(", ").append(getItemMeta());
-        }
-        return toString.append('}').toString();
-    }
-
-    @Override
-    @Utility
-    public boolean equals(Object obj) {
-        if (this == obj) {
-            return true;
-        }
-        if (!(obj instanceof ItemStack)) {
-            return false;
-        }
-
-        ItemStack stack = (ItemStack) obj;
-        return getAmount() == stack.getAmount() && isSimilar(stack);
-    }
-
-    /**
-     * This method is the same as equals, but does not consider stack size
-     * (amount).
-     *
-     * @param stack the item stack to compare to
-     * @return true if the two stacks are equal, ignoring the amount
-     */
-    @Utility
-    public boolean isSimilar(ItemStack stack) {
-        if (stack == null) {
-            return false;
-        }
-        if (stack == this) {
-            return true;
-        }
-        return getTypeId() == stack.getTypeId() && getDurability() == stack.getDurability() && hasItemMeta() == stack.hasItemMeta() && (hasItemMeta() ? Bukkit.getItemFactory().equals(getItemMeta(), stack.getItemMeta()) : true);
-    }
-
-    @Override
-    public ItemStack clone() {
-        try {
-            ItemStack itemStack = (ItemStack) super.clone();
-
-            if (this.meta != null) {
-                itemStack.meta = this.meta.clone();
-            }
-
-            if (this.data != null) {
-                itemStack.data = this.data.clone();
-            }
-
-            return itemStack;
-        } catch (CloneNotSupportedException e) {
-            throw new Error(e);
-        }
-    }
-
-    @Override
-    @Utility
-    public int hashCode() { // Torch
-        int hash = 1;
-
-        hash = hash * 31 + getTypeId();
-        hash = hash * 31 + getAmount();
-        hash = hash * 31 + (getDurability() & 0xffff);
-        hash = hash * 31 + (hasItemMeta() ? (meta == null ? getItemMeta().hashCode() : meta.hashCode()) : 0);
-
-        return hash;
-    }
-
-    /**
-     * Checks if this ItemStack contains the given {@link Enchantment}
-     *
-     * @param ench Enchantment to test
-     * @return True if this has the given enchantment
-     */
-    public boolean containsEnchantment(Enchantment ench) {
-        return meta == null ? false : meta.hasEnchant(ench);
-    }
-
-    /**
-     * Gets the level of the specified enchantment on this item stack
-     *
-     * @param ench Enchantment to check
-     * @return Level of the enchantment, or 0
-     */
-    public int getEnchantmentLevel(Enchantment ench) {
-        return meta == null ? 0 : meta.getEnchantLevel(ench);
-    }
-
-    /**
-     * Gets a map containing all enchantments and their levels on this item.
-     *
-     * @return Map of enchantments.
-     */
-    public Map<Enchantment, Integer> getEnchantments() {
-        return meta == null ? ImmutableMap.<Enchantment, Integer>of() : meta.getEnchants();
-    }
-
-    /**
-     * Adds the specified enchantments to this item stack.
-     * <p>
-     * This method is the same as calling {@link
-     * #addEnchantment(org.bukkit.enchantments.Enchantment, int)} for each
-     * element of the map.
-     *
-     * @param enchantments Enchantments to add
-     * @throws IllegalArgumentException if the specified enchantments is null
-     * @throws IllegalArgumentException if any specific enchantment or level
-     *     is null. <b>Warning</b>: Some enchantments may be added before this
-     *     exception is thrown.
-     */
-    @Utility
-    public void addEnchantments(Map<Enchantment, Integer> enchantments) {
-        Validate.notNull(enchantments, "Enchantments cannot be null");
-        for (Map.Entry<Enchantment, Integer> entry : enchantments.entrySet()) {
-            addEnchantment(entry.getKey(), entry.getValue());
-        }
-    }
-
-    /**
-     * Adds the specified {@link Enchantment} to this item stack.
-     * <p>
-     * If this item stack already contained the given enchantment (at any
-     * level), it will be replaced.
-     *
-     * @param ench Enchantment to add
-     * @param level Level of the enchantment
-     * @throws IllegalArgumentException if enchantment null, or enchantment is
-     *     not applicable
-     */
-    @Utility
-    public void addEnchantment(Enchantment ench, int level) {
-        Validate.notNull(ench, "Enchantment cannot be null");
-        if ((level < ench.getStartLevel()) || (level > ench.getMaxLevel())) {
-            throw new IllegalArgumentException("Enchantment level is either too low or too high (given " + level + ", bounds are " + ench.getStartLevel() + " to " + ench.getMaxLevel() + ")");
-        } else if (!ench.canEnchantItem(this)) {
-            throw new IllegalArgumentException("Specified enchantment cannot be applied to this itemstack");
-        }
-
-        addUnsafeEnchantment(ench, level);
-    }
-
-    /**
-     * Adds the specified enchantments to this item stack in an unsafe manner.
-     * <p>
-     * This method is the same as calling {@link
-     * #addUnsafeEnchantment(org.bukkit.enchantments.Enchantment, int)} for
-     * each element of the map.
-     *
-     * @param enchantments Enchantments to add
-     */
-    @Utility
-    public void addUnsafeEnchantments(Map<Enchantment, Integer> enchantments) {
-        for (Map.Entry<Enchantment, Integer> entry : enchantments.entrySet()) {
-            addUnsafeEnchantment(entry.getKey(), entry.getValue());
-        }
-    }
-
-    /**
-     * Adds the specified {@link Enchantment} to this item stack.
-     * <p>
-     * If this item stack already contained the given enchantment (at any
-     * level), it will be replaced.
-     * <p>
-     * This method is unsafe and will ignore level restrictions or item type.
-     * Use at your own discretion.
-     *
-     * @param ench Enchantment to add
-     * @param level Level of the enchantment
-     */
-    public void addUnsafeEnchantment(Enchantment ench, int level) {
-        (meta == null ? meta = Bukkit.getItemFactory().getItemMeta(getType0()) : meta).addEnchant(ench, level, true);
-    }
-
-    /**
-     * Removes the specified {@link Enchantment} if it exists on this
-     * ItemStack
-     *
-     * @param ench Enchantment to remove
-     * @return Previous level, or 0
-     */
-    public int removeEnchantment(Enchantment ench) {
-        int level = getEnchantmentLevel(ench);
-        if (level == 0 || meta == null) {
-            return level;
-        }
-        meta.removeEnchant(ench);
-        return level;
-    }
-
-    @Utility
-    public Map<String, Object> serialize() {
-        Map<String, Object> result = new LinkedHashMap<String, Object>();
-
-        result.put("type", getType().name());
-
-        if (getDurability() != 0) {
-            result.put("damage", getDurability());
-        }
-
-        if (getAmount() != 1) {
-            result.put("amount", getAmount());
-        }
-
-        ItemMeta meta = getItemMeta();
-        if (!Bukkit.getItemFactory().equals(meta, null)) {
-            result.put("meta", meta);
-        }
-
-        return result;
-    }
-
-    /**
-     * Required method for configuration serialization
-     *
-     * @param args map to deserialize
-     * @return deserialized item stack
-     * @see ConfigurationSerializable
-     */
-    public static ItemStack deserialize(Map<String, Object> args) {
-        Material type = Material.getMaterial((String) args.get("type"));
-        short damage = 0;
-        int amount = 1;
-
-        if (args.containsKey("damage")) {
-            damage = ((Number) args.get("damage")).shortValue();
-        }
-
-        if (args.containsKey("amount")) {
-            amount = ((Number) args.get("amount")).intValue();
-        }
-
-        ItemStack result = new ItemStack(type, amount, damage);
-
-        if (args.containsKey("enchantments")) { // Backward compatiblity, @deprecated
-            Object raw = args.get("enchantments");
-
-            if (raw instanceof Map) {
-                Map<?, ?> map = (Map<?, ?>) raw;
-
-                for (Map.Entry<?, ?> entry : map.entrySet()) {
-                    Enchantment enchantment = Enchantment.getByName(entry.getKey().toString());
-
-                    if ((enchantment != null) && (entry.getValue() instanceof Integer)) {
-                        result.addUnsafeEnchantment(enchantment, (Integer) entry.getValue());
-                    }
-                }
-            }
-        } else if (args.containsKey("meta")) { // We cannot and will not have meta when enchantments (pre-ItemMeta) exist
-            Object raw = args.get("meta");
-            if (raw instanceof ItemMeta) {
-                result.setItemMeta((ItemMeta) raw);
-            }
-        }
-
-        return result;
-    }
-
-    /**
-     * Get a copy of this ItemStack's {@link ItemMeta}.
-     *
-     * @return a copy of the current ItemStack's ItemData
-     */
-    public ItemMeta getItemMeta() {
-        return this.meta == null ? Bukkit.getItemFactory().getItemMeta(getType0()) : this.meta.clone();
-    }
-
-    /**
-     * Checks to see if any meta data has been defined.
-     *
-     * @return Returns true if some meta data has been set for this item
-     */
-    public boolean hasItemMeta() {
-        return !Bukkit.getItemFactory().equals(meta, null);
-    }
-
-    /**
-     * Set the ItemMeta of this ItemStack.
-     *
-     * @param itemMeta new ItemMeta, or null to indicate meta data be cleared.
-     * @return True if successfully applied ItemMeta, see {@link
-     *     ItemFactory#isApplicable(ItemMeta, ItemStack)}
-     * @throws IllegalArgumentException if the item meta was not created by
-     *     the {@link ItemFactory}
-     */
-    public boolean setItemMeta(ItemMeta itemMeta) {
-        return setItemMeta0(itemMeta, getType0());
-    }
-
-    /*
-     * Cannot be overridden, so it's safe for constructor call
-     */
-    private boolean setItemMeta0(ItemMeta itemMeta, Material material) {
-        if (itemMeta == null) {
-            this.meta = null;
-            return true;
-        }
-        if (!Bukkit.getItemFactory().isApplicable(itemMeta, material)) {
-            return false;
-        }
-        this.meta = Bukkit.getItemFactory().asMetaFor(itemMeta, material);
-        if (this.meta == itemMeta) {
-            this.meta = itemMeta.clone();
-        }
-
-        return true;
-    }
-}
diff --git a/src/main/java/org/bukkit/bukkit/inventory/meta/BookMeta.java b/src/main/java/org/bukkit/bukkit/inventory/meta/BookMeta.java
deleted file mode 100644
index 599a20c..0000000
--- a/src/main/java/org/bukkit/bukkit/inventory/meta/BookMeta.java
+++ /dev/null
@@ -1,176 +0,0 @@
-package org.bukkit.inventory.meta;
-
-import java.util.List;
-
-import org.bukkit.Material;
-
-/**
- * Represents a book ({@link Material#BOOK_AND_QUILL} or {@link
- * Material#WRITTEN_BOOK}) that can have a title, an author, and pages.
- */
-public interface BookMeta extends ItemMeta {
-
-    /**
-     * Represents the generation (or level of copying) of a written book
-     */
-    enum Generation {
-        /**
-         * Book written into a book-and-quill. Can be copied. (Default value)
-         */
-        ORIGINAL,
-        /**
-         * Book that was copied from an original. Can be copied.
-         */
-        COPY_OF_ORIGINAL,
-        /**
-         * Book that was copied from a copy of an original. Can't be copied.
-         */
-        COPY_OF_COPY,
-        /**
-         * Unused; unobtainable by players. Can't be copied.
-         */
-        TATTERED;
-    }
-
-    /**
-     * Checks for the existence of a title in the book.
-     *
-     * @return true if the book has a title
-     */
-    boolean hasTitle();
-
-    /**
-     * Gets the title of the book.
-     * <p>
-     * Plugins should check that hasTitle() returns true before calling this
-     * method.
-     *
-     * @return the title of the book
-     */
-    String getTitle();
-
-    /**
-     * Sets the title of the book.
-     * <p>
-     * Limited to 16 characters. Removes title when given null.
-     *
-     * @param title the title to set
-     * @return true if the title was successfully set
-     */
-    boolean setTitle(String title);
-
-    /**
-     * Checks for the existence of an author in the book.
-     *
-     * @return true if the book has an author
-     */
-    boolean hasAuthor();
-
-    /**
-     * Gets the author of the book.
-     * <p>
-     * Plugins should check that hasAuthor() returns true before calling this
-     * method.
-     *
-     * @return the author of the book
-     */
-    String getAuthor();
-
-    /**
-     * Sets the author of the book. Removes author when given null.
-     *
-     * @param author the author to set
-     */
-    void setAuthor(String author);
-
-    /**
-     * Checks for the existence of generation level in the book.
-     *
-     * @return true if the book has a generation level
-     */
-    boolean hasGeneration();
-
-    /**
-     * Gets the generation of the book.
-     * <p>
-     * Plugins should check that hasGeneration() returns true before calling
-     * this method.
-     *
-     * @return the generation of the book
-     */
-    Generation getGeneration();
-
-    /**
-     * Sets the generation of the book. Removes generation when given null.
-     *
-     * @param generation the generation to set
-     */
-    void setGeneration(Generation generation);
-
-    /**
-     * Checks for the existence of pages in the book.
-     *
-     * @return true if the book has pages
-     */
-    boolean hasPages();
-
-    /**
-     * Gets the specified page in the book. The given page must exist.
-     *
-     * @param page the page number to get
-     * @return the page from the book
-     */
-    String getPage(int page);
-
-    /**
-     * Sets the specified page in the book. Pages of the book must be
-     * contiguous.
-     * <p>
-     * The data can be up to 256 characters in length, additional characters
-     * are truncated.
-     *
-     * @param page the page number to set
-     * @param data the data to set for that page
-     */
-    void setPage(int page, String data);
-
-    /**
-     * Gets all the pages in the book.
-     *
-     * @return list of all the pages in the book
-     */
-    List<String> getPages();
-
-    /**
-     * Clears the existing book pages, and sets the book to use the provided
-     * pages. Maximum 50 pages with 256 characters per page.
-     *
-     * @param pages A list of pages to set the book to use
-     */
-    void setPages(List<String> pages);
-
-    /**
-     * Clears the existing book pages, and sets the book to use the provided
-     * pages. Maximum 50 pages with 256 characters per page.
-     *
-     * @param pages A list of strings, each being a page
-     */
-    void setPages(String... pages);
-
-    /**
-     * Adds new pages to the end of the book. Up to a maximum of 50 pages with
-     * 256 characters per page.
-     *
-     * @param pages A list of strings, each being a page
-     */
-    void addPage(String... pages);
-
-    /**
-     * Gets the number of pages in the book.
-     *
-     * @return the number of pages in the book
-     */
-    int getPageCount();
-
-    BookMeta clone();
-}
\ No newline at end of file
diff --git a/src/main/java/org/bukkit/command/SimpleCommandMap.java b/src/main/java/org/bukkit/command/SimpleCommandMap.java
new file mode 100644
index 0000000..649f9f7
--- /dev/null
+++ b/src/main/java/org/bukkit/command/SimpleCommandMap.java
@@ -0,0 +1,285 @@
+package org.bukkit.command;
+
+import static org.bukkit.util.Java15Compat.Arrays_copyOfRange;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.regex.Pattern;
+
+import com.destroystokyo.paper.event.server.ServerExceptionEvent;
+import com.destroystokyo.paper.exception.ServerCommandException;
+import com.destroystokyo.paper.exception.ServerTabCompleteException;
+
+import org.bukkit.Location;
+import org.apache.commons.lang.Validate;
+import org.bukkit.Server;
+import org.bukkit.command.defaults.*;
+import org.bukkit.entity.Player;
+import org.bukkit.util.StringUtil;
+
+public class SimpleCommandMap implements CommandMap {
+    private static final Pattern PATTERN_ON_SPACE = Pattern.compile(" ", Pattern.LITERAL);
+    protected final Map<String, Command> knownCommands = new HashMap<String, Command>();
+    private final Server server;
+
+    public SimpleCommandMap(final Server server) {
+        this.server = server;
+        setDefaultCommands();
+    }
+
+    private void setDefaultCommands() {
+        register("bukkit", new VersionCommand("version"));
+        register("bukkit", new ReloadCommand("reload"));
+        register("bukkit", new PluginsCommand("plugins"));
+        register("bukkit", new co.aikar.timings.TimingsCommand("timings")); // Spigot
+    }
+
+    public void setFallbackCommands() {
+        register("bukkit", new HelpCommand());
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void registerAll(String fallbackPrefix, List<Command> commands) {
+        if (commands != null) {
+            for (Command c : commands) {
+                register(fallbackPrefix, c);
+            }
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public boolean register(String fallbackPrefix, Command command) {
+        return register(command.getName(), fallbackPrefix, command);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public boolean register(String label, String fallbackPrefix, Command command) {
+		command.timings = co.aikar.timings.TimingsManager.getCommandTiming(fallbackPrefix, command); // Spigot
+        label = label.toLowerCase().trim();
+        fallbackPrefix = fallbackPrefix.toLowerCase().trim();
+        boolean registered = register(label, command, false, fallbackPrefix);
+
+        Iterator<String> iterator = command.getAliases().iterator();
+        while (iterator.hasNext()) {
+            if (!register(iterator.next(), command, true, fallbackPrefix)) {
+                iterator.remove();
+            }
+        }
+
+        // If we failed to register under the real name, we need to set the command label to the direct address
+        if (!registered) {
+            command.setLabel(fallbackPrefix + ":" + label);
+        }
+
+        // Register to us so further updates of the commands label and aliases are postponed until its reregistered
+        command.register(this);
+
+        return registered;
+    }
+
+    /**
+     * Registers a command with the given name is possible. Also uses
+     * fallbackPrefix to create a unique name.
+     *
+     * @param label the name of the command, without the '/'-prefix.
+     * @param command the command to register
+     * @param isAlias whether the command is an alias
+     * @param fallbackPrefix a prefix which is prepended to the command for a
+     *     unique address
+     * @return true if command was registered, false otherwise.
+     */
+    private synchronized boolean register(String label, Command command, boolean isAlias, String fallbackPrefix) {
+        knownCommands.put(fallbackPrefix + ":" + label, command);
+        if ((command instanceof VanillaCommand || isAlias) && knownCommands.containsKey(label)) {
+            // Request is for an alias/fallback command and it conflicts with
+            // a existing command or previous alias ignore it
+            // Note: This will mean it gets removed from the commands list of active aliases
+            return false;
+        }
+
+        boolean registered = true;
+
+        // If the command exists but is an alias we overwrite it, otherwise we return
+        Command conflict = knownCommands.get(label);
+        if (conflict != null && conflict.getLabel().equals(label)) {
+            return false;
+        }
+
+        if (!isAlias) {
+            command.setLabel(label);
+        }
+        knownCommands.put(label, command);
+
+        return registered;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public boolean dispatch(CommandSender sender, String commandLine) throws CommandException {
+        String[] args = PATTERN_ON_SPACE.split(commandLine);
+
+        if (args.length == 0) {
+            return false;
+        }
+
+        String sentCommandLabel = args[0].toLowerCase();
+        Command target = getCommand(sentCommandLabel);
+
+        if (target == null) {
+            return false;
+        }
+		
+		// Paper start - Plugins do weird things to workaround normal registration
+        if (target.timings == null) {
+            target.timings = co.aikar.timings.TimingsManager.getCommandTiming(null, target);
+        }
+        // Paper end
+
+        try {
+            // Note: we don't return the result of target.execute as thats success / failure, we return handled (true) or not handled (false)
+            target.execute(sender, sentCommandLabel, Arrays_copyOfRange(args, 1, args.length));
+        } catch (CommandException ex) {
+            throw ex;
+        } catch (Throwable ex) {
+            String msg = "Unhandled exception executing '" + commandLine + "' in " + target;
+            server.getPluginManager().callEvent(new ServerExceptionEvent(new ServerCommandException(ex, target, sender, args))); // Paper
+            throw new CommandException(msg, ex);
+        }
+
+        // return true as command was handled
+        return true;
+    }
+
+    public synchronized void clearCommands() {
+        for (Map.Entry<String, Command> entry : knownCommands.entrySet()) {
+            entry.getValue().unregister(this);
+        }
+        knownCommands.clear();
+        setDefaultCommands();
+    }
+
+    public Command getCommand(String name) {
+        Command target = knownCommands.get(name.toLowerCase());
+        return target;
+    }
+
+    public List<String> tabComplete(CommandSender sender, String cmdLine) {
+		return tabComplete(sender, cmdLine, null); // Paper - location tab-completes, code moved below
+    }
+
+    // Paper start - location tab-completes
+    /**
+     * This code was copied, except for the noted change, from tabComplete(CommandSender sender, String cmdLine)
+     */
+    public List<String> tabComplete(CommandSender sender, String cmdLine, Location location) {
+        Validate.notNull(sender, "Sender cannot be null");
+        Validate.notNull(cmdLine, "Command line cannot null");
+
+        int spaceIndex = cmdLine.indexOf(' ');
+
+        if (spaceIndex == -1) {
+            ArrayList<String> completions = new ArrayList<String>();
+            Map<String, Command> knownCommands = this.knownCommands;
+
+            final String prefix = (sender instanceof Player ? "/" : "");
+
+            for (Map.Entry<String, Command> commandEntry : knownCommands.entrySet()) {
+                Command command = commandEntry.getValue();
+
+                if (!command.testPermissionSilent(sender)) {
+                    continue;
+                }
+
+                String name = commandEntry.getKey(); // Use the alias, not command name
+
+                if (StringUtil.startsWithIgnoreCase(name, cmdLine)) {
+                    completions.add(prefix + name);
+                }
+            }
+
+            Collections.sort(completions, String.CASE_INSENSITIVE_ORDER);
+            return completions;
+        }
+
+        String commandName = cmdLine.substring(0, spaceIndex);
+        Command target = getCommand(commandName);
+
+        if (target == null) {
+            return null;
+        }
+
+        if (!target.testPermissionSilent(sender)) {
+            return null;
+        }
+
+        String argLine = cmdLine.substring(spaceIndex + 1, cmdLine.length());
+        String[] args = PATTERN_ON_SPACE.split(argLine, -1);
+
+        try {
+            return target.tabComplete(sender, commandName, args, location); // Paper - add location argument
+        } catch (CommandException ex) {
+            throw ex;
+        } catch (Throwable ex) {
+            String msg = "Unhandled exception executing tab-completer for '" + cmdLine + "' in " + target;
+            server.getPluginManager().callEvent(new ServerExceptionEvent(new ServerTabCompleteException(msg, ex, target, sender, args))); // Paper
+            throw new CommandException(msg, ex);
+        }
+    }
+
+    public Collection<Command> getCommands() {
+        return Collections.unmodifiableCollection(knownCommands.values());
+    }
+
+    public void registerServerAliases() {
+        Map<String, String[]> values = server.getCommandAliases();
+
+        for (String alias : values.keySet()) {
+            if (alias.contains(" ")) {
+                server.getLogger().warning("Could not register alias " + alias + " because it contains illegal characters");
+                continue;
+            }
+
+            String[] commandStrings = values.get(alias);
+            List<String> targets = new ArrayList<String>();
+            StringBuilder bad = new StringBuilder();
+
+            for (String commandString : commandStrings) {
+                String[] commandArgs = commandString.split(" ");
+                Command command = getCommand(commandArgs[0]);
+
+                if (command == null) {
+                    if (bad.length() > 0) {
+                        bad.append(", ");
+                    }
+                    bad.append(commandString);
+                } else {
+                    targets.add(commandString);
+                }
+            }
+
+            if (bad.length() > 0) {
+                server.getLogger().warning("Could not register alias " + alias + " because it contains commands that do not exist: " + bad);
+                continue;
+            }
+
+            // We register these as commands so they have absolute priority.
+            if (targets.size() > 0) {
+                knownCommands.put(alias.toLowerCase(), new FormattedCommandAlias(alias.toLowerCase(), targets.toArray(new String[targets.size()])));
+            } else {
+                knownCommands.remove(alias.toLowerCase());
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBook.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBook.java
index 7f2a30a..9d96f9d 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBook.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBook.java
@@ -178,6 +178,10 @@ public class CraftMetaBook extends CraftMetaItem implements BookMeta {
     public boolean hasPages() {
         return !pages.isEmpty();
     }
+	
+	public boolean hasGeneration() {
+        return generation != null;
+    }
 
     public String getTitle() {
         return this.title;
@@ -296,6 +300,9 @@ public class CraftMetaBook extends CraftMetaItem implements BookMeta {
         if (hasPages()) {
             hash = 61 * hash + 17 * this.pages.hashCode();
         }
+		if (hasGeneration()) {
+            hash = 61 * hash + 19 * this.generation.hashCode();
+        }
         return original != hash ? CraftMetaBook.class.hashCode() ^ hash : hash;
     }
 
@@ -309,7 +316,8 @@ public class CraftMetaBook extends CraftMetaItem implements BookMeta {
 
             return (hasTitle() ? that.hasTitle() && this.title.equals(that.title) : !that.hasTitle())
                     && (hasAuthor() ? that.hasAuthor() && this.author.equals(that.author) : !that.hasAuthor())
-                    && (hasPages() ? that.hasPages() && this.pages.equals(that.pages) : !that.hasPages());
+                    && (hasPages() ? that.hasPages() && this.pages.equals(that.pages) : !that.hasPages())
+                    && (hasGeneration() ? that.hasGeneration() && this.generation.equals(that.generation) : !that.hasGeneration());
         }
         return true;
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/util/Versioning.java b/src/main/java/org/bukkit/craftbukkit/util/Versioning.java
index 4135e72..42d2aa4 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/Versioning.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/Versioning.java
@@ -20,7 +20,7 @@ public final class Versioning {
 
                 result = properties.getProperty("version");
             } catch (IOException ex) {
-                Logger.getLogger(Versioning.class.getName()).log(Level.SEVERE, "Could not get Bukkit version!", ex);
+                Logger.getLogger(Versioning.class.getName()).log(Level.SEVERE, "Could not get Torch version!", ex);
             }
         }
 
diff --git a/src/main/java/org/bukkit/enchantments/EnchantmentTarget.java b/src/main/java/org/bukkit/enchantments/EnchantmentTarget.java
new file mode 100644
index 0000000..dee2350
--- /dev/null
+++ b/src/main/java/org/bukkit/enchantments/EnchantmentTarget.java
@@ -0,0 +1,182 @@
+package org.bukkit.enchantments;
+
+import org.bukkit.Material;
+import org.bukkit.inventory.ItemStack;
+
+/**
+ * Represents the applicable target for a {@link Enchantment}
+ */
+public enum EnchantmentTarget {
+    /**
+     * Allows the Enchantment to be placed on all items
+     */
+    ALL {
+        @Override
+        public boolean includes(Material item) {
+            return true;
+        }
+    },
+
+    /**
+     * Allows the Enchantment to be placed on armor
+     */
+    ARMOR {
+        @Override
+        public boolean includes(Material item) {
+            return ARMOR_FEET.includes(item)
+                || ARMOR_LEGS.includes(item)
+                || ARMOR_HEAD.includes(item)
+                || ARMOR_TORSO.includes(item);
+        }
+    },
+
+    /**
+     * Allows the Enchantment to be placed on feet slot armor
+     */
+    ARMOR_FEET {
+        @Override
+        public boolean includes(Material item) {
+            return item.equals(Material.LEATHER_BOOTS)
+                || item.equals(Material.CHAINMAIL_BOOTS)
+                || item.equals(Material.IRON_BOOTS)
+                || item.equals(Material.DIAMOND_BOOTS)
+                || item.equals(Material.GOLD_BOOTS);
+        }
+    },
+
+    /**
+     * Allows the Enchantment to be placed on leg slot armor
+     */
+    ARMOR_LEGS {
+        @Override
+        public boolean includes(Material item) {
+            return item.equals(Material.LEATHER_LEGGINGS)
+                || item.equals(Material.CHAINMAIL_LEGGINGS)
+                || item.equals(Material.IRON_LEGGINGS)
+                || item.equals(Material.DIAMOND_LEGGINGS)
+                || item.equals(Material.GOLD_LEGGINGS);
+        }
+    },
+
+    /**
+     * Allows the Enchantment to be placed on torso slot armor
+     */
+    ARMOR_TORSO {
+        @Override
+        public boolean includes(Material item) {
+            return item.equals(Material.LEATHER_CHESTPLATE)
+                || item.equals(Material.CHAINMAIL_CHESTPLATE)
+                || item.equals(Material.IRON_CHESTPLATE)
+                || item.equals(Material.DIAMOND_CHESTPLATE)
+                || item.equals(Material.GOLD_CHESTPLATE);
+        }
+    },
+
+    /**
+     * Allows the Enchantment to be placed on head slot armor
+     */
+    ARMOR_HEAD {
+        @Override
+        public boolean includes(Material item) {
+            return item.equals(Material.LEATHER_HELMET)
+                || item.equals(Material.CHAINMAIL_HELMET)
+                || item.equals(Material.DIAMOND_HELMET)
+                || item.equals(Material.IRON_HELMET)
+                || item.equals(Material.GOLD_HELMET);
+        }
+    },
+
+    /**
+     * Allows the Enchantment to be placed on weapons (swords)
+     */
+    WEAPON {
+        @Override
+        public boolean includes(Material item) {
+            return item.equals(Material.WOOD_SWORD)
+                || item.equals(Material.STONE_SWORD)
+                || item.equals(Material.IRON_SWORD)
+                || item.equals(Material.DIAMOND_SWORD)
+                || item.equals(Material.GOLD_SWORD);
+        }
+    },
+
+    /**
+     * Allows the Enchantment to be placed on tools (spades, pickaxe, hoes,
+     * axes)
+     */
+    TOOL {
+        @Override
+        public boolean includes(Material item) {
+            return item.equals(Material.WOOD_SPADE)
+                || item.equals(Material.STONE_SPADE)
+                || item.equals(Material.IRON_SPADE)
+                || item.equals(Material.DIAMOND_SPADE)
+                || item.equals(Material.GOLD_SPADE)
+                || item.equals(Material.WOOD_PICKAXE)
+                || item.equals(Material.STONE_PICKAXE)
+                || item.equals(Material.IRON_PICKAXE)
+                || item.equals(Material.DIAMOND_PICKAXE)
+                || item.equals(Material.GOLD_PICKAXE)
+                || item.equals(Material.WOOD_HOE)         // NOTE: No vanilla enchantments for this
+                || item.equals(Material.STONE_HOE)        // NOTE: No vanilla enchantments for this
+                || item.equals(Material.IRON_HOE)         // NOTE: No vanilla enchantments for this
+                || item.equals(Material.DIAMOND_HOE)      // NOTE: No vanilla enchantments for this
+                || item.equals(Material.GOLD_HOE)         // NOTE: No vanilla enchantments for this
+                || item.equals(Material.WOOD_AXE)
+                || item.equals(Material.STONE_AXE)
+                || item.equals(Material.IRON_AXE)
+                || item.equals(Material.DIAMOND_AXE)
+                || item.equals(Material.GOLD_AXE)
+                || item.equals(Material.SHEARS)           // NOTE: No vanilla enchantments for this
+                || item.equals(Material.FLINT_AND_STEEL); // NOTE: No vanilla enchantments for this
+        }
+    },
+
+    /**
+     * Allows the Enchantment to be placed on bows.
+     */
+    BOW {
+        @Override
+        public boolean includes(Material item) {
+            return item.equals(Material.BOW);
+        }
+    },
+
+    /**
+     * Allows the Enchantment to be placed on fishing rods.
+     */
+    FISHING_ROD {
+        @Override
+        public boolean includes(Material item) {
+            return item.equals(Material.FISHING_ROD);
+        }
+    },
+
+    /**
+     * Allows the enchantment to be placed on items with durability.
+     */
+    BREAKABLE {
+        @Override
+        public boolean includes(Material item) {
+            return item.getMaxDurability() > 0 && item.getMaxStackSize() == 1;
+        }
+    };
+
+    /**
+     * Check whether this target includes the specified item.
+     *
+     * @param item The item to check
+     * @return True if the target includes the item
+     */
+    public abstract boolean includes(Material item);
+
+    /**
+     * Check whether this target includes the specified item.
+     *
+     * @param item The item to check
+     * @return True if the target includes the item
+     */
+    public boolean includes(ItemStack item) {
+        return includes(item.getType());
+    }
+}
diff --git a/src/main/java/org/bukkit/entity/Player.java b/src/main/java/org/bukkit/entity/Player.java
new file mode 100644
index 0000000..9436cc7
--- /dev/null
+++ b/src/main/java/org/bukkit/entity/Player.java
@@ -0,0 +1,1622 @@
+package org.bukkit.entity;
+
+import java.net.InetSocketAddress;
+
+import com.destroystokyo.paper.Title;
+import org.bukkit.Achievement;
+import org.bukkit.ChatColor;
+import org.bukkit.Effect;
+import org.bukkit.GameMode;
+import org.bukkit.Instrument;
+import org.bukkit.Location;
+import org.bukkit.Material;
+import org.bukkit.Note;
+import org.bukkit.OfflinePlayer;
+import org.bukkit.Particle;
+import org.bukkit.Sound;
+import org.bukkit.Statistic;
+import org.bukkit.WeatherType;
+import org.bukkit.command.CommandSender;
+import org.bukkit.conversations.Conversable;
+import org.bukkit.map.MapView;
+import org.bukkit.plugin.messaging.PluginMessageRecipient;
+import org.bukkit.scoreboard.Scoreboard;
+
+import com.destroystokyo.paper.profile.AccountProfile; // Paper
+
+/**
+ * Represents a player, connected or not
+ */
+public interface Player extends HumanEntity, Conversable, CommandSender, OfflinePlayer, PluginMessageRecipient {
+
+    /**
+     * Gets the "friendly" name to display of this player. This may include
+     * color.
+     * <p>
+     * Note that this name will not be displayed in game, only in chat and
+     * places defined by plugins.
+     *
+     * @return the friendly name
+     */
+    public String getDisplayName();
+
+    /**
+     * Sets the "friendly" name to display of this player. This may include
+     * color.
+     * <p>
+     * Note that this name will not be displayed in game, only in chat and
+     * places defined by plugins.
+     *
+     * @param name The new display name.
+     */
+    public void setDisplayName(String name);
+
+    /**
+     * Gets the name that is shown on the player list.
+     *
+     * @return the player list name
+     */
+    public String getPlayerListName();
+
+    /**
+     * Sets the name that is shown on the in-game player list.
+     * <p>
+     * The name cannot be longer than 16 characters, but {@link ChatColor} is
+     * supported.
+     * <p>
+     * If the value is null, the name will be identical to {@link #getName()}.
+     * <p>
+     * This name is case sensitive and unique, two names with different casing
+     * will appear as two different people. If a player joins afterwards with
+     * a name that conflicts with a player's custom list name, the joining
+     * player's player list name will have a random number appended to it (1-2
+     * characters long in the default implementation). If the joining player's
+     * name is 15 or 16 characters long, part of the name will be truncated at
+     * the end to allow the addition of the two digits.
+     *
+     * @param name new player list name
+     * @throws IllegalArgumentException if the name is already used by someone
+     *     else
+     * @throws IllegalArgumentException if the length of the name is too long
+     */
+    public void setPlayerListName(String name);
+
+    /**
+     * Set the target of the player's compass.
+     *
+     * @param loc Location to point to
+     */
+    public void setCompassTarget(Location loc);
+
+    /**
+     * Get the previously set compass target.
+     *
+     * @return location of the target
+     */
+    public Location getCompassTarget();
+
+    /**
+     * Gets the socket address of this player
+     *
+     * @return the player's address
+     */
+    public InetSocketAddress getAddress();
+
+    /**
+     * Sends this sender a message raw
+     *
+     * @param message Message to be displayed
+     */
+    public void sendRawMessage(String message);
+
+    /**
+     * Kicks player with custom kick message.
+     *
+     * @param message kick message
+     */
+    public void kickPlayer(String message);
+
+    /**
+     * Says a message (or runs a command).
+     *
+     * @param msg message to print
+     */
+    public void chat(String msg);
+
+    /**
+     * Makes the player perform the given command
+     *
+     * @param command Command to perform
+     * @return true if the command was successful, otherwise false
+     */
+    public boolean performCommand(String command);
+
+    /**
+     * Returns if the player is in sneak mode
+     *
+     * @return true if player is in sneak mode
+     */
+    public boolean isSneaking();
+
+    /**
+     * Sets the sneak mode the player
+     *
+     * @param sneak true if player should appear sneaking
+     */
+    public void setSneaking(boolean sneak);
+
+    /**
+     * Gets whether the player is sprinting or not.
+     *
+     * @return true if player is sprinting.
+     */
+    public boolean isSprinting();
+
+    /**
+     * Sets whether the player is sprinting or not.
+     *
+     * @param sprinting true if the player should be sprinting
+     */
+    public void setSprinting(boolean sprinting);
+
+    /**
+     * Saves the players current location, health, inventory, motion, and
+     * other information into the username.dat file, in the world/player
+     * folder
+     */
+    public void saveData();
+
+    /**
+     * Loads the players current location, health, inventory, motion, and
+     * other information from the username.dat file, in the world/player
+     * folder.
+     * <p>
+     * Note: This will overwrite the players current inventory, health,
+     * motion, etc, with the state from the saved dat file.
+     */
+    public void loadData();
+
+    /**
+     * Sets whether the player is ignored as not sleeping. If everyone is
+     * either sleeping or has this flag set, then time will advance to the
+     * next day. If everyone has this flag set but no one is actually in bed,
+     * then nothing will happen.
+     *
+     * @param isSleeping Whether to ignore.
+     */
+    public void setSleepingIgnored(boolean isSleeping);
+
+    /**
+     * Returns whether the player is sleeping ignored.
+     *
+     * @return Whether player is ignoring sleep.
+     */
+    public boolean isSleepingIgnored();
+
+    /**
+     * Play a note for a player at a location. This requires a note block
+     * at the particular location (as far as the client is concerned). This
+     * will not work without a note block. This will not work with cake.
+     *
+     * @param loc The location of a note block.
+     * @param instrument The instrument ID.
+     * @param note The note ID.
+     * @deprecated Magic value
+     */
+    @Deprecated
+    public void playNote(Location loc, byte instrument, byte note);
+
+    /**
+     * Play a note for a player at a location. This requires a note block
+     * at the particular location (as far as the client is concerned). This
+     * will not work without a note block. This will not work with cake.
+     *
+     * @param loc The location of a note block
+     * @param instrument The instrument
+     * @param note The note
+     */
+    public void playNote(Location loc, Instrument instrument, Note note);
+
+
+    /**
+     * Play a sound for a player at the location.
+     * <p>
+     * This function will fail silently if Location or Sound are null.
+     *
+     * @param location The location to play the sound
+     * @param sound The sound to play
+     * @param volume The volume of the sound
+     * @param pitch The pitch of the sound
+     */
+    public void playSound(Location location, Sound sound, float volume, float pitch);
+
+    /**
+     * Play a sound for a player at the location.
+     * <p>
+     * This function will fail silently if Location or Sound are null. No
+     * sound will be heard by the player if their client does not have the
+     * respective sound for the value passed.
+     *
+     * @param location the location to play the sound
+     * @param sound the internal sound name to play
+     * @param volume the volume of the sound
+     * @param pitch the pitch of the sound
+     */
+    public void playSound(Location location, String sound, float volume, float pitch);
+
+    /**
+     * Plays an effect to just this player.
+     *
+     * @param loc the location to play the effect at
+     * @param effect the {@link Effect}
+     * @param data a data bit needed for some effects
+     * @deprecated Magic value
+     */
+    @Deprecated
+    public void playEffect(Location loc, Effect effect, int data);
+
+    /**
+     * Plays an effect to just this player.
+     *
+     * @param <T> the data based based on the type of the effect
+     * @param loc the location to play the effect at
+     * @param effect the {@link Effect}
+     * @param data a data bit needed for some effects
+     */
+    public <T> void playEffect(Location loc, Effect effect, T data);
+
+    /**
+     * Send a block change. This fakes a block change packet for a user at a
+     * certain location. This will not actually change the world in any way.
+     *
+     * @param loc The location of the changed block
+     * @param material The new block
+     * @param data The block data
+     * @deprecated Magic value
+     */
+    @Deprecated
+    public void sendBlockChange(Location loc, Material material, byte data);
+
+    /**
+     * Send a chunk change. This fakes a chunk change packet for a user at a
+     * certain location. The updated cuboid must be entirely within a single
+     * chunk. This will not actually change the world in any way.
+     * <p>
+     * At least one of the dimensions of the cuboid must be even. The size of
+     * the data buffer must be 2.5*sx*sy*sz and formatted in accordance with
+     * the Packet51 format.
+     *
+     * @param loc The location of the cuboid
+     * @param sx The x size of the cuboid
+     * @param sy The y size of the cuboid
+     * @param sz The z size of the cuboid
+     * @param data The data to be sent
+     * @return true if the chunk change packet was sent
+     * @deprecated Magic value
+     */
+    @Deprecated
+    public boolean sendChunkChange(Location loc, int sx, int sy, int sz, byte[] data);
+
+    /**
+     * Send a block change. This fakes a block change packet for a user at a
+     * certain location. This will not actually change the world in any way.
+     *
+     * @param loc The location of the changed block
+     * @param material The new block ID
+     * @param data The block data
+     * @deprecated Magic value
+     */
+    @Deprecated
+    public void sendBlockChange(Location loc, int material, byte data);
+
+    /**
+     * Send a sign change. This fakes a sign change packet for a user at
+     * a certain location. This will not actually change the world in any way.
+     * This method will use a sign at the location's block or a faked sign
+     * sent via {@link #sendBlockChange(org.bukkit.Location, int, byte)} or
+     * {@link #sendBlockChange(org.bukkit.Location, org.bukkit.Material, byte)}.
+     * <p>
+     * If the client does not have a sign at the given location it will
+     * display an error message to the user.
+     *
+     * @param loc the location of the sign
+     * @param lines the new text on the sign or null to clear it
+     * @throws IllegalArgumentException if location is null
+     * @throws IllegalArgumentException if lines is non-null and has a length less than 4
+     */
+    public void sendSignChange(Location loc, String[] lines) throws IllegalArgumentException;
+
+    /**
+     * Render a map and send it to the player in its entirety. This may be
+     * used when streaming the map in the normal manner is not desirable.
+     *
+     * @param map The map to be sent
+     */
+    public void sendMap(MapView map);
+
+    // Paper start
+    /**
+     * Sends the component to the player
+     *
+     * @param component the components to send
+     */
+    @Override
+    public void sendMessage(net.md_5.bungee.api.chat.BaseComponent component);
+
+    /**
+     * Sends an array of components as a single message to the player
+     *
+     * @param components the components to send
+     */
+    @Override
+    public void sendMessage(net.md_5.bungee.api.chat.BaseComponent... components);
+
+    /**
+     * Sends an array of components as a single message to the specified screen position of this player
+     *
+     * @param position the screen position
+     * @param components the components to send
+     */
+    public void sendMessage(net.md_5.bungee.api.ChatMessageType position, net.md_5.bungee.api.chat.BaseComponent... components);
+
+    /**
+     * Set the text displayed in the player list header and footer for this player
+     *
+     * @param header content for the top of the player list
+     * @param footer content for the bottom of the player list
+     */
+    public void setPlayerListHeaderFooter(net.md_5.bungee.api.chat.BaseComponent[] header, net.md_5.bungee.api.chat.BaseComponent[] footer);
+
+    /**
+     * Set the text displayed in the player list header and footer for this player
+     *
+     * @param header content for the top of the player list
+     * @param footer content for the bottom of the player list
+     */
+    public void setPlayerListHeaderFooter(net.md_5.bungee.api.chat.BaseComponent header, net.md_5.bungee.api.chat.BaseComponent footer);
+
+    /**
+     * Update the times for titles displayed to the player
+     *
+     * @param fadeInTicks  ticks to fade-in
+     * @param stayTicks    ticks to stay visible
+     * @param fadeOutTicks ticks to fade-out
+     * @deprecated Use {@link #updateTitle(Title)}
+     */
+    @Deprecated
+    public void setTitleTimes(int fadeInTicks, int stayTicks, int fadeOutTicks);
+
+    /**
+     * Update the subtitle of titles displayed to the player
+     *
+     * @deprecated Use {@link #updateTitle(Title)}
+     */
+    @Deprecated
+    public void setSubtitle(net.md_5.bungee.api.chat.BaseComponent[] subtitle);
+
+    /**
+     * Update the subtitle of titles displayed to the player
+     *
+     * @deprecated Use {@link #updateTitle(Title)}
+     */
+    @Deprecated
+    public void setSubtitle(net.md_5.bungee.api.chat.BaseComponent subtitle);
+
+    /**
+     * Show the given title to the player, along with the last subtitle set, using the last set times
+     *
+     * @deprecated Use {@link #sendTitle(Title)} or {@link #updateTitle(Title)}
+     */
+    @Deprecated
+    public void showTitle(net.md_5.bungee.api.chat.BaseComponent[] title);
+
+    /**
+     * Show the given title to the player, along with the last subtitle set, using the last set times
+     *
+     * @deprecated Use {@link #sendTitle(Title)} or {@link #updateTitle(Title)}
+     */
+    @Deprecated
+    public void showTitle(net.md_5.bungee.api.chat.BaseComponent title);
+
+    /**
+     * Show the given title and subtitle to the player using the given times
+     *
+     * @param title        big text
+     * @param subtitle     little text under it
+     * @param fadeInTicks  ticks to fade-in
+     * @param stayTicks    ticks to stay visible
+     * @param fadeOutTicks ticks to fade-out
+     * @deprecated Use {@link #sendTitle(Title)} or {@link #updateTitle(Title)}
+     */
+    @Deprecated
+    public void showTitle(net.md_5.bungee.api.chat.BaseComponent[] title, net.md_5.bungee.api.chat.BaseComponent[] subtitle, int fadeInTicks, int stayTicks, int fadeOutTicks);
+
+    /**
+     * Show the given title and subtitle to the player using the given times
+     *
+     * @param title        big text
+     * @param subtitle     little text under it
+     * @param fadeInTicks  ticks to fade-in
+     * @param stayTicks    ticks to stay visible
+     * @param fadeOutTicks ticks to fade-out
+     * @deprecated Use {@link #sendTitle(Title)} or {@link #updateTitle(Title)}
+     */
+    @Deprecated
+    public void showTitle(net.md_5.bungee.api.chat.BaseComponent title, net.md_5.bungee.api.chat.BaseComponent subtitle, int fadeInTicks, int stayTicks, int fadeOutTicks);
+
+    /**
+     * Show the title to the player, overriding any previously displayed title.
+     * <p>
+     * <p>This method overrides any previous title, use {@link #updateTitle(Title)} to change the existing one.</p>
+     *
+     * @param title the title to send
+     * @throws NullPointerException if the title is null
+     */
+    void sendTitle(Title title);
+
+    /**
+     * Show the title to the player, overriding any previously displayed title.
+     * <p>
+     * <p>This method doesn't override previous titles, but changes their values.</p>
+     *
+     * @param title the title to send
+     * @throws NullPointerException if title is null
+     */
+    void updateTitle(Title title);
+
+    /**
+     * Hide any title that is currently visible to the player
+     */
+    public void hideTitle();
+    // Paper end
+
+    /**
+     * Forces an update of the player's entire inventory.
+     *
+     */
+    //@Deprecated // Spigot - undeprecate
+    public void updateInventory();
+
+    /**
+     * Awards the given achievement and any parent achievements that the
+     * player does not have.
+     *
+     * @param achievement Achievement to award
+     * @throws IllegalArgumentException if achievement is null
+     */
+    public void awardAchievement(Achievement achievement);
+
+    /**
+     * Removes the given achievement and any children achievements that the
+     * player has.
+     *
+     * @param achievement Achievement to remove
+     * @throws IllegalArgumentException if achievement is null
+     */
+    public void removeAchievement(Achievement achievement);
+
+    /**
+     * Gets whether this player has the given achievement.
+     *
+     * @param achievement the achievement to check
+     * @return whether the player has the achievement
+     * @throws IllegalArgumentException if achievement is null
+     */
+    public boolean hasAchievement(Achievement achievement);
+
+    /**
+     * Increments the given statistic for this player.
+     * <p>
+     * This is equivalent to the following code:
+     * <code>incrementStatistic(Statistic, 1)</code>
+     *
+     * @param statistic Statistic to increment
+     * @throws IllegalArgumentException if statistic is null
+     * @throws IllegalArgumentException if the statistic requires an
+     *     additional parameter
+     */
+    public void incrementStatistic(Statistic statistic) throws IllegalArgumentException;
+
+    /**
+     * Decrements the given statistic for this player.
+     * <p>
+     * This is equivalent to the following code:
+     * <code>decrementStatistic(Statistic, 1)</code>
+     *
+     * @param statistic Statistic to decrement
+     * @throws IllegalArgumentException if statistic is null
+     * @throws IllegalArgumentException if the statistic requires an
+     *     additional parameter
+     */
+    public void decrementStatistic(Statistic statistic) throws IllegalArgumentException;
+
+    /**
+     * Increments the given statistic for this player.
+     *
+     * @param statistic Statistic to increment
+     * @param amount Amount to increment this statistic by
+     * @throws IllegalArgumentException if statistic is null
+     * @throws IllegalArgumentException if amount is negative
+     * @throws IllegalArgumentException if the statistic requires an
+     *     additional parameter
+     */
+    public void incrementStatistic(Statistic statistic, int amount) throws IllegalArgumentException;
+
+    /**
+     * Decrements the given statistic for this player.
+     *
+     * @param statistic Statistic to decrement
+     * @param amount Amount to decrement this statistic by
+     * @throws IllegalArgumentException if statistic is null
+     * @throws IllegalArgumentException if amount is negative
+     * @throws IllegalArgumentException if the statistic requires an
+     *     additional parameter
+     */
+    public void decrementStatistic(Statistic statistic, int amount) throws IllegalArgumentException;
+
+    /**
+     * Sets the given statistic for this player.
+     *
+     * @param statistic Statistic to set
+     * @param newValue The value to set this statistic to
+     * @throws IllegalArgumentException if statistic is null
+     * @throws IllegalArgumentException if newValue is negative
+     * @throws IllegalArgumentException if the statistic requires an
+     *     additional parameter
+     */
+    public void setStatistic(Statistic statistic, int newValue) throws IllegalArgumentException;
+
+    /**
+     * Gets the value of the given statistic for this player.
+     *
+     * @param statistic Statistic to check
+     * @return the value of the given statistic
+     * @throws IllegalArgumentException if statistic is null
+     * @throws IllegalArgumentException if the statistic requires an
+     *     additional parameter
+     */
+    public int getStatistic(Statistic statistic) throws IllegalArgumentException;
+
+    /**
+     * Increments the given statistic for this player for the given material.
+     * <p>
+     * This is equivalent to the following code:
+     * <code>incrementStatistic(Statistic, Material, 1)</code>
+     *
+     * @param statistic Statistic to increment
+     * @param material Material to offset the statistic with
+     * @throws IllegalArgumentException if statistic is null
+     * @throws IllegalArgumentException if material is null
+     * @throws IllegalArgumentException if the given parameter is not valid
+     *     for the statistic
+     */
+    public void incrementStatistic(Statistic statistic, Material material) throws IllegalArgumentException;
+
+    /**
+     * Decrements the given statistic for this player for the given material.
+     * <p>
+     * This is equivalent to the following code:
+     * <code>decrementStatistic(Statistic, Material, 1)</code>
+     *
+     * @param statistic Statistic to decrement
+     * @param material Material to offset the statistic with
+     * @throws IllegalArgumentException if statistic is null
+     * @throws IllegalArgumentException if material is null
+     * @throws IllegalArgumentException if the given parameter is not valid
+     *     for the statistic
+     */
+    public void decrementStatistic(Statistic statistic, Material material) throws IllegalArgumentException;
+
+    /**
+     * Gets the value of the given statistic for this player.
+     *
+     * @param statistic Statistic to check
+     * @param material Material offset of the statistic
+     * @return the value of the given statistic
+     * @throws IllegalArgumentException if statistic is null
+     * @throws IllegalArgumentException if material is null
+     * @throws IllegalArgumentException if the given parameter is not valid
+     *     for the statistic
+     */
+    public int getStatistic(Statistic statistic, Material material) throws IllegalArgumentException;
+
+    /**
+     * Increments the given statistic for this player for the given material.
+     *
+     * @param statistic Statistic to increment
+     * @param material Material to offset the statistic with
+     * @param amount Amount to increment this statistic by
+     * @throws IllegalArgumentException if statistic is null
+     * @throws IllegalArgumentException if material is null
+     * @throws IllegalArgumentException if amount is negative
+     * @throws IllegalArgumentException if the given parameter is not valid
+     *     for the statistic
+     */
+    public void incrementStatistic(Statistic statistic, Material material, int amount) throws IllegalArgumentException;
+
+    /**
+     * Decrements the given statistic for this player for the given material.
+     *
+     * @param statistic Statistic to decrement
+     * @param material Material to offset the statistic with
+     * @param amount Amount to decrement this statistic by
+     * @throws IllegalArgumentException if statistic is null
+     * @throws IllegalArgumentException if material is null
+     * @throws IllegalArgumentException if amount is negative
+     * @throws IllegalArgumentException if the given parameter is not valid
+     *     for the statistic
+     */
+    public void decrementStatistic(Statistic statistic, Material material, int amount) throws IllegalArgumentException;
+
+    /**
+     * Sets the given statistic for this player for the given material.
+     *
+     * @param statistic Statistic to set
+     * @param material Material to offset the statistic with
+     * @param newValue The value to set this statistic to
+     * @throws IllegalArgumentException if statistic is null
+     * @throws IllegalArgumentException if material is null
+     * @throws IllegalArgumentException if newValue is negative
+     * @throws IllegalArgumentException if the given parameter is not valid
+     *     for the statistic
+     */
+    public void setStatistic(Statistic statistic, Material material, int newValue) throws IllegalArgumentException;
+
+    /**
+     * Increments the given statistic for this player for the given entity.
+     * <p>
+     * This is equivalent to the following code:
+     * <code>incrementStatistic(Statistic, EntityType, 1)</code>
+     *
+     * @param statistic Statistic to increment
+     * @param entityType EntityType to offset the statistic with
+     * @throws IllegalArgumentException if statistic is null
+     * @throws IllegalArgumentException if entityType is null
+     * @throws IllegalArgumentException if the given parameter is not valid
+     *     for the statistic
+     */
+    public void incrementStatistic(Statistic statistic, EntityType entityType) throws IllegalArgumentException;
+
+    /**
+     * Decrements the given statistic for this player for the given entity.
+     * <p>
+     * This is equivalent to the following code:
+     * <code>decrementStatistic(Statistic, EntityType, 1)</code>
+     *
+     * @param statistic Statistic to decrement
+     * @param entityType EntityType to offset the statistic with
+     * @throws IllegalArgumentException if statistic is null
+     * @throws IllegalArgumentException if entityType is null
+     * @throws IllegalArgumentException if the given parameter is not valid
+     *     for the statistic
+     */
+    public void decrementStatistic(Statistic statistic, EntityType entityType) throws IllegalArgumentException;
+
+    /**
+     * Gets the value of the given statistic for this player.
+     *
+     * @param statistic Statistic to check
+     * @param entityType EntityType offset of the statistic
+     * @return the value of the given statistic
+     * @throws IllegalArgumentException if statistic is null
+     * @throws IllegalArgumentException if entityType is null
+     * @throws IllegalArgumentException if the given parameter is not valid
+     *     for the statistic
+     */
+    public int getStatistic(Statistic statistic, EntityType entityType) throws IllegalArgumentException;
+
+    /**
+     * Increments the given statistic for this player for the given entity.
+     *
+     * @param statistic Statistic to increment
+     * @param entityType EntityType to offset the statistic with
+     * @param amount Amount to increment this statistic by
+     * @throws IllegalArgumentException if statistic is null
+     * @throws IllegalArgumentException if entityType is null
+     * @throws IllegalArgumentException if amount is negative
+     * @throws IllegalArgumentException if the given parameter is not valid
+     *     for the statistic
+     */
+    public void incrementStatistic(Statistic statistic, EntityType entityType, int amount) throws IllegalArgumentException;
+
+    /**
+     * Decrements the given statistic for this player for the given entity.
+     *
+     * @param statistic Statistic to decrement
+     * @param entityType EntityType to offset the statistic with
+     * @param amount Amount to decrement this statistic by
+     * @throws IllegalArgumentException if statistic is null
+     * @throws IllegalArgumentException if entityType is null
+     * @throws IllegalArgumentException if amount is negative
+     * @throws IllegalArgumentException if the given parameter is not valid
+     *     for the statistic
+     */
+    public void decrementStatistic(Statistic statistic, EntityType entityType, int amount);
+
+    /**
+     * Sets the given statistic for this player for the given entity.
+     *
+     * @param statistic Statistic to set
+     * @param entityType EntityType to offset the statistic with
+     * @param newValue The value to set this statistic to
+     * @throws IllegalArgumentException if statistic is null
+     * @throws IllegalArgumentException if entityType is null
+     * @throws IllegalArgumentException if newValue is negative
+     * @throws IllegalArgumentException if the given parameter is not valid
+     *     for the statistic
+     */
+    public void setStatistic(Statistic statistic, EntityType entityType, int newValue);
+
+    /**
+     * Sets the current time on the player's client. When relative is true the
+     * player's time will be kept synchronized to its world time with the
+     * specified offset.
+     * <p>
+     * When using non relative time the player's time will stay fixed at the
+     * specified time parameter. It's up to the caller to continue updating
+     * the player's time. To restore player time to normal use
+     * resetPlayerTime().
+     *
+     * @param time The current player's perceived time or the player's time
+     *     offset from the server time.
+     * @param relative When true the player time is kept relative to its world
+     *     time.
+     */
+    public void setPlayerTime(long time, boolean relative);
+
+    /**
+     * Returns the player's current timestamp.
+     *
+     * @return The player's time
+     */
+    public long getPlayerTime();
+
+    /**
+     * Returns the player's current time offset relative to server time, or
+     * the current player's fixed time if the player's time is absolute.
+     *
+     * @return The player's time
+     */
+    public long getPlayerTimeOffset();
+
+    /**
+     * Returns true if the player's time is relative to the server time,
+     * otherwise the player's time is absolute and will not change its current
+     * time unless done so with setPlayerTime().
+     *
+     * @return true if the player's time is relative to the server time.
+     */
+    public boolean isPlayerTimeRelative();
+
+    /**
+     * Restores the normal condition where the player's time is synchronized
+     * with the server time.
+     * <p>
+     * Equivalent to calling setPlayerTime(0, true).
+     */
+    public void resetPlayerTime();
+
+    /**
+     * Sets the type of weather the player will see.  When used, the weather
+     * status of the player is locked until {@link #resetPlayerWeather()} is
+     * used.
+     *
+     * @param type The WeatherType enum type the player should experience
+     */
+    public void setPlayerWeather(WeatherType type);
+
+    /**
+     * Returns the type of weather the player is currently experiencing.
+     *
+     * @return The WeatherType that the player is currently experiencing or
+     *     null if player is seeing server weather.
+     */
+    public WeatherType getPlayerWeather();
+
+    /**
+     * Restores the normal condition where the player's weather is controlled
+     * by server conditions.
+     */
+    public void resetPlayerWeather();
+
+    /**
+     * Gives the player the amount of experience specified.
+     *
+     * @param amount Exp amount to give
+     */
+    public void giveExp(int amount);
+
+    /**
+     * Gives the player the amount of experience levels specified. Levels can
+     * be taken by specifying a negative amount.
+     *
+     * @param amount amount of experience levels to give or take
+     */
+    public void giveExpLevels(int amount);
+
+    /**
+     * Gets the players current experience points towards the next level.
+     * <p>
+     * This is a percentage value. 0 is "no progress" and 1 is "next level".
+     *
+     * @return Current experience points
+     */
+    public float getExp();
+
+    /**
+     * Sets the players current experience points towards the next level
+     * <p>
+     * This is a percentage value. 0 is "no progress" and 1 is "next level".
+     *
+     * @param exp New experience points
+     */
+    public void setExp(float exp);
+
+    /**
+     * Gets the players current experience level
+     *
+     * @return Current experience level
+     */
+    public int getLevel();
+
+    /**
+     * Sets the players current experience level
+     *
+     * @param level New experience level
+     */
+    public void setLevel(int level);
+
+    /**
+     * Gets the players total experience points
+     *
+     * @return Current total experience points
+     */
+    public int getTotalExperience();
+
+    /**
+     * Sets the players current experience level
+     *
+     * @param exp New experience level
+     */
+    public void setTotalExperience(int exp);
+
+    /**
+     * Gets the players current exhaustion level.
+     * <p>
+     * Exhaustion controls how fast the food level drops. While you have a
+     * certain amount of exhaustion, your saturation will drop to zero, and
+     * then your food will drop to zero.
+     *
+     * @return Exhaustion level
+     */
+    public float getExhaustion();
+
+    /**
+     * Sets the players current exhaustion level
+     *
+     * @param value Exhaustion level
+     */
+    public void setExhaustion(float value);
+
+    /**
+     * Gets the players current saturation level.
+     * <p>
+     * Saturation is a buffer for food level. Your food level will not drop if
+     * you are saturated {@literal >} 0.
+     *
+     * @return Saturation level
+     */
+    public float getSaturation();
+
+    /**
+     * Sets the players current saturation level
+     *
+     * @param value Saturation level
+     */
+    public void setSaturation(float value);
+
+    /**
+     * Gets the players current food level
+     *
+     * @return Food level
+     */
+    public int getFoodLevel();
+
+    /**
+     * Sets the players current food level
+     *
+     * @param value New food level
+     */
+    public void setFoodLevel(int value);
+
+    /**
+     * Gets the Location where the player will spawn at their bed, null if
+     * they have not slept in one or their current bed spawn is invalid.
+     *
+     * @return Bed Spawn Location if bed exists, otherwise null.
+     */
+    public Location getBedSpawnLocation();
+
+    /**
+     * Sets the Location where the player will spawn at their bed.
+     *
+     * @param location where to set the respawn location
+     */
+    public void setBedSpawnLocation(Location location);
+
+    /**
+     * Sets the Location where the player will spawn at their bed.
+     *
+     * @param location where to set the respawn location
+     * @param force whether to forcefully set the respawn location even if a
+     *     valid bed is not present
+     */
+    public void setBedSpawnLocation(Location location, boolean force);
+
+    /**
+     * Determines if the Player is allowed to fly via jump key double-tap like
+     * in creative mode.
+     *
+     * @return True if the player is allowed to fly.
+     */
+    public boolean getAllowFlight();
+
+    /**
+     * Sets if the Player is allowed to fly via jump key double-tap like in
+     * creative mode.
+     *
+     * @param flight If flight should be allowed.
+     */
+    public void setAllowFlight(boolean flight);
+
+    /**
+     * Hides a player from this player
+     *
+     * @param player Player to hide
+     */
+    public void hidePlayer(Player player);
+
+    /**
+     * Allows this player to see a player that was previously hidden
+     *
+     * @param player Player to show
+     */
+    public void showPlayer(Player player);
+
+    /**
+     * Checks to see if a player has been hidden from this player
+     *
+     * @param player Player to check
+     * @return True if the provided player is not being hidden from this
+     *     player
+     */
+    public boolean canSee(Player player);
+
+    /**
+     * Checks to see if this player is currently standing on a block. This
+     * information may not be reliable, as it is a state provided by the
+     * client, and may therefore not be accurate.
+     *
+     * @return True if the player standing on a solid block, else false.
+     * @deprecated Inconsistent with {@link
+     *     org.bukkit.entity.Entity#isOnGround()}
+     */
+    @Deprecated
+    public boolean isOnGround();
+
+    /**
+     * Checks to see if this player is currently flying or not.
+     *
+     * @return True if the player is flying, else false.
+     */
+    public boolean isFlying();
+
+    /**
+     * Makes this player start or stop flying.
+     *
+     * @param value True to fly.
+     */
+    public void setFlying(boolean value);
+
+    /**
+     * Sets the speed at which a client will fly. Negative values indicate
+     * reverse directions.
+     *
+     * @param value The new speed, from -1 to 1.
+     * @throws IllegalArgumentException If new speed is less than -1 or
+     *     greater than 1
+     */
+    public void setFlySpeed(float value) throws IllegalArgumentException;
+
+    /**
+     * Sets the speed at which a client will walk. Negative values indicate
+     * reverse directions.
+     *
+     * @param value The new speed, from -1 to 1.
+     * @throws IllegalArgumentException If new speed is less than -1 or
+     *     greater than 1
+     */
+    public void setWalkSpeed(float value) throws IllegalArgumentException;
+
+    /**
+     * Gets the current allowed speed that a client can fly.
+     *
+     * @return The current allowed speed, from -1 to 1
+     */
+    public float getFlySpeed();
+
+    /**
+     * Gets the current allowed speed that a client can walk.
+     *
+     * @return The current allowed speed, from -1 to 1
+     */
+    public float getWalkSpeed();
+
+    /**
+     * Request that the player's client download and switch texture packs.
+     * <p>
+     * The player's client will download the new texture pack asynchronously
+     * in the background, and will automatically switch to it once the
+     * download is complete. If the client has downloaded and cached the same
+     * texture pack in the past, it will perform a quick timestamp check over
+     * the network to determine if the texture pack has changed and needs to
+     * be downloaded again. When this request is sent for the very first time
+     * from a given server, the client will first display a confirmation GUI
+     * to the player before proceeding with the download.
+     * <p>
+     * Notes:
+     * <ul>
+     * <li>Players can disable server textures on their client, in which
+     *     case this method will have no affect on them.
+     * <li>There is no concept of resetting texture packs back to default
+     *     within Minecraft, so players will have to relog to do so.
+     * </ul>
+     *
+     * @param url The URL from which the client will download the texture
+     *     pack. The string must contain only US-ASCII characters and should
+     *     be encoded as per RFC 1738.
+     * @throws IllegalArgumentException Thrown if the URL is null.
+     * @throws IllegalArgumentException Thrown if the URL is too long.
+     * @deprecated Minecraft no longer uses textures packs. Instead you
+     *     should use {@link #setResourcePack(String)}.
+     */
+    @Deprecated
+    public void setTexturePack(String url);
+
+    /**
+     * Request that the player's client download and switch resource packs.
+     * <p>
+     * The player's client will download the new resource pack asynchronously
+     * in the background, and will automatically switch to it once the
+     * download is complete. If the client has downloaded and cached the same
+     * resource pack in the past, it will perform a quick timestamp check
+     * over the network to determine if the resource pack has changed and
+     * needs to be downloaded again. When this request is sent for the very
+     * first time from a given server, the client will first display a
+     * confirmation GUI to the player before proceeding with the download.
+     * <p>
+     * Notes:
+     * <ul>
+     * <li>Players can disable server resources on their client, in which
+     *     case this method will have no affect on them.
+     * <li>There is no concept of resetting resource packs back to default
+     *     within Minecraft, so players will have to relog to do so.
+     * </ul>
+     *
+     * @param url The URL from which the client will download the resource
+     *     pack. The string must contain only US-ASCII characters and should
+     *     be encoded as per RFC 1738.
+     * @throws IllegalArgumentException Thrown if the URL is null.
+     * @throws IllegalArgumentException Thrown if the URL is too long. The
+     *     length restriction is an implementation specific arbitrary value.
+     * @deprecated use {@link #setResourcePack(String, String)}
+     */
+    @Deprecated // Paper
+    public void setResourcePack(String url);
+
+    /**
+     * Gets the Scoreboard displayed to this player
+     *
+     * @return The current scoreboard seen by this player
+     */
+    public Scoreboard getScoreboard();
+
+    /**
+     * Sets the player's visible Scoreboard.
+     *
+     * @param scoreboard New Scoreboard for the player
+     * @throws IllegalArgumentException if scoreboard is null
+     * @throws IllegalArgumentException if scoreboard was not created by the
+     *     {@link org.bukkit.scoreboard.ScoreboardManager scoreboard manager}
+     * @throws IllegalStateException if this is a player that is not logged
+     *     yet or has logged out
+     */
+    public void setScoreboard(Scoreboard scoreboard) throws IllegalArgumentException, IllegalStateException;
+
+    /**
+     * Gets if the client is displayed a 'scaled' health, that is, health on a
+     * scale from 0-{@link #getHealthScale()}.
+     *
+     * @return if client health display is scaled
+     * @see Player#setHealthScaled(boolean)
+     */
+    public boolean isHealthScaled();
+
+    /**
+     * Sets if the client is displayed a 'scaled' health, that is, health on a
+     * scale from 0-{@link #getHealthScale()}.
+     * <p>
+     * Displayed health follows a simple formula <code>displayedHealth =
+     * getHealth() / getMaxHealth() * getHealthScale()</code>.
+     *
+     * @param scale if the client health display is scaled
+     */
+    public void setHealthScaled(boolean scale);
+
+    /**
+     * Sets the number to scale health to for the client; this will also
+     * {@link #setHealthScaled(boolean) setHealthScaled(true)}.
+     * <p>
+     * Displayed health follows a simple formula <code>displayedHealth =
+     * getHealth() / getMaxHealth() * getHealthScale()</code>.
+     *
+     * @param scale the number to scale health to
+     * @throws IllegalArgumentException if scale is &lt;0
+     * @throws IllegalArgumentException if scale is {@link Double#NaN}
+     * @throws IllegalArgumentException if scale is too high
+     */
+    public void setHealthScale(double scale) throws IllegalArgumentException;
+
+    /**
+     * Gets the number that health is scaled to for the client.
+     *
+     * @return the number that health would be scaled to for the client if
+     *     HealthScaling is set to true
+     * @see Player#setHealthScale(double)
+     * @see Player#setHealthScaled(boolean)
+     */
+    public double getHealthScale();
+
+    /**
+     * Gets the entity which is followed by the camera when in
+     * {@link GameMode#SPECTATOR}.
+     *
+     * @return the followed entity, or null if not in spectator mode or not
+     * following a specific entity.
+     */
+    public Entity getSpectatorTarget();
+
+    /**
+     * Sets the entity which is followed by the camera when in
+     * {@link GameMode#SPECTATOR}.
+     *
+     * @param entity the entity to follow or null to reset
+     * @throws IllegalStateException if the player is not in
+     * {@link GameMode#SPECTATOR}
+     */
+    public void setSpectatorTarget(Entity entity);
+
+    /**
+     * Sends a title and a subtitle message to the player. If either of these
+     * values are null, they will not be sent and the display will remain
+     * unchanged. If they are empty strings, the display will be updated as
+     * such. If the strings contain a new line, only the first line will be
+     * sent.
+     *
+     * @param title Title text
+     * @param subtitle Subtitle text
+     * @deprecated API subject to change
+     */
+    @Deprecated
+    public void sendTitle(String title, String subtitle);
+
+    /**
+     * Resets the title displayed to the player.
+     * @deprecated API subject to change.
+     */
+    // Paper - undeprecate
+    public void resetTitle();
+
+
+    /**
+     * Spawns the particle (the number of times specified by count)
+     * at the target location.
+     *
+     * @param particle the particle to spawn
+     * @param location the location to spawn at
+     * @param count the number of particles
+     */
+    public void spawnParticle(Particle particle, Location location, int count);
+
+    /**
+     * Spawns the particle (the number of times specified by count)
+     * at the target location.
+     *
+     * @param particle the particle to spawn
+     * @param x the position on the x axis to spawn at
+     * @param y the position on the y axis to spawn at
+     * @param z the position on the z axis to spawn at
+     * @param count the number of particles
+     */
+    public void spawnParticle(Particle particle, double x, double y, double z, int count);
+
+    /**
+     * Spawns the particle (the number of times specified by count)
+     * at the target location.
+     *
+     * @param particle the particle to spawn
+     * @param location the location to spawn at
+     * @param count the number of particles
+     * @param data the data to use for the particle or null,
+     *             the type of this depends on {@link Particle#getDataType()}
+     */
+    public <T> void spawnParticle(Particle particle, Location location, int count, T data);
+
+
+    /**
+     * Spawns the particle (the number of times specified by count)
+     * at the target location.
+     *
+     * @param particle the particle to spawn
+     * @param x the position on the x axis to spawn at
+     * @param y the position on the y axis to spawn at
+     * @param z the position on the z axis to spawn at
+     * @param count the number of particles
+     * @param data the data to use for the particle or null,
+     *             the type of this depends on {@link Particle#getDataType()}
+     */
+    public <T> void spawnParticle(Particle particle, double x, double y, double z, int count, T data);
+
+    /**
+     * Spawns the particle (the number of times specified by count)
+     * at the target location. The position of each particle will be
+     * randomized positively and negatively by the offset parameters
+     * on each axis.
+     *
+     * @param particle the particle to spawn
+     * @param location the location to spawn at
+     * @param count the number of particles
+     * @param offsetX the maximum random offset on the X axis
+     * @param offsetY the maximum random offset on the Y axis
+     * @param offsetZ the maximum random offset on the Z axis
+     */
+    public void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ);
+
+    /**
+     * Spawns the particle (the number of times specified by count)
+     * at the target location. The position of each particle will be
+     * randomized positively and negatively by the offset parameters
+     * on each axis.
+     *
+     * @param particle the particle to spawn
+     * @param x the position on the x axis to spawn at
+     * @param y the position on the y axis to spawn at
+     * @param z the position on the z axis to spawn at
+     * @param count the number of particles
+     * @param offsetX the maximum random offset on the X axis
+     * @param offsetY the maximum random offset on the Y axis
+     * @param offsetZ the maximum random offset on the Z axis
+     */
+    public void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ);
+
+    /**
+     * Spawns the particle (the number of times specified by count)
+     * at the target location. The position of each particle will be
+     * randomized positively and negatively by the offset parameters
+     * on each axis.
+     *
+     * @param particle the particle to spawn
+     * @param location the location to spawn at
+     * @param count the number of particles
+     * @param offsetX the maximum random offset on the X axis
+     * @param offsetY the maximum random offset on the Y axis
+     * @param offsetZ the maximum random offset on the Z axis
+     * @param data the data to use for the particle or null,
+     *             the type of this depends on {@link Particle#getDataType()}
+     */
+    public <T> void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ, T data);
+
+    /**
+     * Spawns the particle (the number of times specified by count)
+     * at the target location. The position of each particle will be
+     * randomized positively and negatively by the offset parameters
+     * on each axis.
+     *
+     * @param particle the particle to spawn
+     * @param x the position on the x axis to spawn at
+     * @param y the position on the y axis to spawn at
+     * @param z the position on the z axis to spawn at
+     * @param count the number of particles
+     * @param offsetX the maximum random offset on the X axis
+     * @param offsetY the maximum random offset on the Y axis
+     * @param offsetZ the maximum random offset on the Z axis
+     * @param data the data to use for the particle or null,
+     *             the type of this depends on {@link Particle#getDataType()}
+     */
+    public <T> void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ, T data);
+
+    /**
+     * Spawns the particle (the number of times specified by count)
+     * at the target location. The position of each particle will be
+     * randomized positively and negatively by the offset parameters
+     * on each axis.
+     *
+     * @param particle the particle to spawn
+     * @param location the location to spawn at
+     * @param count the number of particles
+     * @param offsetX the maximum random offset on the X axis
+     * @param offsetY the maximum random offset on the Y axis
+     * @param offsetZ the maximum random offset on the Z axis
+     * @param extra the extra data for this particle, depends on the
+     *              particle used (normally speed)
+     */
+    public void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ, double extra);
+
+    /**
+     * Spawns the particle (the number of times specified by count)
+     * at the target location. The position of each particle will be
+     * randomized positively and negatively by the offset parameters
+     * on each axis.
+     *
+     * @param particle the particle to spawn
+     * @param x the position on the x axis to spawn at
+     * @param y the position on the y axis to spawn at
+     * @param z the position on the z axis to spawn at
+     * @param count the number of particles
+     * @param offsetX the maximum random offset on the X axis
+     * @param offsetY the maximum random offset on the Y axis
+     * @param offsetZ the maximum random offset on the Z axis
+     * @param extra the extra data for this particle, depends on the
+     *              particle used (normally speed)
+     */
+    public void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ, double extra);
+
+    /**
+     * Spawns the particle (the number of times specified by count)
+     * at the target location. The position of each particle will be
+     * randomized positively and negatively by the offset parameters
+     * on each axis.
+     *
+     * @param particle the particle to spawn
+     * @param location the location to spawn at
+     * @param count the number of particles
+     * @param offsetX the maximum random offset on the X axis
+     * @param offsetY the maximum random offset on the Y axis
+     * @param offsetZ the maximum random offset on the Z axis
+     * @param extra the extra data for this particle, depends on the
+     *              particle used (normally speed)
+     * @param data the data to use for the particle or null,
+     *             the type of this depends on {@link Particle#getDataType()}
+     */
+    public <T> void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ, double extra, T data);
+
+    /**
+     * Spawns the particle (the number of times specified by count)
+     * at the target location. The position of each particle will be
+     * randomized positively and negatively by the offset parameters
+     * on each axis.
+     *
+     * @param particle the particle to spawn
+     * @param x the position on the x axis to spawn at
+     * @param y the position on the y axis to spawn at
+     * @param z the position on the z axis to spawn at
+     * @param count the number of particles
+     * @param offsetX the maximum random offset on the X axis
+     * @param offsetY the maximum random offset on the Y axis
+     * @param offsetZ the maximum random offset on the Z axis
+     * @param extra the extra data for this particle, depends on the
+     *              particle used (normally speed)
+     * @param data the data to use for the particle or null,
+     *             the type of this depends on {@link Particle#getDataType()}
+     */
+    public <T> void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ, double extra, T data);
+
+    /**
+     * Get whether the player can affect mob spawning
+     *
+     * @return if the player can affect mob spawning
+     */
+    public boolean getAffectsSpawning();
+
+    /**
+     * Set whether the player can affect mob spawning
+     *
+     * @param affects Whether the player can affect mob spawning
+     */
+    public void setAffectsSpawning(boolean affects);
+
+    /**
+     * Gets the view distance for this player
+     *
+     * @return the player's view distance
+     */
+    public int getViewDistance();
+
+    /**
+     * Sets the view distance for this player
+     *
+     * @param viewDistance the player's view distance
+     */
+    public void setViewDistance(int viewDistance);
+
+    // Paper start
+    /**
+     * Request that the player's client download and switch resource packs.
+     * <p>
+     * The player's client will download the new resource pack asynchronously
+     * in the background, and will automatically switch to it once the
+     * download is complete. If the client has downloaded and cached the same
+     * resource pack in the past, it will perform a quick timestamp check
+     * over the network to determine if the resource pack has changed and
+     * needs to be downloaded again. When this request is sent for the very
+     * first time from a given server, the client will first display a
+     * confirmation GUI to the player before proceeding with the download.
+     * <p>
+     * Notes:
+     * <ul>
+     * <li>Players can disable server resources on their client, in which
+     *     case this method will have no affect on them.
+     * <li>There is no concept of resetting resource packs back to default
+     *     within Minecraft, so players will have to relog to do so.
+     * </ul>
+     *
+     * @param url The URL from which the client will download the resource
+     *     pack. The string must contain only US-ASCII characters and should
+     *     be encoded as per RFC 1738.
+     * @param hash A 40 character hexadecimal and lowercase SHA-1 digest of
+     *     the resource pack file.
+     * @throws IllegalArgumentException Thrown if the URL is null.
+     * @throws IllegalArgumentException Thrown if the URL is too long. The
+     *     length restriction is an implementation specific arbitrary value.
+     */
+    void setResourcePack(String url, String hash);
+
+    /**
+     * @return the most recent resource pack status received from the player,
+     *         or null if no status has ever been received from this player.
+     */
+    org.bukkit.event.player.PlayerResourcePackStatusEvent.Status getResourcePackStatus();
+
+    /**
+     * @return the most recent resource pack hash received from the player,
+     *         or null if no hash has ever been received from this player.
+     */
+    String getResourcePackHash();
+
+    /**
+     * @return true if the last resource pack status received from this player
+     *         was {@link org.bukkit.event.player.PlayerResourcePackStatusEvent.Status#SUCCESSFULLY_LOADED}
+     */
+    boolean hasResourcePack();
+    // Paper end
+
+    // Spigot start
+    public class Spigot extends Entity.Spigot
+    {
+
+        /**
+         * Gets the connection address of this player, regardless of whether it
+         * has been spoofed or not.
+         *
+         * @return the player's connection address
+         */
+        public InetSocketAddress getRawAddress()
+        {
+            throw new UnsupportedOperationException( "Not supported yet." );
+        }
+
+        public void playEffect(Location location, Effect effect, int id, int data, float offsetX, float offsetY, float offsetZ, float speed, int particleCount, int radius)
+        {
+            throw new UnsupportedOperationException( "Not supported yet." );
+        }
+
+        /**
+         * Gets whether the player collides with entities
+         *
+         * @return the player's collision toggle state
+         * @deprecated see {@link LivingEntity#isCollidable()}
+         */
+        @Deprecated
+        public boolean getCollidesWithEntities()
+        {
+            throw new UnsupportedOperationException( "Not supported yet." );
+        }
+
+        /**
+         * Sets whether the player collides with entities
+         *
+         * @param collides whether the player should collide with entities or
+         * not.
+         * @deprecated {@link LivingEntity#setCollidable(boolean)}
+         */
+        @Deprecated
+        public void setCollidesWithEntities(boolean collides)
+        {
+            throw new UnsupportedOperationException( "Not supported yet." );
+        }
+
+        /**
+         * Respawns the player if dead.
+         */
+        public void respawn()
+        {
+            throw new UnsupportedOperationException( "Not supported yet." );
+        }
+
+        /**
+         * Gets player locale language.
+         *
+         * @return the player's client language settings
+         */
+        public String getLocale()
+        {
+            throw new UnsupportedOperationException( "Not supported yet." );
+        }
+
+        /**
+         * Gets all players hidden with {@link #hidePlayer(org.bukkit.entity.Player)}.
+         *
+         * @return a Set with all hidden players
+         */
+        public java.util.Set<Player> getHiddenPlayers()
+        {
+            throw new UnsupportedOperationException( "Not supported yet." );
+        }
+
+        /**
+         * Sends the component to the player
+         *
+         * @param component the components to send
+         */
+        public void sendMessage(net.md_5.bungee.api.chat.BaseComponent component) {
+            throw new UnsupportedOperationException("Not supported yet.");
+        }
+
+        /**
+         * Sends an array of components as a single message to the player
+         *
+         * @param components the components to send
+         */
+        public void sendMessage(net.md_5.bungee.api.chat.BaseComponent... components) {
+            throw new UnsupportedOperationException("Not supported yet.");
+        }
+
+        /**
+         * Sends the component to the specified screen position of this player
+         *
+         * @param position the screen position
+         * @param component the components to send
+         */
+        public void sendMessage(net.md_5.bungee.api.ChatMessageType position, net.md_5.bungee.api.chat.BaseComponent component) {
+            throw new UnsupportedOperationException("Not supported yet.");
+        }
+
+        /**
+         * Sends an array of components as a single message to the specified screen position of this player
+         *
+         * @param position the screen position
+         * @param component the components to send
+         */
+        public void sendMessage(net.md_5.bungee.api.ChatMessageType position, net.md_5.bungee.api.chat.BaseComponent... components) {
+            throw new UnsupportedOperationException("Not supported yet.");
+        }
+
+        public int getPing()
+        {
+            throw new UnsupportedOperationException( "Not supported yet." );
+        }
+    }
+
+    Spigot spigot();
+    // Spigot end
+	
+	// Paper start
+    /**
+     * Return this player's profile
+     *
+     * @return this player's profile
+     */
+    @Override
+    public AccountProfile getAccount();
+    // Paper end
+}
diff --git a/src/main/java/org/bukkit/entity/Villager.java b/src/main/java/org/bukkit/entity/Villager.java
new file mode 100644
index 0000000..65b7797
--- /dev/null
+++ b/src/main/java/org/bukkit/entity/Villager.java
@@ -0,0 +1,159 @@
+package org.bukkit.entity;
+
+import java.util.List;
+import org.bukkit.inventory.Inventory;
+import org.bukkit.inventory.InventoryHolder;
+import org.bukkit.inventory.MerchantRecipe;
+
+/**
+ * Represents a villager NPC
+ */
+public interface Villager extends Ageable, NPC, InventoryHolder {
+
+    /**
+     * Gets the current profession of this villager.
+     *
+     * @return Current profession.
+     */
+    public Profession getProfession();
+
+    /**
+     * Sets the new profession of this villager.
+     *
+     * @param profession New profession.
+     */
+    public void setProfession(Profession profession);
+
+    /**
+     * Get a list of trades currently available from this villager.
+     *
+     * @return an immutable list of trades
+     */
+    List<MerchantRecipe> getRecipes();
+
+    /**
+     * Set the list of trades currently available from this villager.
+     * <br>
+     * This will not change the selected trades of players currently trading
+     * with this villager.
+     *
+     * @param recipes a list of recipes
+     */
+    void setRecipes(List<MerchantRecipe> recipes);
+
+    /**
+     * Get the recipe at a certain index of this villager's trade list.
+     *
+     * @param i the index
+     * @return the recipe
+     * @throws IndexOutOfBoundsException
+     */
+    MerchantRecipe getRecipe(int i) throws IndexOutOfBoundsException;
+
+    /**
+     * Set the recipe at a certain index of this villager's trade list.
+     *
+     * @param i the index
+     * @param recipe the recipe
+     * @throws IndexOutOfBoundsException
+     */
+    void setRecipe(int i, MerchantRecipe recipe) throws IndexOutOfBoundsException;
+
+    /**
+     * Get the number of trades this villager currently has available.
+     *
+     * @return the recipe count
+     */
+    int getRecipeCount();
+
+    /**
+     * Gets this villager's inventory.
+     * <br>
+     * Note that this inventory is not the Merchant inventory, rather, it is the
+     * items that a villager might have collected (from harvesting crops, etc.)
+     *
+     * {@inheritDoc}
+     */
+    @Override
+    Inventory getInventory();
+
+    /**
+     * Gets whether this villager is currently trading.
+     *
+     * @return whether the villager is trading
+     */
+    boolean isTrading();
+
+    /**
+     * Gets the player this villager is trading with, or null if it is not
+     * currently trading.
+     *
+     * @return the trader, or null
+     */
+    HumanEntity getTrader();
+
+    /**
+     * Gets this villager's riches, the number of emeralds this villager has
+     * been given.
+     *
+     * @return the villager's riches
+     */
+    int getRiches();
+
+    /**
+     * Sets this villager's riches.
+     *
+     * @see Villager#getRiches()
+     *
+     * @param riches the new riches
+     */
+    void setRiches(int riches);
+
+    /**
+     * Represents the various different Villager professions there may be.
+     */
+    public enum Profession {
+        FARMER(0),
+        LIBRARIAN(1),
+        PRIEST(2),
+        BLACKSMITH(3),
+        BUTCHER(4),
+		HUSK(5);
+
+        private static final Profession[] professions = new Profession[Profession.values().length];
+        private final int id;
+
+        static {
+            for (Profession type : values()) {
+                professions[type.getId()] = type;
+            }
+        }
+
+        private Profession(int id) {
+            this.id = id;
+        }
+
+        /**
+         * Gets the ID of this profession.
+         *
+         * @return Profession ID.
+         * @deprecated Magic value
+         */
+        @Deprecated
+        public int getId() {
+            return id;
+        }
+
+        /**
+         * Gets a profession by its ID.
+         *
+         * @param id ID of the profession to get.
+         * @return Resulting profession, or null if not found.
+         * @deprecated Magic value
+         */
+        @Deprecated
+        public static Profession getProfession(int id) {
+            return (id >= professions.length) ? null : professions[id];
+        }
+    }
+}
diff --git a/src/main/java/org/bukkit/event/entity/CreatureSpawnEvent.java b/src/main/java/org/bukkit/event/entity/CreatureSpawnEvent.java
new file mode 100644
index 0000000..54dd901
--- /dev/null
+++ b/src/main/java/org/bukkit/event/entity/CreatureSpawnEvent.java
@@ -0,0 +1,184 @@
+package org.bukkit.event.entity;
+
+import org.bukkit.Location;
+import org.bukkit.entity.Entity;
+import org.bukkit.entity.LivingEntity;
+import org.bukkit.event.Cancellable;
+import org.bukkit.event.HandlerList;
+
+/**
+ * Called when a creature is spawned into a world.
+ * <p>
+ * If a Creature Spawn event is cancelled, the creature will not spawn.
+ */
+public class CreatureSpawnEvent extends EntityEvent implements Cancellable {
+    private static final HandlerList handlers = new HandlerList();
+    private boolean canceled;
+    private final SpawnReason spawnReason;
+
+    public CreatureSpawnEvent(final LivingEntity spawnee, final SpawnReason spawnReason) {
+        super(spawnee);
+        this.spawnReason = spawnReason;
+    }
+
+    public boolean isCancelled() {
+        return canceled;
+    }
+
+    public void setCancelled(boolean cancel) {
+        canceled = cancel;
+    }
+
+    @Override
+    public LivingEntity getEntity() {
+        return (LivingEntity) entity;
+    }
+
+    /**
+     * Gets the location at which the creature is spawning.
+     *
+     * @return The location at which the creature is spawning
+     */
+    public Location getLocation() {
+        return getEntity().getLocation();
+    }
+
+    /**
+     * Gets the reason for why the creature is being spawned.
+     *
+     * @return A SpawnReason value detailing the reason for the creature being
+     *     spawned
+     */
+    public SpawnReason getSpawnReason() {
+        return spawnReason;
+    }
+
+    @Override
+    public HandlerList getHandlers() {
+        return handlers;
+    }
+
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+
+    /**
+     * An enum to specify the type of spawning
+     */
+    public enum SpawnReason {
+
+        /**
+         * When something spawns from natural means
+         */
+        NATURAL,
+        /**
+         * When an entity spawns as a jockey of another entity (mostly spider
+         * jockeys)
+         */
+        JOCKEY,
+        /**
+         * When a creature spawns due to chunk generation
+         */
+        CHUNK_GEN,
+        /**
+         * When a creature spawns from a spawner
+         */
+        SPAWNER,
+        /**
+         * When a creature spawns from an egg
+         */
+        EGG,
+        /**
+         * When a creature spawns from a Spawner Egg
+         */
+        SPAWNER_EGG,
+        /**
+         * When a creature spawns because of a lightning strike
+         */
+        LIGHTNING,
+        /**
+         * When a creature is spawned by a player that is sleeping
+         *
+         * @deprecated No longer used
+         */
+        @Deprecated
+        BED,
+        /**
+         * When a snowman is spawned by being built
+         */
+        BUILD_SNOWMAN,
+        /**
+         * When an iron golem is spawned by being built
+         */
+        BUILD_IRONGOLEM,
+        /**
+         * When a wither boss is spawned by being built
+         */
+        BUILD_WITHER,
+        /**
+         * When an iron golem is spawned to defend a village
+         */
+        VILLAGE_DEFENSE,
+        /**
+         * When a zombie is spawned to invade a village
+         */
+        VILLAGE_INVASION,
+        /**
+         * When an animal breeds to create a child
+         */
+        BREEDING,
+        /**
+         * When a slime splits
+         */
+        SLIME_SPLIT,
+        /**
+         * When an entity calls for reinforcements
+         */
+        REINFORCEMENTS,
+        /**
+         * When a creature is spawned by nether portal
+         */
+        NETHER_PORTAL,
+        /**
+         * When a creature is spawned by a dispenser dispensing an egg
+         */
+        DISPENSE_EGG,
+        /**
+         * When a zombie infects a villager
+         */
+        INFECTION,
+        /**
+         * When a villager is cured from infection
+         */
+        CURED,
+        /**
+         * When an ocelot has a baby spawned along with them
+         */
+        OCELOT_BABY,
+        /**
+         * When a silverfish spawns from a block
+         */
+        SILVERFISH_BLOCK,
+        /**
+         * When an entity spawns as a mount of another entity (mostly chicken
+         * jockeys)
+         */
+        MOUNT,
+        /**
+         * When an entity spawns as a trap for players approaching
+         */
+        TRAP,
+		/**
+         * When an entity is spawned as a result of ender pearl usage
+         */
+        ENDER_PEARL,
+        /**
+         * When a creature is spawned by plugins
+         */
+        CUSTOM,
+        /**
+         * When an entity is missing a SpawnReason
+         */
+        DEFAULT
+    }
+}
diff --git a/src/main/java/org/bukkit/event/entity/EntityBreedEvent.java b/src/main/java/org/bukkit/event/entity/EntityBreedEvent.java
new file mode 100644
index 0000000..ce0973b
--- /dev/null
+++ b/src/main/java/org/bukkit/event/entity/EntityBreedEvent.java
@@ -0,0 +1,119 @@
+package org.bukkit.event.entity;
+
+import org.apache.commons.lang.Validate;
+import org.bukkit.entity.LivingEntity;
+import org.bukkit.event.Cancellable;
+import org.bukkit.event.HandlerList;
+import org.bukkit.inventory.ItemStack;
+
+/**
+ * Called when one Entity breeds with another Entity.
+ */
+public class EntityBreedEvent extends EntityEvent implements Cancellable {
+
+    private static final HandlerList handlers = new HandlerList();
+    //
+    private final LivingEntity mother;
+    private final LivingEntity father;
+    private final LivingEntity breeder;
+    private final ItemStack bredWith;
+    private int experience;
+    //
+    private boolean cancel;
+
+    public EntityBreedEvent(LivingEntity child, LivingEntity mother, LivingEntity father, LivingEntity breeder, ItemStack bredWith, int experience) {
+        super(child);
+
+        Validate.notNull(child, "Cannot have null child");
+        Validate.notNull(mother, "Cannot have null mother");
+        Validate.notNull(father, "Cannot have null father");
+
+        // Breeder can be null in the case of spontaneous conception
+        this.mother = mother;
+        this.father = father;
+        this.breeder = breeder;
+        this.bredWith = bredWith;
+
+        setExperience(experience);
+    }
+
+    @Override
+    public LivingEntity getEntity() {
+        return (LivingEntity) entity;
+    }
+
+    /**
+     * Gets the parent creating this entity.
+     *
+     * @return The "birth" parent
+     */
+    public LivingEntity getMother() {
+        return mother;
+    }
+
+    /**
+     * Gets the other parent of the newly born entity.
+     *
+     * @return the other parent
+     */
+    public LivingEntity getFather() {
+        return father;
+    }
+
+    /**
+     * Gets the Entity responsible for breeding. Breeder is null for spontaneous
+     * conception.
+     *
+     * @return The Entity who initiated breeding.
+     */
+    public LivingEntity getBreeder() {
+        return breeder;
+    }
+
+    /**
+     * The ItemStack that was used to initiate breeding, if present.
+     *
+     * @return ItemStack used to initiate breeding.
+     */
+    public ItemStack getBredWith() {
+        return bredWith;
+    }
+
+    /**
+     * Get the amount of experience granted by breeding.
+     *
+     * @return experience amount
+     */
+    public int getExperience() {
+        return experience;
+    }
+
+    /**
+     * Set the amount of experience granted by breeding.
+     *
+     * @param experience experience amount
+     */
+    public void setExperience(int experience) {
+        Validate.isTrue(experience >= 0, "Experience cannot be negative");
+        this.experience = experience;
+    }
+
+    @Override
+    public boolean isCancelled() {
+        return cancel;
+    }
+
+    @Override
+    public void setCancelled(boolean cancel) {
+        this.cancel = cancel;
+    }
+
+    @Override
+    public HandlerList getHandlers() {
+        return handlers;
+    }
+
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/org/bukkit/event/entity/EntityDamageEvent.java b/src/main/java/org/bukkit/event/entity/EntityDamageEvent.java
new file mode 100644
index 0000000..09ce0ae
--- /dev/null
+++ b/src/main/java/org/bukkit/event/entity/EntityDamageEvent.java
@@ -0,0 +1,436 @@
+package org.bukkit.event.entity;
+
+import java.util.EnumMap;
+import java.util.Map;
+import org.bukkit.Material;
+
+import org.apache.commons.lang.Validate;
+import org.bukkit.entity.Entity;
+import org.bukkit.entity.Player;
+import org.bukkit.event.Cancellable;
+import org.bukkit.event.HandlerList;
+import org.bukkit.util.NumberConversions;
+
+import com.google.common.base.Function;
+import com.google.common.base.Functions;
+import com.google.common.collect.ImmutableMap;
+
+/**
+ * Stores data for damage events
+ */
+public class EntityDamageEvent extends EntityEvent implements Cancellable {
+    private static final HandlerList handlers = new HandlerList();
+    private static final DamageModifier[] MODIFIERS = DamageModifier.values();
+    private static final Function<? super Double, Double> ZERO = Functions.constant(-0.0);
+    private final Map<DamageModifier, Double> modifiers;
+    private final Map<DamageModifier, ? extends Function<? super Double, Double>> modifierFunctions;
+    private final Map<DamageModifier, Double> originals;
+    private boolean cancelled;
+    private final DamageCause cause;
+
+    @Deprecated
+    public EntityDamageEvent(final Entity damagee, final DamageCause cause, final int damage) {
+        this(damagee, cause, (double) damage);
+    }
+
+    @Deprecated
+    public EntityDamageEvent(final Entity damagee, final DamageCause cause, final double damage) {
+        this(damagee, cause, new EnumMap<DamageModifier, Double>(ImmutableMap.of(DamageModifier.BASE, damage)), new EnumMap<DamageModifier, Function<? super Double, Double>>(ImmutableMap.of(DamageModifier.BASE, ZERO)));
+    }
+
+    public EntityDamageEvent(final Entity damagee, final DamageCause cause, final Map<DamageModifier, Double> modifiers, final Map<DamageModifier, ? extends Function<? super Double, Double>> modifierFunctions) {
+        super(damagee);
+        Validate.isTrue(modifiers.containsKey(DamageModifier.BASE), "BASE DamageModifier missing");
+        Validate.isTrue(!modifiers.containsKey(null), "Cannot have null DamageModifier");
+        Validate.noNullElements(modifiers.values(), "Cannot have null modifier values");
+        Validate.isTrue(modifiers.keySet().equals(modifierFunctions.keySet()), "Must have a modifier function for each DamageModifier");
+        Validate.noNullElements(modifierFunctions.values(), "Cannot have null modifier function");
+        this.originals = new EnumMap<DamageModifier, Double>(modifiers);
+        this.cause = cause;
+        this.modifiers = modifiers;
+        this.modifierFunctions = modifierFunctions;
+    }
+
+    public boolean isCancelled() {
+        return cancelled;
+    }
+
+    public void setCancelled(boolean cancel) {
+        cancelled = cancel;
+    }
+
+    /**
+     * Gets the original damage for the specified modifier, as defined at this
+     * event's construction.
+     *
+     * @param type the modifier
+     * @return the original damage
+     * @throws IllegalArgumentException if type is null
+     */
+    public double getOriginalDamage(DamageModifier type) throws IllegalArgumentException {
+        final Double damage = originals.get(type);
+        if (damage != null) {
+            return damage;
+        }
+        if (type == null) {
+            throw new IllegalArgumentException("Cannot have null DamageModifier");
+        }
+        return 0;
+    }
+
+    /**
+     * Sets the damage for the specified modifier.
+     *
+     * @param type the damage modifier
+     * @param damage the scalar value of the damage's modifier
+     * @see #getFinalDamage()
+     * @throws IllegalArgumentException if type is null
+     * @throws UnsupportedOperationException if the caller does not support
+     *     the particular DamageModifier, or to rephrase, when {@link
+     *     #isApplicable(DamageModifier)} returns false
+     */
+    public void setDamage(DamageModifier type, double damage) throws IllegalArgumentException, UnsupportedOperationException {
+        if (!modifiers.containsKey(type)) {
+            throw type == null ? new IllegalArgumentException("Cannot have null DamageModifier") : new UnsupportedOperationException(type + " is not applicable to " + getEntity());
+        }
+        modifiers.put(type, damage);
+    }
+
+    /**
+     * Gets the damage change for some modifier
+     *
+     * @param type the damage modifier
+     * @return The raw amount of damage caused by the event
+     * @throws IllegalArgumentException if type is null
+     * @see DamageModifier#BASE
+     */
+    public double getDamage(DamageModifier type) throws IllegalArgumentException {
+        Validate.notNull(type, "Cannot have null DamageModifier");
+        final Double damage = modifiers.get(type);
+        return damage == null ? 0 : damage;
+    }
+
+    /**
+     * This checks to see if a particular modifier is valid for this event's
+     * caller, such that, {@link #setDamage(DamageModifier, double)} will not
+     * throw an {@link UnsupportedOperationException}.
+     * <p>
+     * {@link DamageModifier#BASE} is always applicable.
+     *
+     * @param type the modifier
+     * @return true if the modifier is supported by the caller, false otherwise
+     * @throws IllegalArgumentException if type is null
+     */
+    public boolean isApplicable(DamageModifier type) throws IllegalArgumentException {
+        Validate.notNull(type, "Cannot have null DamageModifier");
+        return modifiers.containsKey(type);
+    }
+
+    /**
+     * Gets the raw amount of damage caused by the event
+     *
+     * @return The raw amount of damage caused by the event
+     * @see DamageModifier#BASE
+     */
+    public double getDamage() {
+        return getDamage(DamageModifier.BASE);
+    }
+
+    /**
+     * Gets the amount of damage caused by the event after all damage
+     * reduction is applied.
+     *
+     * @return the amount of damage caused by the event
+     */
+    public final double getFinalDamage() {
+        double damage = 0;
+        for (DamageModifier modifier : MODIFIERS) {
+            damage += getDamage(modifier);
+        }
+        return damage;
+    }
+
+    /**
+     * This method exists for legacy reasons to provide backwards
+     * compatibility. It will not exist at runtime and should not be used
+     * under any circumstances.
+     * 
+     * @return the (rounded) damage
+     */
+    @Deprecated
+    public int _INVALID_getDamage() {
+        return NumberConversions.ceil(getDamage());
+    }
+
+    /**
+     * Sets the raw amount of damage caused by the event.
+     * <p>
+     * For compatibility this also recalculates the modifiers and scales
+     * them by the difference between the modifier for the previous damage
+     * value and the new one.
+     *
+     * @param damage The raw amount of damage caused by the event
+     */
+    public void setDamage(double damage) {
+        // These have to happen in the same order as the server calculates them, keep the enum sorted
+        double remaining = damage;
+        double oldRemaining = getDamage(DamageModifier.BASE);
+        for (DamageModifier modifier : MODIFIERS) {
+            if (!isApplicable(modifier)) {
+                continue;
+            }
+
+            Function<? super Double, Double> modifierFunction = modifierFunctions.get(modifier);
+            double newVanilla = modifierFunction.apply(remaining);
+            double oldVanilla = modifierFunction.apply(oldRemaining);
+            double difference = oldVanilla - newVanilla;
+
+            // Don't allow value to cross zero, assume zero values should be negative
+            double old = getDamage(modifier);
+            if (old > 0) {
+                setDamage(modifier, Math.max(0, old - difference));
+            } else {
+                setDamage(modifier, Math.min(0, old - difference));
+            }
+            remaining += newVanilla;
+            oldRemaining += oldVanilla;
+        }
+
+        setDamage(DamageModifier.BASE, damage);
+    }
+
+    /**
+     * This method exists for legacy reasons to provide backwards
+     * compatibility. It will not exist at runtime and should not be used
+     * under any circumstances.
+     * 
+     * @param damage the new damage value
+     */
+    @Deprecated
+    public void _INVALID_setDamage(int damage) {
+        setDamage(damage);
+    }
+
+    /**
+     * Gets the cause of the damage.
+     *
+     * @return A DamageCause value detailing the cause of the damage.
+     */
+    public DamageCause getCause() {
+        return cause;
+    }
+
+    @Override
+    public HandlerList getHandlers() {
+        return handlers;
+    }
+
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+
+    /**
+     * An enum to specify the types of modifier
+     */
+    public enum DamageModifier {
+        /**
+         * This represents the amount of damage being done, also known as the
+         * raw {@link EntityDamageEvent#getDamage()}.
+         */
+        BASE,
+        /**
+         * This represents the damage reduced by a wearing a helmet when hit
+         * by a falling block.
+         */
+        HARD_HAT,
+        /**
+         * This represents  the damage reduction caused by blocking, only present for
+         * {@link Player Players}.
+         */
+        BLOCKING,
+        /**
+         * This represents the damage reduction caused by wearing armor.
+         */
+        ARMOR,
+        /**
+         * This represents the damage reduction caused by the Resistance potion effect.
+         */
+        RESISTANCE,
+        /**
+         * This represents the damage reduction caused by the combination of:
+         * <ul>
+         * <li>
+         *     Armor enchantments
+         * </li><li>
+         *     Witch's potion resistance
+         * </li>
+         * </ul>
+         */
+        MAGIC,
+        /**
+         * This represents the damage reduction caused by the absorption potion
+         * effect.
+         */
+        ABSORPTION,
+        ;
+    }
+
+    /**
+     * An enum to specify the cause of the damage
+     */
+    public enum DamageCause {
+
+        /**
+         * Damage caused when an entity contacts a block such as a Cactus.
+         * <p>
+         * Damage: 1 (Cactus)
+         */
+        CONTACT,
+        /**
+         * Damage caused when an entity attacks another entity.
+         * <p>
+         * Damage: variable
+         */
+        ENTITY_ATTACK,
+        /**
+         * Damage caused when attacked by a projectile.
+         * <p>
+         * Damage: variable
+         */
+        PROJECTILE,
+        /**
+         * Damage caused by being put in a block
+         * <p>
+         * Damage: 1
+         */
+        SUFFOCATION,
+        /**
+         * Damage caused when an entity falls a distance greater than 3 blocks
+         * <p>
+         * Damage: fall height - 3.0
+         */
+        FALL,
+        /**
+         * Damage caused by direct exposure to fire
+         * <p>
+         * Damage: 1
+         */
+        FIRE,
+        /**
+         * Damage caused due to burns caused by fire
+         * <p>
+         * Damage: 1
+         */
+        FIRE_TICK,
+        /**
+         * Damage caused due to a snowman melting
+         * <p>
+         * Damage: 1
+         */
+        MELTING,
+        /**
+         * Damage caused by direct exposure to lava
+         * <p>
+         * Damage: 4
+         */
+        LAVA,
+        /**
+         * Damage caused by running out of air while in water
+         * <p>
+         * Damage: 2
+         */
+        DROWNING,
+        /**
+         * Damage caused by being in the area when a block explodes.
+         * <p>
+         * Damage: variable
+         */
+        BLOCK_EXPLOSION,
+        /**
+         * Damage caused by being in the area when an entity, such as a
+         * Creeper, explodes.
+         * <p>
+         * Damage: variable
+         */
+        ENTITY_EXPLOSION,
+        /**
+         * Damage caused by falling into the void
+         * <p>
+         * Damage: 4 for players
+         */
+        VOID,
+        /**
+         * Damage caused by being struck by lightning
+         * <p>
+         * Damage: 5
+         */
+        LIGHTNING,
+        /**
+         * Damage caused by committing suicide using the command "/kill"
+         * <p>
+         * Damage: 1000
+         */
+        SUICIDE,
+        /**
+         * Damage caused by starving due to having an empty hunger bar
+         * <p>
+         * Damage: 1
+         */
+        STARVATION,
+        /**
+         * Damage caused due to an ongoing poison effect
+         * <p>
+         * Damage: 1
+         */
+        POISON,
+        /**
+         * Damage caused by being hit by a damage potion or spell
+         * <p>
+         * Damage: variable
+         */
+        MAGIC,
+        /**
+         * Damage caused by Wither potion effect
+         */
+        WITHER,
+        /**
+         * Damage caused by being hit by a falling block which deals damage
+         * <p>
+         * <b>Note:</b> Not every block deals damage
+         * <p>
+         * Damage: variable
+         */
+        FALLING_BLOCK,
+        /**
+         * Damage caused in retaliation to another attack by the Thorns
+         * enchantment.
+         * <p>
+         * Damage: 1-4 (Thorns)
+         */
+        THORNS,
+        /**
+         * Damage caused by a dragon breathing fire.
+         * <p>
+         * Damage: variable
+         */
+        DRAGON_BREATH,
+        /**
+         * Custom damage.
+         * <p>
+         * Damage: variable
+         */
+        CUSTOM,
+        /**
+         * Damage caused when an entity runs into a wall.
+         * <p>
+         * Damage: variable
+         */
+        FLY_INTO_WALL,
+        /**
+         * Damage caused when an entity steps on {@link Material#MAGMA}.
+         * <p>
+         * Damage: 1
+         */
+        HOT_FLOOR
+    }
+}
diff --git a/src/main/java/org/bukkit/event/entity/EntityTargetEvent.java b/src/main/java/org/bukkit/event/entity/EntityTargetEvent.java
new file mode 100644
index 0000000..9447197
--- /dev/null
+++ b/src/main/java/org/bukkit/event/entity/EntityTargetEvent.java
@@ -0,0 +1,156 @@
+package org.bukkit.event.entity;
+
+import org.bukkit.entity.Entity;
+import org.bukkit.event.Cancellable;
+import org.bukkit.event.HandlerList;
+
+/**
+ * Called when a creature targets or untargets another entity
+ */
+public class EntityTargetEvent extends EntityEvent implements Cancellable {
+    private static final HandlerList handlers = new HandlerList();
+    private boolean cancel = false;
+    private Entity target;
+    private final TargetReason reason;
+
+    public EntityTargetEvent(final Entity entity, final Entity target, final TargetReason reason) {
+        super(entity);
+        this.target = target;
+        this.reason = reason;
+    }
+
+    public boolean isCancelled() {
+        return cancel;
+    }
+
+    public void setCancelled(boolean cancel) {
+        this.cancel = cancel;
+    }
+
+    /**
+     * Returns the reason for the targeting
+     *
+     * @return The reason
+     */
+    public TargetReason getReason() {
+        return reason;
+    }
+
+    /**
+     * Get the entity that this is targeting.
+     * <p>
+     * This will be null in the case that the event is called when the mob
+     * forgets its target.
+     *
+     * @return The entity
+     */
+    public Entity getTarget() {
+        return target;
+    }
+
+    /**
+     * Set the entity that you want the mob to target instead.
+     * <p>
+     * It is possible to be null, null will cause the entity to be
+     * target-less.
+     * <p>
+     * This is different from cancelling the event. Cancelling the event will
+     * cause the entity to keep an original target, while setting to be null
+     * will cause the entity to be reset.
+     *
+     * @param target The entity to target
+     */
+    public void setTarget(Entity target) {
+        this.target = target;
+    }
+
+    @Override
+    public HandlerList getHandlers() {
+        return handlers;
+    }
+
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+
+    /**
+     * An enum to specify the reason for the targeting
+     */
+    public enum TargetReason {
+
+        /**
+         * When the entity's target has died, and so it no longer targets it
+         */
+        TARGET_DIED,
+        /**
+         * When the entity doesn't have a target, so it attacks the nearest
+         * player
+         */
+        CLOSEST_PLAYER,
+        /**
+         * When the target attacks the entity, so entity targets it
+         */
+        TARGET_ATTACKED_ENTITY,
+        /**
+         * When the target attacks a fellow pig zombie, so the whole group
+         * will target him with this reason.
+         */
+        PIG_ZOMBIE_TARGET,
+        /**
+         * When the target is forgotten for whatever reason.
+         * <p>
+         * Currently only occurs in with spiders when there is a high
+         * brightness.
+         */
+        FORGOT_TARGET,
+        /**
+         * When the target attacks the owner of the entity, so the entity
+         * targets it.
+         */
+        TARGET_ATTACKED_OWNER,
+        /**
+         * When the owner of the entity attacks the target attacks, so the
+         * entity targets it.
+         */
+        OWNER_ATTACKED_TARGET,
+        /**
+         * When the entity has no target, so the entity randomly chooses one.
+         */
+        RANDOM_TARGET,
+        /**
+         * When an entity selects a target while defending a village.
+         */
+        DEFEND_VILLAGE,
+        /**
+         * When the target attacks a nearby entity of the same type, so the entity targets it
+         */
+        TARGET_ATTACKED_NEARBY_ENTITY,
+        /**
+         * When a zombie targeting an entity summons reinforcements, so the reinforcements target the same entity
+         */
+        REINFORCEMENT_TARGET,
+        /**
+         * When an entity targets another entity after colliding with it.
+         */
+        COLLISION,
+        /**
+         * For custom calls to the event.
+         */
+        CUSTOM,
+        /**
+         * When the entity doesn't have a target, so it attacks the nearest
+         * entity
+         */
+        CLOSEST_ENTITY,
+		/**
+         * When another entity tempts this entity by having a desired item such
+         * as wheat in it's hand.
+         */
+        TEMPT,
+        /**
+        /**
+         * A currently unknown reason for the entity changing target.
+         */
+        UNKNOWN;
+    }
+}
diff --git a/src/main/java/org/bukkit/inventory/ItemStack.java b/src/main/java/org/bukkit/inventory/ItemStack.java
new file mode 100644
index 0000000..c412224
--- /dev/null
+++ b/src/main/java/org/bukkit/inventory/ItemStack.java
@@ -0,0 +1,611 @@
+package org.bukkit.inventory;
+
+import com.google.common.collect.ImmutableMap;
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+import org.apache.commons.lang.Validate;
+import org.bukkit.Bukkit;
+import org.bukkit.Material;
+import org.bukkit.Utility;
+import org.bukkit.configuration.serialization.ConfigurationSerializable;
+import org.bukkit.enchantments.Enchantment;
+import org.bukkit.inventory.meta.ItemMeta;
+import org.bukkit.material.MaterialData;
+
+/**
+ * Represents a stack of items
+ */
+public class ItemStack implements Cloneable, ConfigurationSerializable {
+    private int type = 0;
+    private int amount = 0;
+    private MaterialData data = null;
+    private short durability = 0;
+    private ItemMeta meta;
+
+    @Utility
+    protected ItemStack() {}
+
+    /**
+     * Defaults stack size to 1, with no extra data
+     *
+     * @param type item material id
+     * @deprecated Magic value
+     */
+    @Deprecated
+    public ItemStack(final int type) {
+        this(type, 1);
+    }
+
+    /**
+     * Defaults stack size to 1, with no extra data
+     *
+     * @param type item material
+     */
+    public ItemStack(final Material type) {
+        this(type, 1);
+    }
+
+    /**
+     * An item stack with no extra data
+     *
+     * @param type item material id
+     * @param amount stack size
+     * @deprecated Magic value
+     */
+    @Deprecated
+    public ItemStack(final int type, final int amount) {
+        this(type, amount, (short) 0);
+    }
+
+    /**
+     * An item stack with no extra data
+     *
+     * @param type item material
+     * @param amount stack size
+     */
+    public ItemStack(final Material type, final int amount) {
+        this(type.getId(), amount);
+    }
+
+    /**
+     * An item stack with the specified damage / durability
+     *
+     * @param type item material id
+     * @param amount stack size
+     * @param damage durability / damage
+     * @deprecated Magic value
+     */
+    @Deprecated
+    public ItemStack(final int type, final int amount, final short damage) {
+        this.type = type;
+        this.amount = amount;
+        this.durability = damage;
+    }
+
+    /**
+     * An item stack with the specified damage / durabiltiy
+     *
+     * @param type item material
+     * @param amount stack size
+     * @param damage durability / damage
+     */
+    public ItemStack(final Material type, final int amount, final short damage) {
+        this(type.getId(), amount, damage);
+    }
+
+    /**
+     * @param type the raw type id
+     * @param amount the amount in the stack
+     * @param damage the damage value of the item
+     * @param data the data value or null
+     * @deprecated this method uses an ambiguous data byte object
+     */
+    @Deprecated
+    public ItemStack(final int type, final int amount, final short damage, final Byte data) {
+        this.type = type;
+        this.amount = amount;
+        this.durability = damage;
+        if (data != null) {
+            createData(data);
+            this.durability = data;
+        }
+    }
+
+    /**
+     * @param type the type
+     * @param amount the amount in the stack
+     * @param damage the damage value of the item
+     * @param data the data value or null
+     * @deprecated this method uses an ambiguous data byte object
+     */
+    @Deprecated
+    public ItemStack(final Material type, final int amount, final short damage, final Byte data) {
+        this(type.getId(), amount, damage, data);
+    }
+
+    /**
+     * Creates a new item stack derived from the specified stack
+     *
+     * @param stack the stack to copy
+     * @throws IllegalArgumentException if the specified stack is null or
+     *     returns an item meta not created by the item factory
+     */
+    public ItemStack(final ItemStack stack) throws IllegalArgumentException {
+        Validate.notNull(stack, "Cannot copy null stack");
+        this.type = stack.getTypeId();
+        this.amount = stack.getAmount();
+        this.durability = stack.getDurability();
+        this.data = stack.getData();
+        if (stack.hasItemMeta()) {
+            setItemMeta0(stack.getItemMeta(), getType0());
+        }
+    }
+
+    /**
+     * Gets the type of this item
+     *
+     * @return Type of the items in this stack
+     */
+    @Utility
+    public Material getType() {
+        return getType0(getTypeId());
+    }
+
+    private Material getType0() {
+        return getType0(this.type);
+    }
+
+    private static Material getType0(int id) {
+        Material material = Material.getMaterial(id);
+        return material == null ? Material.AIR : material;
+    }
+
+    /**
+     * Sets the type of this item
+     * <p>
+     * Note that in doing so you will reset the MaterialData for this stack
+     *
+     * @param type New type to set the items in this stack to
+     */
+    @Utility
+    public void setType(Material type) {
+        Validate.notNull(type, "Material cannot be null");
+        setTypeId(type.getId());
+    }
+
+    /**
+     * Gets the type id of this item
+     *
+     * @return Type Id of the items in this stack
+     * @deprecated Magic value
+     */
+    @Deprecated
+    public int getTypeId() {
+        return type;
+    }
+
+    /**
+     * Sets the type id of this item
+     * <p>
+     * Note that in doing so you will reset the MaterialData for this stack
+     *
+     * @param type New type id to set the items in this stack to
+     * @deprecated Magic value
+     */
+    @Deprecated
+    public void setTypeId(int type) {
+        this.type = type;
+        if (this.meta != null) {
+            this.meta = Bukkit.getItemFactory().asMetaFor(meta, getType0());
+        }
+        createData((byte) 0);
+    }
+
+    /**
+     * Gets the amount of items in this stack
+     *
+     * @return Amount of items in this stick
+     */
+    public int getAmount() {
+        return amount;
+    }
+
+    /**
+     * Sets the amount of items in this stack
+     *
+     * @param amount New amount of items in this stack
+     */
+    public void setAmount(int amount) {
+        this.amount = amount;
+    }
+
+    /**
+     * Gets the MaterialData for this stack of items
+     *
+     * @return MaterialData for this item
+     */
+    public MaterialData getData() {
+        Material mat = getType();
+        if (data == null && mat != null && mat.getData() != null) {
+            data = mat.getNewData((byte) this.getDurability());
+        }
+
+        return data;
+    }
+
+    /**
+     * Sets the MaterialData for this stack of items
+     *
+     * @param data New MaterialData for this item
+     */
+    public void setData(MaterialData data) {
+        Material mat = getType();
+
+        if (data == null || mat == null || mat.getData() == null) {
+            this.data = data;
+        } else {
+            if ((data.getClass() == mat.getData()) || (data.getClass() == MaterialData.class)) {
+                this.data = data;
+            } else {
+                throw new IllegalArgumentException("Provided data is not of type " + mat.getData().getName() + ", found " + data.getClass().getName());
+            }
+        }
+    }
+
+    /**
+     * Sets the durability of this item
+     *
+     * @param durability Durability of this item
+     */
+    public void setDurability(final short durability) {
+        this.durability = durability;
+    }
+
+    /**
+     * Gets the durability of this item
+     *
+     * @return Durability of this item
+     */
+    public short getDurability() {
+        return durability;
+    }
+
+    /**
+     * Get the maximum stacksize for the material hold in this ItemStack.
+     * (Returns -1 if it has no idea)
+     *
+     * @return The maximum you can stack this material to.
+     */
+    @Utility
+    public int getMaxStackSize() {
+        Material material = getType();
+        if (material != null) {
+            return material.getMaxStackSize();
+        }
+        return -1;
+    }
+
+    private void createData(final byte data) {
+        Material mat = Material.getMaterial(type);
+
+        if (mat == null) {
+            this.data = new MaterialData(type, data);
+        } else {
+            this.data = mat.getNewData(data);
+        }
+    }
+
+    @Override
+    @Utility
+    public String toString() {
+        StringBuilder toString = new StringBuilder("ItemStack{").append(getType().name()).append(" x ").append(getAmount());
+        if (hasItemMeta()) {
+            toString.append(", ").append(getItemMeta());
+        }
+        return toString.append('}').toString();
+    }
+
+    @Override
+    @Utility
+    public boolean equals(Object obj) {
+        if (this == obj) {
+            return true;
+        }
+        if (!(obj instanceof ItemStack)) {
+            return false;
+        }
+
+        ItemStack stack = (ItemStack) obj;
+        return getAmount() == stack.getAmount() && isSimilar(stack);
+    }
+
+    /**
+     * This method is the same as equals, but does not consider stack size
+     * (amount).
+     *
+     * @param stack the item stack to compare to
+     * @return true if the two stacks are equal, ignoring the amount
+     */
+    @Utility
+    public boolean isSimilar(ItemStack stack) {
+        if (stack == null) {
+            return false;
+        }
+        if (stack == this) {
+            return true;
+        }
+        return getTypeId() == stack.getTypeId() && getDurability() == stack.getDurability() && hasItemMeta() == stack.hasItemMeta() && (hasItemMeta() ? Bukkit.getItemFactory().equals(getItemMeta(), stack.getItemMeta()) : true);
+    }
+
+    @Override
+    public ItemStack clone() {
+        try {
+            ItemStack itemStack = (ItemStack) super.clone();
+
+            if (this.meta != null) {
+                itemStack.meta = this.meta.clone();
+            }
+
+            if (this.data != null) {
+                itemStack.data = this.data.clone();
+            }
+
+            return itemStack;
+        } catch (CloneNotSupportedException e) {
+            throw new Error(e);
+        }
+    }
+
+    @Override
+    @Utility
+    public int hashCode() { // Torch
+        int hash = 1;
+
+        hash = hash * 31 + getTypeId();
+        hash = hash * 31 + getAmount();
+        hash = hash * 31 + (getDurability() & 0xffff);
+        hash = hash * 31 + (hasItemMeta() ? (meta == null ? getItemMeta().hashCode() : meta.hashCode()) : 0);
+
+        return hash;
+    }
+
+    /**
+     * Checks if this ItemStack contains the given {@link Enchantment}
+     *
+     * @param ench Enchantment to test
+     * @return True if this has the given enchantment
+     */
+    public boolean containsEnchantment(Enchantment ench) {
+        return meta == null ? false : meta.hasEnchant(ench);
+    }
+
+    /**
+     * Gets the level of the specified enchantment on this item stack
+     *
+     * @param ench Enchantment to check
+     * @return Level of the enchantment, or 0
+     */
+    public int getEnchantmentLevel(Enchantment ench) {
+        return meta == null ? 0 : meta.getEnchantLevel(ench);
+    }
+
+    /**
+     * Gets a map containing all enchantments and their levels on this item.
+     *
+     * @return Map of enchantments.
+     */
+    public Map<Enchantment, Integer> getEnchantments() {
+        return meta == null ? ImmutableMap.<Enchantment, Integer>of() : meta.getEnchants();
+    }
+
+    /**
+     * Adds the specified enchantments to this item stack.
+     * <p>
+     * This method is the same as calling {@link
+     * #addEnchantment(org.bukkit.enchantments.Enchantment, int)} for each
+     * element of the map.
+     *
+     * @param enchantments Enchantments to add
+     * @throws IllegalArgumentException if the specified enchantments is null
+     * @throws IllegalArgumentException if any specific enchantment or level
+     *     is null. <b>Warning</b>: Some enchantments may be added before this
+     *     exception is thrown.
+     */
+    @Utility
+    public void addEnchantments(Map<Enchantment, Integer> enchantments) {
+        Validate.notNull(enchantments, "Enchantments cannot be null");
+        for (Map.Entry<Enchantment, Integer> entry : enchantments.entrySet()) {
+            addEnchantment(entry.getKey(), entry.getValue());
+        }
+    }
+
+    /**
+     * Adds the specified {@link Enchantment} to this item stack.
+     * <p>
+     * If this item stack already contained the given enchantment (at any
+     * level), it will be replaced.
+     *
+     * @param ench Enchantment to add
+     * @param level Level of the enchantment
+     * @throws IllegalArgumentException if enchantment null, or enchantment is
+     *     not applicable
+     */
+    @Utility
+    public void addEnchantment(Enchantment ench, int level) {
+        Validate.notNull(ench, "Enchantment cannot be null");
+        if ((level < ench.getStartLevel()) || (level > ench.getMaxLevel())) {
+            throw new IllegalArgumentException("Enchantment level is either too low or too high (given " + level + ", bounds are " + ench.getStartLevel() + " to " + ench.getMaxLevel() + ")");
+        } else if (!ench.canEnchantItem(this)) {
+            throw new IllegalArgumentException("Specified enchantment cannot be applied to this itemstack");
+        }
+
+        addUnsafeEnchantment(ench, level);
+    }
+
+    /**
+     * Adds the specified enchantments to this item stack in an unsafe manner.
+     * <p>
+     * This method is the same as calling {@link
+     * #addUnsafeEnchantment(org.bukkit.enchantments.Enchantment, int)} for
+     * each element of the map.
+     *
+     * @param enchantments Enchantments to add
+     */
+    @Utility
+    public void addUnsafeEnchantments(Map<Enchantment, Integer> enchantments) {
+        for (Map.Entry<Enchantment, Integer> entry : enchantments.entrySet()) {
+            addUnsafeEnchantment(entry.getKey(), entry.getValue());
+        }
+    }
+
+    /**
+     * Adds the specified {@link Enchantment} to this item stack.
+     * <p>
+     * If this item stack already contained the given enchantment (at any
+     * level), it will be replaced.
+     * <p>
+     * This method is unsafe and will ignore level restrictions or item type.
+     * Use at your own discretion.
+     *
+     * @param ench Enchantment to add
+     * @param level Level of the enchantment
+     */
+    public void addUnsafeEnchantment(Enchantment ench, int level) {
+        (meta == null ? meta = Bukkit.getItemFactory().getItemMeta(getType0()) : meta).addEnchant(ench, level, true);
+    }
+
+    /**
+     * Removes the specified {@link Enchantment} if it exists on this
+     * ItemStack
+     *
+     * @param ench Enchantment to remove
+     * @return Previous level, or 0
+     */
+    public int removeEnchantment(Enchantment ench) {
+        int level = getEnchantmentLevel(ench);
+        if (level == 0 || meta == null) {
+            return level;
+        }
+        meta.removeEnchant(ench);
+        return level;
+    }
+
+    @Utility
+    public Map<String, Object> serialize() {
+        Map<String, Object> result = new LinkedHashMap<String, Object>();
+
+        result.put("type", getType().name());
+
+        if (getDurability() != 0) {
+            result.put("damage", getDurability());
+        }
+
+        if (getAmount() != 1) {
+            result.put("amount", getAmount());
+        }
+
+        ItemMeta meta = getItemMeta();
+        if (!Bukkit.getItemFactory().equals(meta, null)) {
+            result.put("meta", meta);
+        }
+
+        return result;
+    }
+
+    /**
+     * Required method for configuration serialization
+     *
+     * @param args map to deserialize
+     * @return deserialized item stack
+     * @see ConfigurationSerializable
+     */
+    public static ItemStack deserialize(Map<String, Object> args) {
+        Material type = Material.getMaterial((String) args.get("type"));
+        short damage = 0;
+        int amount = 1;
+
+        if (args.containsKey("damage")) {
+            damage = ((Number) args.get("damage")).shortValue();
+        }
+
+        if (args.containsKey("amount")) {
+            amount = ((Number) args.get("amount")).intValue();
+        }
+
+        ItemStack result = new ItemStack(type, amount, damage);
+
+        if (args.containsKey("enchantments")) { // Backward compatiblity, @deprecated
+            Object raw = args.get("enchantments");
+
+            if (raw instanceof Map) {
+                Map<?, ?> map = (Map<?, ?>) raw;
+
+                for (Map.Entry<?, ?> entry : map.entrySet()) {
+                    Enchantment enchantment = Enchantment.getByName(entry.getKey().toString());
+
+                    if ((enchantment != null) && (entry.getValue() instanceof Integer)) {
+                        result.addUnsafeEnchantment(enchantment, (Integer) entry.getValue());
+                    }
+                }
+            }
+        } else if (args.containsKey("meta")) { // We cannot and will not have meta when enchantments (pre-ItemMeta) exist
+            Object raw = args.get("meta");
+            if (raw instanceof ItemMeta) {
+                result.setItemMeta((ItemMeta) raw);
+            }
+        }
+
+        return result;
+    }
+
+    /**
+     * Get a copy of this ItemStack's {@link ItemMeta}.
+     *
+     * @return a copy of the current ItemStack's ItemData
+     */
+    public ItemMeta getItemMeta() {
+        return this.meta == null ? Bukkit.getItemFactory().getItemMeta(getType0()) : this.meta.clone();
+    }
+
+    /**
+     * Checks to see if any meta data has been defined.
+     *
+     * @return Returns true if some meta data has been set for this item
+     */
+    public boolean hasItemMeta() {
+        return !Bukkit.getItemFactory().equals(meta, null);
+    }
+
+    /**
+     * Set the ItemMeta of this ItemStack.
+     *
+     * @param itemMeta new ItemMeta, or null to indicate meta data be cleared.
+     * @return True if successfully applied ItemMeta, see {@link
+     *     ItemFactory#isApplicable(ItemMeta, ItemStack)}
+     * @throws IllegalArgumentException if the item meta was not created by
+     *     the {@link ItemFactory}
+     */
+    public boolean setItemMeta(ItemMeta itemMeta) {
+        return setItemMeta0(itemMeta, getType0());
+    }
+
+    /*
+     * Cannot be overridden, so it's safe for constructor call
+     */
+    private boolean setItemMeta0(ItemMeta itemMeta, Material material) {
+        if (itemMeta == null) {
+            this.meta = null;
+            return true;
+        }
+        if (!Bukkit.getItemFactory().isApplicable(itemMeta, material)) {
+            return false;
+        }
+        this.meta = Bukkit.getItemFactory().asMetaFor(itemMeta, material);
+        if (this.meta == itemMeta) {
+            this.meta = itemMeta.clone();
+        }
+
+        return true;
+    }
+}
diff --git a/src/main/java/org/bukkit/inventory/meta/BookMeta.java b/src/main/java/org/bukkit/inventory/meta/BookMeta.java
new file mode 100644
index 0000000..599a20c
--- /dev/null
+++ b/src/main/java/org/bukkit/inventory/meta/BookMeta.java
@@ -0,0 +1,176 @@
+package org.bukkit.inventory.meta;
+
+import java.util.List;
+
+import org.bukkit.Material;
+
+/**
+ * Represents a book ({@link Material#BOOK_AND_QUILL} or {@link
+ * Material#WRITTEN_BOOK}) that can have a title, an author, and pages.
+ */
+public interface BookMeta extends ItemMeta {
+
+    /**
+     * Represents the generation (or level of copying) of a written book
+     */
+    enum Generation {
+        /**
+         * Book written into a book-and-quill. Can be copied. (Default value)
+         */
+        ORIGINAL,
+        /**
+         * Book that was copied from an original. Can be copied.
+         */
+        COPY_OF_ORIGINAL,
+        /**
+         * Book that was copied from a copy of an original. Can't be copied.
+         */
+        COPY_OF_COPY,
+        /**
+         * Unused; unobtainable by players. Can't be copied.
+         */
+        TATTERED;
+    }
+
+    /**
+     * Checks for the existence of a title in the book.
+     *
+     * @return true if the book has a title
+     */
+    boolean hasTitle();
+
+    /**
+     * Gets the title of the book.
+     * <p>
+     * Plugins should check that hasTitle() returns true before calling this
+     * method.
+     *
+     * @return the title of the book
+     */
+    String getTitle();
+
+    /**
+     * Sets the title of the book.
+     * <p>
+     * Limited to 16 characters. Removes title when given null.
+     *
+     * @param title the title to set
+     * @return true if the title was successfully set
+     */
+    boolean setTitle(String title);
+
+    /**
+     * Checks for the existence of an author in the book.
+     *
+     * @return true if the book has an author
+     */
+    boolean hasAuthor();
+
+    /**
+     * Gets the author of the book.
+     * <p>
+     * Plugins should check that hasAuthor() returns true before calling this
+     * method.
+     *
+     * @return the author of the book
+     */
+    String getAuthor();
+
+    /**
+     * Sets the author of the book. Removes author when given null.
+     *
+     * @param author the author to set
+     */
+    void setAuthor(String author);
+
+    /**
+     * Checks for the existence of generation level in the book.
+     *
+     * @return true if the book has a generation level
+     */
+    boolean hasGeneration();
+
+    /**
+     * Gets the generation of the book.
+     * <p>
+     * Plugins should check that hasGeneration() returns true before calling
+     * this method.
+     *
+     * @return the generation of the book
+     */
+    Generation getGeneration();
+
+    /**
+     * Sets the generation of the book. Removes generation when given null.
+     *
+     * @param generation the generation to set
+     */
+    void setGeneration(Generation generation);
+
+    /**
+     * Checks for the existence of pages in the book.
+     *
+     * @return true if the book has pages
+     */
+    boolean hasPages();
+
+    /**
+     * Gets the specified page in the book. The given page must exist.
+     *
+     * @param page the page number to get
+     * @return the page from the book
+     */
+    String getPage(int page);
+
+    /**
+     * Sets the specified page in the book. Pages of the book must be
+     * contiguous.
+     * <p>
+     * The data can be up to 256 characters in length, additional characters
+     * are truncated.
+     *
+     * @param page the page number to set
+     * @param data the data to set for that page
+     */
+    void setPage(int page, String data);
+
+    /**
+     * Gets all the pages in the book.
+     *
+     * @return list of all the pages in the book
+     */
+    List<String> getPages();
+
+    /**
+     * Clears the existing book pages, and sets the book to use the provided
+     * pages. Maximum 50 pages with 256 characters per page.
+     *
+     * @param pages A list of pages to set the book to use
+     */
+    void setPages(List<String> pages);
+
+    /**
+     * Clears the existing book pages, and sets the book to use the provided
+     * pages. Maximum 50 pages with 256 characters per page.
+     *
+     * @param pages A list of strings, each being a page
+     */
+    void setPages(String... pages);
+
+    /**
+     * Adds new pages to the end of the book. Up to a maximum of 50 pages with
+     * 256 characters per page.
+     *
+     * @param pages A list of strings, each being a page
+     */
+    void addPage(String... pages);
+
+    /**
+     * Gets the number of pages in the book.
+     *
+     * @return the number of pages in the book
+     */
+    int getPageCount();
+
+    BookMeta clone();
+}
\ No newline at end of file
-- 
2.8.2.windows.1

