From b380c2d126512fc80811429f7f3e0d277b9b2c63 Mon Sep 17 00:00:00 2001
From: SotrForgotten <i@omc.hk>
Date: Thu, 21 Jul 2016 01:34:27 +0800
Subject: [PATCH] Queued network and optimize for NavigationListener


diff --git a/src/main/java/net/minecraft/server/BlockBeacon.java b/src/main/java/net/minecraft/server/BlockBeacon.java
new file mode 100644
index 0000000..b7f0d53
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockBeacon.java
@@ -0,0 +1,98 @@
+package net.minecraft.server;
+
+import javax.annotation.Nullable;
+
+public class BlockBeacon extends BlockTileEntity {
+
+    public BlockBeacon() {
+        super(Material.SHATTERABLE, MaterialMapColor.G);
+        this.c(3.0F);
+        this.a(CreativeModeTab.f);
+    }
+
+    public TileEntity a(World world, int i) {
+        return new TileEntityBeacon();
+    }
+
+    public boolean interact(World world, BlockPosition blockposition, IBlockData iblockdata, EntityHuman entityhuman, EnumHand enumhand, @Nullable ItemStack itemstack, EnumDirection enumdirection, float f, float f1, float f2) {
+        if (world.isClientSide) {
+            return true;
+        } else {
+            TileEntity tileentity = world.getTileEntity(blockposition);
+
+            if (tileentity instanceof TileEntityBeacon) {
+                entityhuman.openContainer((TileEntityBeacon) tileentity);
+                entityhuman.b(StatisticList.P);
+            }
+
+            return true;
+        }
+    }
+
+    public boolean b(IBlockData iblockdata) {
+        return false;
+    }
+
+    public boolean c(IBlockData iblockdata) {
+        return false;
+    }
+
+    public EnumRenderType a(IBlockData iblockdata) {
+        return EnumRenderType.MODEL;
+    }
+
+    public void postPlace(World world, BlockPosition blockposition, IBlockData iblockdata, EntityLiving entityliving, ItemStack itemstack) {
+        super.postPlace(world, blockposition, iblockdata, entityliving, itemstack);
+        if (itemstack.hasName()) {
+            TileEntity tileentity = world.getTileEntity(blockposition);
+
+            if (tileentity instanceof TileEntityBeacon) {
+                ((TileEntityBeacon) tileentity).a(itemstack.getName());
+            }
+        }
+
+    }
+
+    public void a(IBlockData iblockdata, World world, BlockPosition blockposition, Block block) {
+        TileEntity tileentity = world.getTileEntity(blockposition);
+
+        if (tileentity instanceof TileEntityBeacon) {
+            ((TileEntityBeacon) tileentity).m();
+            world.playBlockAction(blockposition, this, 1, 0);
+        }
+
+    }
+
+    public static void c(final World world, final BlockPosition blockposition) {
+        HttpUtilities.a.submit(new Runnable() {
+            public void run() {
+                Chunk chunk = world.getChunkAtWorldCoords(blockposition);
+
+                for (int i = blockposition.getY() - 1; i >= 0; --i) {
+                    final BlockPosition blockposition1 = new BlockPosition(blockposition.getX(), i, blockposition.getZ());
+
+                    if (!chunk.c(blockposition1)) {
+                        break;
+                    }
+
+                    IBlockData iblockdata = world.getType(blockposition1);
+
+                    if (iblockdata.getBlock() == Blocks.BEACON) {
+                        ((WorldServer) world).postToMainThread(new Runnable() {
+                            public void run() {
+                                TileEntity tileentity = world.getTileEntity(blockposition);
+
+                                if (tileentity instanceof TileEntityBeacon) {
+                                    ((TileEntityBeacon) tileentity).m();
+                                    world.playBlockAction(blockposition, Blocks.BEACON, 1, 0);
+                                }
+
+                            }
+                        });
+                    }
+                }
+
+            }
+        });
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Entity.java b/src/main/java/net/minecraft/server/Entity.java
index a89a778..dd40ee9 100644
--- a/src/main/java/net/minecraft/server/Entity.java
+++ b/src/main/java/net/minecraft/server/Entity.java
@@ -15,7 +15,7 @@ import javax.annotation.Nullable;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
-import org.torch.utils.LightRandom; // Torch
+import org.torch.light.LightRandom; // Torch
 
 import java.util.concurrent.RecursiveAction;
 import java.util.Map;
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 0536d13..63fc9b4 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -122,6 +122,18 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
     protected final Queue<FutureTask<?>> j = new java.util.concurrent.ConcurrentLinkedQueue<FutureTask<?>>(); // Spigot, PAIL: Rename
     private Thread serverThread;
     private long aa = av();
+	
+	private static final Queue<FutureTask<?>> networkQueue = new java.util.concurrent.ConcurrentLinkedQueue<FutureTask<?>>();
+    static void schedulePacket(Callable<?> run) {
+        networkQueue.add(ListenableFutureTask.create(run));
+    }
+    static void processNetworkQueue() {
+        FutureTask<?> entry;
+        int count = networkQueue.size();
+        while (count-- > 0 && (entry = networkQueue.poll()) != null) {
+            SystemUtils.a(entry, MinecraftServer.LOGGER);
+        }
+    }
 
     // CraftBukkit start
     public List<WorldServer> worlds = new ArrayList<WorldServer>();
@@ -894,6 +906,7 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
          }
         // Spigot end
         MinecraftTimings.minecraftSchedulerTimer.stopTiming(); // Paper
+		processNetworkQueue(); // Paper
 
         this.methodProfiler.c("levels");
 
@@ -941,7 +954,8 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
                 // CraftBukkit end */
 
                 this.methodProfiler.a("tick");
-
+				
+				processNetworkQueue(); // Paper
                 CrashReport crashreport;
 
                 try {
@@ -960,6 +974,7 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
                     throw new ReportedException(crashreport);
                 }
 
+				processNetworkQueue(); // Paper
                 try {
                     worldserver.timings.tickEntities.startTiming(); // Spigot
                     worldserver.tickEntities();
@@ -977,6 +992,7 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
                 }
 
                 this.methodProfiler.b();
+				processNetworkQueue(); // Paper
                 this.methodProfiler.a("tracker");
                 worldserver.getTracker().updatePlayers();
                 this.methodProfiler.b();
@@ -1007,6 +1023,7 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
         MinecraftTimings.tickablesTimer.stopTiming(); // Spigot
 
         this.methodProfiler.b();
+		processNetworkQueue(); // Paper
     }
 
     public boolean getAllowNether() {
diff --git a/src/main/java/net/minecraft/server/NavigationListener.java b/src/main/java/net/minecraft/server/NavigationListener.java
new file mode 100644
index 0000000..5adffb9
--- /dev/null
+++ b/src/main/java/net/minecraft/server/NavigationListener.java
@@ -0,0 +1,81 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Lists;
+import java.util.List;
+import javax.annotation.Nullable;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.Map.Entry;
+
+public class NavigationListener implements IWorldAccess {
+
+    private final List<NavigationAbstract> a = Lists.newArrayList();
+
+    public NavigationListener() {}
+	
+	private final Map<EntityInsentient, NavigationAbstract> navigators = new LinkedHashMap<EntityInsentient, NavigationAbstract>();
+
+    public void a(final World world, final BlockPosition blockPosition, final IBlockData blockData, final IBlockData blockData2, final int n) {
+		if (!a(world, blockPosition, blockData, blockData2)) {
+			return;
+		}
+		for (Entry<EntityInsentient, NavigationAbstract> entry : navigators.entrySet()) {
+			NavigationAbstract navigation = entry.getValue();
+			if (!navigation.i()) {
+				PathEntity pathentity = navigation.k();
+				if (pathentity != null && !pathentity.b()) {
+					if (pathentity.d() != 0) {
+						PathPoint pathpoint = pathentity.c();
+						EntityInsentient insentient = entry.getKey();
+						if (
+							blockPosition.distanceSquared(
+								(pathpoint.a + insentient.locX) / 2.0,
+								(pathpoint.b + insentient.locY) / 2.0,
+								(pathpoint.c + insentient.locZ) / 2.0
+							) < (pathentity.d() - pathentity.e()) * (pathentity.d() - pathentity.e())
+						) {
+							navigation.j();
+						}
+					}
+				}
+			}
+		}
+	}
+
+    protected boolean a(World world, BlockPosition blockposition, IBlockData iblockdata, IBlockData iblockdata1) {
+        AxisAlignedBB axisalignedbb = iblockdata.d(world, blockposition);
+        AxisAlignedBB axisalignedbb1 = iblockdata1.d(world, blockposition);
+
+        return axisalignedbb != axisalignedbb1 && (axisalignedbb == null || !axisalignedbb.equals(axisalignedbb1));
+    }
+
+    public void a(BlockPosition blockposition) {}
+
+    public void a(int i, int j, int k, int l, int i1, int j1) {}
+
+    public void a(@Nullable EntityHuman entityhuman, SoundEffect soundeffect, SoundCategory soundcategory, double d0, double d1, double d2, float f, float f1) {}
+
+    public void a(int i, boolean flag, double d0, double d1, double d2, double d3, double d4, double d5, int... aint) {}
+
+    public void a(Entity entity) {
+		if (entity instanceof EntityInsentient) {
+			EntityInsentient insentient = (EntityInsentient) entity;
+			NavigationAbstract navigation = insentient.getNavigation();
+			if (navigation != null) {
+				navigators.put(insentient, navigation);
+			}
+		}
+	}
+
+    public void b(Entity entity) {
+		navigators.remove(entity);
+	}
+
+    public void a(SoundEffect soundeffect, BlockPosition blockposition) {}
+
+    public void a(int i, BlockPosition blockposition, int j) {}
+
+    public void a(EntityHuman entityhuman, int i, BlockPosition blockposition, int j) {}
+
+    public void b(int i, BlockPosition blockposition, int j) {}
+}
diff --git a/src/main/java/net/minecraft/server/PlayerConnectionUtils.java b/src/main/java/net/minecraft/server/PlayerConnectionUtils.java
new file mode 100644
index 0000000..e4d5c79
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PlayerConnectionUtils.java
@@ -0,0 +1,16 @@
+package net.minecraft.server;
+
+public class PlayerConnectionUtils {
+
+    public static <T extends PacketListener> void ensureMainThread(final Packet<T> packet, final T t0, IAsyncTaskHandler iasynctaskhandler) throws CancelledPacketHandleException {
+        if (!iasynctaskhandler.isMainThread()) {
+            // Paper start - faster network processing
+            MinecraftServer.schedulePacket(() -> {
+                packet.a(t0);
+                return null;
+            });
+			// Paper end
+            throw CancelledPacketHandleException.INSTANCE;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/TileEntityBeacon.java b/src/main/java/net/minecraft/server/TileEntityBeacon.java
index 5a9061c..caf42ed 100644
--- a/src/main/java/net/minecraft/server/TileEntityBeacon.java
+++ b/src/main/java/net/minecraft/server/TileEntityBeacon.java
@@ -23,6 +23,12 @@ import org.bukkit.potion.PotionEffect;
 import com.destroystokyo.paper.event.block.BeaconEffectEvent;
 // Paper end
 
+import org.torch.usercache.UserCacheFileEntry;
+import org.torch.usercache.UserCacheEntryType;
+import org.torch.usercache.UserCacheEntryJsonSerializer;
+import org.torch.usercache.DualCache;
+import org.torch.usercache.GameProfileLookup;
+
 public class TileEntityBeacon extends TileEntityContainer implements ITickable, IWorldInventory {
 
     public static final MobEffectList[][] a = new MobEffectList[][] { { MobEffects.FASTER_MOVEMENT, MobEffects.FASTER_DIG}, { MobEffects.RESISTANCE, MobEffects.JUMP}, { MobEffects.INCREASE_DAMAGE}, { MobEffects.REGENERATION}};
diff --git a/src/main/java/net/minecraft/server/UserCache.java b/src/main/java/net/minecraft/server/UserCache.java
index 7631f4c..9ba99da 100644
--- a/src/main/java/net/minecraft/server/UserCache.java
+++ b/src/main/java/net/minecraft/server/UserCache.java
@@ -23,6 +23,11 @@ import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.List;
+import java.util.Locale;
+import java.util.UUID;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.text.ParseException;
@@ -38,6 +43,13 @@ import java.util.Map;
 import java.util.UUID;
 import javax.annotation.Nullable;
 import org.apache.commons.io.IOUtils;
+import org.spigotmc.SpigotConfig;
+import org.torch.usercache.DualCache.DualCacheEntry;
+import org.torch.usercache.UserCacheFileEntry;
+import org.torch.usercache.UserCacheEntryType;
+import org.torch.usercache.UserCacheEntryJsonSerializer;
+import org.torch.usercache.DualCache;
+import org.torch.usercache.GameProfileLookup;
 
 public class UserCache {
 
@@ -86,7 +98,7 @@ public class UserCache {
         };
 
         gameprofilerepository.findProfilesByNames(new String[] { s}, Agent.MINECRAFT, profilelookupcallback);
-        if (!d() && agameprofile[0] == null && !org.apache.commons.lang3.StringUtils.isBlank(s)) { // Paper - Don't lookup a profile with a blank name
+        if (!d() && agameprofile[0] == null) {
             UUID uuid = EntityHuman.a(new GameProfile((UUID) null, s));
             GameProfile gameprofile = new GameProfile(uuid, s);
 
@@ -193,8 +205,6 @@ public class UserCache {
     }
 
     public void b() {
-        if (com.destroystokyo.paper.PaperConfig.disableUserCacheSaving) return; // Paper
- 
         BufferedReader bufferedreader = null;
 
         try {
@@ -235,7 +245,6 @@ public class UserCache {
         c(true);
     }
     public void c(boolean asyncSave) {
-		if (com.destroystokyo.paper.PaperConfig.disableUserCacheSaving) return; // Paper
         // Paper end
         String s = this.b.toJson(this.a(org.spigotmc.SpigotConfig.userCacheCap));
         Runnable save = () -> {
diff --git a/src/main/java/org/torch/light/LightRNG.java b/src/main/java/org/torch/light/LightRNG.java
new file mode 100644
index 0000000..b48aa65
--- /dev/null
+++ b/src/main/java/org/torch/light/LightRNG.java
@@ -0,0 +1,240 @@
+/*
+Written in 2015 by Sebastiano Vigna (vigna@acm.org)
+
+To the extent possible under law, the author has dedicated all copyright
+and related and neighboring rights to this software to the public domain
+worldwide. This software is distributed without any warranty.
+
+See <http://creativecommons.org/publicdomain/zero/1.0/>. */
+package org.torch.light;
+
+/**
+ * This is a SplittableRandom-style generator, meant to have a tiny state
+ * that permits storing many different generators with low overhead.
+ * It should be rather fast, though no guarantees can be made on all hardware.
+ * <br>
+ * Benchmarking on a Windows laptop with an i7-4700MQ processor running OpenJDK 8
+ * reports generation of 64-bit random long output as 17.8x faster than generating
+ * an equivalent number of random longs with java.util.Random, and generation of
+ * 32-bit random int output as 9.8x faster. Specifically, generating 1 billion longs
+ * took about 1.28 nanoseconds per long (1.277 seconds for the whole group) with
+ * LightRNG, while java.util.Random (which is meant to produce int, to be fair) took
+ * about 22.8 nanoseconds per long (22.797 seconds for the whole group). XorRNG
+ * appears to be occasionally faster on int output than LightRNG, but it isn't clear
+ * why or what causes that (JIT or GC internals, possibly). XorRNG is slightly
+ * slower at generating 64-bit random data, including long and double, but not by
+ * a significant degree (a multiplier between 0.9 and 1.2 times). The only deciding
+ * factor then is state size, where LightRNG is as small as possible for any JVM
+ * object with even a single field: 16 bytes (on a 64-bit JVM; 8-byte objects with
+ * 4 bytes or less of non-static members may be possible on 32-bit JVMs but I can't
+ * find anything confirming that guess).
+ * <br>
+ * So yes, this should be very fast, and with only a single long used per LightRNG,
+ * it is about as memory-efficient as these generators get.
+ * <br>
+ * Written in 2015 by Sebastiano Vigna (vigna@acm.org)
+ * @author Sebastiano Vigna
+ * @author Tommy Ettinger
+ */
+public class LightRNG implements RandomnessSource, StatefulRandomness
+{
+	/** 2 raised to the 53, - 1. */
+    private static final long DOUBLE_MASK = ( 1L << 53 ) - 1;
+    /** 2 raised to the -53. */
+    private static final double NORM_53 = 1. / ( 1L << 53 );
+    /** 2 raised to the 24, -1. */
+    private static final long FLOAT_MASK = ( 1L << 24 ) - 1;
+    /** 2 raised to the -24. */
+    private static final double NORM_24 = 1. / ( 1L << 24 );
+
+    private static final long serialVersionUID = -374415589203474497L;
+
+    public long state; /* The state can be seeded with any value. */
+
+    /** Creates a new generator seeded using Math.random. */
+    public LightRNG() {
+        this((long) Math.floor(Math.random() * Long.MAX_VALUE));
+    }
+
+    public LightRNG( final long seed ) {
+        setSeed(seed);
+    }
+
+    @Override
+    public int next( int bits ) {
+        return (int)( nextLong() & ( 1L << bits ) - 1 );
+    }
+
+    /**
+     * Can return any long, positive or negative, of any size permissible in a 64-bit signed integer.
+     * @return any long, all 64 bits are random
+     */
+    @Override
+    public long nextLong() {
+        long z = ( state += 0x9E3779B97F4A7C15L );
+        z = (z ^ (z >>> 30)) * 0xBF58476D1CE4E5B9L;
+        z = (z ^ (z >>> 27)) * 0x94D049BB133111EBL;
+        return z ^ (z >>> 31);
+    }
+
+    /**
+     * Produces a copy of this RandomnessSource that, if next() and/or nextLong() are called on this object and the
+     * copy, both will generate the same sequence of random numbers from the point copy() was called. This just need to
+     * copy the state so it isn't shared, usually, and produce a new value with the same exact state.
+     *
+     * @return a copy of this RandomnessSource
+     */
+    @Override
+    public RandomnessSource copy() {
+        return new LightRNG(state);
+    }
+
+    /**
+     * Can return any int, positive or negative, of any size permissible in a 32-bit signed integer.
+     * @return any int, all 32 bits are random
+     */
+    public int nextInt() {
+        return (int)nextLong();
+    }
+
+    /**
+     * Exclusive on the upper bound.  The lower bound is 0.
+     * @param bound the upper bound; should be positive
+     * @return a random int less than n and at least equal to 0
+     */
+    public int nextInt( final int bound ) {
+        if ( bound <= 0 ) return 0;
+        int threshold = (0x7fffffff - bound + 1) % bound;
+        for (;;) {
+            int bits = (int)(nextLong() & 0x7fffffff);
+            if (bits >= threshold)
+                return bits % bound;
+        }
+    }
+    /**
+     * Inclusive lower, exclusive upper.
+     * @param lower the lower bound, inclusive, can be positive or negative
+     * @param upper the upper bound, exclusive, should be positive, must be greater than lower
+     * @return a random int at least equal to lower and less than upper
+     */
+    public int nextInt( final int lower, final int upper ) {
+        if ( upper - lower <= 0 ) throw new IllegalArgumentException("Upper bound must be greater than lower bound");
+        return lower + nextInt(upper - lower);
+    }
+
+    /**
+     * Exclusive on the upper bound. The lower bound is 0.
+     * @param bound the upper bound; should be positive
+     * @return a random long less than n
+     */
+    public long nextLong( final long bound ) {
+        if ( bound <= 0 ) return 0;
+        long threshold = (0x7fffffffffffffffL - bound + 1) % bound;
+        for (;;) {
+            long bits = nextLong() & 0x7fffffffffffffffL;
+            if (bits >= threshold)
+                return bits % bound;
+        }
+    }
+
+    /**
+     * Inclusive lower, exclusive upper.
+     * @param lower the lower bound, inclusive, can be positive or negative
+     * @param upper the upper bound, exclusive, should be positive, must be greater than lower
+     * @return a random long at least equal to lower and less than upper
+     */
+    public long nextLong( final long lower, final long upper ) {
+        if ( upper - lower <= 0 )  throw new IllegalArgumentException("Upper bound must be greater than lower bound");
+        return lower + nextLong(upper - lower);
+    }
+    /**
+     * Gets a uniform random double in the range [0.0,1.0)
+     * @return a random double at least equal to 0.0 and less than 1.0
+     */
+    public double nextDouble() {
+        return ( nextLong() & DOUBLE_MASK ) * NORM_53;
+    }
+
+    /**
+     * Gets a uniform random double in the range [0.0,outer) given a positive parameter outer. If outer
+     * is negative, it will be the (exclusive) lower bound and 0.0 will be the (inclusive) upper bound.
+     * @param outer the exclusive outer bound, can be negative
+     * @return a random double between 0.0 (inclusive) and outer (exclusive)
+     */
+    public double nextDouble(final double outer) {
+        return nextDouble() * outer;
+    }
+
+    /**
+     * Gets a uniform random float in the range [0.0,1.0)
+     * @return a random float at least equal to 0.0 and less than 1.0
+     */
+    public float nextFloat() {
+        return (float)( ( nextLong() & FLOAT_MASK ) * NORM_24 );
+    }
+
+    /**
+     * Gets a random value, true or false.
+     * Calls nextLong() once.
+     * @return a random true or false value.
+     */
+    public boolean nextBoolean() {
+        return ( nextLong() & 1 ) != 0L;
+    }
+
+    /**
+     * Given a byte array as a parameter, this will fill the array with random bytes (modifying it
+     * in-place). Calls nextLong() {@code Math.ceil(bytes.length / 8.0)} times.
+     * @param bytes a byte array that will have its contents overwritten with random bytes.
+     */
+    public void nextBytes( final byte[] bytes ) {
+        int i = bytes.length, n = 0;
+        while( i != 0 ) {
+            n = Math.min( i, 8 );
+            for ( long bits = nextLong(); n-- != 0; bits >>= 8 ) bytes[ --i ] = (byte)bits;
+        }
+    }
+
+
+
+    /**
+     * Sets the seed of this generator (which is also the current state).
+     * @param seed the seed to use for this LightRNG, as if it was constructed with this seed.
+     */
+    public void setSeed( final long seed ) {
+        state = seed;
+    }
+    /**
+     * Sets the seed (also the current state) of this generator.
+     * @param seed the seed to use for this LightRNG, as if it was constructed with this seed.
+     */
+    @Override
+    public void setState( final long seed ) {
+        state = seed;
+    }
+    /**
+     * Gets the current state of this generator.
+     * @return the current seed of this LightRNG, changed once per call to nextLong()
+     */
+    @Override
+    public long getState() {
+        return state;
+    }
+
+    /**
+     * Advances or rolls back the LightRNG's state without actually generating numbers. Skip forward
+     * or backward a number of steps specified by advance, where a step is equal to one call to nextInt().
+     * @param advance Number of future generations to skip past. Can be negative to backtrack.
+     * @return the state after skipping.
+     */
+    public long skip(long advance)
+    {
+        return state += 0x9E3779B97F4A7C15L * advance;
+    }
+
+    @Override
+    public String toString() {
+        return "LightRNG";
+    }
+
+}
\ No newline at end of file
diff --git a/src/main/java/org/torch/light/LightRandom.java b/src/main/java/org/torch/light/LightRandom.java
new file mode 100644
index 0000000..5793605
--- /dev/null
+++ b/src/main/java/org/torch/light/LightRandom.java
@@ -0,0 +1,55 @@
+package org.torch.light;
+
+import java.util.Random;
+
+/**
+ * This is a "fake" LightRandom, backed by the LightRNG.
+ * 
+ * This is useful if you want to quickly replace a Random variable with
+ * LightRNG without breaking every code.
+ */
+public class LightRandom extends Random {
+	public static LightRNG light = new LightRNG(); // LightRNG, static.
+	
+	private static final long serialVersionUID = 1L;
+
+	@Override
+	public int next(int bits) {
+		return light.next(bits);
+	}
+	
+	@Override
+	public void nextBytes(byte[] bytes) {
+		light.nextBytes(bytes);
+	}
+	
+	@Override
+	public int nextInt() {
+		return light.nextInt();
+	}
+	
+	@Override
+	public int nextInt(int n) {
+		return light.nextInt(n);
+	}
+	
+	@Override
+	public long nextLong() {
+		return light.nextLong();
+	}
+	
+	@Override
+	public boolean nextBoolean() {
+		return light.nextBoolean();
+	}
+	
+	@Override
+	public float nextFloat() {
+		return light.nextFloat();
+	}
+	
+	@Override
+	public double nextDouble() {
+		return light.nextDouble();
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/org/torch/light/RandomnessSource.java b/src/main/java/org/torch/light/RandomnessSource.java
new file mode 100644
index 0000000..5a3442a
--- /dev/null
+++ b/src/main/java/org/torch/light/RandomnessSource.java
@@ -0,0 +1,40 @@
+package org.torch.light;
+
+import java.io.Serializable;
+
+/**
+ * This interface defines the interactions required of a random number
+ * generator. It is a replacement for Java's built-in Random because for
+ * improved performance.
+ *
+ * @author Eben Howard - http://squidpony.com - howard@squidpony.com
+ */
+public interface RandomnessSource extends Serializable {
+
+    /**
+     * Using this method, any algorithm that might use the built-in Java Random
+     * can interface with this randomness source.
+     *
+     * @param bits the number of bits to be returned
+     * @return the integer containing the appropriate number of bits
+     */
+    int next(int bits);
+
+    /**
+     *
+     * Using this method, any algorithm that needs to efficiently generate more
+     * than 32 bits of random data can interface with this randomness source.
+     *
+     * Get a random long between Long.MIN_VALUE and Long.MAX_VALUE (both inclusive).
+     * @return a random long between Long.MIN_VALUE and Long.MAX_VALUE (both inclusive)
+     */
+    long nextLong();
+
+    /**
+     * Produces a copy of this RandomnessSource that, if next() and/or nextLong() are called on this object and the
+     * copy, both will generate the same sequence of random numbers from the point copy() was called. This just need to
+     * copy the state so it isn't shared, usually, and produce a new value with the same exact state.
+     * @return a copy of this RandomnessSource
+     */
+    RandomnessSource copy();
+}
\ No newline at end of file
diff --git a/src/main/java/org/torch/light/StatefulRandomness.java b/src/main/java/org/torch/light/StatefulRandomness.java
new file mode 100644
index 0000000..584caa9
--- /dev/null
+++ b/src/main/java/org/torch/light/StatefulRandomness.java
@@ -0,0 +1,20 @@
+package org.torch.light;
+
+/**
+ * A simple interface for RandomnessSources that have the additional property of a state that can be re-set.
+ * Created by Tommy Ettinger on 9/15/2015.
+ */
+public interface StatefulRandomness extends RandomnessSource {
+    /**
+     * Get the current internal state of the StatefulRandomness as a long.
+     * @return the current internal state of this object.
+     */
+    long getState();
+
+    /**
+     * Set the current internal state of this StatefulRandomness with a long.
+     *
+     * @param state a 64-bit long. You should avoid passing 0, even though some implementations can handle that.
+     */
+    void setState(long state);
+}
\ No newline at end of file
diff --git a/src/main/java/org/torch/network/AlwaysEmptyQueue.java b/src/main/java/org/torch/network/AlwaysEmptyQueue.java
new file mode 100644
index 0000000..5aea4d2
--- /dev/null
+++ b/src/main/java/org/torch/network/AlwaysEmptyQueue.java
@@ -0,0 +1,98 @@
+package org.torch.network;
+
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.Queue;
+
+public class AlwaysEmptyQueue<E> implements Queue<E> {
+
+	@Override
+	public int size() {
+		return 0;
+	}
+
+	@Override
+	public boolean isEmpty() {
+		return true;
+	}
+
+	@Override
+	public void clear() {
+	}
+
+	@Override
+	public boolean add(E e) {
+		return false;
+	}
+
+	@Override
+	public boolean contains(Object o) {
+		throw new UnsupportedOperationException();
+	}
+
+	@Override
+	public Iterator<E> iterator() {
+		throw new UnsupportedOperationException();
+	}
+
+	@Override
+	public Object[] toArray() {
+		throw new UnsupportedOperationException();
+	}
+
+	@Override
+	public <T> T[] toArray(T[] a) {
+		throw new UnsupportedOperationException();
+	}
+
+	@Override
+	public boolean remove(Object o) {
+		throw new UnsupportedOperationException();
+	}
+
+	@Override
+	public boolean containsAll(Collection<?> c) {
+		throw new UnsupportedOperationException();
+	}
+
+	@Override
+	public boolean addAll(Collection<? extends E> c) {
+		throw new UnsupportedOperationException();
+	}
+
+	@Override
+	public boolean removeAll(Collection<?> c) {
+		throw new UnsupportedOperationException();
+	}
+
+	@Override
+	public boolean retainAll(Collection<?> c) {
+		throw new UnsupportedOperationException();
+	}
+
+	@Override
+	public boolean offer(E e) {
+		throw new UnsupportedOperationException();
+	}
+
+	@Override
+	public E remove() {
+		throw new UnsupportedOperationException();
+	}
+
+	@Override
+	public E poll() {
+		throw new UnsupportedOperationException();
+	}
+
+	@Override
+	public E element() {
+		throw new UnsupportedOperationException();
+	}
+
+	@Override
+	public E peek() {
+		throw new UnsupportedOperationException();
+	}
+
+}
diff --git a/src/main/java/org/torch/network/FakeReadWriteLock.java b/src/main/java/org/torch/network/FakeReadWriteLock.java
new file mode 100644
index 0000000..f6af12d
--- /dev/null
+++ b/src/main/java/org/torch/network/FakeReadWriteLock.java
@@ -0,0 +1,56 @@
+package org.torch.network;
+
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+public class FakeReadWriteLock extends ReentrantReadWriteLock {
+
+	private static final long serialVersionUID = 1L;
+
+	private final FakeReadLock fakereadlock = new FakeReadLock(this);
+	private final FakeWriteLock fakewritelock = new FakeWriteLock(this);
+
+	@Override
+	public ReadLock readLock() {
+		return fakereadlock;
+	}
+
+	@Override
+	public WriteLock writeLock() {
+		return fakewritelock;
+	}
+
+	public static class FakeReadLock extends ReadLock {
+		private static final long serialVersionUID = 1L;
+
+		protected FakeReadLock(ReentrantReadWriteLock lock) {
+			super(lock);
+		}
+
+		@Override
+		public void lock() {
+		}
+
+		@Override
+		public void unlock() {
+		}
+		
+	}
+
+	public static class FakeWriteLock extends WriteLock {
+		private static final long serialVersionUID = 1L;
+
+		protected FakeWriteLock(ReentrantReadWriteLock lock) {
+			super(lock);
+		}
+
+		@Override
+		public void lock() {
+		}
+
+		@Override
+		public void unlock() {
+		}
+		
+	}
+
+}
diff --git a/src/main/java/org/torch/usercache/DualCache.java b/src/main/java/org/torch/usercache/DualCache.java
new file mode 100644
index 0000000..4ff1df7
--- /dev/null
+++ b/src/main/java/org/torch/usercache/DualCache.java
@@ -0,0 +1,178 @@
+package org.torch.usercache;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock;
+
+public class DualCache<PK, SK, V> {
+
+	private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
+	private final ReadLock rlock = lock.readLock();
+	private final WriteLock wlock = lock.writeLock();
+
+	private final long validtime;
+	private final int limit;
+
+	private final Map<PK, DualCacheEntry<PK, SK, V>> primary;
+	private final Map<SK, DualCacheEntry<PK, SK, V>> secondary;
+
+	public DualCache(int limit, long validtime) {
+		this.limit = limit;
+		this.validtime = validtime;
+		int size = (int) (limit * 1.5);
+		primary = new LinkedHashMap<>(size, 0.75F, true);
+		secondary = new HashMap<>(size);
+	}
+
+	public V getByPrimaryKey(Object primaryKey) {
+		rlock.lock();
+		try {
+			DualCacheEntry<PK, SK, V> entry = primary.get(primaryKey);
+			return entry != null ? entry.value : null;
+		} finally {
+			rlock.unlock();
+		}
+	}
+
+	public V getBySecondaryKey(Object secondaryKey) {
+		DualCacheEntry<PK, SK, V> entry = null;
+		rlock.lock();
+		try {
+			entry = secondary.get(secondaryKey);
+		} finally {
+			rlock.unlock();
+		}
+		if (entry != null) {
+			if (System.currentTimeMillis() > entry.expiretime) {
+				remove(entry.pk);
+				return null;
+			}
+			if (entry != null) {
+				getByPrimaryKey(entry.pk);
+			}
+		}
+		return entry != null ? entry.value : null;
+	}
+
+	public void put(PK primaryKey, SK secondaryKey, V value) {
+		wlock.lock();
+		try {
+			DualCacheEntry<PK, SK, V> oldEntry = primary.get(primaryKey);
+			if (oldEntry != null) {
+				secondary.remove(oldEntry.sk);
+			}
+			DualCacheEntry<PK, SK, V> newEntry = new DualCacheEntry<>(primaryKey, secondaryKey, value, System.currentTimeMillis() + validtime);
+			primary.put(primaryKey, newEntry);
+			secondary.put(secondaryKey, newEntry);
+			if (primary.size() > limit) {
+				remove(primary.keySet().iterator().next());
+			}
+		} finally {
+			wlock.unlock();
+		}
+	}
+
+	public void remove(Object primaryKey) {
+		wlock.lock();
+		try {
+			DualCacheEntry<PK, SK, V> entry = primary.remove(primaryKey);
+			if (entry != null) {
+				secondary.remove(entry.sk);
+			}
+		} finally {
+			wlock.unlock();
+		}
+	}
+
+	public List<PK> getPrimaryKeys() {
+		rlock.lock();
+		try {
+			return new ArrayList<>(primary.keySet());
+		} finally {
+			rlock.unlock();
+		}
+	}
+
+	public List<SK> getSecondaryKeys() {
+		rlock.lock();
+		try {
+			return new ArrayList<>(secondary.keySet());
+		} finally {
+			rlock.unlock();
+		}
+	}
+
+	public void clear() {
+		wlock.lock();
+		try {
+			primary.clear();
+			secondary.clear();
+		} finally {
+			wlock.unlock();
+		}
+	}
+
+	public void putLoaded(PK primaryKey, SK secondaryKey, V value, long expiretime) {
+		wlock.lock();
+		try {
+			DualCacheEntry<PK, SK, V> newEntry = new DualCacheEntry<>(primaryKey, secondaryKey, value, System.currentTimeMillis() + expiretime);
+			primary.put(primaryKey, newEntry);
+			secondary.put(secondaryKey, newEntry);
+		} finally {
+			wlock.unlock();
+		}
+	}
+
+	public List<DualCacheEntry<PK, SK, V>> getEntries() {
+		rlock.lock();
+		try {
+			return new ArrayList<>(primary.values());
+		} finally {
+			rlock.unlock();
+		}
+	}
+
+	public static class DualCacheEntry<PK, SK, V> {
+		protected PK pk;
+		protected SK sk;
+		protected V value;
+		protected long expiretime;
+		public DualCacheEntry(PK pk, SK sk, V v, long expiretime) {
+			this.pk = pk;
+			this.sk = sk;
+			this.value = v;
+			this.expiretime = expiretime;
+		}
+
+		public PK getPrimaryKey() {
+			return pk;
+		}
+
+		public SK getSecondaryKey() {
+			return sk;
+		}
+
+		public V getValue() {
+			return value;
+		}
+
+		public long getExpireDate() {
+			return expiretime;
+		}
+
+		@Override
+		public String toString() {
+			return
+			"PK: "+getPrimaryKey()+", "+
+			"SK: "+getSecondaryKey()+", "+
+			"Expire: "+getExpireDate()+", "+
+			"Value: "+getValue();
+		}
+	}
+
+}
diff --git a/src/main/java/org/torch/usercache/GameProfileLookup.java b/src/main/java/org/torch/usercache/GameProfileLookup.java
new file mode 100644
index 0000000..cfb95ec
--- /dev/null
+++ b/src/main/java/org/torch/usercache/GameProfileLookup.java
@@ -0,0 +1,24 @@
+package org.torch.usercache;
+
+import com.mojang.authlib.GameProfile;
+import com.mojang.authlib.ProfileLookupCallback;
+
+public class GameProfileLookup implements ProfileLookupCallback {
+
+	private GameProfile[] gameProfileHolderArray;
+
+	public GameProfileLookup(GameProfile[] gameProfileHolderArray) {
+		this.gameProfileHolderArray = gameProfileHolderArray;
+	}
+
+	@Override
+	public void onProfileLookupFailed(GameProfile profile, Exception exception) {
+		this.gameProfileHolderArray[0] = null;
+	}
+
+	@Override
+	public void onProfileLookupSucceeded(GameProfile profile) {
+		this.gameProfileHolderArray[0] = profile;
+	}
+
+}
diff --git a/src/main/java/org/torch/usercache/UserCacheEntryJsonSerializer.java b/src/main/java/org/torch/usercache/UserCacheEntryJsonSerializer.java
new file mode 100644
index 0000000..fb17336
--- /dev/null
+++ b/src/main/java/org/torch/usercache/UserCacheEntryJsonSerializer.java
@@ -0,0 +1,67 @@
+package org.torch.usercache;
+
+import java.lang.reflect.Type;
+import java.text.ParseException;
+import java.util.Date;
+import java.util.UUID;
+
+import net.minecraft.server.UserCache;
+
+import com.google.gson.JsonDeserializationContext;
+import com.google.gson.JsonDeserializer;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonParseException;
+import com.google.gson.JsonSerializationContext;
+import com.google.gson.JsonSerializer;
+import com.mojang.authlib.GameProfile;
+
+public class UserCacheEntryJsonSerializer implements JsonDeserializer<UserCacheFileEntry>, JsonSerializer<UserCacheFileEntry> {
+
+	@Override
+	public JsonElement serialize(UserCacheFileEntry entry, Type type, JsonSerializationContext ctx) {
+		JsonObject jsonobject = new JsonObject();
+		jsonobject.addProperty("name", entry.getProfile().getName());
+		UUID uuid = entry.getProfile().getId();
+		jsonobject.addProperty("uuid", uuid == null ? "" : uuid.toString());
+		jsonobject.addProperty("expiresOn", UserCache.a.format(entry.getExpireDate()));
+		return jsonobject;
+	}
+
+	@Override
+	public UserCacheFileEntry deserialize(JsonElement element, Type type, JsonDeserializationContext ctx) throws JsonParseException {
+		if (element.isJsonObject()) {
+			JsonObject jsonobject = element.getAsJsonObject();
+			JsonElement nameElement = jsonobject.get("name");
+			JsonElement uuidElement = jsonobject.get("uuid");
+			JsonElement expireDateElement = jsonobject.get("expiresOn");
+			if ((nameElement != null) && (uuidElement != null)) {
+				String name = uuidElement.getAsString();
+				String uuidstring = nameElement.getAsString();
+				Date date = null;
+				if (expireDateElement != null) {
+					try {
+						date = UserCache.a.parse(expireDateElement.getAsString());
+					} catch (ParseException parseexception) {
+						date = null;
+					}
+				}
+				if ((uuidstring != null) && (name != null)) {
+					UUID uuid;
+					try {
+						uuid = UUID.fromString(name);
+					} catch (Throwable throwable) {
+						return null;
+					}
+					UserCacheFileEntry usercacheentry = new UserCacheFileEntry(new GameProfile(uuid, uuidstring), date);
+
+					return usercacheentry;
+				}
+				return null;
+			}
+			return null;
+		}
+		return null;
+	}
+
+}
diff --git a/src/main/java/org/torch/usercache/UserCacheEntryType.java b/src/main/java/org/torch/usercache/UserCacheEntryType.java
new file mode 100644
index 0000000..acce721
--- /dev/null
+++ b/src/main/java/org/torch/usercache/UserCacheEntryType.java
@@ -0,0 +1,26 @@
+package org.torch.usercache;
+
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.util.List;
+
+public class UserCacheEntryType implements ParameterizedType {
+
+	@Override
+	public Type[] getActualTypeArguments() {
+		return new Type[] {
+			UserCacheFileEntry.class
+		};
+	}
+
+	@Override
+	public Type getRawType() {
+		return List.class;
+	}
+
+	@Override
+	public Type getOwnerType() {
+		return null;
+	}
+
+}
diff --git a/src/main/java/org/torch/usercache/UserCacheFileEntry.java b/src/main/java/org/torch/usercache/UserCacheFileEntry.java
new file mode 100644
index 0000000..2ea3226
--- /dev/null
+++ b/src/main/java/org/torch/usercache/UserCacheFileEntry.java
@@ -0,0 +1,25 @@
+package org.torch.usercache;
+
+import java.util.Date;
+
+import com.mojang.authlib.GameProfile;
+
+public class UserCacheFileEntry {
+
+	private GameProfile profile;
+	private Date expireDate;
+
+	public UserCacheFileEntry(GameProfile profile, Date date) {
+		this.profile = profile;
+		this.expireDate = date;
+	}
+
+	public long getExpireDate() {
+		return expireDate.getTime();
+	}
+
+	public GameProfile getProfile() {
+		return profile;
+	}
+
+}
diff --git a/src/main/java/org/torch/utils/LightRNG.java b/src/main/java/org/torch/utils/LightRNG.java
deleted file mode 100644
index 656ec2d..0000000
--- a/src/main/java/org/torch/utils/LightRNG.java
+++ /dev/null
@@ -1,240 +0,0 @@
-/*
-Written in 2015 by Sebastiano Vigna (vigna@acm.org)
-
-To the extent possible under law, the author has dedicated all copyright
-and related and neighboring rights to this software to the public domain
-worldwide. This software is distributed without any warranty.
-
-See <http://creativecommons.org/publicdomain/zero/1.0/>. */
-package org.torch.utils;
-
-/**
- * This is a SplittableRandom-style generator, meant to have a tiny state
- * that permits storing many different generators with low overhead.
- * It should be rather fast, though no guarantees can be made on all hardware.
- * <br>
- * Benchmarking on a Windows laptop with an i7-4700MQ processor running OpenJDK 8
- * reports generation of 64-bit random long output as 17.8x faster than generating
- * an equivalent number of random longs with java.util.Random, and generation of
- * 32-bit random int output as 9.8x faster. Specifically, generating 1 billion longs
- * took about 1.28 nanoseconds per long (1.277 seconds for the whole group) with
- * LightRNG, while java.util.Random (which is meant to produce int, to be fair) took
- * about 22.8 nanoseconds per long (22.797 seconds for the whole group). XorRNG
- * appears to be occasionally faster on int output than LightRNG, but it isn't clear
- * why or what causes that (JIT or GC internals, possibly). XorRNG is slightly
- * slower at generating 64-bit random data, including long and double, but not by
- * a significant degree (a multiplier between 0.9 and 1.2 times). The only deciding
- * factor then is state size, where LightRNG is as small as possible for any JVM
- * object with even a single field: 16 bytes (on a 64-bit JVM; 8-byte objects with
- * 4 bytes or less of non-static members may be possible on 32-bit JVMs but I can't
- * find anything confirming that guess).
- * <br>
- * So yes, this should be very fast, and with only a single long used per LightRNG,
- * it is about as memory-efficient as these generators get.
- * <br>
- * Written in 2015 by Sebastiano Vigna (vigna@acm.org)
- * @author Sebastiano Vigna
- * @author Tommy Ettinger
- */
-public class LightRNG implements RandomnessSource, StatefulRandomness
-{
-	/** 2 raised to the 53, - 1. */
-    private static final long DOUBLE_MASK = ( 1L << 53 ) - 1;
-    /** 2 raised to the -53. */
-    private static final double NORM_53 = 1. / ( 1L << 53 );
-    /** 2 raised to the 24, -1. */
-    private static final long FLOAT_MASK = ( 1L << 24 ) - 1;
-    /** 2 raised to the -24. */
-    private static final double NORM_24 = 1. / ( 1L << 24 );
-
-    private static final long serialVersionUID = -374415589203474497L;
-
-    public long state; /* The state can be seeded with any value. */
-
-    /** Creates a new generator seeded using Math.random. */
-    public LightRNG() {
-        this((long) Math.floor(Math.random() * Long.MAX_VALUE));
-    }
-
-    public LightRNG( final long seed ) {
-        setSeed(seed);
-    }
-
-    @Override
-    public int next( int bits ) {
-        return (int)( nextLong() & ( 1L << bits ) - 1 );
-    }
-
-    /**
-     * Can return any long, positive or negative, of any size permissible in a 64-bit signed integer.
-     * @return any long, all 64 bits are random
-     */
-    @Override
-    public long nextLong() {
-        long z = ( state += 0x9E3779B97F4A7C15L );
-        z = (z ^ (z >>> 30)) * 0xBF58476D1CE4E5B9L;
-        z = (z ^ (z >>> 27)) * 0x94D049BB133111EBL;
-        return z ^ (z >>> 31);
-    }
-
-    /**
-     * Produces a copy of this RandomnessSource that, if next() and/or nextLong() are called on this object and the
-     * copy, both will generate the same sequence of random numbers from the point copy() was called. This just need to
-     * copy the state so it isn't shared, usually, and produce a new value with the same exact state.
-     *
-     * @return a copy of this RandomnessSource
-     */
-    @Override
-    public RandomnessSource copy() {
-        return new LightRNG(state);
-    }
-
-    /**
-     * Can return any int, positive or negative, of any size permissible in a 32-bit signed integer.
-     * @return any int, all 32 bits are random
-     */
-    public int nextInt() {
-        return (int)nextLong();
-    }
-
-    /**
-     * Exclusive on the upper bound.  The lower bound is 0.
-     * @param bound the upper bound; should be positive
-     * @return a random int less than n and at least equal to 0
-     */
-    public int nextInt( final int bound ) {
-        if ( bound <= 0 ) return 0;
-        int threshold = (0x7fffffff - bound + 1) % bound;
-        for (;;) {
-            int bits = (int)(nextLong() & 0x7fffffff);
-            if (bits >= threshold)
-                return bits % bound;
-        }
-    }
-    /**
-     * Inclusive lower, exclusive upper.
-     * @param lower the lower bound, inclusive, can be positive or negative
-     * @param upper the upper bound, exclusive, should be positive, must be greater than lower
-     * @return a random int at least equal to lower and less than upper
-     */
-    public int nextInt( final int lower, final int upper ) {
-        if ( upper - lower <= 0 ) throw new IllegalArgumentException("Upper bound must be greater than lower bound");
-        return lower + nextInt(upper - lower);
-    }
-
-    /**
-     * Exclusive on the upper bound. The lower bound is 0.
-     * @param bound the upper bound; should be positive
-     * @return a random long less than n
-     */
-    public long nextLong( final long bound ) {
-        if ( bound <= 0 ) return 0;
-        long threshold = (0x7fffffffffffffffL - bound + 1) % bound;
-        for (;;) {
-            long bits = nextLong() & 0x7fffffffffffffffL;
-            if (bits >= threshold)
-                return bits % bound;
-        }
-    }
-
-    /**
-     * Inclusive lower, exclusive upper.
-     * @param lower the lower bound, inclusive, can be positive or negative
-     * @param upper the upper bound, exclusive, should be positive, must be greater than lower
-     * @return a random long at least equal to lower and less than upper
-     */
-    public long nextLong( final long lower, final long upper ) {
-        if ( upper - lower <= 0 )  throw new IllegalArgumentException("Upper bound must be greater than lower bound");
-        return lower + nextLong(upper - lower);
-    }
-    /**
-     * Gets a uniform random double in the range [0.0,1.0)
-     * @return a random double at least equal to 0.0 and less than 1.0
-     */
-    public double nextDouble() {
-        return ( nextLong() & DOUBLE_MASK ) * NORM_53;
-    }
-
-    /**
-     * Gets a uniform random double in the range [0.0,outer) given a positive parameter outer. If outer
-     * is negative, it will be the (exclusive) lower bound and 0.0 will be the (inclusive) upper bound.
-     * @param outer the exclusive outer bound, can be negative
-     * @return a random double between 0.0 (inclusive) and outer (exclusive)
-     */
-    public double nextDouble(final double outer) {
-        return nextDouble() * outer;
-    }
-
-    /**
-     * Gets a uniform random float in the range [0.0,1.0)
-     * @return a random float at least equal to 0.0 and less than 1.0
-     */
-    public float nextFloat() {
-        return (float)( ( nextLong() & FLOAT_MASK ) * NORM_24 );
-    }
-
-    /**
-     * Gets a random value, true or false.
-     * Calls nextLong() once.
-     * @return a random true or false value.
-     */
-    public boolean nextBoolean() {
-        return ( nextLong() & 1 ) != 0L;
-    }
-
-    /**
-     * Given a byte array as a parameter, this will fill the array with random bytes (modifying it
-     * in-place). Calls nextLong() {@code Math.ceil(bytes.length / 8.0)} times.
-     * @param bytes a byte array that will have its contents overwritten with random bytes.
-     */
-    public void nextBytes( final byte[] bytes ) {
-        int i = bytes.length, n = 0;
-        while( i != 0 ) {
-            n = Math.min( i, 8 );
-            for ( long bits = nextLong(); n-- != 0; bits >>= 8 ) bytes[ --i ] = (byte)bits;
-        }
-    }
-
-
-
-    /**
-     * Sets the seed of this generator (which is also the current state).
-     * @param seed the seed to use for this LightRNG, as if it was constructed with this seed.
-     */
-    public void setSeed( final long seed ) {
-        state = seed;
-    }
-    /**
-     * Sets the seed (also the current state) of this generator.
-     * @param seed the seed to use for this LightRNG, as if it was constructed with this seed.
-     */
-    @Override
-    public void setState( final long seed ) {
-        state = seed;
-    }
-    /**
-     * Gets the current state of this generator.
-     * @return the current seed of this LightRNG, changed once per call to nextLong()
-     */
-    @Override
-    public long getState() {
-        return state;
-    }
-
-    /**
-     * Advances or rolls back the LightRNG's state without actually generating numbers. Skip forward
-     * or backward a number of steps specified by advance, where a step is equal to one call to nextInt().
-     * @param advance Number of future generations to skip past. Can be negative to backtrack.
-     * @return the state after skipping.
-     */
-    public long skip(long advance)
-    {
-        return state += 0x9E3779B97F4A7C15L * advance;
-    }
-
-    @Override
-    public String toString() {
-        return "LightRNG";
-    }
-
-}
\ No newline at end of file
diff --git a/src/main/java/org/torch/utils/LightRandom.java b/src/main/java/org/torch/utils/LightRandom.java
deleted file mode 100644
index ed238ca..0000000
--- a/src/main/java/org/torch/utils/LightRandom.java
+++ /dev/null
@@ -1,55 +0,0 @@
-package org.torch.utils;
-
-import java.util.Random;
-
-/**
- * This is a "fake" LightRandom, backed by the LightRNG.
- * 
- * This is useful if you want to quickly replace a Random variable with
- * LightRNG without breaking every code.
- */
-public class LightRandom extends Random {
-	public static LightRNG light = new LightRNG(); // LightRNG, static.
-	
-	private static final long serialVersionUID = 1L;
-
-	@Override
-	public int next(int bits) {
-		return light.next(bits);
-	}
-	
-	@Override
-	public void nextBytes(byte[] bytes) {
-		light.nextBytes(bytes);
-	}
-	
-	@Override
-	public int nextInt() {
-		return light.nextInt();
-	}
-	
-	@Override
-	public int nextInt(int n) {
-		return light.nextInt(n);
-	}
-	
-	@Override
-	public long nextLong() {
-		return light.nextLong();
-	}
-	
-	@Override
-	public boolean nextBoolean() {
-		return light.nextBoolean();
-	}
-	
-	@Override
-	public float nextFloat() {
-		return light.nextFloat();
-	}
-	
-	@Override
-	public double nextDouble() {
-		return light.nextDouble();
-	}
-}
\ No newline at end of file
diff --git a/src/main/java/org/torch/utils/RandomnessSource.java b/src/main/java/org/torch/utils/RandomnessSource.java
deleted file mode 100644
index ca622aa..0000000
--- a/src/main/java/org/torch/utils/RandomnessSource.java
+++ /dev/null
@@ -1,40 +0,0 @@
-package org.torch.utils;
-
-import java.io.Serializable;
-
-/**
- * This interface defines the interactions required of a random number
- * generator. It is a replacement for Java's built-in Random because for
- * improved performance.
- *
- * @author Eben Howard - http://squidpony.com - howard@squidpony.com
- */
-public interface RandomnessSource extends Serializable {
-
-    /**
-     * Using this method, any algorithm that might use the built-in Java Random
-     * can interface with this randomness source.
-     *
-     * @param bits the number of bits to be returned
-     * @return the integer containing the appropriate number of bits
-     */
-    int next(int bits);
-
-    /**
-     *
-     * Using this method, any algorithm that needs to efficiently generate more
-     * than 32 bits of random data can interface with this randomness source.
-     *
-     * Get a random long between Long.MIN_VALUE and Long.MAX_VALUE (both inclusive).
-     * @return a random long between Long.MIN_VALUE and Long.MAX_VALUE (both inclusive)
-     */
-    long nextLong();
-
-    /**
-     * Produces a copy of this RandomnessSource that, if next() and/or nextLong() are called on this object and the
-     * copy, both will generate the same sequence of random numbers from the point copy() was called. This just need to
-     * copy the state so it isn't shared, usually, and produce a new value with the same exact state.
-     * @return a copy of this RandomnessSource
-     */
-    RandomnessSource copy();
-}
\ No newline at end of file
diff --git a/src/main/java/org/torch/utils/StatefulRandomness.java b/src/main/java/org/torch/utils/StatefulRandomness.java
deleted file mode 100644
index 27ba0dd..0000000
--- a/src/main/java/org/torch/utils/StatefulRandomness.java
+++ /dev/null
@@ -1,20 +0,0 @@
-package org.torch.utils;
-
-/**
- * A simple interface for RandomnessSources that have the additional property of a state that can be re-set.
- * Created by Tommy Ettinger on 9/15/2015.
- */
-public interface StatefulRandomness extends RandomnessSource {
-    /**
-     * Get the current internal state of the StatefulRandomness as a long.
-     * @return the current internal state of this object.
-     */
-    long getState();
-
-    /**
-     * Set the current internal state of this StatefulRandomness with a long.
-     *
-     * @param state a 64-bit long. You should avoid passing 0, even though some implementations can handle that.
-     */
-    void setState(long state);
-}
\ No newline at end of file
-- 
2.8.2.windows.1

