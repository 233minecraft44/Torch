From 7a694bdd6805adfdbdae996fe3bae6be393e19dd Mon Sep 17 00:00:00 2001
From: SotrForgotten <i@omc.hk>
Date: Fri, 15 Jul 2016 17:28:24 +0800
Subject: [PATCH] Fix async pathfinding


diff --git a/src/main/java/com/destroystokyo/paper/PaperConfig.java b/src/main/java/com/destroystokyo/paper/PaperConfig.java
index 3bc91a2..b4904ef 100644
--- a/src/main/java/com/destroystokyo/paper/PaperConfig.java
+++ b/src/main/java/com/destroystokyo/paper/PaperConfig.java
@@ -222,14 +222,14 @@ public class PaperConfig {
         regionFileCacheSize = getInt("settings.region-file-cache-size", 256);
     }
 	
-	public static boolean usePaperIO = false;
+	public static boolean usePaperIO = true;
     public static int paperIORegionFileCacheSize = 256;
     public static int paperIOAsyncChunkSaveQueueSize = -1;
     public static int paperIOAsyncChunkSaveQueueThreads = 2;
     public static boolean paperIODeleteCorruptChunks = true;
     public static boolean paperIOStats = true;
     private static void paperIO() {
-        usePaperIO = getBoolean("paper-io.enabled", false);
+        usePaperIO = getBoolean("paper-io.enabled", true);
         // Region file cache size (per world). 
         // TODO: Move to world settings.
         paperIORegionFileCacheSize = getInt("paper-io.region-file-cache-size", 256);
diff --git a/src/main/java/de/minetick/pathsearch/MigotNavigation.java b/src/main/java/de/minetick/pathsearch/MigotNavigation.java
index 0c9f53c..a86939b 100644
--- a/src/main/java/de/minetick/pathsearch/MigotNavigation.java
+++ b/src/main/java/de/minetick/pathsearch/MigotNavigation.java
@@ -96,7 +96,7 @@ public class MigotNavigation extends Navigation {
 
     @Override
     public PathEntity a(Entity entity) {
-        if(!this.offloadSearches() || this.b.h(entity) < minimumDistanceForOffloadingSquared) {
+        if(!this.offloadSearches() || this.a.h(entity) < minimumDistanceForOffloadingSquared) { // Torch
             return super.a(entity);
         }
         if(!this.b()) {
@@ -119,7 +119,7 @@ public class MigotNavigation extends Navigation {
         if(entry == null && !this.hasAsyncSearchIssued()) {
             resultPath = super.a(entity);
             if(resultPath != null) {
-                entry = new SearchCacheEntryEntity(this.b, entity, resultPath);
+                entry = new SearchCacheEntryEntity(this.a, entity, resultPath); // Torch
                 synchronized(this.searchCache) {
                     SearchCacheEntry oldEntry = this.searchCache.put(id, entry);
                     if(oldEntry != null) {
@@ -137,7 +137,7 @@ public class MigotNavigation extends Navigation {
     }
 
     public PathEntity a(BlockPosition blockposition, PositionPathSearchType type) {
-        if(!this.offloadSearches() || this.b.c(blockposition) < minimumDistanceForOffloadingSquared) {
+        if(!this.offloadSearches() || this.a.c(blockposition) < minimumDistanceForOffloadingSquared) { // Torch
             return super.a(blockposition);
         }
         if(!this.b()) {
@@ -161,7 +161,7 @@ public class MigotNavigation extends Navigation {
         if(entry == null && !this.hasAsyncSearchIssued()) {
             resultPath = super.a(blockposition);
             if(resultPath != null) {
-                entry = new SearchCacheEntryPosition(this.b, blockposition, resultPath);
+                entry = new SearchCacheEntryPosition(this.a, blockposition, resultPath); // Torch
                 synchronized(this.positionSearchCache) {
                     SearchCacheEntry oldEntry = this.positionSearchCache.put(type, entry);
                     if(oldEntry != null) {
@@ -217,6 +217,6 @@ public class MigotNavigation extends Navigation {
     }
 
     private boolean offloadSearches() {
-        return Migot.getConfig().isPathSearchOffloadedFor(this.b);
+        return Migot.getConfig().isPathSearchOffloadedFor(this.a); // Torch
     }
 }
\ No newline at end of file
diff --git a/src/main/java/net/minecraft/server/BlockDragonEgg.java b/src/main/java/net/minecraft/server/BlockDragonEgg.java
index 1c3a4be..1578988 100644
--- a/src/main/java/net/minecraft/server/BlockDragonEgg.java
+++ b/src/main/java/net/minecraft/server/BlockDragonEgg.java
@@ -33,7 +33,7 @@ public class BlockDragonEgg extends Block {
         if (BlockFalling.i(world.getType(blockposition.down())) && blockposition.getY() >= 0) {
             byte b0 = 32;
 
-            if (!world.instantBlockFall && world.areChunksLoadedBetween(blockposition.a(-b0, -b0, -b0), blockposition.a(b0, b0, b0))) { // Migot
+            if (!BlockFalling.instaFall && world.areChunksLoadedBetween(blockposition.a(-b0, -b0, -b0), blockposition.a(b0, b0, b0))) {
                 world.addEntity(new EntityFallingBlock(world, (double) ((float) blockposition.getX() + 0.5F), (double) blockposition.getY(), (double) ((float) blockposition.getZ() + 0.5F), this.getBlockData()));
             } else {
                 world.setAir(blockposition);
diff --git a/src/main/java/net/minecraft/server/BlockFalling.java b/src/main/java/net/minecraft/server/BlockFalling.java
index 2610aea..8df2976 100644
--- a/src/main/java/net/minecraft/server/BlockFalling.java
+++ b/src/main/java/net/minecraft/server/BlockFalling.java
@@ -4,7 +4,7 @@ import java.util.Random;
 
 public class BlockFalling extends Block {
 
-    // public static boolean instaFall;
+    public static boolean instaFall;
 
     public BlockFalling() {
         super(Material.SAND);
@@ -34,7 +34,7 @@ public class BlockFalling extends Block {
         if (i(world.getType(blockposition.down())) && blockposition.getY() >= 0) {
             byte b0 = 32;
 
-            if (!world.instantBlockFall && world.areChunksLoadedBetween(blockposition.a(-b0, -b0, -b0), blockposition.a(b0, b0, b0))) { // Migot
+            if (!BlockFalling.instaFall && world.areChunksLoadedBetween(blockposition.a(-b0, -b0, -b0), blockposition.a(b0, b0, b0))) { // Migot
                 if (!world.isClientSide) {
                     EntityFallingBlock entityfallingblock = new EntityFallingBlock(world, (double) blockposition.getX() + 0.5D, (double) blockposition.getY(), (double) blockposition.getZ() + 0.5D, world.getType(blockposition));
 
diff --git a/src/main/java/net/minecraft/server/ChunkProviderGenerate.java b/src/main/java/net/minecraft/server/ChunkProviderGenerate.java
index 40ba59e..534fd9f 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderGenerate.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderGenerate.java
@@ -303,7 +303,7 @@ public class ChunkProviderGenerate implements ChunkGenerator {
     }
 
     public void recreateStructures(int i, int j) {
-        this.n.instantBlockFall = true; // Migot
+        BlockFalling.instaFall = true;
         int k = i * 16;
         int l = j * 16;
         BlockPosition blockposition = new BlockPosition(k, 0, l);
@@ -388,7 +388,7 @@ public class ChunkProviderGenerate implements ChunkGenerator {
             }
         }
 
-        this.n.instantBlockFall = false; // Migot
+        BlockFalling.instaFall = false;
     }
 
     public boolean a(Chunk chunk, int i, int j) {
diff --git a/src/main/java/net/minecraft/server/ChunkProviderHell.java b/src/main/java/net/minecraft/server/ChunkProviderHell.java
index b876e8e..e523afa 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderHell.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderHell.java
@@ -297,7 +297,7 @@ public class ChunkProviderHell implements ChunkGenerator {
     }
 
     public void recreateStructures(int i, int j) {
-        this.n.instantBlockFall = true; // Migot
+        BlockFalling.instaFall = true;
         BlockPosition blockposition = new BlockPosition(i * 16, 0, j * 16);
         ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(i, j);
 
@@ -337,7 +337,7 @@ public class ChunkProviderHell implements ChunkGenerator {
             this.D.generate(this.n, this.p, blockposition.a(this.p.nextInt(16), this.p.nextInt(108) + 10, this.p.nextInt(16)));
         }
 
-        this.n.instantBlockFall = false; // Migot
+        BlockFalling.instaFall = false;
     }
 
     public boolean a(Chunk chunk, int i, int j) {
diff --git a/src/main/java/net/minecraft/server/ChunkProviderTheEnd.java b/src/main/java/net/minecraft/server/ChunkProviderTheEnd.java
index 65bc6e5..c08c743 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderTheEnd.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderTheEnd.java
@@ -267,7 +267,7 @@ public class ChunkProviderTheEnd implements ChunkGenerator {
     }
 
     public void recreateStructures(int i, int j) {
-        this.l.instantBlockFall = true; // Migot
+        BlockFalling.instaFall = true;
         BlockPosition blockposition = new BlockPosition(i * 16, 0, j * 16);
 
         if (this.m) {
@@ -306,7 +306,7 @@ public class ChunkProviderTheEnd implements ChunkGenerator {
             }
         }
 
-        this.l.instantBlockFall = false; // Migot
+        BlockFalling.instaFall = false;
     }
 
     public boolean a(Chunk chunk, int i, int j) {
diff --git a/src/main/java/net/minecraft/server/Entity.java b/src/main/java/net/minecraft/server/Entity.java
index d344a69..237167e 100644
--- a/src/main/java/net/minecraft/server/Entity.java
+++ b/src/main/java/net/minecraft/server/Entity.java
@@ -1453,15 +1453,14 @@ public abstract class Entity implements ICommandListener {
     }
 
     public boolean an() {
-		// Migot start
-        return this.an(this.world);
-    }
+		return this.an(this.world);
+     }
  
     public boolean an(IBlockAccess iblockaccess) {
         int currentTick = MinecraftServer.currentTick;
         if (this.lastLavaCheck != currentTick) {
             this.lastLavaCheck = currentTick;
-            this.isInLava = this.world.a(this.getBoundingBox().grow(-0.10000000149011612D, -0.4000000059604645D, -0.10000000149011612D), Material.LAVA);
+            this.isInLava = this.world.a(iblockaccess, this.getBoundingBox().grow(-0.10000000149011612D, -0.4000000059604645D, -0.10000000149011612D), Material.LAVA);
         }
         return this.isInLava;
     }
@@ -2596,68 +2595,16 @@ public abstract class Entity implements ICommandListener {
             WorldServer worldserver = ((CraftWorld) getBukkitEntity().getLocation().getWorld()).getHandle();
             WorldServer worldserver1 = ((CraftWorld) exit.getWorld()).getHandle();
             int i = worldserver1.dimension;
-            // CraftBukkit end
-
             this.dimension = i;
-            /* CraftBukkit start - TODO: Check if we need this
-            if (j == 1 && i == 1) {
-                worldserver1 = minecraftserver.getWorldServer(0);
-                this.dimension = 0;
-            }
-            // CraftBukkit end */
-
             this.world.kill(this);
             this.dead = false;
             this.world.methodProfiler.a("reposition");
-            /* CraftBukkit start - Handled in calculateTarget
-            BlockPosition blockposition;
-
-            if (i == 1) {
-                blockposition = worldserver1.getDimensionSpawn();
-            } else {
-                double d0 = this.locX;
-                double d1 = this.locZ;
-                double d2 = 8.0D;
-
-                if (i == -1) {
-                    d0 = MathHelper.a(d0 / d2, worldserver1.getWorldBorder().b() + 16.0D, worldserver1.getWorldBorder().d() - 16.0D);
-                    d1 = MathHelper.a(d1 / d2, worldserver1.getWorldBorder().c() + 16.0D, worldserver1.getWorldBorder().e() - 16.0D);
-                } else if (i == 0) {
-                    d0 = MathHelper.a(d0 * d2, worldserver1.getWorldBorder().b() + 16.0D, worldserver1.getWorldBorder().d() - 16.0D);
-                    d1 = MathHelper.a(d1 * d2, worldserver1.getWorldBorder().c() + 16.0D, worldserver1.getWorldBorder().e() - 16.0D);
-                }
-
-                d0 = (double) MathHelper.clamp((int) d0, -29999872, 29999872);
-                d1 = (double) MathHelper.clamp((int) d1, -29999872, 29999872);
-                float f = this.yaw;
-
-                this.setPositionRotation(d0, this.locY, d1, 90.0F, 0.0F);
-                PortalTravelAgent portaltravelagent = worldserver1.getTravelAgent();
-
-                portaltravelagent.b(this, f);
-                blockposition = new BlockPosition(this);
-            }
-
-            // CraftBukkit end */
-            // CraftBukkit start - Ensure chunks are loaded in case TravelAgent is not used which would initially cause chunks to load during find/create
-            // minecraftserver.getPlayerList().changeWorld(this, j, worldserver, worldserver1);
             worldserver1.getMinecraftServer().getPlayerList().repositionEntity(this, exit, portal);
-            // worldserver.entityJoinedWorld(this, false); // Handled in repositionEntity
-            // CraftBukkit end
             this.world.methodProfiler.c("reloading");
             Entity entity = EntityTypes.createEntityByName(EntityTypes.b(this), worldserver1);
 
             if (entity != null) {
                 entity.a(this);
-                /* CraftBukkit start - We need to do this...
-                if (j == 1 && i == 1) {
-                    BlockPosition blockposition1 = worldserver1.q(worldserver1.getSpawn());
-
-                    entity.setPositionRotation(blockposition1, entity.yaw, entity.pitch);
-                } else {
-                    entity.setPositionRotation(blockposition, entity.yaw, entity.pitch);
-                }
-                // CraftBukkit end */
 
                 boolean flag = entity.attachedToPlayer;
 
diff --git a/src/main/java/net/minecraft/server/NavigationAbstract.java b/src/main/java/net/minecraft/server/NavigationAbstract.java
index bf39386..02d10f9 100644
--- a/src/main/java/net/minecraft/server/NavigationAbstract.java
+++ b/src/main/java/net/minecraft/server/NavigationAbstract.java
@@ -300,9 +300,30 @@ public abstract class NavigationAbstract {
 
     protected abstract boolean a(Vec3D vec3d, Vec3D vec3d1, int i, int j, int k);
 
+    public boolean b(BlockPosition blockposition) {
+        return this.b.getType(blockposition.down()).b();
+    }
+
+    public PathfinderAbstract q() {
+        return this.e;
+    }
+	
+	// Torch start - Async pathfinding
+	/*
+	 Torch remapping fix;
+	 (Origin) -> (Current) (Type)
+	 this.b -> this.a (EntityInsentient)
+	 this.i -> this.o (float) (1.0F -> 0.5F)
+	 this.c -> this.b (World)
+	 this.j -> this.s (Pathfinder)
+	*/
+	/*public EntityInsentient getEntity() {
+        return this.a; // Torch - remapping fix
+    }*/
+
     @Override
     public int hashCode() {
-        return this.a.getUniqueID().hashCode();
+        return this.a.getUniqueID().hashCode(); // Torch - remapping fix
     }
 
     public void cleanUpExpiredSearches() {}
@@ -311,42 +332,34 @@ public abstract class NavigationAbstract {
 
     public void setSearchResult(PathSearchJobPosition pathSearch) { }
 
-    public boolean a(double d0, double d1, double d2, double d3, PositionPathSearchType type) {
-        return this.a(d0, d1, d2, d3);
+    public boolean a(double d0, double d1, double d2, double d3, PositionPathSearchType type) { // Torch
+        return this.a(d0, d1, d2, d3); // Torch - hold method
     }
 
-    public PathEntity a(double d0, double d1, double d2, PositionPathSearchType type) {
-        return this.a(d0, d1, d2);
+    public PathEntity a(double d0, double d1, double d2, PositionPathSearchType type) { // Torch
+        return this.a(d0, d1, d2); // Torch - hold method
     }
 
     public ChunkCache createChunkCache(boolean forEntitySearch) {
-        if (this.b()) {
-            float f = this.h();
-            BlockPosition blockposition1 = new BlockPosition(this.a);
+        if (this.b()) { // Torch - hold method
+            float f = this.h(); // Torch - hold method
+            BlockPosition blockposition1 = new BlockPosition(this.a); // Torch - remapping fix
             int i = (int) (f + (forEntitySearch ? 16.0F : 8.0F));
-            return new ChunkCache(this.b, blockposition1.a(-i, -i, -i), blockposition1.a(i, i, i), 0);
+            return new ChunkCache(this.b, blockposition1.a(-i, -i, -i), blockposition1.a(i, i, i), 0); // Torch - remapping fix
         }
         return null;
     }
 
     public PathEntity doPathSearch(ChunkCache chunkcache, BlockPosition blockposition) {
-        if (this.b()) {
-            float f = this.h();
-			return this.s.a(chunkcache, this.a, blockposition, f);
+        if (this.b()) { // Torch - hold method
+            float f = this.h(); // Torch - hold method
+            return this.s.a((IBlockAccess) chunkcache, (Entity) this.a, blockposition, f); // Torch - remapping fix
         }
         return null;
     }
 	
-    public PathEntity doPathSearch(ChunkCache chunkcache, Entity entity) {
+	public PathEntity doPathSearch(ChunkCache chunkcache, Entity entity) {
         return this.doPathSearch(chunkcache, (new BlockPosition(entity)).up());
     }
-    // Migot end
-
-    public boolean b(BlockPosition blockposition) {
-        return this.b.getType(blockposition.down()).b();
-    }
-
-    public PathfinderAbstract q() {
-        return this.e;
-    }
+    // Torch end
 }
diff --git a/src/main/java/net/minecraft/server/Pathfinder.java b/src/main/java/net/minecraft/server/Pathfinder.java
new file mode 100644
index 0000000..df2f4ed
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Pathfinder.java
@@ -0,0 +1,140 @@
+package net.minecraft.server;
+
+import java.util.HashSet;
+import java.util.Set;
+import javax.annotation.Nullable;
+
+public class Pathfinder {
+
+    private final Path a = new Path();
+    private final Set<PathPoint> b = new HashSet();
+    private final PathPoint[] c = new PathPoint[32];
+    private final PathfinderAbstract d;
+
+    public Pathfinder(PathfinderAbstract pathfinderabstract) {
+        this.d = pathfinderabstract;
+    }
+
+    @Nullable
+    public PathEntity a(IBlockAccess iblockaccess, EntityInsentient entityinsentient, Entity entity, float f) {
+        return this.a(iblockaccess, entityinsentient, entity.locX, entity.getBoundingBox().b, entity.locZ, f);
+    }
+	
+	@Nullable
+    public PathEntity a(IBlockAccess iblockaccess, Entity entity, BlockPosition blockposition, float f) {
+		return this.a(iblockaccess, entity, (double) ((float) blockposition.getX() + 0.5F), (double) ((float) blockposition.getY() + 0.5F), (double) ((float) blockposition.getZ() + 0.5F), f);
+    }
+
+    @Nullable
+    public PathEntity a(IBlockAccess iblockaccess, EntityInsentient entityinsentient, BlockPosition blockposition, float f) {
+        return this.a(iblockaccess, entityinsentient, (double) ((float) blockposition.getX() + 0.5F), (double) ((float) blockposition.getY() + 0.5F), (double) ((float) blockposition.getZ() + 0.5F), f);
+    }
+
+    @Nullable
+    private PathEntity a(IBlockAccess iblockaccess, EntityInsentient entityinsentient, double d0, double d1, double d2, float f) {
+        this.a.a();
+        this.d.a(iblockaccess, entityinsentient);
+        PathPoint pathpoint = this.d.b();
+        PathPoint pathpoint1 = this.d.a(d0, d1, d2);
+        PathEntity pathentity = this.a(pathpoint, pathpoint1, f);
+
+        this.d.a();
+        return pathentity;
+    }
+	
+	@Nullable
+    private PathEntity a(IBlockAccess iblockaccess, Entity entity, double d0, double d1, double d2, float f) {
+        this.a.a();
+        this.d.a(iblockaccess, entity);
+        PathPoint pathpoint = this.d.b();
+        PathPoint pathpoint1 = this.d.a(d0, d1, d2);
+        PathEntity pathentity = this.a(pathpoint, pathpoint1, f);
+
+        this.d.a();
+        return pathentity;
+    }
+
+    @Nullable
+    private PathEntity a(PathPoint pathpoint, PathPoint pathpoint1, float f) {
+        pathpoint.e = 0.0F;
+        pathpoint.f = pathpoint.c(pathpoint1);
+        pathpoint.g = pathpoint.f;
+        this.a.a();
+        this.b.clear();
+        this.a.a(pathpoint);
+        PathPoint pathpoint2 = pathpoint;
+        int i = 0;
+
+        while (!this.a.e()) {
+            ++i;
+            if (i >= 200) {
+                break;
+            }
+
+            PathPoint pathpoint3 = this.a.c();
+
+            if (pathpoint3.equals(pathpoint1)) {
+                pathpoint2 = pathpoint1;
+                break;
+            }
+
+            if (pathpoint3.c(pathpoint1) < pathpoint2.c(pathpoint1)) {
+                pathpoint2 = pathpoint3;
+            }
+
+            pathpoint3.i = true;
+            int j = this.d.a(this.c, pathpoint3, pathpoint1, f);
+
+            for (int k = 0; k < j; ++k) {
+                PathPoint pathpoint4 = this.c[k];
+                float f1 = pathpoint3.c(pathpoint4);
+
+                pathpoint4.j = pathpoint3.j + f1;
+                pathpoint4.k = f1 + pathpoint4.l;
+                float f2 = pathpoint3.e + pathpoint4.k;
+
+                if (pathpoint4.j < f && (!pathpoint4.a() || f2 < pathpoint4.e)) {
+                    pathpoint4.h = pathpoint3;
+                    pathpoint4.e = f2;
+                    pathpoint4.f = pathpoint4.c(pathpoint1) + pathpoint4.l;
+                    if (pathpoint4.a()) {
+                        this.a.a(pathpoint4, pathpoint4.e + pathpoint4.f);
+                    } else {
+                        pathpoint4.g = pathpoint4.e + pathpoint4.f;
+                        this.a.a(pathpoint4);
+                    }
+                }
+            }
+        }
+
+        if (pathpoint2 == pathpoint) {
+            return null;
+        } else {
+            PathEntity pathentity = this.a(pathpoint, pathpoint2);
+
+            return pathentity;
+        }
+    }
+
+    private PathEntity a(PathPoint pathpoint, PathPoint pathpoint1) {
+        int i = 1;
+
+        PathPoint pathpoint2;
+
+        for (pathpoint2 = pathpoint1; pathpoint2.h != null; pathpoint2 = pathpoint2.h) {
+            ++i;
+        }
+
+        PathPoint[] apathpoint = new PathPoint[i];
+
+        pathpoint2 = pathpoint1;
+        --i;
+
+        for (apathpoint[i] = pathpoint1; pathpoint2.h != null; apathpoint[i] = pathpoint2) {
+            pathpoint2 = pathpoint2.h;
+            --i;
+        }
+
+        return new PathEntity(apathpoint);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PathfinderGoalAvoidTarget.java b/src/main/java/net/minecraft/server/PathfinderGoalAvoidTarget.java
index 89346f0..d8eb58a 100644
--- a/src/main/java/net/minecraft/server/PathfinderGoalAvoidTarget.java
+++ b/src/main/java/net/minecraft/server/PathfinderGoalAvoidTarget.java
@@ -48,7 +48,7 @@ public class PathfinderGoalAvoidTarget<T extends Entity> extends PathfinderGoal
         if (list.isEmpty()) {
             return false;
         } else {
-            this.b = (Entity) list.get(0);
+            this.b = (T) list.get(0);
             Vec3D vec3d = RandomPositionGenerator.b(this.a, 16, 7, new Vec3D(this.b.locX, this.b.locY, this.b.locZ));
 
             if (vec3d == null) {
@@ -56,7 +56,7 @@ public class PathfinderGoalAvoidTarget<T extends Entity> extends PathfinderGoal
             } else if (this.b.e(vec3d.x, vec3d.y, vec3d.z) < this.b.h(this.a)) {
                 return false;
             } else {
-                this.g = this.h.a(vec3d.x, vec3d.y, vec3d.z, de.minetick.pathsearch.PositionPathSearchType.AVOIDTARGET); // Migot
+				this.g = this.h.a(vec3d.x, vec3d.y, vec3d.z, de.minetick.pathsearch.PositionPathSearchType.AVOIDTARGET); // Migot
                 return this.g == null ? false : this.g.b(vec3d);
             }
         }
diff --git a/src/main/java/net/minecraft/server/PathfinderGoalFleeSun.java b/src/main/java/net/minecraft/server/PathfinderGoalFleeSun.java
index 53af902..5eea7ef 100644
--- a/src/main/java/net/minecraft/server/PathfinderGoalFleeSun.java
+++ b/src/main/java/net/minecraft/server/PathfinderGoalFleeSun.java
@@ -47,7 +47,10 @@ public class PathfinderGoalFleeSun extends PathfinderGoal {
     }
 
     public void c() {
-		this.a.getNavigation().a(this.b, this.c, this.d, this.e, de.minetick.pathsearch.PositionPathSearchType.FLEESUN); // Migot
+		// Torch remapping fix - start
+		// Origin: this.a.getNavigation().a(this.b, this.c, this.d, this.e);
+		this.a.getNavigation().a(this.b, this.c, this.d, this.e, de.minetick.pathsearch.PositionPathSearchType.FLEESUN); // Torch - remapping fix
+		// Torch end
     }
 
     @Nullable
diff --git a/src/main/java/net/minecraft/server/PathfinderGoalGotoTarget.java b/src/main/java/net/minecraft/server/PathfinderGoalGotoTarget.java
index f690ec5..d5adafb 100644
--- a/src/main/java/net/minecraft/server/PathfinderGoalGotoTarget.java
+++ b/src/main/java/net/minecraft/server/PathfinderGoalGotoTarget.java
@@ -34,8 +34,12 @@ public abstract class PathfinderGoalGotoTarget extends PathfinderGoal {
     }
 
     public void c() {
-		this.c.getNavigation().a((double) ((float) this.b.getX()) + 0.5D, (double) (this.b.getY() + 1), (double) ((float) this.b.getZ()) + 0.5D, this.d, de.minetick.pathsearch.PositionPathSearchType.GOTOTARGET); // Migot
-        this.e = 0;
+		// Torch start - remapping fix
+		// Origin: this.c.getNavigation().a((double) ((float) this.b.getX()) + 0.5D, (double) (this.b.getY() + 1), (double) ((float) this.b.getZ()) + 0.5D, this.d);
+		// Pre-Apply: this.c.getNavigation().a((double) ((float) this.b.getX()) + 0.5D, (double) (this.b.getY() + 1), (double) ((float) this.b.getZ()) + 0.5D, this.d, de.minetick.pathsearch.PositionPathSearchType.GOTOTARGET);
+		this.c.getNavigation().a((double) ((float) this.b.getX()) + 0.5D, (double) (this.b.getY() + 1), (double) ((float) this.b.getZ()) + 0.5D, this.d, de.minetick.pathsearch.PositionPathSearchType.GOTOTARGET); // Migot // Torch
+        // Torch end
+		this.e = 0;
         this.f = this.c.getRandom().nextInt(this.c.getRandom().nextInt(1200) + 1200) + 1200;
     }
 
@@ -46,8 +50,12 @@ public abstract class PathfinderGoalGotoTarget extends PathfinderGoal {
             this.g = false;
             ++this.e;
             if (this.e % 40 == 0) {
-				this.c.getNavigation().a((double) ((float) this.b.getX()) + 0.5D, (double) (this.b.getY() + 1), (double) ((float) this.b.getZ()) + 0.5D, this.d, de.minetick.pathsearch.PositionPathSearchType.GOTOTARGET); // Migot
-            }
+				// Torch start - remapping fix
+				// Origin: this.c.getNavigation().a((double) ((float) this.b.getX()) + 0.5D, (double) (this.b.getY() + 1), (double) ((float) this.b.getZ()) + 0.5D, this.d);
+				// Pre-Apply: this.c.getNavigation().a((double) ((float) this.b.getX()) + 0.5D, (double) (this.b.getY() + 1), (double) ((float) this.b.getZ()) + 0.5D, this.d, de.minetick.pathsearch.PositionPathSearchType.GOTOTARGET);
+				this.c.getNavigation().a((double) ((float) this.b.getX()) + 0.5D, (double) (this.b.getY() + 1), (double) ((float) this.b.getZ()) + 0.5D, this.d, de.minetick.pathsearch.PositionPathSearchType.GOTOTARGET); // Migot // Torch
+				// Torch end
+			}
         } else {
             this.g = true;
             --this.e;
diff --git a/src/main/java/net/minecraft/server/PathfinderGoalMoveIndoors.java b/src/main/java/net/minecraft/server/PathfinderGoalMoveIndoors.java
index 5ffad6c..3b37c9c 100644
--- a/src/main/java/net/minecraft/server/PathfinderGoalMoveIndoors.java
+++ b/src/main/java/net/minecraft/server/PathfinderGoalMoveIndoors.java
@@ -49,11 +49,19 @@ public class PathfinderGoalMoveIndoors extends PathfinderGoal {
         if (this.a.c(blockposition) > 256.0D) {
             Vec3D vec3d = RandomPositionGenerator.a(this.a, 14, 3, new Vec3D((double) i + 0.5D, (double) j, (double) k + 0.5D));
 
+			// Torch start - remapping fix
             if (vec3d != null) {
-				this.a.getNavigation().a(vec3d.x, vec3d.y, vec3d.z, 1.0D, de.minetick.pathsearch.PositionPathSearchType.MOVEINDOORS); // Migot
+				// Origin: this.a.getNavigation().a(vec3d.x, vec3d.y, vec3d.z, 1.0D);
+				// Pre-Apply: this.a.getNavigation().a(vec3d.a, vec3d.b, vec3d.c, 1.0D, de.minetick.pathsearch.PositionPathSearchType.MOVEINDOORS);
+				// Remap: this.a.getNavigation().a(vec3d.x, vec3d.y, vec3d.z, 1.0D, de.minetick.pathsearch.PositionPathSearchType.MOVEINDOORS);
+				this.a.getNavigation().a(vec3d.x, vec3d.y, vec3d.z, 1.0D, de.minetick.pathsearch.PositionPathSearchType.MOVEINDOORS); // Migot // Torch
             }
         } else {
-			this.a.getNavigation().a((double) i + 0.5D, (double) j, (double) k + 0.5D, 1.0D, de.minetick.pathsearch.PositionPathSearchType.MOVEINDOORS); // Migot
+			// Origin: this.a.getNavigation().a((double) i + 0.5D, (double) j, (double) k + 0.5D, 1.0D);
+			// Pre-Apply: this.a.getNavigation().a((double) i + 0.5D, (double) j, (double) k + 0.5D, 1.0D, de.minetick.pathsearch.PositionPathSearchType.MOVEINDOORS);
+			// Remap: this.a.getNavigation().a((double) i + 0.5D, (double) j, (double) k + 0.5D, 1.0D, de.minetick.pathsearch.PositionPathSearchType.MOVEINDOORS);
+			this.a.getNavigation().a((double) i + 0.5D, (double) j, (double) k + 0.5D, 1.0D, de.minetick.pathsearch.PositionPathSearchType.MOVEINDOORS); // Migot // Torch
+			// Torch end
         }
 
     }
diff --git a/src/main/java/net/minecraft/server/PathfinderGoalMoveThroughVillage.java b/src/main/java/net/minecraft/server/PathfinderGoalMoveThroughVillage.java
index b27a531..9eee73e 100644
--- a/src/main/java/net/minecraft/server/PathfinderGoalMoveThroughVillage.java
+++ b/src/main/java/net/minecraft/server/PathfinderGoalMoveThroughVillage.java
@@ -52,7 +52,12 @@ public class PathfinderGoalMoveThroughVillage extends PathfinderGoal {
                             return false;
                         } else {
                             navigation.a(false);
-							this.c = this.a.getNavigation().a(vec3d.x, vec3d.y, vec3d.z, de.minetick.pathsearch.PositionPathSearchType.MOVETHROUGHVILLAGE); // Migot
+							// Torch start - remapping fix
+							// Origin: this.c = this.a.getNavigation().a(vec3d.x, vec3d.y, vec3d.z);
+							// Pre-Apply: this.c = this.a.getNavigation().a(vec3d.a, vec3d.b, vec3d.c, de.minetick.pathsearch.PositionPathSearchType.MOVETHROUGHVILLAGE);
+							// Remap: this.c = this.a.getNavigation().a(vec3d.x, vec3d.y, vec3d.z, de.minetick.pathsearch.PositionPathSearchType.MOVETHROUGHVILLAGE);
+							this.c = this.a.getNavigation().a(vec3d.x, vec3d.y, vec3d.z, de.minetick.pathsearch.PositionPathSearchType.MOVETHROUGHVILLAGE); // Migot // Torch
+							// Torch end
                             navigation.a(flag);
                             return this.c != null;
                         }
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index 2fca42c..9972005 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -52,7 +52,6 @@ public abstract class World implements IBlockAccess {
     protected boolean d;
     // Spigot start - guard entity list from removals
 	protected boolean cancelHeavyCalculations = false;
-	public boolean instantBlockFall;
 	public final List<Entity> entityList = Lists.newCopyOnWriteArrayList(); // Hose
 	/*
     public final List<Entity> entityList = new java.util.ArrayList<Entity>()
@@ -827,7 +826,17 @@ public abstract class World implements IBlockAccess {
 
     // Paper start - reduces need to do isLoaded before getType
     public IBlockData getTypeIfLoaded(BlockPosition blockposition) {
-        if (captureTreeGeneration) return findCaptured(blockposition); // use seperate findCaptured() method
+        // CraftBukkit start - tree generation
+        if (captureTreeGeneration) {
+            Iterator<BlockState> it = capturedBlockStates.iterator();
+            while (it.hasNext()) {
+                BlockState previous = it.next();
+                if (previous.getX() == blockposition.getX() && previous.getY() == blockposition.getY() && previous.getZ() == blockposition.getZ()) {
+                    return CraftMagicNumbers.getBlock(previous.getTypeId()).fromLegacyData(previous.getRawData());
+                }
+            }
+        }
+        // CraftBukkit end
         Chunk chunk = this.getChunkIfLoaded(blockposition);
         if (chunk != null) {
             return blockposition.isValidLocation() ? chunk.getBlockData(blockposition) : Blocks.AIR.getBlockData();
@@ -836,44 +845,30 @@ public abstract class World implements IBlockAccess {
     }
     // Paper end
 
-    // Paper start - optimize getType
-    // hoist tree generation into a seperate method to assist inlining
-    public IBlockData getType(BlockPosition pos) {
-        return getType(pos, this.captureTreeGeneration);
-    }
-
-    private IBlockData findCaptured(BlockPosition blockposition) {
+    public IBlockData getType(BlockPosition blockposition) {
         // CraftBukkit start - tree generation
 		// Paper start - optimize getType lookup to reduce instructions - getBlockData already enforces valid Y, move tree out
         final int x = blockposition.getX();
         final int y = blockposition.getY();
         final int z = blockposition.getZ();
-		Iterator<BlockState> it = capturedBlockStates.iterator();
-        while (it.hasNext()) {
-            final IBlockData previous = getCapturedBlockType(x, y, z);
-            if (previous != null) {
-                return previous;
+		if (captureTreeGeneration) {
+            Iterator<BlockState> it = capturedBlockStates.iterator();
+            while (it.hasNext()) {
+                BlockState previous = it.next();
+                if (previous.getX() == blockposition.getX() && previous.getY() == blockposition.getY() && previous.getZ() == blockposition.getZ()) {
+                    return CraftMagicNumbers.getBlock(previous.getTypeId()).fromLegacyData(previous.getRawData());
+                }
             }
 		}
         // CraftBukkit end
-        return getType(blockposition, captureTreeGeneration);
-    }
-	
-	public IBlockData getType(BlockPosition blockposition, boolean captureTreeGeneration) {
-        if (captureTreeGeneration) {
-            // CraftBukkit end
-            return findCaptured(blockposition); // Move into seperate method to assist inlining
-         }
-        if (blockposition.isValidLocation()) { // Paper
+        if (!blockposition.isValidLocation()) { // Paper
+            return Blocks.AIR.getBlockData();
+        } else {
             Chunk chunk = this.getChunkAtWorldCoords(blockposition);
-            ChunkSection chunksection = chunk.getSections()[blockposition.getY() >> 4];
-            if (chunksection != null) {
-                return chunksection.getType(blockposition.getX() & 15, blockposition.getY() & 15, blockposition.getZ() & 15);
-            }
-        }
-        return Blocks.AIR.getBlockData();
-     }
-    // Paper end
+			
+			return chunk.getBlockData(blockposition);
+		}
+    }
 	
 	// Paper start
     private IBlockData getCapturedBlockType(int x, int y, int z) {
@@ -2141,12 +2136,10 @@ public abstract class World implements IBlockAccess {
     }
 
     public boolean a(AxisAlignedBB axisalignedbb, Material material) {
-		// Migot start
-        return this.a(this, axisalignedbb, material);
+		return this.a(this, axisalignedbb, material);
     }
 
     public boolean a(IBlockAccess iblockaccess, AxisAlignedBB axisalignedbb, Material material) {
-    // Migot end
         int i = MathHelper.floor(axisalignedbb.a);
         int j = MathHelper.f(axisalignedbb.d);
         int k = MathHelper.floor(axisalignedbb.b);
-- 
2.8.2.windows.1

