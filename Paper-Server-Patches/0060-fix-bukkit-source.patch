From 0cc076380a7ea83760a21ea2648a7ce22d1c3486 Mon Sep 17 00:00:00 2001
From: SotrForgotten <i@omc.hk>
Date: Sun, 26 Jun 2016 09:34:41 +0800
Subject: [PATCH] fix bukkit source


diff --git a/src/main/java/org/bukkit/Achievement.java b/src/main/java/org/bukkit/Achievement.java
deleted file mode 100644
index ee874ee..0000000
--- a/src/main/java/org/bukkit/Achievement.java
+++ /dev/null
@@ -1,70 +0,0 @@
-package org.bukkit;
-
-/**
- * Represents an achievement, which may be given to players.
- */
-public enum Achievement {
-    OPEN_INVENTORY,
-    MINE_WOOD (OPEN_INVENTORY),
-    BUILD_WORKBENCH (MINE_WOOD),
-    BUILD_PICKAXE (BUILD_WORKBENCH),
-    BUILD_FURNACE (BUILD_PICKAXE),
-    ACQUIRE_IRON (BUILD_FURNACE),
-    BUILD_HOE (BUILD_WORKBENCH),
-    MAKE_BREAD (BUILD_HOE),
-    BAKE_CAKE (BUILD_HOE),
-    BUILD_BETTER_PICKAXE (BUILD_PICKAXE),
-    COOK_FISH (BUILD_FURNACE),
-    ON_A_RAIL (ACQUIRE_IRON),
-    BUILD_SWORD (BUILD_WORKBENCH),
-    KILL_ENEMY (BUILD_SWORD),
-    KILL_COW (BUILD_SWORD),
-    FLY_PIG (KILL_COW),
-    SNIPE_SKELETON (KILL_ENEMY),
-    GET_DIAMONDS (ACQUIRE_IRON),
-    NETHER_PORTAL (GET_DIAMONDS),
-    GHAST_RETURN (NETHER_PORTAL),
-    GET_BLAZE_ROD (NETHER_PORTAL),
-    BREW_POTION (GET_BLAZE_ROD),
-    END_PORTAL (GET_BLAZE_ROD),
-    THE_END (END_PORTAL),
-    ENCHANTMENTS (GET_DIAMONDS),
-    OVERKILL (ENCHANTMENTS),
-    BOOKCASE (ENCHANTMENTS),
-    EXPLORE_ALL_BIOMES (END_PORTAL),
-    SPAWN_WITHER (THE_END),
-    KILL_WITHER (SPAWN_WITHER),
-    FULL_BEACON (KILL_WITHER),
-    BREED_COW (KILL_COW),
-    DIAMONDS_TO_YOU (GET_DIAMONDS),
-    OVERPOWERED (BUILD_BETTER_PICKAXE)
-    ;
-
-    private final Achievement parent;
-
-    private Achievement() {
-        parent = null;
-    }
-
-    private Achievement(Achievement parent) {
-        this.parent = parent;
-    }
-
-    /**
-     * Returns whether or not this achievement has a parent achievement.
-     * 
-     * @return whether the achievement has a parent achievement
-     */
-    public boolean hasParent() {
-        return parent != null;
-    }
-
-    /**
-     * Returns the parent achievement of this achievement, or null if none.
-     * 
-     * @return the parent achievement or null
-     */
-    public Achievement getParent() {
-        return parent;
-    }
-}
diff --git a/src/main/java/org/bukkit/Art.java b/src/main/java/org/bukkit/Art.java
deleted file mode 100644
index ba66f16..0000000
--- a/src/main/java/org/bukkit/Art.java
+++ /dev/null
@@ -1,111 +0,0 @@
-package org.bukkit;
-
-import java.util.HashMap;
-
-import org.apache.commons.lang.Validate;
-
-import com.google.common.collect.Maps;
-
-/**
- * Represents the art on a painting
- */
-public enum Art {
-    KEBAB(0, 1, 1),
-    AZTEC(1, 1, 1),
-    ALBAN(2, 1, 1),
-    AZTEC2(3, 1, 1),
-    BOMB(4, 1, 1),
-    PLANT(5, 1, 1),
-    WASTELAND(6, 1, 1),
-    POOL(7, 2, 1),
-    COURBET(8, 2, 1),
-    SEA(9, 2, 1),
-    SUNSET(10, 2, 1),
-    CREEBET(11, 2, 1),
-    WANDERER(12, 1, 2),
-    GRAHAM(13, 1, 2),
-    MATCH(14, 2, 2),
-    BUST(15, 2, 2),
-    STAGE(16, 2, 2),
-    VOID(17, 2, 2),
-    SKULL_AND_ROSES(18, 2, 2),
-    WITHER(19, 2, 2),
-    FIGHTERS(20, 4, 2),
-    POINTER(21, 4, 4),
-    PIGSCENE(22, 4, 4),
-    BURNINGSKULL(23, 4, 4),
-    SKELETON(24, 4, 3),
-    DONKEYKONG(25, 4, 3);
-
-    private int id, width, height;
-    private static final HashMap<String, Art> BY_NAME = Maps.newHashMap();
-    private static final HashMap<Integer, Art> BY_ID = Maps.newHashMap();
-
-    private Art(int id, int width, int height) {
-        this.id = id;
-        this.width = width;
-        this.height = height;
-    }
-
-    /**
-     * Gets the width of the painting, in blocks
-     *
-     * @return The width of the painting, in blocks
-     */
-    public int getBlockWidth() {
-        return width;
-    }
-
-    /**
-     * Gets the height of the painting, in blocks
-     *
-     * @return The height of the painting, in blocks
-     */
-    public int getBlockHeight() {
-        return height;
-    }
-
-    /**
-     * Get the ID of this painting.
-     *
-     * @return The ID of this painting
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public int getId() {
-        return id;
-    }
-
-    /**
-     * Get a painting by its numeric ID
-     *
-     * @param id The ID
-     * @return The painting
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public static Art getById(int id) {
-        return BY_ID.get(id);
-    }
-
-    /**
-     * Get a painting by its unique name
-     * <p>
-     * This ignores underscores and capitalization
-     *
-     * @param name The name
-     * @return The painting
-     */
-    public static Art getByName(String name) {
-        Validate.notNull(name, "Name cannot be null");
-
-        return BY_NAME.get(name.toLowerCase().replaceAll("_", ""));
-    }
-
-    static {
-        for (Art art : values()) {
-            BY_ID.put(art.id, art);
-            BY_NAME.put(art.toString().toLowerCase().replaceAll("_", ""), art);
-        }
-    }
-}
diff --git a/src/main/java/org/bukkit/BanEntry.java b/src/main/java/org/bukkit/BanEntry.java
deleted file mode 100644
index b2437c6..0000000
--- a/src/main/java/org/bukkit/BanEntry.java
+++ /dev/null
@@ -1,128 +0,0 @@
-package org.bukkit;
-
-import java.util.Date;
-
-/**
- * A single entry from a ban list. This may represent either a player ban or
- * an IP ban.
- * <p>
- * Ban entries include the following properties:
- * <table border=1>
- * <caption>Property information</caption>
- * <tr>
- *     <th>Property</th>
- *     <th>Description</th>
- * </tr><tr>
- *     <td>Target Name / IP Address</td>
- *     <td>The target name or IP address</td>
- * </tr><tr>
- *     <td>Creation Date</td>
- *     <td>The creation date of the ban</td>
- * </tr><tr>
- *     <td>Source</td>
- *     <td>The source of the ban, such as a player, console, plugin, etc</td>
- * </tr><tr>
- *     <td>Expiration Date</td>
- *     <td>The expiration date of the ban</td>
- * </tr><tr>
- *     <td>Reason</td>
- *     <td>The reason for the ban</td>
- * </tr>
- * </table>
- * <p>
- * Unsaved information is not automatically written to the implementation's
- * ban list, instead, the {@link #save()} method must be called to write the
- * changes to the ban list. If this ban entry has expired (such as from an
- * unban) and is no longer found in the list, the {@link #save()} call will
- * re-add it to the list, therefore banning the victim specified.
- * <p>
- * Likewise, changes to the associated {@link BanList} or other entries may or
- * may not be reflected in this entry.
- */
-public interface BanEntry {
-
-    /**
-     * Gets the target involved. This may be in the form of an IP or a player
-     * name.
-     *
-     * @return the target name or IP address
-     */
-    public String getTarget();
-
-    /**
-     * Gets the date this ban entry was created.
-     *
-     * @return the creation date
-     */
-    public Date getCreated();
-
-    /**
-     * Sets the date this ban entry was created.
-     *
-     * @param created the new created date, cannot be null
-     * @see #save() saving changes
-     */
-    public void setCreated(Date created);
-
-    /**
-     * Gets the source of this ban.
-     * <p>
-     * Note: A source is considered any String, although this is generally a
-     * player name.
-     *
-     * @return the source of the ban
-     */
-    public String getSource();
-
-    /**
-     * Sets the source of this ban.
-     * <p>
-     * Note: A source is considered any String, although this is generally a
-     * player name.
-     *
-     * @param source the new source where null values become empty strings
-     * @see #save() saving changes
-     */
-    public void setSource(String source);
-
-    /**
-     * Gets the date this ban expires on, or null for no defined end date.
-     *
-     * @return the expiration date
-     */
-    public Date getExpiration();
-
-    /**
-     * Sets the date this ban expires on. Null values are considered
-     * "infinite" bans.
-     *
-     * @param expiration the new expiration date, or null to indicate an
-     *     eternity
-     * @see #save() saving changes
-     */
-    public void setExpiration(Date expiration);
-
-    /**
-     * Gets the reason for this ban.
-     *
-     * @return the ban reason, or null if not set
-     */
-    public String getReason();
-
-    /**
-     * Sets the reason for this ban. Reasons must not be null.
-     *
-     * @param reason the new reason, null values assume the implementation
-     *     default
-     * @see #save() saving changes
-     */
-    public void setReason(String reason);
-
-    /**
-     * Saves the ban entry, overwriting any previous data in the ban list.
-     * <p>
-     * Saving the ban entry of an unbanned player will cause the player to be
-     * banned once again.
-     */
-    public void save();
-}
diff --git a/src/main/java/org/bukkit/BanList.java b/src/main/java/org/bukkit/BanList.java
deleted file mode 100644
index c21b858..0000000
--- a/src/main/java/org/bukkit/BanList.java
+++ /dev/null
@@ -1,72 +0,0 @@
-package org.bukkit;
-
-import java.util.Date;
-import java.util.Set;
-
-/**
- * A ban list, containing bans of some {@link Type}.
- */
-public interface BanList {
-
-    /**
-     * Represents a ban-type that a {@link BanList} may track.
-     */
-    public enum Type {
-        /**
-         * Banned player names
-         */
-        NAME,
-        /**
-         * Banned player IP addresses
-         */
-        IP,
-        ;
-    }
-
-    /**
-     * Gets a {@link BanEntry} by target.
-     *
-     * @param target entry parameter to search for
-     * @return the corresponding entry, or null if none found
-     */
-    public BanEntry getBanEntry(String target);
-
-    /**
-     * Adds a ban to the this list. If a previous ban exists, this will
-     * update the previous entry.
-     *
-     * @param target the target of the ban
-     * @param reason reason for the ban, null indicates implementation default
-     * @param expires date for the ban's expiration (unban), or null to imply
-     *     forever
-     * @param source source of the ban, null indicates implementation default
-     * @return the entry for the newly created ban, or the entry for the
-     *     (updated) previous ban
-     */
-    public BanEntry addBan(String target, String reason, Date expires, String source);
-
-    /**
-     * Gets a set containing every {@link BanEntry} in this list.
-     *
-     * @return an immutable set containing every entry tracked by this list
-     */
-    public Set<BanEntry> getBanEntries();
-
-    /**
-     * Gets if a {@link BanEntry} exists for the target, indicating an active
-     * ban status.
-     *
-     * @param target the target to find
-     * @return true if a {@link BanEntry} exists for the name, indicating an
-     *     active ban status, false otherwise
-     */
-    public boolean isBanned(String target);
-
-    /**
-     * Removes the specified target from this list, therefore indicating a
-     * "not banned" status.
-     *
-     * @param target the target to remove from this list
-     */
-    public void pardon(String target);
-}
diff --git a/src/main/java/org/bukkit/BlockChangeDelegate.java b/src/main/java/org/bukkit/BlockChangeDelegate.java
deleted file mode 100644
index e6b9f0e..0000000
--- a/src/main/java/org/bukkit/BlockChangeDelegate.java
+++ /dev/null
@@ -1,104 +0,0 @@
-package org.bukkit;
-
-/**
- * A delegate for handling block changes. This serves as a direct interface
- * between generation algorithms in the server implementation and utilizing
- * code.
- */
-public interface BlockChangeDelegate {
-
-    /**
-     * Set a block type at the specified coordinates without doing all world
-     * updates and notifications.
-     * <p>
-     * It is safe to have this call World.setTypeId, but it may be slower than
-     * World.setRawTypeId.
-     *
-     * @param x X coordinate
-     * @param y Y coordinate
-     * @param z Z coordinate
-     * @param typeId New block ID
-     * @return true if the block was set successfully
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public boolean setRawTypeId(int x, int y, int z, int typeId);
-
-    /**
-     * Set a block type and data at the specified coordinates without doing
-     * all world updates and notifications.
-     * <p>
-     * It is safe to have this call World.setTypeId, but it may be slower than
-     * World.setRawTypeId.
-     *
-     * @param x X coordinate
-     * @param y Y coordinate
-     * @param z Z coordinate
-     * @param typeId New block ID
-     * @param data Block data
-     * @return true if the block was set successfully
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public boolean setRawTypeIdAndData(int x, int y, int z, int typeId, int data);
-
-    /**
-     * Set a block type at the specified coordinates.
-     * <p>
-     * This method cannot call World.setRawTypeId, a full update is needed.
-     *
-     * @param x X coordinate
-     * @param y Y coordinate
-     * @param z Z coordinate
-     * @param typeId New block ID
-     * @return true if the block was set successfully
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public boolean setTypeId(int x, int y, int z, int typeId);
-
-    /**
-     * Set a block type and data at the specified coordinates.
-     * <p>
-     * This method cannot call World.setRawTypeId, a full update is needed.
-     *
-     * @param x X coordinate
-     * @param y Y coordinate
-     * @param z Z coordinate
-     * @param typeId New block ID
-     * @param data Block data
-     * @return true if the block was set successfully
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public boolean setTypeIdAndData(int x, int y, int z, int typeId, int data);
-
-    /**
-     * Get the block type at the location.
-     *
-     * @param x X coordinate
-     * @param y Y coordinate
-     * @param z Z coordinate
-     * @return The block ID
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public int getTypeId(int x, int y, int z);
-
-    /**
-     * Gets the height of the world.
-     *
-     * @return Height of the world
-     */
-    public int getHeight();
-
-    /**
-     * Checks if the specified block is empty (air) or not.
-     *
-     * @param x X coordinate
-     * @param y Y coordinate
-     * @param z Z coordinate
-     * @return True if the block is considered empty.
-     */
-    public boolean isEmpty(int x, int y, int z);
-}
diff --git a/src/main/java/org/bukkit/Bukkit.java b/src/main/java/org/bukkit/Bukkit.java
deleted file mode 100644
index 7eba4f9..0000000
--- a/src/main/java/org/bukkit/Bukkit.java
+++ /dev/null
@@ -1,1220 +0,0 @@
-package org.bukkit;
-
-import java.awt.image.BufferedImage;
-import java.io.File;
-import java.io.Serializable;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.UUID;
-import java.util.logging.Logger;
-
-import com.destroystokyo.paper.profile.ProfileLookup; // Paper
-import org.bukkit.Warning.WarningState;
-import org.bukkit.boss.BarColor;
-import org.bukkit.boss.BarFlag;
-import org.bukkit.boss.BarStyle;
-import org.bukkit.boss.BossBar;
-import org.bukkit.command.*;
-import org.bukkit.entity.Entity;
-import org.bukkit.entity.Player;
-import org.bukkit.event.inventory.InventoryType;
-import org.bukkit.event.server.ServerListPingEvent;
-import org.bukkit.help.HelpMap;
-import org.bukkit.inventory.Inventory;
-import org.bukkit.inventory.InventoryHolder;
-import org.bukkit.inventory.ItemStack;
-import org.bukkit.inventory.Recipe;
-import org.bukkit.map.MapView;
-import org.bukkit.permissions.Permissible;
-import org.bukkit.plugin.PluginManager;
-import org.bukkit.plugin.ServicesManager;
-import org.bukkit.plugin.messaging.Messenger;
-import org.bukkit.scheduler.BukkitScheduler;
-import org.bukkit.scoreboard.ScoreboardManager;
-import org.bukkit.util.CachedServerIcon;
-
-import com.avaje.ebean.config.ServerConfig;
-import com.google.common.collect.ImmutableList;
-import org.bukkit.generator.ChunkGenerator;
-
-import org.bukkit.inventory.ItemFactory;
-import org.bukkit.inventory.meta.ItemMeta;
-
-/**
- * Represents the Bukkit core, for version and Server singleton handling
- */
-public final class Bukkit {
-    private static Server server;
-
-    /**
-     * Static class cannot be initialized.
-     */
-    private Bukkit() {}
-
-    /**
-     * Gets the current {@link Server} singleton
-     *
-     * @return Server instance being ran
-     */
-    public static Server getServer() {
-        return server;
-    }
-
-    /**
-     * Attempts to set the {@link Server} singleton.
-     * <p>
-     * This cannot be done if the Server is already set.
-     *
-     * @param server Server instance
-     */
-    public static void setServer(Server server) {
-        if (Bukkit.server != null) {
-            throw new UnsupportedOperationException("Cannot redefine singleton Server");
-        }
-
-        Bukkit.server = server;
-        server.getLogger().info("This server is running " + getName() + " version " + getVersion() + " (Implementing API version " + getBukkitVersion() + ")");
-    }
-
-    /**
-     * Gets the name of this server implementation.
-     *
-     * @return name of this server implementation
-     */
-    public static String getName() {
-        return server.getName();
-    }
-
-    /**
-     * Gets the version string of this server implementation.
-     *
-     * @return version of this server implementation
-     */
-    public static String getVersion() {
-        return server.getVersion();
-    }
-
-    /**
-     * Gets the Bukkit version that this server is running.
-     *
-     * @return version of Bukkit
-     */
-    public static String getBukkitVersion() {
-        return server.getBukkitVersion();
-    }
-
-    /**
-     * Gets an array copy of all currently logged in players.
-     * <p>
-     * This method exists for legacy reasons to provide backwards
-     * compatibility. It will not exist at runtime and should not be used
-     * under any circumstances.
-     *
-     * @deprecated superseded by {@link #getOnlinePlayers()}
-     * @return an array of Players that are currently online
-     */
-    @Deprecated
-    public static Player[] _INVALID_getOnlinePlayers() {
-        return server._INVALID_getOnlinePlayers();
-    }
-
-    /**
-     * Gets a view of all currently logged in players. This {@linkplain
-     * Collections#unmodifiableCollection(Collection) view} is a reused
-     * object, making some operations like {@link Collection#size()}
-     * zero-allocation.
-     * <p>
-     * The collection is a view backed by the internal representation, such
-     * that, changes to the internal state of the server will be reflected
-     * immediately. However, the reuse of the returned collection (identity)
-     * is not strictly guaranteed for future or all implementations. Casting
-     * the collection, or relying on interface implementations (like {@link
-     * Serializable} or {@link List}), is deprecated.
-     * <p>
-     * Iteration behavior is undefined outside of self-contained main-thread
-     * uses. Normal and immediate iterator use without consequences that
-     * affect the collection are fully supported. The effects following
-     * (non-exhaustive) {@link Entity#teleport(Location) teleportation},
-     * {@link Player#setHealth(double) death}, and {@link Player#kickPlayer(
-     * String) kicking} are undefined. Any use of this collection from
-     * asynchronous threads is unsafe.
-     * <p>
-     * For safe consequential iteration or mimicking the old array behavior,
-     * using {@link Collection#toArray(Object[])} is recommended. For making
-     * snapshots, {@link ImmutableList#copyOf(Collection)} is recommended.
-     *
-     * @return a view of currently online players.
-     */
-    public static Collection<? extends Player> getOnlinePlayers() {
-        return server.getOnlinePlayers();
-    }
-
-    /**
-     * Get the maximum amount of players which can login to this server.
-     *
-     * @return the amount of players this server allows
-     */
-    public static int getMaxPlayers() {
-        return server.getMaxPlayers();
-    }
-
-    /**
-     * Get the game port that the server runs on.
-     *
-     * @return the port number of this server
-     */
-    public static int getPort() {
-        return server.getPort();
-    }
-
-    /**
-     * Get the view distance from this server.
-     *
-     * @return the view distance from this server.
-     */
-    public static int getViewDistance() {
-        return server.getViewDistance();
-    }
-
-    /**
-     * Get the IP that this server is bound to, or empty string if not
-     * specified.
-     *
-     * @return the IP string that this server is bound to, otherwise empty
-     *     string
-     */
-    public static String getIp() {
-        return server.getIp();
-    }
-
-    /**
-     * Get the name of this server.
-     *
-     * @return the name of this server
-     */
-    public static String getServerName() {
-        return server.getServerName();
-    }
-
-    /**
-     * Get an ID of this server. The ID is a simple generally alphanumeric ID
-     * that can be used for uniquely identifying this server.
-     *
-     * @return the ID of this server
-     */
-    public static String getServerId() {
-        return server.getServerId();
-    }
-    
-    /**
-     * Get world type (level-type setting) for default world.
-     *
-     * @return the value of level-type (e.g. DEFAULT, FLAT, DEFAULT_1_1)
-     */
-    public static String getWorldType() {
-        return server.getWorldType();
-    }
-
-    /**
-     * Get generate-structures setting.
-     *
-     * @return true if structure generation is enabled, false otherwise
-     */
-    public static boolean getGenerateStructures() {
-        return server.getGenerateStructures();
-    }
-
-    /**
-     * Gets whether this server allows the End or not.
-     *
-     * @return whether this server allows the End or not
-     */
-    public static boolean getAllowEnd() {
-        return server.getAllowEnd();
-    }
-
-    /**
-     * Gets whether this server allows the Nether or not.
-     *
-     * @return whether this server allows the Nether or not
-     */
-    public static boolean getAllowNether() {
-        return server.getAllowNether();
-    }
-
-    /**
-     * Gets whether this server has a whitelist or not.
-     *
-     * @return whether this server has a whitelist or not
-     */
-    public static boolean hasWhitelist() {
-        return server.hasWhitelist();
-    }
-
-    /**
-     * Sets if the server is whitelisted.
-     *
-     * @param value true for whitelist on, false for off
-     */
-    public static void setWhitelist(boolean value) {
-        server.setWhitelist(value);
-    }
-
-    /**
-     * Gets a list of whitelisted players.
-     *
-     * @return a set containing all whitelisted players
-     */
-    public static Set<OfflinePlayer> getWhitelistedPlayers() {
-        return server.getWhitelistedPlayers();
-    }
-
-    /**
-     * Reloads the whitelist from disk.
-     */
-    public static void reloadWhitelist() {
-        server.reloadWhitelist();
-    }
-
-    /**
-     * Broadcast a message to all players.
-     * <p>
-     * This is the same as calling {@link #broadcast(java.lang.String,
-     * java.lang.String)} to {@link Server#BROADCAST_CHANNEL_USERS}
-     *
-     * @param message the message
-     * @return the number of players
-     */
-    public static int broadcastMessage(String message) {
-        return server.broadcastMessage(message);
-    }
-
-    // Paper start
-    /**
-     * Sends the component to all online players.
-     *
-     * @param component the component to send
-     */
-    public static void broadcast(net.md_5.bungee.api.chat.BaseComponent component) {
-        server.broadcast(component);
-    }
-
-    /**
-     * Sends an array of components as a single message to all online players.
-     *
-     * @param components the components to send
-     */
-    public static void broadcast(net.md_5.bungee.api.chat.BaseComponent... components) {
-        server.broadcast(components);
-    }
-    // Paper end
-
-    /**
-     * Gets the name of the update folder. The update folder is used to safely
-     * update plugins at the right moment on a plugin load.
-     * <p>
-     * The update folder name is relative to the plugins folder.
-     *
-     * @return the name of the update folder
-     */
-    public static String getUpdateFolder() {
-        return server.getUpdateFolder();
-    }
-
-    /**
-     * Gets the update folder. The update folder is used to safely update
-     * plugins at the right moment on a plugin load.
-     *
-     * @return the update folder
-     */
-    public static File getUpdateFolderFile() {
-        return server.getUpdateFolderFile();
-    }
-
-    /**
-     * Gets the value of the connection throttle setting.
-     *
-     * @return the value of the connection throttle setting
-     */
-    public static long getConnectionThrottle() {
-        return server.getConnectionThrottle();
-    }
-
-    /**
-     * Gets default ticks per animal spawns value.
-     * <p>
-     * <b>Example Usage:</b>
-     * <ul>
-     * <li>A value of 1 will mean the server will attempt to spawn monsters
-     *     every tick.
-     * <li>A value of 400 will mean the server will attempt to spawn monsters
-     *     every 400th tick.
-     * <li>A value below 0 will be reset back to Minecraft's default.
-     * </ul>
-     * <p>
-     * <b>Note:</b> If set to 0, animal spawning will be disabled. We
-     * recommend using spawn-animals to control this instead.
-     * <p>
-     * Minecraft default: 400.
-     *
-     * @return the default ticks per animal spawns value
-     */
-    public static int getTicksPerAnimalSpawns() {
-        return server.getTicksPerAnimalSpawns();
-    }
-
-    /**
-     * Gets the default ticks per monster spawns value.
-     * <p>
-     * <b>Example Usage:</b>
-     * <ul>
-     * <li>A value of 1 will mean the server will attempt to spawn monsters
-     *     every tick.
-     * <li>A value of 400 will mean the server will attempt to spawn monsters
-     *     every 400th tick.
-     * <li>A value below 0 will be reset back to Minecraft's default.
-     * </ul>
-     * <p>
-     * <b>Note:</b> If set to 0, monsters spawning will be disabled. We
-     * recommend using spawn-monsters to control this instead.
-     * <p>
-     * Minecraft default: 1.
-     *
-     * @return the default ticks per monsters spawn value
-     */
-    public static int getTicksPerMonsterSpawns() {
-        return server.getTicksPerMonsterSpawns();
-    }
-
-    /**
-     * Gets a player object by the given username.
-     * <p>
-     * This method may not return objects for offline players.
-     *
-     * @param name the name to look up
-     * @return a player if one was found, null otherwise
-     */
-    public static Player getPlayer(String name) {
-        return server.getPlayer(name);
-    }
-
-    /**
-     * Gets the player with the exact given name, case insensitive.
-     *
-     * @param name Exact name of the player to retrieve
-     * @return a player object if one was found, null otherwise
-     */
-    public static Player getPlayerExact(String name) {
-        return server.getPlayerExact(name);
-    }
-
-    /**
-     * Attempts to match any players with the given name, and returns a list
-     * of all possibly matches.
-     * <p>
-     * This list is not sorted in any particular order. If an exact match is
-     * found, the returned list will only contain a single result.
-     *
-     * @param name the (partial) name to match
-     * @return list of all possible players
-     */
-    public static List<Player> matchPlayer(String name) {
-        return server.matchPlayer(name);
-    }
-
-    /**
-     * Gets the player with the given UUID.
-     *
-     * @param id UUID of the player to retrieve
-     * @return a player object if one was found, null otherwise
-     */
-    public static Player getPlayer(UUID id) {
-        return server.getPlayer(id);
-    }
-
-    /**
-     * Gets the plugin manager for interfacing with plugins.
-     *
-     * @return a plugin manager for this Server instance
-     */
-    public static PluginManager getPluginManager() {
-        return server.getPluginManager();
-    }
-
-    /**
-     * Gets the scheduler for managing scheduled events.
-     *
-     * @return a scheduling service for this server
-     */
-    public static BukkitScheduler getScheduler() {
-        return server.getScheduler();
-    }
-
-    /**
-     * Gets a services manager.
-     *
-     * @return s services manager
-     */
-    public static ServicesManager getServicesManager() {
-        return server.getServicesManager();
-    }
-
-    /**
-     * Gets a list of all worlds on this server.
-     *
-     * @return a list of worlds
-     */
-    public static List<World> getWorlds() {
-        return server.getWorlds();
-    }
-
-    /**
-     * Creates or loads a world with the given name using the specified
-     * options.
-     * <p>
-     * If the world is already loaded, it will just return the equivalent of
-     * getWorld(creator.name()).
-     *
-     * @param creator the options to use when creating the world
-     * @return newly created or loaded world
-     */
-    public static World createWorld(WorldCreator creator) {
-        return server.createWorld(creator);
-    }
-
-    /**
-     * Unloads a world with the given name.
-     *
-     * @param name Name of the world to unload
-     * @param save whether to save the chunks before unloading
-     * @return true if successful, false otherwise
-     */
-    public static boolean unloadWorld(String name, boolean save) {
-        return server.unloadWorld(name, save);
-    }
-
-    /**
-     * Unloads the given world.
-     *
-     * @param world the world to unload
-     * @param save whether to save the chunks before unloading
-     * @return true if successful, false otherwise
-     */
-    public static boolean unloadWorld(World world, boolean save) {
-        return server.unloadWorld(world, save);
-    }
-
-    /**
-     * Gets the world with the given name.
-     *
-     * @param name the name of the world to retrieve
-     * @return a world with the given name, or null if none exists
-     */
-    public static World getWorld(String name) {
-        return server.getWorld(name);
-    }
-
-    /**
-     * Gets the world from the given Unique ID.
-     *
-     * @param uid a unique-id of the world to retrieve
-     * @return a world with the given Unique ID, or null if none exists
-     */
-    public static World getWorld(UUID uid) {
-        return server.getWorld(uid);
-    }
-
-    /**
-     * Gets the map from the given item ID.
-     *
-     * @param id the id of the map to get
-     * @return a map view if it exists, or null otherwise
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public static MapView getMap(short id) {
-        return server.getMap(id);
-    }
-
-    /**
-     * Create a new map with an automatically assigned ID.
-     *
-     * @param world the world the map will belong to
-     * @return a newly created map view
-     */
-    public static MapView createMap(World world) {
-        return server.createMap(world);
-    }
-
-    /**
-     * Reloads the server, refreshing settings and plugin information.
-     */
-    public static void reload() {
-        server.reload();
-    }
-
-    /**
-     * Returns the primary logger associated with this server instance.
-     *
-     * @return Logger associated with this server
-     */
-    public static Logger getLogger() {
-        return server.getLogger();
-    }
-
-    /**
-     * Gets a {@link PluginCommand} with the given name or alias.
-     *
-     * @param name the name of the command to retrieve
-     * @return a plugin command if found, null otherwise
-     */
-    public static PluginCommand getPluginCommand(String name) {
-        return server.getPluginCommand(name);
-    }
-
-    /**
-     * Writes loaded players to disk.
-     */
-    public static void savePlayers() {
-        server.savePlayers();
-    }
-    
-    /**
-     * Dispatches a command on this server, and executes it if found.
-     *
-     * @param sender the apparent sender of the command
-     * @param commandLine the command + arguments. Example: <code>test abc
-     *     123</code>
-     * @return returns false if no target is found
-     * @throws CommandException thrown when the executor for the given command
-     *     fails with an unhandled exception
-     */
-    public static boolean dispatchCommand(CommandSender sender, String commandLine) throws CommandException {
-        return server.dispatchCommand(sender, commandLine);
-    }
-
-    /**
-     * Populates a given {@link ServerConfig} with values attributes to this
-     * server.
-     *
-     * @param config the server config to populate
-     */
-    public static void configureDbConfig(ServerConfig config) {
-        server.configureDbConfig(config);
-    }
-
-    /**
-     * Adds a recipe to the crafting manager.
-     *
-     * @param recipe the recipe to add
-     * @return true if the recipe was added, false if it wasn't for some
-     *     reason
-     */
-    public static boolean addRecipe(Recipe recipe) {
-        return server.addRecipe(recipe);
-    }
-
-    /**
-     * Get a list of all recipes for a given item. The stack size is ignored
-     * in comparisons. If the durability is -1, it will match any data value.
-     *
-     * @param result the item to match against recipe results
-     * @return a list of recipes with the given result
-     */
-    public static List<Recipe> getRecipesFor(ItemStack result) {
-        return server.getRecipesFor(result);
-    }
-
-    /**
-     * Get an iterator through the list of crafting recipes.
-     *
-     * @return an iterator
-     */
-    public static Iterator<Recipe> recipeIterator() {
-        return server.recipeIterator();
-    }
-
-    /**
-     * Clears the list of crafting recipes.
-     */
-    public static void clearRecipes() {
-        server.clearRecipes();
-    }
-
-    /**
-     * Resets the list of crafting recipes to the default.
-     */
-    public static void resetRecipes() {
-        server.resetRecipes();
-    }
-    
-    /**
-     * Gets a list of command aliases defined in the server properties.
-     *
-     * @return a map of aliases to command names
-     */
-    public static Map<String, String[]> getCommandAliases() {
-        return server.getCommandAliases();
-    }
-
-    /**
-     * Gets the radius, in blocks, around each worlds spawn point to protect.
-     *
-     * @return spawn radius, or 0 if none
-     */
-    public static int getSpawnRadius() {
-        return server.getSpawnRadius();
-    }
-
-    /**
-     * Sets the radius, in blocks, around each worlds spawn point to protect.
-     *
-     * @param value new spawn radius, or 0 if none
-     */
-    public static void setSpawnRadius(int value) {
-        server.setSpawnRadius(value);
-    }
-
-    /**
-     * Gets whether the Server is in online mode or not.
-     *
-     * @return true if the server authenticates clients, false otherwise
-     */
-    public static boolean getOnlineMode() {
-        return server.getOnlineMode();
-    }
-
-    /**
-     * Gets whether this server allows flying or not.
-     *
-     * @return true if the server allows flight, false otherwise
-     */
-    public static boolean getAllowFlight() {
-        return server.getAllowFlight();
-    }
-
-    /**
-     * Gets whether the server is in hardcore mode or not.
-     *
-     * @return true if the server mode is hardcore, false otherwise
-     */
-    public static boolean isHardcore() {
-        return server.isHardcore();
-    }
-
-    /**
-     * Gets whether to use vanilla (false) or exact behaviour (true).
-     *
-     * <ul>
-     * <li>Vanilla behaviour: check for collisions and move the player if
-     *     needed.
-     * <li>Exact behaviour: spawn players exactly where they should be.
-     * </ul>
-     *
-     * @return true if exact location locations are used for spawning, false
-     *     for vanilla collision detection or otherwise
-     *
-     * @deprecated non standard and unused feature.
-     */
-    @Deprecated
-    public static boolean useExactLoginLocation() {
-        return server.useExactLoginLocation();
-    }
- 
-    /**
-     * Shutdowns the server, stopping everything.
-     */
-    public static void shutdown() {
-        server.shutdown();
-    }
-
-    /**
-     * Broadcasts the specified message to every user with the given
-     * permission name.
-     *
-     * @param message message to broadcast
-     * @param permission the required permission {@link Permissible
-     *     permissibles} must have to receive the broadcast
-     * @return number of message recipients
-     */
-    public static int broadcast(String message, String permission) {
-        return server.broadcast(message, permission);
-    }
-
-    /**
-     * Gets the player by the given name, regardless if they are offline or
-     * online.
-     * <p>
-     * This method may involve a blocking web request to get the UUID for the
-     * given name.
-     * <p>
-     * This will return an object even if the player does not exist. To this
-     * method, all players will exist.
-     *
-     * @deprecated Persistent storage of users should be by UUID as names are no longer
-     *             unique past a single session.
-     * @param name the name the player to retrieve
-     * @return an offline player
-     * @see #getOfflinePlayer(java.util.UUID)
-     */
-    @Deprecated
-    public static OfflinePlayer getOfflinePlayer(String name) {
-        return server.getOfflinePlayer(name);
-    }
-
-    /**
-     * Gets the player by the given UUID, regardless if they are offline or
-     * online.
-     * <p>
-     * This will return an object even if the player does not exist. To this
-     * method, all players will exist.
-     *
-     * @param id the UUID of the player to retrieve
-     * @return an offline player
-     */
-    public static OfflinePlayer getOfflinePlayer(UUID id) {
-        return server.getOfflinePlayer(id);
-    }
-
-    /**
-     * Gets a set containing all current IPs that are banned.
-     *
-     * @return a set containing banned IP addresses
-     */
-    public static Set<String> getIPBans() {
-        return server.getIPBans();
-    }
-
-    /**
-     * Bans the specified address from the server.
-     *
-     * @param address the IP address to ban
-     */
-    public static void banIP(String address) {
-        server.banIP(address);
-    }
-
-    /**
-     * Unbans the specified address from the server.
-     *
-     * @param address the IP address to unban
-     */
-    public static void unbanIP(String address) {
-        server.unbanIP(address);
-    }
-
-    /**
-     * Gets a set containing all banned players.
-     *
-     * @return a set containing banned players
-     */
-    public static Set<OfflinePlayer> getBannedPlayers() {
-        return server.getBannedPlayers();
-    }
-
-    /**
-     * Gets a ban list for the supplied type.
-     * <p>
-     * Bans by name are no longer supported and this method will return
-     * null when trying to request them. The replacement is bans by UUID.
-     *
-     * @param type the type of list to fetch, cannot be null
-     * @return a ban list of the specified type
-     */
-    public static BanList getBanList(BanList.Type type){
-        return server.getBanList(type);
-    }
-
-    /**
-     * Gets a set containing all player operators.
-     *
-     * @return a set containing player operators
-     */
-    public static Set<OfflinePlayer> getOperators() {
-        return server.getOperators();
-    }
-
-    /**
-     * Gets the default {@link GameMode} for new players.
-     *
-     * @return the default game mode
-     */
-    public static GameMode getDefaultGameMode() {
-        return server.getDefaultGameMode();
-    }
-
-    /**
-     * Sets the default {@link GameMode} for new players.
-     *
-     * @param mode the new game mode
-     */
-    public static void setDefaultGameMode(GameMode mode) {
-        server.setDefaultGameMode(mode);
-    }
-
-    /**
-     * Gets a {@link ConsoleCommandSender} that may be used as an input source
-     * for this server.
-     *
-     * @return a console command sender
-     */
-    public static ConsoleCommandSender getConsoleSender() {
-        return server.getConsoleSender();
-    }
-
-    /**
-     * Gets the folder that contains all of the various {@link World}s.
-     *
-     * @return folder that contains all worlds
-     */
-    public static File getWorldContainer() {
-        return server.getWorldContainer();
-    }
-
-    /**
-     * Gets every player that has ever played on this server.
-     *
-     * @return an array containing all previous players
-     */
-    public static OfflinePlayer[] getOfflinePlayers() {
-        return server.getOfflinePlayers();
-    }
-
-    /**
-     * Gets the {@link Messenger} responsible for this server.
-     *
-     * @return messenger responsible for this server
-     */
-    public static Messenger getMessenger() {
-        return server.getMessenger();
-    }
-
-    /**
-     * Gets the {@link HelpMap} providing help topics for this server.
-     *
-     * @return a help map for this server
-     */
-    public static HelpMap getHelpMap() {
-        return server.getHelpMap();
-    }
-
-    /**
-     * Creates an empty inventory of the specified type. If the type is {@link
-     * InventoryType#CHEST}, the new inventory has a size of 27; otherwise the
-     * new inventory has the normal size for its type.
-     *
-     * @param owner the holder of the inventory, or null to indicate no holder
-     * @param type the type of inventory to create
-     * @return a new inventory
-     */
-    public static Inventory createInventory(InventoryHolder owner, InventoryType type) {
-        return server.createInventory(owner, type);
-    }
-
-    /**
-     * Creates an empty inventory with the specified type and title. If the type
-     * is {@link InventoryType#CHEST}, the new inventory has a size of 27;
-     * otherwise the new inventory has the normal size for its type.<br>
-     * It should be noted that some inventory types do not support titles and
-     * may not render with said titles on the Minecraft client.
-     *
-     * @param owner The holder of the inventory; can be null if there's no holder.
-     * @param type The type of inventory to create.
-     * @param title The title of the inventory, to be displayed when it is viewed.
-     * @return The new inventory.
-     */
-    public static Inventory createInventory(InventoryHolder owner, InventoryType type, String title) {
-        return server.createInventory(owner, type, title);
-    }
-
-    /**
-     * Creates an empty inventory of type {@link InventoryType#CHEST} with the
-     * specified size.
-     *
-     * @param owner the holder of the inventory, or null to indicate no holder
-     * @param size a multiple of 9 as the size of inventory to create
-     * @return a new inventory
-     * @throws IllegalArgumentException if the size is not a multiple of 9
-     */
-    public static Inventory createInventory(InventoryHolder owner, int size) throws IllegalArgumentException {
-        return server.createInventory(owner, size);
-    }
-
-    /**
-     * Creates an empty inventory of type {@link InventoryType#CHEST} with the
-     * specified size and title.
-     *
-     * @param owner the holder of the inventory, or null to indicate no holder
-     * @param size a multiple of 9 as the size of inventory to create
-     * @param title the title of the inventory, displayed when inventory is
-     *     viewed
-     * @return a new inventory
-     * @throws IllegalArgumentException if the size is not a multiple of 9
-     */
-    public static Inventory createInventory(InventoryHolder owner, int size, String title) throws IllegalArgumentException {
-        return server.createInventory(owner, size, title);
-    }
-
-    /**
-     * Gets user-specified limit for number of monsters that can spawn in a
-     * chunk.
-     *
-     * @return the monster spawn limit
-     */
-    public static int getMonsterSpawnLimit() {
-        return server.getMonsterSpawnLimit();
-    }
-
-    /**
-     * Gets user-specified limit for number of animals that can spawn in a
-     * chunk.
-     *
-     * @return the animal spawn limit
-     */
-    public static int getAnimalSpawnLimit() {
-        return server.getAnimalSpawnLimit();
-    }
-
-    /**
-     * Gets user-specified limit for number of water animals that can spawn in
-     * a chunk.
-     *
-     * @return the water animal spawn limit
-     */
-    public static int getWaterAnimalSpawnLimit() {
-        return server.getWaterAnimalSpawnLimit();
-    }
-    
-    /**
-     * Gets user-specified limit for number of ambient mobs that can spawn in
-     * a chunk.
-     *
-     * @return the ambient spawn limit
-     */
-    public static int getAmbientSpawnLimit() {
-        return server.getAmbientSpawnLimit();
-    }
-
-    /**
-     * Checks the current thread against the expected primary thread for the
-     * server.
-     * <p>
-     * <b>Note:</b> this method should not be used to indicate the current
-     * synchronized state of the runtime. A current thread matching the main
-     * thread indicates that it is synchronized, but a mismatch <b>does not
-     * preclude</b> the same assumption.
-     *
-     * @return true if the current thread matches the expected primary thread,
-     *     false otherwise
-     */
-    public static boolean isPrimaryThread() {
-        return server.isPrimaryThread();
-    }
-
-    /**
-     * Gets the message that is displayed on the server list.
-     *
-     * @return the servers MOTD
-     */
-    public static String getMotd() {
-        return server.getMotd();
-    }
-
-    /**
-     * Gets the default message that is displayed when the server is stopped.
-     *
-     * @return the shutdown message
-     */
-    public static String getShutdownMessage() {
-        return server.getShutdownMessage();
-    }
-
-    /**
-     * Gets the current warning state for the server.
-     *
-     * @return the configured warning state
-     */
-    public static WarningState getWarningState() {
-        return server.getWarningState();
-    }
-
-    /**
-     * Gets the instance of the item factory (for {@link ItemMeta}).
-     *
-     * @return the item factory
-     * @see ItemFactory
-     */
-    public static ItemFactory getItemFactory() {
-        return server.getItemFactory();
-    }
-
-    /**
-     * Gets the instance of the scoreboard manager.
-     * <p>
-     * This will only exist after the first world has loaded.
-     *
-     * @return the scoreboard manager or null if no worlds are loaded.
-     */
-    public static ScoreboardManager getScoreboardManager() {
-        return server.getScoreboardManager();
-    }
-
-    /**
-     * Gets an instance of the server's default server-icon.
-     *
-     * @return the default server-icon; null values may be used by the
-     *     implementation to indicate no defined icon, but this behavior is
-     *     not guaranteed
-     */
-    public static CachedServerIcon getServerIcon() {
-        return server.getServerIcon();
-    }
-
-    /**
-     * Loads an image from a file, and returns a cached image for the specific
-     * server-icon.
-     * <p>
-     * Size and type are implementation defined. An incompatible file is
-     * guaranteed to throw an implementation-defined {@link Exception}.
-     *
-     * @param file the file to load the from
-     * @throws IllegalArgumentException if image is null
-     * @throws Exception if the image does not meet current server server-icon
-     *     specifications
-     * @return a cached server-icon that can be used for a {@link
-     *     ServerListPingEvent#setServerIcon(CachedServerIcon)}
-     */
-    public static CachedServerIcon loadServerIcon(File file) throws IllegalArgumentException, Exception {
-        return server.loadServerIcon(file);
-    }
-
-    /**
-     * Creates a cached server-icon for the specific image.
-     * <p>
-     * Size and type are implementation defined. An incompatible file is
-     * guaranteed to throw an implementation-defined {@link Exception}.
-     *
-     * @param image the image to use
-     * @throws IllegalArgumentException if image is null
-     * @throws Exception if the image does not meet current server
-     *     server-icon specifications
-     * @return a cached server-icon that can be used for a {@link
-     *     ServerListPingEvent#setServerIcon(CachedServerIcon)}
-     */
-    public static CachedServerIcon loadServerIcon(BufferedImage image) throws IllegalArgumentException, Exception {
-        return server.loadServerIcon(image);
-    }
-
-    /**
-     * Set the idle kick timeout. Any players idle for the specified amount of
-     * time will be automatically kicked.
-     * <p>
-     * A value of 0 will disable the idle kick timeout.
-     *
-     * @param threshold the idle timeout in minutes
-     */
-    public static void setIdleTimeout(int threshold) {
-        server.setIdleTimeout(threshold);
-    }
-
-    /**
-     * Gets the idle kick timeout.
-     *
-     * @return the idle timeout in minutes
-     */
-    public static int getIdleTimeout() {
-        return server.getIdleTimeout();
-    }
-
-    /**
-     * Create a ChunkData for use in a generator.
-     * 
-     * See {@link ChunkGenerator#generateChunkData(org.bukkit.World, java.util.Random, int, int, org.bukkit.generator.ChunkGenerator.BiomeGrid)}
-     * 
-     * @param world the world to create the ChunkData for
-     * @return a new ChunkData for the world
-     * 
-     */
-    public static ChunkGenerator.ChunkData createChunkData(World world) {
-        return server.createChunkData(world);
-    }
-
-    /**
-     * Creates a boss bar instance to display to players. The progress
-     * defaults to 1.0
-     *
-     * @param title the title of the boss bar
-     * @param color the color of the boss bar
-     * @param style the style of the boss bar
-     * @param flags an optional list of flags to set on the boss bar
-     * @return the created boss bar
-     */
-    public static BossBar createBossBar(String title, BarColor color, BarStyle style, BarFlag... flags) {
-        return server.createBossBar(title, color, style, flags);
-    }
-
-    /**
-     * Gets the current server TPS
-     * @return current server TPS (1m, 5m, 15m in Paper-Server)
-     */
-    public static double[] getTPS() {
-        return server.getTPS();
-    }
-
-    /**
-     * @see UnsafeValues
-     * @return the unsafe values instance
-     */
-    @Deprecated
-    public static UnsafeValues getUnsafe() {
-        return server.getUnsafe();
-    }
-
-    // Paper start
-    /**
-     * Gets the active {@link CommandMap}
-     *
-     * @return the active command map
-     */
-    public static CommandMap getCommandMap() {
-        return server.getCommandMap();
-    }
-
-    /**
-     * Reload the Permissions in permissions.yml
-     */
-    public static void reloadPermissions() {
-        server.reloadPermissions();
-    }
-
-    /**
-     * Find an entity on the server by its UUID
-     *
-     * @param uuid The UUID of the entity
-     * @return The entity that is identified by the given UUID, or null if one isn't found
-     */
-    public static Entity getEntity(UUID uuid) {
-        return server.getEntity(uuid);
-    }
-    // Paper end
-
-    public static Server.Spigot spigot()
-    {
-        return server.spigot();
-    }
-	
-	// Paper start
-  /**
-   * Get the server's profile lookup
-   *
-   * @return the server's profile lookup
-   */
-  public static ProfileLookup getProfileLookup() {
-      return getServer().getProfileLookup();
-  }
-  // Paper end
-}
diff --git a/src/main/java/org/bukkit/ChatColor.java b/src/main/java/org/bukkit/ChatColor.java
deleted file mode 100644
index b8872b4..0000000
--- a/src/main/java/org/bukkit/ChatColor.java
+++ /dev/null
@@ -1,257 +0,0 @@
-package org.bukkit;
-
-import java.util.Map;
-import java.util.regex.Pattern;
-
-import org.apache.commons.lang.Validate;
-
-import com.google.common.collect.Maps;
-
-/**
- * All supported color values for chat
- */
-public enum ChatColor {
-    /**
-     * Represents black
-     */
-    BLACK('0', 0x00),
-    /**
-     * Represents dark blue
-     */
-    DARK_BLUE('1', 0x1),
-    /**
-     * Represents dark green
-     */
-    DARK_GREEN('2', 0x2),
-    /**
-     * Represents dark blue (aqua)
-     */
-    DARK_AQUA('3', 0x3),
-    /**
-     * Represents dark red
-     */
-    DARK_RED('4', 0x4),
-    /**
-     * Represents dark purple
-     */
-    DARK_PURPLE('5', 0x5),
-    /**
-     * Represents gold
-     */
-    GOLD('6', 0x6),
-    /**
-     * Represents gray
-     */
-    GRAY('7', 0x7),
-    /**
-     * Represents dark gray
-     */
-    DARK_GRAY('8', 0x8),
-    /**
-     * Represents blue
-     */
-    BLUE('9', 0x9),
-    /**
-     * Represents green
-     */
-    GREEN('a', 0xA),
-    /**
-     * Represents aqua
-     */
-    AQUA('b', 0xB),
-    /**
-     * Represents red
-     */
-    RED('c', 0xC),
-    /**
-     * Represents light purple
-     */
-    LIGHT_PURPLE('d', 0xD),
-    /**
-     * Represents yellow
-     */
-    YELLOW('e', 0xE),
-    /**
-     * Represents white
-     */
-    WHITE('f', 0xF),
-    /**
-     * Represents magical characters that change around randomly
-     */
-    MAGIC('k', 0x10, true),
-    /**
-     * Makes the text bold.
-     */
-    BOLD('l', 0x11, true),
-    /**
-     * Makes a line appear through the text.
-     */
-    STRIKETHROUGH('m', 0x12, true),
-    /**
-     * Makes the text appear underlined.
-     */
-    UNDERLINE('n', 0x13, true),
-    /**
-     * Makes the text italic.
-     */
-    ITALIC('o', 0x14, true),
-    /**
-     * Resets all previous chat colors or formats.
-     */
-    RESET('r', 0x15);
-
-    /**
-     * The special character which prefixes all chat colour codes. Use this if
-     * you need to dynamically convert colour codes from your custom format.
-     */
-    public static final char COLOR_CHAR = '\u00A7';
-    private static final Pattern STRIP_COLOR_PATTERN = Pattern.compile("(?i)" + String.valueOf(COLOR_CHAR) + "[0-9A-FK-OR]");
-
-    private final int intCode;
-    private final char code;
-    private final boolean isFormat;
-    private final String toString;
-    private final static Map<Integer, ChatColor> BY_ID = Maps.newHashMap();
-    private final static Map<Character, ChatColor> BY_CHAR = Maps.newHashMap();
-
-    private ChatColor(char code, int intCode) {
-        this(code, intCode, false);
-    }
-
-    private ChatColor(char code, int intCode, boolean isFormat) {
-        this.code = code;
-        this.intCode = intCode;
-        this.isFormat = isFormat;
-        this.toString = new String(new char[] {COLOR_CHAR, code});
-    }
-
-    /**
-     * Gets the char value associated with this color
-     *
-     * @return A char value of this color code
-     */
-    public char getChar() {
-        return code;
-    }
-
-    @Override
-    public String toString() {
-        return toString;
-    }
-
-    /**
-     * Checks if this code is a format code as opposed to a color code.
-     * 
-     * @return whether this ChatColor is a format code
-     */
-    public boolean isFormat() {
-        return isFormat;
-    }
-
-    /**
-     * Checks if this code is a color code as opposed to a format code.
-     * 
-     * @return whether this ChatColor is a color code
-     */
-    public boolean isColor() {
-        return !isFormat && this != RESET;
-    }
-
-    /**
-     * Gets the color represented by the specified color code
-     *
-     * @param code Code to check
-     * @return Associative {@link org.bukkit.ChatColor} with the given code,
-     *     or null if it doesn't exist
-     */
-    public static ChatColor getByChar(char code) {
-        return BY_CHAR.get(code);
-    }
-
-    /**
-     * Gets the color represented by the specified color code
-     *
-     * @param code Code to check
-     * @return Associative {@link org.bukkit.ChatColor} with the given code,
-     *     or null if it doesn't exist
-     */
-    public static ChatColor getByChar(String code) {
-        Validate.notNull(code, "Code cannot be null");
-        Validate.isTrue(code.length() > 0, "Code must have at least one char");
-
-        return BY_CHAR.get(code.charAt(0));
-    }
-
-    /**
-     * Strips the given message of all color codes
-     *
-     * @param input String to strip of color
-     * @return A copy of the input string, without any coloring
-     */
-    public static String stripColor(final String input) {
-        if (input == null) {
-            return null;
-        }
-
-        return STRIP_COLOR_PATTERN.matcher(input).replaceAll("");
-    }
-
-    /**
-     * Translates a string using an alternate color code character into a
-     * string that uses the internal ChatColor.COLOR_CODE color code
-     * character. The alternate color code character will only be replaced if
-     * it is immediately followed by 0-9, A-F, a-f, K-O, k-o, R or r.
-     *
-     * @param altColorChar The alternate color code character to replace. Ex: {@literal &}
-     * @param textToTranslate Text containing the alternate color code character.
-     * @return Text containing the ChatColor.COLOR_CODE color code character.
-     */
-    public static String translateAlternateColorCodes(char altColorChar, String textToTranslate) {
-        char[] b = textToTranslate.toCharArray();
-        for (int i = 0; i < b.length - 1; i++) {
-            if (b[i] == altColorChar && "0123456789AaBbCcDdEeFfKkLlMmNnOoRr".indexOf(b[i+1]) > -1) {
-                b[i] = ChatColor.COLOR_CHAR;
-                b[i+1] = Character.toLowerCase(b[i+1]);
-            }
-        }
-        return new String(b);
-    }
-
-    /**
-     * Gets the ChatColors used at the end of the given input string.
-     *
-     * @param input Input string to retrieve the colors from.
-     * @return Any remaining ChatColors to pass onto the next line.
-     */
-    public static String getLastColors(String input) {
-        String result = "";
-        int length = input.length();
-
-        // Search backwards from the end as it is faster
-        for (int index = length - 1; index > -1; index--) {
-            char section = input.charAt(index);
-            if (section == COLOR_CHAR && index < length - 1) {
-                char c = input.charAt(index + 1);
-                ChatColor color = getByChar(c);
-
-                if (color != null) {
-                    result = color.toString() + result;
-
-                    // Once we find a color or reset we can stop searching
-                    if (color.isColor() || color.equals(RESET)) {
-                        break;
-                    }
-                }
-            }
-        }
-
-        return result;
-    }
-
-    static {
-        for (ChatColor color : values()) {
-            BY_ID.put(color.intCode, color);
-            BY_CHAR.put(color.code, color);
-        }
-    }
-}
diff --git a/src/main/java/org/bukkit/Chunk.java b/src/main/java/org/bukkit/Chunk.java
deleted file mode 100644
index f39aabc..0000000
--- a/src/main/java/org/bukkit/Chunk.java
+++ /dev/null
@@ -1,126 +0,0 @@
-package org.bukkit;
-
-import org.bukkit.block.Block;
-import org.bukkit.block.BlockState;
-import org.bukkit.entity.Entity;
-
-/**
- * Represents a chunk of blocks
- */
-public interface Chunk {
-
-    /**
-     * Gets the X-coordinate of this chunk
-     *
-     * @return X-coordinate
-     */
-    int getX();
-
-    /**
-     * Gets the Z-coordinate of this chunk
-     *
-     * @return Z-coordinate
-     */
-    int getZ();
-
-    /**
-     * Gets the world containing this chunk
-     *
-     * @return Parent World
-     */
-    World getWorld();
-
-    /**
-     * Gets a block from this chunk
-     *
-     * @param x 0-15
-     * @param y 0-127
-     * @param z 0-15
-     * @return the Block
-     */
-    Block getBlock(int x, int y, int z);
-
-    /**
-     * Capture thread-safe read-only snapshot of chunk data
-     *
-     * @return ChunkSnapshot
-     */
-    ChunkSnapshot getChunkSnapshot();
-
-    /**
-     * Capture thread-safe read-only snapshot of chunk data
-     *
-     * @param includeMaxblocky - if true, snapshot includes per-coordinate
-     *     maximum Y values
-     * @param includeBiome - if true, snapshot includes per-coordinate biome
-     *     type
-     * @param includeBiomeTempRain - if true, snapshot includes per-coordinate
-     *     raw biome temperature and rainfall
-     * @return ChunkSnapshot
-     */
-    ChunkSnapshot getChunkSnapshot(boolean includeMaxblocky, boolean includeBiome, boolean includeBiomeTempRain);
-
-    /**
-     * Get a list of all entities in the chunk.
-     *
-     * @return The entities.
-     */
-    Entity[] getEntities();
-
-    /**
-     * Get a list of all tile entities in the chunk.
-     *
-     * @return The tile entities.
-     */
-    BlockState[] getTileEntities();
-
-    /**
-     * Checks if the chunk is loaded.
-     *
-     * @return True if it is loaded.
-     */
-    boolean isLoaded();
-
-    /**
-     * Loads the chunk.
-     *
-     * @param generate Whether or not to generate a chunk if it doesn't
-     *     already exist
-     * @return true if the chunk has loaded successfully, otherwise false
-     */
-    boolean load(boolean generate);
-
-    /**
-     * Loads the chunk.
-     *
-     * @return true if the chunk has loaded successfully, otherwise false
-     */
-    boolean load();
-
-    /**
-     * Unloads and optionally saves the Chunk
-     *
-     * @param save Controls whether the chunk is saved
-     * @param safe Controls whether to unload the chunk when players are
-     *     nearby
-     * @return true if the chunk has unloaded successfully, otherwise false
-     * @deprecated it is never safe to remove a chunk in use
-     */
-    @Deprecated
-    boolean unload(boolean save, boolean safe);
-
-    /**
-     * Unloads and optionally saves the Chunk
-     *
-     * @param save Controls whether the chunk is saved
-     * @return true if the chunk has unloaded successfully, otherwise false
-     */
-    boolean unload(boolean save);
-
-    /**
-     * Unloads and optionally saves the Chunk
-     *
-     * @return true if the chunk has unloaded successfully, otherwise false
-     */
-    boolean unload();
-}
diff --git a/src/main/java/org/bukkit/ChunkSnapshot.java b/src/main/java/org/bukkit/ChunkSnapshot.java
deleted file mode 100644
index 83fccc8..0000000
--- a/src/main/java/org/bukkit/ChunkSnapshot.java
+++ /dev/null
@@ -1,129 +0,0 @@
-package org.bukkit;
-
-import org.bukkit.block.Biome;
-
-/**
- * Represents a static, thread-safe snapshot of chunk of blocks.
- * <p>
- * Purpose is to allow clean, efficient copy of a chunk data to be made, and
- * then handed off for processing in another thread (e.g. map rendering)
- */
-public interface ChunkSnapshot {
-
-    /**
-     * Gets the X-coordinate of this chunk
-     *
-     * @return X-coordinate
-     */
-    int getX();
-
-    /**
-     * Gets the Z-coordinate of this chunk
-     *
-     * @return Z-coordinate
-     */
-    int getZ();
-
-    /**
-     * Gets name of the world containing this chunk
-     *
-     * @return Parent World Name
-     */
-    String getWorldName();
-
-    /**
-     * Get block type for block at corresponding coordinate in the chunk
-     *
-     * @param x 0-15
-     * @param y 0-127
-     * @param z 0-15
-     * @return 0-255
-     * @deprecated Magic value
-     */
-    @Deprecated
-    int getBlockTypeId(int x, int y, int z);
-
-    /**
-     * Get block data for block at corresponding coordinate in the chunk
-     *
-     * @param x 0-15
-     * @param y 0-127
-     * @param z 0-15
-     * @return 0-15
-     * @deprecated Magic value
-     */
-    @Deprecated
-    int getBlockData(int x, int y, int z);
-
-    /**
-     * Get sky light level for block at corresponding coordinate in the chunk
-     *
-     * @param x 0-15
-     * @param y 0-127
-     * @param z 0-15
-     * @return 0-15
-     */
-    int getBlockSkyLight(int x, int y, int z);
-
-    /**
-     * Get light level emitted by block at corresponding coordinate in the
-     * chunk
-     *
-     * @param x 0-15
-     * @param y 0-127
-     * @param z 0-15
-     * @return 0-15
-     */
-    int getBlockEmittedLight(int x, int y, int z);
-
-    /**
-     * Gets the highest non-air coordinate at the given coordinates
-     *
-     * @param x X-coordinate of the blocks
-     * @param z Z-coordinate of the blocks
-     * @return Y-coordinate of the highest non-air block
-     */
-    int getHighestBlockYAt(int x, int z);
-
-    /**
-     * Get biome at given coordinates
-     *
-     * @param x X-coordinate
-     * @param z Z-coordinate
-     * @return Biome at given coordinate
-     */
-    Biome getBiome(int x, int z);
-
-    /**
-     * Get raw biome temperature (0.0-1.0) at given coordinate
-     *
-     * @param x X-coordinate
-     * @param z Z-coordinate
-     * @return temperature at given coordinate
-     */
-    double getRawBiomeTemperature(int x, int z);
-
-    /**
-     * Get raw biome rainfall (0.0-1.0) at given coordinate
-     *
-     * @param x X-coordinate
-     * @param z Z-coordinate
-     * @return rainfall at given coordinate
-     */
-    double getRawBiomeRainfall(int x, int z);
-
-    /**
-     * Get world full time when chunk snapshot was captured
-     *
-     * @return time in ticks
-     */
-    long getCaptureFullTime();
-
-    /**
-     * Test if section is empty
-     *
-     * @param sy - section Y coordinate (block Y / 16)
-     * @return true if empty, false if not
-     */
-    boolean isSectionEmpty(int sy);
-}
diff --git a/src/main/java/org/bukkit/CoalType.java b/src/main/java/org/bukkit/CoalType.java
deleted file mode 100644
index 4fcccd2..0000000
--- a/src/main/java/org/bukkit/CoalType.java
+++ /dev/null
@@ -1,50 +0,0 @@
-package org.bukkit;
-
-import java.util.Map;
-
-import com.google.common.collect.Maps;
-
-/**
- * Represents the two types of coal
- */
-public enum CoalType {
-    COAL(0x0),
-    CHARCOAL(0x1);
-
-    private final byte data;
-    private final static Map<Byte, CoalType> BY_DATA = Maps.newHashMap();
-
-    private CoalType(final int data) {
-        this.data = (byte) data;
-    }
-
-    /**
-     * Gets the associated data value representing this type of coal
-     *
-     * @return A byte containing the data value of this coal type
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public byte getData() {
-        return data;
-    }
-
-    /**
-     * Gets the type of coal with the given data value
-     *
-     * @param data Data value to fetch
-     * @return The {@link CoalType} representing the given value, or null if
-     *     it doesn't exist
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public static CoalType getByData(final byte data) {
-        return BY_DATA.get(data);
-    }
-
-    static {
-        for (CoalType type : values()) {
-            BY_DATA.put(type.data, type);
-        }
-    }
-}
diff --git a/src/main/java/org/bukkit/Color.java b/src/main/java/org/bukkit/Color.java
deleted file mode 100644
index 83927dd..0000000
--- a/src/main/java/org/bukkit/Color.java
+++ /dev/null
@@ -1,344 +0,0 @@
-package org.bukkit;
-
-import java.util.Map;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.configuration.serialization.ConfigurationSerializable;
-import org.bukkit.configuration.serialization.SerializableAs;
-
-import com.google.common.collect.ImmutableMap;
-
-/**
- * A container for a color palette. This class is immutable; the set methods
- * return a new color. The color names listed as fields are HTML4 standards,
- * but subject to change.
- */
-@SerializableAs("Color")
-public final class Color implements ConfigurationSerializable {
-    private static final int BIT_MASK = 0xff;
-
-    /**
-     * White, or (0xFF,0xFF,0xFF) in (R,G,B)
-     */
-    public static final Color WHITE = fromRGB(0xFFFFFF);
-
-    /**
-     * Silver, or (0xC0,0xC0,0xC0) in (R,G,B)
-     */
-    public static final Color SILVER = fromRGB(0xC0C0C0);
-
-    /**
-     * Gray, or (0x80,0x80,0x80) in (R,G,B)
-     */
-    public static final Color GRAY = fromRGB(0x808080);
-
-    /**
-     * Black, or (0x00,0x00,0x00) in (R,G,B)
-     */
-    public static final Color BLACK = fromRGB(0x000000);
-
-    /**
-     * Red, or (0xFF,0x00,0x00) in (R,G,B)
-     */
-    public static final Color RED = fromRGB(0xFF0000);
-
-    /**
-     * Maroon, or (0x80,0x00,0x00) in (R,G,B)
-     */
-    public static final Color MAROON = fromRGB(0x800000);
-
-    /**
-     * Yellow, or (0xFF,0xFF,0x00) in (R,G,B)
-     */
-    public static final Color YELLOW = fromRGB(0xFFFF00);
-
-    /**
-     * Olive, or (0x80,0x80,0x00) in (R,G,B)
-     */
-    public static final Color OLIVE = fromRGB(0x808000);
-
-    /**
-     * Lime, or (0x00,0xFF,0x00) in (R,G,B)
-     */
-    public static final Color LIME = fromRGB(0x00FF00);
-
-    /**
-     * Green, or (0x00,0x80,0x00) in (R,G,B)
-     */
-    public static final Color GREEN = fromRGB(0x008000);
-
-    /**
-     * Aqua, or (0x00,0xFF,0xFF) in (R,G,B)
-     */
-    public static final Color AQUA = fromRGB(0x00FFFF);
-
-    /**
-     * Teal, or (0x00,0x80,0x80) in (R,G,B)
-     */
-    public static final Color TEAL = fromRGB(0x008080);
-
-    /**
-     * Blue, or (0x00,0x00,0xFF) in (R,G,B)
-     */
-    public static final Color BLUE = fromRGB(0x0000FF);
-
-    /**
-     * Navy, or (0x00,0x00,0x80) in (R,G,B)
-     */
-    public static final Color NAVY = fromRGB(0x000080);
-
-    /**
-     * Fuchsia, or (0xFF,0x00,0xFF) in (R,G,B)
-     */
-    public static final Color FUCHSIA = fromRGB(0xFF00FF);
-
-    /**
-     * Purple, or (0x80,0x00,0x80) in (R,G,B)
-     */
-    public static final Color PURPLE = fromRGB(0x800080);
-
-    /**
-     * Orange, or (0xFF,0xA5,0x00) in (R,G,B)
-     */
-    public static final Color ORANGE = fromRGB(0xFFA500);
-
-    private final byte red;
-    private final byte green;
-    private final byte blue;
-
-    /**
-     * Creates a new Color object from a red, green, and blue
-     *
-     * @param red integer from 0-255
-     * @param green integer from 0-255
-     * @param blue integer from 0-255
-     * @return a new Color object for the red, green, blue
-     * @throws IllegalArgumentException if any value is strictly {@literal >255 or <0}
-     */
-    public static Color fromRGB(int red, int green, int blue) throws IllegalArgumentException {
-        return new Color(red, green, blue);
-    }
-
-    /**
-     * Creates a new Color object from a blue, green, and red
-     *
-     * @param blue integer from 0-255
-     * @param green integer from 0-255
-     * @param red integer from 0-255
-     * @return a new Color object for the red, green, blue
-     * @throws IllegalArgumentException if any value is strictly {@literal >255 or <0}
-     */
-    public static Color fromBGR(int blue, int green, int red) throws IllegalArgumentException {
-        return new Color(red, green, blue);
-    }
-
-    /**
-     * Creates a new color object from an integer that contains the red,
-     * green, and blue bytes in the lowest order 24 bits.
-     *
-     * @param rgb the integer storing the red, green, and blue values
-     * @return a new color object for specified values
-     * @throws IllegalArgumentException if any data is in the highest order 8
-     *     bits
-     */
-    public static Color fromRGB(int rgb) throws IllegalArgumentException {
-        Validate.isTrue((rgb >> 24) == 0, "Extrenuous data in: ", rgb);
-        return fromRGB(rgb >> 16 & BIT_MASK, rgb >> 8 & BIT_MASK, rgb >> 0 & BIT_MASK);
-    }
-
-    /**
-     * Creates a new color object from an integer that contains the blue,
-     * green, and red bytes in the lowest order 24 bits.
-     *
-     * @param bgr the integer storing the blue, green, and red values
-     * @return a new color object for specified values
-     * @throws IllegalArgumentException if any data is in the highest order 8
-     *     bits
-     */
-    public static Color fromBGR(int bgr) throws IllegalArgumentException {
-        Validate.isTrue((bgr >> 24) == 0, "Extrenuous data in: ", bgr);
-        return fromBGR(bgr >> 16 & BIT_MASK, bgr >> 8 & BIT_MASK, bgr >> 0 & BIT_MASK);
-    }
-
-    private Color(int red, int green, int blue) {
-        Validate.isTrue(red >= 0 && red <= BIT_MASK, "Red is not between 0-255: ", red);
-        Validate.isTrue(green >= 0 && green <= BIT_MASK, "Green is not between 0-255: ", green);
-        Validate.isTrue(blue >= 0 && blue <= BIT_MASK, "Blue is not between 0-255: ", blue);
-
-        this.red = (byte) red;
-        this.green = (byte) green;
-        this.blue = (byte) blue;
-    }
-
-    /**
-     * Gets the red component
-     *
-     * @return red component, from 0 to 255
-     */
-    public int getRed() {
-        return BIT_MASK & red;
-    }
-
-    /**
-     * Creates a new Color object with specified component
-     *
-     * @param red the red component, from 0 to 255
-     * @return a new color object with the red component
-     */
-    public Color setRed(int red) {
-        return fromRGB(red, getGreen(), getBlue());
-    }
-
-    /**
-     * Gets the green component
-     *
-     * @return green component, from 0 to 255
-     */
-    public int getGreen() {
-        return BIT_MASK & green;
-    }
-
-    /**
-     * Creates a new Color object with specified component
-     *
-     * @param green the red component, from 0 to 255
-     * @return a new color object with the red component
-     */
-    public Color setGreen(int green) {
-        return fromRGB(getRed(), green, getBlue());
-    }
-
-    /**
-     * Gets the blue component
-     *
-     * @return blue component, from 0 to 255
-     */
-    public int getBlue() {
-        return BIT_MASK & blue;
-    }
-
-    /**
-     * Creates a new Color object with specified component
-     *
-     * @param blue the red component, from 0 to 255
-     * @return a new color object with the red component
-     */
-    public Color setBlue(int blue) {
-        return fromRGB(getRed(), getGreen(), blue);
-    }
-
-    /**
-     *
-     * @return An integer representation of this color, as 0xRRGGBB
-     */
-    public int asRGB() {
-        return getRed() << 16 | getGreen() << 8 | getBlue() << 0;
-    }
-
-    /**
-     *
-     * @return An integer representation of this color, as 0xBBGGRR
-     */
-    public int asBGR() {
-        return getBlue() << 16 | getGreen() << 8 | getRed() << 0;
-    }
-
-    /**
-     * Creates a new color with its RGB components changed as if it was dyed
-     * with the colors passed in, replicating vanilla workbench dyeing
-     *
-     * @param colors The DyeColors to dye with
-     * @return A new color with the changed rgb components
-     */
-    // TODO: Javadoc what this method does, not what it mimics. API != Implementation
-    public Color mixDyes(DyeColor... colors) {
-        Validate.noNullElements(colors, "Colors cannot be null");
-
-        Color[] toPass = new Color[colors.length];
-        for (int i = 0; i < colors.length; i++) {
-            toPass[i] = colors[i].getColor();
-        }
-
-        return mixColors(toPass);
-    }
-
-    /**
-     * Creates a new color with its RGB components changed as if it was dyed
-     * with the colors passed in, replicating vanilla workbench dyeing
-     *
-     * @param colors The colors to dye with
-     * @return A new color with the changed rgb components
-     */
-    // TODO: Javadoc what this method does, not what it mimics. API != Implementation
-    public Color mixColors(Color... colors) {
-        Validate.noNullElements(colors, "Colors cannot be null");
-
-        int totalRed = this.getRed();
-        int totalGreen = this.getGreen();
-        int totalBlue = this.getBlue();
-        int totalMax = Math.max(Math.max(totalRed, totalGreen), totalBlue);
-        for (Color color : colors) {
-            totalRed += color.getRed();
-            totalGreen += color.getGreen();
-            totalBlue += color.getBlue();
-            totalMax += Math.max(Math.max(color.getRed(), color.getGreen()), color.getBlue());
-        }
-
-        float averageRed = totalRed / (colors.length + 1);
-        float averageGreen = totalGreen / (colors.length + 1);
-        float averageBlue = totalBlue / (colors.length + 1);
-        float averageMax = totalMax / (colors.length + 1);
-
-        float maximumOfAverages = Math.max(Math.max(averageRed, averageGreen), averageBlue);
-        float gainFactor = averageMax / maximumOfAverages;
-
-        return Color.fromRGB((int) (averageRed * gainFactor), (int) (averageGreen * gainFactor), (int) (averageBlue * gainFactor));
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        if (!(o instanceof Color)) {
-            return false;
-        }
-        final Color that = (Color) o;
-        return this.blue == that.blue && this.green == that.green && this.red == that.red;
-    }
-
-    @Override
-    public int hashCode() {
-        return asRGB() ^ Color.class.hashCode();
-    }
-
-    public Map<String, Object> serialize() {
-        return ImmutableMap.<String, Object>of(
-            "RED", getRed(),
-            "BLUE", getBlue(),
-            "GREEN", getGreen()
-        );
-    }
-
-    @SuppressWarnings("javadoc")
-    public static Color deserialize(Map<String, Object> map) {
-        return fromRGB(
-            asInt("RED", map),
-            asInt("GREEN", map),
-            asInt("BLUE", map)
-        );
-    }
-
-    private static int asInt(String string, Map<String, Object> map) {
-        Object value = map.get(string);
-        if (value == null) {
-            throw new IllegalArgumentException(string + " not in map " + map);
-        }
-        if (!(value instanceof Number)) {
-            throw new IllegalArgumentException(string + '(' + value + ") is not a number");
-        }
-        return ((Number) value).intValue();
-    }
-
-    @Override
-    public String toString() {
-        return "Color:[rgb0x" + Integer.toHexString(getRed()).toUpperCase() + Integer.toHexString(getGreen()).toUpperCase() + Integer.toHexString(getBlue()).toUpperCase() + "]";
-    }
-}
diff --git a/src/main/java/org/bukkit/CropState.java b/src/main/java/org/bukkit/CropState.java
deleted file mode 100644
index ef0faf9..0000000
--- a/src/main/java/org/bukkit/CropState.java
+++ /dev/null
@@ -1,81 +0,0 @@
-package org.bukkit;
-
-import java.util.Map;
-
-import com.google.common.collect.Maps;
-
-/**
- * Represents the different growth states of crops
- */
-public enum CropState {
-
-    /**
-     * State when first seeded
-     */
-    SEEDED(0x0),
-    /**
-     * First growth stage
-     */
-    GERMINATED(0x1),
-    /**
-     * Second growth stage
-     */
-    VERY_SMALL(0x2),
-    /**
-     * Third growth stage
-     */
-    SMALL(0x3),
-    /**
-     * Fourth growth stage
-     */
-    MEDIUM(0x4),
-    /**
-     * Fifth growth stage
-     */
-    TALL(0x5),
-    /**
-     * Almost ripe stage
-     */
-    VERY_TALL(0x6),
-    /**
-     * Ripe stage
-     */
-    RIPE(0x7);
-
-    private final byte data;
-    private final static Map<Byte, CropState> BY_DATA = Maps.newHashMap();
-
-    private CropState(final int data) {
-        this.data = (byte) data;
-    }
-
-    /**
-     * Gets the associated data value representing this growth state
-     *
-     * @return A byte containing the data value of this growth state
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public byte getData() {
-        return data;
-    }
-
-    /**
-     * Gets the CropState with the given data value
-     *
-     * @param data Data value to fetch
-     * @return The {@link CropState} representing the given value, or null if
-     *     it doesn't exist
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public static CropState getByData(final byte data) {
-        return BY_DATA.get(data);
-    }
-
-    static {
-        for (CropState cropState : values()) {
-            BY_DATA.put(cropState.getData(), cropState);
-        }
-    }
-}
diff --git a/src/main/java/org/bukkit/Difficulty.java b/src/main/java/org/bukkit/Difficulty.java
deleted file mode 100644
index a8a5a78..0000000
--- a/src/main/java/org/bukkit/Difficulty.java
+++ /dev/null
@@ -1,72 +0,0 @@
-package org.bukkit;
-
-import java.util.Map;
-
-import com.google.common.collect.Maps;
-
-/**
- * Represents the various difficulty levels that are available.
- */
-public enum Difficulty {
-    /**
-     * Players regain health over time, hostile mobs don't spawn, the hunger
-     * bar does not deplete.
-     */
-    PEACEFUL(0),
-
-    /**
-     * Hostile mobs spawn, enemies deal less damage than on normal difficulty,
-     * the hunger bar does deplete and starving deals up to 5 hearts of
-     * damage. (Default value)
-     */
-    EASY(1),
-
-    /**
-     * Hostile mobs spawn, enemies deal normal amounts of damage, the hunger
-     * bar does deplete and starving deals up to 9.5 hearts of damage.
-     */
-    NORMAL(2),
-
-    /**
-     * Hostile mobs spawn, enemies deal greater damage than on normal
-     * difficulty, the hunger bar does deplete and starving can kill players.
-     */
-    HARD(3);
-
-    private final int value;
-    private final static Map<Integer, Difficulty> BY_ID = Maps.newHashMap();
-
-    private Difficulty(final int value) {
-        this.value = value;
-    }
-
-    /**
-     * Gets the difficulty value associated with this Difficulty.
-     *
-     * @return An integer value of this difficulty
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public int getValue() {
-        return value;
-    }
-
-    /**
-     * Gets the Difficulty represented by the specified value
-     *
-     * @param value Value to check
-     * @return Associative {@link Difficulty} with the given value, or null if
-     *     it doesn't exist
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public static Difficulty getByValue(final int value) {
-        return BY_ID.get(value);
-    }
-
-    static {
-        for (Difficulty diff : values()) {
-            BY_ID.put(diff.value, diff);
-        }
-    }
-}
diff --git a/src/main/java/org/bukkit/DyeColor.java b/src/main/java/org/bukkit/DyeColor.java
deleted file mode 100644
index 214806e..0000000
--- a/src/main/java/org/bukkit/DyeColor.java
+++ /dev/null
@@ -1,239 +0,0 @@
-package org.bukkit;
-
-import java.util.Map;
-
-import com.google.common.collect.ImmutableMap;
-
-/**
- * All supported color values for dyes and cloth
- */
-public enum DyeColor {
-
-    /**
-     * Represents white dye.
-     */
-    WHITE(0x0, 0xF, Color.WHITE, Color.fromRGB(0xF0F0F0)),
-    /**
-     * Represents orange dye.
-     */
-    ORANGE(0x1, 0xE, Color.fromRGB(0xD87F33), Color.fromRGB(0xEB8844)),
-    /**
-     * Represents magenta dye.
-     */
-    MAGENTA(0x2, 0xD, Color.fromRGB(0xB24CD8), Color.fromRGB(0xC354CD)),
-    /**
-     * Represents light blue dye.
-     */
-    LIGHT_BLUE(0x3, 0xC, Color.fromRGB(0x6699D8), Color.fromRGB(0x6689D3)),
-    /**
-     * Represents yellow dye.
-     */
-    YELLOW(0x4, 0xB, Color.fromRGB(0xE5E533), Color.fromRGB(0xDECF2A)),
-    /**
-     * Represents lime dye.
-     */
-    LIME(0x5, 0xA, Color.fromRGB(0x7FCC19), Color.fromRGB(0x41CD34)),
-    /**
-     * Represents pink dye.
-     */
-    PINK(0x6, 0x9, Color.fromRGB(0xF27FA5), Color.fromRGB(0xD88198)),
-    /**
-     * Represents gray dye.
-     */
-    GRAY(0x7, 0x8, Color.fromRGB(0x4C4C4C), Color.fromRGB(0x434343)),
-    /**
-     * Represents silver dye.
-     */
-    SILVER(0x8, 0x7, Color.fromRGB(0x999999), Color.fromRGB(0xABABAB)),
-    /**
-     * Represents cyan dye.
-     */
-    CYAN(0x9, 0x6, Color.fromRGB(0x4C7F99), Color.fromRGB(0x287697)),
-    /**
-     * Represents purple dye.
-     */
-    PURPLE(0xA, 0x5, Color.fromRGB(0x7F3FB2), Color.fromRGB(0x7B2FBE)),
-    /**
-     * Represents blue dye.
-     */
-    BLUE(0xB, 0x4, Color.fromRGB(0x334CB2), Color.fromRGB(0x253192)),
-    /**
-     * Represents brown dye.
-     */
-    BROWN(0xC, 0x3, Color.fromRGB(0x664C33), Color.fromRGB(0x51301A)),
-    /**
-     * Represents green dye.
-     */
-    GREEN(0xD, 0x2, Color.fromRGB(0x667F33), Color.fromRGB(0x3B511A)),
-    /**
-     * Represents red dye.
-     */
-    RED(0xE, 0x1, Color.fromRGB(0x993333), Color.fromRGB(0xB3312C)),
-    /**
-     * Represents black dye.
-     */
-    BLACK(0xF, 0x0, Color.fromRGB(0x191919), Color.fromRGB(0x1E1B1B));
-
-    private final byte woolData;
-    private final byte dyeData;
-    private final Color color;
-    private final Color firework;
-    private final static DyeColor[] BY_WOOL_DATA;
-    private final static DyeColor[] BY_DYE_DATA;
-    private final static Map<Color, DyeColor> BY_COLOR;
-    private final static Map<Color, DyeColor> BY_FIREWORK;
-
-    private DyeColor(final int woolData, final int dyeData, Color color, Color firework) {
-        this.woolData = (byte) woolData;
-        this.dyeData = (byte) dyeData;
-        this.color = color;
-        this.firework = firework;
-    }
-
-    /**
-     * Gets the associated (wool) data value representing this color.
-     *
-     * @return A byte containing the (wool) data value of this color
-     * @deprecated The name is misleading. It would imply {@link
-     *     Material#INK_SACK} but uses {@link Material#WOOL}
-     * @see #getWoolData()
-     * @see #getDyeData()
-     */
-    @Deprecated
-    public byte getData() {
-        return getWoolData();
-    }
-
-    /**
-     * Gets the associated wool data value representing this color.
-     *
-     * @return A byte containing the wool data value of this color
-     * @see #getDyeData()
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public byte getWoolData() {
-        return woolData;
-    }
-
-    /**
-     * Gets the associated dye data value representing this color.
-     *
-     * @return A byte containing the dye data value of this color
-     * @see #getWoolData()
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public byte getDyeData() {
-        return dyeData;
-    }
-
-    /**
-     * Gets the color that this dye represents.
-     *
-     * @return The {@link Color} that this dye represents
-     */
-    public Color getColor() {
-        return color;
-    }
-
-    /**
-     * Gets the firework color that this dye represents.
-     *
-     * @return The {@link Color} that this dye represents
-     */
-    public Color getFireworkColor() {
-        return firework;
-    }
-
-    /**
-     * Gets the DyeColor with the given (wool) data value.
-     *
-     * @param data (wool) data value to fetch
-     * @return The {@link DyeColor} representing the given value, or null if
-     *     it doesn't exist
-     * @deprecated The name is misleading. It would imply {@link
-     *     Material#INK_SACK} but uses {@link Material#WOOL}
-     * @see #getByDyeData(byte)
-     * @see #getByWoolData(byte)
-     */
-    @Deprecated
-    public static DyeColor getByData(final byte data) {
-        return getByWoolData(data);
-    }
-
-    /**
-     * Gets the DyeColor with the given wool data value.
-     *
-     * @param data Wool data value to fetch
-     * @return The {@link DyeColor} representing the given value, or null if
-     *     it doesn't exist
-     * @see #getByDyeData(byte)
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public static DyeColor getByWoolData(final byte data) {
-        int i = 0xff & data;
-        if (i >= BY_WOOL_DATA.length) {
-            return null;
-        }
-        return BY_WOOL_DATA[i];
-    }
-
-    /**
-     * Gets the DyeColor with the given dye data value.
-     *
-     * @param data Dye data value to fetch
-     * @return The {@link DyeColor} representing the given value, or null if
-     *     it doesn't exist
-     * @see #getByWoolData(byte)
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public static DyeColor getByDyeData(final byte data) {
-        int i = 0xff & data;
-        if (i >= BY_DYE_DATA.length) {
-            return null;
-        }
-        return BY_DYE_DATA[i];
-    }
-
-    /**
-     * Gets the DyeColor with the given color value.
-     *
-     * @param color Color value to get the dye by
-     * @return The {@link DyeColor} representing the given value, or null if
-     *     it doesn't exist
-     */
-    public static DyeColor getByColor(final Color color) {
-        return BY_COLOR.get(color);
-    }
-
-    /**
-     * Gets the DyeColor with the given firework color value.
-     *
-     * @param color Color value to get dye by
-     * @return The {@link DyeColor} representing the given value, or null if
-     *     it doesn't exist
-     */
-    public static DyeColor getByFireworkColor(final Color color) {
-        return BY_FIREWORK.get(color);
-    }
-
-    static {
-        BY_WOOL_DATA = values();
-        BY_DYE_DATA = values();
-        ImmutableMap.Builder<Color, DyeColor> byColor = ImmutableMap.builder();
-        ImmutableMap.Builder<Color, DyeColor> byFirework = ImmutableMap.builder();
-
-        for (DyeColor color : values()) {
-            BY_WOOL_DATA[color.woolData & 0xff] = color;
-            BY_DYE_DATA[color.dyeData & 0xff] = color;
-            byColor.put(color.getColor(), color);
-            byFirework.put(color.getFireworkColor(), color);
-        }
-
-        BY_COLOR = byColor.build();
-        BY_FIREWORK = byFirework.build();
-    }
-}
diff --git a/src/main/java/org/bukkit/Effect.java b/src/main/java/org/bukkit/Effect.java
deleted file mode 100644
index ba7dc49..0000000
--- a/src/main/java/org/bukkit/Effect.java
+++ /dev/null
@@ -1,264 +0,0 @@
-package org.bukkit;
-
-import java.util.Map;
-
-import com.google.common.collect.Maps;
-
-import org.bukkit.block.BlockFace;
-import org.bukkit.potion.Potion;
-
-/**
- * A list of effects that the server is able to send to players.
- */
-public enum Effect {
-    /**
-     * An alternate click sound.
-     */
-    CLICK2(1000, Type.SOUND),
-    /**
-     * A click sound.
-     */
-    CLICK1(1001, Type.SOUND),
-    /**
-     * Sound of a bow firing.
-     */
-    BOW_FIRE(1002, Type.SOUND),
-    /**
-     * Sound of a door opening.
-     */
-    DOOR_TOGGLE(1006, Type.SOUND),
-    /**
-     * Sound of a door opening.
-     */
-    IRON_DOOR_TOGGLE(1005, Type.SOUND),
-    /**
-     * Sound of a trapdoor opening.
-     */
-    TRAPDOOR_TOGGLE(1007, Type.SOUND),
-    /**
-     * Sound of a door opening.
-     */
-    IRON_TRAPDOOR_TOGGLE(1037, Type.SOUND),
-    /**
-     * Sound of a door opening.
-     */
-    FENCE_GATE_TOGGLE(1008, Type.SOUND),
-    /**
-     * Sound of a door closing.
-     */
-    DOOR_CLOSE(1012, Type.SOUND),
-    /**
-     * Sound of a door closing.
-     */
-    IRON_DOOR_CLOSE(1011, Type.SOUND),
-    /**
-     * Sound of a trapdoor closing.
-     */
-    TRAPDOOR_CLOSE(1013, Type.SOUND),
-    /**
-     * Sound of a door closing.
-     */
-    IRON_TRAPDOOR_CLOSE(1036, Type.SOUND),
-    /**
-     * Sound of a door closing.
-     */
-    FENCE_GATE_CLOSE(1014, Type.SOUND),
-    /**
-     * Sound of fire being extinguished.
-     */
-    EXTINGUISH(1009, Type.SOUND),
-    /**
-     * A song from a record. Needs the record item ID as additional info
-     */
-    RECORD_PLAY(1010, Type.SOUND, Material.class),
-    /**
-     * Sound of ghast shrieking.
-     */
-    GHAST_SHRIEK(1015, Type.SOUND),
-    /**
-     * Sound of ghast firing.
-     */
-    GHAST_SHOOT(1016, Type.SOUND),
-    /**
-     * Sound of blaze firing.
-     */
-    BLAZE_SHOOT(1018, Type.SOUND),
-    /**
-     * Sound of zombies chewing on wooden doors.
-     */
-    ZOMBIE_CHEW_WOODEN_DOOR(1019, Type.SOUND),
-    /**
-     * Sound of zombies chewing on iron doors.
-     */
-    ZOMBIE_CHEW_IRON_DOOR(1020, Type.SOUND),
-    /**
-     * Sound of zombies destroying a door.
-     */
-    ZOMBIE_DESTROY_DOOR(1021, Type.SOUND),
-    /**
-     * A visual smoke effect. Needs direction as additional info.
-     */
-    SMOKE(2000, Type.VISUAL, BlockFace.class),
-    /**
-     * Sound of a block breaking. Needs block ID as additional info.
-     */
-    STEP_SOUND(2001, Type.SOUND, Material.class),
-    /**
-     * Visual effect of a splash potion breaking. Needs potion data value as
-     * additional info.
-     */
-    POTION_BREAK(2002, Type.VISUAL, Potion.class),
-    /**
-     * An ender eye signal; a visual effect.
-     */
-    ENDER_SIGNAL(2003, Type.VISUAL),
-    /**
-     * The flames seen on a mobspawner; a visual effect.
-     */
-    MOBSPAWNER_FLAMES(2004, Type.VISUAL),
-    /**
-     * The sound played by brewing stands when brewing
-      */
-    BREWING_STAND_BREW(1035, Type.SOUND),
-    /**
-     * The sound played when a chorus flower grows
-     */
-    CHORUS_FLOWER_GROW(1033, Type.SOUND),
-    /**
-     * The sound played when a chorus flower dies
-     */
-    CHORUS_FLOWER_DEATH(1034, Type.SOUND),
-    /**
-     * The sound played when traveling through a portal
-     */
-    PORTAL_TRAVEL(1032, Type.SOUND),
-    /**
-     * The sound played when launching an endereye
-     */
-    ENDEREYE_LAUNCH(1003, Type.SOUND),
-    /**
-     * The sound played when launching a firework
-     */
-    FIREWORK_SHOOT(1004, Type.SOUND),
-    /**
-     * Particles displayed when a villager grows a plant, data
-     * is the number of particles
-     */
-    VILLAGER_PLANT_GROW(2005, Type.VISUAL, Integer.class),
-    /**
-     * The sound/particles used by the enderdragon's breath
-     * attack.
-     */
-    DRAGON_BREATH(2006, Type.VISUAL),
-    /**
-     * The sound played when an anvil breaks
-     */
-    ANVIL_BREAK(1029, Type.SOUND),
-    /**
-     * The sound played when an anvil is used
-     */
-    ANVIL_USE(1030, Type.SOUND),
-    /**
-     * The sound played when an anvil lands after
-     * falling
-     */
-    ANVIL_LAND(1031, Type.SOUND),
-    /**
-     * Sound of an enderdragon firing
-     */
-    ENDERDRAGON_SHOOT(1017, Type.SOUND),
-    /**
-     * The sound played when a wither breaks a block
-     */
-    WITHER_BREAK_BLOCK(1022, Type.SOUND),
-    /**
-     * Sound of a wither shooting
-     */
-    WITHER_SHOOT(1024, Type.SOUND),
-    /**
-     * The sound played when a zombie infects a target
-     */
-    ZOMBIE_INFECT(1026, Type.SOUND),
-    /**
-     * The sound played when a villager is converted by
-     * a zombie
-     */
-    ZOMBIE_CONVERTED_VILLAGER(1027, Type.SOUND),
-    /**
-     * Sound played by a bat taking off
-     */
-    BAT_TAKEOFF(1025, Type.SOUND),
-    /**
-     * The sound/particles caused by a end gateway spawning
-     */
-    END_GATEWAY_SPAWN(3000, Type.VISUAL),
-    /**
-     * The sound of an enderdragon growling
-     */
-    ENDERDRAGON_GROWL(3001, Type.SOUND),
-    ;
-
-    private final int id;
-    private final Type type;
-    private final Class<?> data;
-    private static final Map<Integer, Effect> BY_ID = Maps.newHashMap();
-
-    Effect(int id, Type type) {
-        this(id,type,null);
-    }
-
-    Effect(int id, Type type, Class<?> data) {
-        this.id = id;
-        this.type = type;
-        this.data = data;
-    }
-
-    /**
-     * Gets the ID for this effect.
-     *
-     * @return ID of this effect
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public int getId() {
-        return this.id;
-    }
-
-    /**
-     * @return The type of the effect.
-     */
-    public Type getType() {
-        return this.type;
-    }
-
-    /**
-     * @return The class which represents data for this effect, or null if
-     *     none
-     */
-    public Class<?> getData() {
-        return this.data;
-    }
-
-    /**
-     * Gets the Effect associated with the given ID.
-     *
-     * @param id ID of the Effect to return
-     * @return Effect with the given ID
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public static Effect getById(int id) {
-        return BY_ID.get(id);
-    }
-
-    static {
-        for (Effect effect : values()) {
-            BY_ID.put(effect.id, effect);
-        }
-    }
-
-    /**
-     * Represents the type of an effect.
-     */
-    public enum Type {SOUND, VISUAL}
-}
diff --git a/src/main/java/org/bukkit/EntityEffect.java b/src/main/java/org/bukkit/EntityEffect.java
deleted file mode 100644
index c816edf..0000000
--- a/src/main/java/org/bukkit/EntityEffect.java
+++ /dev/null
@@ -1,136 +0,0 @@
-package org.bukkit;
-
-import java.util.Map;
-
-import com.google.common.collect.Maps;
-
-/**
- * A list of all Effects that can happen to entities.
- */
-public enum EntityEffect {
-
-    /**
-     * When mobs get hurt.
-     */
-    HURT(2),
-
-    /**
-     * When a mob dies.
-     * <p>
-     * <b>This will cause client-glitches!</b>
-     */
-    DEATH(3),
-
-    /**
-     * The smoke when taming a wolf fails.
-     * <p>
-     * Without client-mods this will be ignored if the entity is not a wolf.
-     */
-    WOLF_SMOKE(6),
-
-    /**
-     * The hearts when taming a wolf succeeds.
-     * <p>
-     * Without client-mods this will be ignored if the entity is not a wolf.
-     */
-    WOLF_HEARTS(7),
-
-    /**
-     * When a wolf shakes (after being wet).
-     * <p>
-     * Without client-mods this will be ignored if the entity is not a wolf.
-     */
-    WOLF_SHAKE(8),
-
-    /**
-     * When a sheep eats a LONG_GRASS block.
-     */
-    SHEEP_EAT(10),
-
-    /**
-     * When an Iron Golem gives a rose.
-     * <p>
-     * This will not play an effect if the entity is not an iron golem.
-     */
-    IRON_GOLEM_ROSE(11),
-
-    /**
-     * Hearts from a villager.
-     * <p>
-     * This will not play an effect if the entity is not a villager.
-     */
-    VILLAGER_HEART(12),
-
-    /**
-     * When a villager is angry.
-     * <p>
-     * This will not play an effect if the entity is not a villager.
-     */
-    VILLAGER_ANGRY(13),
-
-    /**
-     * Happy particles from a villager.
-     * <p>
-     * This will not play an effect if the entity is not a villager.
-     */
-    VILLAGER_HAPPY(14),
-
-    /**
-     * Magic particles from a witch.
-     * <p>
-     * This will not play an effect if the entity is not a witch.
-     */
-    WITCH_MAGIC(15),
-
-    /**
-     * When a zombie transforms into a villager by shaking violently.
-     * <p>
-     * This will not play an effect if the entity is not a zombie.
-     */
-    ZOMBIE_TRANSFORM(16),
-
-    /**
-     * When a firework explodes.
-     * <p>
-     * This will not play an effect if the entity is not a firework.
-     */
-    FIREWORK_EXPLODE(17);
-
-    private final byte data;
-    private final static Map<Byte, EntityEffect> BY_DATA = Maps.newHashMap();
-
-    EntityEffect(final int data) {
-        this.data = (byte) data;
-    }
-
-    /**
-     * Gets the data value of this EntityEffect
-     *
-     * @return The data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public byte getData() {
-        return data;
-    }
-
-    /**
-     * Gets the EntityEffect with the given data value
-     *
-     * @param data Data value to fetch
-     * @return The {@link EntityEffect} representing the given value, or null
-     *     if it doesn't exist
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public static EntityEffect getByData(final byte data) {
-        return BY_DATA.get(data);
-    }
-
-
-    static {
-        for (EntityEffect entityEffect : values()) {
-            BY_DATA.put(entityEffect.data, entityEffect);
-        }
-    }
-}
diff --git a/src/main/java/org/bukkit/FireworkEffect.java b/src/main/java/org/bukkit/FireworkEffect.java
deleted file mode 100644
index 4b0687f..0000000
--- a/src/main/java/org/bukkit/FireworkEffect.java
+++ /dev/null
@@ -1,424 +0,0 @@
-package org.bukkit;
-
-import java.util.List;
-import java.util.Map;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.configuration.serialization.ConfigurationSerializable;
-import org.bukkit.configuration.serialization.SerializableAs;
-
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap;
-
-/**
- * Represents a single firework effect.
- */
-@SerializableAs("Firework")
-public final class FireworkEffect implements ConfigurationSerializable {
-
-    /**
-     * The type or shape of the effect.
-     */
-    public enum Type {
-        /**
-         * A small ball effect.
-         */
-        BALL,
-        /**
-         * A large ball effect.
-         */
-        BALL_LARGE,
-        /**
-         * A star-shaped effect.
-         */
-        STAR,
-        /**
-         * A burst effect.
-         */
-        BURST,
-        /**
-         * A creeper-face effect.
-         */
-        CREEPER,
-        ;
-    }
-
-    /**
-     * Construct a firework effect.
-     *
-     * @return A utility object for building a firework effect
-     */
-    public static Builder builder() {
-        return new Builder();
-    }
-
-    /**
-     * This is a builder for FireworkEffects.
-     *
-     * @see FireworkEffect#builder()
-     */
-    public static final class Builder {
-        boolean flicker = false;
-        boolean trail = false;
-        final ImmutableList.Builder<Color> colors = ImmutableList.builder();
-        ImmutableList.Builder<Color> fadeColors = null;
-        Type type = Type.BALL;
-
-        Builder() {}
-
-        /**
-         * Specify the type of the firework effect.
-         *
-         * @param type The effect type
-         * @return This object, for chaining
-         * @throws IllegalArgumentException If type is null
-         */
-        public Builder with(Type type) throws IllegalArgumentException {
-            Validate.notNull(type, "Cannot have null type");
-            this.type = type;
-            return this;
-        }
-
-        /**
-         * Add a flicker to the firework effect.
-         *
-         * @return This object, for chaining
-         */
-        public Builder withFlicker() {
-            flicker = true;
-            return this;
-        }
-
-        /**
-         * Set whether the firework effect should flicker.
-         *
-         * @param flicker true if it should flicker, false if not
-         * @return This object, for chaining
-         */
-        public Builder flicker(boolean flicker) {
-            this.flicker = flicker;
-            return this;
-        }
-
-        /**
-         * Add a trail to the firework effect.
-         *
-         * @return This object, for chaining
-         */
-        public Builder withTrail() {
-            trail = true;
-            return this;
-        }
-
-        /**
-         * Set whether the firework effect should have a trail.
-         *
-         * @param trail true if it should have a trail, false for no trail
-         * @return This object, for chaining
-         */
-        public Builder trail(boolean trail) {
-            this.trail = trail;
-            return this;
-        }
-
-        /**
-         * Add a primary color to the firework effect.
-         *
-         * @param color The color to add
-         * @return This object, for chaining
-         * @throws IllegalArgumentException If color is null
-         */
-        public Builder withColor(Color color) throws IllegalArgumentException {
-            Validate.notNull(color, "Cannot have null color");
-
-            colors.add(color);
-
-            return this;
-        }
-
-        /**
-         * Add several primary colors to the firework effect.
-         *
-         * @param colors The colors to add
-         * @return This object, for chaining
-         * @throws IllegalArgumentException If colors is null
-         * @throws IllegalArgumentException If any color is null (may be
-         *     thrown after changes have occurred)
-         */
-        public Builder withColor(Color...colors) throws IllegalArgumentException {
-            Validate.notNull(colors, "Cannot have null colors");
-            if (colors.length == 0) {
-                return this;
-            }
-
-            ImmutableList.Builder<Color> list = this.colors;
-            for (Color color : colors) {
-                Validate.notNull(color, "Color cannot be null");
-                list.add(color);
-            }
-
-            return this;
-        }
-
-        /**
-         * Add several primary colors to the firework effect.
-         *
-         * @param colors An iterable object whose iterator yields the desired
-         *     colors
-         * @return This object, for chaining
-         * @throws IllegalArgumentException If colors is null
-         * @throws IllegalArgumentException If any color is null (may be
-         *     thrown after changes have occurred)
-         */
-        public Builder withColor(Iterable<?> colors) throws IllegalArgumentException {
-            Validate.notNull(colors, "Cannot have null colors");
-
-            ImmutableList.Builder<Color> list = this.colors;
-            for (Object color : colors) {
-                if (!(color instanceof Color)) {
-                    throw new IllegalArgumentException(color + " is not a Color in " + colors);
-                }
-                list.add((Color) color);
-            }
-
-            return this;
-        }
-
-        /**
-         * Add a fade color to the firework effect.
-         *
-         * @param color The color to add
-         * @return This object, for chaining
-         * @throws IllegalArgumentException If colors is null
-         * @throws IllegalArgumentException If any color is null (may be
-         *     thrown after changes have occurred)
-         */
-        public Builder withFade(Color color) throws IllegalArgumentException {
-            Validate.notNull(color, "Cannot have null color");
-
-            if (fadeColors == null) {
-                fadeColors = ImmutableList.builder();
-            }
-
-            fadeColors.add(color);
-
-            return this;
-        }
-
-        /**
-         * Add several fade colors to the firework effect.
-         *
-         * @param colors The colors to add
-         * @return This object, for chaining
-         * @throws IllegalArgumentException If colors is null
-         * @throws IllegalArgumentException If any color is null (may be
-         *     thrown after changes have occurred)
-         */
-        public Builder withFade(Color...colors) throws IllegalArgumentException {
-            Validate.notNull(colors, "Cannot have null colors");
-            if (colors.length == 0) {
-                return this;
-            }
-
-            ImmutableList.Builder<Color> list = this.fadeColors;
-            if (list == null) {
-                list = this.fadeColors = ImmutableList.builder();
-            }
-
-            for (Color color : colors) {
-                Validate.notNull(color, "Color cannot be null");
-                list.add(color);
-            }
-
-            return this;
-        }
-
-        /**
-         * Add several fade colors to the firework effect.
-         *
-         * @param colors An iterable object whose iterator yields the desired
-         *     colors
-         * @return This object, for chaining
-         * @throws IllegalArgumentException If colors is null
-         * @throws IllegalArgumentException If any color is null (may be
-         *     thrown after changes have occurred)
-         */
-        public Builder withFade(Iterable<?> colors) throws IllegalArgumentException {
-            Validate.notNull(colors, "Cannot have null colors");
-
-            ImmutableList.Builder<Color> list = this.fadeColors;
-            if (list == null) {
-                list = this.fadeColors = ImmutableList.builder();
-            }
-
-            for (Object color : colors) {
-                if (!(color instanceof Color)) {
-                    throw new IllegalArgumentException(color + " is not a Color in " + colors);
-                }
-                list.add((Color) color);
-            }
-
-            return this;
-        }
-
-        /**
-         * Create a {@link FireworkEffect} from the current contents of this
-         * builder.
-         * <p>
-         * To successfully build, you must have specified at least one color.
-         *
-         * @return The representative firework effect
-         */
-        public FireworkEffect build() {
-            return new FireworkEffect(
-                flicker,
-                trail,
-                colors.build(),
-                fadeColors == null ? ImmutableList.<Color>of() : fadeColors.build(),
-                type
-            );
-        }
-    }
-
-    private static final String FLICKER = "flicker";
-    private static final String TRAIL = "trail";
-    private static final String COLORS = "colors";
-    private static final String FADE_COLORS = "fade-colors";
-    private static final String TYPE = "type";
-
-    private final boolean flicker;
-    private final boolean trail;
-    private final ImmutableList<Color> colors;
-    private final ImmutableList<Color> fadeColors;
-    private final Type type;
-    private String string = null;
-
-    FireworkEffect(boolean flicker, boolean trail, ImmutableList<Color> colors, ImmutableList<Color> fadeColors, Type type) {
-        if (colors.isEmpty()) {
-            throw new IllegalStateException("Cannot make FireworkEffect without any color");
-        }
-        this.flicker = flicker;
-        this.trail = trail;
-        this.colors = colors;
-        this.fadeColors = fadeColors;
-        this.type = type;
-    }
-
-    /**
-     * Get whether the firework effect flickers.
-     *
-     * @return true if it flickers, false if not
-     */
-    public boolean hasFlicker() {
-        return flicker;
-    }
-
-    /**
-     * Get whether the firework effect has a trail.
-     *
-     * @return true if it has a trail, false if not
-     */
-    public boolean hasTrail() {
-        return trail;
-    }
-
-    /**
-     * Get the primary colors of the firework effect.
-     *
-     * @return An immutable list of the primary colors
-     */
-    public List<Color> getColors() {
-        return colors;
-    }
-
-    /**
-     * Get the fade colors of the firework effect.
-     *
-     * @return An immutable list of the fade colors
-     */
-    public List<Color> getFadeColors() {
-        return fadeColors;
-    }
-
-    /**
-     * Get the type of the firework effect.
-     *
-     * @return The effect type
-     */
-    public Type getType() {
-        return type;
-    }
-
-    /**
-     * @see ConfigurationSerializable
-     * @param map the map to deserialize
-     * @return the resulting serializable
-     */
-    public static ConfigurationSerializable deserialize(Map<String, Object> map) {
-        Type type = Type.valueOf((String) map.get(TYPE));
-        if (type == null) {
-            throw new IllegalArgumentException(map.get(TYPE) + " is not a valid Type");
-        }
-
-        return builder()
-            .flicker((Boolean) map.get(FLICKER))
-            .trail((Boolean) map.get(TRAIL))
-            .withColor((Iterable<?>) map.get(COLORS))
-            .withFade((Iterable<?>) map.get(FADE_COLORS))
-            .with(type)
-            .build();
-    }
-
-    @Override
-    public Map<String, Object> serialize() {
-        return ImmutableMap.<String, Object>of(
-            FLICKER, flicker,
-            TRAIL, trail,
-            COLORS, colors,
-            FADE_COLORS, fadeColors,
-            TYPE, type.name()
-        );
-    }
-
-    @Override
-    public String toString() {
-        final String string = this.string;
-        if (string == null) {
-            return this.string = "FireworkEffect:" + serialize();
-        }
-        return string;
-    }
-
-    @Override
-    public int hashCode() {
-        /**
-         * TRUE and FALSE as per boolean.hashCode()
-         */
-        final int PRIME = 31, TRUE = 1231, FALSE = 1237;
-        int hash = 1;
-        hash = hash * PRIME + (flicker ? TRUE : FALSE);
-        hash = hash * PRIME + (trail ? TRUE : FALSE);
-        hash = hash * PRIME + type.hashCode();
-        hash = hash * PRIME + colors.hashCode();
-        hash = hash * PRIME + fadeColors.hashCode();
-        return hash;
-    }
-
-    @Override
-    public boolean equals(Object obj) {
-        if (this == obj) {
-            return true;
-        }
-
-        if (!(obj instanceof FireworkEffect)) {
-            return false;
-        }
-
-        FireworkEffect that = (FireworkEffect) obj;
-        return this.flicker == that.flicker
-                && this.trail == that.trail
-                && this.type == that.type
-                && this.colors.equals(that.colors)
-                && this.fadeColors.equals(that.fadeColors);
-    }
-}
diff --git a/src/main/java/org/bukkit/GameMode.java b/src/main/java/org/bukkit/GameMode.java
deleted file mode 100644
index 803944e..0000000
--- a/src/main/java/org/bukkit/GameMode.java
+++ /dev/null
@@ -1,73 +0,0 @@
-package org.bukkit;
-
-import java.util.Map;
-
-import org.bukkit.entity.HumanEntity;
-
-import com.google.common.collect.Maps;
-
-/**
- * Represents the various type of game modes that {@link HumanEntity}s may
- * have
- */
-public enum GameMode {
-    /**
-     * Creative mode may fly, build instantly, become invulnerable and create
-     * free items.
-     */
-    CREATIVE(1),
-
-    /**
-     * Survival mode is the "normal" gameplay type, with no special features.
-     */
-    SURVIVAL(0),
-
-    /**
-     * Adventure mode cannot break blocks without the correct tools.
-     */
-    ADVENTURE(2),
-
-    /**
-     * Spectator mode cannot interact with the world in anyway and is 
-     * invisible to normal players. This grants the player the 
-     * ability to no-clip through the world.
-     */
-    SPECTATOR(3);
-
-    private final int value;
-    private final static Map<Integer, GameMode> BY_ID = Maps.newHashMap();
-
-    private GameMode(final int value) {
-        this.value = value;
-    }
-
-    /**
-     * Gets the mode value associated with this GameMode
-     *
-     * @return An integer value of this gamemode
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public int getValue() {
-        return value;
-    }
-
-    /**
-     * Gets the GameMode represented by the specified value
-     *
-     * @param value Value to check
-     * @return Associative {@link GameMode} with the given value, or null if
-     *     it doesn't exist
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public static GameMode getByValue(final int value) {
-        return BY_ID.get(value);
-    }
-
-    static {
-        for (GameMode mode : values()) {
-            BY_ID.put(mode.getValue(), mode);
-        }
-    }
-}
diff --git a/src/main/java/org/bukkit/GrassSpecies.java b/src/main/java/org/bukkit/GrassSpecies.java
deleted file mode 100644
index 1111515..0000000
--- a/src/main/java/org/bukkit/GrassSpecies.java
+++ /dev/null
@@ -1,61 +0,0 @@
-package org.bukkit;
-
-import java.util.Map;
-
-import com.google.common.collect.Maps;
-
-/**
- * Represents the different types of grass.
- */
-public enum GrassSpecies {
-
-    /**
-     * Represents the dead looking grass.
-     */
-    DEAD(0x0),
-    /**
-     * Represents the normal grass species.
-     */
-    NORMAL(0x1),
-    /**
-     * Represents the fern-looking grass species.
-     */
-    FERN_LIKE(0x2);
-
-    private final byte data;
-    private final static Map<Byte, GrassSpecies> BY_DATA = Maps.newHashMap();
-
-    private GrassSpecies(final int data) {
-        this.data = (byte) data;
-    }
-
-    /**
-     * Gets the associated data value representing this species
-     *
-     * @return A byte containing the data value of this grass species
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public byte getData() {
-        return data;
-    }
-
-    /**
-     * Gets the GrassSpecies with the given data value
-     *
-     * @param data Data value to fetch
-     * @return The {@link GrassSpecies} representing the given value, or null
-     *     if it doesn't exist
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public static GrassSpecies getByData(final byte data) {
-        return BY_DATA.get(data);
-    }
-
-    static {
-        for (GrassSpecies grassSpecies : values()) {
-            BY_DATA.put(grassSpecies.getData(), grassSpecies);
-        }
-    }
-}
diff --git a/src/main/java/org/bukkit/Instrument.java b/src/main/java/org/bukkit/Instrument.java
deleted file mode 100644
index 891a2b1..0000000
--- a/src/main/java/org/bukkit/Instrument.java
+++ /dev/null
@@ -1,67 +0,0 @@
-package org.bukkit;
-
-import java.util.Map;
-
-import com.google.common.collect.Maps;
-
-public enum Instrument {
-
-    /**
-     * Piano is the standard instrument for a note block.
-     */
-    PIANO(0x0),
-    /**
-     * Bass drum is normally played when a note block is on top of a
-     * stone-like block
-     */
-    BASS_DRUM(0x1),
-    /**
-     * Snare drum is normally played when a note block is on top of a sandy
-     * block.
-     */
-    SNARE_DRUM(0x2),
-    /**
-     * Sticks are normally played when a note block is on top of a glass
-     * block.
-     */
-    STICKS(0x3),
-    /**
-     * Bass guitar is normally played when a note block is on top of a wooden
-     * block.
-     */
-    BASS_GUITAR(0x4);
-
-    private final byte type;
-    private final static Map<Byte, Instrument> BY_DATA = Maps.newHashMap();
-
-    private Instrument(final int type) {
-        this.type = (byte) type;
-    }
-
-    /**
-     * @return The type ID of this instrument.
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public byte getType() {
-        return this.type;
-    }
-
-    /**
-     * Get an instrument by its type ID.
-     *
-     * @param type The type ID
-     * @return The instrument
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public static Instrument getByType(final byte type) {
-        return BY_DATA.get(type);
-    }
-
-    static {
-        for (Instrument instrument : Instrument.values()) {
-            BY_DATA.put(instrument.getType(), instrument);
-        }
-    }
-}
diff --git a/src/main/java/org/bukkit/Location.java b/src/main/java/org/bukkit/Location.java
deleted file mode 100644
index e7af316..0000000
--- a/src/main/java/org/bukkit/Location.java
+++ /dev/null
@@ -1,600 +0,0 @@
-package org.bukkit;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import org.bukkit.block.Block;
-import org.bukkit.configuration.serialization.ConfigurationSerializable;
-import org.bukkit.util.NumberConversions;
-import static org.bukkit.util.NumberConversions.checkFinite;
-import org.bukkit.util.Vector;
-
-/**
- * Represents a 3-dimensional position in a world
- */
-public class Location implements Cloneable, ConfigurationSerializable {
-    private World world;
-    private double x;
-    private double y;
-    private double z;
-    private float pitch;
-    private float yaw;
-
-    /**
-     * Constructs a new Location with the given coordinates
-     *
-     * @param world The world in which this location resides
-     * @param x The x-coordinate of this new location
-     * @param y The y-coordinate of this new location
-     * @param z The z-coordinate of this new location
-     */
-    public Location(final World world, final double x, final double y, final double z) {
-        this(world, x, y, z, 0, 0);
-    }
-
-    /**
-     * Constructs a new Location with the given coordinates and direction
-     *
-     * @param world The world in which this location resides
-     * @param x The x-coordinate of this new location
-     * @param y The y-coordinate of this new location
-     * @param z The z-coordinate of this new location
-     * @param yaw The absolute rotation on the x-plane, in degrees
-     * @param pitch The absolute rotation on the y-plane, in degrees
-     */
-    public Location(final World world, final double x, final double y, final double z, final float yaw, final float pitch) {
-        this.world = world;
-        this.x = x;
-        this.y = y;
-        this.z = z;
-        this.pitch = pitch;
-        this.yaw = yaw;
-    }
-
-    /**
-     * Sets the world that this location resides in
-     *
-     * @param world New world that this location resides in
-     */
-    public void setWorld(World world) {
-        this.world = world;
-    }
-
-    /**
-     * Gets the world that this location resides in
-     *
-     * @return World that contains this location
-     */
-    public World getWorld() {
-        return world;
-    }
-
-    /**
-     * Gets the chunk at the represented location
-     *
-     * @return Chunk at the represented location
-     */
-    public Chunk getChunk() {
-        return world.getChunkAt(this);
-    }
-
-    /**
-     * Gets the block at the represented location
-     *
-     * @return Block at the represented location
-     */
-    public Block getBlock() {
-        return world.getBlockAt(this);
-    }
-
-    /**
-     * Sets the x-coordinate of this location
-     *
-     * @param x X-coordinate
-     */
-    public void setX(double x) {
-        this.x = x;
-    }
-
-    /**
-     * Gets the x-coordinate of this location
-     *
-     * @return x-coordinate
-     */
-    public double getX() {
-        return x;
-    }
-
-    /**
-     * Gets the floored value of the X component, indicating the block that
-     * this location is contained with.
-     *
-     * @return block X
-     */
-    public int getBlockX() {
-        return locToBlock(x);
-    }
-
-    /**
-     * Sets the y-coordinate of this location
-     *
-     * @param y y-coordinate
-     */
-    public void setY(double y) {
-        this.y = y;
-    }
-
-    /**
-     * Gets the y-coordinate of this location
-     *
-     * @return y-coordinate
-     */
-    public double getY() {
-        return y;
-    }
-
-    /**
-     * Gets the floored value of the Y component, indicating the block that
-     * this location is contained with.
-     *
-     * @return block y
-     */
-    public int getBlockY() {
-        return locToBlock(y);
-    }
-
-    /**
-     * Sets the z-coordinate of this location
-     *
-     * @param z z-coordinate
-     */
-    public void setZ(double z) {
-        this.z = z;
-    }
-
-    /**
-     * Gets the z-coordinate of this location
-     *
-     * @return z-coordinate
-     */
-    public double getZ() {
-        return z;
-    }
-
-    /**
-     * Gets the floored value of the Z component, indicating the block that
-     * this location is contained with.
-     *
-     * @return block z
-     */
-    public int getBlockZ() {
-        return locToBlock(z);
-    }
-
-    /**
-     * Sets the yaw of this location, measured in degrees.
-     * <ul>
-     * <li>A yaw of 0 or 360 represents the positive z direction.
-     * <li>A yaw of 180 represents the negative z direction.
-     * <li>A yaw of 90 represents the negative x direction.
-     * <li>A yaw of 270 represents the positive x direction.
-     * </ul>
-     * Increasing yaw values are the equivalent of turning to your
-     * right-facing, increasing the scale of the next respective axis, and
-     * decreasing the scale of the previous axis.
-     *
-     * @param yaw new rotation's yaw
-     */
-    public void setYaw(float yaw) {
-        this.yaw = yaw;
-    }
-
-    /**
-     * Gets the yaw of this location, measured in degrees.
-     * <ul>
-     * <li>A yaw of 0 or 360 represents the positive z direction.
-     * <li>A yaw of 180 represents the negative z direction.
-     * <li>A yaw of 90 represents the negative x direction.
-     * <li>A yaw of 270 represents the positive x direction.
-     * </ul>
-     * Increasing yaw values are the equivalent of turning to your
-     * right-facing, increasing the scale of the next respective axis, and
-     * decreasing the scale of the previous axis.
-     *
-     * @return the rotation's yaw
-     */
-    public float getYaw() {
-        return yaw;
-    }
-
-    /**
-     * Sets the pitch of this location, measured in degrees.
-     * <ul>
-     * <li>A pitch of 0 represents level forward facing.
-     * <li>A pitch of 90 represents downward facing, or negative y
-     *     direction.
-     * <li>A pitch of -90 represents upward facing, or positive y direction.
-     * </ul>
-     * Increasing pitch values the equivalent of looking down.
-     *
-     * @param pitch new incline's pitch
-     */
-    public void setPitch(float pitch) {
-        this.pitch = pitch;
-    }
-
-    /**
-     * Gets the pitch of this location, measured in degrees.
-     * <ul>
-     * <li>A pitch of 0 represents level forward facing.
-     * <li>A pitch of 90 represents downward facing, or negative y
-     *     direction.
-     * <li>A pitch of -90 represents upward facing, or positive y direction.
-     * </ul>
-     * Increasing pitch values the equivalent of looking down.
-     *
-     * @return the incline's pitch
-     */
-    public float getPitch() {
-        return pitch;
-    }
-
-    /**
-     * Gets a unit-vector pointing in the direction that this Location is
-     * facing.
-     *
-     * @return a vector pointing the direction of this location's {@link
-     *     #getPitch() pitch} and {@link #getYaw() yaw}
-     */
-    public Vector getDirection() {
-        Vector vector = new Vector();
-
-        double rotX = this.getYaw();
-        double rotY = this.getPitch();
-
-        vector.setY(-Math.sin(Math.toRadians(rotY)));
-
-        double xz = Math.cos(Math.toRadians(rotY));
-
-        vector.setX(-xz * Math.sin(Math.toRadians(rotX)));
-        vector.setZ(xz * Math.cos(Math.toRadians(rotX)));
-
-        return vector;
-    }
-
-    /**
-     * Sets the {@link #getYaw() yaw} and {@link #getPitch() pitch} to point
-     * in the direction of the vector.
-     * 
-     * @param vector the direction vector
-     * @return the same location
-     */
-    public Location setDirection(Vector vector) {
-        /*
-         * Sin = Opp / Hyp
-         * Cos = Adj / Hyp
-         * Tan = Opp / Adj
-         *
-         * x = -Opp
-         * z = Adj
-         */
-        final double _2PI = 2 * Math.PI;
-        final double x = vector.getX();
-        final double z = vector.getZ();
-
-        if (x == 0 && z == 0) {
-            pitch = vector.getY() > 0 ? -90 : 90;
-            return this;
-        }
-
-        double theta = Math.atan2(-x, z);
-        yaw = (float) Math.toDegrees((theta + _2PI) % _2PI);
-
-        double x2 = NumberConversions.square(x);
-        double z2 = NumberConversions.square(z);
-        double xz = Math.sqrt(x2 + z2);
-        pitch = (float) Math.toDegrees(Math.atan(-vector.getY() / xz));
-
-        return this;
-    }
-
-    /**
-     * Adds the location by another.
-     *
-     * @see Vector
-     * @param vec The other location
-     * @return the same location
-     * @throws IllegalArgumentException for differing worlds
-     */
-    public Location add(Location vec) {
-        if (vec == null || vec.getWorld() != getWorld()) {
-            throw new IllegalArgumentException("Cannot add Locations of differing worlds");
-        }
-
-        x += vec.x;
-        y += vec.y;
-        z += vec.z;
-        return this;
-    }
-
-    /**
-     * Adds the location by a vector.
-     *
-     * @see Vector
-     * @param vec Vector to use
-     * @return the same location
-     */
-    public Location add(Vector vec) {
-        this.x += vec.getX();
-        this.y += vec.getY();
-        this.z += vec.getZ();
-        return this;
-    }
-
-    /**
-     * Adds the location by another. Not world-aware.
-     *
-     * @see Vector
-     * @param x X coordinate
-     * @param y Y coordinate
-     * @param z Z coordinate
-     * @return the same location
-     */
-    public Location add(double x, double y, double z) {
-        this.x += x;
-        this.y += y;
-        this.z += z;
-        return this;
-    }
-
-    /**
-     * Subtracts the location by another.
-     *
-     * @see Vector
-     * @param vec The other location
-     * @return the same location
-     * @throws IllegalArgumentException for differing worlds
-     */
-    public Location subtract(Location vec) {
-        if (vec == null || vec.getWorld() != getWorld()) {
-            throw new IllegalArgumentException("Cannot add Locations of differing worlds");
-        }
-
-        x -= vec.x;
-        y -= vec.y;
-        z -= vec.z;
-        return this;
-    }
-
-    /**
-     * Subtracts the location by a vector.
-     *
-     * @see Vector
-     * @param vec The vector to use
-     * @return the same location
-     */
-    public Location subtract(Vector vec) {
-        this.x -= vec.getX();
-        this.y -= vec.getY();
-        this.z -= vec.getZ();
-        return this;
-    }
-
-    /**
-     * Subtracts the location by another. Not world-aware and
-     * orientation independent.
-     *
-     * @see Vector
-     * @param x X coordinate
-     * @param y Y coordinate
-     * @param z Z coordinate
-     * @return the same location
-     */
-    public Location subtract(double x, double y, double z) {
-        this.x -= x;
-        this.y -= y;
-        this.z -= z;
-        return this;
-    }
-
-    /**
-     * Gets the magnitude of the location, defined as sqrt(x^2+y^2+z^2). The
-     * value of this method is not cached and uses a costly square-root
-     * function, so do not repeatedly call this method to get the location's
-     * magnitude. NaN will be returned if the inner result of the sqrt()
-     * function overflows, which will be caused if the length is too long. Not
-     * world-aware and orientation independent.
-     *
-     * @see Vector
-     * @return the magnitude
-     */
-    public double length() {
-        return Math.sqrt(NumberConversions.square(x) + NumberConversions.square(y) + NumberConversions.square(z));
-    }
-
-    /**
-     * Gets the magnitude of the location squared. Not world-aware and
-     * orientation independent.
-     *
-     * @see Vector
-     * @return the magnitude
-     */
-    public double lengthSquared() {
-        return NumberConversions.square(x) + NumberConversions.square(y) + NumberConversions.square(z);
-    }
-
-    /**
-     * Get the distance between this location and another. The value of this
-     * method is not cached and uses a costly square-root function, so do not
-     * repeatedly call this method to get the location's magnitude. NaN will
-     * be returned if the inner result of the sqrt() function overflows, which
-     * will be caused if the distance is too long.
-     *
-     * @see Vector
-     * @param o The other location
-     * @return the distance
-     * @throws IllegalArgumentException for differing worlds
-     */
-    public double distance(Location o) {
-        return Math.sqrt(distanceSquared(o));
-    }
-
-    /**
-     * Get the squared distance between this location and another.
-     *
-     * @see Vector
-     * @param o The other location
-     * @return the distance
-     * @throws IllegalArgumentException for differing worlds
-     */
-    public double distanceSquared(Location o) {
-        if (o == null) {
-            throw new IllegalArgumentException("Cannot measure distance to a null location");
-        } else if (o.getWorld() == null || getWorld() == null) {
-            throw new IllegalArgumentException("Cannot measure distance to a null world");
-        } else if (o.getWorld() != getWorld()) {
-            throw new IllegalArgumentException("Cannot measure distance between " + getWorld().getName() + " and " + o.getWorld().getName());
-        }
-
-        return NumberConversions.square(x - o.x) + NumberConversions.square(y - o.y) + NumberConversions.square(z - o.z);
-    }
-
-    /**
-     * Performs scalar multiplication, multiplying all components with a
-     * scalar. Not world-aware.
-     *
-     * @param m The factor
-     * @see Vector
-     * @return the same location
-     */
-    public Location multiply(double m) {
-        x *= m;
-        y *= m;
-        z *= m;
-        return this;
-    }
-
-    /**
-     * Zero this location's components. Not world-aware.
-     *
-     * @see Vector
-     * @return the same location
-     */
-    public Location zero() {
-        x = 0;
-        y = 0;
-        z = 0;
-        return this;
-    }
-
-    @Override
-    public boolean equals(Object obj) {
-        if (obj == null) {
-            return false;
-        }
-        if (getClass() != obj.getClass()) {
-            return false;
-        }
-        final Location other = (Location) obj;
-
-        if (this.world != other.world && (this.world == null || !this.world.equals(other.world))) {
-            return false;
-        }
-        if (Double.doubleToLongBits(this.x) != Double.doubleToLongBits(other.x)) {
-            return false;
-        }
-        if (Double.doubleToLongBits(this.y) != Double.doubleToLongBits(other.y)) {
-            return false;
-        }
-        if (Double.doubleToLongBits(this.z) != Double.doubleToLongBits(other.z)) {
-            return false;
-        }
-        if (Float.floatToIntBits(this.pitch) != Float.floatToIntBits(other.pitch)) {
-            return false;
-        }
-        if (Float.floatToIntBits(this.yaw) != Float.floatToIntBits(other.yaw)) {
-            return false;
-        }
-        return true;
-    }
-
-    @Override
-    public int hashCode() {
-        int hash = 3;
-
-        hash = 19 * hash + (this.world != null ? this.world.hashCode() : 0);
-        hash = 19 * hash + (int) (Double.doubleToLongBits(this.x) ^ (Double.doubleToLongBits(this.x) >>> 32));
-        hash = 19 * hash + (int) (Double.doubleToLongBits(this.y) ^ (Double.doubleToLongBits(this.y) >>> 32));
-        hash = 19 * hash + (int) (Double.doubleToLongBits(this.z) ^ (Double.doubleToLongBits(this.z) >>> 32));
-        hash = 19 * hash + Float.floatToIntBits(this.pitch);
-        hash = 19 * hash + Float.floatToIntBits(this.yaw);
-        return hash;
-    }
-
-    @Override
-    public String toString() {
-        return "Location{" + "world=" + world + ",x=" + x + ",y=" + y + ",z=" + z + ",pitch=" + pitch + ",yaw=" + yaw + '}';
-    }
-
-    /**
-     * Constructs a new {@link Vector} based on this Location
-     *
-     * @return New Vector containing the coordinates represented by this
-     *     Location
-     */
-    public Vector toVector() {
-        return new Vector(x, y, z);
-    }
-
-    @Override
-    public Location clone() {
-        try {
-            return (Location) super.clone();
-        } catch (CloneNotSupportedException e) {
-            throw new Error(e);
-        }
-    }
-
-    /**
-     * Safely converts a double (location coordinate) to an int (block
-     * coordinate)
-     *
-     * @param loc Precise coordinate
-     * @return Block coordinate
-     */
-    public static int locToBlock(double loc) {
-        return NumberConversions.floor(loc);
-    }
-
-	@Utility
-	public Map<String, Object> serialize() {
-		Map<String, Object> data = new HashMap<String, Object>();
-		data.put("world", this.world.getName());
-
-		data.put("x", this.x);
-		data.put("y", this.y);
-		data.put("z", this.z);
-
-		data.put("yaw", this.yaw);
-		data.put("pitch", this.pitch);
-
-		return data;
-	}
-	
-	 /**
-     * Required method for deserialization
-     *
-     * @param args map to deserialize
-     * @return deserialized location
-     * @throws IllegalArgumentException if the world don't exists
-     * @see ConfigurationSerializable
-     */
-	public static Location deserialize(Map<String, Object> args) {
-		World world = Bukkit.getWorld((String) args.get("world"));
-		if (world == null) {
-			throw new IllegalArgumentException("unknown world");
-		}
-
-		return new Location(world, NumberConversions.toDouble(args.get("x")), NumberConversions.toDouble(args.get("y")), NumberConversions.toDouble(args.get("z")), NumberConversions.toFloat(args.get("yaw")), NumberConversions.toFloat(args.get("pitch")));
-	}
-}
diff --git a/src/main/java/org/bukkit/Material.java b/src/main/java/org/bukkit/Material.java
deleted file mode 100644
index ac0cc7e..0000000
--- a/src/main/java/org/bukkit/Material.java
+++ /dev/null
@@ -1,1207 +0,0 @@
-package org.bukkit;
-
-import java.lang.reflect.Constructor;
-import java.util.Map;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.map.MapView;
-import org.bukkit.material.Bed;
-import org.bukkit.material.Button;
-import org.bukkit.material.Cake;
-import org.bukkit.material.Cauldron;
-import org.bukkit.material.Chest;
-import org.bukkit.material.Coal;
-import org.bukkit.material.CocoaPlant;
-import org.bukkit.material.Command;
-import org.bukkit.material.Comparator;
-import org.bukkit.material.Crops;
-import org.bukkit.material.DetectorRail;
-import org.bukkit.material.Diode;
-import org.bukkit.material.Dispenser;
-import org.bukkit.material.Door;
-import org.bukkit.material.Dye;
-import org.bukkit.material.EnderChest;
-import org.bukkit.material.FlowerPot;
-import org.bukkit.material.Furnace;
-import org.bukkit.material.Gate;
-import org.bukkit.material.Hopper;
-import org.bukkit.material.Ladder;
-import org.bukkit.material.Leaves;
-import org.bukkit.material.Lever;
-import org.bukkit.material.LongGrass;
-import org.bukkit.material.MaterialData;
-import org.bukkit.material.MonsterEggs;
-import org.bukkit.material.Mushroom;
-import org.bukkit.material.NetherWarts;
-import org.bukkit.material.PistonBaseMaterial;
-import org.bukkit.material.PistonExtensionMaterial;
-import org.bukkit.material.PoweredRail;
-import org.bukkit.material.PressurePlate;
-import org.bukkit.material.Pumpkin;
-import org.bukkit.material.Rails;
-import org.bukkit.material.RedstoneTorch;
-import org.bukkit.material.RedstoneWire;
-import org.bukkit.material.Sandstone;
-import org.bukkit.material.Sapling;
-import org.bukkit.material.Sign;
-import org.bukkit.material.Skull;
-import org.bukkit.material.SmoothBrick;
-import org.bukkit.material.SpawnEgg;
-import org.bukkit.material.Stairs;
-import org.bukkit.material.Step;
-import org.bukkit.material.Torch;
-import org.bukkit.material.TrapDoor;
-import org.bukkit.material.Tree;
-import org.bukkit.material.Tripwire;
-import org.bukkit.material.TripwireHook;
-import org.bukkit.material.Vine;
-import org.bukkit.material.Wood;
-import org.bukkit.material.WoodenStep;
-import org.bukkit.material.Wool;
-import org.bukkit.potion.Potion;
-import org.bukkit.util.Java15Compat;
-
-import com.google.common.collect.Maps;
-
-import org.bukkit.material.Banner;
-
-/**
- * An enum of all material IDs accepted by the official server and client
- */
-public enum Material {
-    AIR(0, 0),
-    STONE(1),
-    GRASS(2),
-    DIRT(3),
-    COBBLESTONE(4),
-    WOOD(5, Wood.class),
-    SAPLING(6, Sapling.class),
-    BEDROCK(7),
-    WATER(8, MaterialData.class),
-    STATIONARY_WATER(9, MaterialData.class),
-    LAVA(10, MaterialData.class),
-    STATIONARY_LAVA(11, MaterialData.class),
-    SAND(12),
-    GRAVEL(13),
-    GOLD_ORE(14),
-    IRON_ORE(15),
-    COAL_ORE(16),
-    LOG(17, Tree.class),
-    LEAVES(18, Leaves.class),
-    SPONGE(19),
-    GLASS(20),
-    LAPIS_ORE(21),
-    LAPIS_BLOCK(22),
-    DISPENSER(23, Dispenser.class),
-    SANDSTONE(24, Sandstone.class),
-    NOTE_BLOCK(25),
-    BED_BLOCK(26, Bed.class),
-    POWERED_RAIL(27, PoweredRail.class),
-    DETECTOR_RAIL(28, DetectorRail.class),
-    PISTON_STICKY_BASE(29, PistonBaseMaterial.class),
-    WEB(30),
-    LONG_GRASS(31, LongGrass.class),
-    DEAD_BUSH(32),
-    PISTON_BASE(33, PistonBaseMaterial.class),
-    PISTON_EXTENSION(34, PistonExtensionMaterial.class),
-    WOOL(35, Wool.class),
-    PISTON_MOVING_PIECE(36),
-    YELLOW_FLOWER(37),
-    RED_ROSE(38),
-    BROWN_MUSHROOM(39),
-    RED_MUSHROOM(40),
-    GOLD_BLOCK(41),
-    IRON_BLOCK(42),
-    DOUBLE_STEP(43, Step.class),
-    STEP(44, Step.class),
-    BRICK(45),
-    TNT(46),
-    BOOKSHELF(47),
-    MOSSY_COBBLESTONE(48),
-    OBSIDIAN(49),
-    TORCH(50, Torch.class),
-    FIRE(51),
-    MOB_SPAWNER(52),
-    WOOD_STAIRS(53, Stairs.class),
-    CHEST(54, Chest.class),
-    REDSTONE_WIRE(55, RedstoneWire.class),
-    DIAMOND_ORE(56),
-    DIAMOND_BLOCK(57),
-    WORKBENCH(58),
-    CROPS(59, Crops.class),
-    SOIL(60, MaterialData.class),
-    FURNACE(61, Furnace.class),
-    BURNING_FURNACE(62, Furnace.class),
-    SIGN_POST(63, 64, Sign.class),
-    WOODEN_DOOR(64, Door.class),
-    LADDER(65, Ladder.class),
-    RAILS(66, Rails.class),
-    COBBLESTONE_STAIRS(67, Stairs.class),
-    WALL_SIGN(68, 64, Sign.class),
-    LEVER(69, Lever.class),
-    STONE_PLATE(70, PressurePlate.class),
-    IRON_DOOR_BLOCK(71, Door.class),
-    WOOD_PLATE(72, PressurePlate.class),
-    REDSTONE_ORE(73),
-    GLOWING_REDSTONE_ORE(74),
-    REDSTONE_TORCH_OFF(75, RedstoneTorch.class),
-    REDSTONE_TORCH_ON(76, RedstoneTorch.class),
-    STONE_BUTTON(77, Button.class),
-    SNOW(78),
-    ICE(79),
-    SNOW_BLOCK(80),
-    CACTUS(81, MaterialData.class),
-    CLAY(82),
-    SUGAR_CANE_BLOCK(83, MaterialData.class),
-    JUKEBOX(84),
-    FENCE(85),
-    PUMPKIN(86, Pumpkin.class),
-    NETHERRACK(87),
-    SOUL_SAND(88),
-    GLOWSTONE(89),
-    PORTAL(90),
-    JACK_O_LANTERN(91, Pumpkin.class),
-    CAKE_BLOCK(92, 64, Cake.class),
-    DIODE_BLOCK_OFF(93, Diode.class),
-    DIODE_BLOCK_ON(94, Diode.class),
-    STAINED_GLASS(95),
-    TRAP_DOOR(96, TrapDoor.class),
-    MONSTER_EGGS(97, MonsterEggs.class),
-    SMOOTH_BRICK(98, SmoothBrick.class),
-    HUGE_MUSHROOM_1(99, Mushroom.class),
-    HUGE_MUSHROOM_2(100, Mushroom.class),
-    IRON_FENCE(101),
-    THIN_GLASS(102),
-    MELON_BLOCK(103),
-    PUMPKIN_STEM(104, MaterialData.class),
-    MELON_STEM(105, MaterialData.class),
-    VINE(106, Vine.class),
-    FENCE_GATE(107, Gate.class),
-    BRICK_STAIRS(108, Stairs.class),
-    SMOOTH_STAIRS(109, Stairs.class),
-    MYCEL(110),
-    WATER_LILY(111),
-    NETHER_BRICK(112),
-    NETHER_FENCE(113),
-    NETHER_BRICK_STAIRS(114, Stairs.class),
-    NETHER_WARTS(115, NetherWarts.class),
-    ENCHANTMENT_TABLE(116),
-    BREWING_STAND(117, MaterialData.class),
-    CAULDRON(118, Cauldron.class),
-    ENDER_PORTAL(119),
-    ENDER_PORTAL_FRAME(120),
-    ENDER_STONE(121),
-    DRAGON_EGG(122),
-    REDSTONE_LAMP_OFF(123),
-    REDSTONE_LAMP_ON(124),
-    WOOD_DOUBLE_STEP(125, Wood.class),
-    WOOD_STEP(126, WoodenStep.class),
-    COCOA(127, CocoaPlant.class),
-    SANDSTONE_STAIRS(128, Stairs.class),
-    EMERALD_ORE(129),
-    ENDER_CHEST(130, EnderChest.class),
-    TRIPWIRE_HOOK(131, TripwireHook.class),
-    TRIPWIRE(132, Tripwire.class),
-    EMERALD_BLOCK(133),
-    SPRUCE_WOOD_STAIRS(134, Stairs.class),
-    BIRCH_WOOD_STAIRS(135, Stairs.class),
-    JUNGLE_WOOD_STAIRS(136, Stairs.class),
-    COMMAND(137, Command.class),
-    BEACON(138),
-    COBBLE_WALL(139),
-    FLOWER_POT(140, FlowerPot.class),
-    CARROT(141, Crops.class),
-    POTATO(142, Crops.class),
-    WOOD_BUTTON(143, Button.class),
-    SKULL(144, Skull.class),
-    ANVIL(145),
-    TRAPPED_CHEST(146, Chest.class),
-    GOLD_PLATE(147),
-    IRON_PLATE(148),
-    REDSTONE_COMPARATOR_OFF(149, Comparator.class),
-    REDSTONE_COMPARATOR_ON(150, Comparator.class),
-    DAYLIGHT_DETECTOR(151),
-    REDSTONE_BLOCK(152),
-    QUARTZ_ORE(153),
-    HOPPER(154, Hopper.class),
-    QUARTZ_BLOCK(155),
-    QUARTZ_STAIRS(156, Stairs.class),
-    ACTIVATOR_RAIL(157, PoweredRail.class),
-    DROPPER(158, Dispenser.class),
-    STAINED_CLAY(159),
-    STAINED_GLASS_PANE(160),
-    LEAVES_2(161, Leaves.class),
-    LOG_2(162, Tree.class),
-    ACACIA_STAIRS(163, Stairs.class),
-    DARK_OAK_STAIRS(164, Stairs.class),
-    SLIME_BLOCK(165),
-    BARRIER(166),
-    IRON_TRAPDOOR(167, TrapDoor.class),
-    PRISMARINE(168),
-    SEA_LANTERN(169),
-    HAY_BLOCK(170),
-    CARPET(171),
-    HARD_CLAY(172),
-    COAL_BLOCK(173),
-    PACKED_ICE(174),
-    DOUBLE_PLANT(175),
-    STANDING_BANNER(176, Banner.class),
-    WALL_BANNER(177, Banner.class),
-    DAYLIGHT_DETECTOR_INVERTED(178),
-    RED_SANDSTONE(179),
-    RED_SANDSTONE_STAIRS(180, Stairs.class),
-    DOUBLE_STONE_SLAB2(181),
-    STONE_SLAB2(182),
-    SPRUCE_FENCE_GATE(183, Gate.class),
-    BIRCH_FENCE_GATE(184, Gate.class),
-    JUNGLE_FENCE_GATE(185, Gate.class),
-    DARK_OAK_FENCE_GATE(186, Gate.class),
-    ACACIA_FENCE_GATE(187, Gate.class),
-    SPRUCE_FENCE(188),
-    BIRCH_FENCE(189),
-    JUNGLE_FENCE(190),
-    DARK_OAK_FENCE(191),
-    ACACIA_FENCE(192),
-    SPRUCE_DOOR(193, Door.class),
-    BIRCH_DOOR(194, Door.class),
-    JUNGLE_DOOR(195, Door.class),
-    ACACIA_DOOR(196, Door.class),
-    DARK_OAK_DOOR(197, Door.class),
-    END_ROD(198),
-    CHORUS_PLANT(199),
-    CHORUS_FLOWER(200),
-    PURPUR_BLOCK(201),
-    PURPUR_PILLAR(202),
-    PURPUR_STAIRS(203, Stairs.class),
-    PURPUR_DOUBLE_SLAB(204),
-    PURPUR_SLAB(205),
-    END_BRICKS(206),
-    BEETROOT_BLOCK(207, Crops.class),
-    GRASS_PATH(208),
-    END_GATEWAY(209),
-    COMMAND_REPEATING(210, Command.class),
-    COMMAND_CHAIN(211, Command.class),
-    FROSTED_ICE(212),
-    STRUCTURE_BLOCK(255),
-    // ----- Item Separator -----
-    IRON_SPADE(256, 1, 250),
-    IRON_PICKAXE(257, 1, 250),
-    IRON_AXE(258, 1, 250),
-    FLINT_AND_STEEL(259, 1, 64),
-    APPLE(260),
-    BOW(261, 1, 384),
-    ARROW(262),
-    COAL(263, Coal.class),
-    DIAMOND(264),
-    IRON_INGOT(265),
-    GOLD_INGOT(266),
-    IRON_SWORD(267, 1, 250),
-    WOOD_SWORD(268, 1, 59),
-    WOOD_SPADE(269, 1, 59),
-    WOOD_PICKAXE(270, 1, 59),
-    WOOD_AXE(271, 1, 59),
-    STONE_SWORD(272, 1, 131),
-    STONE_SPADE(273, 1, 131),
-    STONE_PICKAXE(274, 1, 131),
-    STONE_AXE(275, 1, 131),
-    DIAMOND_SWORD(276, 1, 1561),
-    DIAMOND_SPADE(277, 1, 1561),
-    DIAMOND_PICKAXE(278, 1, 1561),
-    DIAMOND_AXE(279, 1, 1561),
-    STICK(280),
-    BOWL(281),
-    MUSHROOM_SOUP(282, 1),
-    GOLD_SWORD(283, 1, 32),
-    GOLD_SPADE(284, 1, 32),
-    GOLD_PICKAXE(285, 1, 32),
-    GOLD_AXE(286, 1, 32),
-    STRING(287),
-    FEATHER(288),
-    SULPHUR(289),
-    WOOD_HOE(290, 1, 59),
-    STONE_HOE(291, 1, 131),
-    IRON_HOE(292, 1, 250),
-    DIAMOND_HOE(293, 1, 1561),
-    GOLD_HOE(294, 1, 32),
-    SEEDS(295),
-    WHEAT(296),
-    BREAD(297),
-    LEATHER_HELMET(298, 1, 55),
-    LEATHER_CHESTPLATE(299, 1, 80),
-    LEATHER_LEGGINGS(300, 1, 75),
-    LEATHER_BOOTS(301, 1, 65),
-    CHAINMAIL_HELMET(302, 1, 165),
-    CHAINMAIL_CHESTPLATE(303, 1, 240),
-    CHAINMAIL_LEGGINGS(304, 1, 225),
-    CHAINMAIL_BOOTS(305, 1, 195),
-    IRON_HELMET(306, 1, 165),
-    IRON_CHESTPLATE(307, 1, 240),
-    IRON_LEGGINGS(308, 1, 225),
-    IRON_BOOTS(309, 1, 195),
-    DIAMOND_HELMET(310, 1, 363),
-    DIAMOND_CHESTPLATE(311, 1, 528),
-    DIAMOND_LEGGINGS(312, 1, 495),
-    DIAMOND_BOOTS(313, 1, 429),
-    GOLD_HELMET(314, 1, 77),
-    GOLD_CHESTPLATE(315, 1, 112),
-    GOLD_LEGGINGS(316, 1, 105),
-    GOLD_BOOTS(317, 1, 91),
-    FLINT(318),
-    PORK(319),
-    GRILLED_PORK(320),
-    PAINTING(321),
-    GOLDEN_APPLE(322),
-    SIGN(323, 16),
-    WOOD_DOOR(324, 64),
-    BUCKET(325, 16),
-    WATER_BUCKET(326, 1),
-    LAVA_BUCKET(327, 1),
-    MINECART(328, 1),
-    SADDLE(329, 1),
-    IRON_DOOR(330, 64),
-    REDSTONE(331),
-    SNOW_BALL(332, 16),
-    BOAT(333, 1),
-    LEATHER(334),
-    MILK_BUCKET(335, 1),
-    CLAY_BRICK(336),
-    CLAY_BALL(337),
-    SUGAR_CANE(338),
-    PAPER(339),
-    BOOK(340),
-    SLIME_BALL(341),
-    STORAGE_MINECART(342, 1),
-    POWERED_MINECART(343, 1),
-    EGG(344, 16),
-    COMPASS(345),
-    FISHING_ROD(346, 1, 64),
-    WATCH(347),
-    GLOWSTONE_DUST(348),
-    RAW_FISH(349),
-    COOKED_FISH(350),
-    INK_SACK(351, Dye.class),
-    BONE(352),
-    SUGAR(353),
-    CAKE(354, 1),
-    BED(355, 1),
-    DIODE(356),
-    COOKIE(357),
-    /**
-     * @see MapView
-     */
-    MAP(358, MaterialData.class),
-    SHEARS(359, 1, 238),
-    MELON(360),
-    PUMPKIN_SEEDS(361),
-    MELON_SEEDS(362),
-    RAW_BEEF(363),
-    COOKED_BEEF(364),
-    RAW_CHICKEN(365),
-    COOKED_CHICKEN(366),
-    ROTTEN_FLESH(367),
-    ENDER_PEARL(368, 16),
-    BLAZE_ROD(369),
-    GHAST_TEAR(370),
-    GOLD_NUGGET(371),
-    NETHER_STALK(372),
-    POTION(373, 1, MaterialData.class),
-    GLASS_BOTTLE(374),
-    SPIDER_EYE(375),
-    FERMENTED_SPIDER_EYE(376),
-    BLAZE_POWDER(377),
-    MAGMA_CREAM(378),
-    BREWING_STAND_ITEM(379),
-    CAULDRON_ITEM(380),
-    EYE_OF_ENDER(381),
-    SPECKLED_MELON(382),
-    MONSTER_EGG(383, 64, SpawnEgg.class),
-    EXP_BOTTLE(384, 64),
-    FIREBALL(385, 64),
-    BOOK_AND_QUILL(386, 1),
-    WRITTEN_BOOK(387, 16),
-    EMERALD(388, 64),
-    ITEM_FRAME(389),
-    FLOWER_POT_ITEM(390),
-    CARROT_ITEM(391),
-    POTATO_ITEM(392),
-    BAKED_POTATO(393),
-    POISONOUS_POTATO(394),
-    EMPTY_MAP(395),
-    GOLDEN_CARROT(396),
-    SKULL_ITEM(397),
-    CARROT_STICK(398, 1, 25),
-    NETHER_STAR(399),
-    PUMPKIN_PIE(400),
-    FIREWORK(401),
-    FIREWORK_CHARGE(402),
-    ENCHANTED_BOOK(403, 1),
-    REDSTONE_COMPARATOR(404),
-    NETHER_BRICK_ITEM(405),
-    QUARTZ(406),
-    EXPLOSIVE_MINECART(407, 1),
-    HOPPER_MINECART(408, 1),
-    PRISMARINE_SHARD(409),
-    PRISMARINE_CRYSTALS(410),
-    RABBIT(411),
-    COOKED_RABBIT(412),
-    RABBIT_STEW(413, 1),
-    RABBIT_FOOT(414),
-    RABBIT_HIDE(415),
-    ARMOR_STAND(416, 16),
-    IRON_BARDING(417, 1),
-    GOLD_BARDING(418, 1),
-    DIAMOND_BARDING(419, 1),
-    LEASH(420),
-    NAME_TAG(421),
-    COMMAND_MINECART(422, 1),
-    MUTTON(423),
-    COOKED_MUTTON(424),
-    BANNER(425, 16),
-    END_CRYSTAL(426),
-    SPRUCE_DOOR_ITEM(427),
-    BIRCH_DOOR_ITEM(428),
-    JUNGLE_DOOR_ITEM(429),
-    ACACIA_DOOR_ITEM(430),
-    DARK_OAK_DOOR_ITEM(431),
-    CHORUS_FRUIT(432),
-    CHORUS_FRUIT_POPPED(433),
-    BEETROOT(434),
-    BEETROOT_SEEDS(435),
-    BEETROOT_SOUP(436, 1),
-    DRAGONS_BREATH(437),
-    SPLASH_POTION(438, 1),
-    SPECTRAL_ARROW(439),
-    TIPPED_ARROW(440),
-    LINGERING_POTION(441, 1),
-    SHIELD(442, 1, 336),
-    ELYTRA(443, 1, 431),
-    BOAT_SPRUCE(444, 1),
-    BOAT_BIRCH(445, 1),
-    BOAT_JUNGLE(446, 1),
-    BOAT_ACACIA(447, 1),
-    BOAT_DARK_OAK(448, 1),
-    GOLD_RECORD(2256, 1),
-    GREEN_RECORD(2257, 1),
-    RECORD_3(2258, 1),
-    RECORD_4(2259, 1),
-    RECORD_5(2260, 1),
-    RECORD_6(2261, 1),
-    RECORD_7(2262, 1),
-    RECORD_8(2263, 1),
-    RECORD_9(2264, 1),
-    RECORD_10(2265, 1),
-    RECORD_11(2266, 1),
-    RECORD_12(2267, 1),
-    ;
-
-    private final int id;
-    private final Constructor<? extends MaterialData> ctor;
-    private static Material[] byId = new Material[383];
-    private final static Map<String, Material> BY_NAME = Maps.newHashMap();
-    private final int maxStack;
-    private final short durability;
-
-    private Material(final int id) {
-        this(id, 64);
-    }
-
-    private Material(final int id, final int stack) {
-        this(id, stack, MaterialData.class);
-    }
-
-    private Material(final int id, final int stack, final int durability) {
-        this(id, stack, durability, MaterialData.class);
-    }
-
-    private Material(final int id, final Class<? extends MaterialData> data) {
-        this(id, 64, data);
-    }
-
-    private Material(final int id, final int stack, final Class<? extends MaterialData> data) {
-        this(id, stack, 0, data);
-    }
-
-    private Material(final int id, final int stack, final int durability, final Class<? extends MaterialData> data) {
-        this.id = id;
-        this.durability = (short) durability;
-        this.maxStack = stack;
-        // try to cache the constructor for this material
-        try {
-            this.ctor = data.getConstructor(int.class, byte.class);
-        } catch (NoSuchMethodException ex) {
-            throw new AssertionError(ex);
-        } catch (SecurityException ex) {
-            throw new AssertionError(ex);
-        }
-    }
-
-    /**
-     * Gets the item ID or block ID of this Material
-     *
-     * @return ID of this material
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public int getId() {
-        return id;
-    }
-
-    /**
-     * Gets the maximum amount of this material that can be held in a stack
-     *
-     * @return Maximum stack size for this material
-     */
-    public int getMaxStackSize() {
-        return maxStack;
-    }
-
-    /**
-     * Gets the maximum durability of this material
-     *
-     * @return Maximum durability for this material
-     */
-    public short getMaxDurability() {
-        return durability;
-    }
-
-    /**
-     * Gets the MaterialData class associated with this Material
-     *
-     * @return MaterialData associated with this Material
-     */
-    public Class<? extends MaterialData> getData() {
-        return ctor.getDeclaringClass();
-    }
-
-    /**
-     * Constructs a new MaterialData relevant for this Material, with the
-     * given initial data
-     *
-     * @param raw Initial data to construct the MaterialData with
-     * @return New MaterialData with the given data
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public MaterialData getNewData(final byte raw) {
-        try {
-            return ctor.newInstance(id, raw);
-        } catch (InstantiationException ex) {
-            final Throwable t = ex.getCause();
-            if (t instanceof RuntimeException) {
-                throw (RuntimeException) t;
-            }
-            if (t instanceof Error) {
-                throw (Error) t;
-            }
-            throw new AssertionError(t);
-        } catch (Throwable t) {
-            throw new AssertionError(t);
-        }
-    }
-
-    /**
-     * Checks if this Material is a placable block
-     *
-     * @return true if this material is a block
-     */
-    public boolean isBlock() {
-        return id < 256;
-    }
-
-    /**
-     * Checks if this Material is edible.
-     *
-     * @return true if this Material is edible.
-     */
-    public boolean isEdible() {
-        switch (this) {
-            case BREAD:
-            case CARROT_ITEM:
-            case BAKED_POTATO:
-            case POTATO_ITEM:
-            case POISONOUS_POTATO:
-            case GOLDEN_CARROT:
-            case PUMPKIN_PIE:
-            case COOKIE:
-            case MELON:
-            case MUSHROOM_SOUP:
-            case RAW_CHICKEN:
-            case COOKED_CHICKEN:
-            case RAW_BEEF:
-            case COOKED_BEEF:
-            case RAW_FISH:
-            case COOKED_FISH:
-            case PORK:
-            case GRILLED_PORK:
-            case APPLE:
-            case GOLDEN_APPLE:
-            case ROTTEN_FLESH:
-            case SPIDER_EYE:
-            case RABBIT:
-            case COOKED_RABBIT:
-            case RABBIT_STEW:
-            case MUTTON:
-            case COOKED_MUTTON:
-            case BEETROOT:
-            case CHORUS_FRUIT:
-            case BEETROOT_SOUP:
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    /**
-     * Attempts to get the Material with the given ID
-     *
-     * @param id ID of the material to get
-     * @return Material if found, or null
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public static Material getMaterial(final int id) {
-        if (byId.length > id && id >= 0) {
-            return byId[id];
-        } else {
-            return null;
-        }
-    }
-
-    /**
-     * Attempts to get the Material with the given name.
-     * <p>
-     * This is a normal lookup, names must be the precise name they are given
-     * in the enum.
-     *
-     * @param name Name of the material to get
-     * @return Material if found, or null
-     */
-    public static Material getMaterial(final String name) {
-        return BY_NAME.get(name);
-    }
-
-    /**
-     * Attempts to match the Material with the given name.
-     * <p>
-     * This is a match lookup; names will be converted to uppercase, then
-     * stripped of special characters in an attempt to format it like the
-     * enum.
-     * <p>
-     * Using this for match by ID is deprecated.
-     *
-     * @param name Name of the material to get
-     * @return Material if found, or null
-     */
-    public static Material matchMaterial(final String name) {
-        Validate.notNull(name, "Name cannot be null");
-
-        Material result = null;
-
-        try {
-            result = getMaterial(Integer.parseInt(name));
-        } catch (NumberFormatException ex) {}
-
-        if (result == null) {
-            String filtered = name.toUpperCase();
-
-            filtered = filtered.replaceAll("\\s+", "_").replaceAll("\\W", "");
-            result = BY_NAME.get(filtered);
-        }
-
-        return result;
-    }
-
-    static {
-        for (Material material : values()) {
-            if (byId.length > material.id) {
-                byId[material.id] = material;
-            } else {
-                byId = Java15Compat.Arrays_copyOfRange(byId, 0, material.id + 2);
-                byId[material.id] = material;
-            }
-            BY_NAME.put(material.name(), material);
-        }
-    }
-
-    /**
-     * @return True if this material represents a playable music disk.
-     */
-    public boolean isRecord() {
-        return id >= GOLD_RECORD.id && id <= RECORD_12.id;
-    }
-
-    /**
-     * Check if the material is a block and solid (cannot be passed through by
-     * a player)
-     *
-     * @return True if this material is a block and solid
-     */
-    public boolean isSolid() {
-        if (!isBlock() || id == 0) {
-            return false;
-        }
-        switch (this) {
-            case STONE:
-            case GRASS:
-            case DIRT:
-            case COBBLESTONE:
-            case WOOD:
-            case BEDROCK:
-            case SAND:
-            case GRAVEL:
-            case GOLD_ORE:
-            case IRON_ORE:
-            case COAL_ORE:
-            case LOG:
-            case LEAVES:
-            case SPONGE:
-            case GLASS:
-            case LAPIS_ORE:
-            case LAPIS_BLOCK:
-            case DISPENSER:
-            case SANDSTONE:
-            case NOTE_BLOCK:
-            case BED_BLOCK:
-            case PISTON_STICKY_BASE:
-            case PISTON_BASE:
-            case PISTON_EXTENSION:
-            case WOOL:
-            case PISTON_MOVING_PIECE:
-            case GOLD_BLOCK:
-            case IRON_BLOCK:
-            case DOUBLE_STEP:
-            case STEP:
-            case BRICK:
-            case TNT:
-            case BOOKSHELF:
-            case MOSSY_COBBLESTONE:
-            case OBSIDIAN:
-            case MOB_SPAWNER:
-            case WOOD_STAIRS:
-            case CHEST:
-            case DIAMOND_ORE:
-            case DIAMOND_BLOCK:
-            case WORKBENCH:
-            case SOIL:
-            case FURNACE:
-            case BURNING_FURNACE:
-            case SIGN_POST:
-            case WOODEN_DOOR:
-            case COBBLESTONE_STAIRS:
-            case WALL_SIGN:
-            case STONE_PLATE:
-            case IRON_DOOR_BLOCK:
-            case WOOD_PLATE:
-            case REDSTONE_ORE:
-            case GLOWING_REDSTONE_ORE:
-            case ICE:
-            case SNOW_BLOCK:
-            case CACTUS:
-            case CLAY:
-            case JUKEBOX:
-            case FENCE:
-            case PUMPKIN:
-            case NETHERRACK:
-            case SOUL_SAND:
-            case GLOWSTONE:
-            case JACK_O_LANTERN:
-            case CAKE_BLOCK:
-            case STAINED_GLASS:
-            case TRAP_DOOR:
-            case MONSTER_EGGS:
-            case SMOOTH_BRICK:
-            case HUGE_MUSHROOM_1:
-            case HUGE_MUSHROOM_2:
-            case IRON_FENCE:
-            case THIN_GLASS:
-            case MELON_BLOCK:
-            case FENCE_GATE:
-            case BRICK_STAIRS:
-            case SMOOTH_STAIRS:
-            case MYCEL:
-            case NETHER_BRICK:
-            case NETHER_FENCE:
-            case NETHER_BRICK_STAIRS:
-            case ENCHANTMENT_TABLE:
-            case BREWING_STAND:
-            case CAULDRON:
-            case ENDER_PORTAL_FRAME:
-            case ENDER_STONE:
-            case DRAGON_EGG:
-            case REDSTONE_LAMP_OFF:
-            case REDSTONE_LAMP_ON:
-            case WOOD_DOUBLE_STEP:
-            case WOOD_STEP:
-            case SANDSTONE_STAIRS:
-            case EMERALD_ORE:
-            case ENDER_CHEST:
-            case EMERALD_BLOCK:
-            case SPRUCE_WOOD_STAIRS:
-            case BIRCH_WOOD_STAIRS:
-            case JUNGLE_WOOD_STAIRS:
-            case COMMAND:
-            case BEACON:
-            case COBBLE_WALL:
-            case ANVIL:
-            case TRAPPED_CHEST:
-            case GOLD_PLATE:
-            case IRON_PLATE:
-            case DAYLIGHT_DETECTOR:
-            case REDSTONE_BLOCK:
-            case QUARTZ_ORE:
-            case HOPPER:
-            case QUARTZ_BLOCK:
-            case QUARTZ_STAIRS:
-            case DROPPER:
-            case STAINED_CLAY:
-            case HAY_BLOCK:
-            case HARD_CLAY:
-            case COAL_BLOCK:
-            case STAINED_GLASS_PANE:
-            case LEAVES_2:
-            case LOG_2:
-            case ACACIA_STAIRS:
-            case DARK_OAK_STAIRS:
-            case PACKED_ICE:
-            case RED_SANDSTONE:
-            case SLIME_BLOCK:
-            case BARRIER:
-            case IRON_TRAPDOOR:
-            case PRISMARINE:
-            case SEA_LANTERN:
-            case DOUBLE_STONE_SLAB2:
-            case RED_SANDSTONE_STAIRS:
-            case STONE_SLAB2:
-            case SPRUCE_FENCE_GATE:
-            case BIRCH_FENCE_GATE:
-            case JUNGLE_FENCE_GATE:
-            case DARK_OAK_FENCE_GATE:
-            case ACACIA_FENCE_GATE:
-            case SPRUCE_FENCE:
-            case BIRCH_FENCE:
-            case JUNGLE_FENCE:
-            case DARK_OAK_FENCE:
-            case ACACIA_FENCE:
-            case STANDING_BANNER:
-            case WALL_BANNER:
-            case DAYLIGHT_DETECTOR_INVERTED:
-            case SPRUCE_DOOR:
-            case BIRCH_DOOR:
-            case JUNGLE_DOOR:
-            case ACACIA_DOOR:
-            case DARK_OAK_DOOR:
-            case PURPUR_BLOCK:
-            case PURPUR_PILLAR:
-            case PURPUR_STAIRS:
-            case PURPUR_DOUBLE_SLAB:
-            case PURPUR_SLAB:
-            case END_BRICKS:
-            case GRASS_PATH:
-            case STRUCTURE_BLOCK:
-            case COMMAND_REPEATING:
-            case COMMAND_CHAIN:
-            case FROSTED_ICE:
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    /**
-     * Check if the material is a block and does not block any light
-     *
-     * @return True if this material is a block and does not block any light
-     */
-    public boolean isTransparent() {
-        if (!isBlock()) {
-            return false;
-        }
-        switch (this) {
-            case AIR:
-            case SAPLING:
-            case POWERED_RAIL:
-            case DETECTOR_RAIL:
-            case LONG_GRASS:
-            case DEAD_BUSH:
-            case YELLOW_FLOWER:
-            case RED_ROSE:
-            case BROWN_MUSHROOM:
-            case RED_MUSHROOM:
-            case TORCH:
-            case FIRE:
-            case REDSTONE_WIRE:
-            case CROPS:
-            case LADDER:
-            case RAILS:
-            case LEVER:
-            case REDSTONE_TORCH_OFF:
-            case REDSTONE_TORCH_ON:
-            case STONE_BUTTON:
-            case SNOW:
-            case SUGAR_CANE_BLOCK:
-            case PORTAL:
-            case DIODE_BLOCK_OFF:
-            case DIODE_BLOCK_ON:
-            case PUMPKIN_STEM:
-            case MELON_STEM:
-            case VINE:
-            case WATER_LILY:
-            case NETHER_WARTS:
-            case ENDER_PORTAL:
-            case COCOA:
-            case TRIPWIRE_HOOK:
-            case TRIPWIRE:
-            case FLOWER_POT:
-            case CARROT:
-            case POTATO:
-            case WOOD_BUTTON:
-            case SKULL:
-            case REDSTONE_COMPARATOR_OFF:
-            case REDSTONE_COMPARATOR_ON:
-            case ACTIVATOR_RAIL:
-            case CARPET:
-            case DOUBLE_PLANT:
-            case END_ROD:
-            case CHORUS_PLANT:
-            case CHORUS_FLOWER:
-            case BEETROOT_BLOCK:
-            case END_GATEWAY:
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    /**
-     * Check if the material is a block and can catch fire
-     *
-     * @return True if this material is a block and can catch fire
-     */
-    public boolean isFlammable() {
-        if (!isBlock()) {
-            return false;
-        }
-        switch (this) {
-            case WOOD:
-            case LOG:
-            case LEAVES:
-            case NOTE_BLOCK:
-            case BED_BLOCK:
-            case LONG_GRASS:
-            case DEAD_BUSH:
-            case WOOL:
-            case TNT:
-            case BOOKSHELF:
-            case WOOD_STAIRS:
-            case CHEST:
-            case WORKBENCH:
-            case SIGN_POST:
-            case WOODEN_DOOR:
-            case WALL_SIGN:
-            case WOOD_PLATE:
-            case JUKEBOX:
-            case FENCE:
-            case TRAP_DOOR:
-            case HUGE_MUSHROOM_1:
-            case HUGE_MUSHROOM_2:
-            case VINE:
-            case FENCE_GATE:
-            case WOOD_DOUBLE_STEP:
-            case WOOD_STEP:
-            case SPRUCE_WOOD_STAIRS:
-            case BIRCH_WOOD_STAIRS:
-            case JUNGLE_WOOD_STAIRS:
-            case TRAPPED_CHEST:
-            case DAYLIGHT_DETECTOR:
-            case CARPET:
-            case LEAVES_2:
-            case LOG_2:
-            case ACACIA_STAIRS:
-            case DARK_OAK_STAIRS:
-            case DOUBLE_PLANT:
-            case SPRUCE_FENCE_GATE:
-            case BIRCH_FENCE_GATE:
-            case JUNGLE_FENCE_GATE:
-            case DARK_OAK_FENCE_GATE:
-            case ACACIA_FENCE_GATE:
-            case SPRUCE_FENCE:
-            case BIRCH_FENCE:
-            case JUNGLE_FENCE:
-            case DARK_OAK_FENCE:
-            case ACACIA_FENCE:
-            case STANDING_BANNER:
-            case WALL_BANNER:
-            case DAYLIGHT_DETECTOR_INVERTED:
-            case SPRUCE_DOOR:
-            case BIRCH_DOOR:
-            case JUNGLE_DOOR:
-            case ACACIA_DOOR:
-            case DARK_OAK_DOOR:
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    /**
-     * Check if the material is a block and can burn away
-     *
-     * @return True if this material is a block and can burn away
-     */
-    public boolean isBurnable() {
-        if (!isBlock()) {
-            return false;
-        }
-        switch (this) {
-            case WOOD:
-            case LOG:
-            case LEAVES:
-            case LONG_GRASS:
-            case WOOL:
-            case YELLOW_FLOWER:
-            case RED_ROSE:
-            case TNT:
-            case BOOKSHELF:
-            case WOOD_STAIRS:
-            case FENCE:
-            case VINE:
-            case WOOD_DOUBLE_STEP:
-            case WOOD_STEP:
-            case SPRUCE_WOOD_STAIRS:
-            case BIRCH_WOOD_STAIRS:
-            case JUNGLE_WOOD_STAIRS:
-            case HAY_BLOCK:
-            case COAL_BLOCK:
-            case LEAVES_2:
-            case LOG_2:
-            case CARPET:
-            case DOUBLE_PLANT:
-            case DEAD_BUSH:
-            case FENCE_GATE:
-            case SPRUCE_FENCE_GATE:
-            case BIRCH_FENCE_GATE:
-            case JUNGLE_FENCE_GATE:
-            case DARK_OAK_FENCE_GATE:
-            case ACACIA_FENCE_GATE:
-            case SPRUCE_FENCE:
-            case BIRCH_FENCE:
-            case JUNGLE_FENCE:
-            case DARK_OAK_FENCE:
-            case ACACIA_FENCE:
-            case ACACIA_STAIRS:
-            case DARK_OAK_STAIRS:
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    /**
-     * Check if the material is a block and completely blocks vision
-     *
-     * @return True if this material is a block and completely blocks vision
-     */
-    public boolean isOccluding() {
-        if (!isBlock()) {
-            return false;
-        }
-        switch (this) {
-            case STONE:
-            case GRASS:
-            case DIRT:
-            case COBBLESTONE:
-            case WOOD:
-            case BEDROCK:
-            case SAND:
-            case GRAVEL:
-            case GOLD_ORE:
-            case IRON_ORE:
-            case COAL_ORE:
-            case LOG:
-            case SPONGE:
-            case LAPIS_ORE:
-            case LAPIS_BLOCK:
-            case DISPENSER:
-            case SANDSTONE:
-            case NOTE_BLOCK:
-            case WOOL:
-            case GOLD_BLOCK:
-            case IRON_BLOCK:
-            case DOUBLE_STEP:
-            case BRICK:
-            case BOOKSHELF:
-            case MOSSY_COBBLESTONE:
-            case OBSIDIAN:
-            case MOB_SPAWNER:
-            case DIAMOND_ORE:
-            case DIAMOND_BLOCK:
-            case WORKBENCH:
-            case FURNACE:
-            case BURNING_FURNACE:
-            case REDSTONE_ORE:
-            case GLOWING_REDSTONE_ORE:
-            case SNOW_BLOCK:
-            case CLAY:
-            case JUKEBOX:
-            case PUMPKIN:
-            case NETHERRACK:
-            case SOUL_SAND:
-            case JACK_O_LANTERN:
-            case MONSTER_EGGS:
-            case SMOOTH_BRICK:
-            case HUGE_MUSHROOM_1:
-            case HUGE_MUSHROOM_2:
-            case MELON_BLOCK:
-            case MYCEL:
-            case NETHER_BRICK:
-            case ENDER_STONE:
-            case REDSTONE_LAMP_OFF:
-            case REDSTONE_LAMP_ON:
-            case WOOD_DOUBLE_STEP:
-            case EMERALD_ORE:
-            case EMERALD_BLOCK:
-            case COMMAND:
-            case QUARTZ_ORE:
-            case QUARTZ_BLOCK:
-            case DROPPER:
-            case STAINED_CLAY:
-            case HAY_BLOCK:
-            case HARD_CLAY:
-            case COAL_BLOCK:
-            case LOG_2:
-            case PACKED_ICE:
-            case SLIME_BLOCK:
-            case BARRIER:
-            case PRISMARINE:
-            case RED_SANDSTONE:
-            case DOUBLE_STONE_SLAB2:
-            case PURPUR_BLOCK:
-            case PURPUR_PILLAR:
-            case PURPUR_DOUBLE_SLAB:
-            case END_BRICKS:
-            case STRUCTURE_BLOCK:
-            case COMMAND_REPEATING:
-            case COMMAND_CHAIN:
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    /**
-     * @return True if this material is affected by gravity.
-     */
-    public boolean hasGravity() {
-        if (!isBlock()) {
-            return false;
-        }
-        switch (this) {
-            case SAND:
-            case GRAVEL:
-            case ANVIL:
-                return true;
-            default:
-                return false;
-        }
-    }
-}
diff --git a/src/main/java/org/bukkit/NetherWartsState.java b/src/main/java/org/bukkit/NetherWartsState.java
deleted file mode 100644
index f43209c..0000000
--- a/src/main/java/org/bukkit/NetherWartsState.java
+++ /dev/null
@@ -1,21 +0,0 @@
-package org.bukkit;
-
-public enum NetherWartsState {
-
-    /**
-     * State when first seeded
-     */
-    SEEDED,
-    /**
-     * First growth stage
-     */
-    STAGE_ONE,
-    /**
-     * Second growth stage
-     */
-    STAGE_TWO,
-    /**
-     * Ready to harvest
-     */
-    RIPE;
-}
diff --git a/src/main/java/org/bukkit/Note.java b/src/main/java/org/bukkit/Note.java
deleted file mode 100644
index 417936f..0000000
--- a/src/main/java/org/bukkit/Note.java
+++ /dev/null
@@ -1,276 +0,0 @@
-package org.bukkit;
-
-import java.util.Map;
-
-import org.apache.commons.lang.Validate;
-
-import com.google.common.collect.Maps;
-
-/**
- * A note class to store a specific note.
- */
-public class Note {
-
-    /**
-     * An enum holding tones.
-     */
-    public enum Tone {
-        G(0x1, true),
-        A(0x3, true),
-        B(0x5, false),
-        C(0x6, true),
-        D(0x8, true),
-        E(0xA, false),
-        F(0xB, true);
-
-        private final boolean sharpable;
-        private final byte id;
-
-        private static final Map<Byte, Note.Tone> BY_DATA = Maps.newHashMap();
-        /** The number of tones including sharped tones. */
-        public static final byte TONES_COUNT = 12;
-
-        private Tone(int id, boolean sharpable) {
-            this.id = (byte) (id % TONES_COUNT);
-            this.sharpable = sharpable;
-        }
-
-        /**
-         * Returns the not sharped id of this tone.
-         *
-         * @return the not sharped id of this tone.
-         * @deprecated Magic value
-         */
-        @Deprecated
-        public byte getId() {
-            return getId(false);
-        }
-
-        /**
-         * Returns the id of this tone. These method allows to return the
-         * sharped id of the tone. If the tone couldn't be sharped it always
-         * return the not sharped id of this tone.
-         *
-         * @param sharped Set to true to return the sharped id.
-         * @return the id of this tone.
-         * @deprecated Magic value
-         */
-        @Deprecated
-        public byte getId(boolean sharped) {
-            byte id = (byte) (sharped && sharpable ? this.id + 1 : this.id);
-
-            return (byte) (id % TONES_COUNT);
-        }
-
-        /**
-         * Returns if this tone could be sharped.
-         *
-         * @return if this tone could be sharped.
-         */
-        public boolean isSharpable() {
-            return sharpable;
-        }
-
-        /**
-         * Returns if this tone id is the sharped id of the tone.
-         *
-         * @param id the id of the tone.
-         * @return if the tone id is the sharped id of the tone.
-         * @throws IllegalArgumentException if neither the tone nor the
-         *     semitone have the id.
-         * @deprecated Magic value
-         */
-        @Deprecated
-        public boolean isSharped(byte id) {
-            if (id == getId(false)) {
-                return false;
-            } else if (id == getId(true)) {
-                return true;
-            } else {
-                // The id isn't matching to the tone!
-                throw new IllegalArgumentException("The id isn't matching to the tone.");
-            }
-        }
-
-        /**
-         * Returns the tone to id. Also returning the semitones.
-         *
-         * @param id the id of the tone.
-         * @return the tone to id.
-         * @deprecated Magic value
-         */
-        @Deprecated
-        public static Tone getById(byte id) {
-            return BY_DATA.get(id);
-        }
-
-        static {
-            for (Tone tone : values()) {
-                int id = tone.id % TONES_COUNT;
-                BY_DATA.put((byte) id, tone);
-
-                if (tone.isSharpable()) {
-                    id = (id + 1) % TONES_COUNT;
-                    BY_DATA.put((byte) id, tone);
-                }
-            }
-        }
-    }
-
-    private final byte note;
-
-    /**
-     * Creates a new note.
-     *
-     * @param note Internal note id. {@link #getId()} always return this
-     *     value. The value has to be in the interval [0;&nbsp;24].
-     */
-    public Note(int note) {
-        Validate.isTrue(note >= 0 && note <= 24, "The note value has to be between 0 and 24.");
-
-        this.note = (byte) note;
-    }
-
-    /**
-     * Creates a new note.
-     *
-     * @param octave The octave where the note is in. Has to be 0 - 2.
-     * @param tone The tone within the octave. If the octave is 2 the note has
-     *     to be F#.
-     * @param sharped Set if the tone is sharped (e.g. for F#).
-     */
-    public Note(int octave, Tone tone, boolean sharped) {
-        if (sharped && !tone.isSharpable()) {
-            tone = Tone.values()[tone.ordinal() + 1];
-            sharped = false;
-        }
-        if (octave < 0 || octave > 2 || (octave == 2 && !(tone == Tone.F && sharped))) {
-            throw new IllegalArgumentException("Tone and octave have to be between F#0 and F#2");
-        }
-
-        this.note = (byte) (octave * Tone.TONES_COUNT + tone.getId(sharped));
-    }
-
-    /**
-     * Creates a new note for a flat tone, such as A-flat.
-     *
-     * @param octave The octave where the note is in. Has to be 0 - 1.
-     * @param tone The tone within the octave.
-     * @return The new note.
-     */
-    public static Note flat(int octave, Tone tone) {
-        Validate.isTrue(octave != 2, "Octave cannot be 2 for flats");
-        tone = tone == Tone.G ? Tone.F : Tone.values()[tone.ordinal() - 1];
-        return new Note(octave, tone, tone.isSharpable());
-    }
-
-    /**
-     * Creates a new note for a sharp tone, such as A-sharp.
-     *
-     * @param octave The octave where the note is in. Has to be 0 - 2.
-     * @param tone The tone within the octave. If the octave is 2 the note has
-     *     to be F#.
-     * @return The new note.
-     */
-    public static Note sharp(int octave, Tone tone) {
-        return new Note(octave, tone, true);
-    }
-
-    /**
-     * Creates a new note for a natural tone, such as A-natural.
-     *
-     * @param octave The octave where the note is in. Has to be 0 - 1.
-     * @param tone The tone within the octave.
-     * @return The new note.
-     */
-    public static Note natural(int octave, Tone tone) {
-        Validate.isTrue(octave != 2, "Octave cannot be 2 for naturals");
-        return new Note(octave, tone, false);
-    }
-
-    /**
-     * @return The note a semitone above this one.
-     */
-    public Note sharped() {
-        Validate.isTrue(note < 24, "This note cannot be sharped because it is the highest known note!");
-        return new Note(note + 1);
-    }
-
-    /**
-     * @return The note a semitone below this one.
-     */
-    public Note flattened() {
-        Validate.isTrue(note > 0, "This note cannot be flattened because it is the lowest known note!");
-        return new Note(note - 1);
-    }
-
-    /**
-     * Returns the internal id of this note.
-     *
-     * @return the internal id of this note.
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public byte getId() {
-        return note;
-    }
-
-    /**
-     * Returns the octave of this note.
-     *
-     * @return the octave of this note.
-     */
-    public int getOctave() {
-        return note / Tone.TONES_COUNT;
-    }
-
-    private byte getToneByte() {
-        return (byte) (note % Tone.TONES_COUNT);
-    }
-
-    /**
-     * Returns the tone of this note.
-     *
-     * @return the tone of this note.
-     */
-    public Tone getTone() {
-        return Tone.getById(getToneByte());
-    }
-
-    /**
-     * Returns if this note is sharped.
-     *
-     * @return if this note is sharped.
-     */
-    public boolean isSharped() {
-        byte note = getToneByte();
-        return Tone.getById(note).isSharped(note);
-    }
-
-    @Override
-    public int hashCode() {
-        final int prime = 31;
-        int result = 1;
-        result = prime * result + note;
-        return result;
-    }
-
-    @Override
-    public boolean equals(Object obj) {
-        if (this == obj)
-            return true;
-        if (obj == null)
-            return false;
-        if (getClass() != obj.getClass())
-            return false;
-        Note other = (Note) obj;
-        if (note != other.note)
-            return false;
-        return true;
-    }
-
-    @Override
-    public String toString() {
-        return "Note{" + getTone().toString() + (isSharped() ? "#" : "") + "}";
-    }
-}
diff --git a/src/main/java/org/bukkit/OfflinePlayer.java b/src/main/java/org/bukkit/OfflinePlayer.java
deleted file mode 100644
index 81e9292..0000000
--- a/src/main/java/org/bukkit/OfflinePlayer.java
+++ /dev/null
@@ -1,128 +0,0 @@
-package org.bukkit;
-
-import java.util.Date;
-import java.util.UUID;
-
-import org.bukkit.configuration.serialization.ConfigurationSerializable;
-import org.bukkit.entity.AnimalTamer;
-import org.bukkit.entity.Player;
-import org.bukkit.permissions.ServerOperator;
-
-import com.destroystokyo.paper.profile.AccountProfile; // Paper
-
-public interface OfflinePlayer extends ServerOperator, AnimalTamer, ConfigurationSerializable {
-
-    /**
-     * Checks if this player is currently online
-     *
-     * @return true if they are online
-     */
-    public boolean isOnline();
-
-    /**
-     * Returns the name of this player
-     * <p>
-     * Names are no longer unique past a single game session. For persistent storage
-     * it is recommended that you use {@link #getUniqueId()} instead.
-     *
-     * @return Player name or null if we have not seen a name for this player yet
-     */
-    public String getName();
-
-    /**
-     * Returns the UUID of this player
-     *
-     * @return Player UUID
-     */
-    public UUID getUniqueId();
-
-    /**
-     * Checks if this player is banned or not
-     *
-     * @return true if banned, otherwise false
-     */
-    public boolean isBanned();
-
-    /**
-     * Bans or unbans this player
-     *
-     * @param banned true if banned
-     * @deprecated Use {@link org.bukkit.BanList#addBan(String, String, Date,
-     *     String)} or {@link org.bukkit.BanList#pardon(String)} to enhance
-     *     functionality
-     */
-    @Deprecated
-    public void setBanned(boolean banned);
-
-    /**
-     * Checks if this player is whitelisted or not
-     *
-     * @return true if whitelisted
-     */
-    public boolean isWhitelisted();
-
-    /**
-     * Sets if this player is whitelisted or not
-     *
-     * @param value true if whitelisted
-     */
-    public void setWhitelisted(boolean value);
-
-    /**
-     * Gets a {@link Player} object that this represents, if there is one
-     * <p>
-     * If the player is online, this will return that player. Otherwise,
-     * it will return null.
-     *
-     * @return Online player
-     */
-    public Player getPlayer();
-
-    /**
-     * Gets the first date and time that this player was witnessed on this
-     * server.
-     * <p>
-     * If the player has never played before, this will return 0. Otherwise,
-     * it will be the amount of milliseconds since midnight, January 1, 1970
-     * UTC.
-     *
-     * @return Date of first log-in for this player, or 0
-     */
-    public long getFirstPlayed();
-
-    /**
-     * Gets the last date and time that this player was witnessed on this
-     * server.
-     * <p>
-     * If the player has never played before, this will return 0. Otherwise,
-     * it will be the amount of milliseconds since midnight, January 1, 1970
-     * UTC.
-     *
-     * @return Date of last log-in for this player, or 0
-     */
-    public long getLastPlayed();
-
-    /**
-     * Checks if this player has played on this server before.
-     *
-     * @return True if the player has played before, otherwise false
-     */
-    public boolean hasPlayedBefore();
-
-    /**
-     * Gets the Location where the player will spawn at their bed, null if
-     * they have not slept in one or their current bed spawn is invalid.
-     *
-     * @return Bed Spawn Location if bed exists, otherwise null.
-     */
-    public Location getBedSpawnLocation();
-
-	// Paper start
-   /**
-    * Return this player's profile
-    *
-    * @return this player's profile
-    */
-   public AccountProfile getAccount();
-   // Paper end
-}
diff --git a/src/main/java/org/bukkit/Particle.java b/src/main/java/org/bukkit/Particle.java
deleted file mode 100644
index af491f3..0000000
--- a/src/main/java/org/bukkit/Particle.java
+++ /dev/null
@@ -1,71 +0,0 @@
-package org.bukkit;
-
-import org.bukkit.inventory.ItemStack;
-import org.bukkit.material.MaterialData;
-
-public enum Particle {
-    EXPLOSION_NORMAL,
-    EXPLOSION_LARGE,
-    EXPLOSION_HUGE,
-    FIREWORKS_SPARK,
-    WATER_BUBBLE,
-    WATER_SPLASH,
-    WATER_WAKE,
-    SUSPENDED,
-    SUSPENDED_DEPTH,
-    CRIT,
-    CRIT_MAGIC,
-    SMOKE_NORMAL,
-    SMOKE_LARGE,
-    SPELL,
-    SPELL_INSTANT,
-    SPELL_MOB,
-    SPELL_MOB_AMBIENT,
-    SPELL_WITCH,
-    DRIP_WATER,
-    DRIP_LAVA,
-    VILLAGER_ANGRY,
-    VILLAGER_HAPPY,
-    TOWN_AURA,
-    NOTE,
-    PORTAL,
-    ENCHANTMENT_TABLE,
-    FLAME,
-    LAVA,
-    FOOTSTEP,
-    CLOUD,
-    REDSTONE,
-    SNOWBALL,
-    SNOW_SHOVEL,
-    SLIME,
-    HEART,
-    BARRIER,
-    ITEM_CRACK(ItemStack.class),
-    BLOCK_CRACK(MaterialData.class),
-    BLOCK_DUST(MaterialData.class),
-    WATER_DROP,
-    ITEM_TAKE,
-    MOB_APPEARANCE,
-    DRAGON_BREATH,
-    END_ROD,
-    DAMAGE_INDICATOR,
-    SWEEP_ATTACK;
-
-    private final Class<?> dataType;
-
-    Particle() {
-        dataType = Void.class;
-    }
-
-    Particle(Class<?> data) {
-        dataType = data;
-    }
-
-    /**
-     * Returns the required data type for the particle
-     * @return the required data type
-     */
-    public Class<?> getDataType() {
-        return dataType;
-    }
-}
diff --git a/src/main/java/org/bukkit/PortalType.java b/src/main/java/org/bukkit/PortalType.java
deleted file mode 100644
index 427cfbb..0000000
--- a/src/main/java/org/bukkit/PortalType.java
+++ /dev/null
@@ -1,22 +0,0 @@
-package org.bukkit;
-
-/**
- * Represents various types of portals that can be made in a world.
- */
-public enum PortalType {
-
-    /**
-     * This is a Nether portal, made of obsidian.
-     */
-    NETHER,
-
-    /**
-     * This is an Ender portal.
-     */
-    ENDER,
-
-    /**
-     * This is a custom Plugin portal.
-     */
-    CUSTOM;
-}
diff --git a/src/main/java/org/bukkit/Rotation.java b/src/main/java/org/bukkit/Rotation.java
deleted file mode 100644
index 5d059ea..0000000
--- a/src/main/java/org/bukkit/Rotation.java
+++ /dev/null
@@ -1,63 +0,0 @@
-package org.bukkit;
-
-/**
- * An enum to specify a rotation based orientation, like that on a clock.
- * <p>
- * It represents how something is viewed, as opposed to cardinal directions.
- */
-public enum Rotation {
-
-    /**
-     * No rotation
-     */
-    NONE,
-    /**
-     * Rotated clockwise by 45 degrees
-     */
-    CLOCKWISE_45,
-    /**
-     * Rotated clockwise by 90 degrees
-     */
-    CLOCKWISE,
-    /**
-     * Rotated clockwise by 135 degrees
-     */
-    CLOCKWISE_135,
-    /**
-     * Flipped upside-down, a 180 degree rotation
-     */
-    FLIPPED,
-    /**
-     * Flipped upside-down + 45 degree rotation
-     */
-    FLIPPED_45,
-    /**
-     * Rotated counter-clockwise by 90 degrees
-     */
-    COUNTER_CLOCKWISE,
-    /**
-     * Rotated counter-clockwise by 45 degrees
-     */
-    COUNTER_CLOCKWISE_45
-    ;
-
-    private static final Rotation [] rotations = values();
-
-    /**
-     * Rotate clockwise by 90 degrees.
-     *
-     * @return the relative rotation
-     */
-    public Rotation rotateClockwise() {
-        return rotations[(this.ordinal() + 1) & 0x7];
-    }
-
-    /**
-     * Rotate counter-clockwise by 90 degrees.
-     *
-     * @return the relative rotation
-     */
-    public Rotation rotateCounterClockwise() {
-        return rotations[(this.ordinal() - 1) & 0x7];
-    }
-}
diff --git a/src/main/java/org/bukkit/SandstoneType.java b/src/main/java/org/bukkit/SandstoneType.java
deleted file mode 100644
index a9ac16e..0000000
--- a/src/main/java/org/bukkit/SandstoneType.java
+++ /dev/null
@@ -1,51 +0,0 @@
-package org.bukkit;
-
-import java.util.Map;
-
-import com.google.common.collect.Maps;
-
-/**
- * Represents the three different types of Sandstone
- */
-public enum SandstoneType {
-    CRACKED(0x0),
-    GLYPHED(0x1),
-    SMOOTH(0x2);
-
-    private final byte data;
-    private final static Map<Byte, SandstoneType> BY_DATA = Maps.newHashMap();
-
-    private SandstoneType(final int data) {
-        this.data = (byte) data;
-    }
-
-    /**
-     * Gets the associated data value representing this type of sandstone
-     *
-     * @return A byte containing the data value of this sandstone type
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public byte getData() {
-        return data;
-    }
-
-    /**
-     * Gets the type of sandstone with the given data value
-     *
-     * @param data Data value to fetch
-     * @return The {@link SandstoneType} representing the given value, or null
-     *     if it doesn't exist
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public static SandstoneType getByData(final byte data) {
-        return BY_DATA.get(data);
-    }
-
-    static {
-        for (SandstoneType type : values()) {
-            BY_DATA.put(type.data, type);
-        }
-    }
-}
diff --git a/src/main/java/org/bukkit/Server.java b/src/main/java/org/bukkit/Server.java
deleted file mode 100644
index ad736c2..0000000
--- a/src/main/java/org/bukkit/Server.java
+++ /dev/null
@@ -1,962 +0,0 @@
-package org.bukkit;
-
-import java.awt.image.BufferedImage;
-import java.io.File;
-import java.io.Serializable;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.UUID;
-import java.util.logging.Logger;
-
-import com.destroystokyo.paper.profile.ProfileLookup; // Paper
-
-import org.bukkit.Warning.WarningState;
-import org.bukkit.boss.BarColor;
-import org.bukkit.boss.BarFlag;
-import org.bukkit.boss.BarStyle;
-import org.bukkit.boss.BossBar;
-import org.bukkit.command.CommandException;
-import org.bukkit.command.CommandSender;
-import org.bukkit.command.ConsoleCommandSender;
-import org.bukkit.command.PluginCommand;
-import org.bukkit.entity.Entity;
-import org.bukkit.entity.Player;
-import org.bukkit.event.inventory.InventoryType;
-import org.bukkit.event.server.ServerListPingEvent;
-import org.bukkit.help.HelpMap;
-import org.bukkit.inventory.Inventory;
-import org.bukkit.inventory.InventoryHolder;
-import org.bukkit.inventory.ItemStack;
-import org.bukkit.inventory.Recipe;
-import org.bukkit.map.MapView;
-import org.bukkit.permissions.Permissible;
-import org.bukkit.plugin.PluginManager;
-import org.bukkit.plugin.ServicesManager;
-import org.bukkit.plugin.messaging.Messenger;
-import org.bukkit.plugin.messaging.PluginMessageRecipient;
-import org.bukkit.scheduler.BukkitScheduler;
-import org.bukkit.scoreboard.ScoreboardManager;
-import org.bukkit.util.CachedServerIcon;
-
-import com.avaje.ebean.config.ServerConfig;
-import com.google.common.collect.ImmutableList;
-import org.bukkit.generator.ChunkGenerator;
-
-import org.bukkit.inventory.ItemFactory;
-import org.bukkit.inventory.meta.ItemMeta;
-
-/**
- * Represents a server implementation.
- */
-public interface Server extends PluginMessageRecipient {
-
-    /**
-     * Used for all administrative messages, such as an operator using a
-     * command.
-     * <p>
-     * For use in {@link #broadcast(java.lang.String, java.lang.String)}.
-     */
-    public static final String BROADCAST_CHANNEL_ADMINISTRATIVE = "bukkit.broadcast.admin";
-
-    /**
-     * Used for all announcement messages, such as informing users that a
-     * player has joined.
-     * <p>
-     * For use in {@link #broadcast(java.lang.String, java.lang.String)}.
-     */
-    public static final String BROADCAST_CHANNEL_USERS = "bukkit.broadcast.user";
-
-    /**
-     * Gets the name of this server implementation.
-     *
-     * @return name of this server implementation
-     */
-    public String getName();
-
-    /**
-     * Gets the version string of this server implementation.
-     *
-     * @return version of this server implementation
-     */
-    public String getVersion();
-
-    /**
-     * Gets the Bukkit version that this server is running.
-     *
-     * @return version of Bukkit
-     */
-    public String getBukkitVersion();
-
-    /**
-     * Gets an array copy of all currently logged in players.
-     * <p>
-     * This method exists for legacy reasons to provide backwards
-     * compatibility. It will not exist at runtime and should not be used
-     * under any circumstances.
-     *
-     * @deprecated superseded by {@link #getOnlinePlayers()}
-     * @return an array of Players that are currently online
-     */
-    @Deprecated
-    public Player[] _INVALID_getOnlinePlayers();
-
-    /**
-     * Gets a view of all currently logged in players. This {@linkplain
-     * Collections#unmodifiableCollection(Collection) view} is a reused
-     * object, making some operations like {@link Collection#size()}
-     * zero-allocation.
-     * <p>
-     * The collection is a view backed by the internal representation, such
-     * that, changes to the internal state of the server will be reflected
-     * immediately. However, the reuse of the returned collection (identity)
-     * is not strictly guaranteed for future or all implementations. Casting
-     * the collection, or relying on interface implementations (like {@link
-     * Serializable} or {@link List}), is deprecated.
-     * <p>
-     * Iteration behavior is undefined outside of self-contained main-thread
-     * uses. Normal and immediate iterator use without consequences that
-     * affect the collection are fully supported. The effects following
-     * (non-exhaustive) {@link Entity#teleport(Location) teleportation},
-     * {@link Player#setHealth(double) death}, and {@link Player#kickPlayer(
-     * String) kicking} are undefined. Any use of this collection from
-     * asynchronous threads is unsafe.
-     * <p>
-     * For safe consequential iteration or mimicking the old array behavior,
-     * using {@link Collection#toArray(Object[])} is recommended. For making
-     * snapshots, {@link ImmutableList#copyOf(Collection)} is recommended.
-     *
-     * @return a view of currently online players.
-     */
-    public Collection<? extends Player> getOnlinePlayers();
-
-    /**
-     * Get the maximum amount of players which can login to this server.
-     *
-     * @return the amount of players this server allows
-     */
-    public int getMaxPlayers();
-
-    /**
-     * Get the game port that the server runs on.
-     *
-     * @return the port number of this server
-     */
-    public int getPort();
-
-    /**
-     * Get the view distance from this server.
-     *
-     * @return the view distance from this server.
-     */
-    public int getViewDistance();
-
-    /**
-     * Get the IP that this server is bound to, or empty string if not
-     * specified.
-     *
-     * @return the IP string that this server is bound to, otherwise empty
-     *     string
-     */
-    public String getIp();
-
-    /**
-     * Get the name of this server.
-     *
-     * @return the name of this server
-     */
-    public String getServerName();
-
-    /**
-     * Get an ID of this server. The ID is a simple generally alphanumeric ID
-     * that can be used for uniquely identifying this server.
-     *
-     * @return the ID of this server
-     */
-    public String getServerId();
-
-    /**
-     * Get world type (level-type setting) for default world.
-     *
-     * @return the value of level-type (e.g. DEFAULT, FLAT, DEFAULT_1_1)
-     */
-    public String getWorldType();
-
-    /**
-     * Get generate-structures setting.
-     *
-     * @return true if structure generation is enabled, false otherwise
-     */
-    public boolean getGenerateStructures();
-
-    /**
-     * Gets whether this server allows the End or not.
-     *
-     * @return whether this server allows the End or not
-     */
-    public boolean getAllowEnd();
-
-    /**
-     * Gets whether this server allows the Nether or not.
-     *
-     * @return whether this server allows the Nether or not
-     */
-    public boolean getAllowNether();
-
-    /**
-     * Gets whether this server has a whitelist or not.
-     *
-     * @return whether this server has a whitelist or not
-     */
-    public boolean hasWhitelist();
-
-    /**
-     * Sets if the server is whitelisted.
-     *
-     * @param value true for whitelist on, false for off
-     */
-    public void setWhitelist(boolean value);
-
-    /**
-     * Gets a list of whitelisted players.
-     *
-     * @return a set containing all whitelisted players
-     */
-    public Set<OfflinePlayer> getWhitelistedPlayers();
-
-    /**
-     * Reloads the whitelist from disk.
-     */
-    public void reloadWhitelist();
-
-    /**
-     * Broadcast a message to all players.
-     * <p>
-     * This is the same as calling {@link #broadcast(java.lang.String,
-     * java.lang.String)} to {@link #BROADCAST_CHANNEL_USERS}
-     *
-     * @param message the message
-     * @return the number of players
-     */
-    public int broadcastMessage(String message);
-
-    /**
-     * Gets the name of the update folder. The update folder is used to safely
-     * update plugins at the right moment on a plugin load.
-     * <p>
-     * The update folder name is relative to the plugins folder.
-     *
-     * @return the name of the update folder
-     */
-    public String getUpdateFolder();
-
-    /**
-     * Gets the update folder. The update folder is used to safely update
-     * plugins at the right moment on a plugin load.
-     *
-     * @return the update folder
-     */
-    public File getUpdateFolderFile();
-
-    /**
-     * Gets the value of the connection throttle setting.
-     *
-     * @return the value of the connection throttle setting
-     */
-    public long getConnectionThrottle();
-
-    /**
-     * Gets default ticks per animal spawns value.
-     * <p>
-     * <b>Example Usage:</b>
-     * <ul>
-     * <li>A value of 1 will mean the server will attempt to spawn monsters
-     *     every tick.
-     * <li>A value of 400 will mean the server will attempt to spawn monsters
-     *     every 400th tick.
-     * <li>A value below 0 will be reset back to Minecraft's default.
-     * </ul>
-     * <p>
-     * <b>Note:</b> If set to 0, animal spawning will be disabled. We
-     * recommend using spawn-animals to control this instead.
-     * <p>
-     * Minecraft default: 400.
-     *
-     * @return the default ticks per animal spawns value
-     */
-    public int getTicksPerAnimalSpawns();
-
-    /**
-     * Gets the default ticks per monster spawns value.
-     * <p>
-     * <b>Example Usage:</b>
-     * <ul>
-     * <li>A value of 1 will mean the server will attempt to spawn monsters
-     *     every tick.
-     * <li>A value of 400 will mean the server will attempt to spawn monsters
-     *     every 400th tick.
-     * <li>A value below 0 will be reset back to Minecraft's default.
-     * </ul>
-     * <p>
-     * <b>Note:</b> If set to 0, monsters spawning will be disabled. We
-     * recommend using spawn-monsters to control this instead.
-     * <p>
-     * Minecraft default: 1.
-     *
-     * @return the default ticks per monsters spawn value
-     */
-    public int getTicksPerMonsterSpawns();
-
-    /**
-     * Gets a player object by the given username.
-     * <p>
-     * This method may not return objects for offline players.
-     *
-     * @deprecated Use {@link #getPlayer(UUID)} as player names are no longer
-     *     guaranteed to be unique
-     * @param name the name to look up
-     * @return a player if one was found, null otherwise
-     */
-    @Deprecated
-    public Player getPlayer(String name);
-
-    /**
-     * Gets the player with the exact given name, case insensitive.
-     *
-     * @deprecated Use {@link #getPlayer(UUID)} as player names are no longer
-     *     guaranteed to be unique
-     * @param name Exact name of the player to retrieve
-     * @return a player object if one was found, null otherwise
-     */
-    @Deprecated
-    public Player getPlayerExact(String name);
-
-    /**
-     * Attempts to match any players with the given name, and returns a list
-     * of all possibly matches.
-     * <p>
-     * This list is not sorted in any particular order. If an exact match is
-     * found, the returned list will only contain a single result.
-     *
-     * @deprecated Use {@link #getPlayer(UUID)} as player names are no longer
-     *     guaranteed to be unique
-     * @param name the (partial) name to match
-     * @return list of all possible players
-     */
-    @Deprecated
-    public List<Player> matchPlayer(String name);
-
-    /**
-     * Gets the player with the given UUID.
-     *
-     * @param id UUID of the player to retrieve
-     * @return a player object if one was found, null otherwise
-     */
-    public Player getPlayer(UUID id);
-
-    /**
-     * Gets the plugin manager for interfacing with plugins.
-     *
-     * @return a plugin manager for this Server instance
-     */
-    public PluginManager getPluginManager();
-
-    /**
-     * Gets the scheduler for managing scheduled events.
-     *
-     * @return a scheduling service for this server
-     */
-    public BukkitScheduler getScheduler();
-
-    /**
-     * Gets a services manager.
-     *
-     * @return s services manager
-     */
-    public ServicesManager getServicesManager();
-
-    /**
-     * Gets a list of all worlds on this server.
-     *
-     * @return a list of worlds
-     */
-    public List<World> getWorlds();
-
-    /**
-     * Creates or loads a world with the given name using the specified
-     * options.
-     * <p>
-     * If the world is already loaded, it will just return the equivalent of
-     * getWorld(creator.name()).
-     *
-     * @param creator the options to use when creating the world
-     * @return newly created or loaded world
-     */
-    public World createWorld(WorldCreator creator);
-
-    /**
-     * Unloads a world with the given name.
-     *
-     * @param name Name of the world to unload
-     * @param save whether to save the chunks before unloading
-     * @return true if successful, false otherwise
-     */
-    public boolean unloadWorld(String name, boolean save);
-
-    /**
-     * Unloads the given world.
-     *
-     * @param world the world to unload
-     * @param save whether to save the chunks before unloading
-     * @return true if successful, false otherwise
-     */
-    public boolean unloadWorld(World world, boolean save);
-
-    /**
-     * Gets the world with the given name.
-     *
-     * @param name the name of the world to retrieve
-     * @return a world with the given name, or null if none exists
-     */
-    public World getWorld(String name);
-
-    /**
-     * Gets the world from the given Unique ID.
-     *
-     * @param uid a unique-id of the world to retrieve
-     * @return a world with the given Unique ID, or null if none exists
-     */
-    public World getWorld(UUID uid);
-
-    /**
-     * Gets the map from the given item ID.
-     *
-     * @param id the id of the map to get
-     * @return a map view if it exists, or null otherwise
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public MapView getMap(short id);
-
-    /**
-     * Create a new map with an automatically assigned ID.
-     *
-     * @param world the world the map will belong to
-     * @return a newly created map view
-     */
-    public MapView createMap(World world);
-
-    /**
-     * Reloads the server, refreshing settings and plugin information.
-     */
-    public void reload();
-
-    /**
-     * Returns the primary logger associated with this server instance.
-     *
-     * @return Logger associated with this server
-     */
-    public Logger getLogger();
-
-    /**
-     * Gets a {@link PluginCommand} with the given name or alias.
-     *
-     * @param name the name of the command to retrieve
-     * @return a plugin command if found, null otherwise
-     */
-    public PluginCommand getPluginCommand(String name);
-
-    /**
-     * Writes loaded players to disk.
-     */
-    public void savePlayers();
-
-    /**
-     * Dispatches a command on this server, and executes it if found.
-     *
-     * @param sender the apparent sender of the command
-     * @param commandLine the command + arguments. Example: <code>test abc
-     *     123</code>
-     * @return returns false if no target is found
-     * @throws CommandException thrown when the executor for the given command
-     *     fails with an unhandled exception
-     */
-    public boolean dispatchCommand(CommandSender sender, String commandLine) throws CommandException;
-
-    /**
-     * Populates a given {@link ServerConfig} with values attributes to this
-     * server.
-     *
-     * @param config the server config to populate
-     */
-    public void configureDbConfig(ServerConfig config);
-
-    /**
-     * Adds a recipe to the crafting manager.
-     *
-     * @param recipe the recipe to add
-     * @return true if the recipe was added, false if it wasn't for some
-     *     reason
-     */
-    public boolean addRecipe(Recipe recipe);
-
-    /**
-     * Get a list of all recipes for a given item. The stack size is ignored
-     * in comparisons. If the durability is -1, it will match any data value.
-     *
-     * @param result the item to match against recipe results
-     * @return a list of recipes with the given result
-     */
-    public List<Recipe> getRecipesFor(ItemStack result);
-
-    /**
-     * Get an iterator through the list of crafting recipes.
-     *
-     * @return an iterator
-     */
-    public Iterator<Recipe> recipeIterator();
-
-    /**
-     * Clears the list of crafting recipes.
-     */
-    public void clearRecipes();
-
-    /**
-     * Resets the list of crafting recipes to the default.
-     */
-    public void resetRecipes();
-
-    /**
-     * Gets a list of command aliases defined in the server properties.
-     *
-     * @return a map of aliases to command names
-     */
-    public Map<String, String[]> getCommandAliases();
-
-    /**
-     * Gets the radius, in blocks, around each worlds spawn point to protect.
-     *
-     * @return spawn radius, or 0 if none
-     */
-    public int getSpawnRadius();
-
-    /**
-     * Sets the radius, in blocks, around each worlds spawn point to protect.
-     *
-     * @param value new spawn radius, or 0 if none
-     */
-    public void setSpawnRadius(int value);
-
-    /**
-     * Gets whether the Server is in online mode or not.
-     *
-     * @return true if the server authenticates clients, false otherwise
-     */
-    public boolean getOnlineMode();
-
-    /**
-     * Gets whether this server allows flying or not.
-     *
-     * @return true if the server allows flight, false otherwise
-     */
-    public boolean getAllowFlight();
-
-    /**
-     * Gets whether the server is in hardcore mode or not.
-     *
-     * @return true if the server mode is hardcore, false otherwise
-     */
-    public boolean isHardcore();
-
-    /**
-     * Gets whether to use vanilla (false) or exact behaviour (true).
-     *
-     * <ul>
-     * <li>Vanilla behaviour: check for collisions and move the player if
-     *     needed.
-     * <li>Exact behaviour: spawn players exactly where they should be.
-     * </ul>
-     *
-     * @return true if exact location locations are used for spawning, false
-     *     for vanilla collision detection or otherwise
-     *
-     * @deprecated non standard and unused feature.
-     */
-    @Deprecated
-    public boolean useExactLoginLocation();
-
-    /**
-     * Shutdowns the server, stopping everything.
-     */
-    public void shutdown();
-
-    /**
-     * Broadcasts the specified message to every user with the given
-     * permission name.
-     *
-     * @param message message to broadcast
-     * @param permission the required permission {@link Permissible
-     *     permissibles} must have to receive the broadcast
-     * @return number of message recipients
-     */
-    public int broadcast(String message, String permission);
-
-    /**
-     * Gets the player by the given name, regardless if they are offline or
-     * online.
-     * <p>
-     * This method may involve a blocking web request to get the UUID for the
-     * given name.
-     * <p>
-     * This will return an object even if the player does not exist. To this
-     * method, all players will exist.
-     *
-     * @deprecated Persistent storage of users should be by UUID as names are no longer
-     *             unique past a single session.
-     * @param name the name the player to retrieve
-     * @return an offline player
-     * @see #getOfflinePlayer(java.util.UUID)
-     */
-    @Deprecated
-    public OfflinePlayer getOfflinePlayer(String name);
-
-    /**
-     * Gets the player by the given UUID, regardless if they are offline or
-     * online.
-     * <p>
-     * This will return an object even if the player does not exist. To this
-     * method, all players will exist.
-     *
-     * @param id the UUID of the player to retrieve
-     * @return an offline player
-     */
-    public OfflinePlayer getOfflinePlayer(UUID id);
-
-    /**
-     * Gets a set containing all current IPs that are banned.
-     *
-     * @return a set containing banned IP addresses
-     */
-    public Set<String> getIPBans();
-
-    /**
-     * Bans the specified address from the server.
-     *
-     * @param address the IP address to ban
-     */
-    public void banIP(String address);
-
-    /**
-     * Unbans the specified address from the server.
-     *
-     * @param address the IP address to unban
-     */
-    public void unbanIP(String address);
-
-    /**
-     * Gets a set containing all banned players.
-     *
-     * @return a set containing banned players
-     */
-    public Set<OfflinePlayer> getBannedPlayers();
-
-    /**
-     * Gets a ban list for the supplied type.
-     * <p>
-     * Bans by name are no longer supported and this method will return
-     * null when trying to request them. The replacement is bans by UUID.
-     *
-     * @param type the type of list to fetch, cannot be null
-     * @return a ban list of the specified type
-     */
-    public BanList getBanList(BanList.Type type);
-
-    /**
-     * Gets a set containing all player operators.
-     *
-     * @return a set containing player operators
-     */
-    public Set<OfflinePlayer> getOperators();
-
-    /**
-     * Gets the default {@link GameMode} for new players.
-     *
-     * @return the default game mode
-     */
-    public GameMode getDefaultGameMode();
-
-    /**
-     * Sets the default {@link GameMode} for new players.
-     *
-     * @param mode the new game mode
-     */
-    public void setDefaultGameMode(GameMode mode);
-
-    /**
-     * Gets a {@link ConsoleCommandSender} that may be used as an input source
-     * for this server.
-     *
-     * @return a console command sender
-     */
-    public ConsoleCommandSender getConsoleSender();
-
-    /**
-     * Gets the folder that contains all of the various {@link World}s.
-     *
-     * @return folder that contains all worlds
-     */
-    public File getWorldContainer();
-
-    /**
-     * Gets every player that has ever played on this server.
-     *
-     * @return an array containing all previous players
-     */
-    public OfflinePlayer[] getOfflinePlayers();
-
-    /**
-     * Gets the {@link Messenger} responsible for this server.
-     *
-     * @return messenger responsible for this server
-     */
-    public Messenger getMessenger();
-
-    /**
-     * Gets the {@link HelpMap} providing help topics for this server.
-     *
-     * @return a help map for this server
-     */
-    public HelpMap getHelpMap();
-
-    /**
-     * Creates an empty inventory of the specified type. If the type is {@link
-     * InventoryType#CHEST}, the new inventory has a size of 27; otherwise the
-     * new inventory has the normal size for its type.
-     *
-     * @param owner the holder of the inventory, or null to indicate no holder
-     * @param type the type of inventory to create
-     * @return a new inventory
-     */
-    Inventory createInventory(InventoryHolder owner, InventoryType type);
-
-    /**
-     * Creates an empty inventory with the specified type and title. If the type
-     * is {@link InventoryType#CHEST}, the new inventory has a size of 27;
-     * otherwise the new inventory has the normal size for its type.<br>
-     * It should be noted that some inventory types do not support titles and
-     * may not render with said titles on the Minecraft client.
-     *
-     * @param owner The holder of the inventory; can be null if there's no holder.
-     * @param type The type of inventory to create.
-     * @param title The title of the inventory, to be displayed when it is viewed.
-     * @return The new inventory.
-     */
-    Inventory createInventory(InventoryHolder owner, InventoryType type, String title);
-
-    /**
-     * Creates an empty inventory of type {@link InventoryType#CHEST} with the
-     * specified size.
-     *
-     * @param owner the holder of the inventory, or null to indicate no holder
-     * @param size a multiple of 9 as the size of inventory to create
-     * @return a new inventory
-     * @throws IllegalArgumentException if the size is not a multiple of 9
-     */
-    Inventory createInventory(InventoryHolder owner, int size) throws IllegalArgumentException;
-
-    /**
-     * Creates an empty inventory of type {@link InventoryType#CHEST} with the
-     * specified size and title.
-     *
-     * @param owner the holder of the inventory, or null to indicate no holder
-     * @param size a multiple of 9 as the size of inventory to create
-     * @param title the title of the inventory, displayed when inventory is
-     *     viewed
-     * @return a new inventory
-     * @throws IllegalArgumentException if the size is not a multiple of 9
-     */
-    Inventory createInventory(InventoryHolder owner, int size, String title) throws IllegalArgumentException;
-
-    /**
-     * Gets user-specified limit for number of monsters that can spawn in a
-     * chunk.
-     *
-     * @return the monster spawn limit
-     */
-    int getMonsterSpawnLimit();
-
-    /**
-     * Gets user-specified limit for number of animals that can spawn in a
-     * chunk.
-     *
-     * @return the animal spawn limit
-     */
-    int getAnimalSpawnLimit();
-
-    /**
-     * Gets user-specified limit for number of water animals that can spawn in
-     * a chunk.
-     *
-     * @return the water animal spawn limit
-     */
-    int getWaterAnimalSpawnLimit();
-
-    /**
-     * Gets user-specified limit for number of ambient mobs that can spawn in
-     * a chunk.
-     *
-     * @return the ambient spawn limit
-     */
-    int getAmbientSpawnLimit();
-
-    /**
-     * Checks the current thread against the expected primary thread for the
-     * server.
-     * <p>
-     * <b>Note:</b> this method should not be used to indicate the current
-     * synchronized state of the runtime. A current thread matching the main
-     * thread indicates that it is synchronized, but a mismatch <b>does not
-     * preclude</b> the same assumption.
-     *
-     * @return true if the current thread matches the expected primary thread,
-     *     false otherwise
-     */
-    boolean isPrimaryThread();
-
-    /**
-     * Gets the message that is displayed on the server list.
-     *
-     * @return the servers MOTD
-     */
-    String getMotd();
-
-    /**
-     * Gets the default message that is displayed when the server is stopped.
-     *
-     * @return the shutdown message
-     */
-    String getShutdownMessage();
-
-    /**
-     * Gets the current warning state for the server.
-     *
-     * @return the configured warning state
-     */
-    public WarningState getWarningState();
-
-    /**
-     * Gets the instance of the item factory (for {@link ItemMeta}).
-     *
-     * @return the item factory
-     * @see ItemFactory
-     */
-    ItemFactory getItemFactory();
-
-    /**
-     * Gets the instance of the scoreboard manager.
-     * <p>
-     * This will only exist after the first world has loaded.
-     *
-     * @return the scoreboard manager or null if no worlds are loaded.
-     */
-    ScoreboardManager getScoreboardManager();
-
-    /**
-     * Gets an instance of the server's default server-icon.
-     *
-     * @return the default server-icon; null values may be used by the
-     *     implementation to indicate no defined icon, but this behavior is
-     *     not guaranteed
-     */
-    CachedServerIcon getServerIcon();
-
-    /**
-     * Loads an image from a file, and returns a cached image for the specific
-     * server-icon.
-     * <p>
-     * Size and type are implementation defined. An incompatible file is
-     * guaranteed to throw an implementation-defined {@link Exception}.
-     *
-     * @param file the file to load the from
-     * @throws IllegalArgumentException if image is null
-     * @throws Exception if the image does not meet current server server-icon
-     *     specifications
-     * @return a cached server-icon that can be used for a {@link
-     *     ServerListPingEvent#setServerIcon(CachedServerIcon)}
-     */
-    CachedServerIcon loadServerIcon(File file) throws IllegalArgumentException, Exception;
-
-    /**
-     * Creates a cached server-icon for the specific image.
-     * <p>
-     * Size and type are implementation defined. An incompatible file is
-     * guaranteed to throw an implementation-defined {@link Exception}.
-     *
-     * @param image the image to use
-     * @throws IllegalArgumentException if image is null
-     * @throws Exception if the image does not meet current server
-     *     server-icon specifications
-     * @return a cached server-icon that can be used for a {@link
-     *     ServerListPingEvent#setServerIcon(CachedServerIcon)}
-     */
-    CachedServerIcon loadServerIcon(BufferedImage image) throws IllegalArgumentException, Exception;
-
-    /**
-     * Set the idle kick timeout. Any players idle for the specified amount of
-     * time will be automatically kicked.
-     * <p>
-     * A value of 0 will disable the idle kick timeout.
-     *
-     * @param threshold the idle timeout in minutes
-     */
-    public void setIdleTimeout(int threshold);
-
-    /**
-     * Gets the idle kick timeout.
-     *
-     * @return the idle timeout in minutes
-     */
-    public int getIdleTimeout();
-
-    /**
-     * Create a ChunkData for use in a generator.
-     * 
-     * See {@link ChunkGenerator#generateChunkData(org.bukkit.World, java.util.Random, int, int, org.bukkit.generator.ChunkGenerator.BiomeGrid)}
-     * 
-     * @param world the world to create the ChunkData for
-     * @return a new ChunkData for the world
-     * 
-     */
-    public ChunkGenerator.ChunkData createChunkData(World world);
-
-    /**
-     * Creates a boss bar instance to display to players. The progress
-     * defaults to 1.0
-     *
-     * @param title the title of the boss bar
-     * @param color the color of the boss bar
-     * @param style the style of the boss bar
-     * @param flags an optional list of flags to set on the boss bar
-     * @return the created boss bar
-     */
-    BossBar createBossBar(String title, BarColor color, BarStyle style, BarFlag ...flags);
-
-    /**
-     * @see UnsafeValues
-     * @return the unsafe values instance
-     */
-    @Deprecated
-    UnsafeValues getUnsafe();
-	
-	// Paper start - profile api
-   /**
-    * Get the server's profile lookup
-    *
-    * @return the server's profile lookup
-    */
-   public ProfileLookup getProfileLookup();
-   // Paper end
-}
diff --git a/src/main/java/org/bukkit/SkullType.java b/src/main/java/org/bukkit/SkullType.java
deleted file mode 100644
index db651d5..0000000
--- a/src/main/java/org/bukkit/SkullType.java
+++ /dev/null
@@ -1,13 +0,0 @@
-package org.bukkit;
-
-/**
- * Represents the different types of skulls.
- */
-public enum SkullType {
-    SKELETON,
-    WITHER,
-    ZOMBIE,
-    PLAYER,
-    CREEPER,
-    DRAGON;
-}
diff --git a/src/main/java/org/bukkit/Sound.java b/src/main/java/org/bukkit/Sound.java
deleted file mode 100644
index a038633..0000000
--- a/src/main/java/org/bukkit/Sound.java
+++ /dev/null
@@ -1,456 +0,0 @@
-package org.bukkit;
-
-/**
- * An Enum of Sounds the server is able to send to players.
- * <p>
- * WARNING: At any time, sounds may be added/removed from this Enum or even
- * MineCraft itself! There is no guarantee the sounds will play. There is no
- * guarantee values will not be removed from this Enum. As such, you should
- * not depend on the ordinal values of this class.
- */
-public enum Sound {
-    AMBIENT_CAVE,
-    BLOCK_ANVIL_BREAK,
-    BLOCK_ANVIL_DESTROY,
-    BLOCK_ANVIL_FALL,
-    BLOCK_ANVIL_HIT,
-    BLOCK_ANVIL_LAND,
-    BLOCK_ANVIL_PLACE,
-    BLOCK_ANVIL_STEP,
-    BLOCK_ANVIL_USE,
-    BLOCK_BREWING_STAND_BREW,
-    BLOCK_CHEST_CLOSE,
-    BLOCK_CHEST_LOCKED,
-    BLOCK_CHEST_OPEN,
-    BLOCK_CHORUS_FLOWER_DEATH,
-    BLOCK_CHORUS_FLOWER_GROW,
-    BLOCK_CLOTH_BREAK,
-    BLOCK_CLOTH_FALL,
-    BLOCK_CLOTH_HIT,
-    BLOCK_CLOTH_PLACE,
-    BLOCK_CLOTH_STEP,
-    BLOCK_COMPARATOR_CLICK,
-    BLOCK_DISPENSER_DISPENSE,
-    BLOCK_DISPENSER_FAIL,
-    BLOCK_DISPENSER_LAUNCH,
-    BLOCK_ENDERCHEST_CLOSE,
-    BLOCK_ENDERCHEST_OPEN,
-    BLOCK_END_GATEWAY_SPAWN,
-    BLOCK_FENCE_GATE_CLOSE,
-    BLOCK_FENCE_GATE_OPEN,
-    BLOCK_FIRE_AMBIENT,
-    BLOCK_FIRE_EXTINGUISH,
-    BLOCK_FURNACE_FIRE_CRACKLE,
-    BLOCK_GLASS_BREAK,
-    BLOCK_GLASS_FALL,
-    BLOCK_GLASS_HIT,
-    BLOCK_GLASS_PLACE,
-    BLOCK_GLASS_STEP,
-    BLOCK_GRASS_BREAK,
-    BLOCK_GRASS_FALL,
-    BLOCK_GRASS_HIT,
-    BLOCK_GRASS_PLACE,
-    BLOCK_GRASS_STEP,
-    BLOCK_GRAVEL_BREAK,
-    BLOCK_GRAVEL_FALL,
-    BLOCK_GRAVEL_HIT,
-    BLOCK_GRAVEL_PLACE,
-    BLOCK_GRAVEL_STEP,
-    BLOCK_IRON_DOOR_CLOSE,
-    BLOCK_IRON_DOOR_OPEN,
-    BLOCK_IRON_TRAPDOOR_CLOSE,
-    BLOCK_IRON_TRAPDOOR_OPEN,
-    BLOCK_LADDER_BREAK,
-    BLOCK_LADDER_FALL,
-    BLOCK_LADDER_HIT,
-    BLOCK_LADDER_PLACE,
-    BLOCK_LADDER_STEP,
-    BLOCK_LAVA_AMBIENT,
-    BLOCK_LAVA_EXTINGUISH,
-    BLOCK_LAVA_POP,
-    BLOCK_LEVER_CLICK,
-    BLOCK_METAL_BREAK,
-    BLOCK_METAL_FALL,
-    BLOCK_METAL_HIT,
-    BLOCK_METAL_PLACE,
-    BLOCK_METAL_PRESSUREPLATE_CLICK_OFF,
-    BLOCK_METAL_PRESSUREPLATE_CLICK_ON,
-    BLOCK_METAL_STEP,
-    BLOCK_NOTE_BASEDRUM,
-    BLOCK_NOTE_BASS,
-    BLOCK_NOTE_HARP,
-    BLOCK_NOTE_HAT,
-    BLOCK_NOTE_PLING,
-    BLOCK_NOTE_SNARE,
-    BLOCK_PISTON_CONTRACT,
-    BLOCK_PISTON_EXTEND,
-    BLOCK_PORTAL_AMBIENT,
-    BLOCK_PORTAL_TRAVEL,
-    BLOCK_PORTAL_TRIGGER,
-    BLOCK_REDSTONE_TORCH_BURNOUT,
-    BLOCK_SAND_BREAK,
-    BLOCK_SAND_FALL,
-    BLOCK_SAND_HIT,
-    BLOCK_SAND_PLACE,
-    BLOCK_SAND_STEP,
-    BLOCK_SLIME_BREAK,
-    BLOCK_SLIME_FALL,
-    BLOCK_SLIME_HIT,
-    BLOCK_SLIME_PLACE,
-    BLOCK_SLIME_STEP,
-    BLOCK_SNOW_BREAK,
-    BLOCK_SNOW_FALL,
-    BLOCK_SNOW_HIT,
-    BLOCK_SNOW_PLACE,
-    BLOCK_SNOW_STEP,
-    BLOCK_STONE_BREAK,
-    BLOCK_STONE_BUTTON_CLICK_OFF,
-    BLOCK_STONE_BUTTON_CLICK_ON,
-    BLOCK_STONE_FALL,
-    BLOCK_STONE_HIT,
-    BLOCK_STONE_PLACE,
-    BLOCK_STONE_PRESSUREPLATE_CLICK_OFF,
-    BLOCK_STONE_PRESSUREPLATE_CLICK_ON,
-    BLOCK_STONE_STEP,
-    BLOCK_TRIPWIRE_ATTACH,
-    BLOCK_TRIPWIRE_CLICK_OFF,
-    BLOCK_TRIPWIRE_CLICK_ON,
-    BLOCK_TRIPWIRE_DETACH,
-    BLOCK_WATERLILY_PLACE,
-    BLOCK_WATER_AMBIENT,
-    BLOCK_WOODEN_DOOR_CLOSE,
-    BLOCK_WOODEN_DOOR_OPEN,
-    BLOCK_WOODEN_TRAPDOOR_CLOSE,
-    BLOCK_WOODEN_TRAPDOOR_OPEN,
-    BLOCK_WOOD_BREAK,
-    BLOCK_WOOD_BUTTON_CLICK_OFF,
-    BLOCK_WOOD_BUTTON_CLICK_ON,
-    BLOCK_WOOD_FALL,
-    BLOCK_WOOD_HIT,
-    BLOCK_WOOD_PLACE,
-    BLOCK_WOOD_PRESSUREPLATE_CLICK_OFF,
-    BLOCK_WOOD_PRESSUREPLATE_CLICK_ON,
-    BLOCK_WOOD_STEP,
-    ENCHANT_THORNS_HIT,
-    ENTITY_ARMORSTAND_BREAK,
-    ENTITY_ARMORSTAND_FALL,
-    ENTITY_ARMORSTAND_HIT,
-    ENTITY_ARMORSTAND_PLACE,
-    ENTITY_ARROW_HIT,
-    ENTITY_ARROW_HIT_PLAYER,
-    ENTITY_ARROW_SHOOT,
-    ENTITY_BAT_AMBIENT,
-    ENTITY_BAT_DEATH,
-    ENTITY_BAT_HURT,
-    ENTITY_BAT_LOOP,
-    ENTITY_BAT_TAKEOFF,
-    ENTITY_BLAZE_AMBIENT,
-    ENTITY_BLAZE_BURN,
-    ENTITY_BLAZE_DEATH,
-    ENTITY_BLAZE_HURT,
-    ENTITY_BLAZE_SHOOT,
-    ENTITY_BOBBER_SPLASH,
-    ENTITY_BOBBER_THROW,
-    ENTITY_CAT_AMBIENT,
-    ENTITY_CAT_DEATH,
-    ENTITY_CAT_HISS,
-    ENTITY_CAT_HURT,
-    ENTITY_CAT_PURR,
-    ENTITY_CAT_PURREOW,
-    ENTITY_CHICKEN_AMBIENT,
-    ENTITY_CHICKEN_DEATH,
-    ENTITY_CHICKEN_EGG,
-    ENTITY_CHICKEN_HURT,
-    ENTITY_CHICKEN_STEP,
-    ENTITY_COW_AMBIENT,
-    ENTITY_COW_DEATH,
-    ENTITY_COW_HURT,
-    ENTITY_COW_MILK,
-    ENTITY_COW_STEP,
-    ENTITY_CREEPER_DEATH,
-    ENTITY_CREEPER_HURT,
-    ENTITY_CREEPER_PRIMED,
-    ENTITY_DONKEY_AMBIENT,
-    ENTITY_DONKEY_ANGRY,
-    ENTITY_DONKEY_CHEST,
-    ENTITY_DONKEY_DEATH,
-    ENTITY_DONKEY_HURT,
-    ENTITY_EGG_THROW,
-    ENTITY_ELDER_GUARDIAN_AMBIENT,
-    ENTITY_ELDER_GUARDIAN_AMBIENT_LAND,
-    ENTITY_ELDER_GUARDIAN_CURSE,
-    ENTITY_ELDER_GUARDIAN_DEATH,
-    ENTITY_ELDER_GUARDIAN_DEATH_LAND,
-    ENTITY_ELDER_GUARDIAN_HURT,
-    ENTITY_ELDER_GUARDIAN_HURT_LAND,
-    ENTITY_ENDERDRAGON_AMBIENT,
-    ENTITY_ENDERDRAGON_DEATH,
-    ENTITY_ENDERDRAGON_FIREBALL_EXPLODE,
-    ENTITY_ENDERDRAGON_FLAP,
-    ENTITY_ENDERDRAGON_GROWL,
-    ENTITY_ENDERDRAGON_HURT,
-    ENTITY_ENDERDRAGON_SHOOT,
-    ENTITY_ENDEREYE_LAUNCH,
-    ENTITY_ENDERMEN_AMBIENT,
-    ENTITY_ENDERMEN_DEATH,
-    ENTITY_ENDERMEN_HURT,
-    ENTITY_ENDERMEN_SCREAM,
-    ENTITY_ENDERMEN_STARE,
-    ENTITY_ENDERMEN_TELEPORT,
-    ENTITY_ENDERMITE_AMBIENT,
-    ENTITY_ENDERMITE_DEATH,
-    ENTITY_ENDERMITE_HURT,
-    ENTITY_ENDERMITE_STEP,
-    ENTITY_ENDERPEARL_THROW,
-    ENTITY_EXPERIENCE_BOTTLE_THROW,
-    ENTITY_EXPERIENCE_ORB_PICKUP,
-    ENTITY_EXPERIENCE_ORB_TOUCH,
-    ENTITY_FIREWORK_BLAST,
-    ENTITY_FIREWORK_BLAST_FAR,
-    ENTITY_FIREWORK_LARGE_BLAST,
-    ENTITY_FIREWORK_LARGE_BLAST_FAR,
-    ENTITY_FIREWORK_LAUNCH,
-    ENTITY_FIREWORK_SHOOT,
-    ENTITY_FIREWORK_TWINKLE,
-    ENTITY_FIREWORK_TWINKLE_FAR,
-    ENTITY_GENERIC_BIG_FALL,
-    ENTITY_GENERIC_BURN,
-    ENTITY_GENERIC_DEATH,
-    ENTITY_GENERIC_DRINK,
-    ENTITY_GENERIC_EAT,
-    ENTITY_GENERIC_EXPLODE,
-    ENTITY_GENERIC_EXTINGUISH_FIRE,
-    ENTITY_GENERIC_HURT,
-    ENTITY_GENERIC_SMALL_FALL,
-    ENTITY_GENERIC_SPLASH,
-    ENTITY_GENERIC_SWIM,
-    ENTITY_GHAST_AMBIENT,
-    ENTITY_GHAST_DEATH,
-    ENTITY_GHAST_HURT,
-    ENTITY_GHAST_SCREAM,
-    ENTITY_GHAST_SHOOT,
-    ENTITY_GHAST_WARN,
-    ENTITY_GUARDIAN_AMBIENT,
-    ENTITY_GUARDIAN_AMBIENT_LAND,
-    ENTITY_GUARDIAN_ATTACK,
-    ENTITY_GUARDIAN_DEATH,
-    ENTITY_GUARDIAN_DEATH_LAND,
-    ENTITY_GUARDIAN_FLOP,
-    ENTITY_GUARDIAN_HURT,
-    ENTITY_GUARDIAN_HURT_LAND,
-    ENTITY_HORSE_AMBIENT,
-    ENTITY_HORSE_ANGRY,
-    ENTITY_HORSE_ARMOR,
-    ENTITY_HORSE_BREATHE,
-    ENTITY_HORSE_DEATH,
-    ENTITY_HORSE_EAT,
-    ENTITY_HORSE_GALLOP,
-    ENTITY_HORSE_HURT,
-    ENTITY_HORSE_JUMP,
-    ENTITY_HORSE_LAND,
-    ENTITY_HORSE_SADDLE,
-    ENTITY_HORSE_STEP,
-    ENTITY_HORSE_STEP_WOOD,
-    ENTITY_HOSTILE_BIG_FALL,
-    ENTITY_HOSTILE_DEATH,
-    ENTITY_HOSTILE_HURT,
-    ENTITY_HOSTILE_SMALL_FALL,
-    ENTITY_HOSTILE_SPLASH,
-    ENTITY_HOSTILE_SWIM,
-    ENTITY_IRONGOLEM_ATTACK,
-    ENTITY_IRONGOLEM_DEATH,
-    ENTITY_IRONGOLEM_HURT,
-    ENTITY_IRONGOLEM_STEP,
-    ENTITY_ITEMFRAME_ADD_ITEM,
-    ENTITY_ITEMFRAME_BREAK,
-    ENTITY_ITEMFRAME_PLACE,
-    ENTITY_ITEMFRAME_REMOVE_ITEM,
-    ENTITY_ITEMFRAME_ROTATE_ITEM,
-    ENTITY_ITEM_BREAK,
-    ENTITY_ITEM_PICKUP,
-    ENTITY_LEASHKNOT_BREAK,
-    ENTITY_LEASHKNOT_PLACE,
-    ENTITY_LIGHTNING_IMPACT,
-    ENTITY_LIGHTNING_THUNDER,
-    ENTITY_LINGERINGPOTION_THROW,
-    ENTITY_MAGMACUBE_DEATH,
-    ENTITY_MAGMACUBE_HURT,
-    ENTITY_MAGMACUBE_JUMP,
-    ENTITY_MAGMACUBE_SQUISH,
-    ENTITY_MINECART_INSIDE,
-    ENTITY_MINECART_RIDING,
-    ENTITY_MOOSHROOM_SHEAR,
-    ENTITY_MULE_AMBIENT,
-    ENTITY_MULE_DEATH,
-    ENTITY_MULE_HURT,
-    ENTITY_PAINTING_BREAK,
-    ENTITY_PAINTING_PLACE,
-    ENTITY_PIG_AMBIENT,
-    ENTITY_PIG_DEATH,
-    ENTITY_PIG_HURT,
-    ENTITY_PIG_SADDLE,
-    ENTITY_PIG_STEP,
-    ENTITY_PLAYER_ATTACK_CRIT,
-    ENTITY_PLAYER_ATTACK_KNOCKBACK,
-    ENTITY_PLAYER_ATTACK_NODAMAGE,
-    ENTITY_PLAYER_ATTACK_STRONG,
-    ENTITY_PLAYER_ATTACK_SWEEP,
-    ENTITY_PLAYER_ATTACK_WEAK,
-    ENTITY_PLAYER_BIG_FALL,
-    ENTITY_PLAYER_BREATH,
-    ENTITY_PLAYER_BURP,
-    ENTITY_PLAYER_DEATH,
-    ENTITY_PLAYER_HURT,
-    ENTITY_PLAYER_LEVELUP,
-    ENTITY_PLAYER_SMALL_FALL,
-    ENTITY_PLAYER_SPLASH,
-    ENTITY_PLAYER_SWIM,
-    ENTITY_RABBIT_AMBIENT,
-    ENTITY_RABBIT_ATTACK,
-    ENTITY_RABBIT_DEATH,
-    ENTITY_RABBIT_HURT,
-    ENTITY_RABBIT_JUMP,
-    ENTITY_SHEEP_AMBIENT,
-    ENTITY_SHEEP_DEATH,
-    ENTITY_SHEEP_HURT,
-    ENTITY_SHEEP_SHEAR,
-    ENTITY_SHEEP_STEP,
-    ENTITY_SHULKER_AMBIENT,
-    ENTITY_SHULKER_BULLET_HIT,
-    ENTITY_SHULKER_BULLET_HURT,
-    ENTITY_SHULKER_CLOSE,
-    ENTITY_SHULKER_DEATH,
-    ENTITY_SHULKER_HURT,
-    ENTITY_SHULKER_HURT_CLOSED,
-    ENTITY_SHULKER_OPEN,
-    ENTITY_SHULKER_SHOOT,
-    ENTITY_SHULKER_TELEPORT,
-    ENTITY_SILVERFISH_AMBIENT,
-    ENTITY_SILVERFISH_DEATH,
-    ENTITY_SILVERFISH_HURT,
-    ENTITY_SILVERFISH_STEP,
-    ENTITY_SKELETON_AMBIENT,
-    ENTITY_SKELETON_DEATH,
-    ENTITY_SKELETON_HORSE_AMBIENT,
-    ENTITY_SKELETON_HORSE_DEATH,
-    ENTITY_SKELETON_HORSE_HURT,
-    ENTITY_SKELETON_HURT,
-    ENTITY_SKELETON_SHOOT,
-    ENTITY_SKELETON_STEP,
-    ENTITY_SLIME_ATTACK,
-    ENTITY_SLIME_DEATH,
-    ENTITY_SLIME_HURT,
-    ENTITY_SLIME_JUMP,
-    ENTITY_SLIME_SQUISH,
-    ENTITY_SMALL_MAGMACUBE_DEATH,
-    ENTITY_SMALL_MAGMACUBE_HURT,
-    ENTITY_SMALL_MAGMACUBE_SQUISH,
-    ENTITY_SMALL_SLIME_DEATH,
-    ENTITY_SMALL_SLIME_HURT,
-    ENTITY_SMALL_SLIME_JUMP,
-    ENTITY_SMALL_SLIME_SQUISH,
-    ENTITY_SNOWBALL_THROW,
-    ENTITY_SNOWMAN_AMBIENT,
-    ENTITY_SNOWMAN_DEATH,
-    ENTITY_SNOWMAN_HURT,
-    ENTITY_SNOWMAN_SHOOT,
-    ENTITY_SPIDER_AMBIENT,
-    ENTITY_SPIDER_DEATH,
-    ENTITY_SPIDER_HURT,
-    ENTITY_SPIDER_STEP,
-    ENTITY_SPLASH_POTION_BREAK,
-    ENTITY_SPLASH_POTION_THROW,
-    ENTITY_SQUID_AMBIENT,
-    ENTITY_SQUID_DEATH,
-    ENTITY_SQUID_HURT,
-    ENTITY_TNT_PRIMED,
-    ENTITY_VILLAGER_AMBIENT,
-    ENTITY_VILLAGER_DEATH,
-    ENTITY_VILLAGER_HURT,
-    ENTITY_VILLAGER_NO,
-    ENTITY_VILLAGER_TRADING,
-    ENTITY_VILLAGER_YES,
-    ENTITY_WITCH_AMBIENT,
-    ENTITY_WITCH_DEATH,
-    ENTITY_WITCH_DRINK,
-    ENTITY_WITCH_HURT,
-    ENTITY_WITCH_THROW,
-    ENTITY_WITHER_AMBIENT,
-    ENTITY_WITHER_BREAK_BLOCK,
-    ENTITY_WITHER_DEATH,
-    ENTITY_WITHER_HURT,
-    ENTITY_WITHER_SHOOT,
-    ENTITY_WITHER_SPAWN,
-    ENTITY_WOLF_AMBIENT,
-    ENTITY_WOLF_DEATH,
-    ENTITY_WOLF_GROWL,
-    ENTITY_WOLF_HOWL,
-    ENTITY_WOLF_HURT,
-    ENTITY_WOLF_PANT,
-    ENTITY_WOLF_SHAKE,
-    ENTITY_WOLF_STEP,
-    ENTITY_WOLF_WHINE,
-    ENTITY_ZOMBIE_AMBIENT,
-    ENTITY_ZOMBIE_ATTACK_DOOR_WOOD,
-    ENTITY_ZOMBIE_ATTACK_IRON_DOOR,
-    ENTITY_ZOMBIE_BREAK_DOOR_WOOD,
-    ENTITY_ZOMBIE_DEATH,
-    ENTITY_ZOMBIE_HORSE_AMBIENT,
-    ENTITY_ZOMBIE_HORSE_DEATH,
-    ENTITY_ZOMBIE_HORSE_HURT,
-    ENTITY_ZOMBIE_HURT,
-    ENTITY_ZOMBIE_INFECT,
-    ENTITY_ZOMBIE_PIG_AMBIENT,
-    ENTITY_ZOMBIE_PIG_ANGRY,
-    ENTITY_ZOMBIE_PIG_DEATH,
-    ENTITY_ZOMBIE_PIG_HURT,
-    ENTITY_ZOMBIE_STEP,
-    ENTITY_ZOMBIE_VILLAGER_AMBIENT,
-    ENTITY_ZOMBIE_VILLAGER_CONVERTED,
-    ENTITY_ZOMBIE_VILLAGER_CURE,
-    ENTITY_ZOMBIE_VILLAGER_DEATH,
-    ENTITY_ZOMBIE_VILLAGER_HURT,
-    ENTITY_ZOMBIE_VILLAGER_STEP,
-    ITEM_ARMOR_EQUIP_CHAIN,
-    ITEM_ARMOR_EQUIP_DIAMOND,
-    ITEM_ARMOR_EQUIP_GENERIC,
-    ITEM_ARMOR_EQUIP_GOLD,
-    ITEM_ARMOR_EQUIP_IRON,
-    ITEM_ARMOR_EQUIP_LEATHER,
-    ITEM_BOTTLE_FILL,
-    ITEM_BOTTLE_FILL_DRAGONBREATH,
-    ITEM_BUCKET_EMPTY,
-    ITEM_BUCKET_EMPTY_LAVA,
-    ITEM_BUCKET_FILL,
-    ITEM_BUCKET_FILL_LAVA,
-    ITEM_CHORUS_FRUIT_TELEPORT,
-    ITEM_ELYTRA_FLYING,
-    ITEM_FIRECHARGE_USE,
-    ITEM_FLINTANDSTEEL_USE,
-    ITEM_HOE_TILL,
-    ITEM_SHIELD_BLOCK,
-    ITEM_SHIELD_BREAK,
-    ITEM_SHOVEL_FLATTEN,
-    MUSIC_CREATIVE,
-    MUSIC_CREDITS,
-    MUSIC_DRAGON,
-    MUSIC_END,
-    MUSIC_GAME,
-    MUSIC_MENU,
-    MUSIC_NETHER,
-    RECORD_11,
-    RECORD_13,
-    RECORD_BLOCKS,
-    RECORD_CAT,
-    RECORD_CHIRP,
-    RECORD_FAR,
-    RECORD_MALL,
-    RECORD_MELLOHI,
-    RECORD_STAL,
-    RECORD_STRAD,
-    RECORD_WAIT,
-    RECORD_WARD,
-    UI_BUTTON_CLICK,
-    WEATHER_RAIN,
-    WEATHER_RAIN_ABOVE,
-}
diff --git a/src/main/java/org/bukkit/Statistic.java b/src/main/java/org/bukkit/Statistic.java
deleted file mode 100644
index 3f0ec9f..0000000
--- a/src/main/java/org/bukkit/Statistic.java
+++ /dev/null
@@ -1,137 +0,0 @@
-package org.bukkit;
-
-/**
- * Represents a countable statistic, which is tracked by the server.
- */
-public enum Statistic {
-    DAMAGE_DEALT,
-    DAMAGE_TAKEN,
-    DEATHS,
-    MOB_KILLS,
-    PLAYER_KILLS,
-    FISH_CAUGHT,
-    ANIMALS_BRED,
-    TREASURE_FISHED,
-    JUNK_FISHED,
-    LEAVE_GAME,
-    JUMP,
-    DROP(Type.ITEM),
-    PICKUP(Type.ITEM),
-    PLAY_ONE_TICK,
-    WALK_ONE_CM,
-    SWIM_ONE_CM,
-    FALL_ONE_CM,
-    SNEAK_TIME,
-    CLIMB_ONE_CM,
-    FLY_ONE_CM,
-    DIVE_ONE_CM,
-    MINECART_ONE_CM,
-    BOAT_ONE_CM,
-    PIG_ONE_CM,
-    HORSE_ONE_CM,
-    SPRINT_ONE_CM,
-    CROUCH_ONE_CM,
-    AVIATE_ONE_CM,
-    MINE_BLOCK(Type.BLOCK),
-    USE_ITEM(Type.ITEM),
-    BREAK_ITEM(Type.ITEM),
-    CRAFT_ITEM(Type.ITEM),
-    KILL_ENTITY(Type.ENTITY),
-    ENTITY_KILLED_BY(Type.ENTITY),
-    TIME_SINCE_DEATH,
-    TALKED_TO_VILLAGER,
-    TRADED_WITH_VILLAGER,
-    CAKE_SLICES_EATEN,
-    CAULDRON_FILLED,
-    CAULDRON_USED,
-    ARMOR_CLEANED,
-    BANNER_CLEANED,
-    BREWINGSTAND_INTERACTION,
-    BEACON_INTERACTION,
-    DROPPER_INSPECTED,
-    HOPPER_INSPECTED,
-    DISPENSER_INSPECTED,
-    NOTEBLOCK_PLAYED,
-    NOTEBLOCK_TUNED,
-    FLOWER_POTTED,
-    TRAPPED_CHEST_TRIGGERED,
-    ENDERCHEST_OPENED,
-    ITEM_ENCHANTED,
-    RECORD_PLAYED,
-    FURNACE_INTERACTION,
-    CRAFTING_TABLE_INTERACTION,
-    CHEST_OPENED,
-    SLEEP_IN_BED;
-
-    private final Type type;
-
-    private Statistic() {
-        this(Type.UNTYPED);
-    }
-
-    private Statistic(Type type) {
-        this.type = type;
-    }
-
-    /**
-     * Gets the type of this statistic.
-     *
-     * @return the type of this statistic
-     */
-    public Type getType() {
-        return type;
-    }
-
-    /**
-     * Checks if this is a substatistic.
-     * <p>
-     * A substatistic exists en masse for each block, item, or entitytype, depending on
-     * {@link #getType()}.
-     * <p>
-     * This is a redundant method and equivalent to checking
-     * <code>getType() != Type.UNTYPED</code>
-     *
-     * @return true if this is a substatistic
-     */
-    public boolean isSubstatistic() {
-        return type != Type.UNTYPED;
-    }
-
-    /**
-     * Checks if this is a substatistic dealing with blocks.
-     * <p>
-     * This is a redundant method and equivalent to checking
-     * <code>getType() == Type.BLOCK</code>
-     *
-     * @return true if this deals with blocks
-     */
-    public boolean isBlock() {
-        return type == Type.BLOCK;
-    }
-
-    /**
-     * The type of statistic.
-     *
-     */
-    public enum Type {
-        /**
-         * Statistics of this type do not require a qualifier.
-         */
-        UNTYPED,
-
-        /**
-         * Statistics of this type require an Item Material qualifier.
-         */
-        ITEM,
-
-        /**
-         * Statistics of this type require a Block Material qualifier.
-         */
-        BLOCK,
-
-        /**
-         * Statistics of this type require an EntityType qualifier.
-         */
-        ENTITY;
-    }
-}
diff --git a/src/main/java/org/bukkit/TravelAgent.java b/src/main/java/org/bukkit/TravelAgent.java
deleted file mode 100644
index 2dfeffa..0000000
--- a/src/main/java/org/bukkit/TravelAgent.java
+++ /dev/null
@@ -1,94 +0,0 @@
-package org.bukkit;
-
-/**
- * The Travel Agent handles the creation and the research of Nether and End
- * portals when Entities try to use one.
- * <p>
- * It is used in {@link org.bukkit.event.entity.EntityPortalEvent} and in
- * {@link org.bukkit.event.player.PlayerPortalEvent} to help developers
- * reproduce and/or modify Vanilla behaviour.
- */
-public interface TravelAgent {
-
-    /**
-     * Set the Block radius to search in for available portals.
-     *
-     * @param radius the radius in which to search for a portal from the
-     *     location
-     * @return this travel agent
-     */
-    public TravelAgent setSearchRadius(int radius);
-
-    /**
-     * Gets the search radius value for finding an available portal.
-     *
-     * @return the currently set search radius
-     */
-    public int getSearchRadius();
-
-    /**
-     * Sets the maximum radius from the given location to create a portal.
-     *
-     * @param radius the radius in which to create a portal from the location
-     * @return this travel agent
-     */
-    public TravelAgent setCreationRadius(int radius);
-
-    /**
-     * Gets the maximum radius from the given location to create a portal.
-     *
-     * @return the currently set creation radius
-     */
-    public int getCreationRadius();
-
-    /**
-     * Returns whether the TravelAgent will attempt to create a destination
-     * portal or not.
-     *
-     * @return whether the TravelAgent should create a destination portal or
-     *     not
-     */
-    public boolean getCanCreatePortal();
-
-    /**
-     * Sets whether the TravelAgent should attempt to create a destination
-     * portal or not.
-     *
-     * @param create Sets whether the TravelAgent should create a destination
-     *     portal or not
-     */
-    public void setCanCreatePortal(boolean create);
-
-    /**
-     * Attempt to find a portal near the given location, if a portal is not
-     * found it will attempt to create one.
-     *
-     * @param location the location where the search for a portal should begin
-     * @return the location of a portal which has been found or returns the
-     *     location passed to the method if unsuccessful
-     * @see #createPortal(Location)
-     */
-    public Location findOrCreate(Location location);
-
-    /**
-     * Attempt to find a portal near the given location.
-     *
-     * @param location the desired location of the portal
-     * @return the location of the nearest portal to the location
-     */
-    public Location findPortal(Location location);
-
-    /**
-     * Attempt to create a portal near the given location.
-     * <p>
-     * In the case of a Nether portal teleportation, this will attempt to
-     * create a Nether portal.
-     * <p>
-     * In the case of an Ender portal teleportation, this will (re-)create the
-     * obsidian platform and clean blocks above it.
-     *
-     * @param location the desired location of the portal
-     * @return true if a portal was successfully created
-     */
-    public boolean createPortal(Location location);
-}
diff --git a/src/main/java/org/bukkit/TreeSpecies.java b/src/main/java/org/bukkit/TreeSpecies.java
deleted file mode 100644
index f29062a..0000000
--- a/src/main/java/org/bukkit/TreeSpecies.java
+++ /dev/null
@@ -1,74 +0,0 @@
-package org.bukkit;
-
-import java.util.Map;
-
-import com.google.common.collect.Maps;
-
-/**
- * Represents the different species of trees regardless of size.
- */
-public enum TreeSpecies {
-
-    /**
-     * Represents the common tree species.
-     */
-    GENERIC(0x0),
-    /**
-     * Represents the darker barked/leaved tree species.
-     */
-    REDWOOD(0x1),
-    /**
-     * Represents birches.
-     */
-    BIRCH(0x2),
-    /**
-     * Represents jungle trees.
-     */
-    JUNGLE(0x3),
-    /**
-     * Represents acacia trees.
-     */
-    ACACIA(0x4),
-    /**
-     * Represents dark oak trees.
-     */
-    DARK_OAK(0x5),
-    ;
-
-    private final byte data;
-    private final static Map<Byte, TreeSpecies> BY_DATA = Maps.newHashMap();
-
-    private TreeSpecies(final int data) {
-        this.data = (byte) data;
-    }
-
-    /**
-     * Gets the associated data value representing this species
-     *
-     * @return A byte containing the data value of this tree species
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public byte getData() {
-        return data;
-    }
-
-    /**
-     * Gets the TreeSpecies with the given data value
-     *
-     * @param data Data value to fetch
-     * @return The {@link TreeSpecies} representing the given value, or null
-     *     if it doesn't exist
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public static TreeSpecies getByData(final byte data) {
-        return BY_DATA.get(data);
-    }
-
-    static {
-        for (TreeSpecies species : values()) {
-            BY_DATA.put(species.data, species);
-        }
-    }
-}
diff --git a/src/main/java/org/bukkit/TreeType.java b/src/main/java/org/bukkit/TreeType.java
deleted file mode 100644
index dba084f..0000000
--- a/src/main/java/org/bukkit/TreeType.java
+++ /dev/null
@@ -1,76 +0,0 @@
-package org.bukkit;
-
-/**
- * Tree and organic structure types.
- */
-public enum TreeType {
-
-    /**
-     * Regular tree, no branches
-     */
-    TREE,
-    /**
-     * Regular tree, extra tall with branches
-     */
-    BIG_TREE,
-    /**
-     * Redwood tree, shaped like a pine tree
-     */
-    REDWOOD,
-    /**
-     * Tall redwood tree with just a few leaves at the top
-     */
-    TALL_REDWOOD,
-    /**
-     * Birch tree
-     */
-    BIRCH,
-    /**
-     * Standard jungle tree; 4 blocks wide and tall
-     */
-    JUNGLE,
-    /**
-     * Smaller jungle tree; 1 block wide
-     */
-    SMALL_JUNGLE,
-    /**
-     * Jungle tree with cocoa plants; 1 block wide
-     */
-    COCOA_TREE,
-    /**
-     * Small bush that grows in the jungle
-     */
-    JUNGLE_BUSH,
-    /**
-     * Big red mushroom; short and fat
-     */
-    RED_MUSHROOM,
-    /**
-     * Big brown mushroom; tall and umbrella-like
-     */
-    BROWN_MUSHROOM,
-    /**
-     * Swamp tree (regular with vines on the side)
-     */
-    SWAMP,
-    /**
-     * Acacia tree.
-     */
-    ACACIA,
-    /**
-     * Dark Oak tree.
-     */
-    DARK_OAK,
-    /**
-     * Mega redwood tree; 4 blocks wide and tall
-     */
-    MEGA_REDWOOD,
-    /**
-     * Tall birch tree
-     */
-    TALL_BIRCH,
-    /**
-     * Large plant native to The End
-     */
-    CHORUS_PLANT,
-}
diff --git a/src/main/java/org/bukkit/UnsafeValues.java b/src/main/java/org/bukkit/UnsafeValues.java
deleted file mode 100644
index 568c83e..0000000
--- a/src/main/java/org/bukkit/UnsafeValues.java
+++ /dev/null
@@ -1,33 +0,0 @@
-package org.bukkit;
-
-import java.util.List;
-
-import org.bukkit.inventory.ItemStack;
-
-/**
- * This interface provides value conversions that may be specific to a
- * runtime, or have arbitrary meaning (read: magic values).
- * <p>
- * Their existence and behavior is not guaranteed across future versions. They
- * may be poorly named, throw exceptions, have misleading parameters, or any
- * other bad programming practice.
- * <p>
- * This interface is unsupported and only for internal use.
- *
- * @deprecated Unsupported {@literal &} internal use only
- */
-@Deprecated
-public interface UnsafeValues {
-
-    Material getMaterialFromInternalName(String name);
-
-    List<String> tabCompleteInternalMaterialName(String token, List<String> completions);
-
-    ItemStack modifyItemStack(ItemStack stack, String arguments);
-
-    Statistic getStatisticFromInternalName(String name);
-
-    Achievement getAchievementFromInternalName(String name);
-
-    List<String> tabCompleteInternalStatisticOrAchievementName(String token, List<String> completions);
-}
diff --git a/src/main/java/org/bukkit/Utility.java b/src/main/java/org/bukkit/Utility.java
deleted file mode 100644
index da66853..0000000
--- a/src/main/java/org/bukkit/Utility.java
+++ /dev/null
@@ -1,18 +0,0 @@
-package org.bukkit;
-
-import java.lang.annotation.ElementType;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.lang.annotation.Target;
-
-/**
- * This annotation indicates a method (and sometimes constructor) will chain
- * its internal operations.
- * <p>
- * This is solely meant for identifying methods that don't need to be
- * overridden / handled manually.
- */
-@Target({ElementType.CONSTRUCTOR, ElementType.METHOD})
-@Retention(RetentionPolicy.SOURCE)
-public @interface Utility {
-}
diff --git a/src/main/java/org/bukkit/Warning.java b/src/main/java/org/bukkit/Warning.java
deleted file mode 100644
index 6a2a3b0..0000000
--- a/src/main/java/org/bukkit/Warning.java
+++ /dev/null
@@ -1,109 +0,0 @@
-package org.bukkit;
-
-import java.lang.annotation.ElementType;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.lang.annotation.Target;
-import java.util.Map;
-
-import com.google.common.collect.ImmutableMap;
-
-/**
- * This designates the warning state for a specific item.
- * <p>
- * When the server settings dictate 'default' warnings, warnings are printed
- * if the {@link #value()} is true.
- */
-@Target({ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.TYPE})
-@Retention(RetentionPolicy.RUNTIME)
-public @interface Warning {
-
-    /**
-     * This represents the states that server verbose for warnings may be.
-     */
-    public enum WarningState {
-
-        /**
-         * Indicates all warnings should be printed for deprecated items.
-         */
-        ON,
-        /**
-         * Indicates no warnings should be printed for deprecated items.
-         */
-        OFF,
-        /**
-         * Indicates each warning would default to the configured {@link
-         * Warning} annotation, or always if annotation not found.
-         */
-        DEFAULT;
-
-        private static final Map<String, WarningState> values = ImmutableMap.<String,WarningState>builder()
-                .put("off", OFF)
-                .put("false", OFF)
-                .put("f", OFF)
-                .put("no", OFF)
-                .put("n", OFF)
-                .put("on", ON)
-                .put("true", ON)
-                .put("t", ON)
-                .put("yes", ON)
-                .put("y", ON)
-                .put("", DEFAULT)
-                .put("d", DEFAULT)
-                .put("default", DEFAULT)
-                .build();
-
-        /**
-         * This method checks the provided warning should be printed for this
-         * state
-         *
-         * @param warning The warning annotation added to a deprecated item
-         * @return <ul>
-         *     <li>ON is always True
-         *     <li>OFF is always false
-         *     <li>DEFAULT is false if and only if annotation is not null and
-         *     specifies false for {@link Warning#value()}, true otherwise.
-         *     </ul>
-         */
-        public boolean printFor(Warning warning) {
-            if (this == DEFAULT) {
-                return warning == null || warning.value();
-            }
-            return this == ON;
-        }
-
-        /**
-         * This method returns the corresponding warning state for the given
-         * string value.
-         *
-         * @param value The string value to check
-         * @return {@link #DEFAULT} if not found, or the respective
-         *     WarningState
-         */
-        public static WarningState value(final String value) {
-            if (value == null) {
-                return DEFAULT;
-            }
-            WarningState state = values.get(value.toLowerCase());
-            if (state == null) {
-                return DEFAULT;
-            }
-            return state;
-        }
-    }
-
-    /**
-     * This sets if the deprecation warnings when registering events gets
-     * printed when the setting is in the default state.
-     *
-     * @return false normally, or true to encourage warning printout
-     */
-    boolean value() default false;
-
-    /**
-     * This can provide detailed information on why the event is deprecated.
-     *
-     * @return The reason an event is deprecated
-     */
-    String reason() default "";
-}
diff --git a/src/main/java/org/bukkit/WeatherType.java b/src/main/java/org/bukkit/WeatherType.java
deleted file mode 100644
index 36b993f..0000000
--- a/src/main/java/org/bukkit/WeatherType.java
+++ /dev/null
@@ -1,17 +0,0 @@
-package org.bukkit;
-
-/**
- * An enum of all current weather types
- */
-public enum WeatherType {
-
-    /**
-     * Raining or snowing depending on biome.
-     */
-    DOWNFALL,
-    /**
-     * Clear weather, clouds but no rain.
-     */
-    CLEAR,
-    ;
-}
diff --git a/src/main/java/org/bukkit/World.java b/src/main/java/org/bukkit/World.java
deleted file mode 100644
index 9d71de4..0000000
--- a/src/main/java/org/bukkit/World.java
+++ /dev/null
@@ -1,1447 +0,0 @@
-package org.bukkit;
-
-import java.io.File;
-import org.bukkit.generator.ChunkGenerator;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.UUID;
-
-import org.bukkit.block.Biome;
-import org.bukkit.block.Block;
-import org.bukkit.entity.*;
-import org.bukkit.generator.BlockPopulator;
-import org.bukkit.inventory.ItemStack;
-import org.bukkit.metadata.Metadatable;
-import org.bukkit.plugin.messaging.PluginMessageRecipient;
-import org.bukkit.util.Vector;
-
-/**
- * Represents a world, which may contain entities, chunks and blocks
- */
-public interface World extends PluginMessageRecipient, Metadatable {
-
-    /**
-     * Gets the {@link Block} at the given coordinates
-     *
-     * @param x X-coordinate of the block
-     * @param y Y-coordinate of the block
-     * @param z Z-coordinate of the block
-     * @return Block at the given coordinates
-     * @see #getBlockTypeIdAt(int, int, int) Returns the current type ID of
-     *     the block
-     */
-    public Block getBlockAt(int x, int y, int z);
-
-    /**
-     * Gets the {@link Block} at the given {@link Location}
-     *
-     * @param location Location of the block
-     * @return Block at the given location
-     * @see #getBlockTypeIdAt(org.bukkit.Location) Returns the current type ID
-     *     of the block
-     */
-    public Block getBlockAt(Location location);
-
-    /**
-     * Gets the block type ID at the given coordinates
-     *
-     * @param x X-coordinate of the block
-     * @param y Y-coordinate of the block
-     * @param z Z-coordinate of the block
-     * @return Type ID of the block at the given coordinates
-     * @see #getBlockAt(int, int, int) Returns a live Block object at the
-     *     given location
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public int getBlockTypeIdAt(int x, int y, int z);
-
-    /**
-     * Gets the block type ID at the given {@link Location}
-     *
-     * @param location Location of the block
-     * @return Type ID of the block at the given location
-     * @see #getBlockAt(org.bukkit.Location) Returns a live Block object at
-     *     the given location
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public int getBlockTypeIdAt(Location location);
-
-    /**
-     * Gets the highest non-air coordinate at the given coordinates
-     *
-     * @param x X-coordinate of the blocks
-     * @param z Z-coordinate of the blocks
-     * @return Y-coordinate of the highest non-air block
-     */
-    public int getHighestBlockYAt(int x, int z);
-
-    /**
-     * Gets the highest non-air coordinate at the given {@link Location}
-     *
-     * @param location Location of the blocks
-     * @return Y-coordinate of the highest non-air block
-     */
-    public int getHighestBlockYAt(Location location);
-
-    /**
-     * Gets the highest non-empty block at the given coordinates
-     *
-     * @param x X-coordinate of the block
-     * @param z Z-coordinate of the block
-     * @return Highest non-empty block
-     */
-    public Block getHighestBlockAt(int x, int z);
-
-    /**
-     * Gets the highest non-empty block at the given coordinates
-     *
-     * @param location Coordinates to get the highest block
-     * @return Highest non-empty block
-     */
-    public Block getHighestBlockAt(Location location);
-
-    /**
-     * Gets the {@link Chunk} at the given coordinates
-     *
-     * @param x X-coordinate of the chunk
-     * @param z Z-coordinate of the chunk
-     * @return Chunk at the given coordinates
-     */
-    public Chunk getChunkAt(int x, int z);
-
-    /**
-     * Gets the {@link Chunk} at the given {@link Location}
-     *
-     * @param location Location of the chunk
-     * @return Chunk at the given location
-     */
-    public Chunk getChunkAt(Location location);
-
-    /**
-     * Gets the {@link Chunk} that contains the given {@link Block}
-     *
-     * @param block Block to get the containing chunk from
-     * @return The chunk that contains the given block
-     */
-    public Chunk getChunkAt(Block block);
-
-    /**
-     * Checks if the specified {@link Chunk} is loaded
-     *
-     * @param chunk The chunk to check
-     * @return true if the chunk is loaded, otherwise false
-     */
-    public boolean isChunkLoaded(Chunk chunk);
-
-    /**
-     * Gets an array of all loaded {@link Chunk}s
-     *
-     * @return Chunk[] containing all loaded chunks
-     */
-    public Chunk[] getLoadedChunks();
-
-    /**
-     * Loads the specified {@link Chunk}
-     *
-     * @param chunk The chunk to load
-     */
-    public void loadChunk(Chunk chunk);
-
-    /**
-     * Checks if the {@link Chunk} at the specified coordinates is loaded
-     *
-     * @param x X-coordinate of the chunk
-     * @param z Z-coordinate of the chunk
-     * @return true if the chunk is loaded, otherwise false
-     */
-    public boolean isChunkLoaded(int x, int z);
-
-    /**
-     * Checks if the {@link Chunk} at the specified coordinates is loaded and
-     * in use by one or more players
-     *
-     * @param x X-coordinate of the chunk
-     * @param z Z-coordinate of the chunk
-     * @return true if the chunk is loaded and in use by one or more players,
-     *     otherwise false
-     */
-    public boolean isChunkInUse(int x, int z);
-
-    /**
-     * Loads the {@link Chunk} at the specified coordinates
-     * <p>
-     * If the chunk does not exist, it will be generated.
-     * <p>
-     * This method is analogous to {@link #loadChunk(int, int, boolean)} where
-     * generate is true.
-     *
-     * @param x X-coordinate of the chunk
-     * @param z Z-coordinate of the chunk
-     */
-    public void loadChunk(int x, int z);
-
-    /**
-     * Loads the {@link Chunk} at the specified coordinates
-     *
-     * @param x X-coordinate of the chunk
-     * @param z Z-coordinate of the chunk
-     * @param generate Whether or not to generate a chunk if it doesn't
-     *     already exist
-     * @return true if the chunk has loaded successfully, otherwise false
-     */
-    public boolean loadChunk(int x, int z, boolean generate);
-
-    /**
-     * Safely unloads and saves the {@link Chunk} at the specified coordinates
-     * <p>
-     * This method is analogous to {@link #unloadChunk(int, int, boolean,
-     * boolean)} where safe and saveis true
-     *
-     * @param chunk the chunk to unload
-     * @return true if the chunk has unloaded successfully, otherwise false
-     */
-    public boolean unloadChunk(Chunk chunk);
-
-    /**
-     * Safely unloads and saves the {@link Chunk} at the specified coordinates
-     * <p>
-     * This method is analogous to {@link #unloadChunk(int, int, boolean,
-     * boolean)} where safe and saveis true
-     *
-     * @param x X-coordinate of the chunk
-     * @param z Z-coordinate of the chunk
-     * @return true if the chunk has unloaded successfully, otherwise false
-     */
-    public boolean unloadChunk(int x, int z);
-
-    /**
-     * Safely unloads and optionally saves the {@link Chunk} at the specified
-     * coordinates
-     * <p>
-     * This method is analogous to {@link #unloadChunk(int, int, boolean,
-     * boolean)} where save is true
-     *
-     * @param x X-coordinate of the chunk
-     * @param z Z-coordinate of the chunk
-     * @param save Whether or not to save the chunk
-     * @return true if the chunk has unloaded successfully, otherwise false
-     */
-    public boolean unloadChunk(int x, int z, boolean save);
-
-    /**
-     * Unloads and optionally saves the {@link Chunk} at the specified
-     * coordinates
-     *
-     * @param x X-coordinate of the chunk
-     * @param z Z-coordinate of the chunk
-     * @param save Controls whether the chunk is saved
-     * @param safe Controls whether to unload the chunk when players are
-     *     nearby
-     * @return true if the chunk has unloaded successfully, otherwise false
-     * @deprecated it is never safe to remove a chunk in use
-     */
-    @Deprecated
-    public boolean unloadChunk(int x, int z, boolean save, boolean safe);
-
-    /**
-     * Safely queues the {@link Chunk} at the specified coordinates for
-     * unloading
-     * <p>
-     * This method is analogous to {@link #unloadChunkRequest(int, int,
-     * boolean)} where safe is true
-     *
-     * @param x X-coordinate of the chunk
-     * @param z Z-coordinate of the chunk
-     * @return true is the queue attempt was successful, otherwise false
-     */
-    public boolean unloadChunkRequest(int x, int z);
-
-    /**
-     * Queues the {@link Chunk} at the specified coordinates for unloading
-     *
-     * @param x X-coordinate of the chunk
-     * @param z Z-coordinate of the chunk
-     * @param safe Controls whether to queue the chunk when players are nearby
-     * @return Whether the chunk was actually queued
-     */
-    public boolean unloadChunkRequest(int x, int z, boolean safe);
-
-    /**
-     * Regenerates the {@link Chunk} at the specified coordinates
-     *
-     * @param x X-coordinate of the chunk
-     * @param z Z-coordinate of the chunk
-     * @return Whether the chunk was actually regenerated
-     */
-    public boolean regenerateChunk(int x, int z);
-
-    /**
-     * Resends the {@link Chunk} to all clients
-     *
-     * @param x X-coordinate of the chunk
-     * @param z Z-coordinate of the chunk
-     * @return Whether the chunk was actually refreshed
-     * 
-     * @deprecated This method is not guaranteed to work suitably across all client implementations.
-     */
-    @Deprecated
-    public boolean refreshChunk(int x, int z);
-
-    /**
-     * Drops an item at the specified {@link Location}
-     *
-     * @param location Location to drop the item
-     * @param item ItemStack to drop
-     * @return ItemDrop entity created as a result of this method
-     */
-    public Item dropItem(Location location, ItemStack item);
-
-    /**
-     * Drops an item at the specified {@link Location} with a random offset
-     *
-     * @param location Location to drop the item
-     * @param item ItemStack to drop
-     * @return ItemDrop entity created as a result of this method
-     */
-    public Item dropItemNaturally(Location location, ItemStack item);
-
-    /**
-     * Creates an {@link Arrow} entity at the given {@link Location}
-     *
-     * @param location Location to spawn the arrow
-     * @param direction Direction to shoot the arrow in
-     * @param speed Speed of the arrow. A recommend speed is 0.6
-     * @param spread Spread of the arrow. A recommend spread is 12
-     * @return Arrow entity spawned as a result of this method
-     */
-    public Arrow spawnArrow(Location location, Vector direction, float speed, float spread);
-
-    /**
-     * Creates an arrow entity of the given class at the given {@link Location}
-     *
-     * @param <T> type of arrow to spawn
-     * @param location Location to spawn the arrow
-     * @param direction Direction to shoot the arrow in
-     * @param speed Speed of the arrow. A recommend speed is 0.6
-     * @param spread Spread of the arrow. A recommend spread is 12
-     * @param clazz the Entity class for the arrow
-     * {@link org.bukkit.entity.SpectralArrow},{@link org.bukkit.entity.Arrow},{@link org.bukkit.entity.TippedArrow}
-     * @return Arrow entity spawned as a result of this method
-     */
-    public <T extends Arrow> T spawnArrow(Location location, Vector direction, float speed, float spread, Class<T> clazz);
-
-    /**
-     * Creates a tree at the given {@link Location}
-     *
-     * @param location Location to spawn the tree
-     * @param type Type of the tree to create
-     * @return true if the tree was created successfully, otherwise false
-     */
-    public boolean generateTree(Location location, TreeType type);
-
-    /**
-     * Creates a tree at the given {@link Location}
-     *
-     * @param loc Location to spawn the tree
-     * @param type Type of the tree to create
-     * @param delegate A class to call for each block changed as a result of
-     *     this method
-     * @return true if the tree was created successfully, otherwise false
-     */
-    public boolean generateTree(Location loc, TreeType type, BlockChangeDelegate delegate);
-
-    /**
-     * Creates a entity at the given {@link Location}
-     *
-     * @param loc The location to spawn the entity
-     * @param type The entity to spawn
-     * @return Resulting Entity of this method, or null if it was unsuccessful
-     */
-    public Entity spawnEntity(Location loc, EntityType type);
-
-    /**
-     * Strikes lightning at the given {@link Location}
-     *
-     * @param loc The location to strike lightning
-     * @return The lightning entity.
-     */
-    public LightningStrike strikeLightning(Location loc);
-
-    /**
-     * Strikes lightning at the given {@link Location} without doing damage
-     *
-     * @param loc The location to strike lightning
-     * @return The lightning entity.
-     */
-    public LightningStrike strikeLightningEffect(Location loc);
-
-    /**
-     * Get a list of all entities in this World
-     *
-     * @return A List of all Entities currently residing in this world
-     */
-    public List<Entity> getEntities();
-
-    /**
-     * Get a list of all living entities in this World
-     *
-     * @return A List of all LivingEntities currently residing in this world
-     */
-    public List<LivingEntity> getLivingEntities();
-
-    /**
-     * Get a collection of all entities in this World matching the given
-     * class/interface
-     *
-     * @param <T> an entity subclass
-     * @param classes The classes representing the types of entity to match
-     * @return A List of all Entities currently residing in this world that
-     *     match the given class/interface
-     */
-    @Deprecated
-    public <T extends Entity> Collection<T> getEntitiesByClass(Class<T>... classes);
-
-    /**
-     * Get a collection of all entities in this World matching the given
-     * class/interface
-     * 
-     * @param <T> an entity subclass
-     * @param cls The class representing the type of entity to match
-     * @return A List of all Entities currently residing in this world that
-     *     match the given class/interface
-     */
-    public <T extends Entity> Collection<T> getEntitiesByClass(Class<T> cls);
-
-    /**
-     * Get a collection of all entities in this World matching any of the
-     * given classes/interfaces
-     *
-     * @param classes The classes representing the types of entity to match
-     * @return A List of all Entities currently residing in this world that
-     *     match one or more of the given classes/interfaces
-     */
-    public Collection<Entity> getEntitiesByClasses(Class<?>... classes);
-
-    /**
-     * Get a list of all players in this World
-     *
-     * @return A list of all Players currently residing in this world
-     */
-    public List<Player> getPlayers();
-
-    /**
-     * Returns a list of entities within a bounding box centered around a Location.
-     *
-     * Some implementations may impose artificial restrictions on the size of the search bounding box.
-     *
-     * @param location The center of the bounding box
-     * @param x 1/2 the size of the box along x axis
-     * @param y 1/2 the size of the box along y axis
-     * @param z 1/2 the size of the box along z axis
-     * @return the collection of entities near location. This will always be a non-null collection.
-     */
-    public Collection<Entity> getNearbyEntities(Location location, double x, double y, double z);
-
-    /**
-     * Gets the unique name of this world
-     *
-     * @return Name of this world
-     */
-    public String getName();
-
-    /**
-     * Gets the Unique ID of this world
-     *
-     * @return Unique ID of this world.
-     */
-    public UUID getUID();
-
-    /**
-     * Gets the default spawn {@link Location} of this world
-     *
-     * @return The spawn location of this world
-     */
-    public Location getSpawnLocation();
-
-    /**
-     * Sets the spawn location of the world
-     *
-     * @param x X coordinate
-     * @param y Y coordinate
-     * @param z Z coordinate
-     * @return True if it was successfully set.
-     */
-    public boolean setSpawnLocation(int x, int y, int z);
-
-    /**
-     * Gets the relative in-game time of this world.
-     * <p>
-     * The relative time is analogous to hours * 1000
-     *
-     * @return The current relative time
-     * @see #getFullTime() Returns an absolute time of this world
-     */
-    public long getTime();
-
-    /**
-     * Sets the relative in-game time on the server.
-     * <p>
-     * The relative time is analogous to hours * 1000
-     * <p>
-     * Note that setting the relative time below the current relative time
-     * will actually move the clock forward a day. If you require to rewind
-     * time, please see {@link #setFullTime(long)}
-     *
-     * @param time The new relative time to set the in-game time to (in
-     *     hours*1000)
-     * @see #setFullTime(long) Sets the absolute time of this world
-     */
-    public void setTime(long time);
-
-    /**
-     * Gets the full in-game time on this world
-     *
-     * @return The current absolute time
-     * @see #getTime() Returns a relative time of this world
-     */
-    public long getFullTime();
-
-    /**
-     * Sets the in-game time on the server
-     * <p>
-     * Note that this sets the full time of the world, which may cause adverse
-     * effects such as breaking redstone clocks and any scheduled events
-     *
-     * @param time The new absolute time to set this world to
-     * @see #setTime(long) Sets the relative time of this world
-     */
-    public void setFullTime(long time);
-
-    /**
-     * Returns whether the world has an ongoing storm.
-     *
-     * @return Whether there is an ongoing storm
-     */
-    public boolean hasStorm();
-
-    /**
-     * Set whether there is a storm. A duration will be set for the new
-     * current conditions.
-     *
-     * @param hasStorm Whether there is rain and snow
-     */
-    public void setStorm(boolean hasStorm);
-
-    /**
-     * Get the remaining time in ticks of the current conditions.
-     *
-     * @return Time in ticks
-     */
-    public int getWeatherDuration();
-
-    /**
-     * Set the remaining time in ticks of the current conditions.
-     *
-     * @param duration Time in ticks
-     */
-    public void setWeatherDuration(int duration);
-
-    /**
-     * Returns whether there is thunder.
-     *
-     * @return Whether there is thunder
-     */
-    public boolean isThundering();
-
-    /**
-     * Set whether it is thundering.
-     *
-     * @param thundering Whether it is thundering
-     */
-    public void setThundering(boolean thundering);
-
-    /**
-     * Get the thundering duration.
-     *
-     * @return Duration in ticks
-     */
-    public int getThunderDuration();
-
-    /**
-     * Set the thundering duration.
-     *
-     * @param duration Duration in ticks
-     */
-    public void setThunderDuration(int duration);
-
-    /**
-     * Creates explosion at given coordinates with given power
-     *
-     * @param x X coordinate
-     * @param y Y coordinate
-     * @param z Z coordinate
-     * @param power The power of explosion, where 4F is TNT
-     * @return false if explosion was canceled, otherwise true
-     */
-    public boolean createExplosion(double x, double y, double z, float power);
-
-    /**
-     * Creates explosion at given coordinates with given power and optionally
-     * setting blocks on fire.
-     *
-     * @param x X coordinate
-     * @param y Y coordinate
-     * @param z Z coordinate
-     * @param power The power of explosion, where 4F is TNT
-     * @param setFire Whether or not to set blocks on fire
-     * @return false if explosion was canceled, otherwise true
-     */
-    public boolean createExplosion(double x, double y, double z, float power, boolean setFire);
-
-    /**
-     * Creates explosion at given coordinates with given power and optionally
-     * setting blocks on fire or breaking blocks.
-     *
-     * @param x X coordinate
-     * @param y Y coordinate
-     * @param z Z coordinate
-     * @param power The power of explosion, where 4F is TNT
-     * @param setFire Whether or not to set blocks on fire
-     * @param breakBlocks Whether or not to have blocks be destroyed
-     * @return false if explosion was canceled, otherwise true
-     */
-    public boolean createExplosion(double x, double y, double z, float power, boolean setFire, boolean breakBlocks);
-
-    /**
-     * Creates explosion at given coordinates with given power
-     *
-     * @param loc Location to blow up
-     * @param power The power of explosion, where 4F is TNT
-     * @return false if explosion was canceled, otherwise true
-     */
-    public boolean createExplosion(Location loc, float power);
-
-    /**
-     * Creates explosion at given coordinates with given power and optionally
-     * setting blocks on fire.
-     *
-     * @param loc Location to blow up
-     * @param power The power of explosion, where 4F is TNT
-     * @param setFire Whether or not to set blocks on fire
-     * @return false if explosion was canceled, otherwise true
-     */
-    public boolean createExplosion(Location loc, float power, boolean setFire);
-
-    /**
-     * Gets the {@link Environment} type of this world
-     *
-     * @return This worlds Environment type
-     */
-    public Environment getEnvironment();
-
-    /**
-     * Gets the Seed for this world.
-     *
-     * @return This worlds Seed
-     */
-    public long getSeed();
-
-    /**
-     * Gets the current PVP setting for this world.
-     *
-     * @return True if PVP is enabled
-     */
-    public boolean getPVP();
-
-    /**
-     * Sets the PVP setting for this world.
-     *
-     * @param pvp True/False whether PVP should be Enabled.
-     */
-    public void setPVP(boolean pvp);
-
-    /**
-     * Gets the chunk generator for this world
-     *
-     * @return ChunkGenerator associated with this world
-     */
-    public ChunkGenerator getGenerator();
-
-    /**
-     * Saves world to disk
-     */
-    public void save();
-
-    /**
-     * Gets a list of all applied {@link BlockPopulator}s for this World
-     *
-     * @return List containing any or none BlockPopulators
-     */
-    public List<BlockPopulator> getPopulators();
-
-    /**
-     * Spawn an entity of a specific class at the given {@link Location}
-     *
-     * @param location the {@link Location} to spawn the entity at
-     * @param clazz the class of the {@link Entity} to spawn
-     * @param <T> the class of the {@link Entity} to spawn
-     * @return an instance of the spawned {@link Entity}
-     * @throws IllegalArgumentException if either parameter is null or the
-     *     {@link Entity} requested cannot be spawned
-     */
-    public <T extends Entity> T spawn(Location location, Class<T> clazz) throws IllegalArgumentException;
-
-    /**
-     * Spawn a {@link FallingBlock} entity at the given {@link Location} of
-     * the specified {@link Material}. The material dictates what is falling.
-     * When the FallingBlock hits the ground, it will place that block.
-     * <p>
-     * The Material must be a block type, check with {@link Material#isBlock()
-     * material.isBlock()}. The Material may not be air.
-     *
-     * @param location The {@link Location} to spawn the FallingBlock
-     * @param material The block {@link Material} type
-     * @param data The block data
-     * @return The spawned {@link FallingBlock} instance
-     * @throws IllegalArgumentException if {@link Location} or {@link
-     *     Material} are null or {@link Material} is not a block
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public FallingBlock spawnFallingBlock(Location location, Material material, byte data) throws IllegalArgumentException;
-
-    /**
-     * Spawn a {@link FallingBlock} entity at the given {@link Location} of
-     * the specified blockId (converted to {@link Material})
-     *
-     * @param location The {@link Location} to spawn the FallingBlock
-     * @param blockId The id of the intended material
-     * @param blockData The block data
-     * @return The spawned FallingBlock instance
-     * @throws IllegalArgumentException if location is null, or blockId is
-     *     invalid
-     * @see #spawnFallingBlock(org.bukkit.Location, org.bukkit.Material, byte)
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public FallingBlock spawnFallingBlock(Location location, int blockId, byte blockData) throws IllegalArgumentException;
-
-    /**
-     * Plays an effect to all players within a default radius around a given
-     * location.
-     *
-     * @param location the {@link Location} around which players must be to
-     *     hear the sound
-     * @param effect the {@link Effect}
-     * @param data a data bit needed for some effects
-     */
-    public void playEffect(Location location, Effect effect, int data);
-
-    /**
-     * Plays an effect to all players within a given radius around a location.
-     *
-     * @param location the {@link Location} around which players must be to
-     *     hear the effect
-     * @param effect the {@link Effect}
-     * @param data a data bit needed for some effects
-     * @param radius the radius around the location
-     */
-    public void playEffect(Location location, Effect effect, int data, int radius);
-
-    /**
-     * Plays an effect to all players within a default radius around a given
-     * location.
-     *
-     * @param <T> data dependant on the type of effect
-     * @param location the {@link Location} around which players must be to
-     *     hear the sound
-     * @param effect the {@link Effect}
-     * @param data a data bit needed for some effects
-     */
-    public <T> void playEffect(Location location, Effect effect, T data);
-
-    /**
-     * Plays an effect to all players within a given radius around a location.
-     *
-     * @param <T> data dependant on the type of effect
-     * @param location the {@link Location} around which players must be to
-     *     hear the effect
-     * @param effect the {@link Effect}
-     * @param data a data bit needed for some effects
-     * @param radius the radius around the location
-     */
-    public <T> void playEffect(Location location, Effect effect, T data, int radius);
-
-    /**
-     * Get empty chunk snapshot (equivalent to all air blocks), optionally
-     * including valid biome data. Used for representing an ungenerated chunk,
-     * or for fetching only biome data without loading a chunk.
-     *
-     * @param x - chunk x coordinate
-     * @param z - chunk z coordinate
-     * @param includeBiome - if true, snapshot includes per-coordinate biome
-     *     type
-     * @param includeBiomeTempRain - if true, snapshot includes per-coordinate
-     *     raw biome temperature and rainfall
-     * @return The empty snapshot.
-     */
-    public ChunkSnapshot getEmptyChunkSnapshot(int x, int z, boolean includeBiome, boolean includeBiomeTempRain);
-
-    /**
-     * Sets the spawn flags for this.
-     *
-     * @param allowMonsters - if true, monsters are allowed to spawn in this
-     *     world.
-     * @param allowAnimals - if true, animals are allowed to spawn in this
-     *     world.
-     */
-    public void setSpawnFlags(boolean allowMonsters, boolean allowAnimals);
-
-    /**
-     * Gets whether animals can spawn in this world.
-     *
-     * @return whether animals can spawn in this world.
-     */
-    public boolean getAllowAnimals();
-
-    /**
-     * Gets whether monsters can spawn in this world.
-     *
-     * @return whether monsters can spawn in this world.
-     */
-    public boolean getAllowMonsters();
-
-    /**
-     * Gets the biome for the given block coordinates.
-     *
-     * @param x X coordinate of the block
-     * @param z Z coordinate of the block
-     * @return Biome of the requested block
-     */
-    Biome getBiome(int x, int z);
-
-    /**
-     * Sets the biome for the given block coordinates
-     *
-     * @param x X coordinate of the block
-     * @param z Z coordinate of the block
-     * @param bio new Biome type for this block
-     */
-    void setBiome(int x, int z, Biome bio);
-
-    /**
-     * Gets the temperature for the given block coordinates.
-     * <p>
-     * It is safe to run this method when the block does not exist, it will
-     * not create the block.
-     *
-     * @param x X coordinate of the block
-     * @param z Z coordinate of the block
-     * @return Temperature of the requested block
-     */
-    public double getTemperature(int x, int z);
-
-    /**
-     * Gets the humidity for the given block coordinates.
-     * <p>
-     * It is safe to run this method when the block does not exist, it will
-     * not create the block.
-     *
-     * @param x X coordinate of the block
-     * @param z Z coordinate of the block
-     * @return Humidity of the requested block
-     */
-    public double getHumidity(int x, int z);
-
-    /**
-     * Gets the maximum height of this world.
-     * <p>
-     * If the max height is 100, there are only blocks from y=0 to y=99.
-     *
-     * @return Maximum height of the world
-     */
-    public int getMaxHeight();
-
-    /**
-     * Gets the sea level for this world.
-     * <p>
-     * This is often half of {@link #getMaxHeight()}
-     *
-     * @return Sea level
-     */
-    public int getSeaLevel();
-
-    /**
-     * Gets whether the world's spawn area should be kept loaded into memory
-     * or not.
-     *
-     * @return true if the world's spawn area will be kept loaded into memory.
-     */
-    public boolean getKeepSpawnInMemory();
-
-    /**
-     * Sets whether the world's spawn area should be kept loaded into memory
-     * or not.
-     *
-     * @param keepLoaded if true then the world's spawn area will be kept
-     *     loaded into memory.
-     */
-    public void setKeepSpawnInMemory(boolean keepLoaded);
-
-    /**
-     * Gets whether or not the world will automatically save
-     *
-     * @return true if the world will automatically save, otherwise false
-     */
-    public boolean isAutoSave();
-
-    /**
-     * Sets whether or not the world will automatically save
-     *
-     * @param value true if the world should automatically save, otherwise
-     *     false
-     */
-    public void setAutoSave(boolean value);
-
-    /**
-     * Sets the Difficulty of the world.
-     *
-     * @param difficulty the new difficulty you want to set the world to
-     */
-    public void setDifficulty(Difficulty difficulty);
-
-    /**
-     * Gets the Difficulty of the world.
-     *
-     * @return The difficulty of the world.
-     */
-    public Difficulty getDifficulty();
-
-    /**
-     * Gets the folder of this world on disk.
-     *
-     * @return The folder of this world.
-     */
-    public File getWorldFolder();
-
-    /**
-     * Gets the type of this world.
-     *
-     * @return Type of this world.
-     */
-    public WorldType getWorldType();
-
-    /**
-     * Gets whether or not structures are being generated.
-     *
-     * @return True if structures are being generated.
-     */
-    public boolean canGenerateStructures();
-
-    /**
-     * Gets the world's ticks per animal spawns value
-     * <p>
-     * This value determines how many ticks there are between attempts to
-     * spawn animals.
-     * <p>
-     * <b>Example Usage:</b>
-     * <ul>
-     * <li>A value of 1 will mean the server will attempt to spawn animals in
-     *     this world every tick.
-     * <li>A value of 400 will mean the server will attempt to spawn animals
-     *     in this world every 400th tick.
-     * <li>A value below 0 will be reset back to Minecraft's default.
-     * </ul>
-     * <p>
-     * <b>Note:</b>
-     * If set to 0, animal spawning will be disabled for this world. We
-     * recommend using {@link #setSpawnFlags(boolean, boolean)} to control
-     * this instead.
-     * <p>
-     * Minecraft default: 400.
-     *
-     * @return The world's ticks per animal spawns value
-     */
-    public long getTicksPerAnimalSpawns();
-
-    /**
-     * Sets the world's ticks per animal spawns value
-     * <p>
-     * This value determines how many ticks there are between attempts to
-     * spawn animals.
-     * <p>
-     * <b>Example Usage:</b>
-     * <ul>
-     * <li>A value of 1 will mean the server will attempt to spawn animals in
-     *     this world every tick.
-     * <li>A value of 400 will mean the server will attempt to spawn animals
-     *     in this world every 400th tick.
-     * <li>A value below 0 will be reset back to Minecraft's default.
-     * </ul>
-     * <p>
-     * <b>Note:</b>
-     * If set to 0, animal spawning will be disabled for this world. We
-     * recommend using {@link #setSpawnFlags(boolean, boolean)} to control
-     * this instead.
-     * <p>
-     * Minecraft default: 400.
-     *
-     * @param ticksPerAnimalSpawns the ticks per animal spawns value you want
-     *     to set the world to
-     */
-    public void setTicksPerAnimalSpawns(int ticksPerAnimalSpawns);
-
-    /**
-     * Gets the world's ticks per monster spawns value
-     * <p>
-     * This value determines how many ticks there are between attempts to
-     * spawn monsters.
-     * <p>
-     * <b>Example Usage:</b>
-     * <ul>
-     * <li>A value of 1 will mean the server will attempt to spawn monsters in
-     *     this world every tick.
-     * <li>A value of 400 will mean the server will attempt to spawn monsters
-     *     in this world every 400th tick.
-     * <li>A value below 0 will be reset back to Minecraft's default.
-     * </ul>
-     * <p>
-     * <b>Note:</b>
-     * If set to 0, monsters spawning will be disabled for this world. We
-     * recommend using {@link #setSpawnFlags(boolean, boolean)} to control
-     * this instead.
-     * <p>
-     * Minecraft default: 1.
-     *
-     * @return The world's ticks per monster spawns value
-     */
-    public long getTicksPerMonsterSpawns();
-
-    /**
-     * Sets the world's ticks per monster spawns value
-     * <p>
-     * This value determines how many ticks there are between attempts to
-     * spawn monsters.
-     * <p>
-     * <b>Example Usage:</b>
-     * <ul>
-     * <li>A value of 1 will mean the server will attempt to spawn monsters in
-     *     this world on every tick.
-     * <li>A value of 400 will mean the server will attempt to spawn monsters
-     *     in this world every 400th tick.
-     * <li>A value below 0 will be reset back to Minecraft's default.
-     * </ul>
-     * <p>
-     * <b>Note:</b>
-     * If set to 0, monsters spawning will be disabled for this world. We
-     * recommend using {@link #setSpawnFlags(boolean, boolean)} to control
-     * this instead.
-     * <p>
-     * Minecraft default: 1.
-     *
-     * @param ticksPerMonsterSpawns the ticks per monster spawns value you
-     *     want to set the world to
-     */
-    public void setTicksPerMonsterSpawns(int ticksPerMonsterSpawns);
-
-    /**
-     * Gets limit for number of monsters that can spawn in a chunk in this
-     * world
-     *
-     * @return The monster spawn limit
-     */
-    int getMonsterSpawnLimit();
-
-    /**
-     * Sets the limit for number of monsters that can spawn in a chunk in this
-     * world
-     * <p>
-     * <b>Note:</b> If set to a negative number the world will use the
-     * server-wide spawn limit instead.
-     * 
-     * @param limit the new mob limit
-     */
-    void setMonsterSpawnLimit(int limit);
-
-    /**
-     * Gets the limit for number of animals that can spawn in a chunk in this
-     * world
-     *
-     * @return The animal spawn limit
-     */
-    int getAnimalSpawnLimit();
-
-    /**
-     * Sets the limit for number of animals that can spawn in a chunk in this
-     * world
-     * <p>
-     * <b>Note:</b> If set to a negative number the world will use the
-     * server-wide spawn limit instead.
-     * 
-     * @param limit the new mob limit
-     */
-    void setAnimalSpawnLimit(int limit);
-
-    /**
-     * Gets the limit for number of water animals that can spawn in a chunk in
-     * this world
-     *
-     * @return The water animal spawn limit
-     */
-    int getWaterAnimalSpawnLimit();
-
-    /**
-     * Sets the limit for number of water animals that can spawn in a chunk in
-     * this world
-     * <p>
-     * <b>Note:</b> If set to a negative number the world will use the
-     * server-wide spawn limit instead.
-     * 
-     * @param limit the new mob limit
-     */
-    void setWaterAnimalSpawnLimit(int limit);
-
-    /**
-     * Gets the limit for number of ambient mobs that can spawn in a chunk in
-     * this world
-     *
-     * @return The ambient spawn limit
-     */
-    int getAmbientSpawnLimit();
-
-    /**
-     * Sets the limit for number of ambient mobs that can spawn in a chunk in
-     * this world
-     * <p>
-     * <b>Note:</b> If set to a negative number the world will use the
-     * server-wide spawn limit instead.
-     * 
-     * @param limit the new mob limit
-     */
-    void setAmbientSpawnLimit(int limit);
-
-    /**
-     * Play a Sound at the provided Location in the World
-     * <p>
-     * This function will fail silently if Location or Sound are null.
-     *
-     * @param location The location to play the sound
-     * @param sound The sound to play
-     * @param volume The volume of the sound
-     * @param pitch The pitch of the sound
-     */
-    void playSound(Location location, Sound sound, float volume, float pitch);
-
-    /**
-     * Play a Sound at the provided Location in the World.
-     * <p>
-     * This function will fail silently if Location or Sound are null. No
-     * sound will be heard by the players if their clients do not have the
-     * respective sound for the value passed.
-     *
-     * @param location the location to play the sound
-     * @param sound the internal sound name to play
-     * @param volume the volume of the sound
-     * @param pitch the pitch of the sound
-     */
-    void playSound(Location location, String sound, float volume, float pitch);
-
-    /**
-     * Get existing rules
-     *
-     * @return An array of rules
-     */
-    public String[] getGameRules();
-
-    /**
-     * Gets the current state of the specified rule
-     * <p>
-     * Will return null if rule passed is null
-     *
-     * @param rule Rule to look up value of
-     * @return String value of rule
-     */
-    public String getGameRuleValue(String rule);
-
-    /**
-     * Set the specified gamerule to specified value.
-     * <p>
-     * The rule may attempt to validate the value passed, will return true if
-     * value was set.
-     * <p>
-     * If rule is null, the function will return false.
-     *
-     * @param rule Rule to set
-     * @param value Value to set rule to
-     * @return True if rule was set
-     */
-    public boolean setGameRuleValue(String rule, String value);
-
-    /**
-     * Checks if string is a valid game rule
-     *
-     * @param rule Rule to check
-     * @return True if rule exists
-     */
-    public boolean isGameRule(String rule);
-
-    /**
-     * Gets the world border for this world.
-     *
-     * @return The world border for this world.
-     */
-    public WorldBorder getWorldBorder();
-
-    /**
-     * Spawns the particle (the number of times specified by count)
-     * at the target location.
-     *
-     * @param particle the particle to spawn
-     * @param location the location to spawn at
-     * @param count the number of particles
-     */
-    public void spawnParticle(Particle particle, Location location, int count);
-
-    /**
-     * Spawns the particle (the number of times specified by count)
-     * at the target location.
-     *
-     * @param particle the particle to spawn
-     * @param x the position on the x axis to spawn at
-     * @param y the position on the y axis to spawn at
-     * @param z the position on the z axis to spawn at
-     * @param count the number of particles
-     */
-    public void spawnParticle(Particle particle, double x, double y, double z, int count);
-
-    /**
-     * Spawns the particle (the number of times specified by count)
-     * at the target location.
-     *
-     * @param particle the particle to spawn
-     * @param location the location to spawn at
-     * @param count the number of particles
-     * @param data the data to use for the particle or null,
-     *             the type of this depends on {@link Particle#getDataType()}
-     */
-    public <T> void spawnParticle(Particle particle, Location location, int count, T data);
-
-
-    /**
-     * Spawns the particle (the number of times specified by count)
-     * at the target location.
-     *
-     * @param particle the particle to spawn
-     * @param x the position on the x axis to spawn at
-     * @param y the position on the y axis to spawn at
-     * @param z the position on the z axis to spawn at
-     * @param count the number of particles
-     * @param data the data to use for the particle or null,
-     *             the type of this depends on {@link Particle#getDataType()}
-     */
-    public <T> void spawnParticle(Particle particle, double x, double y, double z, int count, T data);
-
-    /**
-     * Spawns the particle (the number of times specified by count)
-     * at the target location. The position of each particle will be
-     * randomized positively and negatively by the offset parameters
-     * on each axis.
-     *
-     * @param particle the particle to spawn
-     * @param location the location to spawn at
-     * @param count the number of particles
-     * @param offsetX the maximum random offset on the X axis
-     * @param offsetY the maximum random offset on the Y axis
-     * @param offsetZ the maximum random offset on the Z axis
-     */
-    public void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ);
-
-    /**
-     * Spawns the particle (the number of times specified by count)
-     * at the target location. The position of each particle will be
-     * randomized positively and negatively by the offset parameters
-     * on each axis.
-     *
-     * @param particle the particle to spawn
-     * @param x the position on the x axis to spawn at
-     * @param y the position on the y axis to spawn at
-     * @param z the position on the z axis to spawn at
-     * @param count the number of particles
-     * @param offsetX the maximum random offset on the X axis
-     * @param offsetY the maximum random offset on the Y axis
-     * @param offsetZ the maximum random offset on the Z axis
-     */
-    public void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ);
-
-    /**
-     * Spawns the particle (the number of times specified by count)
-     * at the target location. The position of each particle will be
-     * randomized positively and negatively by the offset parameters
-     * on each axis.
-     *
-     * @param particle the particle to spawn
-     * @param location the location to spawn at
-     * @param count the number of particles
-     * @param offsetX the maximum random offset on the X axis
-     * @param offsetY the maximum random offset on the Y axis
-     * @param offsetZ the maximum random offset on the Z axis
-     * @param data the data to use for the particle or null,
-     *             the type of this depends on {@link Particle#getDataType()}
-     */
-    public <T> void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ, T data);
-
-    /**
-     * Spawns the particle (the number of times specified by count)
-     * at the target location. The position of each particle will be
-     * randomized positively and negatively by the offset parameters
-     * on each axis.
-     *
-     * @param particle the particle to spawn
-     * @param x the position on the x axis to spawn at
-     * @param y the position on the y axis to spawn at
-     * @param z the position on the z axis to spawn at
-     * @param count the number of particles
-     * @param offsetX the maximum random offset on the X axis
-     * @param offsetY the maximum random offset on the Y axis
-     * @param offsetZ the maximum random offset on the Z axis
-     * @param data the data to use for the particle or null,
-     *             the type of this depends on {@link Particle#getDataType()}
-     */
-    public <T> void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ, T data);
-
-    /**
-     * Spawns the particle (the number of times specified by count)
-     * at the target location. The position of each particle will be
-     * randomized positively and negatively by the offset parameters
-     * on each axis.
-     *
-     * @param particle the particle to spawn
-     * @param location the location to spawn at
-     * @param count the number of particles
-     * @param offsetX the maximum random offset on the X axis
-     * @param offsetY the maximum random offset on the Y axis
-     * @param offsetZ the maximum random offset on the Z axis
-     * @param extra the extra data for this particle, depends on the
-     *              particle used (normally speed)
-     */
-    public void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ, double extra);
-
-    /**
-     * Spawns the particle (the number of times specified by count)
-     * at the target location. The position of each particle will be
-     * randomized positively and negatively by the offset parameters
-     * on each axis.
-     *
-     * @param particle the particle to spawn
-     * @param x the position on the x axis to spawn at
-     * @param y the position on the y axis to spawn at
-     * @param z the position on the z axis to spawn at
-     * @param count the number of particles
-     * @param offsetX the maximum random offset on the X axis
-     * @param offsetY the maximum random offset on the Y axis
-     * @param offsetZ the maximum random offset on the Z axis
-     * @param extra the extra data for this particle, depends on the
-     *              particle used (normally speed)
-     */
-    public void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ, double extra);
-
-    /**
-     * Spawns the particle (the number of times specified by count)
-     * at the target location. The position of each particle will be
-     * randomized positively and negatively by the offset parameters
-     * on each axis.
-     *
-     * @param particle the particle to spawn
-     * @param location the location to spawn at
-     * @param count the number of particles
-     * @param offsetX the maximum random offset on the X axis
-     * @param offsetY the maximum random offset on the Y axis
-     * @param offsetZ the maximum random offset on the Z axis
-     * @param extra the extra data for this particle, depends on the
-     *              particle used (normally speed)
-     * @param data the data to use for the particle or null,
-     *             the type of this depends on {@link Particle#getDataType()}
-     */
-    public <T> void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ, double extra, T data);
-
-    /**
-     * Spawns the particle (the number of times specified by count)
-     * at the target location. The position of each particle will be
-     * randomized positively and negatively by the offset parameters
-     * on each axis.
-     *
-     * @param particle the particle to spawn
-     * @param x the position on the x axis to spawn at
-     * @param y the position on the y axis to spawn at
-     * @param z the position on the z axis to spawn at
-     * @param count the number of particles
-     * @param offsetX the maximum random offset on the X axis
-     * @param offsetY the maximum random offset on the Y axis
-     * @param offsetZ the maximum random offset on the Z axis
-     * @param extra the extra data for this particle, depends on the
-     *              particle used (normally speed)
-     * @param data the data to use for the particle or null,
-     *             the type of this depends on {@link Particle#getDataType()}
-     */
-    public <T> void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ, double extra, T data);
-
-
-    /**
-     * Represents various map environment types that a world may be
-     */
-    public enum Environment {
-
-        /**
-         * Represents the "normal"/"surface world" map
-         */
-        NORMAL(0),
-        /**
-         * Represents a nether based map ("hell")
-         */
-        NETHER(-1),
-        /**
-         * Represents the "end" map
-         */
-        THE_END(1);
-
-        private final int id;
-        private static final Map<Integer, Environment> lookup = new HashMap<Integer, Environment>();
-
-        private Environment(int id) {
-            this.id = id;
-        }
-
-        /**
-         * Gets the dimension ID of this environment
-         *
-         * @return dimension ID
-         * @deprecated Magic value
-         */
-        @Deprecated
-        public int getId() {
-            return id;
-        }
-
-        /**
-         * Get an environment by ID
-         *
-         * @param id The ID of the environment
-         * @return The environment
-         * @deprecated Magic value
-         */
-        @Deprecated
-        public static Environment getEnvironment(int id) {
-            return lookup.get(id);
-        }
-
-        static {
-            for (Environment env : values()) {
-                lookup.put(env.getId(), env);
-            }
-        }
-    }
-}
diff --git a/src/main/java/org/bukkit/WorldBorder.java b/src/main/java/org/bukkit/WorldBorder.java
deleted file mode 100644
index 55c8983..0000000
--- a/src/main/java/org/bukkit/WorldBorder.java
+++ /dev/null
@@ -1,109 +0,0 @@
-package org.bukkit;
-
-public interface WorldBorder {
-
-    /**
-     * Resets the border to default values.
-     */
-    public void reset();
-
-    /**
-     * Gets the current side length of the border.
-     *
-     * @return The current side length of the border.
-     */
-    public double getSize();
-
-    /**
-     * Sets the border to a square region with the specified side length in blocks.
-     *
-     * @param newSize The new size of the border.
-     */
-    public void setSize(double newSize);
-
-    /**
-     * Sets the border to a square region with the specified side length in blocks.
-     *
-     * @param newSize The new side length of the border.
-     * @param seconds The time in seconds in which the border grows or shrinks from the previous size to that being set.
-     */
-    public void setSize(double newSize, long seconds);
-
-    /**
-     * Gets the current border center.
-     *
-     * @return The current border center.
-     */
-    public Location getCenter();
-
-    /**
-     * Sets the new border center.
-     *
-     * @param x The new center x-coordinate.
-     * @param z The new center z-coordinate.
-     */
-    public void setCenter(double x, double z);
-
-    /**
-     * Sets the new border center.
-     *
-     * @param location The new location of the border center. (Only x/z used)
-     */
-    public void setCenter(Location location);
-
-    /**
-     * Gets the current border damage buffer.
-     *
-     * @return The current border damage buffer.
-     */
-    public double getDamageBuffer();
-
-    /**
-     * Sets the amount of blocks a player may safely be outside the border before taking damage.
-     *
-     * @param blocks The amount of blocks. (The default is 5 blocks.)
-     */
-    public void setDamageBuffer(double blocks);
-
-    /**
-     * Gets the current border damage amount.
-     *
-     * @return The current border damage amount.
-     */
-    public double getDamageAmount();
-
-    /**
-     * Sets the amount of damage a player takes when outside the border plus the border buffer.
-     *
-     * @param damage The amount of damage. (The default is 0.2 damage per second per block.)
-     */
-    public void setDamageAmount(double damage);
-
-    /**
-     * Gets the current border warning time in seconds.
-     *
-     * @return The current border warning time in seconds.
-     */
-    public int getWarningTime();
-
-    /**
-     * Sets the warning time that causes the screen to be tinted red when a contracting border will reach the player within the specified time.
-     *
-     * @param seconds The amount of time in seconds. (The default is 15 seconds.)
-     */
-    public void setWarningTime(int seconds);
-
-    /**
-     * Gets the current border warning distance.
-     *
-     * @return The current border warning distance.
-     */
-    public int getWarningDistance();
-
-    /**
-     * Sets the warning distance that causes the screen to be tinted red when the player is within the specified number of blocks from the border.
-     *
-     * @param distance The distance in blocks. (The default is 5 blocks.)
-     */
-    public void setWarningDistance(int distance);
-}
diff --git a/src/main/java/org/bukkit/WorldCreator.java b/src/main/java/org/bukkit/WorldCreator.java
deleted file mode 100644
index 53980fd..0000000
--- a/src/main/java/org/bukkit/WorldCreator.java
+++ /dev/null
@@ -1,317 +0,0 @@
-package org.bukkit;
-
-import java.util.Random;
-import org.bukkit.command.CommandSender;
-import org.bukkit.generator.ChunkGenerator;
-import org.bukkit.plugin.Plugin;
-
-/**
- * Represents various types of options that may be used to create a world.
- */
-public class WorldCreator {
-    private final String name;
-    private long seed;
-    private World.Environment environment = World.Environment.NORMAL;
-    private ChunkGenerator generator = null;
-    private WorldType type = WorldType.NORMAL;
-    private boolean generateStructures = true;
-    private String generatorSettings = "";
-
-    /**
-     * Creates an empty WorldCreationOptions for the given world name
-     *
-     * @param name Name of the world that will be created
-     */
-    public WorldCreator(String name) {
-        if (name == null) {
-            throw new IllegalArgumentException("World name cannot be null");
-        }
-
-        this.name = name;
-        this.seed = (new Random()).nextLong();
-    }
-
-    /**
-     * Copies the options from the specified world
-     *
-     * @param world World to copy options from
-     * @return This object, for chaining
-     */
-    public WorldCreator copy(World world) {
-        if (world == null) {
-            throw new IllegalArgumentException("World cannot be null");
-        }
-
-        seed = world.getSeed();
-        environment = world.getEnvironment();
-        generator = world.getGenerator();
-
-        return this;
-    }
-
-    /**
-     * Copies the options from the specified {@link WorldCreator}
-     *
-     * @param creator World creator to copy options from
-     * @return This object, for chaining
-     */
-    public WorldCreator copy(WorldCreator creator) {
-        if (creator == null) {
-            throw new IllegalArgumentException("Creator cannot be null");
-        }
-
-        seed = creator.seed();
-        environment = creator.environment();
-        generator = creator.generator();
-
-        return this;
-    }
-
-    /**
-     * Gets the name of the world that is to be loaded or created.
-     *
-     * @return World name
-     */
-    public String name() {
-        return name;
-    }
-
-    /**
-     * Gets the seed that will be used to create this world
-     *
-     * @return World seed
-     */
-    public long seed() {
-        return seed;
-    }
-
-    /**
-     * Sets the seed that will be used to create this world
-     *
-     * @param seed World seed
-     * @return This object, for chaining
-     */
-    public WorldCreator seed(long seed) {
-        this.seed = seed;
-
-        return this;
-    }
-
-    /**
-     * Gets the environment that will be used to create or load the world
-     *
-     * @return World environment
-     */
-    public World.Environment environment() {
-        return environment;
-    }
-
-    /**
-     * Sets the environment that will be used to create or load the world
-     *
-     * @param env World environment
-     * @return This object, for chaining
-     */
-    public WorldCreator environment(World.Environment env) {
-        this.environment = env;
-
-        return this;
-    }
-
-    /**
-     * Gets the type of the world that will be created or loaded
-     *
-     * @return World type
-     */
-    public WorldType type() {
-        return type;
-    }
-
-    /**
-     * Sets the type of the world that will be created or loaded
-     *
-     * @param type World type
-     * @return This object, for chaining
-     */
-    public WorldCreator type(WorldType type) {
-        this.type = type;
-
-        return this;
-    }
-
-    /**
-     * Gets the generator that will be used to create or load the world.
-     * <p>
-     * This may be null, in which case the "natural" generator for this
-     * environment will be used.
-     *
-     * @return Chunk generator
-     */
-    public ChunkGenerator generator() {
-        return generator;
-    }
-
-    /**
-     * Sets the generator that will be used to create or load the world.
-     * <p>
-     * This may be null, in which case the "natural" generator for this
-     * environment will be used.
-     *
-     * @param generator Chunk generator
-     * @return This object, for chaining
-     */
-    public WorldCreator generator(ChunkGenerator generator) {
-        this.generator = generator;
-
-        return this;
-    }
-
-    /**
-     * Sets the generator that will be used to create or load the world.
-     * <p>
-     * This may be null, in which case the "natural" generator for this
-     * environment will be used.
-     * <p>
-     * If the generator cannot be found for the given name, the natural
-     * environment generator will be used instead and a warning will be
-     * printed to the console.
-     *
-     * @param generator Name of the generator to use, in "plugin:id" notation
-     * @return This object, for chaining
-     */
-    public WorldCreator generator(String generator) {
-        this.generator = getGeneratorForName(name, generator, Bukkit.getConsoleSender());
-
-        return this;
-    }
-
-    /**
-     * Sets the generator that will be used to create or load the world.
-     * <p>
-     * This may be null, in which case the "natural" generator for this
-     * environment will be used.
-     * <p>
-     * If the generator cannot be found for the given name, the natural
-     * environment generator will be used instead and a warning will be
-     * printed to the specified output
-     *
-     * @param generator Name of the generator to use, in "plugin:id" notation
-     * @param output {@link CommandSender} that will receive any error
-     *     messages
-     * @return This object, for chaining
-     */
-    public WorldCreator generator(String generator, CommandSender output) {
-        this.generator = getGeneratorForName(name, generator, output);
-
-        return this;
-    }
-
-    /**
-     * Sets the generator settings of the world that will be created or loaded
-     *
-     * @param generatorSettings The settings that should be used by the generator
-     * @return This object, for chaining
-     */
-    public WorldCreator generatorSettings(String generatorSettings) {
-        this.generatorSettings = generatorSettings;
-
-        return this;
-    }
-
-    /**
-     * Gets the generator settings of the world that will be created or loaded
-     *
-     * @return The settings that should be used by the generator
-     */
-    public String generatorSettings() {
-        return generatorSettings;
-    }
-
-    /**
-     * Sets whether or not worlds created or loaded with this creator will
-     * have structures.
-     *
-     * @param generate Whether to generate structures
-     * @return This object, for chaining
-     */
-    public WorldCreator generateStructures(boolean generate) {
-        this.generateStructures = generate;
-
-        return this;
-    }
-
-    /**
-     * Gets whether or not structures will be generated in the world.
-     *
-     * @return True if structures will be generated
-     */
-    public boolean generateStructures() {
-        return generateStructures;
-    }
-
-    /**
-     * Creates a world with the specified options.
-     * <p>
-     * If the world already exists, it will be loaded from disk and some
-     * options may be ignored.
-     *
-     * @return Newly created or loaded world
-     */
-    public World createWorld() {
-        return Bukkit.createWorld(this);
-    }
-
-    /**
-     * Creates a new {@link WorldCreator} for the given world name
-     *
-     * @param name Name of the world to load or create
-     * @return Resulting WorldCreator
-     */
-    public static WorldCreator name(String name) {
-        return new WorldCreator(name);
-    }
-
-    /**
-     * Attempts to get the {@link ChunkGenerator} with the given name.
-     * <p>
-     * If the generator is not found, null will be returned and a message will
-     * be printed to the specified {@link CommandSender} explaining why.
-     * <p>
-     * The name must be in the "plugin:id" notation, or optionally just
-     * "plugin", where "plugin" is the safe-name of a plugin and "id" is an
-     * optional unique identifier for the generator you wish to request from
-     * the plugin.
-     *
-     * @param world Name of the world this will be used for
-     * @param name Name of the generator to retrieve
-     * @param output Where to output if errors are present
-     * @return Resulting generator, or null
-     */
-    public static ChunkGenerator getGeneratorForName(String world, String name, CommandSender output) {
-        ChunkGenerator result = null;
-
-        if (world == null) {
-            throw new IllegalArgumentException("World name must be specified");
-        }
-
-        if (output == null) {
-            output = Bukkit.getConsoleSender();
-        }
-
-        if (name != null) {
-            String[] split = name.split(":", 2);
-            String id = (split.length > 1) ? split[1] : null;
-            Plugin plugin = Bukkit.getPluginManager().getPlugin(split[0]);
-
-            if (plugin == null) {
-                output.sendMessage("Could not set generator for world '" + world + "': Plugin '" + split[0] + "' does not exist");
-            } else if (!plugin.isEnabled()) {
-                output.sendMessage("Could not set generator for world '" + world + "': Plugin '" + plugin.getDescription().getFullName() + "' is not enabled");
-            } else {
-                result = plugin.getDefaultWorldGenerator(world, id);
-            }
-        }
-
-        return result;
-    }
-}
diff --git a/src/main/java/org/bukkit/WorldType.java b/src/main/java/org/bukkit/WorldType.java
deleted file mode 100644
index e817803..0000000
--- a/src/main/java/org/bukkit/WorldType.java
+++ /dev/null
@@ -1,48 +0,0 @@
-package org.bukkit;
-
-import com.google.common.collect.Maps;
-import java.util.Map;
-
-/**
- * Represents various types of worlds that may exist
- */
-public enum WorldType {
-    NORMAL("DEFAULT"),
-    FLAT("FLAT"),
-    VERSION_1_1("DEFAULT_1_1"),
-    LARGE_BIOMES("LARGEBIOMES"),
-    AMPLIFIED("AMPLIFIED"),
-    CUSTOMIZED("CUSTOMIZED");
-
-    private final static Map<String, WorldType> BY_NAME = Maps.newHashMap();
-    private final String name;
-
-    private WorldType(String name) {
-        this.name = name;
-    }
-
-    /**
-     * Gets the name of this WorldType
-     *
-     * @return Name of this type
-     */
-    public String getName() {
-        return name;
-    }
-
-    /**
-     * Gets a Worldtype by its name
-     *
-     * @param name Name of the WorldType to get
-     * @return Requested WorldType, or null if not found
-     */
-    public static WorldType getByName(String name) {
-        return BY_NAME.get(name.toUpperCase());
-    }
-
-    static {
-        for (WorldType type : values()) {
-            BY_NAME.put(type.name, type);
-        }
-    }
-}
diff --git a/src/main/java/org/bukkit/attribute/Attributable.java b/src/main/java/org/bukkit/attribute/Attributable.java
deleted file mode 100644
index 155f13f..0000000
--- a/src/main/java/org/bukkit/attribute/Attributable.java
+++ /dev/null
@@ -1,16 +0,0 @@
-package org.bukkit.attribute;
-
-/**
- * Represents an object which may contain attributes.
- */
-public interface Attributable {
-
-    /**
-     * Gets the specified attribute instance from the object. This instance will
-     * be backed directly to the object and any changes will be visible at once.
-     *
-     * @param attribute the attribute to get
-     * @return the attribute instance or null if not applicable to this object
-     */
-    AttributeInstance getAttribute(Attribute attribute);
-}
diff --git a/src/main/java/org/bukkit/attribute/Attribute.java b/src/main/java/org/bukkit/attribute/Attribute.java
deleted file mode 100644
index 38bea1e..0000000
--- a/src/main/java/org/bukkit/attribute/Attribute.java
+++ /dev/null
@@ -1,48 +0,0 @@
-package org.bukkit.attribute;
-
-/**
- * Types of attributes which may be present on an {@link Attributable}.
- */
-public enum Attribute {
-
-    /**
-     * Maximum health of an Entity.
-     */
-    GENERIC_MAX_HEALTH,
-    /**
-     * Range at which an Entity will follow others.
-     */
-    GENERIC_FOLLOW_RANGE,
-    /**
-     * Resistance of an Entity to knockback.
-     */
-    GENERIC_KNOCKBACK_RESISTANCE,
-    /**
-     * Movement speed of an Entity.
-     */
-    GENERIC_MOVEMENT_SPEED,
-    /**
-     * Attack damage of an Entity.
-     */
-    GENERIC_ATTACK_DAMAGE,
-    /**
-     * Attack speed of an Entity.
-     */
-    GENERIC_ATTACK_SPEED,
-    /**
-     * Armor bonus of an Entity.
-     */
-    GENERIC_ARMOR,
-    /**
-     * Luck bonus of an Entity.
-     */
-    GENERIC_LUCK,
-    /**
-     * Strength with which a horse will jump.
-     */
-    HORSE_JUMP_STRENGTH,
-    /**
-     * Chance of a zombie to spawn reinforcements.
-     */
-    ZOMBIE_SPAWN_REINFORCEMENTS;
-}
diff --git a/src/main/java/org/bukkit/attribute/AttributeInstance.java b/src/main/java/org/bukkit/attribute/AttributeInstance.java
deleted file mode 100644
index 92194b3..0000000
--- a/src/main/java/org/bukkit/attribute/AttributeInstance.java
+++ /dev/null
@@ -1,60 +0,0 @@
-package org.bukkit.attribute;
-
-import java.util.Collection;
-
-/**
- * Represents a mutable instance of an attribute and its associated modifiers
- * and values.
- */
-public interface AttributeInstance {
-
-    /**
-     * The attribute pertaining to this instance.
-     *
-     * @return the attribute
-     */
-    Attribute getAttribute();
-
-    /**
-     * Base value of this instance before modifiers are applied.
-     *
-     * @return base value
-     */
-    double getBaseValue();
-
-    /**
-     * Set the base value of this instance.
-     *
-     * @param value new base value
-     */
-    void setBaseValue(double value);
-
-    /**
-     * Get all modifiers present on this instance.
-     *
-     * @return a copied collection of all modifiers
-     */
-    Collection<AttributeModifier> getModifiers();
-
-    /**
-     * Add a modifier to this instance.
-     *
-     * @param modifier to add
-     */
-    void addModifier(AttributeModifier modifier);
-
-    /**
-     * Remove a modifier from this instance.
-     *
-     * @param modifier to remove
-     */
-    void removeModifier(AttributeModifier modifier);
-
-    /**
-     * Get the value of this instance after all associated modifiers have been
-     * applied.
-     *
-     * @return the total attribute value
-     */
-    double getValue();
-}
diff --git a/src/main/java/org/bukkit/attribute/AttributeModifier.java b/src/main/java/org/bukkit/attribute/AttributeModifier.java
deleted file mode 100644
index ade7bf0..0000000
--- a/src/main/java/org/bukkit/attribute/AttributeModifier.java
+++ /dev/null
@@ -1,103 +0,0 @@
-package org.bukkit.attribute;
-
-import java.util.HashMap;
-import java.util.Map;
-import java.util.UUID;
-import org.apache.commons.lang.Validate;
-import org.bukkit.configuration.serialization.ConfigurationSerializable;
-import org.bukkit.util.NumberConversions;
-
-/**
- * Concrete implementation of an attribute modifier.
- */
-public class AttributeModifier implements ConfigurationSerializable {
-
-    private final UUID uuid;
-    private final String name;
-    private final double amount;
-    private final Operation operation;
-
-    public AttributeModifier(String name, double amount, Operation operation) {
-        this(UUID.randomUUID(), name, amount, operation);
-    }
-
-    public AttributeModifier(UUID uuid, String name, double amount, Operation operation) {
-        Validate.notNull(uuid, "uuid");
-        Validate.notEmpty(name, "Name cannot be empty");
-        Validate.notNull(operation, "operation");
-
-        this.uuid = uuid;
-        this.name = name;
-        this.amount = amount;
-        this.operation = operation;
-    }
-
-    /**
-     * Get the unique ID for this modifier.
-     *
-     * @return unique id
-     */
-    public UUID getUniqueId() {
-        return uuid;
-    }
-
-    /**
-     * Get the name of this modifier.
-     *
-     * @return name
-     */
-    public String getName() {
-        return name;
-    }
-
-    /**
-     * Get the amount by which this modifier will apply its {@link Operation}.
-     *
-     * @return modification amount
-     */
-    public double getAmount() {
-        return amount;
-    }
-
-    /**
-     * Get the operation this modifier will apply.
-     *
-     * @return operation
-     */
-    public Operation getOperation() {
-        return operation;
-    }
-
-    @Override
-    public Map<String, Object> serialize() {
-        Map<String, Object> data = new HashMap<String, Object>();
-        data.put("uuid", uuid);
-        data.put("name", name);
-        data.put("operation", operation.ordinal());
-        data.put("amount", amount);
-        return data;
-    }
-
-    public static AttributeModifier deserialize(Map<String, Object> args) {
-        return new AttributeModifier((UUID) args.get("uuid"), (String) args.get("name"), NumberConversions.toDouble(args.get("amount")), Operation.values()[NumberConversions.toInt(args.get("operation"))]);
-    }
-
-    /**
-     * Enumerable operation to be applied.
-     */
-    public enum Operation {
-
-        /**
-         * Adds (or subtracts) the specified amount to the base value.
-         */
-        ADD_NUMBER,
-        /**
-         * Adds this scalar of amount to the base value.
-         */
-        ADD_SCALAR,
-        /**
-         * Multiply amount by this value, after adding 1 to it.
-         */
-        MULTIPLY_SCALAR_1;
-    }
-}
diff --git a/src/main/java/org/bukkit/block/Banner.java b/src/main/java/org/bukkit/block/Banner.java
deleted file mode 100644
index 723b883..0000000
--- a/src/main/java/org/bukkit/block/Banner.java
+++ /dev/null
@@ -1,77 +0,0 @@
-package org.bukkit.block;
-
-import org.bukkit.DyeColor;
-import org.bukkit.block.banner.Pattern;
-
-import java.util.List;
-
-public interface Banner extends BlockState {
-
-    /**
-     * Returns the base color for this banner
-     *
-     * @return the base color
-     */
-    DyeColor getBaseColor();
-
-    /**
-     * Sets the base color for this banner
-     *
-     * @param color the base color
-     */
-    void setBaseColor(DyeColor color);
-
-    /**
-     * Returns a list of patterns on this banner
-     *
-     * @return the patterns
-     */
-    List<Pattern> getPatterns();
-
-    /**
-     * Sets the patterns used on this banner
-     *
-     * @param patterns the new list of patterns
-     */
-    void setPatterns(List<Pattern> patterns);
-
-    /**
-     * Adds a new pattern on top of the existing
-     * patterns
-     *
-     * @param pattern the new pattern to add
-     */
-    void addPattern(Pattern pattern);
-
-    /**
-     * Returns the pattern at the specified index
-     *
-     * @param i the index
-     * @return the pattern
-     */
-    Pattern getPattern(int i);
-
-    /**
-     * Removes the pattern at the specified index
-     *
-     * @param i the index
-     * @return the removed pattern
-     */
-    Pattern removePattern(int i);
-
-    /**
-     * Sets the pattern at the specified index
-     *
-     * @param i       the index
-     * @param pattern the new pattern
-     */
-    void setPattern(int i, Pattern pattern);
-
-    /**
-     * Returns the number of patterns on this
-     * banner
-     *
-     * @return the number of patterns
-     */
-    int numberOfPatterns();
-}
diff --git a/src/main/java/org/bukkit/block/Beacon.java b/src/main/java/org/bukkit/block/Beacon.java
deleted file mode 100644
index 2de0583..0000000
--- a/src/main/java/org/bukkit/block/Beacon.java
+++ /dev/null
@@ -1,9 +0,0 @@
-package org.bukkit.block;
-
-import org.bukkit.inventory.InventoryHolder;
-
-/**
- * Represents a beacon.
- */
-public interface Beacon extends BlockState, InventoryHolder {
-}
diff --git a/src/main/java/org/bukkit/block/Biome.java b/src/main/java/org/bukkit/block/Biome.java
deleted file mode 100644
index 9585005..0000000
--- a/src/main/java/org/bukkit/block/Biome.java
+++ /dev/null
@@ -1,69 +0,0 @@
-package org.bukkit.block;
-
-/**
- * Holds all accepted Biomes in the default server
- */
-public enum Biome {
-    OCEAN,
-    PLAINS,
-    DESERT,
-    EXTREME_HILLS,
-    FOREST,
-    TAIGA,
-    SWAMPLAND,
-    RIVER,
-    HELL,
-    SKY,
-    FROZEN_OCEAN,
-    FROZEN_RIVER,
-    ICE_FLATS,
-    ICE_MOUNTAINS,
-    MUSHROOM_ISLAND,
-    MUSHROOM_ISLAND_SHORE,
-    BEACHES,
-    DESERT_HILLS,
-    FOREST_HILLS,
-    TAIGA_HILLS,
-    SMALLER_EXTREME_HILLS,
-    JUNGLE,
-    JUNGLE_HILLS,
-    JUNGLE_EDGE,
-    DEEP_OCEAN,
-    STONE_BEACH,
-    COLD_BEACH,
-    BIRCH_FOREST,
-    BIRCH_FOREST_HILLS,
-    ROOFED_FOREST,
-    TAIGA_COLD,
-    TAIGA_COLD_HILLS,
-    REDWOOD_TAIGA,
-    REDWOOD_TAIGA_HILLS,
-    EXTREME_HILLS_WITH_TREES,
-    SAVANNA,
-    SAVANNA_ROCK,
-    MESA,
-    MESA_ROCK,
-    MESA_CLEAR_ROCK,
-    VOID,
-    MUTATED_PLAINS,
-    MUTATED_DESERT,
-    MUTATED_EXTREME_HILLS,
-    MUTATED_FOREST,
-    MUTATED_TAIGA,
-    MUTATED_SWAMPLAND,
-    MUTATED_ICE_FLATS,
-    MUTATED_JUNGLE,
-    MUTATED_JUNGLE_EDGE,
-    MUTATED_BIRCH_FOREST,
-    MUTATED_BIRCH_FOREST_HILLS,
-    MUTATED_ROOFED_FOREST,
-    MUTATED_TAIGA_COLD,
-    MUTATED_REDWOOD_TAIGA,
-    MUTATED_REDWOOD_TAIGA_HILLS,
-    MUTATED_EXTREME_HILLS_WITH_TREES,
-    MUTATED_SAVANNA,
-    MUTATED_SAVANNA_ROCK,
-    MUTATED_MESA,
-    MUTATED_MESA_ROCK,
-    MUTATED_MESA_CLEAR_ROCK
-}
diff --git a/src/main/java/org/bukkit/block/Block.java b/src/main/java/org/bukkit/block/Block.java
deleted file mode 100644
index 235c15b..0000000
--- a/src/main/java/org/bukkit/block/Block.java
+++ /dev/null
@@ -1,393 +0,0 @@
-package org.bukkit.block;
-
-import java.util.Collection;
-
-import org.bukkit.Chunk;
-import org.bukkit.Material;
-import org.bukkit.World;
-import org.bukkit.Location;
-import org.bukkit.inventory.ItemStack;
-import org.bukkit.metadata.Metadatable;
-
-/**
- * Represents a block. This is a live object, and only one Block may exist for
- * any given location in a world. The state of the block may change
- * concurrently to your own handling of it; use block.getState() to get a
- * snapshot state of a block which will not be modified.
- */
-public interface Block extends Metadatable {
-
-    /**
-     * Gets the metadata for this block
-     *
-     * @return block specific metadata
-     * @deprecated Magic value
-     */
-    @Deprecated
-    byte getData();
-
-    /**
-     * Gets the block at the given offsets
-     *
-     * @param modX X-coordinate offset
-     * @param modY Y-coordinate offset
-     * @param modZ Z-coordinate offset
-     * @return Block at the given offsets
-     */
-    Block getRelative(int modX, int modY, int modZ);
-
-    /**
-     * Gets the block at the given face
-     * <p>
-     * This method is equal to getRelative(face, 1)
-     *
-     * @param face Face of this block to return
-     * @return Block at the given face
-     * @see #getRelative(BlockFace, int)
-     */
-    Block getRelative(BlockFace face);
-
-    /**
-     * Gets the block at the given distance of the given face
-     * <p>
-     * For example, the following method places water at 100,102,100; two
-     * blocks above 100,100,100.
-     *
-     * <pre>
-     * Block block = world.getBlockAt(100, 100, 100);
-     * Block shower = block.getRelative(BlockFace.UP, 2);
-     * shower.setType(Material.WATER);
-     * </pre>
-     *
-     * @param face Face of this block to return
-     * @param distance Distance to get the block at
-     * @return Block at the given face
-     */
-    Block getRelative(BlockFace face, int distance);
-
-    /**
-     * Gets the type of this block
-     *
-     * @return block type
-     */
-    Material getType();
-
-    /**
-     * Gets the type-id of this block
-     *
-     * @return block type-id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    int getTypeId();
-
-    /**
-     * Gets the light level between 0-15
-     *
-     * @return light level
-     */
-    byte getLightLevel();
-
-    /**
-     * Get the amount of light at this block from the sky.
-     * <p>
-     * Any light given from other sources (such as blocks like torches) will
-     * be ignored.
-     *
-     * @return Sky light level
-     */
-    byte getLightFromSky();
-
-    /**
-     * Get the amount of light at this block from nearby blocks.
-     * <p>
-     * Any light given from other sources (such as the sun) will be ignored.
-     *
-     * @return Block light level
-     */
-    byte getLightFromBlocks();
-
-    /**
-     * Gets the world which contains this Block
-     *
-     * @return World containing this block
-     */
-    World getWorld();
-
-    /**
-     * Gets the x-coordinate of this block
-     *
-     * @return x-coordinate
-     */
-    int getX();
-
-    /**
-     * Gets the y-coordinate of this block
-     *
-     * @return y-coordinate
-     */
-    int getY();
-
-    /**
-     * Gets the z-coordinate of this block
-     *
-     * @return z-coordinate
-     */
-    int getZ();
-
-    /**
-     * Gets the Location of the block
-     *
-     * @return Location of block
-     */
-    Location getLocation();
-
-    /**
-     * Stores the location of the block in the provided Location object.
-     * <p>
-     * If the provided Location is null this method does nothing and returns
-     * null.
-     *
-     * @param loc the location to copy into
-     * @return The Location object provided or null
-     */
-    Location getLocation(Location loc);
-
-    /**
-     * Gets the chunk which contains this block
-     *
-     * @return Containing Chunk
-     */
-    Chunk getChunk();
-
-    /**
-     * Sets the metadata for this block
-     *
-     * @param data New block specific metadata
-     * @deprecated Magic value
-     */
-    @Deprecated
-    void setData(byte data);
-
-    /**
-     * Sets the metadata for this block
-     *
-     * @param data New block specific metadata
-     * @param applyPhysics False to cancel physics from the changed block.
-     * @deprecated Magic value
-     */
-    @Deprecated
-    void setData(byte data, boolean applyPhysics);
-
-    /**
-     * Sets the type of this block
-     *
-     * @param type Material to change this block to
-     */
-    void setType(Material type);
-
-    /**
-     * Sets the type of this block
-     *
-     * @param type Material to change this block to
-     * @param applyPhysics False to cancel physics on the changed block.
-     */
-    void setType(Material type, boolean applyPhysics);
-
-    /**
-     * Sets the type-id of this block
-     *
-     * @param type Type-Id to change this block to
-     * @return whether the block was changed
-     * @deprecated Magic value
-     */
-    @Deprecated
-    boolean setTypeId(int type);
-
-    /**
-     * Sets the type-id of this block
-     *
-     * @param type Type-Id to change this block to
-     * @param applyPhysics False to cancel physics on the changed block.
-     * @return whether the block was changed
-     * @deprecated Magic value
-     */
-    @Deprecated
-    boolean setTypeId(int type, boolean applyPhysics);
-
-    /**
-     * Sets the type-id of this block
-     *
-     * @param type Type-Id to change this block to
-     * @param data The data value to change this block to
-     * @param applyPhysics False to cancel physics on the changed block
-     * @return whether the block was changed
-     * @deprecated Magic value
-     */
-    @Deprecated
-    boolean setTypeIdAndData(int type, byte data, boolean applyPhysics);
-
-    /**
-     * Gets the face relation of this block compared to the given block.
-     * <p>
-     * For example: 
-     * <pre>{@code
-     * Block current = world.getBlockAt(100, 100, 100);
-     * Block target = world.getBlockAt(100, 101, 100);
-     *
-     * current.getFace(target) == BlockFace.Up;
-     * }</pre>
-     * <br>
-     * If the given block is not connected to this block, null may be returned
-     *
-     * @param block Block to compare against this block
-     * @return BlockFace of this block which has the requested block, or null
-     */
-    BlockFace getFace(Block block);
-
-    /**
-     * Captures the current state of this block. You may then cast that state
-     * into any accepted type, such as Furnace or Sign.
-     * <p>
-     * The returned object will never be updated, and you are not guaranteed
-     * that (for example) a sign is still a sign after you capture its state.
-     *
-     * @return BlockState with the current state of this block.
-     */
-    BlockState getState();
-
-    /**
-     * Returns the biome that this block resides in
-     *
-     * @return Biome type containing this block
-     */
-    Biome getBiome();
-
-    /**
-     * Sets the biome that this block resides in
-     *
-     * @param bio new Biome type for this block
-     */
-    void setBiome(Biome bio);
-
-    /**
-     * Returns true if the block is being powered by Redstone.
-     *
-     * @return True if the block is powered.
-     */
-    boolean isBlockPowered();
-
-    /**
-     * Returns true if the block is being indirectly powered by Redstone.
-     *
-     * @return True if the block is indirectly powered.
-     */
-    boolean isBlockIndirectlyPowered();
-
-    /**
-     * Returns true if the block face is being powered by Redstone.
-     *
-     * @param face The block face
-     * @return True if the block face is powered.
-     */
-    boolean isBlockFacePowered(BlockFace face);
-
-    /**
-     * Returns true if the block face is being indirectly powered by Redstone.
-     *
-     * @param face The block face
-     * @return True if the block face is indirectly powered.
-     */
-    boolean isBlockFaceIndirectlyPowered(BlockFace face);
-
-    /**
-     * Returns the redstone power being provided to this block face
-     *
-     * @param face the face of the block to query or BlockFace.SELF for the
-     *     block itself
-     * @return The power level.
-     */
-    int getBlockPower(BlockFace face);
-
-    /**
-     * Returns the redstone power being provided to this block
-     *
-     * @return The power level.
-     */
-    int getBlockPower();
-
-    /**
-     * Checks if this block is empty.
-     * <p>
-     * A block is considered empty when {@link #getType()} returns {@link
-     * Material#AIR}.
-     *
-     * @return true if this block is empty
-     */
-    boolean isEmpty();
-
-    /**
-     * Checks if this block is liquid.
-     * <p>
-     * A block is considered liquid when {@link #getType()} returns {@link
-     * Material#WATER}, {@link Material#STATIONARY_WATER}, {@link
-     * Material#LAVA} or {@link Material#STATIONARY_LAVA}.
-     *
-     * @return true if this block is liquid
-     */
-    boolean isLiquid();
-
-    /**
-     * Gets the temperature of the biome of this block
-     *
-     * @return Temperature of this block
-     */
-    double getTemperature();
-
-    /**
-     * Gets the humidity of the biome of this block
-     *
-     * @return Humidity of this block
-     */
-    double getHumidity();
-
-    /**
-     * Returns the reaction of the block when moved by a piston
-     *
-     * @return reaction
-     */
-    PistonMoveReaction getPistonMoveReaction();
-
-    /**
-     * Breaks the block and spawns items as if a player had digged it
-     *
-     * @return true if the block was destroyed
-     */
-    boolean breakNaturally();
-
-    /**
-     * Breaks the block and spawns items as if a player had digged it with a
-     * specific tool
-     *
-     * @param tool The tool or item in hand used for digging
-     * @return true if the block was destroyed
-     */
-    boolean breakNaturally(ItemStack tool);
-
-    /**
-     * Returns a list of items which would drop by destroying this block
-     *
-     * @return a list of dropped items for this type of block
-     */
-    Collection<ItemStack> getDrops();
-
-    /**
-     * Returns a list of items which would drop by destroying this block with
-     * a specific tool
-     *
-     * @param tool The tool or item in hand used for digging
-     * @return a list of dropped items for this type of block
-     */
-    Collection<ItemStack> getDrops(ItemStack tool);
-
-}
diff --git a/src/main/java/org/bukkit/block/BlockFace.java b/src/main/java/org/bukkit/block/BlockFace.java
deleted file mode 100644
index 58fb195..0000000
--- a/src/main/java/org/bukkit/block/BlockFace.java
+++ /dev/null
@@ -1,132 +0,0 @@
-package org.bukkit.block;
-
-/**
- * Represents the face of a block
- */
-public enum BlockFace {
-    NORTH(0, 0, -1),
-    EAST(1, 0, 0),
-    SOUTH(0, 0, 1),
-    WEST(-1, 0, 0),
-    UP(0, 1, 0),
-    DOWN(0, -1, 0),
-    NORTH_EAST(NORTH, EAST),
-    NORTH_WEST(NORTH, WEST),
-    SOUTH_EAST(SOUTH, EAST),
-    SOUTH_WEST(SOUTH, WEST),
-    WEST_NORTH_WEST(WEST, NORTH_WEST),
-    NORTH_NORTH_WEST(NORTH, NORTH_WEST),
-    NORTH_NORTH_EAST(NORTH, NORTH_EAST),
-    EAST_NORTH_EAST(EAST, NORTH_EAST),
-    EAST_SOUTH_EAST(EAST, SOUTH_EAST),
-    SOUTH_SOUTH_EAST(SOUTH, SOUTH_EAST),
-    SOUTH_SOUTH_WEST(SOUTH, SOUTH_WEST),
-    WEST_SOUTH_WEST(WEST, SOUTH_WEST),
-    SELF(0, 0, 0);
-
-    private final int modX;
-    private final int modY;
-    private final int modZ;
-
-    private BlockFace(final int modX, final int modY, final int modZ) {
-        this.modX = modX;
-        this.modY = modY;
-        this.modZ = modZ;
-    }
-
-    private BlockFace(final BlockFace face1, final BlockFace face2) {
-        this.modX = face1.getModX() + face2.getModX();
-        this.modY = face1.getModY() + face2.getModY();
-        this.modZ = face1.getModZ() + face2.getModZ();
-    }
-
-    /**
-     * Get the amount of X-coordinates to modify to get the represented block
-     *
-     * @return Amount of X-coordinates to modify
-     */
-    public int getModX() {
-        return modX;
-    }
-
-    /**
-     * Get the amount of Y-coordinates to modify to get the represented block
-     *
-     * @return Amount of Y-coordinates to modify
-     */
-    public int getModY() {
-        return modY;
-    }
-
-    /**
-     * Get the amount of Z-coordinates to modify to get the represented block
-     *
-     * @return Amount of Z-coordinates to modify
-     */
-    public int getModZ() {
-        return modZ;
-    }
-
-    public BlockFace getOppositeFace() {
-        switch (this) {
-        case NORTH:
-            return BlockFace.SOUTH;
-
-        case SOUTH:
-            return BlockFace.NORTH;
-
-        case EAST:
-            return BlockFace.WEST;
-
-        case WEST:
-            return BlockFace.EAST;
-
-        case UP:
-            return BlockFace.DOWN;
-
-        case DOWN:
-            return BlockFace.UP;
-
-        case NORTH_EAST:
-            return BlockFace.SOUTH_WEST;
-
-        case NORTH_WEST:
-            return BlockFace.SOUTH_EAST;
-
-        case SOUTH_EAST:
-            return BlockFace.NORTH_WEST;
-
-        case SOUTH_WEST:
-            return BlockFace.NORTH_EAST;
-
-        case WEST_NORTH_WEST:
-            return BlockFace.EAST_SOUTH_EAST;
-
-        case NORTH_NORTH_WEST:
-            return BlockFace.SOUTH_SOUTH_EAST;
-
-        case NORTH_NORTH_EAST:
-            return BlockFace.SOUTH_SOUTH_WEST;
-
-        case EAST_NORTH_EAST:
-            return BlockFace.WEST_SOUTH_WEST;
-
-        case EAST_SOUTH_EAST:
-            return BlockFace.WEST_NORTH_WEST;
-
-        case SOUTH_SOUTH_EAST:
-            return BlockFace.NORTH_NORTH_WEST;
-
-        case SOUTH_SOUTH_WEST:
-            return BlockFace.NORTH_NORTH_EAST;
-
-        case WEST_SOUTH_WEST:
-            return BlockFace.EAST_NORTH_EAST;
-
-        case SELF:
-            return BlockFace.SELF;
-        }
-
-        return BlockFace.SELF;
-    }
-}
diff --git a/src/main/java/org/bukkit/block/BlockState.java b/src/main/java/org/bukkit/block/BlockState.java
deleted file mode 100644
index 866a73d..0000000
--- a/src/main/java/org/bukkit/block/BlockState.java
+++ /dev/null
@@ -1,206 +0,0 @@
-package org.bukkit.block;
-
-import org.bukkit.Chunk;
-import org.bukkit.Location;
-import org.bukkit.Material;
-import org.bukkit.World;
-import org.bukkit.material.MaterialData;
-import org.bukkit.metadata.Metadatable;
-
-/**
- * Represents a captured state of a block, which will not change
- * automatically.
- * <p>
- * Unlike Block, which only one object can exist per coordinate, BlockState
- * can exist multiple times for any given Block. Note that another plugin may
- * change the state of the block and you will not know, or they may change the
- * block to another type entirely, causing your BlockState to become invalid.
- */
-public interface BlockState extends Metadatable {
-
-    /**
-     * Gets the block represented by this BlockState
-     *
-     * @return Block that this BlockState represents
-     */
-    Block getBlock();
-
-    /**
-     * Gets the metadata for this block
-     *
-     * @return block specific metadata
-     */
-    MaterialData getData();
-
-    /**
-     * Gets the type of this block
-     *
-     * @return block type
-     */
-    Material getType();
-
-    /**
-     * Gets the type-id of this block
-     *
-     * @return block type-id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    int getTypeId();
-
-    /**
-     * Gets the light level between 0-15
-     *
-     * @return light level
-     */
-    byte getLightLevel();
-
-    /**
-     * Gets the world which contains this Block
-     *
-     * @return World containing this block
-     */
-    World getWorld();
-
-    /**
-     * Gets the x-coordinate of this block
-     *
-     * @return x-coordinate
-     */
-    int getX();
-
-    /**
-     * Gets the y-coordinate of this block
-     *
-     * @return y-coordinate
-     */
-    int getY();
-
-    /**
-     * Gets the z-coordinate of this block
-     *
-     * @return z-coordinate
-     */
-    int getZ();
-
-    /**
-     * Gets the location of this block
-     *
-     * @return location
-     */
-    Location getLocation();
-
-    /**
-     * Stores the location of this block in the provided Location object.
-     * <p>
-     * If the provided Location is null this method does nothing and returns
-     * null.
-     *
-     * @param loc the location to copy into
-     * @return The Location object provided or null
-     */
-    Location getLocation(Location loc);
-
-    /**
-     * Gets the chunk which contains this block
-     *
-     * @return Containing Chunk
-     */
-    Chunk getChunk();
-
-    /**
-     * Sets the metadata for this block
-     *
-     * @param data New block specific metadata
-     */
-    void setData(MaterialData data);
-
-    /**
-     * Sets the type of this block
-     *
-     * @param type Material to change this block to
-     */
-    void setType(Material type);
-
-    /**
-     * Sets the type-id of this block
-     *
-     * @param type Type-Id to change this block to
-     * @return Whether it worked?
-     * @deprecated Magic value
-     */
-    @Deprecated
-    boolean setTypeId(int type);
-
-    /**
-     * Attempts to update the block represented by this state, setting it to
-     * the new values as defined by this state.
-     * <p>
-     * This has the same effect as calling update(false). That is to say,
-     * this will not modify the state of a block if it is no longer the same
-     * type as it was when this state was taken. It will return false in this
-     * eventuality.
-     *
-     * @return true if the update was successful, otherwise false
-     * @see #update(boolean)
-     */
-    boolean update();
-
-    /**
-     * Attempts to update the block represented by this state, setting it to
-     * the new values as defined by this state.
-     * <p>
-     * This has the same effect as calling update(force, true). That is to
-     * say, this will trigger a physics update to surrounding blocks.
-     *
-     * @param force true to forcefully set the state
-     * @return true if the update was successful, otherwise false
-     */
-    boolean update(boolean force);
-
-    /**
-     * Attempts to update the block represented by this state, setting it to
-     * the new values as defined by this state.
-     * <p>
-     * Unless force is true, this will not modify the state of a block if it
-     * is no longer the same type as it was when this state was taken. It will
-     * return false in this eventuality.
-     * <p>
-     * If force is true, it will set the type of the block to match the new
-     * state, set the state data and then return true.
-     * <p>
-     * If applyPhysics is true, it will trigger a physics update on
-     * surrounding blocks which could cause them to update or disappear.
-     *
-     * @param force true to forcefully set the state
-     * @param applyPhysics false to cancel updating physics on surrounding
-     *     blocks
-     * @return true if the update was successful, otherwise false
-     */
-    boolean update(boolean force, boolean applyPhysics);
-
-    /**
-     * @return The data as a raw byte.
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public byte getRawData();
-
-    /**
-     * @param data The new data value for the block.
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public void setRawData(byte data);
-
-    /**
-     * Returns whether this state is placed in the world.
-     *
-     * Some methods will not work if the blockState isn't
-     * placed in the world.
-     *
-     * @return whether the state is placed in the world
-     *         or 'virtual' (e.g. on an itemstack)
-     */
-    boolean isPlaced();
-}
diff --git a/src/main/java/org/bukkit/block/BrewingStand.java b/src/main/java/org/bukkit/block/BrewingStand.java
deleted file mode 100644
index f642e68..0000000
--- a/src/main/java/org/bukkit/block/BrewingStand.java
+++ /dev/null
@@ -1,40 +0,0 @@
-package org.bukkit.block;
-
-import org.bukkit.inventory.BrewerInventory;
-import org.bukkit.inventory.InventoryHolder;
-
-/**
- * Represents a brewing stand.
- */
-public interface BrewingStand extends BlockState, InventoryHolder {
-
-    /**
-     * How much time is left in the brewing cycle
-     *
-     * @return Brew Time
-     */
-    int getBrewingTime();
-
-    /**
-     * Set the time left before brewing completes.
-     *
-     * @param brewTime Brewing time
-     */
-    void setBrewingTime(int brewTime);
-
-    /**
-     * Get the level of current fuel for brewing.
-     *
-     * @return The fuel level
-     */
-    int getFuelLevel();
-
-    /**
-     * Set the level of current fuel for brewing.
-     *
-     * @param level fuel level
-     */
-    void setFuelLevel(int level);
-
-    public BrewerInventory getInventory();
-}
diff --git a/src/main/java/org/bukkit/block/Chest.java b/src/main/java/org/bukkit/block/Chest.java
deleted file mode 100644
index ee95841..0000000
--- a/src/main/java/org/bukkit/block/Chest.java
+++ /dev/null
@@ -1,18 +0,0 @@
-package org.bukkit.block;
-
-import org.bukkit.inventory.Inventory;
-import org.bukkit.inventory.InventoryHolder;
-
-/**
- * Represents a chest.
- */
-public interface Chest extends BlockState, InventoryHolder {
-
-    /**
-     * Returns the chest's inventory. If this is a double chest, it returns
-     * just the portion of the inventory linked to this half of the chest.
-     *
-     * @return The inventory.
-     */
-    Inventory getBlockInventory();
-}
diff --git a/src/main/java/org/bukkit/block/CommandBlock.java b/src/main/java/org/bukkit/block/CommandBlock.java
deleted file mode 100644
index 85d5345..0000000
--- a/src/main/java/org/bukkit/block/CommandBlock.java
+++ /dev/null
@@ -1,40 +0,0 @@
-package org.bukkit.block;
-
-public interface CommandBlock extends BlockState {
-
-    /**
-     * Gets the command that this CommandBlock will run when powered.
-     * This will never return null.  If the CommandBlock does not have a
-     * command, an empty String will be returned instead.
-     *
-     * @return Command that this CommandBlock will run when powered.
-     */
-    public String getCommand();
-
-    /**
-     * Sets the command that this CommandBlock will run when powered.
-     * Setting the command to null is the same as setting it to an empty
-     * String.
-     *
-     * @param command Command that this CommandBlock will run when powered.
-     */
-    public void setCommand(String command);
-
-    /**
-     * Gets the name of this CommandBlock.  The name is used with commands
-     * that this CommandBlock executes.  This name will never be null, and
-     * by default is "@".
-     *
-     * @return Name of this CommandBlock.
-     */
-    public String getName();
-
-    /**
-     * Sets the name of this CommandBlock.  The name is used with commands
-     * that this CommandBlock executes.  Setting the name to null is the
-     * same as setting it to "@".
-     *
-     * @param name New name for this CommandBlock.
-     */
-    public void setName(String name);
-}
diff --git a/src/main/java/org/bukkit/block/CreatureSpawner.java b/src/main/java/org/bukkit/block/CreatureSpawner.java
deleted file mode 100644
index cf4fb71..0000000
--- a/src/main/java/org/bukkit/block/CreatureSpawner.java
+++ /dev/null
@@ -1,51 +0,0 @@
-package org.bukkit.block;
-
-import org.bukkit.entity.EntityType;
-
-/**
- * Represents a creature spawner.
- */
-public interface CreatureSpawner extends BlockState {
-
-    /**
-     * Get the spawner's creature type.
-     *
-     * @return The creature type.
-     */
-    public EntityType getSpawnedType();
-
-    /**
-     * Set the spawner's creature type.
-     *
-     * @param creatureType The creature type.
-     */
-    public void setSpawnedType(EntityType creatureType);
-
-    /**
-     * Set the spawner mob type.
-     *
-     * @param creatureType The creature type's name.
-     */
-    public void setCreatureTypeByName(String creatureType);
-
-    /**
-     * Get the spawner's creature type.
-     *
-     * @return The creature type's name.
-     */
-    public String getCreatureTypeName();
-
-    /**
-     * Get the spawner's delay.
-     *
-     * @return The delay.
-     */
-    public int getDelay();
-
-    /**
-     * Set the spawner's delay.
-     *
-     * @param delay The delay.
-     */
-    public void setDelay(int delay);
-}
diff --git a/src/main/java/org/bukkit/block/Dispenser.java b/src/main/java/org/bukkit/block/Dispenser.java
deleted file mode 100644
index 4e6b349..0000000
--- a/src/main/java/org/bukkit/block/Dispenser.java
+++ /dev/null
@@ -1,28 +0,0 @@
-package org.bukkit.block;
-
-import org.bukkit.inventory.InventoryHolder;
-import org.bukkit.projectiles.BlockProjectileSource;
-
-/**
- * Represents a dispenser.
- */
-public interface Dispenser extends BlockState, InventoryHolder {
-
-    /**
-     * Gets the BlockProjectileSource object for this dispenser.
-     * <p>
-     * If the block is no longer a dispenser, this will return null.
-     *
-     * @return a BlockProjectileSource if valid, otherwise null
-     */
-    public BlockProjectileSource getBlockProjectileSource();
-
-    /**
-     * Attempts to dispense the contents of this block.
-     * <p>
-     * If the block is no longer a dispenser, this will return false.
-     *
-     * @return true if successful, otherwise false
-     */
-    public boolean dispense();
-}
diff --git a/src/main/java/org/bukkit/block/DoubleChest.java b/src/main/java/org/bukkit/block/DoubleChest.java
deleted file mode 100644
index 148099c..0000000
--- a/src/main/java/org/bukkit/block/DoubleChest.java
+++ /dev/null
@@ -1,50 +0,0 @@
-package org.bukkit.block;
-
-import org.bukkit.Location;
-import org.bukkit.World;
-import org.bukkit.inventory.DoubleChestInventory;
-import org.bukkit.inventory.Inventory;
-import org.bukkit.inventory.InventoryHolder;
-
-/**
- * Represents a double chest.
- */
-public class DoubleChest implements InventoryHolder {
-    private DoubleChestInventory inventory;
-
-    public DoubleChest(DoubleChestInventory chest) {
-        inventory = chest;
-    }
-
-    public Inventory getInventory() {
-        return inventory;
-    }
-
-    public InventoryHolder getLeftSide() {
-        return inventory.getLeftSide().getHolder();
-    }
-
-    public InventoryHolder getRightSide() {
-        return inventory.getRightSide().getHolder();
-    }
-
-    public Location getLocation() {
-        return new Location(getWorld(), getX(), getY(), getZ());
-    }
-
-    public World getWorld() {
-        return ((Chest)getLeftSide()).getWorld();
-    }
-
-    public double getX() {
-        return 0.5 * (((Chest)getLeftSide()).getX() + ((Chest)getRightSide()).getX());
-    }
-
-    public double getY() {
-        return 0.5 * (((Chest)getLeftSide()).getY() + ((Chest)getRightSide()).getY());
-    }
-
-    public double getZ() {
-        return 0.5 * (((Chest)getLeftSide()).getZ() + ((Chest)getRightSide()).getZ());
-    }
-}
diff --git a/src/main/java/org/bukkit/block/Dropper.java b/src/main/java/org/bukkit/block/Dropper.java
deleted file mode 100644
index a04fa96..0000000
--- a/src/main/java/org/bukkit/block/Dropper.java
+++ /dev/null
@@ -1,25 +0,0 @@
-package org.bukkit.block;
-
-import org.bukkit.inventory.InventoryHolder;
-
-/**
- * Represents a dropper.
- */
-public interface Dropper extends BlockState, InventoryHolder {
-    /**
-     * Tries to drop a randomly selected item from the Dropper's inventory,
-     * following the normal behavior of a Dropper.
-     * <p>
-     * Normal behavior of a Dropper is as follows:
-     * <p>
-     * If the block that the Dropper is facing is an InventoryHolder,
-     * the randomly selected ItemStack is placed within that 
-     * Inventory in the first slot that's available, starting with 0 and
-     * counting up.  If the inventory is full, nothing happens.
-     * <p>
-     * If the block that the Dropper is facing is not an InventoryHolder,
-     * the randomly selected ItemStack is dropped on
-     * the ground in the form of an {@link org.bukkit.entity.Item Item}.
-     */
-    public void drop();
-}
diff --git a/src/main/java/org/bukkit/block/EndGateway.java b/src/main/java/org/bukkit/block/EndGateway.java
deleted file mode 100644
index 3e77fd7..0000000
--- a/src/main/java/org/bukkit/block/EndGateway.java
+++ /dev/null
@@ -1,42 +0,0 @@
-package org.bukkit.block;
-
-import org.bukkit.Location;
-
-/**
- * Represents an end gateway.
- */
-public interface EndGateway extends BlockState {
-
-    /**
-     * Gets the location that entities are teleported to when 
-     * entering the gateway portal.
-     * 
-     * @return the gateway exit location
-     */
-    Location getExitLocation();
-
-    /**
-     * Sets the exit location that entities are teleported to when
-     * they enter the gateway portal.
-     * 
-     * @param location the new exit location
-     * @throws IllegalArgumentException for differing worlds
-     */
-    void setExitLocation(Location location);
-
-    /**
-     * Gets whether this gateway will teleport entities directly to
-     * the exit location instead of finding a nearby location.
-     * 
-     * @return true if the gateway is teleporting to the exact location
-     */
-    boolean isExactTeleport();
-
-    /**
-     * Sets whether this gateway will teleport entities directly to
-     * the exit location instead of finding a nearby location.
-     * 
-     * @param exact whether to teleport to the exact location
-     */
-    void setExactTeleport(boolean exact);
-}
diff --git a/src/main/java/org/bukkit/block/FlowerPot.java b/src/main/java/org/bukkit/block/FlowerPot.java
deleted file mode 100644
index 3db6f80..0000000
--- a/src/main/java/org/bukkit/block/FlowerPot.java
+++ /dev/null
@@ -1,23 +0,0 @@
-package org.bukkit.block;
-
-import org.bukkit.material.MaterialData;
-
-public interface FlowerPot extends BlockState {
-
-    /**
-     * Gets the item present in this flower pot.
-     *
-     * @return item present, or null for empty.
-     */
-    MaterialData getContents();
-
-    /**
-     * Sets the item present in this flower pot.
-     *
-     * NOTE: The Vanilla Minecraft client will currently not refresh this until
-     * a block update is triggered.
-     *
-     * @param item new item, or null for empty.
-     */
-    void setContents(MaterialData item);
-}
diff --git a/src/main/java/org/bukkit/block/Furnace.java b/src/main/java/org/bukkit/block/Furnace.java
deleted file mode 100644
index 9c8cd33..0000000
--- a/src/main/java/org/bukkit/block/Furnace.java
+++ /dev/null
@@ -1,40 +0,0 @@
-package org.bukkit.block;
-
-import org.bukkit.inventory.FurnaceInventory;
-import org.bukkit.inventory.InventoryHolder;
-
-/**
- * Represents a furnace.
- */
-public interface Furnace extends BlockState, InventoryHolder {
-
-    /**
-     * Get burn time.
-     *
-     * @return Burn time
-     */
-    public short getBurnTime();
-
-    /**
-     * Set burn time.
-     *
-     * @param burnTime Burn time
-     */
-    public void setBurnTime(short burnTime);
-
-    /**
-     * Get cook time.
-     *
-     * @return Cook time
-     */
-    public short getCookTime();
-
-    /**
-     * Set cook time.
-     *
-     * @param cookTime Cook time
-     */
-    public void setCookTime(short cookTime);
-
-    public FurnaceInventory getInventory();
-}
diff --git a/src/main/java/org/bukkit/block/Hopper.java b/src/main/java/org/bukkit/block/Hopper.java
deleted file mode 100644
index e097157..0000000
--- a/src/main/java/org/bukkit/block/Hopper.java
+++ /dev/null
@@ -1,10 +0,0 @@
-package org.bukkit.block;
-
-import org.bukkit.inventory.InventoryHolder;
-
-/**
- * Represents a hopper.
- */
-public interface Hopper extends BlockState, InventoryHolder {
-
-}
diff --git a/src/main/java/org/bukkit/block/Jukebox.java b/src/main/java/org/bukkit/block/Jukebox.java
deleted file mode 100644
index 7b45b83..0000000
--- a/src/main/java/org/bukkit/block/Jukebox.java
+++ /dev/null
@@ -1,36 +0,0 @@
-package org.bukkit.block;
-
-import org.bukkit.Material;
-
-/**
- * Represents a Jukebox
- */
-public interface Jukebox extends BlockState {
-    /**
-     * Get the record currently playing
-     *
-     * @return The record Material, or AIR if none is playing
-     */
-    public Material getPlaying();
-
-    /**
-     * Set the record currently playing
-     *
-     * @param record The record Material, or null/AIR to stop playing
-     */
-    public void setPlaying(Material record);
-
-    /**
-     * Check if the jukebox is currently playing a record
-     *
-     * @return True if there is a record playing
-     */
-    public boolean isPlaying();
-
-    /**
-     * Stop the jukebox playing and eject the current record
-     *
-     * @return True if a record was ejected; false if there was none playing
-     */
-    public boolean eject();
-}
diff --git a/src/main/java/org/bukkit/block/NoteBlock.java b/src/main/java/org/bukkit/block/NoteBlock.java
deleted file mode 100644
index 8380068..0000000
--- a/src/main/java/org/bukkit/block/NoteBlock.java
+++ /dev/null
@@ -1,72 +0,0 @@
-package org.bukkit.block;
-
-import org.bukkit.Instrument;
-import org.bukkit.Note;
-
-/**
- * Represents a note.
- */
-public interface NoteBlock extends BlockState {
-
-    /**
-     * Gets the note.
-     *
-     * @return The note.
-     */
-    public Note getNote();
-
-    /**
-     * Gets the note.
-     *
-     * @return The note ID.
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public byte getRawNote();
-
-    /**
-     * Set the note.
-     *
-     * @param note The note.
-     */
-    public void setNote(Note note);
-
-    /**
-     * Set the note.
-     *
-     * @param note The note ID.
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public void setRawNote(byte note);
-
-    /**
-     * Attempts to play the note at block
-     * <p>
-     * If the block is no longer a note block, this will return false
-     *
-     * @return true if successful, otherwise false
-     */
-    public boolean play();
-
-    /**
-     * Plays an arbitrary note with an arbitrary instrument
-     *
-     * @param instrument Instrument ID
-     * @param note Note ID
-     * @return true if successful, otherwise false
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public boolean play(byte instrument, byte note);
-
-    /**
-     * Plays an arbitrary note with an arbitrary instrument
-     *
-     * @param instrument The instrument
-     * @param note The note
-     * @return true if successful, otherwise false
-     * @see Instrument Note
-     */
-    public boolean play(Instrument instrument, Note note);
-}
diff --git a/src/main/java/org/bukkit/block/PistonMoveReaction.java b/src/main/java/org/bukkit/block/PistonMoveReaction.java
deleted file mode 100644
index e5279f7..0000000
--- a/src/main/java/org/bukkit/block/PistonMoveReaction.java
+++ /dev/null
@@ -1,51 +0,0 @@
-package org.bukkit.block;
-
-import java.util.HashMap;
-import java.util.Map;
-
-public enum PistonMoveReaction {
-
-    /**
-     * Indicates that the block can be pushed or pulled.
-     */
-    MOVE(0),
-    /**
-     * Indicates the block is fragile and will break if pushed on.
-     */
-    BREAK(1),
-    /**
-     * Indicates that the block will resist being pushed or pulled.
-     */
-    BLOCK(2);
-
-    private int id;
-    private static Map<Integer, PistonMoveReaction> byId = new HashMap<Integer, PistonMoveReaction>();
-    static {
-        for (PistonMoveReaction reaction : PistonMoveReaction.values()) {
-            byId.put(reaction.id, reaction);
-        }
-    }
-
-    private PistonMoveReaction(int id) {
-        this.id = id;
-    }
-
-    /**
-     * @return The ID of the move reaction
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public int getId() {
-        return this.id;
-    }
-
-    /**
-     * @param id An ID
-     * @return The move reaction with that ID
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public static PistonMoveReaction getById(int id) {
-        return byId.get(id);
-    }
-}
diff --git a/src/main/java/org/bukkit/block/Sign.java b/src/main/java/org/bukkit/block/Sign.java
deleted file mode 100644
index 5d7a633..0000000
--- a/src/main/java/org/bukkit/block/Sign.java
+++ /dev/null
@@ -1,37 +0,0 @@
-package org.bukkit.block;
-
-/**
- * Represents either a SignPost or a WallSign
- */
-public interface Sign extends BlockState {
-
-    /**
-     * Gets all the lines of text currently on this sign.
-     *
-     * @return Array of Strings containing each line of text
-     */
-    public String[] getLines();
-
-    /**
-     * Gets the line of text at the specified index.
-     * <p>
-     * For example, getLine(0) will return the first line of text.
-     *
-     * @param index Line number to get the text from, starting at 0
-     * @throws IndexOutOfBoundsException Thrown when the line does not exist
-     * @return Text on the given line
-     */
-    public String getLine(int index) throws IndexOutOfBoundsException;
-
-    /**
-     * Sets the line of text at the specified index.
-     * <p>
-     * For example, setLine(0, "Line One") will set the first line of text to
-     * "Line One".
-     *
-     * @param index Line number to set the text at, starting from 0
-     * @param line New text to set at the specified index
-     * @throws IndexOutOfBoundsException If the index is out of the range 0..3
-     */
-    public void setLine(int index, String line) throws IndexOutOfBoundsException;
-}
diff --git a/src/main/java/org/bukkit/block/Skull.java b/src/main/java/org/bukkit/block/Skull.java
deleted file mode 100644
index 7fbbc6b..0000000
--- a/src/main/java/org/bukkit/block/Skull.java
+++ /dev/null
@@ -1,84 +0,0 @@
-package org.bukkit.block;
-
-import java.util.UUID;
-import org.bukkit.OfflinePlayer;
-import org.bukkit.SkullType;
-
-/**
- * Represents a Skull
- */
-public interface Skull extends BlockState {
-
-    /**
-     * Checks to see if the skull has an owner
-     *
-     * @return true if the skull has an owner
-     */
-    public boolean hasOwner();
-
-    /**
-     * Gets the owner of the skull, if one exists
-     *
-     * @return the owner of the skull or null if the skull does not have an owner
-     * @deprecated See {@link #getOwningPlayer()}.
-     */
-    @Deprecated
-    public String getOwner();
-
-    /**
-     * Sets the owner of the skull
-     * <p>
-     * Involves a potentially blocking web request to acquire the profile data for
-     * the provided name.
-     *
-     * @param name the new owner of the skull
-     * @return true if the owner was successfully set
-     * @deprecated see {@link #setOwningPlayer(org.bukkit.OfflinePlayer)}.
-     */
-    @Deprecated
-    public boolean setOwner(String name);
-
-    /**
-     * Get the player which owns the skull. This player may appear as the
-     * texture depending on skull type.
-     *
-     * @return owning player
-     */
-    public OfflinePlayer getOwningPlayer();
-
-    /**
-     * Set the player which owns the skull. This player may appear as the
-     * texture depending on skull type.
-     *
-     * @param player the owning player
-     */
-    public void setOwningPlayer(OfflinePlayer player);
-
-    /**
-     * Gets the rotation of the skull in the world
-     *
-     * @return the rotation of the skull
-     */
-    public BlockFace getRotation();
-
-    /**
-     * Sets the rotation of the skull in the world
-     *
-     * @param rotation the rotation of the skull
-     */
-    public void setRotation(BlockFace rotation);
-
-    /**
-     * Gets the type of skull
-     *
-     * @return the type of skull
-     */
-    public SkullType getSkullType();
-
-    /**
-     * Sets the type of skull
-     *
-     * @param skullType the type of skull
-     */
-    public void setSkullType(SkullType skullType);
-}
diff --git a/src/main/java/org/bukkit/block/Structure.java b/src/main/java/org/bukkit/block/Structure.java
deleted file mode 100644
index dd5b8b1..0000000
--- a/src/main/java/org/bukkit/block/Structure.java
+++ /dev/null
@@ -1,3 +0,0 @@
-package org.bukkit.block;
-
-public interface Structure extends BlockState {}
diff --git a/src/main/java/org/bukkit/block/banner/Pattern.java b/src/main/java/org/bukkit/block/banner/Pattern.java
deleted file mode 100644
index 95b0f3c..0000000
--- a/src/main/java/org/bukkit/block/banner/Pattern.java
+++ /dev/null
@@ -1,94 +0,0 @@
-package org.bukkit.block.banner;
-
-import com.google.common.collect.ImmutableMap;
-import java.util.Map;
-import java.util.NoSuchElementException;
-import org.bukkit.DyeColor;
-import org.bukkit.configuration.serialization.ConfigurationSerializable;
-import org.bukkit.configuration.serialization.SerializableAs;
-
-@SerializableAs("Pattern")
-public class Pattern implements ConfigurationSerializable {
-
-    private static final String COLOR = "color";
-    private static final String PATTERN = "pattern";
-    
-    private final DyeColor color;
-    private final PatternType pattern;
-
-    /**
-     * Creates a new pattern from the specified color and
-     * pattern type
-     *
-     * @param color   the pattern color
-     * @param pattern the pattern type
-     */
-    public Pattern(DyeColor color, PatternType pattern) {
-        this.color = color;
-        this.pattern = pattern;
-    }
-    
-    /**
-     * Constructor for deserialization.
-     *
-     * @param map the map to deserialize from
-     */
-    public Pattern(Map<String, Object> map) {
-        color = DyeColor.valueOf(getString(map, COLOR));
-        pattern = PatternType.getByIdentifier(getString(map, PATTERN));
-    }    
-
-    private static String getString(Map<?,?> map, Object key) {
-        Object str = map.get(key);
-        if (str instanceof String) {
-            return (String) str;
-        }
-        throw new NoSuchElementException(map + " does not contain " + key);
-    }
-    
-    @Override
-    public Map<String, Object> serialize() {
-        return ImmutableMap.<String, Object>of(
-            COLOR, color.toString(),
-            PATTERN, pattern.getIdentifier()
-        );
-    }
-
-    /**
-     * Returns the color of the pattern
-     *
-     * @return the color of the pattern
-     */
-    public DyeColor getColor() {
-        return color;
-    }
-
-    /**
-     * Returns the type of pattern
-     *
-     * @return the pattern type
-     */
-    public PatternType getPattern() {
-        return pattern;
-    }
-
-    @Override
-    public int hashCode() {
-        int hash = 3;
-        hash = 97 * hash + (this.color != null ? this.color.hashCode() : 0);
-        hash = 97 * hash + (this.pattern != null ? this.pattern.hashCode() : 0);
-        return hash;
-    }
-
-    @Override
-    public boolean equals(Object obj) {
-        if (obj == null) {
-            return false;
-        }
-        if (getClass() != obj.getClass()) {
-            return false;
-        }
-        final Pattern other = (Pattern) obj;
-        return this.color == other.color && this.pattern == other.pattern;
-    }
-}
diff --git a/src/main/java/org/bukkit/block/banner/PatternType.java b/src/main/java/org/bukkit/block/banner/PatternType.java
deleted file mode 100644
index 25543b0..0000000
--- a/src/main/java/org/bukkit/block/banner/PatternType.java
+++ /dev/null
@@ -1,80 +0,0 @@
-package org.bukkit.block.banner;
-
-import java.util.HashMap;
-import java.util.Map;
-
-public enum PatternType {
-    BASE("b"),
-    SQUARE_BOTTOM_LEFT("bl"),
-    SQUARE_BOTTOM_RIGHT("br"),
-    SQUARE_TOP_LEFT("tl"),
-    SQUARE_TOP_RIGHT("tr"),
-    STRIPE_BOTTOM("bs"),
-    STRIPE_TOP("ts"),
-    STRIPE_LEFT("ls"),
-    STRIPE_RIGHT("rs"),
-    STRIPE_CENTER("cs"),
-    STRIPE_MIDDLE("ms"),
-    STRIPE_DOWNRIGHT("drs"),
-    STRIPE_DOWNLEFT("dls"),
-    STRIPE_SMALL("ss"),
-    CROSS("cr"),
-    STRAIGHT_CROSS("sc"),
-    TRIANGLE_BOTTOM("bt"),
-    TRIANGLE_TOP("tt"),
-    TRIANGLES_BOTTOM("bts"),
-    TRIANGLES_TOP("tts"),
-    DIAGONAL_LEFT("ld"),
-    DIAGONAL_RIGHT("rd"),
-    DIAGONAL_LEFT_MIRROR("lud"),
-    DIAGONAL_RIGHT_MIRROR("rud"),
-    CIRCLE_MIDDLE("mc"),
-    RHOMBUS_MIDDLE("mr"),
-    HALF_VERTICAL("vh"),
-    HALF_HORIZONTAL("hh"),
-    HALF_VERTICAL_MIRROR("vhr"),
-    HALF_HORIZONTAL_MIRROR("hhb"),
-    BORDER("bo"),
-    CURLY_BORDER("cbo"),
-    CREEPER("cre"),
-    GRADIENT("gra"),
-    GRADIENT_UP("gru"),
-    BRICKS("bri"),
-    SKULL("sku"),
-    FLOWER("flo"),
-    MOJANG("moj");
-
-    private final String identifier;
-    private static final Map<String, PatternType> byString = new HashMap<String, PatternType>();
-
-    static {
-        for (PatternType p : values()) {
-            byString.put(p.identifier, p);
-        }
-    }
-
-    private PatternType(String key) {
-        this.identifier = key;
-    }
-
-    /**
-     * Returns the identifier used to represent
-     * this pattern type
-     *
-     * @return the pattern's identifier
-     */
-    public String getIdentifier() {
-        return identifier;
-    }
-
-    /**
-     * Returns the pattern type which matches the passed
-     * identifier or null if no matches are found
-     *
-     * @param identifier the identifier
-     * @return the matched pattern type or null
-     */
-    public static PatternType getByIdentifier(String identifier) {
-        return byString.get(identifier);
-    }
-}
diff --git a/src/main/java/org/bukkit/boss/BarColor.java b/src/main/java/org/bukkit/boss/BarColor.java
deleted file mode 100644
index e191d9f..0000000
--- a/src/main/java/org/bukkit/boss/BarColor.java
+++ /dev/null
@@ -1,11 +0,0 @@
-package org.bukkit.boss;
-
-public enum BarColor {
-    PINK,
-    BLUE,
-    RED,
-    GREEN,
-    YELLOW,
-    PURPLE,
-    WHITE
-}
diff --git a/src/main/java/org/bukkit/boss/BarFlag.java b/src/main/java/org/bukkit/boss/BarFlag.java
deleted file mode 100644
index 69e0299..0000000
--- a/src/main/java/org/bukkit/boss/BarFlag.java
+++ /dev/null
@@ -1,17 +0,0 @@
-package org.bukkit.boss;
-
-public enum BarFlag {
-
-    /**
-     * Darkens the sky like during fighting a wither.
-     */
-    DARKEN_SKY,
-    /**
-     * Tells the client to play the Ender Dragon boss music.
-     */
-    PLAY_BOSS_MUSIC,
-    /**
-     * Creates fog around the world.
-     */
-    CREATE_FOG,
-}
diff --git a/src/main/java/org/bukkit/boss/BarStyle.java b/src/main/java/org/bukkit/boss/BarStyle.java
deleted file mode 100644
index 3e499eb..0000000
--- a/src/main/java/org/bukkit/boss/BarStyle.java
+++ /dev/null
@@ -1,24 +0,0 @@
-package org.bukkit.boss;
-
-public enum BarStyle {
-    /**
-     * Makes the boss bar solid (no segments)
-     */
-    SOLID,
-    /**
-     * Splits the boss bar into 6 segments
-     */
-    SEGMENTED_6,
-    /**
-     * Splits the boss bar into 10 segments
-     */
-    SEGMENTED_10,
-    /**
-     * Splits the boss bar into 12 segments
-     */
-    SEGMENTED_12,
-    /**
-     * Splits the boss bar into 20 segments
-     */
-    SEGMENTED_20,
-}
diff --git a/src/main/java/org/bukkit/boss/BossBar.java b/src/main/java/org/bukkit/boss/BossBar.java
deleted file mode 100644
index effc329..0000000
--- a/src/main/java/org/bukkit/boss/BossBar.java
+++ /dev/null
@@ -1,144 +0,0 @@
-package org.bukkit.boss;
-
-import org.bukkit.entity.Player;
-
-import java.util.List;
-
-public interface BossBar {
-
-    /**
-     * Returns the title of this boss bar
-     *
-     * @return the title of the bar
-     */
-    String getTitle();
-
-    /**
-     * Sets the title of this boss bar
-     *
-     * @param title the title of the bar
-     */
-    void setTitle(String title);
-
-    /**
-     * Returns the color of this boss bar
-     *
-     * @return the color of the bar
-     */
-    BarColor getColor();
-
-    /**
-     * Sets the color of this boss bar.
-     *
-     * @param color the color of the bar
-     */
-    void setColor(BarColor color);
-
-    /**
-     * Returns the style of this boss bar
-     *
-     * @return the style of the bar
-     */
-    BarStyle getStyle();
-
-    /**
-     * Sets the bar style of this boss bar
-     *
-     * @param style the style of the bar
-     */
-    void setStyle(BarStyle style);
-
-    /**
-     * Remove an existing flag on this boss bar
-     *
-     * @param flag the existing flag to remove
-     */
-    void removeFlag(BarFlag flag);
-
-    /**
-     * Add an optional flag to this boss bar
-     *
-     * @param flag an optional flag to set on the boss bar
-     */
-    void addFlag(BarFlag flag);
-
-    /**
-     * Returns whether this boss bar as the passed flag set
-     *
-     * @param flag the flag to check
-     * @return whether it has the flag
-     */
-    boolean hasFlag(BarFlag flag);
-
-    /**
-     * Sets the progress of the bar. Values should be between 0.0 (empty) and
-     * 1.0 (full)
-     *
-     * @param progress the progress of the bar
-     */
-    void setProgress(double progress);
-
-    /**
-     * Returns the progress of the bar between 0.0 and 1.0
-     *
-     * @return the progress of the bar
-     */
-    double getProgress();
-
-    /**
-     * Adds the player to this boss bar causing it to display on their screen.
-     *
-     * @param player the player to add
-     */
-    void addPlayer(Player player);
-
-    /**
-     * Removes the player from this boss bar causing it to be removed from their
-     * screen.
-     *
-     * @param player the player to remove
-     */
-    void removePlayer(Player player);
-
-    /**
-     * Removes all players from this boss bar
-     *
-     * @see #removePlayer(Player)
-     */
-    void removeAll();
-
-    /**
-     * Returns all players viewing this boss bar
-     *
-     * @return a immutable list of players
-     */
-    List<Player> getPlayers();
-
-    /**
-     * Set if the boss bar is displayed to attached players.
-     *
-     * @param visible visible status
-     */
-    void setVisible(boolean visible);
-
-    /**
-     * Return if the boss bar is displayed to attached players.
-     *
-     * @return visible status
-     */
-    boolean isVisible();
-
-    /**
-     * Shows the previously hidden boss bar to all attached players
-     * @deprecated {@link #setVisible(boolean)}
-     */
-    @Deprecated
-    void show();
-
-    /**
-     * Hides this boss bar from all attached players
-     * @deprecated {@link #setVisible(boolean)}
-     */
-    @Deprecated
-    void hide();
-}
diff --git a/src/main/java/org/bukkit/command/BlockCommandSender.java b/src/main/java/org/bukkit/command/BlockCommandSender.java
deleted file mode 100644
index ce229d2..0000000
--- a/src/main/java/org/bukkit/command/BlockCommandSender.java
+++ /dev/null
@@ -1,13 +0,0 @@
-package org.bukkit.command;
-
-import org.bukkit.block.Block;
-
-public interface BlockCommandSender extends CommandSender {
-
-    /**
-     * Returns the block this command sender belongs to
-     *
-     * @return Block for the command sender
-     */
-    public Block getBlock();
-}
diff --git a/src/main/java/org/bukkit/command/Command.java b/src/main/java/org/bukkit/command/Command.java
deleted file mode 100644
index a02c28d..0000000
--- a/src/main/java/org/bukkit/command/Command.java
+++ /dev/null
@@ -1,423 +0,0 @@
-package org.bukkit.command;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-import java.util.Set;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.Bukkit;
-import org.bukkit.ChatColor;
-import org.bukkit.Server;
-import org.bukkit.entity.Player;
-import org.bukkit.entity.minecart.CommandMinecart;
-import org.bukkit.permissions.Permissible;
-import org.bukkit.plugin.PluginDescriptionFile;
-import org.bukkit.util.StringUtil;
-
-import com.google.common.collect.ImmutableList;
-
-/**
- * Represents a Command, which executes various tasks upon user input
- */
-public abstract class Command {
-    private String name;
-    private String nextLabel;
-    private String label;
-    private List<String> aliases;
-    private List<String> activeAliases;
-    private CommandMap commandMap = null;
-    protected String description = "";
-    protected String usageMessage;
-    private String permission;
-    private String permissionMessage;
-
-    protected Command(String name) {
-        this(name, "", "/" + name, new ArrayList<String>());
-    }
-
-    protected Command(String name, String description, String usageMessage, List<String> aliases) {
-        this.name = name;
-        this.nextLabel = name;
-        this.label = name;
-        this.description = description;
-        this.usageMessage = usageMessage;
-        this.aliases = aliases;
-        this.activeAliases = new ArrayList<String>(aliases);
-    }
-
-    /**
-     * Executes the command, returning its success
-     *
-     * @param sender Source object which is executing this command
-     * @param commandLabel The alias of the command used
-     * @param args All arguments passed to the command, split via ' '
-     * @return true if the command was successful, otherwise false
-     */
-    public abstract boolean execute(CommandSender sender, String commandLabel, String[] args);
-
-    /**
-     * Executed on tab completion for this command, returning a list of
-     * options the player can tab through.
-     *
-     * @deprecated This method is not supported and returns null
-     * @param sender Source object which is executing this command
-     * @param args All arguments passed to the command, split via ' '
-     * @return a list of tab-completions for the specified arguments. This
-     *     will never be null. List may be immutable.
-     */
-    @Deprecated
-    public List<String> tabComplete(CommandSender sender, String[] args) {
-        return null;
-    }
-
-    /**
-     * Executed on tab completion for this command, returning a list of
-     * options the player can tab through.
-     *
-     * @param sender Source object which is executing this command
-     * @param alias the alias being used
-     * @param args All arguments passed to the command, split via ' '
-     * @return a list of tab-completions for the specified arguments. This
-     *     will never be null. List may be immutable.
-     * @throws IllegalArgumentException if sender, alias, or args is null
-     */
-    public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {
-        Validate.notNull(sender, "Sender cannot be null");
-        Validate.notNull(args, "Arguments cannot be null");
-        Validate.notNull(alias, "Alias cannot be null");
-
-        if (args.length == 0) {
-            return ImmutableList.of();
-        }
-
-        String lastWord = args[args.length - 1];
-
-        Player senderPlayer = sender instanceof Player ? (Player) sender : null;
-
-        ArrayList<String> matchedPlayers = new ArrayList<String>();
-        for (Player player : sender.getServer().getOnlinePlayers()) {
-            String name = player.getName();
-            if ((senderPlayer == null || senderPlayer.canSee(player)) && StringUtil.startsWithIgnoreCase(name, lastWord)) {
-                matchedPlayers.add(name);
-            }
-        }
-
-        Collections.sort(matchedPlayers, String.CASE_INSENSITIVE_ORDER);
-        return matchedPlayers;
-    }
-
-    /**
-     * Returns the name of this command
-     *
-     * @return Name of this command
-     */
-    public String getName() {
-        return name;
-    }
-
-    /**
-     * Sets the name of this command.
-     * <p>
-     * May only be used before registering the command.
-     * Will return true if the new name is set, and false
-     * if the command has already been registered.
-     *
-     * @param name New command name
-     * @return returns true if the name change happened instantly or false if
-     *     the command was already registered
-     */
-    public boolean setName(String name) {
-        if (!isRegistered()) {
-            this.name = name;
-            return true;
-        }
-        return false;
-    }
-
-    /**
-     * Gets the permission required by users to be able to perform this
-     * command
-     *
-     * @return Permission name, or null if none
-     */
-    public String getPermission() {
-        return permission;
-    }
-
-    /**
-     * Sets the permission required by users to be able to perform this
-     * command
-     *
-     * @param permission Permission name or null
-     */
-    public void setPermission(String permission) {
-        this.permission = permission;
-    }
-
-    /**
-     * Tests the given {@link CommandSender} to see if they can perform this
-     * command.
-     * <p>
-     * If they do not have permission, they will be informed that they cannot
-     * do this.
-     *
-     * @param target User to test
-     * @return true if they can use it, otherwise false
-     */
-    public boolean testPermission(CommandSender target) {
-        if (testPermissionSilent(target)) {
-            return true;
-        }
-
-        if (permissionMessage == null) {
-            target.sendMessage(ChatColor.RED + "I'm sorry, but you do not have permission to perform this command. Please contact the server administrators if you believe that this is in error.");
-        } else if (permissionMessage.length() != 0) {
-            for (String line : permissionMessage.replace("<permission>", permission).split("\n")) {
-                target.sendMessage(line);
-            }
-        }
-
-        return false;
-    }
-
-    /**
-     * Tests the given {@link CommandSender} to see if they can perform this
-     * command.
-     * <p>
-     * No error is sent to the sender.
-     *
-     * @param target User to test
-     * @return true if they can use it, otherwise false
-     */
-    public boolean testPermissionSilent(CommandSender target) {
-        if ((permission == null) || (permission.length() == 0)) {
-            return true;
-        }
-
-        for (String p : permission.split(";")) {
-            if (target.hasPermission(p)) {
-                return true;
-            }
-        }
-
-        return false;
-    }
-
-    /**
-     * Returns the label for this command
-     *
-     * @return Label of this command
-     */
-    public String getLabel() {
-        return label;
-    }
-
-    /**
-     * Sets the label of this command.
-     * <p>
-     * May only be used before registering the command.
-     * Will return true if the new name is set, and false
-     * if the command has already been registered.
-     *
-     * @param name The command's name
-     * @return returns true if the name change happened instantly or false if
-     *     the command was already registered
-     */
-    public boolean setLabel(String name) {
-        this.nextLabel = name;
-        if (!isRegistered()) {
-            this.label = name;
-            return true;
-        }
-        return false;
-    }
-
-    /**
-     * Registers this command to a CommandMap.
-     * Once called it only allows changes the registered CommandMap
-     *
-     * @param commandMap the CommandMap to register this command to
-     * @return true if the registration was successful (the current registered
-     *     CommandMap was the passed CommandMap or null) false otherwise
-     */
-    public boolean register(CommandMap commandMap) {
-        if (allowChangesFrom(commandMap)) {
-            this.commandMap = commandMap;
-            return true;
-        }
-
-        return false;
-    }
-
-    /**
-     * Unregisters this command from the passed CommandMap applying any
-     * outstanding changes
-     *
-     * @param commandMap the CommandMap to unregister
-     * @return true if the unregistration was successfull (the current
-     *     registered CommandMap was the passed CommandMap or null) false
-     *     otherwise
-     */
-    public boolean unregister(CommandMap commandMap) {
-        if (allowChangesFrom(commandMap)) {
-            this.commandMap = null;
-            this.activeAliases = new ArrayList<String>(this.aliases);
-            this.label = this.nextLabel;
-            return true;
-        }
-
-        return false;
-    }
-
-    private boolean allowChangesFrom(CommandMap commandMap) {
-        return (null == this.commandMap || this.commandMap == commandMap);
-    }
-
-    /**
-     * Returns the current registered state of this command
-     *
-     * @return true if this command is currently registered false otherwise
-     */
-    public boolean isRegistered() {
-        return (null != this.commandMap);
-    }
-
-    /**
-     * Returns a list of active aliases of this command
-     *
-     * @return List of aliases
-     */
-    public List<String> getAliases() {
-        return activeAliases;
-    }
-
-    /**
-     * Returns a message to be displayed on a failed permission check for this
-     * command
-     *
-     * @return Permission check failed message
-     */
-    public String getPermissionMessage() {
-        return permissionMessage;
-    }
-
-    /**
-     * Gets a brief description of this command
-     *
-     * @return Description of this command
-     */
-    public String getDescription() {
-        return description;
-    }
-
-    /**
-     * Gets an example usage of this command
-     *
-     * @return One or more example usages
-     */
-    public String getUsage() {
-        return usageMessage;
-    }
-
-    /**
-     * Sets the list of aliases to request on registration for this command.
-     * This is not effective outside of defining aliases in the {@link
-     * PluginDescriptionFile#getCommands()} (under the
-     * `<code>aliases</code>' node) is equivalent to this method.
-     *
-     * @param aliases aliases to register to this command
-     * @return this command object, for chaining
-     */
-    public Command setAliases(List<String> aliases) {
-        this.aliases = aliases;
-        if (!isRegistered()) {
-            this.activeAliases = new ArrayList<String>(aliases);
-        }
-        return this;
-    }
-
-    /**
-     * Sets a brief description of this command. Defining a description in the
-     * {@link PluginDescriptionFile#getCommands()} (under the
-     * `<code>description</code>' node) is equivalent to this method.
-     *
-     * @param description new command description
-     * @return this command object, for chaining
-     */
-    public Command setDescription(String description) {
-        this.description = description;
-        return this;
-    }
-
-    /**
-     * Sets the message sent when a permission check fails
-     *
-     * @param permissionMessage new permission message, null to indicate
-     *     default message, or an empty string to indicate no message
-     * @return this command object, for chaining
-     */
-    public Command setPermissionMessage(String permissionMessage) {
-        this.permissionMessage = permissionMessage;
-        return this;
-    }
-
-    /**
-     * Sets the example usage of this command
-     *
-     * @param usage new example usage
-     * @return this command object, for chaining
-     */
-    public Command setUsage(String usage) {
-        this.usageMessage = usage;
-        return this;
-    }
-
-    public static void broadcastCommandMessage(CommandSender source, String message) {
-        broadcastCommandMessage(source, message, true);
-    }
-
-    public static void broadcastCommandMessage(CommandSender source, String message, boolean sendToSource) {
-        String result = source.getName() + ": " + message;
-
-        if (source instanceof BlockCommandSender) {
-            BlockCommandSender blockCommandSender = (BlockCommandSender) source;
-
-            if (blockCommandSender.getBlock().getWorld().getGameRuleValue("commandBlockOutput").equalsIgnoreCase("false")) {
-                Bukkit.getConsoleSender().sendMessage(result);
-                return;
-            }
-        } else if (source instanceof CommandMinecart) {
-            CommandMinecart commandMinecart = (CommandMinecart) source;
-
-            if (commandMinecart.getWorld().getGameRuleValue("commandBlockOutput").equalsIgnoreCase("false")) {
-                Bukkit.getConsoleSender().sendMessage(result);
-                return;
-            }
-        }
-
-        Set<Permissible> users = Bukkit.getPluginManager().getPermissionSubscriptions(Server.BROADCAST_CHANNEL_ADMINISTRATIVE);
-        String colored = ChatColor.GRAY + "" + ChatColor.ITALIC + "[" + result + ChatColor.GRAY + ChatColor.ITALIC + "]";
-
-        if (sendToSource && !(source instanceof ConsoleCommandSender)) {
-            source.sendMessage(message);
-        }
-
-        for (Permissible user : users) {
-            if (user instanceof CommandSender) {
-                CommandSender target = (CommandSender) user;
-
-                if (target instanceof ConsoleCommandSender) {
-                    target.sendMessage(result);
-                } else if (target != source) {
-                    target.sendMessage(colored);
-                }
-            }
-        }
-    }
-
-    @Override
-    public String toString() {
-        return getClass().getName() + '(' + name + ')';
-    }
-}
diff --git a/src/main/java/org/bukkit/command/CommandException.java b/src/main/java/org/bukkit/command/CommandException.java
deleted file mode 100644
index b63015f..0000000
--- a/src/main/java/org/bukkit/command/CommandException.java
+++ /dev/null
@@ -1,28 +0,0 @@
-package org.bukkit.command;
-
-/**
- * Thrown when an unhandled exception occurs during the execution of a Command
- */
-@SuppressWarnings("serial")
-public class CommandException extends RuntimeException {
-
-    /**
-     * Creates a new instance of <code>CommandException</code> without detail
-     * message.
-     */
-    public CommandException() {}
-
-    /**
-     * Constructs an instance of <code>CommandException</code> with the
-     * specified detail message.
-     *
-     * @param msg the detail message.
-     */
-    public CommandException(String msg) {
-        super(msg);
-    }
-
-    public CommandException(String msg, Throwable cause) {
-        super(msg, cause);
-    }
-}
diff --git a/src/main/java/org/bukkit/command/CommandExecutor.java b/src/main/java/org/bukkit/command/CommandExecutor.java
deleted file mode 100644
index c75586f..0000000
--- a/src/main/java/org/bukkit/command/CommandExecutor.java
+++ /dev/null
@@ -1,18 +0,0 @@
-package org.bukkit.command;
-
-/**
- * Represents a class which contains a single method for executing commands
- */
-public interface CommandExecutor {
-
-    /**
-     * Executes the given command, returning its success
-     *
-     * @param sender Source of the command
-     * @param command Command which was executed
-     * @param label Alias of the command which was used
-     * @param args Passed command arguments
-     * @return true if a valid command, otherwise false
-     */
-    public boolean onCommand(CommandSender sender, Command command, String label, String[] args);
-}
diff --git a/src/main/java/org/bukkit/command/CommandMap.java b/src/main/java/org/bukkit/command/CommandMap.java
deleted file mode 100644
index e7e20d8..0000000
--- a/src/main/java/org/bukkit/command/CommandMap.java
+++ /dev/null
@@ -1,109 +0,0 @@
-package org.bukkit.command;
-
-import java.util.List;
-
-public interface CommandMap {
-
-    /**
-     * Registers all the commands belonging to a certain plugin.
-     * <p>
-     * Caller can use:-
-     * <ul>
-     * <li>command.getName() to determine the label registered for this
-     *     command
-     * <li>command.getAliases() to determine the aliases which where
-     *     registered
-     * </ul>
-     *
-     * @param fallbackPrefix a prefix which is prepended to each command with
-     *     a ':' one or more times to make the command unique
-     * @param commands a list of commands to register
-     */
-    public void registerAll(String fallbackPrefix, List<Command> commands);
-
-    /**
-     * Registers a command. Returns true on success; false if name is already
-     * taken and fallback had to be used.
-     * <p>
-     * Caller can use:-
-     * <ul>
-     * <li>command.getName() to determine the label registered for this
-     *     command
-     * <li>command.getAliases() to determine the aliases which where
-     *     registered
-     * </ul>
-     *
-     * @param label the label of the command, without the '/'-prefix.
-     * @param fallbackPrefix a prefix which is prepended to the command with a
-     *     ':' one or more times to make the command unique
-     * @param command the command to register
-     * @return true if command was registered with the passed in label, false
-     *     otherwise, which indicates the fallbackPrefix was used one or more
-     *     times
-     */
-    public boolean register(String label, String fallbackPrefix, Command command);
-
-    /**
-     * Registers a command. Returns true on success; false if name is already
-     * taken and fallback had to be used.
-     * <p>
-     * Caller can use:-
-     * <ul>
-     * <li>command.getName() to determine the label registered for this
-     *     command
-     * <li>command.getAliases() to determine the aliases which where
-     *     registered
-     * </ul>
-     *
-     * @param fallbackPrefix a prefix which is prepended to the command with a
-     *     ':' one or more times to make the command unique
-     * @param command the command to register, from which label is determined
-     *     from the command name
-     * @return true if command was registered with the passed in label, false
-     *     otherwise, which indicates the fallbackPrefix was used one or more
-     *     times
-     */
-    public boolean register(String fallbackPrefix, Command command);
-
-    /**
-     * Looks for the requested command and executes it if found.
-     *
-     * @param sender The command's sender
-     * @param cmdLine command + arguments. Example: "/test abc 123"
-     * @return returns false if no target is found, true otherwise.
-     * @throws CommandException Thrown when the executor for the given command
-     *     fails with an unhandled exception
-     */
-    public boolean dispatch(CommandSender sender, String cmdLine) throws CommandException;
-
-    /**
-     * Clears all registered commands.
-     */
-    public void clearCommands();
-
-    /**
-     * Gets the command registered to the specified name
-     *
-     * @param name Name of the command to retrieve
-     * @return Command with the specified name or null if a command with that
-     *     label doesn't exist
-     */
-    public Command getCommand(String name);
-
-
-    /**
-     * Looks for the requested command and executes an appropriate
-     * tab-completer if found. This method will also tab-complete partial
-     * commands.
-     *
-     * @param sender The command's sender.
-     * @param cmdLine The entire command string to tab-complete, excluding
-     *     initial slash.
-     * @return a list of possible tab-completions. This list may be immutable.
-     *     Will be null if no matching command of which sender has permission.
-     * @throws CommandException Thrown when the tab-completer for the given
-     *     command fails with an unhandled exception
-     * @throws IllegalArgumentException if either sender or cmdLine are null
-     */
-    public List<String> tabComplete(CommandSender sender, String cmdLine) throws IllegalArgumentException;
-}
diff --git a/src/main/java/org/bukkit/command/CommandSender.java b/src/main/java/org/bukkit/command/CommandSender.java
deleted file mode 100644
index 148756b..0000000
--- a/src/main/java/org/bukkit/command/CommandSender.java
+++ /dev/null
@@ -1,35 +0,0 @@
-package org.bukkit.command;
-
-import org.bukkit.Server;
-import org.bukkit.permissions.Permissible;
-
-public interface CommandSender extends Permissible {
-
-    /**
-     * Sends this sender a message
-     *
-     * @param message Message to be displayed
-     */
-    public void sendMessage(String message);
-
-    /**
-     * Sends this sender multiple messages
-     *
-     * @param messages An array of messages to be displayed
-     */
-    public void sendMessage(String[] messages);
-
-    /**
-     * Returns the server instance that this command is running on
-     *
-     * @return Server instance
-     */
-    public Server getServer();
-
-    /**
-     * Gets the name of this command sender
-     *
-     * @return Name of the sender
-     */
-    public String getName();
-}
diff --git a/src/main/java/org/bukkit/command/ConsoleCommandSender.java b/src/main/java/org/bukkit/command/ConsoleCommandSender.java
deleted file mode 100644
index f309c2e..0000000
--- a/src/main/java/org/bukkit/command/ConsoleCommandSender.java
+++ /dev/null
@@ -1,6 +0,0 @@
-package org.bukkit.command;
-
-import org.bukkit.conversations.Conversable;
-
-public interface ConsoleCommandSender extends CommandSender, Conversable {
-}
diff --git a/src/main/java/org/bukkit/command/FormattedCommandAlias.java b/src/main/java/org/bukkit/command/FormattedCommandAlias.java
deleted file mode 100644
index 3f07d7f..0000000
--- a/src/main/java/org/bukkit/command/FormattedCommandAlias.java
+++ /dev/null
@@ -1,124 +0,0 @@
-package org.bukkit.command;
-
-import java.util.ArrayList;
-import java.util.logging.Level;
-
-import org.bukkit.Bukkit;
-import org.bukkit.entity.Player;
-import org.bukkit.event.player.PlayerCommandPreprocessEvent;
-import org.bukkit.event.server.RemoteServerCommandEvent;
-import org.bukkit.event.server.ServerCommandEvent;
-
-public class FormattedCommandAlias extends Command {
-    private final String[] formatStrings;
-
-    public FormattedCommandAlias(String alias, String[] formatStrings) {
-        super(alias);
-        this.formatStrings = formatStrings;
-    }
-
-    @Override
-    public boolean execute(CommandSender sender, String commandLabel, String[] args) {
-        boolean result = false;
-        ArrayList<String> commands = new ArrayList<String>();
-        for (String formatString : formatStrings) {
-            try {
-                commands.add(buildCommand(formatString, args));
-            } catch (Throwable throwable) {
-                if (throwable instanceof IllegalArgumentException) {
-                    sender.sendMessage(throwable.getMessage());
-                } else {
-                    sender.sendMessage(org.bukkit.ChatColor.RED + "An internal error occurred while attempting to perform this command");
-                }
-                return false;
-            }
-        }
-
-        for (String command : commands) {
-            result |= Bukkit.dispatchCommand(sender, command);
-        }
-
-        return result;
-    }
-
-    private String buildCommand(String formatString, String[] args) {
-        int index = formatString.indexOf("$");
-        while (index != -1) {
-            int start = index;
-
-            if (index > 0 && formatString.charAt(start - 1) == '\\') {
-                formatString = formatString.substring(0, start - 1) + formatString.substring(start);
-                index = formatString.indexOf("$", index);
-                continue;
-            }
-
-            boolean required = false;
-            if (formatString.charAt(index + 1) == '$') {
-                required = true;
-                // Move index past the second $
-                index++;
-            }
-
-            // Move index past the $
-            index++;
-            int argStart = index;
-            while (index < formatString.length() && inRange(((int) formatString.charAt(index)) - 48, 0, 9)) {
-                // Move index past current digit
-                index++;
-            }
-
-            // No numbers found
-            if (argStart == index) {
-                throw new IllegalArgumentException("Invalid replacement token");
-            }
-
-            int position = Integer.valueOf(formatString.substring(argStart, index));
-
-            // Arguments are not 0 indexed
-            if (position == 0) {
-                throw new IllegalArgumentException("Invalid replacement token");
-            }
-
-            // Convert position to 0 index
-            position--;
-
-            boolean rest = false;
-            if (index < formatString.length() && formatString.charAt(index) == '-') {
-                rest = true;
-                // Move index past the -
-                index++;
-            }
-
-            int end = index;
-
-            if (required && position >= args.length) {
-                throw new IllegalArgumentException("Missing required argument " + (position + 1));
-            }
-
-            StringBuilder replacement = new StringBuilder();
-            if (rest && position < args.length) {
-                for (int i = position; i < args.length; i++) {
-                    if (i != position) {
-                        replacement.append(' ');
-                    }
-                    replacement.append(args[i]);
-                }
-            } else if (position < args.length) {
-                replacement.append(args[position]);
-            }
-
-            formatString = formatString.substring(0, start) + replacement.toString() + formatString.substring(end);
-            // Move index past the replaced data so we don't process it again
-            index = start + replacement.length();
-
-            // Move to the next replacement token
-            index = formatString.indexOf("$", index);
-        }
-
-        return formatString;
-    }
-
-    private static boolean inRange(int i, int j, int k) {
-        return i >= j && i <= k;
-    }
-}
diff --git a/src/main/java/org/bukkit/command/MultipleCommandAlias.java b/src/main/java/org/bukkit/command/MultipleCommandAlias.java
deleted file mode 100644
index a0a4129..0000000
--- a/src/main/java/org/bukkit/command/MultipleCommandAlias.java
+++ /dev/null
@@ -1,33 +0,0 @@
-package org.bukkit.command;
-
-/**
- * Represents a command that delegates to one or more other commands
- */
-public class MultipleCommandAlias extends Command {
-    private Command[] commands;
-
-    public MultipleCommandAlias(String name, Command[] commands) {
-        super(name);
-        this.commands = commands;
-    }
-
-    /**
-     * Gets the commands associated with the multi-command alias.
-     *
-     * @return commands associated with alias
-     */
-    public Command[] getCommands() {
-        return commands;
-    }
-
-    @Override
-    public boolean execute(CommandSender sender, String commandLabel, String[] args) {
-        boolean result = false;
-
-        for (Command command : commands) {
-            result |= command.execute(sender, commandLabel, args);
-        }
-
-        return result;
-    }
-}
diff --git a/src/main/java/org/bukkit/command/PluginCommand.java b/src/main/java/org/bukkit/command/PluginCommand.java
deleted file mode 100644
index 3bfa31f..0000000
--- a/src/main/java/org/bukkit/command/PluginCommand.java
+++ /dev/null
@@ -1,160 +0,0 @@
-package org.bukkit.command;
-
-import java.util.List;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.plugin.Plugin;
-
-/**
- * Represents a {@link Command} belonging to a plugin
- */
-public final class PluginCommand extends Command implements PluginIdentifiableCommand {
-    private final Plugin owningPlugin;
-    private CommandExecutor executor;
-    private TabCompleter completer;
-
-    protected PluginCommand(String name, Plugin owner) {
-        super(name);
-        this.executor = owner;
-        this.owningPlugin = owner;
-        this.usageMessage = "";
-    }
-
-    /**
-     * Executes the command, returning its success
-     *
-     * @param sender Source object which is executing this command
-     * @param commandLabel The alias of the command used
-     * @param args All arguments passed to the command, split via ' '
-     * @return true if the command was successful, otherwise false
-     */
-    @Override
-    public boolean execute(CommandSender sender, String commandLabel, String[] args) {
-        boolean success = false;
-
-        if (!owningPlugin.isEnabled()) {
-            return false;
-        }
-
-        if (!testPermission(sender)) {
-            return true;
-        }
-
-        try {
-            success = executor.onCommand(sender, this, commandLabel, args);
-        } catch (Throwable ex) {
-            throw new CommandException("Unhandled exception executing command '" + commandLabel + "' in plugin " + owningPlugin.getDescription().getFullName(), ex);
-        }
-
-        if (!success && usageMessage.length() > 0) {
-            for (String line : usageMessage.replace("<command>", commandLabel).split("\n")) {
-                sender.sendMessage(line);
-            }
-        }
-
-        return success;
-    }
-
-    /**
-     * Sets the {@link CommandExecutor} to run when parsing this command
-     *
-     * @param executor New executor to run
-     */
-    public void setExecutor(CommandExecutor executor) {
-        this.executor = executor == null ? owningPlugin : executor;
-    }
-
-    /**
-     * Gets the {@link CommandExecutor} associated with this command
-     *
-     * @return CommandExecutor object linked to this command
-     */
-    public CommandExecutor getExecutor() {
-        return executor;
-    }
-
-    /**
-     * Sets the {@link TabCompleter} to run when tab-completing this command.
-     * <p>
-     * If no TabCompleter is specified, and the command's executor implements
-     * TabCompleter, then the executor will be used for tab completion.
-     *
-     * @param completer New tab completer
-     */
-    public void setTabCompleter(TabCompleter completer) {
-        this.completer = completer;
-    }
-
-    /**
-     * Gets the {@link TabCompleter} associated with this command.
-     *
-     * @return TabCompleter object linked to this command
-     */
-    public TabCompleter getTabCompleter() {
-        return completer;
-    }
-
-    /**
-     * Gets the owner of this PluginCommand
-     *
-     * @return Plugin that owns this command
-     */
-    public Plugin getPlugin() {
-        return owningPlugin;
-    }
-
-    /**
-     * {@inheritDoc}
-     * <p>
-     * Delegates to the tab completer if present.
-     * <p>
-     * If it is not present or returns null, will delegate to the current
-     * command executor if it implements {@link TabCompleter}. If a non-null
-     * list has not been found, will default to standard player name
-     * completion in {@link
-     * Command#tabComplete(CommandSender, String, String[])}.
-     * <p>
-     * This method does not consider permissions.
-     *
-     * @throws CommandException if the completer or executor throw an
-     *     exception during the process of tab-completing.
-     * @throws IllegalArgumentException if sender, alias, or args is null
-     */
-    @Override
-    public java.util.List<String> tabComplete(CommandSender sender, String alias, String[] args) throws CommandException, IllegalArgumentException {
-        Validate.notNull(sender, "Sender cannot be null");
-        Validate.notNull(args, "Arguments cannot be null");
-        Validate.notNull(alias, "Alias cannot be null");
-
-        List<String> completions = null;
-        try {
-            if (completer != null) {
-                completions = completer.onTabComplete(sender, this, alias, args);
-            }
-            if (completions == null && executor instanceof TabCompleter) {
-                completions = ((TabCompleter) executor).onTabComplete(sender, this, alias, args);
-            }
-        } catch (Throwable ex) {
-            StringBuilder message = new StringBuilder();
-            message.append("Unhandled exception during tab completion for command '/").append(alias).append(' ');
-            for (String arg : args) {
-                message.append(arg).append(' ');
-            }
-            message.deleteCharAt(message.length() - 1).append("' in plugin ").append(owningPlugin.getDescription().getFullName());
-            throw new CommandException(message.toString(), ex);
-        }
-
-        if (completions == null) {
-            return super.tabComplete(sender, alias, args);
-        }
-        return completions;
-    }
-
-    @Override
-    public String toString() {
-        StringBuilder stringBuilder = new StringBuilder(super.toString());
-        stringBuilder.deleteCharAt(stringBuilder.length() - 1);
-        stringBuilder.append(", ").append(owningPlugin.getDescription().getFullName()).append(')');
-        return stringBuilder.toString();
-    }
-}
diff --git a/src/main/java/org/bukkit/command/PluginCommandYamlParser.java b/src/main/java/org/bukkit/command/PluginCommandYamlParser.java
deleted file mode 100644
index 5854583..0000000
--- a/src/main/java/org/bukkit/command/PluginCommandYamlParser.java
+++ /dev/null
@@ -1,76 +0,0 @@
-package org.bukkit.command;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Map;
-import java.util.Map.Entry;
-
-import org.bukkit.Bukkit;
-import org.bukkit.plugin.Plugin;
-
-public class PluginCommandYamlParser {
-
-    public static List<Command> parse(Plugin plugin) {
-        List<Command> pluginCmds = new ArrayList<Command>();
-
-        Map<String, Map<String, Object>> map = plugin.getDescription().getCommands();
-
-        if (map == null) {
-            return pluginCmds;
-        }
-
-        for (Entry<String, Map<String, Object>> entry : map.entrySet()) {
-            if (entry.getKey().contains(":")) {
-                Bukkit.getServer().getLogger().severe("Could not load command " + entry.getKey() + " for plugin " + plugin.getName() + ": Illegal Characters");
-                continue;
-            }
-            Command newCmd = new PluginCommand(entry.getKey(), plugin);
-            Object description = entry.getValue().get("description");
-            Object usage = entry.getValue().get("usage");
-            Object aliases = entry.getValue().get("aliases");
-            Object permission = entry.getValue().get("permission");
-            Object permissionMessage = entry.getValue().get("permission-message");
-
-            if (description != null) {
-                newCmd.setDescription(description.toString());
-            }
-
-            if (usage != null) {
-                newCmd.setUsage(usage.toString());
-            }
-
-            if (aliases != null) {
-                List<String> aliasList = new ArrayList<String>();
-
-                if (aliases instanceof List) {
-                    for (Object o : (List<?>) aliases) {
-                        if (o.toString().contains(":")) {
-                            Bukkit.getServer().getLogger().severe("Could not load alias " + o.toString() + " for plugin " + plugin.getName() + ": Illegal Characters");
-                            continue;
-                        }
-                        aliasList.add(o.toString());
-                    }
-                } else {
-                    if (aliases.toString().contains(":")) {
-                        Bukkit.getServer().getLogger().severe("Could not load alias " + aliases.toString() + " for plugin " + plugin.getName() + ": Illegal Characters");
-                    } else {
-                        aliasList.add(aliases.toString());
-                    }
-                }
-
-                newCmd.setAliases(aliasList);
-            }
-
-            if (permission != null) {
-                newCmd.setPermission(permission.toString());
-            }
-
-            if (permissionMessage != null) {
-                newCmd.setPermissionMessage(permissionMessage.toString());
-            }
-
-            pluginCmds.add(newCmd);
-        }
-        return pluginCmds;
-    }
-}
diff --git a/src/main/java/org/bukkit/command/PluginIdentifiableCommand.java b/src/main/java/org/bukkit/command/PluginIdentifiableCommand.java
deleted file mode 100644
index c5e0d2c..0000000
--- a/src/main/java/org/bukkit/command/PluginIdentifiableCommand.java
+++ /dev/null
@@ -1,19 +0,0 @@
-package org.bukkit.command;
-
-import org.bukkit.plugin.Plugin;
-
-/**
- * This interface is used by the help system to group commands into
- * sub-indexes based on the {@link Plugin} they are a part of. Custom command
- * implementations will need to implement this interface to have a sub-index
- * automatically generated on the plugin's behalf.
- */
-public interface PluginIdentifiableCommand {
-
-    /**
-     * Gets the owner of this PluginIdentifiableCommand.
-     *
-     * @return Plugin that owns this PluginIdentifiableCommand.
-     */
-    public Plugin getPlugin();
-}
diff --git a/src/main/java/org/bukkit/command/ProxiedCommandSender.java b/src/main/java/org/bukkit/command/ProxiedCommandSender.java
deleted file mode 100644
index 24c4eba..0000000
--- a/src/main/java/org/bukkit/command/ProxiedCommandSender.java
+++ /dev/null
@@ -1,20 +0,0 @@
-
-package org.bukkit.command;
-
-public interface ProxiedCommandSender extends CommandSender {
-
-    /**
-     * Returns the CommandSender which triggered this proxied command
-     *
-     * @return the caller which triggered the command
-     */
-    CommandSender getCaller();
-
-    /**
-     * Returns the CommandSender which is being used to call the command
-     *
-     * @return the caller which the command is being run as
-     */
-    CommandSender getCallee();
-
-}
diff --git a/src/main/java/org/bukkit/command/RemoteConsoleCommandSender.java b/src/main/java/org/bukkit/command/RemoteConsoleCommandSender.java
deleted file mode 100644
index dc3bc1d..0000000
--- a/src/main/java/org/bukkit/command/RemoteConsoleCommandSender.java
+++ /dev/null
@@ -1,4 +0,0 @@
-package org.bukkit.command;
-
-public interface RemoteConsoleCommandSender extends CommandSender {
-}
diff --git a/src/main/java/org/bukkit/command/SimpleCommandMap.java b/src/main/java/org/bukkit/command/SimpleCommandMap.java
deleted file mode 100644
index a229d08..0000000
--- a/src/main/java/org/bukkit/command/SimpleCommandMap.java
+++ /dev/null
@@ -1,261 +0,0 @@
-package org.bukkit.command;
-
-import static org.bukkit.util.Java15Compat.Arrays_copyOfRange;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.regex.Pattern;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.Server;
-import org.bukkit.command.defaults.*;
-import org.bukkit.entity.Player;
-import org.bukkit.util.StringUtil;
-
-public class SimpleCommandMap implements CommandMap {
-    private static final Pattern PATTERN_ON_SPACE = Pattern.compile(" ", Pattern.LITERAL);
-    protected final Map<String, Command> knownCommands = new HashMap<String, Command>();
-    private final Server server;
-
-    public SimpleCommandMap(final Server server) {
-        this.server = server;
-        setDefaultCommands();
-    }
-
-    private void setDefaultCommands() {
-        register("bukkit", new VersionCommand("version"));
-        register("bukkit", new ReloadCommand("reload"));
-        register("bukkit", new PluginsCommand("plugins"));
-        register("bukkit", new TimingsCommand("timings"));
-    }
-
-    public void setFallbackCommands() {
-        register("bukkit", new HelpCommand());
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public void registerAll(String fallbackPrefix, List<Command> commands) {
-        if (commands != null) {
-            for (Command c : commands) {
-                register(fallbackPrefix, c);
-            }
-        }
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public boolean register(String fallbackPrefix, Command command) {
-        return register(command.getName(), fallbackPrefix, command);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public boolean register(String label, String fallbackPrefix, Command command) {
-        label = label.toLowerCase().trim();
-        fallbackPrefix = fallbackPrefix.toLowerCase().trim();
-        boolean registered = register(label, command, false, fallbackPrefix);
-
-        Iterator<String> iterator = command.getAliases().iterator();
-        while (iterator.hasNext()) {
-            if (!register(iterator.next(), command, true, fallbackPrefix)) {
-                iterator.remove();
-            }
-        }
-
-        // If we failed to register under the real name, we need to set the command label to the direct address
-        if (!registered) {
-            command.setLabel(fallbackPrefix + ":" + label);
-        }
-
-        // Register to us so further updates of the commands label and aliases are postponed until its reregistered
-        command.register(this);
-
-        return registered;
-    }
-
-    /**
-     * Registers a command with the given name is possible. Also uses
-     * fallbackPrefix to create a unique name.
-     *
-     * @param label the name of the command, without the '/'-prefix.
-     * @param command the command to register
-     * @param isAlias whether the command is an alias
-     * @param fallbackPrefix a prefix which is prepended to the command for a
-     *     unique address
-     * @return true if command was registered, false otherwise.
-     */
-    private synchronized boolean register(String label, Command command, boolean isAlias, String fallbackPrefix) {
-        knownCommands.put(fallbackPrefix + ":" + label, command);
-        if ((command instanceof VanillaCommand || isAlias) && knownCommands.containsKey(label)) {
-            // Request is for an alias/fallback command and it conflicts with
-            // a existing command or previous alias ignore it
-            // Note: This will mean it gets removed from the commands list of active aliases
-            return false;
-        }
-
-        boolean registered = true;
-
-        // If the command exists but is an alias we overwrite it, otherwise we return
-        Command conflict = knownCommands.get(label);
-        if (conflict != null && conflict.getLabel().equals(label)) {
-            return false;
-        }
-
-        if (!isAlias) {
-            command.setLabel(label);
-        }
-        knownCommands.put(label, command);
-
-        return registered;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public boolean dispatch(CommandSender sender, String commandLine) throws CommandException {
-        String[] args = PATTERN_ON_SPACE.split(commandLine);
-
-        if (args.length == 0) {
-            return false;
-        }
-
-        String sentCommandLabel = args[0].toLowerCase();
-        Command target = getCommand(sentCommandLabel);
-
-        if (target == null) {
-            return false;
-        }
-
-        try {
-            // Note: we don't return the result of target.execute as thats success / failure, we return handled (true) or not handled (false)
-            target.execute(sender, sentCommandLabel, Arrays_copyOfRange(args, 1, args.length));
-        } catch (CommandException ex) {
-            throw ex;
-        } catch (Throwable ex) {
-            throw new CommandException("Unhandled exception executing '" + commandLine + "' in " + target, ex);
-        }
-
-        // return true as command was handled
-        return true;
-    }
-
-    public synchronized void clearCommands() {
-        for (Map.Entry<String, Command> entry : knownCommands.entrySet()) {
-            entry.getValue().unregister(this);
-        }
-        knownCommands.clear();
-        setDefaultCommands();
-    }
-
-    public Command getCommand(String name) {
-        Command target = knownCommands.get(name.toLowerCase());
-        return target;
-    }
-
-    public List<String> tabComplete(CommandSender sender, String cmdLine) {
-        Validate.notNull(sender, "Sender cannot be null");
-        Validate.notNull(cmdLine, "Command line cannot null");
-
-        int spaceIndex = cmdLine.indexOf(' ');
-
-        if (spaceIndex == -1) {
-            ArrayList<String> completions = new ArrayList<String>();
-            Map<String, Command> knownCommands = this.knownCommands;
-
-            final String prefix = (sender instanceof Player ? "/" : "");
-
-            for (Map.Entry<String, Command> commandEntry : knownCommands.entrySet()) {
-                Command command = commandEntry.getValue();
-
-                if (!command.testPermissionSilent(sender)) {
-                    continue;
-                }
-
-                String name = commandEntry.getKey(); // Use the alias, not command name
-
-                if (StringUtil.startsWithIgnoreCase(name, cmdLine)) {
-                    completions.add(prefix + name);
-                }
-            }
-
-            Collections.sort(completions, String.CASE_INSENSITIVE_ORDER);
-            return completions;
-        }
-
-        String commandName = cmdLine.substring(0, spaceIndex);
-        Command target = getCommand(commandName);
-
-        if (target == null) {
-            return null;
-        }
-
-        if (!target.testPermissionSilent(sender)) {
-            return null;
-        }
-
-        String argLine = cmdLine.substring(spaceIndex + 1, cmdLine.length());
-        String[] args = PATTERN_ON_SPACE.split(argLine, -1);
-
-        try {
-            return target.tabComplete(sender, commandName, args);
-        } catch (CommandException ex) {
-            throw ex;
-        } catch (Throwable ex) {
-            throw new CommandException("Unhandled exception executing tab-completer for '" + cmdLine + "' in " + target, ex);
-        }
-    }
-
-    public Collection<Command> getCommands() {
-        return Collections.unmodifiableCollection(knownCommands.values());
-    }
-
-    public void registerServerAliases() {
-        Map<String, String[]> values = server.getCommandAliases();
-
-        for (String alias : values.keySet()) {
-            if (alias.contains(":") || alias.contains(" ")) {
-                server.getLogger().warning("Could not register alias " + alias + " because it contains illegal characters");
-                continue;
-            }
-
-            String[] commandStrings = values.get(alias);
-            List<String> targets = new ArrayList<String>();
-            StringBuilder bad = new StringBuilder();
-
-            for (String commandString : commandStrings) {
-                String[] commandArgs = commandString.split(" ");
-                Command command = getCommand(commandArgs[0]);
-
-                if (command == null) {
-                    if (bad.length() > 0) {
-                        bad.append(", ");
-                    }
-                    bad.append(commandString);
-                } else {
-                    targets.add(commandString);
-                }
-            }
-
-            if (bad.length() > 0) {
-                server.getLogger().warning("Could not register alias " + alias + " because it contains commands that do not exist: " + bad);
-                continue;
-            }
-
-            // We register these as commands so they have absolute priority.
-            if (targets.size() > 0) {
-                knownCommands.put(alias.toLowerCase(), new FormattedCommandAlias(alias.toLowerCase(), targets.toArray(new String[targets.size()])));
-            } else {
-                knownCommands.remove(alias.toLowerCase());
-            }
-        }
-    }
-}
diff --git a/src/main/java/org/bukkit/command/TabCommandExecutor.java b/src/main/java/org/bukkit/command/TabCommandExecutor.java
deleted file mode 100644
index d24d795..0000000
--- a/src/main/java/org/bukkit/command/TabCommandExecutor.java
+++ /dev/null
@@ -1,16 +0,0 @@
-package org.bukkit.command;
-
-import java.util.List;
-
-/**
- * Represents a class which can handle command tab completion and commands
- *
- * @deprecated Remains for plugins that would have implemented it even without
- *     functionality
- * @see TabExecutor
- */
-@Deprecated
-public interface TabCommandExecutor extends CommandExecutor {
-    public List<String> onTabComplete();
-
-}
diff --git a/src/main/java/org/bukkit/command/TabCompleter.java b/src/main/java/org/bukkit/command/TabCompleter.java
deleted file mode 100644
index 6d61e3a..0000000
--- a/src/main/java/org/bukkit/command/TabCompleter.java
+++ /dev/null
@@ -1,22 +0,0 @@
-package org.bukkit.command;
-
-import java.util.List;
-
-/**
- * Represents a class which can suggest tab completions for commands.
- */
-public interface TabCompleter {
-
-    /**
-     * Requests a list of possible completions for a command argument.
-     *
-     * @param sender Source of the command
-     * @param command Command which was executed
-     * @param alias The alias used
-     * @param args The arguments passed to the command, including final
-     *     partial argument to be completed and command label
-     * @return A List of possible completions for the final argument, or null
-     *     to default to the command executor
-     */
-    public List<String> onTabComplete(CommandSender sender, Command command, String alias, String[] args);
-}
diff --git a/src/main/java/org/bukkit/command/TabExecutor.java b/src/main/java/org/bukkit/command/TabExecutor.java
deleted file mode 100644
index 6b8e3fb..0000000
--- a/src/main/java/org/bukkit/command/TabExecutor.java
+++ /dev/null
@@ -1,8 +0,0 @@
-package org.bukkit.command;
-
-/**
- * This class is provided as a convenience to implement both TabCompleter and
- * CommandExecutor.
- */
-public interface TabExecutor extends TabCompleter, CommandExecutor {
-}
diff --git a/src/main/java/org/bukkit/command/defaults/AchievementCommand.java b/src/main/java/org/bukkit/command/defaults/AchievementCommand.java
deleted file mode 100644
index c2e1795..0000000
--- a/src/main/java/org/bukkit/command/defaults/AchievementCommand.java
+++ /dev/null
@@ -1,188 +0,0 @@
-package org.bukkit.command.defaults;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.Achievement;
-import org.bukkit.Bukkit;
-import org.bukkit.ChatColor;
-import org.bukkit.Statistic;
-import org.bukkit.Material;
-import org.bukkit.Statistic.Type;
-import org.bukkit.command.Command;
-import org.bukkit.command.CommandSender;
-import org.bukkit.entity.EntityType;
-import org.bukkit.entity.Player;
-import org.bukkit.event.player.PlayerAchievementAwardedEvent;
-import org.bukkit.event.player.PlayerStatisticIncrementEvent;
-
-import com.google.common.collect.ImmutableList;
-
-@Deprecated
-public class AchievementCommand extends VanillaCommand {
-    public AchievementCommand() {
-        super("achievement");
-        this.description = "Gives the specified player an achievement or changes a statistic value. Use '*' to give all achievements.";
-        this.usageMessage = "/achievement give <stat_name> [player]";
-        this.setPermission("bukkit.command.achievement");
-    }
-
-    @Override
-    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
-        if (!testPermission(sender)) return true;
-
-        if (args.length < 2) {
-            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
-            return false;
-        }
-
-        if (!args[0].equalsIgnoreCase("give")) {
-            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
-            return false;
-        }
-
-        String statisticString = args[1];
-        Player player = null;
-
-        if (args.length > 2) {
-            player = Bukkit.getPlayer(args[1]);
-        } else if (sender instanceof Player) {
-            player = (Player) sender;
-        }
-
-        if (player == null) {
-            sender.sendMessage("You must specify which player you wish to perform this action on.");
-            return true;
-        }
-
-        if (statisticString.equals("*")) {
-            for (Achievement achievement : Achievement.values()) {
-                if (player.hasAchievement(achievement)) {
-                    continue;
-                }
-                PlayerAchievementAwardedEvent event = new PlayerAchievementAwardedEvent(player, achievement);
-                Bukkit.getServer().getPluginManager().callEvent(event);
-                if (!event.isCancelled()) {
-                    player.awardAchievement(achievement);
-                }
-            }
-            Command.broadcastCommandMessage(sender, String.format("Successfully given all achievements to %s", player.getName()));
-            return true;
-        }
-
-        Achievement achievement = Bukkit.getUnsafe().getAchievementFromInternalName(statisticString);
-        Statistic statistic = Bukkit.getUnsafe().getStatisticFromInternalName(statisticString);
-
-        if (achievement != null) {
-            if (player.hasAchievement(achievement)) {
-                sender.sendMessage(String.format("%s already has achievement %s", player.getName(), statisticString));
-                return true;
-            }
-
-            PlayerAchievementAwardedEvent event = new PlayerAchievementAwardedEvent(player, achievement);
-            Bukkit.getServer().getPluginManager().callEvent(event);
-            if (event.isCancelled()) {
-                sender.sendMessage(String.format("Unable to award %s the achievement %s", player.getName(), statisticString));
-                return true;
-            }
-            player.awardAchievement(achievement);
-                
-            Command.broadcastCommandMessage(sender, String.format("Successfully given %s the stat %s", player.getName(), statisticString));
-            return true;
-        }
-
-        if (statistic == null) {
-            sender.sendMessage(String.format("Unknown achievement or statistic '%s'", statisticString));
-            return true;
-        }
-
-        if (statistic.getType() == Type.UNTYPED) {
-            PlayerStatisticIncrementEvent event = new PlayerStatisticIncrementEvent(player, statistic, player.getStatistic(statistic), player.getStatistic(statistic) + 1);
-            Bukkit.getServer().getPluginManager().callEvent(event);
-            if (event.isCancelled()) {
-                sender.sendMessage(String.format("Unable to increment %s for %s", statisticString, player.getName()));
-                return true;
-            }
-            player.incrementStatistic(statistic);
-            Command.broadcastCommandMessage(sender, String.format("Successfully given %s the stat %s", player.getName(), statisticString));
-            return true;
-        }
-
-        if (statistic.getType() == Type.ENTITY) {
-            EntityType entityType = EntityType.fromName(statisticString.substring(statisticString.lastIndexOf(".") + 1));
-
-            if (entityType == null) {
-                sender.sendMessage(String.format("Unknown achievement or statistic '%s'", statisticString));
-                return true;
-            }
-
-            PlayerStatisticIncrementEvent event = new PlayerStatisticIncrementEvent(player, statistic, player.getStatistic(statistic), player.getStatistic(statistic) + 1, entityType);
-            Bukkit.getServer().getPluginManager().callEvent(event);
-            if (event.isCancelled()) {
-                sender.sendMessage(String.format("Unable to increment %s for %s", statisticString, player.getName()));
-                return true;
-            }
-
-            try {
-                player.incrementStatistic(statistic, entityType);
-            } catch (IllegalArgumentException e) {
-                sender.sendMessage(String.format("Unknown achievement or statistic '%s'", statisticString));
-                return true;
-            }
-        } else {
-            int id;
-            try {
-                id = getInteger(sender, statisticString.substring(statisticString.lastIndexOf(".") + 1), 0, Integer.MAX_VALUE, true);
-            } catch (NumberFormatException e) {
-                sender.sendMessage(e.getMessage());
-                return true;
-            }
-
-            Material material = Material.getMaterial(id);
-
-            if (material == null) {
-                sender.sendMessage(String.format("Unknown achievement or statistic '%s'", statisticString));
-                return true;
-            }
-
-            PlayerStatisticIncrementEvent event = new PlayerStatisticIncrementEvent(player, statistic, player.getStatistic(statistic), player.getStatistic(statistic) + 1, material);
-            Bukkit.getServer().getPluginManager().callEvent(event);
-            if (event.isCancelled()) {
-                sender.sendMessage(String.format("Unable to increment %s for %s", statisticString, player.getName()));
-                return true;
-            }
-
-            try {
-                player.incrementStatistic(statistic, material);
-            } catch (IllegalArgumentException e) {
-                sender.sendMessage(String.format("Unknown achievement or statistic '%s'", statisticString));
-                return true;
-            }
-        }
-
-        Command.broadcastCommandMessage(sender, String.format("Successfully given %s the stat %s", player.getName(), statisticString));
-        return true;
-    }
-
-    @Override
-    public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {
-        Validate.notNull(sender, "Sender cannot be null");
-        Validate.notNull(args, "Arguments cannot be null");
-        Validate.notNull(alias, "Alias cannot be null");
-
-        if (args.length == 1) {
-            return Arrays.asList("give");
-        }
-
-        if (args.length == 2) {
-            return Bukkit.getUnsafe().tabCompleteInternalStatisticOrAchievementName(args[1], new ArrayList<String>());
-        }
-
-        if (args.length == 3) {
-            return super.tabComplete(sender, alias, args);
-        }
-        return ImmutableList.of();
-    }
-}
diff --git a/src/main/java/org/bukkit/command/defaults/BanCommand.java b/src/main/java/org/bukkit/command/defaults/BanCommand.java
deleted file mode 100644
index 59b804c..0000000
--- a/src/main/java/org/bukkit/command/defaults/BanCommand.java
+++ /dev/null
@@ -1,56 +0,0 @@
-package org.bukkit.command.defaults;
-
-import java.util.List;
-
-import org.apache.commons.lang.StringUtils;
-import org.apache.commons.lang.Validate;
-import org.bukkit.BanList;
-import org.bukkit.Bukkit;
-import org.bukkit.ChatColor;
-import org.bukkit.command.Command;
-import org.bukkit.command.CommandSender;
-import org.bukkit.entity.Player;
-
-import com.google.common.collect.ImmutableList;
-
-@Deprecated
-public class BanCommand extends VanillaCommand {
-    public BanCommand() {
-        super("ban");
-        this.description = "Prevents the specified player from using this server";
-        this.usageMessage = "/ban <player> [reason ...]";
-        this.setPermission("bukkit.command.ban.player");
-    }
-
-    @Override
-    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
-        if (!testPermission(sender)) return true;
-        if (args.length == 0)  {
-            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
-            return false;
-        }
-
-        String reason = args.length > 0 ? StringUtils.join(args, ' ', 1, args.length) : null;
-        Bukkit.getBanList(BanList.Type.NAME).addBan(args[0], reason, null, sender.getName());
-
-        Player player = Bukkit.getPlayer(args[0]);
-        if (player != null) {
-            player.kickPlayer("Banned by admin.");
-        }
-
-        Command.broadcastCommandMessage(sender, "Banned player " + args[0]);
-        return true;
-    }
-
-    @Override
-    public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {
-        Validate.notNull(sender, "Sender cannot be null");
-        Validate.notNull(args, "Arguments cannot be null");
-        Validate.notNull(alias, "Alias cannot be null");
-
-        if (args.length >= 1) {
-            return super.tabComplete(sender, alias, args);
-        }
-        return ImmutableList.of();
-    }
-}
diff --git a/src/main/java/org/bukkit/command/defaults/BanIpCommand.java b/src/main/java/org/bukkit/command/defaults/BanIpCommand.java
deleted file mode 100644
index 9fcd046..0000000
--- a/src/main/java/org/bukkit/command/defaults/BanIpCommand.java
+++ /dev/null
@@ -1,78 +0,0 @@
-package org.bukkit.command.defaults;
-
-import java.util.List;
-import java.util.regex.Pattern;
-
-import org.apache.commons.lang.StringUtils;
-import org.apache.commons.lang.Validate;
-import org.bukkit.BanList;
-import org.bukkit.Bukkit;
-import org.bukkit.ChatColor;
-import org.bukkit.command.Command;
-import org.bukkit.command.CommandSender;
-import org.bukkit.entity.Player;
-
-import com.google.common.collect.ImmutableList;
-
-@Deprecated
-public class BanIpCommand extends VanillaCommand {
-    public static final Pattern ipValidity = Pattern.compile("^([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])$");
-
-    public BanIpCommand() {
-        super("ban-ip");
-        this.description = "Prevents the specified IP address from using this server";
-        this.usageMessage = "/ban-ip <address|player> [reason ...]";
-        this.setPermission("bukkit.command.ban.ip");
-    }
-
-    @Override
-    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
-        if (!testPermission(sender)) return true;
-        if (args.length < 1)  {
-            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
-            return false;
-        }
-
-        String reason = args.length > 0 ? StringUtils.join(args, ' ', 1, args.length) : null;
-
-        if (ipValidity.matcher(args[0]).matches()) {
-            processIPBan(args[0], sender, reason);
-        } else {
-            Player player = Bukkit.getPlayer(args[0]);
-
-            if (player == null) {
-                sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
-                return false;
-            }
-
-            processIPBan(player.getAddress().getAddress().getHostAddress(), sender, reason);
-        }
-
-        return true;
-    }
-
-    private void processIPBan(String ip, CommandSender sender, String reason) {
-        Bukkit.getBanList(BanList.Type.IP).addBan(ip, reason, null, sender.getName());
-
-        // Find all matching players and kick
-        for (Player player : Bukkit.getOnlinePlayers()) {
-            if (player.getAddress().getAddress().getHostAddress().equals(ip)) {
-                player.kickPlayer("You have been IP banned.");
-            }
-        }
-
-        Command.broadcastCommandMessage(sender, "Banned IP Address " + ip);
-    }
-
-    @Override
-    public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {
-        Validate.notNull(sender, "Sender cannot be null");
-        Validate.notNull(args, "Arguments cannot be null");
-        Validate.notNull(alias, "Alias cannot be null");
-
-        if (args.length == 1) {
-            return super.tabComplete(sender, alias, args);
-        }
-        return ImmutableList.of();
-    }
-}
diff --git a/src/main/java/org/bukkit/command/defaults/BanListCommand.java b/src/main/java/org/bukkit/command/defaults/BanListCommand.java
deleted file mode 100644
index f8d32df..0000000
--- a/src/main/java/org/bukkit/command/defaults/BanListCommand.java
+++ /dev/null
@@ -1,74 +0,0 @@
-package org.bukkit.command.defaults;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.UUID;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.BanEntry;
-import org.bukkit.BanList;
-import org.bukkit.Bukkit;
-import org.bukkit.ChatColor;
-import org.bukkit.OfflinePlayer;
-import org.bukkit.command.CommandSender;
-import org.bukkit.util.StringUtil;
-
-import com.google.common.collect.ImmutableList;
-
-@Deprecated
-public class BanListCommand extends VanillaCommand {
-    private static final List<String> BANLIST_TYPES = ImmutableList.of("ips", "players");
-
-    public BanListCommand() {
-        super("banlist");
-        this.description = "View all players banned from this server";
-        this.usageMessage = "/banlist [ips|players]";
-        this.setPermission("bukkit.command.ban.list");
-    }
-
-    @Override
-    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
-        if (!testPermission(sender)) return true;
-
-        BanList.Type banType = BanList.Type.NAME;
-        if (args.length > 0) {
-            if (args[0].equalsIgnoreCase("ips")) {
-                banType = BanList.Type.IP;
-            } else if (!args[0].equalsIgnoreCase("players")) {
-                sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
-                return false;
-            }
-        }
-
-        StringBuilder message = new StringBuilder();
-        BanEntry[] banlist = Bukkit.getBanList(banType).getBanEntries().toArray(new BanEntry[0]);
-
-        for (int x = 0; x < banlist.length; x++) {
-            if (x != 0) {
-                if (x == banlist.length - 1) {
-                    message.append(" and ");
-                } else {
-                    message.append(", ");
-                }
-            }
-
-            message.append(banlist[x].getTarget());
-        }
-
-        sender.sendMessage("There are " + banlist.length + " total banned players:");
-        sender.sendMessage(message.toString());
-        return true;
-    }
-
-    @Override
-    public List<String> tabComplete(CommandSender sender, String alias, String[] args) {
-        Validate.notNull(sender, "Sender cannot be null");
-        Validate.notNull(args, "Arguments cannot be null");
-        Validate.notNull(alias, "Alias cannot be null");
-
-        if (args.length == 1) {
-            return StringUtil.copyPartialMatches(args[0], BANLIST_TYPES, new ArrayList<String>(BANLIST_TYPES.size()));
-        }
-        return ImmutableList.of();
-    }
-}
diff --git a/src/main/java/org/bukkit/command/defaults/BukkitCommand.java b/src/main/java/org/bukkit/command/defaults/BukkitCommand.java
deleted file mode 100644
index 23c8580..0000000
--- a/src/main/java/org/bukkit/command/defaults/BukkitCommand.java
+++ /dev/null
@@ -1,15 +0,0 @@
-package org.bukkit.command.defaults;
-
-import java.util.List;
-
-import org.bukkit.command.Command;
-
-public abstract class BukkitCommand extends Command {
-    protected BukkitCommand(String name) {
-        super(name);
-    }
-
-    protected BukkitCommand(String name, String description, String usageMessage, List<String> aliases) {
-        super(name, description, usageMessage, aliases);
-    }
-}
diff --git a/src/main/java/org/bukkit/command/defaults/ClearCommand.java b/src/main/java/org/bukkit/command/defaults/ClearCommand.java
deleted file mode 100644
index 05317e1..0000000
--- a/src/main/java/org/bukkit/command/defaults/ClearCommand.java
+++ /dev/null
@@ -1,115 +0,0 @@
-package org.bukkit.command.defaults;
-
-import com.google.common.collect.ImmutableList;
-import org.apache.commons.lang.Validate;
-import org.bukkit.Bukkit;
-import org.bukkit.ChatColor;
-import org.bukkit.Material;
-import org.bukkit.command.Command;
-import org.bukkit.command.CommandSender;
-import org.bukkit.entity.Player;
-import org.bukkit.util.StringUtil;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-
-@Deprecated
-public class ClearCommand extends VanillaCommand {
-    private static List<String> materials;
-    static {
-        ArrayList<String> materialList = new ArrayList<String>();
-        for (Material material : Material.values()) {
-            materialList.add(material.name());
-        }
-        Collections.sort(materialList);
-        materials = ImmutableList.copyOf(materialList);
-    }
-
-    public ClearCommand() {
-        super("clear");
-        this.description = "Clears the player's inventory. Can specify item and data filters too.";
-        this.usageMessage = "/clear <player> [item] [data]";
-        this.setPermission("bukkit.command.clear");
-    }
-
-    @Override
-    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
-        if (!testPermission(sender)) return true;
-
-        Player player = null;
-        if (args.length > 0) {
-            player = Bukkit.getPlayer(args[0]);
-        } else if (sender instanceof Player) {
-            player = (Player) sender;
-        }
-
-        if (player != null) {
-            int id;
-
-            if (args.length > 1 && !(args[1].equals("-1"))) {
-                Material material = Material.matchMaterial(args[1]);
-                if (material == null) {
-                    sender.sendMessage(ChatColor.RED + "There's no item called " + args[1]);
-                    return false;
-                }
-
-                id = material.getId();
-            } else {
-                id = -1;
-            }
-
-            int data = args.length >= 3 ? getInteger(sender, args[2], 0) : -1;
-            int count = player.getInventory().clear(id, data);
-
-            Command.broadcastCommandMessage(sender, "Cleared the inventory of " + player.getDisplayName() + ", removing " + count + " items");
-        } else if (args.length == 0) {
-            sender.sendMessage(ChatColor.RED + "Please provide a player!");
-        } else {
-            sender.sendMessage(ChatColor.RED + "Can't find player " + args[0]);
-        }
-
-        return true;
-    }
-
-    @Override
-    public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {
-        Validate.notNull(sender, "Sender cannot be null");
-        Validate.notNull(args, "Arguments cannot be null");
-        Validate.notNull(alias, "Alias cannot be null");
-
-        if (args.length == 1) {
-            return super.tabComplete(sender, alias, args);
-        }
-        if (args.length == 2) {
-            final String arg = args[1];
-            final List<String> materials = ClearCommand.materials;
-            List<String> completion = null;
-
-            final int size = materials.size();
-            int i = Collections.binarySearch(materials, arg, String.CASE_INSENSITIVE_ORDER);
-
-            if (i < 0) {
-                // Insertion (start) index
-                i = -1 - i;
-            }
-
-            for ( ; i < size; i++) {
-                String material = materials.get(i);
-                if (StringUtil.startsWithIgnoreCase(material, arg)) {
-                    if (completion == null) {
-                        completion = new ArrayList<String>();
-                    }
-                    completion.add(material);
-                } else {
-                    break;
-                }
-            }
-
-            if (completion != null) {
-                return completion;
-            }
-        }
-        return ImmutableList.of();
-    }
-}
diff --git a/src/main/java/org/bukkit/command/defaults/DefaultGameModeCommand.java b/src/main/java/org/bukkit/command/defaults/DefaultGameModeCommand.java
deleted file mode 100644
index f217aea..0000000
--- a/src/main/java/org/bukkit/command/defaults/DefaultGameModeCommand.java
+++ /dev/null
@@ -1,71 +0,0 @@
-package org.bukkit.command.defaults;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.Bukkit;
-import org.bukkit.GameMode;
-import org.bukkit.command.Command;
-import org.bukkit.command.CommandSender;
-import org.bukkit.util.StringUtil;
-
-import com.google.common.collect.ImmutableList;
-
-@Deprecated
-public class DefaultGameModeCommand extends VanillaCommand {
-    private static final List<String> GAMEMODE_NAMES = ImmutableList.of("adventure", "creative", "survival");
-
-    public DefaultGameModeCommand() {
-        super("defaultgamemode");
-        this.description = "Set the default gamemode";
-        this.usageMessage = "/defaultgamemode <mode>";
-        this.setPermission("bukkit.command.defaultgamemode");
-    }
-
-    @Override
-    public boolean execute(CommandSender sender, String commandLabel, String[] args) {
-        if (!testPermission(sender)) return true;
-        if (args.length == 0) {
-            sender.sendMessage("Usage: " + usageMessage);
-            return false;
-        }
-
-        String modeArg = args[0];
-        int value = -1;
-
-        try {
-            value = Integer.parseInt(modeArg);
-        } catch (NumberFormatException ex) {}
-
-        GameMode mode = GameMode.getByValue(value);
-
-        if (mode == null) {
-            if (modeArg.equalsIgnoreCase("creative") || modeArg.equalsIgnoreCase("c")) {
-                mode = GameMode.CREATIVE;
-            } else if (modeArg.equalsIgnoreCase("adventure") || modeArg.equalsIgnoreCase("a")) {
-                mode = GameMode.ADVENTURE;
-            } else {
-                mode = GameMode.SURVIVAL;
-            }
-        }
-
-        Bukkit.getServer().setDefaultGameMode(mode);
-        Command.broadcastCommandMessage(sender, "Default game mode set to " + mode.toString().toLowerCase());
-
-        return true;
-    }
-
-    @Override
-    public List<String> tabComplete(CommandSender sender, String alias, String[] args) {
-        Validate.notNull(sender, "Sender cannot be null");
-        Validate.notNull(args, "Arguments cannot be null");
-        Validate.notNull(alias, "Alias cannot be null");
-
-        if (args.length == 1) {
-            return StringUtil.copyPartialMatches(args[0], GAMEMODE_NAMES, new ArrayList<String>(GAMEMODE_NAMES.size()));
-        }
-
-        return ImmutableList.of();
-    }
-}
diff --git a/src/main/java/org/bukkit/command/defaults/DeopCommand.java b/src/main/java/org/bukkit/command/defaults/DeopCommand.java
deleted file mode 100644
index 86be15e..0000000
--- a/src/main/java/org/bukkit/command/defaults/DeopCommand.java
+++ /dev/null
@@ -1,63 +0,0 @@
-package org.bukkit.command.defaults;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.Bukkit;
-import org.bukkit.ChatColor;
-import org.bukkit.OfflinePlayer;
-import org.bukkit.command.Command;
-import org.bukkit.command.CommandSender;
-import org.bukkit.entity.Player;
-import org.bukkit.util.StringUtil;
-
-import com.google.common.collect.ImmutableList;
-
-@Deprecated
-public class DeopCommand extends VanillaCommand {
-    public DeopCommand() {
-        super("deop");
-        this.description = "Takes the specified player's operator status";
-        this.usageMessage = "/deop <player>";
-        this.setPermission("bukkit.command.op.take");
-    }
-
-    @Override
-    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
-        if (!testPermission(sender)) return true;
-        if (args.length != 1 || args[0].length() == 0) {
-            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
-            return false;
-        }
-
-        OfflinePlayer player = Bukkit.getOfflinePlayer(args[0]);
-        player.setOp(false);
-
-        if (player instanceof Player) {
-            ((Player) player).sendMessage(ChatColor.YELLOW + "You are no longer op!");
-        }
-
-        Command.broadcastCommandMessage(sender, "De-opped " + args[0]);
-        return true;
-    }
-
-    @Override
-    public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {
-        Validate.notNull(sender, "Sender cannot be null");
-        Validate.notNull(args, "Arguments cannot be null");
-        Validate.notNull(alias, "Alias cannot be null");
-
-        if (args.length == 1) {
-            List<String> completions = new ArrayList<String>();
-            for (OfflinePlayer player : Bukkit.getOperators()) {
-                String playerName = player.getName();
-                if (StringUtil.startsWithIgnoreCase(playerName, args[0])) {
-                    completions.add(playerName);
-                }
-            }
-            return completions;
-        }
-        return ImmutableList.of();
-    }
-}
diff --git a/src/main/java/org/bukkit/command/defaults/DifficultyCommand.java b/src/main/java/org/bukkit/command/defaults/DifficultyCommand.java
deleted file mode 100644
index 74a8ac2..0000000
--- a/src/main/java/org/bukkit/command/defaults/DifficultyCommand.java
+++ /dev/null
@@ -1,82 +0,0 @@
-package org.bukkit.command.defaults;
-
-import com.google.common.collect.ImmutableList;
-import org.apache.commons.lang.Validate;
-import org.bukkit.Bukkit;
-import org.bukkit.ChatColor;
-import org.bukkit.command.Command;
-import org.bukkit.command.CommandSender;
-import org.bukkit.util.StringUtil;
-import org.bukkit.Difficulty;
-
-import java.util.ArrayList;
-import java.util.List;
-
-@Deprecated
-public class DifficultyCommand extends VanillaCommand {
-    private static final List<String> DIFFICULTY_NAMES = ImmutableList.of("peaceful", "easy", "normal", "hard");
-
-    public DifficultyCommand() {
-        super("difficulty");
-        this.description = "Sets the game difficulty";
-        this.usageMessage = "/difficulty <new difficulty> ";
-        this.setPermission("bukkit.command.difficulty");
-    }
-
-    @Override
-    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
-        if (!testPermission(sender)) return true;
-        if (args.length != 1 || args[0].length() == 0) {
-            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
-            return false;
-        }
-
-        Difficulty difficulty = Difficulty.getByValue(getDifficultyForString(sender, args[0]));
-
-        if (Bukkit.isHardcore()) {
-            difficulty = Difficulty.HARD;
-        }
-
-        Bukkit.getWorlds().get(0).setDifficulty(difficulty);
-
-        int levelCount = 1;
-        if (Bukkit.getAllowNether()) {
-            Bukkit.getWorlds().get(levelCount).setDifficulty(difficulty);
-            levelCount++;
-        }
-
-        if (Bukkit.getAllowEnd()) {
-            Bukkit.getWorlds().get(levelCount).setDifficulty(difficulty);
-        }
-
-        Command.broadcastCommandMessage(sender, "Set difficulty to " + difficulty.toString());
-        return true;
-    }
-
-    protected int getDifficultyForString(CommandSender sender, String name) {
-        if (name.equalsIgnoreCase("peaceful") || name.equalsIgnoreCase("p")) {
-            return 0;
-        } else if (name.equalsIgnoreCase("easy") || name.equalsIgnoreCase("e")) {
-            return 1;
-        } else if (name.equalsIgnoreCase("normal") || name.equalsIgnoreCase("n")) {
-            return 2;
-        } else if (name.equalsIgnoreCase("hard") || name.equalsIgnoreCase("h")) {
-            return 3;
-        } else {
-            return getInteger(sender, name, 0, 3);
-        }
-    }
-
-    @Override
-    public List<String> tabComplete(CommandSender sender, String alias, String[] args) {
-        Validate.notNull(sender, "Sender cannot be null");
-        Validate.notNull(args, "Arguments cannot be null");
-        Validate.notNull(alias, "Alias cannot be null");
-
-        if (args.length == 1) {
-            return StringUtil.copyPartialMatches(args[0], DIFFICULTY_NAMES, new ArrayList<String>(DIFFICULTY_NAMES.size()));
-        }
-
-        return ImmutableList.of();
-    }
-}
diff --git a/src/main/java/org/bukkit/command/defaults/EffectCommand.java b/src/main/java/org/bukkit/command/defaults/EffectCommand.java
deleted file mode 100644
index de63bbe..0000000
--- a/src/main/java/org/bukkit/command/defaults/EffectCommand.java
+++ /dev/null
@@ -1,120 +0,0 @@
-package org.bukkit.command.defaults;
-
-import com.google.common.collect.ImmutableList;
-import java.util.ArrayList;
-import java.util.List;
-import org.bukkit.ChatColor;
-import org.bukkit.command.CommandSender;
-import org.bukkit.entity.Player;
-import org.bukkit.potion.PotionEffect;
-import org.bukkit.potion.PotionEffectType;
-import org.bukkit.util.StringUtil;
-
-@Deprecated
-public class EffectCommand extends VanillaCommand {
-    private static final List<String> effects;
-
-    public EffectCommand() {
-        super("effect");
-        this.description = "Adds/Removes effects on players";
-        this.usageMessage = "/effect <player> <effect|clear> [seconds] [amplifier]";
-        this.setPermission("bukkit.command.effect");
-    }
-
-    static {
-        ImmutableList.Builder<String> builder = ImmutableList.<String>builder();
-
-        for (PotionEffectType type : PotionEffectType.values()) {
-            if (type != null) {
-                builder.add(type.getName());
-            }
-        }
-
-        effects = builder.build();
-    }
-
-    @Override
-    public boolean execute(CommandSender sender, String commandLabel, String[] args) {
-        if (!testPermission(sender)) {
-            return true;
-        }
-
-        if (args.length < 2) {
-            sender.sendMessage(getUsage());
-            return true;
-        }
-
-        final Player player = sender.getServer().getPlayer(args[0]);
-
-        if (player == null) {
-            sender.sendMessage(ChatColor.RED + String.format("Player, %s, not found", args[0]));
-            return true;
-        }
-
-        if ("clear".equalsIgnoreCase(args[1])) {
-            for (PotionEffect effect : player.getActivePotionEffects()) {
-                player.removePotionEffect(effect.getType());
-            }
-            sender.sendMessage(String.format("Took all effects from %s", args[0]));
-            return true;
-        }
-
-        PotionEffectType effect = PotionEffectType.getByName(args[1]);
-
-        if (effect == null) {
-            effect = PotionEffectType.getById(getInteger(sender, args[1], 0));
-        }
-
-        if (effect == null) {
-            sender.sendMessage(ChatColor.RED + String.format("Effect, %s, not found", args[1]));
-            return true;
-        }
-
-        int duration = 600;
-        int duration_temp = 30;
-        int amplification = 0;
-
-        if (args.length >= 3) {
-            duration_temp = getInteger(sender, args[2], 0, 1000000);
-            if (effect.isInstant()) {
-                duration = duration_temp;
-            } else {
-                duration = duration_temp * 20;
-            }
-        } else if (effect.isInstant()) {
-            duration = 1;
-        }
-
-        if (args.length >= 4) {
-            amplification = getInteger(sender, args[3], 0, 255);
-        }
-
-        if (duration_temp == 0) {
-            if (!player.hasPotionEffect(effect)) {
-                sender.sendMessage(String.format("Couldn't take %s from %s as they do not have the effect", effect.getName(), args[0]));
-                return true;
-            }
-
-            player.removePotionEffect(effect);
-            broadcastCommandMessage(sender, String.format("Took %s from %s", effect.getName(), args[0]));
-        } else {
-            final PotionEffect applyEffect = new PotionEffect(effect, duration, amplification);
-
-            player.addPotionEffect(applyEffect, true);
-            broadcastCommandMessage(sender, String.format("Given %s (ID %d) * %d to %s for %d seconds", effect.getName(), effect.getId(), amplification, args[0], duration_temp));
-        }
-
-        return true;
-    }
-
-    @Override
-    public List<String> tabComplete(CommandSender sender, String commandLabel, String[] args) {
-        if (args.length == 1) {
-            return super.tabComplete(sender, commandLabel, args);
-        } else if (args.length == 2) {
-            return StringUtil.copyPartialMatches(args[1], effects, new ArrayList<String>(effects.size()));
-        }
-
-        return ImmutableList.of();
-    }
-}
diff --git a/src/main/java/org/bukkit/command/defaults/EnchantCommand.java b/src/main/java/org/bukkit/command/defaults/EnchantCommand.java
deleted file mode 100644
index 5f0b686..0000000
--- a/src/main/java/org/bukkit/command/defaults/EnchantCommand.java
+++ /dev/null
@@ -1,170 +0,0 @@
-package org.bukkit.command.defaults;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-import java.util.Map;
-
-import org.apache.commons.lang.Validate;
-import org.apache.commons.lang.WordUtils;
-import com.google.common.collect.ImmutableList;
-
-import org.bukkit.Bukkit;
-import org.bukkit.ChatColor;
-import org.bukkit.Material;
-import org.bukkit.command.Command;
-import org.bukkit.command.CommandSender;
-import org.bukkit.enchantments.Enchantment;
-import org.bukkit.entity.Player;
-import org.bukkit.inventory.ItemStack;
-import org.bukkit.util.StringUtil;
-
-@Deprecated
-public class EnchantCommand extends VanillaCommand {
-    private static final List<String> ENCHANTMENT_NAMES = new ArrayList<String>();
-
-    public EnchantCommand() {
-        super("enchant");
-        this.description = "Adds enchantments to the item the player is currently holding. Specify 0 for the level to remove an enchantment. Specify force to ignore normal enchantment restrictions";
-        this.usageMessage = "/enchant <player> <enchantment> [level|max|0] [force]";
-        this.setPermission("bukkit.command.enchant");
-    }
-
-    @Override
-    public boolean execute(CommandSender sender, String commandLabel, String[] args) {
-        if (!testPermission(sender)) return true;
-        if (args.length < 2) {
-            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
-            return false;
-        }
-
-        boolean force = false;
-        if (args.length > 2) {
-            force = args[args.length > 3 ? 3 : 2].equalsIgnoreCase("force");
-        }
-
-        Player player = Bukkit.getPlayerExact(args[0]);
-        if (player == null) {
-            sender.sendMessage("Can't find player " + args[0]);
-        } else {
-            ItemStack item = player.getItemInHand();
-            if (item.getType() == Material.AIR) {
-                sender.sendMessage("The player isn't holding an item");
-            } else {
-                String itemName = item.getType().toString().replaceAll("_", " ");
-                itemName = WordUtils.capitalizeFully(itemName);
-
-                Enchantment enchantment = getEnchantment(args[1].toUpperCase());
-                if (enchantment == null) {
-                    sender.sendMessage(String.format("Enchantment does not exist: %s", args[1]));
-                }  else {
-                    String enchantmentName = enchantment.getName().replaceAll("_", " ");
-                    enchantmentName = WordUtils.capitalizeFully(enchantmentName);
-
-                    if (!force && !enchantment.canEnchantItem(item)) {
-                        sender.sendMessage(String.format("%s cannot be applied to %s", enchantmentName, itemName));
-                    } else {
-                        int level = 1;
-                        if (args.length > 2) {
-                            Integer integer = getInteger(args[2]);
-                            int minLevel = enchantment.getStartLevel();
-                            int maxLevel = force ? Short.MAX_VALUE : enchantment.getMaxLevel();
-
-                            if (integer != null) {
-                                if (integer == 0) {
-                                    item.removeEnchantment(enchantment);
-                                    Command.broadcastCommandMessage(sender, String.format("Removed %s on %s's %s", enchantmentName, player.getName(), itemName));
-                                    return true;
-                                }
-
-                                if (integer < minLevel || integer > maxLevel) {
-                                    sender.sendMessage(String.format("Level for enchantment %s must be between %d and %d", enchantmentName, minLevel, maxLevel));
-                                    sender.sendMessage("Specify 0 for level to remove an enchantment");
-                                    return true;
-                                }
-
-                                level = integer;
-                            }
-
-                            if ("max".equals(args[2])) {
-                                level = maxLevel;
-                            }
-                        }
-
-                        Map<Enchantment, Integer> enchantments = item.getEnchantments();
-                        boolean conflicts = false;
-
-                        if (!force && !enchantments.isEmpty()) { // TODO: Improve this to use a "hasEnchantments" call
-                            for (Map.Entry<Enchantment, Integer> entry : enchantments.entrySet()) {
-                                Enchantment enchant = entry.getKey();
-
-                                if (enchant.equals(enchantment)) continue;
-                                if (enchant.conflictsWith(enchantment)) {
-                                    sender.sendMessage(String.format("Can't apply the enchantment %s on an item with the enchantment %s", enchantmentName, WordUtils.capitalizeFully(enchant.getName().replaceAll("_", " "))));
-                                    conflicts = true;
-                                    break;
-                                }
-                            }
-                        }
-
-                        if (!conflicts) {
-                            item.addUnsafeEnchantment(enchantment, level);
-
-                            Command.broadcastCommandMessage(sender, String.format("Applied %s (Lvl %d) on %s's %s", enchantmentName, level, player.getName(), itemName), false);
-                            sender.sendMessage(String.format("Enchanting succeeded, applied %s (Lvl %d) onto your %s", enchantmentName, level, itemName));
-                        }
-                    }
-                }
-            }
-        }
-        return true;
-    }
-
-     @Override
-    public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {
-        Validate.notNull(sender, "Sender cannot be null");
-        Validate.notNull(args, "Arguments cannot be null");
-        Validate.notNull(alias, "Alias cannot be null");
-
-        if (args.length == 1) {
-            return super.tabComplete(sender, alias, args);
-        }
-
-        if (args.length == 2) {
-            return StringUtil.copyPartialMatches(args[1], ENCHANTMENT_NAMES, new ArrayList<String>(ENCHANTMENT_NAMES.size()));
-        }
-
-        if (args.length == 3 || args.length == 4) {
-            if (!args[args.length - 2].equalsIgnoreCase("force")) {
-                return ImmutableList.of("force");
-            }
-        }
-
-        return ImmutableList.of();
-     }
-
-    private Enchantment getEnchantment(String lookup) {
-        Enchantment enchantment = Enchantment.getByName(lookup);
-
-        if (enchantment == null) {
-            Integer id = getInteger(lookup);
-            if (id != null) {
-                enchantment = Enchantment.getById(id);
-            }
-        }
-
-        return enchantment;
-    }
-
-    public static void buildEnchantments() {
-        if (!ENCHANTMENT_NAMES.isEmpty()) {
-            throw new IllegalStateException("Enchantments have already been built!");
-        }
-
-        for (Enchantment enchantment : Enchantment.values()) {
-            ENCHANTMENT_NAMES.add(enchantment.getName());
-        }
-
-        Collections.sort(ENCHANTMENT_NAMES);
-    }
-}
diff --git a/src/main/java/org/bukkit/command/defaults/ExpCommand.java b/src/main/java/org/bukkit/command/defaults/ExpCommand.java
deleted file mode 100644
index aa33c0c..0000000
--- a/src/main/java/org/bukkit/command/defaults/ExpCommand.java
+++ /dev/null
@@ -1,90 +0,0 @@
-package org.bukkit.command.defaults;
-
-import java.util.List;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.Bukkit;
-import org.bukkit.ChatColor;
-import org.bukkit.command.Command;
-import org.bukkit.command.CommandSender;
-import org.bukkit.entity.Player;
-
-import com.google.common.collect.ImmutableList;
-
-@Deprecated
-public class ExpCommand extends VanillaCommand {
-    public ExpCommand() {
-        super("xp");
-        this.description = "Gives the specified player a certain amount of experience. Specify <amount>L to give levels instead, with a negative amount resulting in taking levels.";
-        this.usageMessage = "/xp <amount> [player] OR /xp <amount>L [player]";
-        this.setPermission("bukkit.command.xp");
-    }
-
-    @Override
-    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
-        if (!testPermission(sender)) return true;
-
-        if (args.length > 0) {
-            String inputAmount = args[0];
-            Player player = null;
-
-            boolean isLevel = inputAmount.endsWith("l") || inputAmount.endsWith("L");
-            if (isLevel && inputAmount.length() > 1) {
-                inputAmount = inputAmount.substring(0, inputAmount.length() - 1);
-            }
-
-            int amount = getInteger(sender, inputAmount, Integer.MIN_VALUE, Integer.MAX_VALUE);
-            boolean isTaking = amount < 0;
-
-            if (isTaking) {
-                amount *= -1;
-            }
-
-            if (args.length > 1) {
-                player = Bukkit.getPlayer(args[1]);
-            } else if (sender instanceof Player) {
-                player = (Player) sender;
-            }
-
-            if (player != null) {
-                if (isLevel) {
-                    if (isTaking) {
-                        player.giveExpLevels(-amount);
-                        Command.broadcastCommandMessage(sender, "Taken " + amount + " level(s) from " + player.getName());
-                    } else {
-                        player.giveExpLevels(amount);
-                        Command.broadcastCommandMessage(sender, "Given " + amount + " level(s) to " + player.getName());
-                    }
-                } else {
-                    if (isTaking) {
-                        sender.sendMessage(ChatColor.RED + "Taking experience can only be done by levels, cannot give players negative experience points");
-                        return false;
-                    } else {
-                        player.giveExp(amount);
-                        Command.broadcastCommandMessage(sender, "Given " + amount + " experience to " + player.getName());
-                    }
-                }
-            } else {
-                sender.sendMessage("Can't find player, was one provided?\n" + ChatColor.RED + "Usage: " + usageMessage);
-                return false;
-            }
-
-            return true;
-        }
-
-        sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
-        return false;
-    }
-
-    @Override
-    public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {
-        Validate.notNull(sender, "Sender cannot be null");
-        Validate.notNull(args, "Arguments cannot be null");
-        Validate.notNull(alias, "Alias cannot be null");
-
-        if (args.length == 2) {
-            return super.tabComplete(sender, alias, args);
-        }
-        return ImmutableList.of();
-    }
-}
diff --git a/src/main/java/org/bukkit/command/defaults/GameModeCommand.java b/src/main/java/org/bukkit/command/defaults/GameModeCommand.java
deleted file mode 100644
index f9675a0..0000000
--- a/src/main/java/org/bukkit/command/defaults/GameModeCommand.java
+++ /dev/null
@@ -1,101 +0,0 @@
-package org.bukkit.command.defaults;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.Bukkit;
-import org.bukkit.ChatColor;
-import org.bukkit.GameMode;
-import org.bukkit.command.Command;
-import org.bukkit.command.CommandSender;
-import org.bukkit.entity.Player;
-import org.bukkit.util.StringUtil;
-
-import com.google.common.collect.ImmutableList;
-
-@Deprecated
-public class GameModeCommand extends VanillaCommand {
-    private static final List<String> GAMEMODE_NAMES = ImmutableList.of("adventure", "creative", "survival", "spectator");
-
-    public GameModeCommand() {
-        super("gamemode");
-        this.description = "Changes the player to a specific game mode";
-        this.usageMessage = "/gamemode <mode> [player]";
-        this.setPermission("bukkit.command.gamemode");
-    }
-
-    @Override
-    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
-        if (!testPermission(sender)) return true;
-        if (args.length == 0) {
-            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
-            return false;
-        }
-
-        String modeArg = args[0];
-        String playerArg = sender.getName();
-
-        if (args.length == 2) {
-            playerArg = args[1];
-        }
-
-        Player player = Bukkit.getPlayerExact(playerArg);
-
-        if (player != null) {
-            int value = -1;
-
-            try {
-                value = Integer.parseInt(modeArg);
-            } catch (NumberFormatException ex) {}
-
-            GameMode mode = GameMode.getByValue(value);
-
-            if (mode == null) {
-                if (modeArg.equalsIgnoreCase("creative") || modeArg.equalsIgnoreCase("c")) {
-                    mode = GameMode.CREATIVE;
-                } else if (modeArg.equalsIgnoreCase("adventure") || modeArg.equalsIgnoreCase("a")) {
-                    mode = GameMode.ADVENTURE;
-                } else if (modeArg.equalsIgnoreCase("spectator") || modeArg.equalsIgnoreCase("sp")) {
-                    mode = GameMode.SPECTATOR;
-                } else {
-                    mode = GameMode.SURVIVAL;
-                }
-            }
-
-            if (mode != player.getGameMode()) {
-                player.setGameMode(mode);
-
-                if (mode != player.getGameMode()) {
-                    sender.sendMessage("Game mode change for " + player.getName() + " failed!");
-                } else {
-                    if (player == sender) {
-                        Command.broadcastCommandMessage(sender, "Set own game mode to " + mode.toString() + " mode");
-                    } else {
-                        Command.broadcastCommandMessage(sender, "Set " + player.getName() + "'s game mode to " + mode.toString() + " mode");
-                    }
-                }
-            } else {
-                sender.sendMessage(player.getName() + " already has game mode " + mode.getValue());
-            }
-        } else {
-            sender.sendMessage("Can't find player " + playerArg);
-        }
-
-        return true;
-    }
-
-    @Override
-    public List<String> tabComplete(CommandSender sender, String alias, String[] args) {
-        Validate.notNull(sender, "Sender cannot be null");
-        Validate.notNull(args, "Arguments cannot be null");
-        Validate.notNull(alias, "Alias cannot be null");
-
-        if (args.length == 1) {
-            return StringUtil.copyPartialMatches(args[0], GAMEMODE_NAMES, new ArrayList<String>(GAMEMODE_NAMES.size()));
-        } else if (args.length == 2) {
-            return super.tabComplete(sender, alias, args);
-        }
-        return ImmutableList.of();
-    }
-}
diff --git a/src/main/java/org/bukkit/command/defaults/GameRuleCommand.java b/src/main/java/org/bukkit/command/defaults/GameRuleCommand.java
deleted file mode 100644
index 13e2589..0000000
--- a/src/main/java/org/bukkit/command/defaults/GameRuleCommand.java
+++ /dev/null
@@ -1,89 +0,0 @@
-package org.bukkit.command.defaults;
-
-import com.google.common.collect.ImmutableList;
-import org.apache.commons.lang.Validate;
-import org.bukkit.ChatColor;
-import org.bukkit.command.BlockCommandSender;
-import org.bukkit.command.Command;
-import org.bukkit.command.CommandSender;
-import org.bukkit.util.StringUtil;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import org.bukkit.Bukkit;
-import org.bukkit.World;
-import org.bukkit.entity.HumanEntity;
-
-@Deprecated
-public class GameRuleCommand extends VanillaCommand {
-    private static final List<String> GAMERULE_STATES = ImmutableList.of("true", "false");
-
-    public GameRuleCommand() {
-        super("gamerule");
-        this.description = "Sets a server's game rules";
-        this.usageMessage = "/gamerule <rule name> <value> OR /gamerule <rule name>";
-        this.setPermission("bukkit.command.gamerule");
-    }
-
-    @Override
-    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
-        if (!testPermission(sender)) return true;
-
-        if (args.length > 0) {
-            String rule = args[0];
-            World world = getGameWorld(sender);
-
-            if (world.isGameRule(rule)) {
-                if (args.length > 1) {
-                    String value = args[1];
-
-                    world.setGameRuleValue(rule, value);
-                    Command.broadcastCommandMessage(sender, "Game rule " + rule + " has been set to: " + value);
-                } else {
-                    String value = world.getGameRuleValue(rule);
-                    sender.sendMessage(rule + " = " + value);
-                }
-            } else {
-                sender.sendMessage(ChatColor.RED + "No game rule called " + rule + " is available");
-            }
-
-            return true;
-        } else {
-            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
-            sender.sendMessage("Rules: " + this.createString(getGameWorld(sender).getGameRules(), 0, ", "));
-
-            return true;
-        }
-    }
-
-    private World getGameWorld(CommandSender sender) {
-        if (sender instanceof HumanEntity) {
-            World world = ((HumanEntity) sender).getWorld();
-            if (world != null) {
-                return world;
-            }
-        } else if (sender instanceof BlockCommandSender) {
-            return ((BlockCommandSender) sender).getBlock().getWorld();
-        }
-
-        return Bukkit.getWorlds().get(0);
-    }
-
-    @Override
-    public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {
-        Validate.notNull(sender, "Sender cannot be null");
-        Validate.notNull(args, "Arguments cannot be null");
-        Validate.notNull(alias, "Alias cannot be null");
-
-        if (args.length == 1) {
-            return StringUtil.copyPartialMatches(args[0], Arrays.asList(getGameWorld(sender).getGameRules()), new ArrayList<String>());
-        }
-
-        if (args.length == 2) {
-            return StringUtil.copyPartialMatches(args[1], GAMERULE_STATES, new ArrayList<String>(GAMERULE_STATES.size()));
-        }
-
-        return ImmutableList.of();
-    }
-}
diff --git a/src/main/java/org/bukkit/command/defaults/GiveCommand.java b/src/main/java/org/bukkit/command/defaults/GiveCommand.java
deleted file mode 100644
index c8b7f0f..0000000
--- a/src/main/java/org/bukkit/command/defaults/GiveCommand.java
+++ /dev/null
@@ -1,130 +0,0 @@
-package org.bukkit.command.defaults;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.Bukkit;
-import org.bukkit.ChatColor;
-import org.bukkit.Material;
-import org.bukkit.command.Command;
-import org.bukkit.command.CommandSender;
-import org.bukkit.entity.Player;
-import org.bukkit.inventory.ItemStack;
-import org.bukkit.util.StringUtil;
-
-import com.google.common.base.Joiner;
-import com.google.common.collect.ImmutableList;
-
-@Deprecated
-public class GiveCommand extends VanillaCommand {
-    private static List<String> materials;
-    static {
-        ArrayList<String> materialList = new ArrayList<String>();
-        for (Material material : Material.values()) {
-            materialList.add(material.name());
-        }
-        Collections.sort(materialList);
-        materials = ImmutableList.copyOf(materialList);
-    }
-
-    public GiveCommand() {
-        super("give");
-        this.description = "Gives the specified player a certain amount of items";
-        this.usageMessage = "/give <player> <item> [amount [data]]";
-        this.setPermission("bukkit.command.give");
-    }
-
-    @Override
-    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
-        if (!testPermission(sender)) return true;
-        if ((args.length < 2)) {
-            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
-            return false;
-        }
-
-        Player player = Bukkit.getPlayerExact(args[0]);
-
-        if (player != null) {
-            Material material = Material.matchMaterial(args[1]);
-
-            if (material == null) {
-                material = Bukkit.getUnsafe().getMaterialFromInternalName(args[1]);
-            }
-
-            if (material != null) {
-                int amount = 1;
-                short data = 0;
-
-                if (args.length >= 3) {
-                    amount = this.getInteger(sender, args[2], 1, 64);
-
-                    if (args.length >= 4) {
-                        try {
-                            data = Short.parseShort(args[3]);
-                        } catch (NumberFormatException ex) {}
-                    }
-                }
-
-                ItemStack stack = new ItemStack(material, amount, data);
-
-                if (args.length >= 5) {
-                    try {
-                        stack = Bukkit.getUnsafe().modifyItemStack(stack, Joiner.on(' ').join(Arrays.asList(args).subList(4, args.length)));
-                    } catch (Throwable t) {
-                        player.sendMessage("Not a valid tag");
-                        return true;
-                    }
-                }
-
-                player.getInventory().addItem(stack);
-
-                Command.broadcastCommandMessage(sender, "Gave " + player.getName() + " some " + material.getId() + " (" + material + ")");
-            } else {
-                sender.sendMessage("There's no item called " + args[1]);
-            }
-        } else {
-            sender.sendMessage("Can't find player " + args[0]);
-        }
-
-        return true;
-    }
-
-    @Override
-    public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {
-        Validate.notNull(sender, "Sender cannot be null");
-        Validate.notNull(args, "Arguments cannot be null");
-        Validate.notNull(alias, "Alias cannot be null");
-
-        if (args.length == 1) {
-            return super.tabComplete(sender, alias, args);
-        }
-        if (args.length == 2) {
-            final String arg = args[1];
-            final List<String> materials = GiveCommand.materials;
-            List<String> completion = new ArrayList<String>();
-
-            final int size = materials.size();
-            int i = Collections.binarySearch(materials, arg, String.CASE_INSENSITIVE_ORDER);
-
-            if (i < 0) {
-                // Insertion (start) index
-                i = -1 - i;
-            }
-
-            for ( ; i < size; i++) {
-                String material = materials.get(i);
-                if (StringUtil.startsWithIgnoreCase(material, arg)) {
-                    completion.add(material);
-                } else {
-                    break;
-                }
-            }
-
-            return Bukkit.getUnsafe().tabCompleteInternalMaterialName(arg, completion);
-        }
-        return ImmutableList.of();
-    }
-}
diff --git a/src/main/java/org/bukkit/command/defaults/HelpCommand.java b/src/main/java/org/bukkit/command/defaults/HelpCommand.java
deleted file mode 100644
index aa359e4..0000000
--- a/src/main/java/org/bukkit/command/defaults/HelpCommand.java
+++ /dev/null
@@ -1,228 +0,0 @@
-package org.bukkit.command.defaults;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.TreeSet;
-
-import org.apache.commons.lang.ArrayUtils;
-import org.apache.commons.lang.StringUtils;
-import org.apache.commons.lang.Validate;
-import org.apache.commons.lang.math.NumberUtils;
-import org.bukkit.Bukkit;
-import org.bukkit.ChatColor;
-import org.bukkit.command.CommandSender;
-import org.bukkit.command.ConsoleCommandSender;
-import org.bukkit.help.HelpMap;
-import org.bukkit.help.HelpTopic;
-import org.bukkit.help.HelpTopicComparator;
-import org.bukkit.help.IndexHelpTopic;
-import org.bukkit.util.ChatPaginator;
-
-import com.google.common.collect.ImmutableList;
-
-public class HelpCommand extends VanillaCommand {
-    public HelpCommand() {
-        super("help");
-        this.description = "Shows the help menu";
-        this.usageMessage = "/help <pageNumber>\n/help <topic>\n/help <topic> <pageNumber>";
-        this.setAliases(Arrays.asList(new String[] { "?" }));
-        this.setPermission("bukkit.command.help");
-    }
-
-    @Override
-    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
-        if (!testPermission(sender)) return true;
-
-        String command;
-        int pageNumber;
-        int pageHeight;
-        int pageWidth;
-
-        if (args.length == 0) {
-            command = "";
-            pageNumber = 1;
-        } else if (NumberUtils.isDigits(args[args.length - 1])) {
-            command = StringUtils.join(ArrayUtils.subarray(args, 0, args.length - 1), " ");
-            try {
-                pageNumber = NumberUtils.createInteger(args[args.length - 1]);
-            } catch (NumberFormatException exception) {
-                pageNumber = 1;
-            }
-            if (pageNumber <= 0) {
-                pageNumber = 1;
-            }
-        } else {
-            command = StringUtils.join(args, " ");
-            pageNumber = 1;
-        }
-
-        if (sender instanceof ConsoleCommandSender) {
-            pageHeight = ChatPaginator.UNBOUNDED_PAGE_HEIGHT;
-            pageWidth = ChatPaginator.UNBOUNDED_PAGE_WIDTH;
-        } else {
-            pageHeight = ChatPaginator.CLOSED_CHAT_PAGE_HEIGHT - 1;
-            pageWidth = ChatPaginator.GUARANTEED_NO_WRAP_CHAT_PAGE_WIDTH;
-        }
-
-        HelpMap helpMap = Bukkit.getServer().getHelpMap();
-        HelpTopic topic = helpMap.getHelpTopic(command);
-
-        if (topic == null) {
-            topic = helpMap.getHelpTopic("/" + command);
-        }
-
-        if (topic == null) {
-            topic = findPossibleMatches(command);
-        }
-
-        if (topic == null || !topic.canSee(sender)) {
-            sender.sendMessage(ChatColor.RED + "No help for " + command);
-            return true;
-        }
-
-        ChatPaginator.ChatPage page = ChatPaginator.paginate(topic.getFullText(sender), pageNumber, pageWidth, pageHeight);
-
-        StringBuilder header = new StringBuilder();
-        header.append(ChatColor.YELLOW);
-        header.append("--------- ");
-        header.append(ChatColor.WHITE);
-        header.append("Help: ");
-        header.append(topic.getName());
-        header.append(" ");
-        if (page.getTotalPages() > 1) {
-            header.append("(");
-            header.append(page.getPageNumber());
-            header.append("/");
-            header.append(page.getTotalPages());
-            header.append(") ");
-        }
-        header.append(ChatColor.YELLOW);
-        for (int i = header.length(); i < ChatPaginator.GUARANTEED_NO_WRAP_CHAT_PAGE_WIDTH; i++) {
-            header.append("-");
-        }
-        sender.sendMessage(header.toString());
-
-        sender.sendMessage(page.getLines());
-
-        return true;
-    }
-
-    @Override
-    public List<String> tabComplete(CommandSender sender, String alias, String[] args) {
-        Validate.notNull(sender, "Sender cannot be null");
-        Validate.notNull(args, "Arguments cannot be null");
-        Validate.notNull(alias, "Alias cannot be null");
-
-        if (args.length == 1) {
-            List<String> matchedTopics = new ArrayList<String>();
-            String searchString = args[0];
-            for (HelpTopic topic : Bukkit.getServer().getHelpMap().getHelpTopics()) {
-                String trimmedTopic = topic.getName().startsWith("/") ? topic.getName().substring(1) : topic.getName();
-
-                if (trimmedTopic.startsWith(searchString)) {
-                    matchedTopics.add(trimmedTopic);
-                }
-            }
-            return matchedTopics;
-        }
-        return ImmutableList.of();
-    }
-
-    protected HelpTopic findPossibleMatches(String searchString) {
-        int maxDistance = (searchString.length() / 5) + 3;
-        Set<HelpTopic> possibleMatches = new TreeSet<HelpTopic>(HelpTopicComparator.helpTopicComparatorInstance());
-
-        if (searchString.startsWith("/")) {
-            searchString = searchString.substring(1);
-        }
-
-        for (HelpTopic topic : Bukkit.getServer().getHelpMap().getHelpTopics()) {
-            String trimmedTopic = topic.getName().startsWith("/") ? topic.getName().substring(1) : topic.getName();
-
-            if (trimmedTopic.length() < searchString.length()) {
-                continue;
-            }
-
-            if (Character.toLowerCase(trimmedTopic.charAt(0)) != Character.toLowerCase(searchString.charAt(0))) {
-                continue;
-            }
-
-            if (damerauLevenshteinDistance(searchString, trimmedTopic.substring(0, searchString.length())) < maxDistance) {
-                possibleMatches.add(topic);
-            }
-        }
-
-        if (possibleMatches.size() > 0) {
-            return new IndexHelpTopic("Search", null, null, possibleMatches, "Search for: " + searchString);
-        } else {
-            return null;
-        }
-    }
-
-    /**
-     * Computes the Dameraur-Levenshtein Distance between two strings. Adapted
-     * from the algorithm at <a href="http://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance">Wikipedia: Damerau–Levenshtein distance</a>
-     *
-     * @param s1 The first string being compared.
-     * @param s2 The second string being compared.
-     * @return The number of substitutions, deletions, insertions, and
-     * transpositions required to get from s1 to s2.
-     */
-    protected static int damerauLevenshteinDistance(String s1, String s2) {
-        if (s1 == null && s2 == null) {
-            return 0;
-        }
-        if (s1 != null && s2 == null) {
-            return s1.length();
-        }
-        if (s1 == null && s2 != null) {
-            return s2.length();
-        }
-
-        int s1Len = s1.length();
-        int s2Len = s2.length();
-        int[][] H = new int[s1Len + 2][s2Len + 2];
-
-        int INF = s1Len + s2Len;
-        H[0][0] = INF;
-        for (int i = 0; i <= s1Len; i++) {
-            H[i + 1][1] = i;
-            H[i + 1][0] = INF;
-        }
-        for (int j = 0; j <= s2Len; j++) {
-            H[1][j + 1] = j;
-            H[0][j + 1] = INF;
-        }
-
-        Map<Character, Integer> sd = new HashMap<Character, Integer>();
-        for (char Letter : (s1 + s2).toCharArray()) {
-            if (!sd.containsKey(Letter)) {
-                sd.put(Letter, 0);
-            }
-        }
-
-        for (int i = 1; i <= s1Len; i++) {
-            int DB = 0;
-            for (int j = 1; j <= s2Len; j++) {
-                int i1 = sd.get(s2.charAt(j - 1));
-                int j1 = DB;
-
-                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {
-                    H[i + 1][j + 1] = H[i][j];
-                    DB = j;
-                } else {
-                    H[i + 1][j + 1] = Math.min(H[i][j], Math.min(H[i + 1][j], H[i][j + 1])) + 1;
-                }
-
-                H[i + 1][j + 1] = Math.min(H[i + 1][j + 1], H[i1][j1] + (i - i1 - 1) + 1 + (j - j1 - 1));
-            }
-            sd.put(s1.charAt(i - 1), i);
-        }
-
-        return H[s1Len + 1][s2Len + 1];
-    }
-}
diff --git a/src/main/java/org/bukkit/command/defaults/KickCommand.java b/src/main/java/org/bukkit/command/defaults/KickCommand.java
deleted file mode 100644
index 634c115..0000000
--- a/src/main/java/org/bukkit/command/defaults/KickCommand.java
+++ /dev/null
@@ -1,60 +0,0 @@
-package org.bukkit.command.defaults;
-
-import java.util.List;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.Bukkit;
-import org.bukkit.ChatColor;
-import org.bukkit.command.Command;
-import org.bukkit.command.CommandSender;
-import org.bukkit.entity.Player;
-
-import com.google.common.collect.ImmutableList;
-
-@Deprecated
-public class KickCommand extends VanillaCommand {
-    public KickCommand() {
-        super("kick");
-        this.description = "Removes the specified player from the server";
-        this.usageMessage = "/kick <player> [reason ...]";
-        this.setPermission("bukkit.command.kick");
-    }
-
-    @Override
-    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
-        if (!testPermission(sender)) return true;
-        if (args.length < 1 || args[0].length() == 0) {
-            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
-            return false;
-        }
-
-        Player player = Bukkit.getPlayerExact(args[0]);
-
-        if (player != null) {
-            String reason = "Kicked by an operator.";
-
-            if (args.length > 1) {
-                reason = createString(args, 1);
-            }
-
-            player.kickPlayer(reason);
-            Command.broadcastCommandMessage(sender, "Kicked player " + player.getName() + ". With reason:\n" + reason);
-        } else {
-            sender.sendMessage( args[0] + " not found.");
-        }
-
-        return true;
-    }
-
-    @Override
-    public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {
-        Validate.notNull(sender, "Sender cannot be null");
-        Validate.notNull(args, "Arguments cannot be null");
-        Validate.notNull(alias, "Alias cannot be null");
-
-        if (args.length >= 1) {
-            return super.tabComplete(sender, alias, args);
-        }
-        return ImmutableList.of();
-    }
-}
diff --git a/src/main/java/org/bukkit/command/defaults/KillCommand.java b/src/main/java/org/bukkit/command/defaults/KillCommand.java
deleted file mode 100644
index 2143eb1..0000000
--- a/src/main/java/org/bukkit/command/defaults/KillCommand.java
+++ /dev/null
@@ -1,51 +0,0 @@
-package org.bukkit.command.defaults;
-
-import java.util.List;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.Bukkit;
-import org.bukkit.command.CommandSender;
-import org.bukkit.entity.Player;
-import org.bukkit.event.entity.EntityDamageEvent;
-
-import com.google.common.collect.ImmutableList;
-
-@Deprecated
-public class KillCommand extends VanillaCommand {
-    public KillCommand() {
-        super("kill");
-        this.description = "Commits suicide, only usable as a player";
-        this.usageMessage = "/kill";
-        this.setPermission("bukkit.command.kill");
-    }
-
-    @Override
-    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
-        if (!testPermission(sender)) return true;
-
-        if (sender instanceof Player) {
-            Player player = (Player) sender;
-
-            EntityDamageEvent ede = new EntityDamageEvent(player, EntityDamageEvent.DamageCause.SUICIDE, 1000);
-            Bukkit.getPluginManager().callEvent(ede);
-            if (ede.isCancelled()) return true;
-
-            ede.getEntity().setLastDamageCause(ede);
-            player.setHealth(0);
-            sender.sendMessage("Ouch. That look like it hurt.");
-        } else {
-            sender.sendMessage("You can only perform this command as a player");
-        }
-
-        return true;
-    }
-
-    @Override
-    public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {
-        Validate.notNull(sender, "Sender cannot be null");
-        Validate.notNull(args, "Arguments cannot be null");
-        Validate.notNull(alias, "Alias cannot be null");
-
-        return ImmutableList.of();
-    }
-}
diff --git a/src/main/java/org/bukkit/command/defaults/ListCommand.java b/src/main/java/org/bukkit/command/defaults/ListCommand.java
deleted file mode 100644
index ea62bee..0000000
--- a/src/main/java/org/bukkit/command/defaults/ListCommand.java
+++ /dev/null
@@ -1,55 +0,0 @@
-package org.bukkit.command.defaults;
-
-import java.util.Collection;
-import java.util.List;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.Bukkit;
-import org.bukkit.command.CommandSender;
-import org.bukkit.entity.Player;
-
-import com.google.common.collect.ImmutableList;
-
-@Deprecated
-public class ListCommand extends VanillaCommand {
-    public ListCommand() {
-        super("list");
-        this.description = "Lists all online players";
-        this.usageMessage = "/list";
-        this.setPermission("bukkit.command.list");
-    }
-
-    @Override
-    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
-        if (!testPermission(sender)) return true;
-
-        StringBuilder online = new StringBuilder();
-
-        final Collection<? extends Player> players = Bukkit.getOnlinePlayers();
-
-        for (Player player : players) {
-            // If a player is hidden from the sender don't show them in the list
-            if (sender instanceof Player && !((Player) sender).canSee(player))
-                continue;
-
-            if (online.length() > 0) {
-                online.append(", ");
-            }
-
-            online.append(player.getDisplayName());
-        }
-
-        sender.sendMessage("There are " + players.size() + "/" + Bukkit.getMaxPlayers() + " players online:\n" + online.toString());
-
-        return true;
-    }
-
-    @Override
-    public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {
-        Validate.notNull(sender, "Sender cannot be null");
-        Validate.notNull(args, "Arguments cannot be null");
-        Validate.notNull(alias, "Alias cannot be null");
-
-        return ImmutableList.of();
-    }
-}
diff --git a/src/main/java/org/bukkit/command/defaults/MeCommand.java b/src/main/java/org/bukkit/command/defaults/MeCommand.java
deleted file mode 100644
index b0d7bf5..0000000
--- a/src/main/java/org/bukkit/command/defaults/MeCommand.java
+++ /dev/null
@@ -1,36 +0,0 @@
-package org.bukkit.command.defaults;
-
-import org.bukkit.Bukkit;
-import org.bukkit.ChatColor;
-import org.bukkit.command.CommandSender;
-
-@Deprecated
-public class MeCommand extends VanillaCommand {
-    public MeCommand() {
-        super("me");
-        this.description = "Performs the specified action in chat";
-        this.usageMessage = "/me <action>";
-        this.setPermission("bukkit.command.me");
-    }
-
-    @Override
-    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
-        if (!testPermission(sender)) return true;
-        if (args.length < 1)  {
-            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
-            return false;
-        }
-
-        StringBuilder message = new StringBuilder();
-        message.append(sender.getName());
-
-        for (String arg : args) {
-            message.append(" ");
-            message.append(arg);
-        }
-
-        Bukkit.broadcastMessage("* " + message.toString());
-
-        return true;
-    }
-}
diff --git a/src/main/java/org/bukkit/command/defaults/OpCommand.java b/src/main/java/org/bukkit/command/defaults/OpCommand.java
deleted file mode 100644
index f5bb8b1..0000000
--- a/src/main/java/org/bukkit/command/defaults/OpCommand.java
+++ /dev/null
@@ -1,76 +0,0 @@
-package org.bukkit.command.defaults;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.Bukkit;
-import org.bukkit.ChatColor;
-import org.bukkit.OfflinePlayer;
-import org.bukkit.command.Command;
-import org.bukkit.command.CommandSender;
-import org.bukkit.entity.Player;
-import org.bukkit.util.StringUtil;
-
-import com.google.common.collect.ImmutableList;
-
-@Deprecated
-public class OpCommand extends VanillaCommand {
-    public OpCommand() {
-        super("op");
-        this.description = "Gives the specified player operator status";
-        this.usageMessage = "/op <player>";
-        this.setPermission("bukkit.command.op.give");
-    }
-
-    @Override
-    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
-        if (!testPermission(sender)) return true;
-        if (args.length != 1 || args[0].length() == 0)  {
-            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
-            return false;
-        }
-
-        OfflinePlayer player = Bukkit.getOfflinePlayer(args[0]);
-        player.setOp(true);
-
-        Command.broadcastCommandMessage(sender, "Opped " + args[0]);
-        return true;
-    }
-
-    @Override
-    public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {
-        Validate.notNull(sender, "Sender cannot be null");
-        Validate.notNull(args, "Arguments cannot be null");
-        Validate.notNull(alias, "Alias cannot be null");
-
-        if (args.length == 1) {
-            if (!(sender instanceof Player)) {
-                return ImmutableList.of();
-            }
-
-            String lastWord = args[0];
-            if (lastWord.length() == 0) {
-                return ImmutableList.of();
-            }
-
-            Player senderPlayer = (Player) sender;
-
-            ArrayList<String> matchedPlayers = new ArrayList<String>();
-            for (Player player : sender.getServer().getOnlinePlayers()) {
-                String name = player.getName();
-                if (!senderPlayer.canSee(player) || player.isOp()) {
-                    continue;
-                }
-                if (StringUtil.startsWithIgnoreCase(name, lastWord)) {
-                    matchedPlayers.add(name);
-                }
-            }
-
-            Collections.sort(matchedPlayers, String.CASE_INSENSITIVE_ORDER);
-            return matchedPlayers;
-        }
-        return ImmutableList.of();
-    }
-}
diff --git a/src/main/java/org/bukkit/command/defaults/PardonCommand.java b/src/main/java/org/bukkit/command/defaults/PardonCommand.java
deleted file mode 100644
index 762189a..0000000
--- a/src/main/java/org/bukkit/command/defaults/PardonCommand.java
+++ /dev/null
@@ -1,57 +0,0 @@
-package org.bukkit.command.defaults;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.BanList;
-import org.bukkit.Bukkit;
-import org.bukkit.ChatColor;
-import org.bukkit.OfflinePlayer;
-import org.bukkit.command.Command;
-import org.bukkit.command.CommandSender;
-import org.bukkit.util.StringUtil;
-
-import com.google.common.collect.ImmutableList;
-
-@Deprecated
-public class PardonCommand extends VanillaCommand {
-    public PardonCommand() {
-        super("pardon");
-        this.description = "Allows the specified player to use this server";
-        this.usageMessage = "/pardon <player>";
-        this.setPermission("bukkit.command.unban.player");
-    }
-
-    @Override
-    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
-        if (!testPermission(sender)) return true;
-        if (args.length != 1)  {
-            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
-            return false;
-        }
-
-        Bukkit.getBanList(BanList.Type.NAME).pardon(args[0]);
-        Command.broadcastCommandMessage(sender, "Pardoned " + args[0]);
-        return true;
-    }
-
-    @Override
-    public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {
-        Validate.notNull(sender, "Sender cannot be null");
-        Validate.notNull(args, "Arguments cannot be null");
-        Validate.notNull(alias, "Alias cannot be null");
-
-        if (args.length == 1) {
-            List<String> completions = new ArrayList<String>();
-            for (OfflinePlayer player : Bukkit.getBannedPlayers()) {
-                String name = player.getName();
-                if (StringUtil.startsWithIgnoreCase(name, args[0])) {
-                    completions.add(name);
-                }
-            }
-            return completions;
-        }
-        return ImmutableList.of();
-    }
-}
diff --git a/src/main/java/org/bukkit/command/defaults/PardonIpCommand.java b/src/main/java/org/bukkit/command/defaults/PardonIpCommand.java
deleted file mode 100644
index 0f63c26..0000000
--- a/src/main/java/org/bukkit/command/defaults/PardonIpCommand.java
+++ /dev/null
@@ -1,53 +0,0 @@
-package org.bukkit.command.defaults;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.Bukkit;
-import org.bukkit.ChatColor;
-import org.bukkit.command.Command;
-import org.bukkit.command.CommandSender;
-import org.bukkit.util.StringUtil;
-
-import com.google.common.collect.ImmutableList;
-
-@Deprecated
-public class PardonIpCommand extends VanillaCommand {
-    public PardonIpCommand() {
-        super("pardon-ip");
-        this.description = "Allows the specified IP address to use this server";
-        this.usageMessage = "/pardon-ip <address>";
-        this.setPermission("bukkit.command.unban.ip");
-    }
-
-    @Override
-    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
-        if (!testPermission(sender)) return true;
-        if (args.length != 1)  {
-            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
-            return false;
-        }
-
-        if (BanIpCommand.ipValidity.matcher(args[0]).matches()) {
-            Bukkit.unbanIP(args[0]);
-            Command.broadcastCommandMessage(sender, "Pardoned ip " + args[0]);
-        } else {
-            sender.sendMessage("Invalid ip");
-        }
-
-        return true;
-    }
-
-    @Override
-    public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {
-        Validate.notNull(sender, "Sender cannot be null");
-        Validate.notNull(args, "Arguments cannot be null");
-        Validate.notNull(alias, "Alias cannot be null");
-
-        if (args.length == 1) {
-            return StringUtil.copyPartialMatches(args[0], Bukkit.getIPBans(), new ArrayList<String>());
-        }
-        return ImmutableList.of();
-    }
-}
diff --git a/src/main/java/org/bukkit/command/defaults/PlaySoundCommand.java b/src/main/java/org/bukkit/command/defaults/PlaySoundCommand.java
deleted file mode 100644
index a7737ad..0000000
--- a/src/main/java/org/bukkit/command/defaults/PlaySoundCommand.java
+++ /dev/null
@@ -1,88 +0,0 @@
-package org.bukkit.command.defaults;
-
-import org.bukkit.Bukkit;
-import org.bukkit.ChatColor;
-import org.bukkit.Location;
-import org.bukkit.command.CommandSender;
-import org.bukkit.entity.Player;
-
-@Deprecated
-public class PlaySoundCommand extends VanillaCommand {
-    public PlaySoundCommand() {
-        super("playsound");
-        this.description = "Plays a sound to a given player";
-        this.usageMessage = "/playsound <sound> <player> [x] [y] [z] [volume] [pitch] [minimumVolume]";
-        this.setPermission("bukkit.command.playsound");
-    }
-
-    @Override
-    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
-        if (!testPermission(sender)) {
-            return true;
-        }
-
-        if (args.length < 2) {
-            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
-            return false;
-        }
-        final String soundArg = args[0];
-        final String playerArg = args[1];
-
-        final Player player = Bukkit.getPlayerExact(playerArg);
-        if (player == null) {
-            sender.sendMessage(ChatColor.RED + "Can't find player " + playerArg);
-            return false;
-        }
-
-        final Location location = player.getLocation();
-
-        double x = Math.floor(location.getX());
-        double y = Math.floor(location.getY() + 0.5D);
-        double z = Math.floor(location.getZ());
-        double volume = 1.0D;
-        double pitch = 1.0D;
-        double minimumVolume = 0.0D;
-
-        switch (args.length) {
-        default:
-        case 8:
-            minimumVolume = getDouble(sender, args[7], 0.0D, 1.0D);
-        case 7:
-            pitch = getDouble(sender, args[6], 0.0D, 2.0D);
-        case 6:
-            volume = getDouble(sender, args[5], 0.0D, Float.MAX_VALUE);
-        case 5:
-            z = getRelativeDouble(z, sender, args[4]);
-        case 4:
-            y = getRelativeDouble(y, sender, args[3]);
-        case 3:
-            x = getRelativeDouble(x, sender, args[2]);
-        case 2:
-            // Noop
-        }
-
-        final double fixedVolume = volume > 1.0D ? volume * 16.0D : 16.0D;
-        final Location soundLocation = new Location(player.getWorld(), x, y, z);
-        if (location.distanceSquared(soundLocation) > fixedVolume * fixedVolume) {
-            if (minimumVolume <= 0.0D) {
-                sender.sendMessage(ChatColor.RED + playerArg + " is too far away to hear the sound");
-                return false;
-            }
-
-            final double deltaX = x - location.getX();
-            final double deltaY = y - location.getY();
-            final double deltaZ = z - location.getZ();
-            final double delta = Math.sqrt(deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ) / 2.0D;
-
-            if (delta > 0.0D) {
-                location.add(deltaX / delta, deltaY / delta, deltaZ / delta);
-            }
-
-            player.playSound(location, soundArg, (float) minimumVolume, (float) pitch);
-        } else {
-            player.playSound(soundLocation, soundArg, (float) volume, (float) pitch);
-        }
-        sender.sendMessage(String.format("Played '%s' to %s", soundArg, playerArg));
-        return true;
-    }
-}
diff --git a/src/main/java/org/bukkit/command/defaults/PluginsCommand.java b/src/main/java/org/bukkit/command/defaults/PluginsCommand.java
deleted file mode 100644
index b888da1..0000000
--- a/src/main/java/org/bukkit/command/defaults/PluginsCommand.java
+++ /dev/null
@@ -1,43 +0,0 @@
-package org.bukkit.command.defaults;
-
-import java.util.Arrays;
-
-import org.bukkit.Bukkit;
-import org.bukkit.ChatColor;
-import org.bukkit.command.CommandSender;
-import org.bukkit.plugin.Plugin;
-
-public class PluginsCommand extends BukkitCommand {
-    public PluginsCommand(String name) {
-        super(name);
-        this.description = "Gets a list of plugins running on the server";
-        this.usageMessage = "/plugins";
-        this.setPermission("bukkit.command.plugins");
-        this.setAliases(Arrays.asList("pl"));
-    }
-
-    @Override
-    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
-        if (!testPermission(sender)) return true;
-
-        sender.sendMessage("Plugins " + getPluginList());
-        return true;
-    }
-
-    private String getPluginList() {
-        StringBuilder pluginList = new StringBuilder();
-        Plugin[] plugins = Bukkit.getPluginManager().getPlugins();
-
-        for (Plugin plugin : plugins) {
-            if (pluginList.length() > 0) {
-                pluginList.append(ChatColor.WHITE);
-                pluginList.append(", ");
-            }
-
-            pluginList.append(plugin.isEnabled() ? ChatColor.GREEN : ChatColor.RED);
-            pluginList.append(plugin.getDescription().getName());
-        }
-
-        return "(" + plugins.length + "): " + pluginList.toString();
-    }
-}
diff --git a/src/main/java/org/bukkit/command/defaults/ReloadCommand.java b/src/main/java/org/bukkit/command/defaults/ReloadCommand.java
deleted file mode 100644
index eb018f1..0000000
--- a/src/main/java/org/bukkit/command/defaults/ReloadCommand.java
+++ /dev/null
@@ -1,30 +0,0 @@
-package org.bukkit.command.defaults;
-
-import java.util.Arrays;
-
-import org.bukkit.Bukkit;
-import org.bukkit.ChatColor;
-import org.bukkit.command.Command;
-import org.bukkit.command.CommandSender;
-
-public class ReloadCommand extends BukkitCommand {
-    public ReloadCommand(String name) {
-        super(name);
-        this.description = "Reloads the server configuration and plugins";
-        this.usageMessage = "/reload";
-        this.setPermission("bukkit.command.reload");
-        this.setAliases(Arrays.asList("rl"));
-    }
-
-    @Override
-    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
-        if (!testPermission(sender)) return true;
-
-        Command.broadcastCommandMessage(sender, ChatColor.RED + "Please note that this command is not supported and may cause issues when using some plugins.");
-        Command.broadcastCommandMessage(sender, ChatColor.RED + "If you encounter any issues please use the /stop command to restart your server.");
-        Bukkit.reload();
-        Command.broadcastCommandMessage(sender, ChatColor.GREEN + "Reload complete.");
-
-        return true;
-    }
-}
diff --git a/src/main/java/org/bukkit/command/defaults/SaveCommand.java b/src/main/java/org/bukkit/command/defaults/SaveCommand.java
deleted file mode 100644
index d08d3ed..0000000
--- a/src/main/java/org/bukkit/command/defaults/SaveCommand.java
+++ /dev/null
@@ -1,47 +0,0 @@
-package org.bukkit.command.defaults;
-
-import java.util.List;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.Bukkit;
-import org.bukkit.World;
-import org.bukkit.command.Command;
-import org.bukkit.command.CommandSender;
-
-import com.google.common.collect.ImmutableList;
-
-@Deprecated
-public class SaveCommand extends VanillaCommand {
-    public SaveCommand() {
-        super("save-all");
-        this.description = "Saves the server to disk";
-        this.usageMessage = "/save-all";
-        this.setPermission("bukkit.command.save.perform");
-    }
-
-    @Override
-    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
-        if (!testPermission(sender)) return true;
-
-        Command.broadcastCommandMessage(sender, "Forcing save..");
-
-        Bukkit.savePlayers();
-
-        for (World world : Bukkit.getWorlds()) {
-            world.save();
-        }
-
-        Command.broadcastCommandMessage(sender, "Save complete.");
-
-        return true;
-    }
-
-    @Override
-    public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {
-        Validate.notNull(sender, "Sender cannot be null");
-        Validate.notNull(args, "Arguments cannot be null");
-        Validate.notNull(alias, "Alias cannot be null");
-
-        return ImmutableList.of();
-    }
-}
diff --git a/src/main/java/org/bukkit/command/defaults/SaveOffCommand.java b/src/main/java/org/bukkit/command/defaults/SaveOffCommand.java
deleted file mode 100644
index 54e6bca..0000000
--- a/src/main/java/org/bukkit/command/defaults/SaveOffCommand.java
+++ /dev/null
@@ -1,42 +0,0 @@
-package org.bukkit.command.defaults;
-
-import java.util.List;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.Bukkit;
-import org.bukkit.World;
-import org.bukkit.command.Command;
-import org.bukkit.command.CommandSender;
-
-import com.google.common.collect.ImmutableList;
-
-@Deprecated
-public class SaveOffCommand extends VanillaCommand {
-    public SaveOffCommand() {
-        super("save-off");
-        this.description = "Disables server autosaving";
-        this.usageMessage = "/save-off";
-        this.setPermission("bukkit.command.save.disable");
-    }
-
-    @Override
-    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
-        if (!testPermission(sender)) return true;
-
-        for (World world : Bukkit.getWorlds()) {
-            world.setAutoSave(false);
-        }
-
-        Command.broadcastCommandMessage(sender, "Disabled level saving..");
-        return true;
-    }
-
-    @Override
-    public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {
-        Validate.notNull(sender, "Sender cannot be null");
-        Validate.notNull(args, "Arguments cannot be null");
-        Validate.notNull(alias, "Alias cannot be null");
-
-        return ImmutableList.of();
-    }
-}
diff --git a/src/main/java/org/bukkit/command/defaults/SaveOnCommand.java b/src/main/java/org/bukkit/command/defaults/SaveOnCommand.java
deleted file mode 100644
index 760e1c4..0000000
--- a/src/main/java/org/bukkit/command/defaults/SaveOnCommand.java
+++ /dev/null
@@ -1,42 +0,0 @@
-package org.bukkit.command.defaults;
-
-import java.util.List;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.Bukkit;
-import org.bukkit.World;
-import org.bukkit.command.Command;
-import org.bukkit.command.CommandSender;
-
-import com.google.common.collect.ImmutableList;
-
-@Deprecated
-public class SaveOnCommand extends VanillaCommand {
-    public SaveOnCommand() {
-        super("save-on");
-        this.description = "Enables server autosaving";
-        this.usageMessage = "/save-on";
-        this.setPermission("bukkit.command.save.enable");
-    }
-
-    @Override
-    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
-        if (!testPermission(sender)) return true;
-
-        for (World world : Bukkit.getWorlds()) {
-            world.setAutoSave(true);
-        }
-
-        Command.broadcastCommandMessage(sender, "Enabled level saving..");
-        return true;
-    }
-
-    @Override
-    public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {
-        Validate.notNull(sender, "Sender cannot be null");
-        Validate.notNull(args, "Arguments cannot be null");
-        Validate.notNull(alias, "Alias cannot be null");
-
-        return ImmutableList.of();
-    }
-}
diff --git a/src/main/java/org/bukkit/command/defaults/SayCommand.java b/src/main/java/org/bukkit/command/defaults/SayCommand.java
deleted file mode 100644
index 9641d18..0000000
--- a/src/main/java/org/bukkit/command/defaults/SayCommand.java
+++ /dev/null
@@ -1,63 +0,0 @@
-package org.bukkit.command.defaults;
-
-import java.util.List;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.Bukkit;
-import org.bukkit.ChatColor;
-import org.bukkit.command.CommandSender;
-import org.bukkit.command.ConsoleCommandSender;
-import org.bukkit.entity.Player;
-
-import com.google.common.collect.ImmutableList;
-
-@Deprecated
-public class SayCommand extends VanillaCommand {
-    public SayCommand() {
-        super("say");
-        this.description = "Broadcasts the given message as the sender";
-        this.usageMessage = "/say <message ...>";
-        this.setPermission("bukkit.command.say");
-    }
-
-    @Override
-    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
-        if (!testPermission(sender)) return true;
-        if (args.length == 0)  {
-            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
-            return false;
-        }
-
-        StringBuilder message = new StringBuilder();
-        message.append(ChatColor.LIGHT_PURPLE).append("[");
-        if (sender instanceof ConsoleCommandSender) {
-            message.append("Server");
-        } else if (sender instanceof Player) {
-            message.append(((Player) sender).getDisplayName());
-        } else {
-            message.append(sender.getName());
-        }
-        message.append(ChatColor.LIGHT_PURPLE).append("] ");
-
-        if (args.length > 0) {
-            message.append(args[0]);
-            for (int i = 1; i < args.length; i++) {
-                message.append(" ").append(args[i]);
-            }
-        }
-
-        Bukkit.broadcastMessage(message.toString());
-        return true;
-    }
-
-    @Override
-    public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {
-        Validate.notNull(sender, "Sender cannot be null");
-        Validate.notNull(args, "Arguments cannot be null");
-
-        if (args.length >= 1) {
-            return super.tabComplete(sender, alias, args);
-        }
-        return ImmutableList.of();
-    }
-}
diff --git a/src/main/java/org/bukkit/command/defaults/ScoreboardCommand.java b/src/main/java/org/bukkit/command/defaults/ScoreboardCommand.java
deleted file mode 100644
index 00197f7..0000000
--- a/src/main/java/org/bukkit/command/defaults/ScoreboardCommand.java
+++ /dev/null
@@ -1,618 +0,0 @@
-package org.bukkit.command.defaults;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import org.apache.commons.lang.ArrayUtils;
-import org.apache.commons.lang.StringUtils;
-import org.apache.commons.lang.Validate;
-import org.bukkit.Bukkit;
-import org.bukkit.ChatColor;
-import org.bukkit.OfflinePlayer;
-import org.bukkit.command.CommandSender;
-import org.bukkit.entity.Player;
-import org.bukkit.scoreboard.DisplaySlot;
-import org.bukkit.scoreboard.Objective;
-import org.bukkit.scoreboard.Score;
-import org.bukkit.scoreboard.Scoreboard;
-import org.bukkit.scoreboard.Team;
-import org.bukkit.util.StringUtil;
-
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap;
-
-@Deprecated
-public class ScoreboardCommand extends VanillaCommand {
-
-    private static final List<String> MAIN_CHOICES = ImmutableList.of("objectives", "players", "teams");
-    private static final List<String> OBJECTIVES_CHOICES = ImmutableList.of("list", "add", "remove", "setdisplay");
-    private static final List<String> OBJECTIVES_CRITERIA = ImmutableList.of("health", "playerKillCount", "totalKillCount", "deathCount", "dummy");
-    private static final List<String> PLAYERS_CHOICES = ImmutableList.of("set", "add", "remove", "reset", "list");
-    private static final List<String> TEAMS_CHOICES = ImmutableList.of("add", "remove", "join", "leave", "empty", "list", "option");
-    private static final List<String> TEAMS_OPTION_CHOICES = ImmutableList.of("color", "friendlyfire", "seeFriendlyInvisibles");
-    private static final Map<String, DisplaySlot> OBJECTIVES_DISPLAYSLOT = ImmutableMap.of("belowName", DisplaySlot.BELOW_NAME, "list", DisplaySlot.PLAYER_LIST, "sidebar", DisplaySlot.SIDEBAR);
-    private static final Map<String, ChatColor> TEAMS_OPTION_COLOR = ImmutableMap.<String, ChatColor>builder()
-            .put("aqua", ChatColor.AQUA)
-            .put("black", ChatColor.BLACK)
-            .put("blue", ChatColor.BLUE)
-            .put("bold", ChatColor.BOLD)
-            .put("dark_aqua", ChatColor.DARK_AQUA)
-            .put("dark_blue", ChatColor.DARK_BLUE)
-            .put("dark_gray",  ChatColor.DARK_GRAY)
-            .put("dark_green", ChatColor.DARK_GREEN)
-            .put("dark_purple", ChatColor.DARK_PURPLE)
-            .put("dark_red", ChatColor.DARK_RED)
-            .put("gold", ChatColor.GOLD)
-            .put("gray", ChatColor.GRAY)
-            .put("green", ChatColor.GREEN)
-            .put("italic", ChatColor.ITALIC)
-            .put("light_purple", ChatColor.LIGHT_PURPLE)
-            .put("obfuscated", ChatColor.MAGIC) // This is the important line
-            .put("red", ChatColor.RED)
-            .put("reset", ChatColor.RESET)
-            .put("strikethrough", ChatColor.STRIKETHROUGH)
-            .put("underline", ChatColor.UNDERLINE)
-            .put("white", ChatColor.WHITE)
-            .put("yellow", ChatColor.YELLOW)
-            .build();
-    private static final List<String> BOOLEAN = ImmutableList.of("true", "false");
-
-    public ScoreboardCommand() {
-        super("scoreboard");
-        this.description = "Scoreboard control";
-        this.usageMessage = "/scoreboard";
-        this.setPermission("bukkit.command.scoreboard");
-    }
-
-    @Override
-    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
-        if (!testPermission(sender))
-            return true;
-        if (args.length < 1 || args[0].length() == 0) {
-            sender.sendMessage(ChatColor.RED + "Usage: /scoreboard <objectives|players|teams>");
-            return false;
-        }
-
-        final Scoreboard mainScoreboard = Bukkit.getScoreboardManager().getMainScoreboard();
-
-        if (args[0].equalsIgnoreCase("objectives")) {
-            if (args.length == 1) {
-                sender.sendMessage(ChatColor.RED + "Usage: /scoreboard objectives <list|add|remove|setdisplay>");
-                return false;
-            }
-            if (args[1].equalsIgnoreCase("list")) {
-                Set<Objective> objectives = mainScoreboard.getObjectives();
-                if (objectives.isEmpty()) {
-                    sender.sendMessage(ChatColor.RED + "There are no objectives on the scoreboard");
-                    return false;
-                }
-                sender.sendMessage(ChatColor.DARK_GREEN + "Showing " + objectives.size() + " objective(s) on scoreboard");
-                for (Objective objective : objectives) {
-                    sender.sendMessage("- " + objective.getName() + ": displays as '" + objective.getDisplayName() + "' and is type '" + objective.getCriteria() + "'");
-                }
-            } else if (args[1].equalsIgnoreCase("add")) {
-                if (args.length < 4) {
-                    sender.sendMessage(ChatColor.RED + "/scoreboard objectives add <name> <criteriaType> [display name ...]");
-                    return false;
-                }
-                String name = args[2];
-                String criteria = args[3];
-
-                if (criteria == null) {
-                    sender.sendMessage(ChatColor.RED + "Invalid objective criteria type. Valid types are: " + stringCollectionToString(OBJECTIVES_CRITERIA));
-                } else if (name.length() > 16) {
-                    sender.sendMessage(ChatColor.RED + "The name '" + name + "' is too long for an objective, it can be at most 16 characters long");
-                } else if (mainScoreboard.getObjective(name) != null) {
-                    sender.sendMessage(ChatColor.RED + "An objective with the name '" + name + "' already exists");
-                } else {
-                    String displayName = null;
-                    if (args.length > 4) {
-                        displayName = StringUtils.join(ArrayUtils.subarray(args, 4, args.length), ' ');
-                        if (displayName.length() > 32) {
-                            sender.sendMessage(ChatColor.RED + "The name '" + displayName + "' is too long for an objective, it can be at most 32 characters long");
-                            return false;
-                        }
-                    }
-                    Objective objective = mainScoreboard.registerNewObjective(name, criteria);
-                    if (displayName != null && displayName.length() > 0) {
-                        objective.setDisplayName(displayName);
-                    }
-                    sender.sendMessage("Added new objective '" + name + "' successfully");
-                }
-            } else if (args[1].equalsIgnoreCase("remove")) {
-                if (args.length != 3) {
-                    sender.sendMessage(ChatColor.RED + "/scoreboard objectives remove <name>");
-                    return false;
-                }
-                String name = args[2];
-                Objective objective = mainScoreboard.getObjective(name);
-                if (objective == null) {
-                    sender.sendMessage(ChatColor.RED + "No objective was found by the name '" + name + "'");
-                } else {
-                    objective.unregister();
-                    sender.sendMessage("Removed objective '" + name + "' successfully");
-                }
-            } else if (args[1].equalsIgnoreCase("setdisplay")) {
-                if (args.length != 3 && args.length != 4) {
-                    sender.sendMessage(ChatColor.RED + "/scoreboard objectives setdisplay <slot> [objective]");
-                    return false;
-                }
-                String slotName = args[2];
-                DisplaySlot slot = OBJECTIVES_DISPLAYSLOT.get(slotName);
-                if (slot == null) {
-                    sender.sendMessage(ChatColor.RED + "No such display slot '" + slotName + "'");
-                } else {
-                    if (args.length == 4) {
-                        String objectiveName = args[3];
-                        Objective objective = mainScoreboard.getObjective(objectiveName);
-                        if (objective == null) {
-                            sender.sendMessage(ChatColor.RED + "No objective was found by the name '" + objectiveName + "'");
-                            return false;
-                        }
-
-                        objective.setDisplaySlot(slot);
-                        sender.sendMessage("Set the display objective in slot '" + slotName + "' to '" + objective.getName() + "'");
-                    } else {
-                        Objective objective = mainScoreboard.getObjective(slot);
-                        if (objective != null) {
-                            objective.setDisplaySlot(null);
-                        }
-                        sender.sendMessage("Cleared objective display slot '" + slotName + "'");
-                    }
-                }
-            }
-        } else if (args[0].equalsIgnoreCase("players")) {
-            if (args.length == 1) {
-                sender.sendMessage(ChatColor.RED + "/scoreboard players <set|add|remove|reset|list>");
-                return false;
-            }
-            if (args[1].equalsIgnoreCase("set") || args[1].equalsIgnoreCase("add") || args[1].equalsIgnoreCase("remove")) {
-                if (args.length != 5) {
-                    if (args[1].equalsIgnoreCase("set")) {
-                        sender.sendMessage(ChatColor.RED + "/scoreboard players set <player> <objective> <score>");
-                    } else if (args[1].equalsIgnoreCase("add")) {
-                        sender.sendMessage(ChatColor.RED + "/scoreboard players add <player> <objective> <count>");
-                    } else {
-                        sender.sendMessage(ChatColor.RED + "/scoreboard players remove <player> <objective> <count>");
-                    }
-                    return false;
-                }
-                String objectiveName = args[3];
-                Objective objective = mainScoreboard.getObjective(objectiveName);
-                if (objective == null) {
-                    sender.sendMessage(ChatColor.RED + "No objective was found by the name '" + objectiveName + "'");
-                    return false;
-                } else if (!objective.isModifiable()) {
-                    sender.sendMessage(ChatColor.RED + "The objective '" + objectiveName + "' is read-only and cannot be set");
-                    return false;
-                }
-
-                String valueString = args[4];
-                int value;
-                try {
-                    value = Integer.parseInt(valueString);
-                } catch (NumberFormatException e) {
-                    sender.sendMessage(ChatColor.RED + "'" + valueString + "' is not a valid number");
-                    return false;
-                }
-                if (value < 1 && !args[1].equalsIgnoreCase("set")) {
-                    sender.sendMessage(ChatColor.RED + "The number you have entered (" + value + ") is too small, it must be at least 1");
-                    return false;
-                }
-
-                String playerName = args[2];
-                if (playerName.length() > 16) {
-                    sender.sendMessage(ChatColor.RED + "'" + playerName + "' is too long for a player name");
-                    return false;
-                }
-                Score score = objective.getScore(playerName);
-                int newScore;
-                if (args[1].equalsIgnoreCase("set")) {
-                    newScore = value;
-                } else if (args[1].equalsIgnoreCase("add")) {
-                    newScore = score.getScore() + value;
-                } else {
-                    newScore = score.getScore() - value;
-                }
-                score.setScore(newScore);
-                sender.sendMessage("Set score of " + objectiveName + " for player " + playerName + " to " + newScore);
-            } else if (args[1].equalsIgnoreCase("reset")) {
-                if (args.length != 3) {
-                    sender.sendMessage(ChatColor.RED + "/scoreboard players reset <player>");
-                    return false;
-                }
-                String playerName = args[2];
-                if (playerName.length() > 16) {
-                    sender.sendMessage(ChatColor.RED + "'" + playerName + "' is too long for a player name");
-                    return false;
-                }
-                mainScoreboard.resetScores(playerName);
-                sender.sendMessage("Reset all scores of player " + playerName);
-            } else if (args[1].equalsIgnoreCase("list")) {
-                if (args.length > 3) {
-                    sender.sendMessage(ChatColor.RED + "/scoreboard players list <player>");
-                    return false;
-                }
-                if (args.length == 2) {
-                    Set<String> entries = mainScoreboard.getEntries();
-                    if (entries.isEmpty()) {
-                        sender.sendMessage(ChatColor.RED + "There are no tracked players on the scoreboard");
-                    } else {
-                        sender.sendMessage(ChatColor.DARK_GREEN + "Showing " + entries.size() + " tracked players on the scoreboard");
-                        sender.sendMessage(stringCollectionToString(entries));
-                    }
-                } else {
-                    String playerName = args[2];
-                    if (playerName.length() > 16) {
-                        sender.sendMessage(ChatColor.RED + "'" + playerName + "' is too long for a player name");
-                        return false;
-                    }
-                    Set<Score> scores = mainScoreboard.getScores(playerName);
-                    if (scores.isEmpty()) {
-                        sender.sendMessage(ChatColor.RED + "Player " + playerName + " has no scores recorded");
-                    } else {
-                        sender.sendMessage(ChatColor.DARK_GREEN + "Showing " + scores.size() + " tracked objective(s) for " + playerName);
-                        for (Score score : scores) {
-                            sender.sendMessage("- " + score.getObjective().getDisplayName() + ": " + score.getScore() + " (" + score.getObjective().getName() + ")");
-                        }
-                    }
-                }
-            }
-        } else if (args[0].equalsIgnoreCase("teams")) {
-            if (args.length == 1) {
-                sender.sendMessage(ChatColor.RED + "/scoreboard teams <list|add|remove|empty|join|leave|option>");
-                return false;
-            }
-            if (args[1].equalsIgnoreCase("list")) {
-                if (args.length == 2) {
-                    Set<Team> teams = mainScoreboard.getTeams();
-                    if (teams.isEmpty()) {
-                        sender.sendMessage(ChatColor.RED + "There are no teams registered on the scoreboard");
-                    } else {
-                        sender.sendMessage(ChatColor.DARK_GREEN + "Showing " + teams.size() + " teams on the scoreboard");
-                        for (Team team : teams) {
-                            sender.sendMessage("- " + team.getName() + ": '" + team.getDisplayName() + "' has " + team.getSize() + " players");
-                        }
-                    }
-                } else if (args.length == 3) {
-                    String teamName = args[2];
-                    Team team = mainScoreboard.getTeam(teamName);
-                    if (team == null) {
-                        sender.sendMessage(ChatColor.RED + "No team was found by the name '" + teamName + "'");
-                    } else {
-                        Set<OfflinePlayer> players = team.getPlayers();
-                        if (players.isEmpty()) {
-                            sender.sendMessage(ChatColor.RED + "Team " + team.getName() + " has no players");
-                        } else {
-                            sender.sendMessage(ChatColor.DARK_GREEN + "Showing " + players.size() + " player(s) in team " + team.getName());
-                            sender.sendMessage(offlinePlayerSetToString(players));
-                        }
-                    }
-                } else {
-                    sender.sendMessage(ChatColor.RED + "/scoreboard teams list [name]");
-                    return false;
-                }
-            } else if (args[1].equalsIgnoreCase("add")) {
-                if (args.length < 3) {
-                    sender.sendMessage(ChatColor.RED + "/scoreboard teams add <name> [display name ...]");
-                    return false;
-                }
-                String name = args[2];
-                if (name.length() > 16) {
-                    sender.sendMessage(ChatColor.RED + "The name '" + name + "' is too long for a team, it can be at most 16 characters long");
-                } else if (mainScoreboard.getTeam(name) != null) {
-                    sender.sendMessage(ChatColor.RED + "A team with the name '" + name + "' already exists");
-                } else {
-                    String displayName = null;
-                    if (args.length > 3) {
-                        displayName = StringUtils.join(ArrayUtils.subarray(args, 3, args.length), ' ');
-                        if (displayName.length() > 32) {
-                            sender.sendMessage(ChatColor.RED + "The display name '" + displayName + "' is too long for a team, it can be at most 32 characters long");
-                            return false;
-                        }
-                    }
-                    Team team = mainScoreboard.registerNewTeam(name);
-                    if (displayName != null && displayName.length() > 0) {
-                        team.setDisplayName(displayName);
-                    }
-                    sender.sendMessage("Added new team '" + team.getName() + "' successfully");
-                }
-            } else if (args[1].equalsIgnoreCase("remove")) {
-                if (args.length != 3) {
-                    sender.sendMessage(ChatColor.RED + "/scoreboard teams remove <name>");
-                    return false;
-                }
-                String name = args[2];
-                Team team = mainScoreboard.getTeam(name);
-                if (team == null) {
-                    sender.sendMessage(ChatColor.RED + "No team was found by the name '" + name + "'");
-                } else {
-                    team.unregister();
-                    sender.sendMessage("Removed team " + name);
-                }
-            } else if (args[1].equalsIgnoreCase("empty")) {
-                if (args.length != 3) {
-                    sender.sendMessage(ChatColor.RED + "/scoreboard teams clear <name>");
-                    return false;
-                }
-                String name = args[2];
-                Team team = mainScoreboard.getTeam(name);
-                if (team == null) {
-                    sender.sendMessage(ChatColor.RED + "No team was found by the name '" + name + "'");
-                } else {
-                    Set<OfflinePlayer> players = team.getPlayers();
-                    if (players.isEmpty()) {
-                        sender.sendMessage(ChatColor.RED + "Team " + team.getName() + " is already empty, cannot remove nonexistant players");
-                    } else {
-                        for (OfflinePlayer player : players) {
-                            team.removePlayer(player);
-                        }
-                        sender.sendMessage("Removed all " + players.size() + " player(s) from team " + team.getName());
-                    }
-                }
-            } else if (args[1].equalsIgnoreCase("join")) {
-                if ((sender instanceof Player) ? args.length < 3 : args.length < 4) {
-                    sender.sendMessage(ChatColor.RED + "/scoreboard teams join <team> [player...]");
-                    return false;
-                }
-                String teamName = args[2];
-                Team team = mainScoreboard.getTeam(teamName);
-                if (team == null) {
-                    sender.sendMessage(ChatColor.RED + "No team was found by the name '" + teamName + "'");
-                } else {
-                    Set<String> addedPlayers = new HashSet<String>();
-                    if ((sender instanceof Player) && args.length == 3) {
-                        team.addPlayer((Player) sender);
-                        addedPlayers.add(sender.getName());
-                    } else {
-                        for (int i = 3; i < args.length; i++) {
-                            String playerName = args[i];
-                            OfflinePlayer offlinePlayer;
-                            Player player = Bukkit.getPlayerExact(playerName);
-                            if (player != null) {
-                                offlinePlayer = player;
-                            } else {
-                                offlinePlayer = Bukkit.getOfflinePlayer(playerName);
-                            }
-                            team.addPlayer(offlinePlayer);
-                            addedPlayers.add(offlinePlayer.getName());
-                        }
-                    }
-                    sender.sendMessage("Added " + addedPlayers.size() + " player(s) to team " + team.getName() + ": " + stringCollectionToString(addedPlayers));
-                }
-            } else if (args[1].equalsIgnoreCase("leave")) {
-                if (!(sender instanceof Player) && args.length < 3) {
-                    sender.sendMessage(ChatColor.RED + "/scoreboard teams leave [player...]");
-                    return false;
-                }
-                Set<String> left = new HashSet<String>();
-                Set<String> noTeam = new HashSet<String>();
-                if ((sender instanceof Player) && args.length == 2) {
-                    Team team = mainScoreboard.getPlayerTeam((Player) sender);
-                    if (team != null) {
-                        team.removePlayer((Player) sender);
-                        left.add(sender.getName());
-                    } else {
-                        noTeam.add(sender.getName());
-                    }
-                } else {
-                    for (int i = 2; i < args.length; i++) {
-                        String playerName = args[i];
-                        OfflinePlayer offlinePlayer;
-                        Player player = Bukkit.getPlayerExact(playerName);
-                        if (player != null) {
-                            offlinePlayer = player;
-                        } else {
-                            offlinePlayer = Bukkit.getOfflinePlayer(playerName);
-                        }
-                        Team team = mainScoreboard.getPlayerTeam(offlinePlayer);
-                        if (team != null) {
-                            team.removePlayer(offlinePlayer);
-                            left.add(offlinePlayer.getName());
-                        } else {
-                            noTeam.add(offlinePlayer.getName());
-                        }
-                    }
-                }
-                if (!left.isEmpty()) {
-                    sender.sendMessage("Removed " + left.size() + " player(s) from their teams: " + stringCollectionToString(left));
-                }
-                if (!noTeam.isEmpty()) {
-                    sender.sendMessage("Could not remove " + noTeam.size() + " player(s) from their teams: " + stringCollectionToString(noTeam));
-                }
-            } else if (args[1].equalsIgnoreCase("option")) {
-                if (args.length != 4 && args.length != 5) {
-                    sender.sendMessage(ChatColor.RED + "/scoreboard teams option <team> <friendlyfire|color|seefriendlyinvisibles> <value>");
-                    return false;
-                }
-                String teamName = args[2];
-                Team team = mainScoreboard.getTeam(teamName);
-                if (team == null) {
-                    sender.sendMessage(ChatColor.RED + "No team was found by the name '" + teamName + "'");
-                    return false;
-                }
-                String option = args[3].toLowerCase();
-                if (!option.equals("friendlyfire") && !option.equals("color") && !option.equals("seefriendlyinvisibles")) {
-                    sender.sendMessage(ChatColor.RED + "/scoreboard teams option <team> <friendlyfire|color|seefriendlyinvisibles> <value>");
-                    return false;
-                }
-                if (args.length == 4) {
-                    if (option.equals("color")) {
-                        sender.sendMessage(ChatColor.RED + "Valid values for option color are: " + stringCollectionToString(TEAMS_OPTION_COLOR.keySet()));
-                    } else {
-                        sender.sendMessage(ChatColor.RED + "Valid values for option " + option + " are: true and false");
-                    }
-                } else {
-                    String value = args[4].toLowerCase();
-                    if (option.equals("color")) {
-                        ChatColor color = TEAMS_OPTION_COLOR.get(value);
-                        if (color == null) {
-                            sender.sendMessage(ChatColor.RED + "Valid values for option color are: " + stringCollectionToString(TEAMS_OPTION_COLOR.keySet()));
-                            return false;
-                        }
-                        team.setPrefix(color.toString());
-                        team.setSuffix(ChatColor.RESET.toString());
-                    } else {
-                        if (!value.equals("true") && !value.equals("false")) {
-                            sender.sendMessage(ChatColor.RED + "Valid values for option " + option + " are: true and false");
-                            return false;
-                        }
-                        if (option.equals("friendlyfire")) {
-                            team.setAllowFriendlyFire(value.equals("true"));
-                        } else {
-                            team.setCanSeeFriendlyInvisibles(value.equals("true"));
-                        }
-                    }
-                    sender.sendMessage("Set option " + option + " for team " + team.getName() + " to " + value);
-                }
-            }
-        } else {
-            sender.sendMessage(ChatColor.RED + "Usage: /scoreboard <objectives|players|teams>");
-            return false;
-        }
-        return true;
-    }
-
-    @Override
-    public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {
-        Validate.notNull(sender, "Sender cannot be null");
-        Validate.notNull(args, "Arguments cannot be null");
-        Validate.notNull(alias, "Alias cannot be null");
-
-        if (args.length == 1) {
-            return StringUtil.copyPartialMatches(args[0], MAIN_CHOICES, new ArrayList<String>());
-        }
-        if (args.length > 1) {
-            if (args[0].equalsIgnoreCase("objectives")) {
-                if (args.length == 2) {
-                    return StringUtil.copyPartialMatches(args[1], OBJECTIVES_CHOICES, new ArrayList<String>());
-                }
-                if (args[1].equalsIgnoreCase("add")) {
-                    if (args.length == 4) {
-                        return StringUtil.copyPartialMatches(args[3], OBJECTIVES_CRITERIA, new ArrayList<String>());
-                    }
-                } else if (args[1].equalsIgnoreCase("remove")) {
-                    if (args.length == 3) {
-                        return StringUtil.copyPartialMatches(args[2], this.getCurrentObjectives(), new ArrayList<String>());
-                    }
-                } else if (args[1].equalsIgnoreCase("setdisplay")) {
-                    if (args.length == 3) {
-                        return StringUtil.copyPartialMatches(args[2], OBJECTIVES_DISPLAYSLOT.keySet(), new ArrayList<String>());
-                    }
-                    if (args.length == 4) {
-                        return StringUtil.copyPartialMatches(args[3], this.getCurrentObjectives(), new ArrayList<String>());
-                    }
-                }
-            } else if (args[0].equalsIgnoreCase("players")) {
-                if (args.length == 2) {
-                    return StringUtil.copyPartialMatches(args[1], PLAYERS_CHOICES, new ArrayList<String>());
-                }
-                if (args[1].equalsIgnoreCase("set") || args[1].equalsIgnoreCase("add") || args[1].equalsIgnoreCase("remove")) {
-                    if (args.length == 3) {
-                        return super.tabComplete(sender, alias, args);
-                    }
-                    if (args.length == 4) {
-                        return StringUtil.copyPartialMatches(args[3], this.getCurrentObjectives(), new ArrayList<String>());
-                    }
-                } else {
-                    if (args.length == 3) {
-                        return StringUtil.copyPartialMatches(args[2], this.getCurrentEntries(), new ArrayList<String>());
-                    }
-                }
-            } else if (args[0].equalsIgnoreCase("teams")) {
-                if (args.length == 2) {
-                    return StringUtil.copyPartialMatches(args[1], TEAMS_CHOICES, new ArrayList<String>());
-                }
-                if (args[1].equalsIgnoreCase("join")) {
-                    if (args.length == 3) {
-                        return StringUtil.copyPartialMatches(args[2], this.getCurrentTeams(), new ArrayList<String>());
-                    }
-                    if (args.length >= 4) {
-                        return super.tabComplete(sender, alias, args);
-                    }
-                } else if (args[1].equalsIgnoreCase("leave")) {
-                    return super.tabComplete(sender, alias, args);
-                } else if (args[1].equalsIgnoreCase("option")) {
-                    if (args.length == 3) {
-                        return StringUtil.copyPartialMatches(args[2], this.getCurrentTeams(), new ArrayList<String>());
-                    }
-                    if (args.length == 4) {
-                        return StringUtil.copyPartialMatches(args[3], TEAMS_OPTION_CHOICES, new ArrayList<String>());
-                    }
-                    if (args.length == 5) {
-                        if (args[3].equalsIgnoreCase("color")) {
-                            return StringUtil.copyPartialMatches(args[4], TEAMS_OPTION_COLOR.keySet(), new ArrayList<String>());
-                        } else {
-                            return StringUtil.copyPartialMatches(args[4], BOOLEAN, new ArrayList<String>());
-                        }
-                    }
-                } else {
-                    if (args.length == 3) {
-                        return StringUtil.copyPartialMatches(args[2], this.getCurrentTeams(), new ArrayList<String>());
-                    }
-                }
-            }
-        }
-
-        return ImmutableList.of();
-    }
-
-    private static String offlinePlayerSetToString(Set<OfflinePlayer> set) {
-        StringBuilder string = new StringBuilder();
-        String lastValue = null;
-        for (OfflinePlayer value : set) {
-            string.append(lastValue = value.getName()).append(", ");
-        }
-        string.delete(string.length() - 2, Integer.MAX_VALUE);
-        if (string.length() != lastValue.length()) {
-            string.insert(string.length() - lastValue.length(), "and ");
-        }
-        return string.toString();
-
-    }
-
-    private static String stringCollectionToString(Collection<String> set) {
-        StringBuilder string = new StringBuilder();
-        String lastValue = null;
-        for (String value : set) {
-            string.append(lastValue = value).append(", ");
-        }
-        string.delete(string.length() - 2, Integer.MAX_VALUE);
-        if (string.length() != lastValue.length()) {
-            string.insert(string.length() - lastValue.length(), "and ");
-        }
-        return string.toString();
-    }
-
-    private List<String> getCurrentObjectives() {
-        List<String> list = new ArrayList<String>();
-        for (Objective objective : Bukkit.getScoreboardManager().getMainScoreboard().getObjectives()) {
-            list.add(objective.getName());
-        }
-        Collections.sort(list, String.CASE_INSENSITIVE_ORDER);
-        return list;
-    }
-
-    private List<String> getCurrentEntries() {
-        List<String> list = new ArrayList<String>();
-        for (String entry : Bukkit.getScoreboardManager().getMainScoreboard().getEntries()) {
-            list.add(entry);
-        }
-        Collections.sort(list, String.CASE_INSENSITIVE_ORDER);
-        return list;
-    }
-
-    private List<String> getCurrentTeams() {
-        List<String> list = new ArrayList<String>();
-        for (Team team : Bukkit.getScoreboardManager().getMainScoreboard().getTeams()) {
-            list.add(team.getName());
-        }
-        Collections.sort(list, String.CASE_INSENSITIVE_ORDER);
-        return list;
-    }
-}
diff --git a/src/main/java/org/bukkit/command/defaults/SeedCommand.java b/src/main/java/org/bukkit/command/defaults/SeedCommand.java
deleted file mode 100644
index 3fb0639..0000000
--- a/src/main/java/org/bukkit/command/defaults/SeedCommand.java
+++ /dev/null
@@ -1,42 +0,0 @@
-package org.bukkit.command.defaults;
-
-import java.util.List;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.Bukkit;
-import org.bukkit.command.CommandSender;
-import org.bukkit.entity.Player;
-
-import com.google.common.collect.ImmutableList;
-
-@Deprecated
-public class SeedCommand extends VanillaCommand {
-    public SeedCommand() {
-        super("seed");
-        this.description = "Shows the world seed";
-        this.usageMessage = "/seed";
-        this.setPermission("bukkit.command.seed");
-    }
-
-    @Override
-    public boolean execute(CommandSender sender, String commandLabel, String[] args) {
-        if (!testPermission(sender)) return true;
-        long seed;
-        if (sender instanceof Player) {
-            seed = ((Player) sender).getWorld().getSeed();
-        } else {
-            seed = Bukkit.getWorlds().get(0).getSeed();
-        }
-        sender.sendMessage("Seed: " + seed);
-        return true;
-    }
-
-    @Override
-    public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {
-        Validate.notNull(sender, "Sender cannot be null");
-        Validate.notNull(args, "Arguments cannot be null");
-        Validate.notNull(alias, "Alias cannot be null");
-
-        return ImmutableList.of();
-    }
-}
diff --git a/src/main/java/org/bukkit/command/defaults/SetIdleTimeoutCommand.java b/src/main/java/org/bukkit/command/defaults/SetIdleTimeoutCommand.java
deleted file mode 100644
index f6cbe03..0000000
--- a/src/main/java/org/bukkit/command/defaults/SetIdleTimeoutCommand.java
+++ /dev/null
@@ -1,54 +0,0 @@
-package org.bukkit.command.defaults;
-
-import com.google.common.collect.ImmutableList;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.Bukkit;
-import org.bukkit.ChatColor;
-import org.bukkit.command.Command;
-import org.bukkit.command.CommandSender;
-
-import java.util.List;
-
-@Deprecated
-public class SetIdleTimeoutCommand extends VanillaCommand {
-
-    public SetIdleTimeoutCommand() {
-        super("setidletimeout");
-        this.description = "Sets the server's idle timeout";
-        this.usageMessage = "/setidletimeout <Minutes until kick>";
-        this.setPermission("bukkit.command.setidletimeout");
-    }
-
-    @Override
-    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
-        if (!testPermission(sender)) return true;
-
-        if (args.length == 1) {
-            int minutes;
-
-            try {
-                minutes = getInteger(sender, args[0], 0, Integer.MAX_VALUE, true);
-            } catch (NumberFormatException ex) {
-                sender.sendMessage(ex.getMessage());
-                return true;
-            }
-
-            Bukkit.getServer().setIdleTimeout(minutes);
-
-            Command.broadcastCommandMessage(sender, "Successfully set the idle timeout to " + minutes + " minutes.");
-            return true;
-        }
-        sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
-        return false;
-    }
-
-    @Override
-    public List<String> tabComplete(CommandSender sender, String alias, String[] args) {
-        Validate.notNull(sender, "Sender cannot be null");
-        Validate.notNull(args, "Arguments cannot be null");
-        Validate.notNull(alias, "Alias cannot be null");
-
-        return ImmutableList.of();
-    }
-}
diff --git a/src/main/java/org/bukkit/command/defaults/SetWorldSpawnCommand.java b/src/main/java/org/bukkit/command/defaults/SetWorldSpawnCommand.java
deleted file mode 100644
index 8bec19c..0000000
--- a/src/main/java/org/bukkit/command/defaults/SetWorldSpawnCommand.java
+++ /dev/null
@@ -1,80 +0,0 @@
-package org.bukkit.command.defaults;
-
-import com.google.common.collect.ImmutableList;
-import org.apache.commons.lang.Validate;
-import org.bukkit.Bukkit;
-import org.bukkit.ChatColor;
-import org.bukkit.Location;
-import org.bukkit.World;
-import org.bukkit.command.Command;
-import org.bukkit.command.CommandSender;
-import org.bukkit.entity.Player;
-
-import java.util.List;
-
-@Deprecated
-public class SetWorldSpawnCommand extends VanillaCommand {
-
-    public SetWorldSpawnCommand() {
-        super("setworldspawn");
-        this.description = "Sets a worlds's spawn point. If no coordinates are specified, the player's coordinates will be used.";
-        this.usageMessage = "/setworldspawn OR /setworldspawn <x> <y> <z>";
-        this.setPermission("bukkit.command.setworldspawn");
-    }
-
-    @Override
-    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
-        if (!testPermission(sender)) return true;
-
-        Player player = null;
-        World world;
-        if (sender instanceof Player) {
-            player = (Player) sender;
-            world = player.getWorld();
-        } else {
-            world = Bukkit.getWorlds().get(0);
-        }
-
-        final int x, y, z;
-
-        if (args.length == 0) {
-            if (player == null) {
-                sender.sendMessage("You can only perform this command as a player");
-                return true;
-            }
-
-            Location location = player.getLocation();
-
-            x = location.getBlockX();
-            y = location.getBlockY();
-            z = location.getBlockZ();
-        } else if (args.length == 3) {
-            try {
-                x = getInteger(sender, args[0], MIN_COORD, MAX_COORD, true);
-                y = getInteger(sender, args[1], 0, world.getMaxHeight(), true);
-                z = getInteger(sender, args[2], MIN_COORD, MAX_COORD, true);
-            } catch (NumberFormatException ex) {
-                sender.sendMessage(ex.getMessage());
-                return true;
-            }
-        } else {
-            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
-            return false;
-        }
-
-        world.setSpawnLocation(x, y, z);
-
-        Command.broadcastCommandMessage(sender, "Set world " + world.getName() + "'s spawnpoint to (" + x + ", " + y + ", " + z + ")");
-        return true;
-
-    }
-
-    @Override
-    public List<String> tabComplete(CommandSender sender, String alias, String[] args) {
-        Validate.notNull(sender, "Sender cannot be null");
-        Validate.notNull(args, "Arguments cannot be null");
-        Validate.notNull(alias, "Alias cannot be null");
-
-        return ImmutableList.of();
-    }
-}
diff --git a/src/main/java/org/bukkit/command/defaults/SpawnpointCommand.java b/src/main/java/org/bukkit/command/defaults/SpawnpointCommand.java
deleted file mode 100644
index be15f7e..0000000
--- a/src/main/java/org/bukkit/command/defaults/SpawnpointCommand.java
+++ /dev/null
@@ -1,88 +0,0 @@
-package org.bukkit.command.defaults;
-
-import com.google.common.collect.ImmutableList;
-import org.apache.commons.lang.Validate;
-import org.bukkit.Bukkit;
-import org.bukkit.ChatColor;
-import org.bukkit.Location;
-import org.bukkit.World;
-import org.bukkit.command.Command;
-import org.bukkit.command.CommandSender;
-import org.bukkit.entity.Player;
-
-import java.util.List;
-
-@Deprecated
-public class SpawnpointCommand extends VanillaCommand {
-
-    public SpawnpointCommand() {
-        super("spawnpoint");
-        this.description = "Sets a player's spawn point";
-        this.usageMessage = "/spawnpoint OR /spawnpoint <player> OR /spawnpoint <player> <x> <y> <z>";
-        this.setPermission("bukkit.command.spawnpoint");
-    }
-
-    @Override
-    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
-        if (!testPermission(sender)) return true;
-
-        Player player;
-
-        if (args.length == 0) {
-            if (sender instanceof Player) {
-                player = (Player) sender;
-            } else {
-                sender.sendMessage("Please provide a player!");
-                return true;
-            }
-        } else {
-            player = Bukkit.getPlayerExact(args[0]);
-            if (player == null) {
-                sender.sendMessage("Can't find player " + args[0]);
-                return true;
-            }
-        }
-
-        World world = player.getWorld();
-
-        if (args.length == 4) {
-            if (world != null) {
-                int pos = 1;
-                final int x, y, z;
-                try {
-                    x = getInteger(sender, args[pos++], MIN_COORD, MAX_COORD, true);
-                    y = getInteger(sender, args[pos++], 0, world.getMaxHeight());
-                    z = getInteger(sender, args[pos], MIN_COORD, MAX_COORD, true);
-                } catch(NumberFormatException ex) {
-                    sender.sendMessage(ex.getMessage());
-                    return true;
-                }
-
-                player.setBedSpawnLocation(new Location(world, x, y, z), true);
-                Command.broadcastCommandMessage(sender, "Set " + player.getDisplayName() + "'s spawnpoint to " + x + ", " + y + ", " + z);
-            }
-        } else if (args.length <= 1) {
-            Location location = player.getLocation();
-            player.setBedSpawnLocation(location, true);
-            Command.broadcastCommandMessage(sender, "Set " + player.getDisplayName() + "'s spawnpoint to " + location.getX() + ", " + location.getY() + ", " + location.getZ());
-        } else {
-            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
-            return false;
-        }
-
-        return true;
-    }
-
-    @Override
-    public List<String> tabComplete(CommandSender sender, String alias, String[] args) {
-        Validate.notNull(sender, "Sender cannot be null");
-        Validate.notNull(args, "Arguments cannot be null");
-        Validate.notNull(alias, "Alias cannot be null");
-
-        if (args.length == 1) {
-            return super.tabComplete(sender, alias, args);
-        }
-
-        return ImmutableList.of();
-    }
-}
diff --git a/src/main/java/org/bukkit/command/defaults/SpreadPlayersCommand.java b/src/main/java/org/bukkit/command/defaults/SpreadPlayersCommand.java
deleted file mode 100644
index 489f760..0000000
--- a/src/main/java/org/bukkit/command/defaults/SpreadPlayersCommand.java
+++ /dev/null
@@ -1,266 +0,0 @@
-package org.bukkit.command.defaults;
-
-import com.google.common.collect.Lists;
-import com.google.common.collect.Maps;
-import com.google.common.collect.Sets;
-import java.util.List;
-import java.util.Map;
-import java.util.Random;
-import java.util.Set;
-
-import org.bukkit.Bukkit;
-import org.bukkit.ChatColor;
-import org.bukkit.Location;
-import org.bukkit.World;
-import org.bukkit.command.CommandSender;
-import org.bukkit.entity.Player;
-import org.bukkit.scoreboard.Team;
-
-@Deprecated
-public class SpreadPlayersCommand extends VanillaCommand {
-    private static final Random random = new Random();
-
-    public SpreadPlayersCommand() {
-        super("spreadplayers");
-        this.description = "Spreads players around a point";
-        this.usageMessage = "/spreadplayers <x> <z> <spreadDistance> <maxRange> <respectTeams true|false> <player ...>";
-        this.setPermission("bukkit.command.spreadplayers");
-    }
-
-    @Override
-    public boolean execute(CommandSender sender, String commandLabel, String[] args) {
-        if (!testPermission(sender)) {
-            return true;
-        }
-
-        if (args.length < 6) {
-            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
-            return false;
-        }
-
-        final double x = getDouble(sender, args[0], -30000000, 30000000);
-        final double z = getDouble(sender, args[1], -30000000, 30000000);
-        final double distance = getDouble(sender, args[2]);
-        final double range = getDouble(sender, args[3]);
-
-        if (distance < 0.0D) {
-            sender.sendMessage(ChatColor.RED + "Distance is too small.");
-            return false;
-        }
-
-        if (range < distance + 1.0D) {
-            sender.sendMessage(ChatColor.RED + "Max range is too small.");
-            return false;
-        }
-
-        final String respectTeams = args[4];
-        boolean teams = false;
-
-        if (respectTeams.equalsIgnoreCase("true")) {
-            teams = true;
-        } else if (!respectTeams.equalsIgnoreCase("false")) {
-            sender.sendMessage(String.format(ChatColor.RED + "'%s' is not true or false", args[4]));
-            return false;
-        }
-
-        List<Player> players = Lists.newArrayList();
-        World world = null;
-
-        for (int i = 5; i < args.length; i++) {
-            Player player = Bukkit.getPlayerExact(args[i]);
-            if (player == null) {
-                continue;
-            }
-
-            if (world == null) {
-                world = player.getWorld();
-            }
-            players.add(player);
-        }
-
-        if (world == null) {
-            return true;
-        }
-
-        final double xRangeMin = x - range;
-        final double zRangeMin = z - range;
-        final double xRangeMax = x + range;
-        final double zRangeMax = z + range;
-
-        final int spreadSize = teams ? getTeams(players) : players.size();
-
-        final Location[] locations = getSpreadLocations(world, spreadSize, xRangeMin, zRangeMin, xRangeMax, zRangeMax);
-        final int rangeSpread = range(world, distance, xRangeMin, zRangeMin, xRangeMax, zRangeMax, locations);
-
-        if (rangeSpread == -1) {
-            sender.sendMessage(String.format("Could not spread %d %s around %s,%s (too many players for space - try using spread of at most %s)", spreadSize, teams ? "teams" : "players", x, z));
-            return false;
-        }
-
-        final double distanceSpread = spread(world, players, locations, teams);
-
-        sender.sendMessage(String.format("Succesfully spread %d %s around %s,%s", locations.length, teams ? "teams" : "players", x, z));
-        if (locations.length > 1) {
-            sender.sendMessage(String.format("(Average distance between %s is %s blocks apart after %s iterations)", teams ? "teams" : "players",  String.format("%.2f", distanceSpread), rangeSpread));
-        }
-        return true;
-    }
-
-    private int range(World world, double distance, double xRangeMin, double zRangeMin, double xRangeMax, double zRangeMax, Location[] locations) {
-        boolean flag = true;
-        double max;
-
-        int i;
-
-        for (i = 0; i < 10000 && flag; ++i) {
-            flag = false;
-            max = Float.MAX_VALUE;
-
-            Location loc1;
-            int j;
-
-            for (int k = 0; k < locations.length; ++k) {
-                Location loc2 = locations[k];
-
-                j = 0;
-                loc1 = new Location(world, 0, 0, 0);
-
-                for (int l = 0; l < locations.length; ++l) {
-                    if (k != l) {
-                        Location loc3 = locations[l];
-                        double dis = loc2.distanceSquared(loc3);
-
-                        max = Math.min(dis, max);
-                        if (dis < distance) {
-                            ++j;
-                            loc1.add(loc3.getX() - loc2.getX(), 0, 0);
-                            loc1.add(loc3.getZ() - loc2.getZ(), 0, 0);
-                        }
-                    }
-                }
-
-                if (j > 0) {
-                    loc2.setX(loc2.getX() / j);
-                    loc2.setZ(loc2.getZ() / j);
-                    double d7 = Math.sqrt(loc1.getX() * loc1.getX() + loc1.getZ() * loc1.getZ());
-
-                    if (d7 > 0.0D) {
-                        loc1.setX(loc1.getX() / d7);
-                        loc2.add(-loc1.getX(), 0, -loc1.getZ());
-                    } else {
-                        double x = xRangeMin >= xRangeMax ? xRangeMin : random.nextDouble() * (xRangeMax - xRangeMin) + xRangeMin;
-                        double z = zRangeMin >= zRangeMax ? zRangeMin : random.nextDouble() * (zRangeMax - zRangeMin) + zRangeMin;
-                        loc2.setX(x);
-                        loc2.setZ(z);
-                    }
-
-                    flag = true;
-                }
-
-                boolean swap = false;
-
-                if (loc2.getX() < xRangeMin) {
-                    loc2.setX(xRangeMin);
-                    swap = true;
-                } else if (loc2.getX() > xRangeMax) {
-                    loc2.setX(xRangeMax);
-                    swap = true;
-                }
-
-                if (loc2.getZ() < zRangeMin) {
-                    loc2.setZ(zRangeMin);
-                    swap = true;
-                } else if (loc2.getZ() > zRangeMax) {
-                    loc2.setZ(zRangeMax);
-                    swap = true;
-                }
-                if (swap) {
-                    flag = true;
-                }
-            }
-
-            if (!flag) {
-                Location[] locs = locations;
-                int i1 = locations.length;
-
-                for (j = 0; j < i1; ++j) {
-                    loc1 = locs[j];
-                    if (world.getHighestBlockYAt(loc1) == 0) {
-                        double x = xRangeMin >= xRangeMax ? xRangeMin : random.nextDouble() * (xRangeMax - xRangeMin) + xRangeMin;
-                        double z = zRangeMin >= zRangeMax ? zRangeMin : random.nextDouble() * (zRangeMax - zRangeMin) + zRangeMin;
-                        locations[i] = (new Location(world, x, 0, z));
-                        loc1.setX(x);
-                        loc1.setZ(z);
-                        flag = true;
-                    }
-                }
-            }
-        }
-
-        if (i >= 10000) {
-            return -1;
-        } else {
-            return i;
-        }
-    }
-
-    private double spread(World world, List<Player> list, Location[] locations, boolean teams) {
-        double distance = 0.0D;
-        int i = 0;
-        Map<Team, Location> hashmap = Maps.newHashMap();
-
-        for (int j = 0; j < list.size(); ++j) {
-            Player player = list.get(j);
-            Location location;
-
-            if (teams) {
-                Team team = player.getScoreboard().getPlayerTeam(player);
-
-                if (!hashmap.containsKey(team)) {
-                    hashmap.put(team, locations[i++]);
-                }
-
-                location = hashmap.get(team);
-            } else {
-                location = locations[i++];
-            }
-
-            player.teleport(new Location(world, Math.floor(location.getX()) + 0.5D, world.getHighestBlockYAt((int) location.getX(), (int) location.getZ()), Math.floor(location.getZ()) + 0.5D));
-            double value = Double.MAX_VALUE;
-
-            for (int k = 0; k < locations.length; ++k) {
-                if (location != locations[k]) {
-                    double d = location.distanceSquared(locations[k]);
-                    value = Math.min(d, value);
-                }
-            }
-
-            distance += value;
-        }
-
-        distance /= list.size();
-        return distance;
-    }
-
-    private int getTeams(List<Player> players) {
-        Set<Team> teams = Sets.newHashSet();
-
-        for (Player player : players) {
-            teams.add(player.getScoreboard().getPlayerTeam(player));
-        }
-
-        return teams.size();
-    }
-
-    private Location[] getSpreadLocations(World world, int size, double xRangeMin, double zRangeMin, double xRangeMax, double zRangeMax) {
-        Location[] locations = new Location[size];
-
-        for (int i = 0; i < size; ++i) {
-            double x = xRangeMin >= xRangeMax ? xRangeMin : random.nextDouble() * (xRangeMax - xRangeMin) + xRangeMin;
-            double z = zRangeMin >= zRangeMax ? zRangeMin : random.nextDouble() * (zRangeMax - zRangeMin) + zRangeMin;
-            locations[i] = (new Location(world, x, 0, z));
-        }
-
-        return locations;
-    }
-}
diff --git a/src/main/java/org/bukkit/command/defaults/StopCommand.java b/src/main/java/org/bukkit/command/defaults/StopCommand.java
deleted file mode 100644
index a9467e1..0000000
--- a/src/main/java/org/bukkit/command/defaults/StopCommand.java
+++ /dev/null
@@ -1,49 +0,0 @@
-package org.bukkit.command.defaults;
-
-import java.util.List;
-
-import org.apache.commons.lang.StringUtils;
-import org.apache.commons.lang.Validate;
-
-import org.bukkit.Bukkit;
-import org.bukkit.command.Command;
-import org.bukkit.command.CommandSender;
-import org.bukkit.entity.Player;
-
-import com.google.common.collect.ImmutableList;
-
-@Deprecated
-public class StopCommand extends VanillaCommand {
-    public StopCommand() {
-        super("stop");
-        this.description = "Stops the server with optional reason";
-        this.usageMessage = "/stop [reason]";
-        this.setPermission("bukkit.command.stop");
-    }
-
-    @Override
-    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
-        if (!testPermission(sender)) return true;
-
-        Command.broadcastCommandMessage(sender, "Stopping the server..");
-        Bukkit.shutdown();
-
-        String reason = this.createString(args, 0);
-        if (StringUtils.isNotEmpty(reason)) {
-            for (Player player : Bukkit.getOnlinePlayers()) {
-                player.kickPlayer(reason);
-            }
-        }
-
-        return true;
-    }
-
-    @Override
-    public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {
-        Validate.notNull(sender, "Sender cannot be null");
-        Validate.notNull(args, "Arguments cannot be null");
-        Validate.notNull(alias, "Alias cannot be null");
-
-        return ImmutableList.of();
-    }
-}
diff --git a/src/main/java/org/bukkit/command/defaults/TeleportCommand.java b/src/main/java/org/bukkit/command/defaults/TeleportCommand.java
deleted file mode 100644
index 7460196..0000000
--- a/src/main/java/org/bukkit/command/defaults/TeleportCommand.java
+++ /dev/null
@@ -1,125 +0,0 @@
-package org.bukkit.command.defaults;
-
-import java.util.List;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.Bukkit;
-import org.bukkit.ChatColor;
-import org.bukkit.Location;
-import org.bukkit.command.Command;
-import org.bukkit.command.CommandSender;
-import org.bukkit.entity.Player;
-import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;
-
-import com.google.common.collect.ImmutableList;
-
-@Deprecated
-public class TeleportCommand extends VanillaCommand {
-
-    public TeleportCommand() {
-        super("tp");
-        this.description = "Teleports the given player (or yourself) to another player or coordinates";
-        this.usageMessage = "/tp [player] <target> and/or <x> <y> <z>";
-        this.setPermission("bukkit.command.teleport");
-    }
-
-    @Override
-    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
-        if (!testPermission(sender)) return true;
-        if (args.length < 1 || args.length > 4) {
-            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
-            return false;
-        }
-
-        Player player;
-
-        if (args.length == 1 || args.length == 3) {
-            if (sender instanceof Player) {
-                player = (Player) sender;
-            } else {
-                sender.sendMessage("Please provide a player!");
-                return true;
-            }
-        } else {
-            player = Bukkit.getPlayerExact(args[0]);
-        }
-
-        if (player == null) {
-            sender.sendMessage("Player not found: " + args[0]);
-            return true;
-        }
-
-        if (args.length < 3) {
-            Player target = Bukkit.getPlayerExact(args[args.length - 1]);
-            if (target == null) {
-                sender.sendMessage("Can't find player " + args[args.length - 1] + ". No tp.");
-                return true;
-            }
-            player.teleport(target, TeleportCause.COMMAND);
-            Command.broadcastCommandMessage(sender, "Teleported " + player.getDisplayName() + " to " + target.getDisplayName());
-        } else if (player.getWorld() != null) {
-            Location playerLocation = player.getLocation();
-            double x = getCoordinate(sender, playerLocation.getX(), args[args.length - 3]);
-            double y = getCoordinate(sender, playerLocation.getY(), args[args.length - 2], 0, 0);
-            double z = getCoordinate(sender, playerLocation.getZ(), args[args.length - 1]);
-
-            if (x == MIN_COORD_MINUS_ONE || y == MIN_COORD_MINUS_ONE || z == MIN_COORD_MINUS_ONE) {
-                sender.sendMessage("Please provide a valid location!");
-                return true;
-            }
-
-            playerLocation.setX(x);
-            playerLocation.setY(y);
-            playerLocation.setZ(z);
-
-            player.teleport(playerLocation, TeleportCause.COMMAND);
-            Command.broadcastCommandMessage(sender, String.format("Teleported %s to %.2f, %.2f, %.2f", player.getDisplayName(), x, y, z));
-        }
-        return true;
-    }
-
-    private double getCoordinate(CommandSender sender, double current, String input) {
-        return getCoordinate(sender, current, input, MIN_COORD, MAX_COORD);
-    }
-
-    private double getCoordinate(CommandSender sender, double current, String input, int min, int max) {
-        boolean relative = input.startsWith("~");
-        double result = relative ? current : 0;
-
-        if (!relative || input.length() > 1) {
-            boolean exact = input.contains(".");
-            if (relative) input = input.substring(1);
-
-            double testResult = getDouble(sender, input);
-            if (testResult == MIN_COORD_MINUS_ONE) {
-                return MIN_COORD_MINUS_ONE;
-            }
-            result += testResult;
-
-            if (!exact && !relative) result += 0.5f;
-        }
-        if (min != 0 || max != 0) {
-            if (result < min) {
-                result = MIN_COORD_MINUS_ONE;
-            }
-
-            if (result > max) {
-                result = MIN_COORD_MINUS_ONE;
-            }
-        }
-
-        return result;
-    }
-
-    @Override
-    public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {
-        Validate.notNull(sender, "Sender cannot be null");
-        Validate.notNull(args, "Arguments cannot be null");
-        Validate.notNull(alias, "Alias cannot be null");
-
-        if (args.length == 1 || args.length == 2) {
-            return super.tabComplete(sender, alias, args);
-        }
-        return ImmutableList.of();
-    }
-}
diff --git a/src/main/java/org/bukkit/command/defaults/TellCommand.java b/src/main/java/org/bukkit/command/defaults/TellCommand.java
deleted file mode 100644
index 7b0a41c..0000000
--- a/src/main/java/org/bukkit/command/defaults/TellCommand.java
+++ /dev/null
@@ -1,49 +0,0 @@
-package org.bukkit.command.defaults;
-
-import java.util.Arrays;
-
-import org.bukkit.Bukkit;
-import org.bukkit.ChatColor;
-import org.bukkit.command.CommandSender;
-import org.bukkit.entity.Player;
-
-@Deprecated
-public class TellCommand extends VanillaCommand {
-    public TellCommand() {
-        super("tell");
-        this.description = "Sends a private message to the given player";
-        this.usageMessage = "/tell <player> <message>";
-        this.setAliases(Arrays.asList(new String[] { "w", "msg" }));
-        this.setPermission("bukkit.command.tell");
-    }
-
-    @Override
-    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
-        if (!testPermission(sender)) return true;
-        if (args.length < 2)  {
-            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
-            return false;
-        }
-
-        Player player = Bukkit.getPlayerExact(args[0]);
-
-        // If a player is hidden from the sender pretend they are offline
-        if (player == null || (sender instanceof Player && !((Player) sender).canSee(player))) {
-            sender.sendMessage("There's no player by that name online.");
-        } else {
-            StringBuilder message = new StringBuilder();
-
-            for (int i = 1; i < args.length; i++) {
-                if (i > 1) message.append(" ");
-                message.append(args[i]);
-            }
-
-            String result = ChatColor.GRAY + sender.getName() + " whispers " + message;
-
-            sender.sendMessage("[" + sender.getName() + "->" + player.getName() + "] " + message);
-            player.sendMessage(result);
-        }
-
-        return true;
-    }
-}
diff --git a/src/main/java/org/bukkit/command/defaults/TestForCommand.java b/src/main/java/org/bukkit/command/defaults/TestForCommand.java
deleted file mode 100644
index 7e5494d..0000000
--- a/src/main/java/org/bukkit/command/defaults/TestForCommand.java
+++ /dev/null
@@ -1,27 +0,0 @@
-package org.bukkit.command.defaults;
-
-import org.bukkit.Bukkit;
-import org.bukkit.ChatColor;
-import org.bukkit.command.CommandSender;
-
-@Deprecated
-public class TestForCommand extends VanillaCommand {
-    public TestForCommand() {
-        super("testfor");
-        this.description = "Tests whether a specifed player is online";
-        this.usageMessage = "/testfor <player>";
-        this.setPermission("bukkit.command.testfor");
-    }
-
-    @Override
-    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
-        if (!testPermission(sender)) return true;
-        if (args.length < 1)  {
-            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
-            return false;
-        }
-
-        sender.sendMessage(ChatColor.RED + "/testfor is only usable by commandblocks with analog output.");
-        return true;
-    }
-}
diff --git a/src/main/java/org/bukkit/command/defaults/TimeCommand.java b/src/main/java/org/bukkit/command/defaults/TimeCommand.java
deleted file mode 100644
index edce68a..0000000
--- a/src/main/java/org/bukkit/command/defaults/TimeCommand.java
+++ /dev/null
@@ -1,89 +0,0 @@
-package org.bukkit.command.defaults;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.Bukkit;
-import org.bukkit.ChatColor;
-import org.bukkit.World;
-import org.bukkit.command.Command;
-import org.bukkit.command.CommandSender;
-import org.bukkit.util.StringUtil;
-
-import com.google.common.collect.ImmutableList;
-
-@Deprecated
-public class TimeCommand extends VanillaCommand {
-    private static final List<String> TABCOMPLETE_ADD_SET = ImmutableList.of("add", "set");
-    private static final List<String> TABCOMPLETE_DAY_NIGHT = ImmutableList.of("day", "night");
-
-    public TimeCommand() {
-        super("time");
-        this.description = "Changes the time on each world";
-        this.usageMessage = "/time set <value>\n/time add <value>";
-        this.setPermission("bukkit.command.time.add;bukkit.command.time.set");
-    }
-
-    @Override
-    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
-        if (args.length < 2) {
-            sender.sendMessage(ChatColor.RED + "Incorrect usage. Correct usage:\n" + usageMessage);
-            return false;
-        }
-
-        int value;
-
-        if (args[0].equals("set")) {
-            if (!sender.hasPermission("bukkit.command.time.set")) {
-                sender.sendMessage(ChatColor.RED + "You don't have permission to set the time");
-                return true;
-            }
-
-            if (args[1].equals("day")) {
-                value = 0;
-            } else if (args[1].equals("night")) {
-                value = 12500;
-            } else {
-                value = getInteger(sender, args[1], 0);
-            }
-
-            for (World world : Bukkit.getWorlds()) {
-                world.setTime(value);
-            }
-
-            Command.broadcastCommandMessage(sender, "Set time to " + value);
-        } else if (args[0].equals("add")) {
-            if (!sender.hasPermission("bukkit.command.time.add")) {
-                sender.sendMessage(ChatColor.RED + "You don't have permission to set the time");
-                return true;
-            }
-
-            value = getInteger(sender, args[1], 0);
-
-            for (World world : Bukkit.getWorlds()) {
-                world.setFullTime(world.getFullTime() + value);
-            }
-
-            Command.broadcastCommandMessage(sender, "Added " + value + " to time");
-        } else {
-            sender.sendMessage("Unknown method. Usage: " + usageMessage);
-        }
-
-        return true;
-    }
-
-    @Override
-    public List<String> tabComplete(CommandSender sender, String alias, String[] args) {
-        Validate.notNull(sender, "Sender cannot be null");
-        Validate.notNull(args, "Arguments cannot be null");
-        Validate.notNull(alias, "Alias cannot be null");
-
-        if (args.length == 1) {
-            return StringUtil.copyPartialMatches(args[0], TABCOMPLETE_ADD_SET, new ArrayList<String>(TABCOMPLETE_ADD_SET.size()));
-        } else if (args.length == 2 && args[0].equalsIgnoreCase("set")) {
-            return StringUtil.copyPartialMatches(args[1], TABCOMPLETE_DAY_NIGHT, new ArrayList<String>(TABCOMPLETE_DAY_NIGHT.size()));
-        }
-        return ImmutableList.of();
-    }
-}
diff --git a/src/main/java/org/bukkit/command/defaults/TimingsCommand.java b/src/main/java/org/bukkit/command/defaults/TimingsCommand.java
deleted file mode 100644
index a39ea5d..0000000
--- a/src/main/java/org/bukkit/command/defaults/TimingsCommand.java
+++ /dev/null
@@ -1,124 +0,0 @@
-package org.bukkit.command.defaults;
-
-import java.io.File;
-import java.io.IOException;
-import java.io.PrintStream;
-import java.util.ArrayList;
-import java.util.List;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.Bukkit;
-import org.bukkit.ChatColor;
-import org.bukkit.command.CommandSender;
-import org.bukkit.event.Event;
-import org.bukkit.event.HandlerList;
-import org.bukkit.plugin.Plugin;
-import org.bukkit.plugin.RegisteredListener;
-import org.bukkit.plugin.TimedRegisteredListener;
-import org.bukkit.util.StringUtil;
-
-import com.google.common.collect.ImmutableList;
-
-public class TimingsCommand extends BukkitCommand {
-    private static final List<String> TIMINGS_SUBCOMMANDS = ImmutableList.of("merged", "reset", "separate");
-
-    public TimingsCommand(String name) {
-        super(name);
-        this.description = "Records timings for all plugin events";
-        this.usageMessage = "/timings <reset|merged|separate>";
-        this.setPermission("bukkit.command.timings");
-    }
-
-    @Override
-    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
-        if (!testPermission(sender)) return true;
-        if (args.length != 1)  {
-            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
-            return false;
-        }
-        if (!sender.getServer().getPluginManager().useTimings()) {
-            sender.sendMessage("Please enable timings by setting \"settings.plugin-profiling\" to true in bukkit.yml");
-            return true;
-        }
-
-        boolean separate = "separate".equalsIgnoreCase(args[0]);
-        if ("reset".equalsIgnoreCase(args[0])) {
-            for (HandlerList handlerList : HandlerList.getHandlerLists()) {
-                for (RegisteredListener listener : handlerList.getRegisteredListeners()) {
-                    if (listener instanceof TimedRegisteredListener) {
-                        ((TimedRegisteredListener)listener).reset();
-                    }
-                }
-            }
-            sender.sendMessage("Timings reset");
-        } else if ("merged".equalsIgnoreCase(args[0]) || separate) {
-
-            int index = 0;
-            int pluginIdx = 0;
-            File timingFolder = new File("timings");
-            timingFolder.mkdirs();
-            File timings = new File(timingFolder, "timings.txt");
-            File names = null;
-            while (timings.exists()) timings = new File(timingFolder, "timings" + (++index) + ".txt");
-            PrintStream fileTimings = null;
-            PrintStream fileNames = null;
-            try {
-                fileTimings = new PrintStream(timings);
-                if (separate) {
-                    names = new File(timingFolder, "names" + index + ".txt");
-                    fileNames = new PrintStream(names);
-                }
-                for (Plugin plugin : Bukkit.getPluginManager().getPlugins()) {
-                    pluginIdx++;
-                    long totalTime = 0;
-                    if (separate) {
-                        fileNames.println(pluginIdx + " " + plugin.getDescription().getFullName());
-                        fileTimings.println("Plugin " + pluginIdx);
-                    }
-                    else fileTimings.println(plugin.getDescription().getFullName());
-                    for (RegisteredListener listener : HandlerList.getRegisteredListeners(plugin)) {
-                        if (listener instanceof TimedRegisteredListener) {
-                            TimedRegisteredListener trl = (TimedRegisteredListener) listener;
-                            long time = trl.getTotalTime();
-                            int count = trl.getCount();
-                            if (count == 0) continue;
-                            long avg = time / count;
-                            totalTime += time;
-                            Class<? extends Event> eventClass = trl.getEventClass();
-                            if (count > 0 && eventClass != null) {
-                                fileTimings.println("    " + eventClass.getSimpleName() + (trl.hasMultiple() ? " (and sub-classes)" : "") + " Time: " + time + " Count: " + count + " Avg: " + avg);
-                            }
-                        }
-                    }
-                    fileTimings.println("    Total time " + totalTime + " (" + totalTime / 1000000000 + "s)");
-                }
-                sender.sendMessage("Timings written to " + timings.getPath());
-                if (separate) sender.sendMessage("Names written to " + names.getPath());
-            } catch (IOException e) {
-            } finally {
-                if (fileTimings != null) {
-                    fileTimings.close();
-                }
-                if (fileNames != null) {
-                    fileNames.close();
-                }
-            }
-        } else {
-            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
-            return false;
-        }
-        return true;
-    }
-
-    @Override
-    public List<String> tabComplete(CommandSender sender, String alias, String[] args) {
-        Validate.notNull(sender, "Sender cannot be null");
-        Validate.notNull(args, "Arguments cannot be null");
-        Validate.notNull(alias, "Alias cannot be null");
-
-        if (args.length == 1) {
-            return StringUtil.copyPartialMatches(args[0], TIMINGS_SUBCOMMANDS, new ArrayList<String>(TIMINGS_SUBCOMMANDS.size()));
-        }
-        return ImmutableList.of();
-    }
-}
diff --git a/src/main/java/org/bukkit/command/defaults/ToggleDownfallCommand.java b/src/main/java/org/bukkit/command/defaults/ToggleDownfallCommand.java
deleted file mode 100644
index 91268a6..0000000
--- a/src/main/java/org/bukkit/command/defaults/ToggleDownfallCommand.java
+++ /dev/null
@@ -1,57 +0,0 @@
-package org.bukkit.command.defaults;
-
-import java.util.List;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.Bukkit;
-import org.bukkit.ChatColor;
-import org.bukkit.World;
-import org.bukkit.command.Command;
-import org.bukkit.command.CommandSender;
-import org.bukkit.entity.Player;
-
-import com.google.common.collect.ImmutableList;
-
-@Deprecated
-public class ToggleDownfallCommand extends VanillaCommand {
-    public ToggleDownfallCommand() {
-        super("toggledownfall");
-        this.description = "Toggles rain on/off on a given world";
-        this.usageMessage = "/toggledownfall";
-        this.setPermission("bukkit.command.toggledownfall");
-    }
-
-    @Override
-    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
-        if (!testPermission(sender)) return true;
-
-        World world = null;
-
-        if (args.length == 1) {
-            world = Bukkit.getWorld(args[0]);
-
-            if (world == null) {
-                sender.sendMessage(ChatColor.RED + "No world exists with the name '" + args[0] + "'");
-                return true;
-            }
-        } else if (sender instanceof Player) {
-            world = ((Player) sender).getWorld();
-        } else {
-            world = Bukkit.getWorlds().get(0);
-        }
-
-        Command.broadcastCommandMessage(sender, "Toggling downfall " + (world.hasStorm() ? "off" : "on") + " for world '" + world.getName() + "'");
-        world.setStorm(!world.hasStorm());
-
-        return true;
-    }
-
-    @Override
-    public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {
-        Validate.notNull(sender, "Sender cannot be null");
-        Validate.notNull(args, "Arguments cannot be null");
-        Validate.notNull(alias, "Alias cannot be null");
-
-        return ImmutableList.of();
-    }
-}
diff --git a/src/main/java/org/bukkit/command/defaults/VanillaCommand.java b/src/main/java/org/bukkit/command/defaults/VanillaCommand.java
deleted file mode 100644
index 9105712..0000000
--- a/src/main/java/org/bukkit/command/defaults/VanillaCommand.java
+++ /dev/null
@@ -1,111 +0,0 @@
-package org.bukkit.command.defaults;
-
-import java.util.List;
-
-import org.bukkit.command.Command;
-import org.bukkit.command.CommandSender;
-
-@Deprecated
-public abstract class VanillaCommand extends Command {
-    static final int MAX_COORD = 30000000;
-    static final int MIN_COORD_MINUS_ONE = -30000001;
-    static final int MIN_COORD = -30000000;
-
-    protected VanillaCommand(String name) {
-        super(name);
-    }
-
-    protected VanillaCommand(String name, String description, String usageMessage, List<String> aliases) {
-        super(name, description, usageMessage, aliases);
-    }
-
-    public boolean matches(String input) {
-        return input.equalsIgnoreCase(this.getName());
-    }
-
-    protected int getInteger(CommandSender sender, String value, int min) {
-        return getInteger(sender, value, min, Integer.MAX_VALUE);
-    }
-
-    int getInteger(CommandSender sender, String value, int min, int max) {
-        return getInteger(sender, value, min, max, false);
-    }
-
-    int getInteger(CommandSender sender, String value, int min, int max, boolean Throws) {
-        int i = min;
-
-        try {
-            i = Integer.valueOf(value);
-        } catch (NumberFormatException ex) {
-            if (Throws) {
-                throw new NumberFormatException(String.format("%s is not a valid number", value));
-            }
-        }
-
-        if (i < min) {
-            i = min;
-        } else if (i > max) {
-            i = max;
-        }
-
-        return i;
-    }
-
-    Integer getInteger(String value) {
-        try {
-            return Integer.valueOf(value);
-        } catch (NumberFormatException ex) {
-            return null;
-        }
-    }
-
-    public static double getRelativeDouble(double original, CommandSender sender, String input) {
-        if (input.startsWith("~")) {
-            double value = getDouble(sender, input.substring(1));
-            if (value == MIN_COORD_MINUS_ONE) {
-                return MIN_COORD_MINUS_ONE;
-            }
-            return original + value;
-        } else {
-            return getDouble(sender, input);
-        }
-    }
-
-    public static double getDouble(CommandSender sender, String input) {
-        try {
-            return Double.parseDouble(input);
-        } catch (NumberFormatException ex) {
-            return MIN_COORD_MINUS_ONE;
-        }
-    }
-
-    public static double getDouble(CommandSender sender, String input, double min, double max) {
-        double result = getDouble(sender, input);
-
-        // TODO: This should throw an exception instead.
-        if (result < min) {
-            result = min;
-        } else if (result > max) {
-            result = max;
-        }
-
-        return result;
-    }
-
-    String createString(String[] args, int start) {
-        return createString(args, start, " ");
-    }
-
-    String createString(String[] args, int start, String glue) {
-        StringBuilder string = new StringBuilder();
-
-        for (int x = start; x < args.length; x++) {
-            string.append(args[x]);
-            if (x != args.length - 1) {
-                string.append(glue);
-            }
-        }
-
-        return string.toString();
-    }
-}
diff --git a/src/main/java/org/bukkit/command/defaults/VersionCommand.java b/src/main/java/org/bukkit/command/defaults/VersionCommand.java
deleted file mode 100644
index b55abdb..0000000
--- a/src/main/java/org/bukkit/command/defaults/VersionCommand.java
+++ /dev/null
@@ -1,255 +0,0 @@
-package org.bukkit.command.defaults;
-
-import com.google.common.base.Charsets;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.Bukkit;
-import org.bukkit.ChatColor;
-import org.bukkit.command.CommandSender;
-import org.bukkit.plugin.Plugin;
-import org.bukkit.plugin.PluginDescriptionFile;
-import org.bukkit.util.StringUtil;
-
-import com.google.common.collect.ImmutableList;
-import com.google.common.io.Resources;
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.net.URL;
-import java.net.URLEncoder;
-import java.util.HashSet;
-import java.util.Set;
-import java.util.concurrent.locks.ReentrantLock;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-import org.json.simple.JSONObject;
-import org.json.simple.parser.JSONParser;
-import org.json.simple.parser.ParseException;
-
-public class VersionCommand extends BukkitCommand {
-    public VersionCommand(String name) {
-        super(name);
-
-        this.description = "Gets the version of this server including any plugins in use";
-        this.usageMessage = "/version [plugin name]";
-        this.setPermission("bukkit.command.version");
-        this.setAliases(Arrays.asList("ver", "about"));
-    }
-
-    @Override
-    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
-        if (!testPermission(sender)) return true;
-
-        if (args.length == 0) {
-            sender.sendMessage("This server is running " + Bukkit.getName() + " version " + Bukkit.getVersion() + " (Implementing API version " + Bukkit.getBukkitVersion() + ")");
-            sendVersion(sender);
-        } else {
-            StringBuilder name = new StringBuilder();
-
-            for (String arg : args) {
-                if (name.length() > 0) {
-                    name.append(' ');
-                }
-
-                name.append(arg);
-            }
-
-            String pluginName = name.toString();
-            Plugin exactPlugin = Bukkit.getPluginManager().getPlugin(pluginName);
-            if (exactPlugin != null) {
-                describeToSender(exactPlugin, sender);
-                return true;
-            }
-
-            boolean found = false;
-            pluginName = pluginName.toLowerCase();
-            for (Plugin plugin : Bukkit.getPluginManager().getPlugins()) {
-                if (plugin.getName().toLowerCase().contains(pluginName)) {
-                    describeToSender(plugin, sender);
-                    found = true;
-                }
-            }
-
-            if (!found) {
-                sender.sendMessage("This server is not running any plugin by that name.");
-                sender.sendMessage("Use /plugins to get a list of plugins.");
-            }
-        }
-        return true;
-    }
-
-    private void describeToSender(Plugin plugin, CommandSender sender) {
-        PluginDescriptionFile desc = plugin.getDescription();
-        sender.sendMessage(ChatColor.GREEN + desc.getName() + ChatColor.WHITE + " version " + ChatColor.GREEN + desc.getVersion());
-
-        if (desc.getDescription() != null) {
-            sender.sendMessage(desc.getDescription());
-        }
-
-        if (desc.getWebsite() != null) {
-            sender.sendMessage("Website: " + ChatColor.GREEN + desc.getWebsite());
-        }
-
-        if (!desc.getAuthors().isEmpty()) {
-            if (desc.getAuthors().size() == 1) {
-                sender.sendMessage("Author: " + getAuthors(desc));
-            } else {
-                sender.sendMessage("Authors: " + getAuthors(desc));
-            }
-        }
-    }
-
-    private String getAuthors(final PluginDescriptionFile desc) {
-        StringBuilder result = new StringBuilder();
-        List<String> authors = desc.getAuthors();
-
-        for (int i = 0; i < authors.size(); i++) {
-            if (result.length() > 0) {
-                result.append(ChatColor.WHITE);
-
-                if (i < authors.size() - 1) {
-                    result.append(", ");
-                } else {
-                    result.append(" and ");
-                }
-            }
-
-            result.append(ChatColor.GREEN);
-            result.append(authors.get(i));
-        }
-
-        return result.toString();
-    }
-
-    @Override
-    public List<String> tabComplete(CommandSender sender, String alias, String[] args) {
-        Validate.notNull(sender, "Sender cannot be null");
-        Validate.notNull(args, "Arguments cannot be null");
-        Validate.notNull(alias, "Alias cannot be null");
-
-        if (args.length == 1) {
-            List<String> completions = new ArrayList<String>();
-            String toComplete = args[0].toLowerCase();
-            for (Plugin plugin : Bukkit.getPluginManager().getPlugins()) {
-                if (StringUtil.startsWithIgnoreCase(plugin.getName(), toComplete)) {
-                    completions.add(plugin.getName());
-                }
-            }
-            return completions;
-        }
-        return ImmutableList.of();
-    }
-
-    private final ReentrantLock versionLock = new ReentrantLock();
-    private boolean hasVersion = false;
-    private String versionMessage = null;
-    private final Set<CommandSender> versionWaiters = new HashSet<CommandSender>();
-    private boolean versionTaskStarted = false;
-    private long lastCheck = 0;
-
-    private void sendVersion(CommandSender sender) {
-        if (hasVersion) {
-            if (System.currentTimeMillis() - lastCheck > 21600000) {
-                lastCheck = System.currentTimeMillis();
-                hasVersion = false;
-            } else {
-                sender.sendMessage(versionMessage);
-                return;
-            }
-        }
-        versionLock.lock();
-        try {
-            if (hasVersion) {
-                sender.sendMessage(versionMessage);
-                return;
-            }
-            versionWaiters.add(sender);
-            sender.sendMessage("Checking version, please wait...");
-            if (!versionTaskStarted) {
-                versionTaskStarted = true;
-                new Thread(new Runnable() {
-
-                    @Override
-                    public void run() {
-                        obtainVersion();
-                    }
-                }).start();
-            }
-        } finally {
-            versionLock.unlock();
-        }
-    }
-
-    private void obtainVersion() {
-        String version = Bukkit.getVersion();
-        if (version == null) version = "Custom";
-        if (version.startsWith("git-Spigot-")) {
-            String[] parts = version.substring("git-Spigot-".length()).split("-");
-            int cbVersions = getDistance("craftbukkit", parts[1].substring(0, parts[1].indexOf(' ')));
-            int spigotVersions = getDistance("spigot", parts[0]);
-            if (cbVersions == -1 || spigotVersions == -1) {
-                setVersionMessage("Error obtaining version information");
-            } else {
-                if (cbVersions == 0 && spigotVersions == 0) {
-                    setVersionMessage("You are running the latest version");
-                } else {
-                    setVersionMessage("You are " + (cbVersions + spigotVersions) + " version(s) behind");
-                }
-            }
-
-        } else if (version.startsWith("git-Bukkit-")) {
-            version = version.substring("git-Bukkit-".length());
-            int cbVersions = getDistance("craftbukkit", version.substring(0, version.indexOf(' ')));
-            if (cbVersions == -1) {
-                setVersionMessage("Error obtaining version information");
-            } else {
-                if (cbVersions == 0) {
-                    setVersionMessage("You are running the latest version");
-                } else {
-                    setVersionMessage("You are " + cbVersions + " version(s) behind");
-                }
-            }
-        } else {
-            setVersionMessage("Unknown version, custom build?");
-        }
-    }
-
-    private void setVersionMessage(String msg) {
-        lastCheck = System.currentTimeMillis();
-        versionMessage = msg;
-        versionLock.lock();
-        try {
-            hasVersion = true;
-            versionTaskStarted = false;
-            for (CommandSender sender : versionWaiters) {
-                sender.sendMessage(versionMessage);
-            }
-            versionWaiters.clear();
-        } finally {
-            versionLock.unlock();
-        }
-    }
-
-    private static int getDistance(String repo, String hash) {
-        try {
-            BufferedReader reader = Resources.asCharSource(
-                    new URL("https://hub.spigotmc.org/stash/rest/api/1.0/projects/SPIGOT/repos/" + repo + "/commits?since=" + URLEncoder.encode(hash, "UTF-8") + "&withCounts=true"),
-                    Charsets.UTF_8
-            ).openBufferedStream();
-            try {
-                JSONObject obj = (JSONObject) new JSONParser().parse(reader);
-                return ((Number) obj.get("totalCount")).intValue();
-            } catch (ParseException ex) {
-                ex.printStackTrace();
-                return -1;
-            } finally {
-                reader.close();
-            }
-        } catch (IOException e) {
-            e.printStackTrace();
-            return -1;
-        }
-    }
-}
diff --git a/src/main/java/org/bukkit/command/defaults/WeatherCommand.java b/src/main/java/org/bukkit/command/defaults/WeatherCommand.java
deleted file mode 100644
index b86a508..0000000
--- a/src/main/java/org/bukkit/command/defaults/WeatherCommand.java
+++ /dev/null
@@ -1,74 +0,0 @@
-package org.bukkit.command.defaults;
-
-import com.google.common.collect.ImmutableList;
-import org.apache.commons.lang.Validate;
-import org.bukkit.Bukkit;
-import org.bukkit.ChatColor;
-import org.bukkit.World;
-import org.bukkit.command.Command;
-import org.bukkit.command.CommandSender;
-import org.bukkit.util.StringUtil;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Random;
-
-@Deprecated
-public class WeatherCommand extends VanillaCommand {
-    private static final List<String> WEATHER_TYPES = ImmutableList.of("clear", "rain", "thunder");
-
-    public WeatherCommand() {
-        super("weather");
-        this.description = "Changes the weather";
-        this.usageMessage = "/weather <clear/rain/thunder> [duration in seconds]";
-        this.setPermission("bukkit.command.weather");
-    }
-
-    @Override
-    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
-        if (!testPermission(sender)) return true;
-        if (args.length == 0) {
-            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
-            return false;
-        }
-
-        int duration = (300 + new Random().nextInt(600)) * 20;
-        if (args.length >= 2) {
-            duration = getInteger(sender, args[1], 1, 1000000) * 20;
-        }
-
-        World world = Bukkit.getWorlds().get(0);
-
-        world.setWeatherDuration(duration);
-        world.setThunderDuration(duration);
-
-        if ("clear".equalsIgnoreCase(args[0])) {
-            world.setStorm(false);
-            world.setThundering(false);
-            Command.broadcastCommandMessage(sender, "Changed weather to clear for " + (duration / 20) + " seconds.");
-        } else if ("rain".equalsIgnoreCase(args[0])) {
-            world.setStorm(true);
-            world.setThundering(false);
-            Command.broadcastCommandMessage(sender, "Changed weather to rainy for " + (duration / 20) + " seconds.");
-        } else if ("thunder".equalsIgnoreCase(args[0])) {
-            world.setStorm(true);
-            world.setThundering(true);
-            Command.broadcastCommandMessage(sender, "Changed weather to thundering " + (duration / 20) + " seconds.");
-        }
-
-        return true;
-    }
-
-    @Override
-    public List<String> tabComplete(CommandSender sender, String alias, String[] args) {
-        Validate.notNull(sender, "Sender cannot be null");
-        Validate.notNull(args, "Arguments cannot be null");
-        Validate.notNull(alias, "Alias cannot be null");
-
-        if (args.length == 1) {
-            return StringUtil.copyPartialMatches(args[0], WEATHER_TYPES, new ArrayList<String>(WEATHER_TYPES.size()));
-        }
-
-        return ImmutableList.of();
-    }
-}
diff --git a/src/main/java/org/bukkit/command/defaults/WhitelistCommand.java b/src/main/java/org/bukkit/command/defaults/WhitelistCommand.java
deleted file mode 100644
index 92de43c..0000000
--- a/src/main/java/org/bukkit/command/defaults/WhitelistCommand.java
+++ /dev/null
@@ -1,128 +0,0 @@
-package org.bukkit.command.defaults;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.Bukkit;
-import org.bukkit.ChatColor;
-import org.bukkit.OfflinePlayer;
-import org.bukkit.command.Command;
-import org.bukkit.command.CommandSender;
-import org.bukkit.util.StringUtil;
-
-import com.google.common.collect.ImmutableList;
-
-@Deprecated
-public class WhitelistCommand extends VanillaCommand {
-    private static final List<String> WHITELIST_SUBCOMMANDS = ImmutableList.of("add", "remove", "on", "off", "list", "reload");
-
-    public WhitelistCommand() {
-        super("whitelist");
-        this.description = "Manages the list of players allowed to use this server";
-        this.usageMessage = "/whitelist (add|remove) <player>\n/whitelist (on|off|list|reload)";
-        this.setPermission("bukkit.command.whitelist.reload;bukkit.command.whitelist.enable;bukkit.command.whitelist.disable;bukkit.command.whitelist.list;bukkit.command.whitelist.add;bukkit.command.whitelist.remove");
-    }
-
-    @Override
-    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
-        if (!testPermission(sender)) return true;
-
-        if (args.length == 1) {
-            if (args[0].equalsIgnoreCase("reload")) {
-                if (badPerm(sender, "reload")) return true;
-
-                Bukkit.reloadWhitelist();
-                Command.broadcastCommandMessage(sender, "Reloaded white-list from file");
-                return true;
-            } else if (args[0].equalsIgnoreCase("on")) {
-                if (badPerm(sender, "enable")) return true;
-
-                Bukkit.setWhitelist(true);
-                Command.broadcastCommandMessage(sender, "Turned on white-listing");
-                return true;
-            } else if (args[0].equalsIgnoreCase("off")) {
-                if (badPerm(sender, "disable")) return true;
-
-                Bukkit.setWhitelist(false);
-                Command.broadcastCommandMessage(sender, "Turned off white-listing");
-                return true;
-            } else if (args[0].equalsIgnoreCase("list")) {
-                if (badPerm(sender, "list")) return true;
-
-                StringBuilder result = new StringBuilder();
-
-                for (OfflinePlayer player : Bukkit.getWhitelistedPlayers()) {
-                    if (result.length() > 0) {
-                        result.append(", ");
-                    }
-
-                    result.append(player.getName());
-                }
-
-                sender.sendMessage("White-listed players: " + result.toString());
-                return true;
-            }
-        } else if (args.length == 2) {
-            if (args[0].equalsIgnoreCase("add")) {
-                if (badPerm(sender, "add")) return true;
-
-                Bukkit.getOfflinePlayer(args[1]).setWhitelisted(true);
-
-                Command.broadcastCommandMessage(sender, "Added " + args[1] + " to white-list");
-                return true;
-            } else if (args[0].equalsIgnoreCase("remove")) {
-                if (badPerm(sender, "remove")) return true;
-
-                Bukkit.getOfflinePlayer(args[1]).setWhitelisted(false);
-
-                Command.broadcastCommandMessage(sender, "Removed " + args[1] + " from white-list");
-                return true;
-            }
-        }
-
-        sender.sendMessage(ChatColor.RED + "Correct command usage:\n" + usageMessage);
-        return false;
-    }
-
-    private boolean badPerm(CommandSender sender, String perm) {
-        if (!sender.hasPermission("bukkit.command.whitelist." + perm)) {
-            sender.sendMessage(ChatColor.RED + "You do not have permission to perform this action.");
-            return true;
-        }
-
-        return false;
-    }
-
-    @Override
-    public List<String> tabComplete(CommandSender sender, String alias, String[] args) {
-        Validate.notNull(sender, "Sender cannot be null");
-        Validate.notNull(args, "Arguments cannot be null");
-        Validate.notNull(alias, "Alias cannot be null");
-
-        if (args.length == 1) {
-            return StringUtil.copyPartialMatches(args[0], WHITELIST_SUBCOMMANDS, new ArrayList<String>(WHITELIST_SUBCOMMANDS.size()));
-        } else if (args.length == 2) {
-            if (args[0].equalsIgnoreCase("add")) {
-                List<String> completions = new ArrayList<String>();
-                for (OfflinePlayer player : Bukkit.getOfflinePlayers()) {
-                    String name = player.getName();
-                    if (StringUtil.startsWithIgnoreCase(name, args[1]) && !player.isWhitelisted()) {
-                        completions.add(name);
-                    }
-                }
-                return completions;
-            } else if (args[0].equalsIgnoreCase("remove")) {
-                List<String> completions = new ArrayList<String>();
-                for (OfflinePlayer player : Bukkit.getWhitelistedPlayers()) {
-                    String name = player.getName();
-                    if (StringUtil.startsWithIgnoreCase(name, args[1])) {
-                        completions.add(name);
-                    }
-                }
-                return completions;
-            }
-        }
-        return ImmutableList.of();
-    }
-}
diff --git a/src/main/java/org/bukkit/configuration/Configuration.java b/src/main/java/org/bukkit/configuration/Configuration.java
deleted file mode 100644
index 52e3ac4..0000000
--- a/src/main/java/org/bukkit/configuration/Configuration.java
+++ /dev/null
@@ -1,84 +0,0 @@
-package org.bukkit.configuration;
-
-import java.util.Map;
-
-/**
- * Represents a source of configurable options and settings
- */
-public interface Configuration extends ConfigurationSection {
-    /**
-     * Sets the default value of the given path as provided.
-     * <p>
-     * If no source {@link Configuration} was provided as a default
-     * collection, then a new {@link MemoryConfiguration} will be created to
-     * hold the new default value.
-     * <p>
-     * If value is null, the value will be removed from the default
-     * Configuration source.
-     *
-     * @param path Path of the value to set.
-     * @param value Value to set the default to.
-     * @throws IllegalArgumentException Thrown if path is null.
-     */
-    public void addDefault(String path, Object value);
-
-    /**
-     * Sets the default values of the given paths as provided.
-     * <p>
-     * If no source {@link Configuration} was provided as a default
-     * collection, then a new {@link MemoryConfiguration} will be created to
-     * hold the new default values.
-     *
-     * @param defaults A map of Path{@literal ->}Values to add to defaults.
-     * @throws IllegalArgumentException Thrown if defaults is null.
-     */
-    public void addDefaults(Map<String, Object> defaults);
-
-    /**
-     * Sets the default values of the given paths as provided.
-     * <p>
-     * If no source {@link Configuration} was provided as a default
-     * collection, then a new {@link MemoryConfiguration} will be created to
-     * hold the new default value.
-     * <p>
-     * This method will not hold a reference to the specified Configuration,
-     * nor will it automatically update if that Configuration ever changes. If
-     * you require this, you should set the default source with {@link
-     * #setDefaults(org.bukkit.configuration.Configuration)}.
-     *
-     * @param defaults A configuration holding a list of defaults to copy.
-     * @throws IllegalArgumentException Thrown if defaults is null or this.
-     */
-    public void addDefaults(Configuration defaults);
-
-    /**
-     * Sets the source of all default values for this {@link Configuration}.
-     * <p>
-     * If a previous source was set, or previous default values were defined,
-     * then they will not be copied to the new source.
-     *
-     * @param defaults New source of default values for this configuration.
-     * @throws IllegalArgumentException Thrown if defaults is null or this.
-     */
-    public void setDefaults(Configuration defaults);
-
-    /**
-     * Gets the source {@link Configuration} for this configuration.
-     * <p>
-     * If no configuration source was set, but default values were added, then
-     * a {@link MemoryConfiguration} will be returned. If no source was set
-     * and no defaults were set, then this method will return null.
-     *
-     * @return Configuration source for default values, or null if none exist.
-     */
-    public Configuration getDefaults();
-
-    /**
-     * Gets the {@link ConfigurationOptions} for this {@link Configuration}.
-     * <p>
-     * All setters through this method are chainable.
-     *
-     * @return Options for this configuration
-     */
-    public ConfigurationOptions options();
-}
diff --git a/src/main/java/org/bukkit/configuration/ConfigurationOptions.java b/src/main/java/org/bukkit/configuration/ConfigurationOptions.java
deleted file mode 100644
index 2f59382..0000000
--- a/src/main/java/org/bukkit/configuration/ConfigurationOptions.java
+++ /dev/null
@@ -1,90 +0,0 @@
-package org.bukkit.configuration;
-
-/**
- * Various settings for controlling the input and output of a {@link
- * Configuration}
- */
-public class ConfigurationOptions {
-    private char pathSeparator = '.';
-    private boolean copyDefaults = false;
-    private final Configuration configuration;
-
-    protected ConfigurationOptions(Configuration configuration) {
-        this.configuration = configuration;
-    }
-
-    /**
-     * Returns the {@link Configuration} that this object is responsible for.
-     *
-     * @return Parent configuration
-     */
-    public Configuration configuration() {
-        return configuration;
-    }
-
-    /**
-     * Gets the char that will be used to separate {@link
-     * ConfigurationSection}s
-     * <p>
-     * This value does not affect how the {@link Configuration} is stored,
-     * only in how you access the data. The default value is '.'.
-     *
-     * @return Path separator
-     */
-    public char pathSeparator() {
-        return pathSeparator;
-    }
-
-    /**
-     * Sets the char that will be used to separate {@link
-     * ConfigurationSection}s
-     * <p>
-     * This value does not affect how the {@link Configuration} is stored,
-     * only in how you access the data. The default value is '.'.
-     *
-     * @param value Path separator
-     * @return This object, for chaining
-     */
-    public ConfigurationOptions pathSeparator(char value) {
-        this.pathSeparator = value;
-        return this;
-    }
-
-    /**
-     * Checks if the {@link Configuration} should copy values from its default
-     * {@link Configuration} directly.
-     * <p>
-     * If this is true, all values in the default Configuration will be
-     * directly copied, making it impossible to distinguish between values
-     * that were set and values that are provided by default. As a result,
-     * {@link ConfigurationSection#contains(java.lang.String)} will always
-     * return the same value as {@link
-     * ConfigurationSection#isSet(java.lang.String)}. The default value is
-     * false.
-     *
-     * @return Whether or not defaults are directly copied
-     */
-    public boolean copyDefaults() {
-        return copyDefaults;
-    }
-
-    /**
-     * Sets if the {@link Configuration} should copy values from its default
-     * {@link Configuration} directly.
-     * <p>
-     * If this is true, all values in the default Configuration will be
-     * directly copied, making it impossible to distinguish between values
-     * that were set and values that are provided by default. As a result,
-     * {@link ConfigurationSection#contains(java.lang.String)} will always
-     * return the same value as {@link
-     * ConfigurationSection#isSet(java.lang.String)}. The default value is
-     * false.
-     *
-     * @param value Whether or not defaults are directly copied
-     * @return This object, for chaining
-     */
-    public ConfigurationOptions copyDefaults(boolean value) {
-        this.copyDefaults = value;
-        return this;
-    }
-}
diff --git a/src/main/java/org/bukkit/configuration/ConfigurationSection.java b/src/main/java/org/bukkit/configuration/ConfigurationSection.java
deleted file mode 100644
index 166f2a6..0000000
--- a/src/main/java/org/bukkit/configuration/ConfigurationSection.java
+++ /dev/null
@@ -1,828 +0,0 @@
-package org.bukkit.configuration;
-
-import java.util.Map;
-import java.util.Set;
-import java.util.List;
-
-import org.bukkit.Color;
-import org.bukkit.OfflinePlayer;
-import org.bukkit.util.Vector;
-import org.bukkit.inventory.ItemStack;
-
-/**
- * Represents a section of a {@link Configuration}
- */
-public interface ConfigurationSection {
-    /**
-     * Gets a set containing all keys in this section.
-     * <p>
-     * If deep is set to true, then this will contain all the keys within any
-     * child {@link ConfigurationSection}s (and their children, etc). These
-     * will be in a valid path notation for you to use.
-     * <p>
-     * If deep is set to false, then this will contain only the keys of any
-     * direct children, and not their own children.
-     *
-     * @param deep Whether or not to get a deep list, as opposed to a shallow
-     *     list.
-     * @return Set of keys contained within this ConfigurationSection.
-     */
-    public Set<String> getKeys(boolean deep);
-
-    /**
-     * Gets a Map containing all keys and their values for this section.
-     * <p>
-     * If deep is set to true, then this will contain all the keys and values
-     * within any child {@link ConfigurationSection}s (and their children,
-     * etc). These keys will be in a valid path notation for you to use.
-     * <p>
-     * If deep is set to false, then this will contain only the keys and
-     * values of any direct children, and not their own children.
-     *
-     * @param deep Whether or not to get a deep list, as opposed to a shallow
-     *     list.
-     * @return Map of keys and values of this section.
-     */
-    public Map<String, Object> getValues(boolean deep);
-
-    /**
-     * Checks if this {@link ConfigurationSection} contains the given path.
-     * <p>
-     * If the value for the requested path does not exist but a default value
-     * has been specified, this will return true.
-     *
-     * @param path Path to check for existence.
-     * @return True if this section contains the requested path, either via
-     *     default or being set.
-     * @throws IllegalArgumentException Thrown when path is null.
-     */
-    public boolean contains(String path);
-
-    /**
-     * Checks if this {@link ConfigurationSection} contains the given path.
-     * <p>
-     * If the value for the requested path does not exist, the boolean parameter
-     * of true has been specified, a default value for the path exists, this
-     * will return true.
-     * <p>
-     * If a boolean parameter of false has been specified, true will only be
-     * returned if there is a set value for the specified path.
-     *
-     * @param path Path to check for existence.
-     * @param ignoreDefault Whether or not to ignore if a default value for the
-     * specified path exists.
-     * @return True if this section contains the requested path, or if a default
-     * value exist and the boolean parameter for this method is true.
-     * @throws IllegalArgumentException Thrown when path is null.
-     */
-    public boolean contains(String path, boolean ignoreDefault);
-
-    /**
-     * Checks if this {@link ConfigurationSection} has a value set for the
-     * given path.
-     * <p>
-     * If the value for the requested path does not exist but a default value
-     * has been specified, this will still return false.
-     *
-     * @param path Path to check for existence.
-     * @return True if this section contains the requested path, regardless of
-     *     having a default.
-     * @throws IllegalArgumentException Thrown when path is null.
-     */
-    public boolean isSet(String path);
-
-    /**
-     * Gets the path of this {@link ConfigurationSection} from its root {@link
-     * Configuration}
-     * <p>
-     * For any {@link Configuration} themselves, this will return an empty
-     * string.
-     * <p>
-     * If the section is no longer contained within its root for any reason,
-     * such as being replaced with a different value, this may return null.
-     * <p>
-     * To retrieve the single name of this section, that is, the final part of
-     * the path returned by this method, you may use {@link #getName()}.
-     *
-     * @return Path of this section relative to its root
-     */
-    public String getCurrentPath();
-
-    /**
-     * Gets the name of this individual {@link ConfigurationSection}, in the
-     * path.
-     * <p>
-     * This will always be the final part of {@link #getCurrentPath()}, unless
-     * the section is orphaned.
-     *
-     * @return Name of this section
-     */
-    public String getName();
-
-    /**
-     * Gets the root {@link Configuration} that contains this {@link
-     * ConfigurationSection}
-     * <p>
-     * For any {@link Configuration} themselves, this will return its own
-     * object.
-     * <p>
-     * If the section is no longer contained within its root for any reason,
-     * such as being replaced with a different value, this may return null.
-     *
-     * @return Root configuration containing this section.
-     */
-    public Configuration getRoot();
-
-    /**
-     * Gets the parent {@link ConfigurationSection} that directly contains
-     * this {@link ConfigurationSection}.
-     * <p>
-     * For any {@link Configuration} themselves, this will return null.
-     * <p>
-     * If the section is no longer contained within its parent for any reason,
-     * such as being replaced with a different value, this may return null.
-     *
-     * @return Parent section containing this section.
-     */
-    public ConfigurationSection getParent();
-
-    /**
-     * Gets the requested Object by path.
-     * <p>
-     * If the Object does not exist but a default value has been specified,
-     * this will return the default value. If the Object does not exist and no
-     * default value was specified, this will return null.
-     *
-     * @param path Path of the Object to get.
-     * @return Requested Object.
-     */
-    public Object get(String path);
-
-    /**
-     * Gets the requested Object by path, returning a default value if not
-     * found.
-     * <p>
-     * If the Object does not exist then the specified default value will
-     * returned regardless of if a default has been identified in the root
-     * {@link Configuration}.
-     *
-     * @param path Path of the Object to get.
-     * @param def The default value to return if the path is not found.
-     * @return Requested Object.
-     */
-    public Object get(String path, Object def);
-
-    /**
-     * Sets the specified path to the given value.
-     * <p>
-     * If value is null, the entry will be removed. Any existing entry will be
-     * replaced, regardless of what the new value is.
-     * <p>
-     * Some implementations may have limitations on what you may store. See
-     * their individual javadocs for details. No implementations should allow
-     * you to store {@link Configuration}s or {@link ConfigurationSection}s,
-     * please use {@link #createSection(java.lang.String)} for that.
-     *
-     * @param path Path of the object to set.
-     * @param value New value to set the path to.
-     */
-    public void set(String path, Object value);
-
-    /**
-     * Creates an empty {@link ConfigurationSection} at the specified path.
-     * <p>
-     * Any value that was previously set at this path will be overwritten. If
-     * the previous value was itself a {@link ConfigurationSection}, it will
-     * be orphaned.
-     *
-     * @param path Path to create the section at.
-     * @return Newly created section
-     */
-    public ConfigurationSection createSection(String path);
-
-    /**
-     * Creates a {@link ConfigurationSection} at the specified path, with
-     * specified values.
-     * <p>
-     * Any value that was previously set at this path will be overwritten. If
-     * the previous value was itself a {@link ConfigurationSection}, it will
-     * be orphaned.
-     *
-     * @param path Path to create the section at.
-     * @param map The values to used.
-     * @return Newly created section
-     */
-    public ConfigurationSection createSection(String path, Map<?, ?> map);
-
-    // Primitives
-    /**
-     * Gets the requested String by path.
-     * <p>
-     * If the String does not exist but a default value has been specified,
-     * this will return the default value. If the String does not exist and no
-     * default value was specified, this will return null.
-     *
-     * @param path Path of the String to get.
-     * @return Requested String.
-     */
-    public String getString(String path);
-
-    /**
-     * Gets the requested String by path, returning a default value if not
-     * found.
-     * <p>
-     * If the String does not exist then the specified default value will
-     * returned regardless of if a default has been identified in the root
-     * {@link Configuration}.
-     *
-     * @param path Path of the String to get.
-     * @param def The default value to return if the path is not found or is
-     *     not a String.
-     * @return Requested String.
-     */
-    public String getString(String path, String def);
-
-    /**
-     * Checks if the specified path is a String.
-     * <p>
-     * If the path exists but is not a String, this will return false. If the
-     * path does not exist, this will return false. If the path does not exist
-     * but a default value has been specified, this will check if that default
-     * value is a String and return appropriately.
-     *
-     * @param path Path of the String to check.
-     * @return Whether or not the specified path is a String.
-     */
-    public boolean isString(String path);
-
-    /**
-     * Gets the requested int by path.
-     * <p>
-     * If the int does not exist but a default value has been specified, this
-     * will return the default value. If the int does not exist and no default
-     * value was specified, this will return 0.
-     *
-     * @param path Path of the int to get.
-     * @return Requested int.
-     */
-    public int getInt(String path);
-
-    /**
-     * Gets the requested int by path, returning a default value if not found.
-     * <p>
-     * If the int does not exist then the specified default value will
-     * returned regardless of if a default has been identified in the root
-     * {@link Configuration}.
-     *
-     * @param path Path of the int to get.
-     * @param def The default value to return if the path is not found or is
-     *     not an int.
-     * @return Requested int.
-     */
-    public int getInt(String path, int def);
-
-    /**
-     * Checks if the specified path is an int.
-     * <p>
-     * If the path exists but is not a int, this will return false. If the
-     * path does not exist, this will return false. If the path does not exist
-     * but a default value has been specified, this will check if that default
-     * value is a int and return appropriately.
-     *
-     * @param path Path of the int to check.
-     * @return Whether or not the specified path is an int.
-     */
-    public boolean isInt(String path);
-
-    /**
-     * Gets the requested boolean by path.
-     * <p>
-     * If the boolean does not exist but a default value has been specified,
-     * this will return the default value. If the boolean does not exist and
-     * no default value was specified, this will return false.
-     *
-     * @param path Path of the boolean to get.
-     * @return Requested boolean.
-     */
-    public boolean getBoolean(String path);
-
-    /**
-     * Gets the requested boolean by path, returning a default value if not
-     * found.
-     * <p>
-     * If the boolean does not exist then the specified default value will
-     * returned regardless of if a default has been identified in the root
-     * {@link Configuration}.
-     *
-     * @param path Path of the boolean to get.
-     * @param def The default value to return if the path is not found or is
-     *     not a boolean.
-     * @return Requested boolean.
-     */
-    public boolean getBoolean(String path, boolean def);
-
-    /**
-     * Checks if the specified path is a boolean.
-     * <p>
-     * If the path exists but is not a boolean, this will return false. If the
-     * path does not exist, this will return false. If the path does not exist
-     * but a default value has been specified, this will check if that default
-     * value is a boolean and return appropriately.
-     *
-     * @param path Path of the boolean to check.
-     * @return Whether or not the specified path is a boolean.
-     */
-    public boolean isBoolean(String path);
-
-    /**
-     * Gets the requested double by path.
-     * <p>
-     * If the double does not exist but a default value has been specified,
-     * this will return the default value. If the double does not exist and no
-     * default value was specified, this will return 0.
-     *
-     * @param path Path of the double to get.
-     * @return Requested double.
-     */
-    public double getDouble(String path);
-
-    /**
-     * Gets the requested double by path, returning a default value if not
-     * found.
-     * <p>
-     * If the double does not exist then the specified default value will
-     * returned regardless of if a default has been identified in the root
-     * {@link Configuration}.
-     *
-     * @param path Path of the double to get.
-     * @param def The default value to return if the path is not found or is
-     *     not a double.
-     * @return Requested double.
-     */
-    public double getDouble(String path, double def);
-
-    /**
-     * Checks if the specified path is a double.
-     * <p>
-     * If the path exists but is not a double, this will return false. If the
-     * path does not exist, this will return false. If the path does not exist
-     * but a default value has been specified, this will check if that default
-     * value is a double and return appropriately.
-     *
-     * @param path Path of the double to check.
-     * @return Whether or not the specified path is a double.
-     */
-    public boolean isDouble(String path);
-
-    /**
-     * Gets the requested long by path.
-     * <p>
-     * If the long does not exist but a default value has been specified, this
-     * will return the default value. If the long does not exist and no
-     * default value was specified, this will return 0.
-     *
-     * @param path Path of the long to get.
-     * @return Requested long.
-     */
-    public long getLong(String path);
-
-    /**
-     * Gets the requested long by path, returning a default value if not
-     * found.
-     * <p>
-     * If the long does not exist then the specified default value will
-     * returned regardless of if a default has been identified in the root
-     * {@link Configuration}.
-     *
-     * @param path Path of the long to get.
-     * @param def The default value to return if the path is not found or is
-     *     not a long.
-     * @return Requested long.
-     */
-    public long getLong(String path, long def);
-
-    /**
-     * Checks if the specified path is a long.
-     * <p>
-     * If the path exists but is not a long, this will return false. If the
-     * path does not exist, this will return false. If the path does not exist
-     * but a default value has been specified, this will check if that default
-     * value is a long and return appropriately.
-     *
-     * @param path Path of the long to check.
-     * @return Whether or not the specified path is a long.
-     */
-    public boolean isLong(String path);
-
-    // Java
-    /**
-     * Gets the requested List by path.
-     * <p>
-     * If the List does not exist but a default value has been specified, this
-     * will return the default value. If the List does not exist and no
-     * default value was specified, this will return null.
-     *
-     * @param path Path of the List to get.
-     * @return Requested List.
-     */
-    public List<?> getList(String path);
-
-    /**
-     * Gets the requested List by path, returning a default value if not
-     * found.
-     * <p>
-     * If the List does not exist then the specified default value will
-     * returned regardless of if a default has been identified in the root
-     * {@link Configuration}.
-     *
-     * @param path Path of the List to get.
-     * @param def The default value to return if the path is not found or is
-     *     not a List.
-     * @return Requested List.
-     */
-    public List<?> getList(String path, List<?> def);
-
-    /**
-     * Checks if the specified path is a List.
-     * <p>
-     * If the path exists but is not a List, this will return false. If the
-     * path does not exist, this will return false. If the path does not exist
-     * but a default value has been specified, this will check if that default
-     * value is a List and return appropriately.
-     *
-     * @param path Path of the List to check.
-     * @return Whether or not the specified path is a List.
-     */
-    public boolean isList(String path);
-
-    /**
-     * Gets the requested List of String by path.
-     * <p>
-     * If the List does not exist but a default value has been specified, this
-     * will return the default value. If the List does not exist and no
-     * default value was specified, this will return an empty List.
-     * <p>
-     * This method will attempt to cast any values into a String if possible,
-     * but may miss any values out if they are not compatible.
-     *
-     * @param path Path of the List to get.
-     * @return Requested List of String.
-     */
-    public List<String> getStringList(String path);
-
-    /**
-     * Gets the requested List of Integer by path.
-     * <p>
-     * If the List does not exist but a default value has been specified, this
-     * will return the default value. If the List does not exist and no
-     * default value was specified, this will return an empty List.
-     * <p>
-     * This method will attempt to cast any values into a Integer if possible,
-     * but may miss any values out if they are not compatible.
-     *
-     * @param path Path of the List to get.
-     * @return Requested List of Integer.
-     */
-    public List<Integer> getIntegerList(String path);
-
-    /**
-     * Gets the requested List of Boolean by path.
-     * <p>
-     * If the List does not exist but a default value has been specified, this
-     * will return the default value. If the List does not exist and no
-     * default value was specified, this will return an empty List.
-     * <p>
-     * This method will attempt to cast any values into a Boolean if possible,
-     * but may miss any values out if they are not compatible.
-     *
-     * @param path Path of the List to get.
-     * @return Requested List of Boolean.
-     */
-    public List<Boolean> getBooleanList(String path);
-
-    /**
-     * Gets the requested List of Double by path.
-     * <p>
-     * If the List does not exist but a default value has been specified, this
-     * will return the default value. If the List does not exist and no
-     * default value was specified, this will return an empty List.
-     * <p>
-     * This method will attempt to cast any values into a Double if possible,
-     * but may miss any values out if they are not compatible.
-     *
-     * @param path Path of the List to get.
-     * @return Requested List of Double.
-     */
-    public List<Double> getDoubleList(String path);
-
-    /**
-     * Gets the requested List of Float by path.
-     * <p>
-     * If the List does not exist but a default value has been specified, this
-     * will return the default value. If the List does not exist and no
-     * default value was specified, this will return an empty List.
-     * <p>
-     * This method will attempt to cast any values into a Float if possible,
-     * but may miss any values out if they are not compatible.
-     *
-     * @param path Path of the List to get.
-     * @return Requested List of Float.
-     */
-    public List<Float> getFloatList(String path);
-
-    /**
-     * Gets the requested List of Long by path.
-     * <p>
-     * If the List does not exist but a default value has been specified, this
-     * will return the default value. If the List does not exist and no
-     * default value was specified, this will return an empty List.
-     * <p>
-     * This method will attempt to cast any values into a Long if possible,
-     * but may miss any values out if they are not compatible.
-     *
-     * @param path Path of the List to get.
-     * @return Requested List of Long.
-     */
-    public List<Long> getLongList(String path);
-
-    /**
-     * Gets the requested List of Byte by path.
-     * <p>
-     * If the List does not exist but a default value has been specified, this
-     * will return the default value. If the List does not exist and no
-     * default value was specified, this will return an empty List.
-     * <p>
-     * This method will attempt to cast any values into a Byte if possible,
-     * but may miss any values out if they are not compatible.
-     *
-     * @param path Path of the List to get.
-     * @return Requested List of Byte.
-     */
-    public List<Byte> getByteList(String path);
-
-    /**
-     * Gets the requested List of Character by path.
-     * <p>
-     * If the List does not exist but a default value has been specified, this
-     * will return the default value. If the List does not exist and no
-     * default value was specified, this will return an empty List.
-     * <p>
-     * This method will attempt to cast any values into a Character if
-     * possible, but may miss any values out if they are not compatible.
-     *
-     * @param path Path of the List to get.
-     * @return Requested List of Character.
-     */
-    public List<Character> getCharacterList(String path);
-
-    /**
-     * Gets the requested List of Short by path.
-     * <p>
-     * If the List does not exist but a default value has been specified, this
-     * will return the default value. If the List does not exist and no
-     * default value was specified, this will return an empty List.
-     * <p>
-     * This method will attempt to cast any values into a Short if possible,
-     * but may miss any values out if they are not compatible.
-     *
-     * @param path Path of the List to get.
-     * @return Requested List of Short.
-     */
-    public List<Short> getShortList(String path);
-
-    /**
-     * Gets the requested List of Maps by path.
-     * <p>
-     * If the List does not exist but a default value has been specified, this
-     * will return the default value. If the List does not exist and no
-     * default value was specified, this will return an empty List.
-     * <p>
-     * This method will attempt to cast any values into a Map if possible, but
-     * may miss any values out if they are not compatible.
-     *
-     * @param path Path of the List to get.
-     * @return Requested List of Maps.
-     */
-    public List<Map<?, ?>> getMapList(String path);
-
-    // Bukkit
-    /**
-     * Gets the requested Vector by path.
-     * <p>
-     * If the Vector does not exist but a default value has been specified,
-     * this will return the default value. If the Vector does not exist and no
-     * default value was specified, this will return null.
-     *
-     * @param path Path of the Vector to get.
-     * @return Requested Vector.
-     */
-    public Vector getVector(String path);
-
-    /**
-     * Gets the requested {@link Vector} by path, returning a default value if
-     * not found.
-     * <p>
-     * If the Vector does not exist then the specified default value will
-     * returned regardless of if a default has been identified in the root
-     * {@link Configuration}.
-     *
-     * @param path Path of the Vector to get.
-     * @param def The default value to return if the path is not found or is
-     *     not a Vector.
-     * @return Requested Vector.
-     */
-    public Vector getVector(String path, Vector def);
-
-    /**
-     * Checks if the specified path is a Vector.
-     * <p>
-     * If the path exists but is not a Vector, this will return false. If the
-     * path does not exist, this will return false. If the path does not exist
-     * but a default value has been specified, this will check if that default
-     * value is a Vector and return appropriately.
-     *
-     * @param path Path of the Vector to check.
-     * @return Whether or not the specified path is a Vector.
-     */
-    public boolean isVector(String path);
-
-    /**
-     * Gets the requested OfflinePlayer by path.
-     * <p>
-     * If the OfflinePlayer does not exist but a default value has been
-     * specified, this will return the default value. If the OfflinePlayer
-     * does not exist and no default value was specified, this will return
-     * null.
-     *
-     * @param path Path of the OfflinePlayer to get.
-     * @return Requested OfflinePlayer.
-     */
-    public OfflinePlayer getOfflinePlayer(String path);
-
-    /**
-     * Gets the requested {@link OfflinePlayer} by path, returning a default
-     * value if not found.
-     * <p>
-     * If the OfflinePlayer does not exist then the specified default value
-     * will returned regardless of if a default has been identified in the
-     * root {@link Configuration}.
-     *
-     * @param path Path of the OfflinePlayer to get.
-     * @param def The default value to return if the path is not found or is
-     *     not an OfflinePlayer.
-     * @return Requested OfflinePlayer.
-     */
-    public OfflinePlayer getOfflinePlayer(String path, OfflinePlayer def);
-
-    /**
-     * Checks if the specified path is an OfflinePlayer.
-     * <p>
-     * If the path exists but is not a OfflinePlayer, this will return false.
-     * If the path does not exist, this will return false. If the path does
-     * not exist but a default value has been specified, this will check if
-     * that default value is a OfflinePlayer and return appropriately.
-     *
-     * @param path Path of the OfflinePlayer to check.
-     * @return Whether or not the specified path is an OfflinePlayer.
-     */
-    public boolean isOfflinePlayer(String path);
-
-    /**
-     * Gets the requested ItemStack by path.
-     * <p>
-     * If the ItemStack does not exist but a default value has been specified,
-     * this will return the default value. If the ItemStack does not exist and
-     * no default value was specified, this will return null.
-     *
-     * @param path Path of the ItemStack to get.
-     * @return Requested ItemStack.
-     */
-    public ItemStack getItemStack(String path);
-
-    /**
-     * Gets the requested {@link ItemStack} by path, returning a default value
-     * if not found.
-     * <p>
-     * If the ItemStack does not exist then the specified default value will
-     * returned regardless of if a default has been identified in the root
-     * {@link Configuration}.
-     *
-     * @param path Path of the ItemStack to get.
-     * @param def The default value to return if the path is not found or is
-     *     not an ItemStack.
-     * @return Requested ItemStack.
-     */
-    public ItemStack getItemStack(String path, ItemStack def);
-
-    /**
-     * Checks if the specified path is an ItemStack.
-     * <p>
-     * If the path exists but is not a ItemStack, this will return false. If
-     * the path does not exist, this will return false. If the path does not
-     * exist but a default value has been specified, this will check if that
-     * default value is a ItemStack and return appropriately.
-     *
-     * @param path Path of the ItemStack to check.
-     * @return Whether or not the specified path is an ItemStack.
-     */
-    public boolean isItemStack(String path);
-
-    /**
-     * Gets the requested Color by path.
-     * <p>
-     * If the Color does not exist but a default value has been specified,
-     * this will return the default value. If the Color does not exist and no
-     * default value was specified, this will return null.
-     *
-     * @param path Path of the Color to get.
-     * @return Requested Color.
-     */
-    public Color getColor(String path);
-
-    /**
-     * Gets the requested {@link Color} by path, returning a default value if
-     * not found.
-     * <p>
-     * If the Color does not exist then the specified default value will
-     * returned regardless of if a default has been identified in the root
-     * {@link Configuration}.
-     *
-     * @param path Path of the Color to get.
-     * @param def The default value to return if the path is not found or is
-     *     not a Color.
-     * @return Requested Color.
-     */
-    public Color getColor(String path, Color def);
-
-    /**
-     * Checks if the specified path is a Color.
-     * <p>
-     * If the path exists but is not a Color, this will return false. If the
-     * path does not exist, this will return false. If the path does not exist
-     * but a default value has been specified, this will check if that default
-     * value is a Color and return appropriately.
-     *
-     * @param path Path of the Color to check.
-     * @return Whether or not the specified path is a Color.
-     */
-    public boolean isColor(String path);
-
-    /**
-     * Gets the requested ConfigurationSection by path.
-     * <p>
-     * If the ConfigurationSection does not exist but a default value has been
-     * specified, this will return the default value. If the
-     * ConfigurationSection does not exist and no default value was specified,
-     * this will return null.
-     *
-     * @param path Path of the ConfigurationSection to get.
-     * @return Requested ConfigurationSection.
-     */
-    public ConfigurationSection getConfigurationSection(String path);
-
-    /**
-     * Checks if the specified path is a ConfigurationSection.
-     * <p>
-     * If the path exists but is not a ConfigurationSection, this will return
-     * false. If the path does not exist, this will return false. If the path
-     * does not exist but a default value has been specified, this will check
-     * if that default value is a ConfigurationSection and return
-     * appropriately.
-     *
-     * @param path Path of the ConfigurationSection to check.
-     * @return Whether or not the specified path is a ConfigurationSection.
-     */
-    public boolean isConfigurationSection(String path);
-
-    /**
-     * Gets the equivalent {@link ConfigurationSection} from the default
-     * {@link Configuration} defined in {@link #getRoot()}.
-     * <p>
-     * If the root contains no defaults, or the defaults doesn't contain a
-     * value for this path, or the value at this path is not a {@link
-     * ConfigurationSection} then this will return null.
-     *
-     * @return Equivalent section in root configuration
-     */
-    public ConfigurationSection getDefaultSection();
-
-    /**
-     * Sets the default value in the root at the given path as provided.
-     * <p>
-     * If no source {@link Configuration} was provided as a default
-     * collection, then a new {@link MemoryConfiguration} will be created to
-     * hold the new default value.
-     * <p>
-     * If value is null, the value will be removed from the default
-     * Configuration source.
-     * <p>
-     * If the value as returned by {@link #getDefaultSection()} is null, then
-     * this will create a new section at the path, replacing anything that may
-     * have existed there previously.
-     *
-     * @param path Path of the value to set.
-     * @param value Value to set the default to.
-     * @throws IllegalArgumentException Thrown if path is null.
-     */
-    public void addDefault(String path, Object value);
-}
diff --git a/src/main/java/org/bukkit/configuration/InvalidConfigurationException.java b/src/main/java/org/bukkit/configuration/InvalidConfigurationException.java
deleted file mode 100644
index d23480e..0000000
--- a/src/main/java/org/bukkit/configuration/InvalidConfigurationException.java
+++ /dev/null
@@ -1,45 +0,0 @@
-package org.bukkit.configuration;
-
-/**
- * Exception thrown when attempting to load an invalid {@link Configuration}
- */
-@SuppressWarnings("serial")
-public class InvalidConfigurationException extends Exception {
-
-    /**
-     * Creates a new instance of InvalidConfigurationException without a
-     * message or cause.
-     */
-    public InvalidConfigurationException() {}
-
-    /**
-     * Constructs an instance of InvalidConfigurationException with the
-     * specified message.
-     *
-     * @param msg The details of the exception.
-     */
-    public InvalidConfigurationException(String msg) {
-        super(msg);
-    }
-
-    /**
-     * Constructs an instance of InvalidConfigurationException with the
-     * specified cause.
-     *
-     * @param cause The cause of the exception.
-     */
-    public InvalidConfigurationException(Throwable cause) {
-        super(cause);
-    }
-
-    /**
-     * Constructs an instance of InvalidConfigurationException with the
-     * specified message and cause.
-     *
-     * @param cause The cause of the exception.
-     * @param msg The details of the exception.
-     */
-    public InvalidConfigurationException(String msg, Throwable cause) {
-        super(msg, cause);
-    }
-}
diff --git a/src/main/java/org/bukkit/configuration/MemoryConfiguration.java b/src/main/java/org/bukkit/configuration/MemoryConfiguration.java
deleted file mode 100644
index 19c27a1..0000000
--- a/src/main/java/org/bukkit/configuration/MemoryConfiguration.java
+++ /dev/null
@@ -1,79 +0,0 @@
-package org.bukkit.configuration;
-
-import java.util.Map;
-
-import org.apache.commons.lang.Validate;
-
-/**
- * This is a {@link Configuration} implementation that does not save or load
- * from any source, and stores all values in memory only.
- * This is useful for temporary Configurations for providing defaults.
- */
-public class MemoryConfiguration extends MemorySection implements Configuration {
-    protected Configuration defaults;
-    protected MemoryConfigurationOptions options;
-
-    /**
-     * Creates an empty {@link MemoryConfiguration} with no default values.
-     */
-    public MemoryConfiguration() {}
-
-    /**
-     * Creates an empty {@link MemoryConfiguration} using the specified {@link
-     * Configuration} as a source for all default values.
-     *
-     * @param defaults Default value provider
-     * @throws IllegalArgumentException Thrown if defaults is null
-     */
-    public MemoryConfiguration(Configuration defaults) {
-        this.defaults = defaults;
-    }
-
-    @Override
-    public void addDefault(String path, Object value) {
-        Validate.notNull(path, "Path may not be null");
-
-        if (defaults == null) {
-            defaults = new MemoryConfiguration();
-        }
-
-        defaults.set(path, value);
-    }
-
-    public void addDefaults(Map<String, Object> defaults) {
-        Validate.notNull(defaults, "Defaults may not be null");
-
-        for (Map.Entry<String, Object> entry : defaults.entrySet()) {
-            addDefault(entry.getKey(), entry.getValue());
-        }
-    }
-
-    public void addDefaults(Configuration defaults) {
-        Validate.notNull(defaults, "Defaults may not be null");
-
-        addDefaults(defaults.getValues(true));
-    }
-
-    public void setDefaults(Configuration defaults) {
-        Validate.notNull(defaults, "Defaults may not be null");
-
-        this.defaults = defaults;
-    }
-
-    public Configuration getDefaults() {
-        return defaults;
-    }
-
-    @Override
-    public ConfigurationSection getParent() {
-        return null;
-    }
-
-    public MemoryConfigurationOptions options() {
-        if (options == null) {
-            options = new MemoryConfigurationOptions(this);
-        }
-
-        return options;
-    }
-}
diff --git a/src/main/java/org/bukkit/configuration/MemoryConfigurationOptions.java b/src/main/java/org/bukkit/configuration/MemoryConfigurationOptions.java
deleted file mode 100644
index 44c046c..0000000
--- a/src/main/java/org/bukkit/configuration/MemoryConfigurationOptions.java
+++ /dev/null
@@ -1,28 +0,0 @@
-package org.bukkit.configuration;
-
-/**
- * Various settings for controlling the input and output of a {@link
- * MemoryConfiguration}
- */
-public class MemoryConfigurationOptions extends ConfigurationOptions {
-    protected MemoryConfigurationOptions(MemoryConfiguration configuration) {
-        super(configuration);
-    }
-
-    @Override
-    public MemoryConfiguration configuration() {
-        return (MemoryConfiguration) super.configuration();
-    }
-
-    @Override
-    public MemoryConfigurationOptions copyDefaults(boolean value) {
-        super.copyDefaults(value);
-        return this;
-    }
-
-    @Override
-    public MemoryConfigurationOptions pathSeparator(char value) {
-        super.pathSeparator(value);
-        return this;
-    }
-}
diff --git a/src/main/java/org/bukkit/configuration/MemorySection.java b/src/main/java/org/bukkit/configuration/MemorySection.java
deleted file mode 100644
index 1f4c8ce..0000000
--- a/src/main/java/org/bukkit/configuration/MemorySection.java
+++ /dev/null
@@ -1,828 +0,0 @@
-package org.bukkit.configuration;
-
-import static org.bukkit.util.NumberConversions.*;
-
-import java.util.ArrayList;
-import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.Color;
-import org.bukkit.OfflinePlayer;
-import org.bukkit.inventory.ItemStack;
-import org.bukkit.util.Vector;
-
-/**
- * A type of {@link ConfigurationSection} that is stored in memory.
- */
-public class MemorySection implements ConfigurationSection {
-    protected final Map<String, Object> map = new LinkedHashMap<String, Object>();
-    private final Configuration root;
-    private final ConfigurationSection parent;
-    private final String path;
-    private final String fullPath;
-
-    /**
-     * Creates an empty MemorySection for use as a root {@link Configuration}
-     * section.
-     * <p>
-     * Note that calling this without being yourself a {@link Configuration}
-     * will throw an exception!
-     *
-     * @throws IllegalStateException Thrown if this is not a {@link
-     *     Configuration} root.
-     */
-    protected MemorySection() {
-        if (!(this instanceof Configuration)) {
-            throw new IllegalStateException("Cannot construct a root MemorySection when not a Configuration");
-        }
-
-        this.path = "";
-        this.fullPath = "";
-        this.parent = null;
-        this.root = (Configuration) this;
-    }
-
-    /**
-     * Creates an empty MemorySection with the specified parent and path.
-     *
-     * @param parent Parent section that contains this own section.
-     * @param path Path that you may access this section from via the root
-     *     {@link Configuration}.
-     * @throws IllegalArgumentException Thrown is parent or path is null, or
-     *     if parent contains no root Configuration.
-     */
-    protected MemorySection(ConfigurationSection parent, String path) {
-        Validate.notNull(parent, "Parent cannot be null");
-        Validate.notNull(path, "Path cannot be null");
-
-        this.path = path;
-        this.parent = parent;
-        this.root = parent.getRoot();
-
-        Validate.notNull(root, "Path cannot be orphaned");
-
-        this.fullPath = createPath(parent, path);
-    }
-
-    public Set<String> getKeys(boolean deep) {
-        Set<String> result = new LinkedHashSet<String>();
-
-        Configuration root = getRoot();
-        if (root != null && root.options().copyDefaults()) {
-            ConfigurationSection defaults = getDefaultSection();
-
-            if (defaults != null) {
-                result.addAll(defaults.getKeys(deep));
-            }
-        }
-
-        mapChildrenKeys(result, this, deep);
-
-        return result;
-    }
-
-    public Map<String, Object> getValues(boolean deep) {
-        Map<String, Object> result = new LinkedHashMap<String, Object>();
-
-        Configuration root = getRoot();
-        if (root != null && root.options().copyDefaults()) {
-            ConfigurationSection defaults = getDefaultSection();
-
-            if (defaults != null) {
-                result.putAll(defaults.getValues(deep));
-            }
-        }
-
-        mapChildrenValues(result, this, deep);
-
-        return result;
-    }
-
-    public boolean contains(String path) {
-        return contains(path, false);
-    }
-
-    public boolean contains(String path, boolean ignoreDefault) {
-        return ((ignoreDefault) ? get(path, null) : get(path)) != null;
-    }
-
-    public boolean isSet(String path) {
-        Configuration root = getRoot();
-        if (root == null) {
-            return false;
-        }
-        if (root.options().copyDefaults()) {
-            return contains(path);
-        }
-        return get(path, null) != null;
-    }
-
-    public String getCurrentPath() {
-        return fullPath;
-    }
-
-    public String getName() {
-        return path;
-    }
-
-    public Configuration getRoot() {
-        return root;
-    }
-
-    public ConfigurationSection getParent() {
-        return parent;
-    }
-
-    public void addDefault(String path, Object value) {
-        Validate.notNull(path, "Path cannot be null");
-
-        Configuration root = getRoot();
-        if (root == null) {
-            throw new IllegalStateException("Cannot add default without root");
-        }
-        if (root == this) {
-            throw new UnsupportedOperationException("Unsupported addDefault(String, Object) implementation");
-        }
-        root.addDefault(createPath(this, path), value);
-    }
-
-    public ConfigurationSection getDefaultSection() {
-        Configuration root = getRoot();
-        Configuration defaults = root == null ? null : root.getDefaults();
-
-        if (defaults != null) {
-            if (defaults.isConfigurationSection(getCurrentPath())) {
-                return defaults.getConfigurationSection(getCurrentPath());
-            }
-        }
-
-        return null;
-    }
-
-    public void set(String path, Object value) {
-        Validate.notEmpty(path, "Cannot set to an empty path");
-
-        Configuration root = getRoot();
-        if (root == null) {
-            throw new IllegalStateException("Cannot use section without a root");
-        }
-
-        final char separator = root.options().pathSeparator();
-        // i1 is the leading (higher) index
-        // i2 is the trailing (lower) index
-        int i1 = -1, i2;
-        ConfigurationSection section = this;
-        while ((i1 = path.indexOf(separator, i2 = i1 + 1)) != -1) {
-            String node = path.substring(i2, i1);
-            ConfigurationSection subSection = section.getConfigurationSection(node);
-            if (subSection == null) {
-                if (value == null) {
-                	// no need to create missing sub-sections if we want to remove the value:
-                    return;
-                }
-                section = section.createSection(node);
-            } else {
-                section = subSection;
-            }
-        }
-
-        String key = path.substring(i2);
-        if (section == this) {
-            if (value == null) {
-                map.remove(key);
-            } else {
-                map.put(key, value);
-            }
-        } else {
-            section.set(key, value);
-        }
-    }
-
-    public Object get(String path) {
-        return get(path, getDefault(path));
-    }
-
-    public Object get(String path, Object def) {
-        Validate.notNull(path, "Path cannot be null");
-
-        if (path.length() == 0) {
-            return this;
-        }
-
-        Configuration root = getRoot();
-        if (root == null) {
-            throw new IllegalStateException("Cannot access section without a root");
-        }
-
-        final char separator = root.options().pathSeparator();
-        // i1 is the leading (higher) index
-        // i2 is the trailing (lower) index
-        int i1 = -1, i2;
-        ConfigurationSection section = this;
-        while ((i1 = path.indexOf(separator, i2 = i1 + 1)) != -1) {
-            section = section.getConfigurationSection(path.substring(i2, i1));
-            if (section == null) {
-                return def;
-            }
-        }
-
-        String key = path.substring(i2);
-        if (section == this) {
-            Object result = map.get(key);
-            return (result == null) ? def : result;
-        }
-        return section.get(key, def);
-    }
-
-    public ConfigurationSection createSection(String path) {
-        Validate.notEmpty(path, "Cannot create section at empty path");
-        Configuration root = getRoot();
-        if (root == null) {
-            throw new IllegalStateException("Cannot create section without a root");
-        }
-
-        final char separator = root.options().pathSeparator();
-        // i1 is the leading (higher) index
-        // i2 is the trailing (lower) index
-        int i1 = -1, i2;
-        ConfigurationSection section = this;
-        while ((i1 = path.indexOf(separator, i2 = i1 + 1)) != -1) {
-            String node = path.substring(i2, i1);
-            ConfigurationSection subSection = section.getConfigurationSection(node);
-            if (subSection == null) {
-                section = section.createSection(node);
-            } else {
-                section = subSection;
-            }
-        }
-
-        String key = path.substring(i2);
-        if (section == this) {
-            ConfigurationSection result = new MemorySection(this, key);
-            map.put(key, result);
-            return result;
-        }
-        return section.createSection(key);
-    }
-
-    public ConfigurationSection createSection(String path, Map<?, ?> map) {
-        ConfigurationSection section = createSection(path);
-
-        for (Map.Entry<?, ?> entry : map.entrySet()) {
-            if (entry.getValue() instanceof Map) {
-                section.createSection(entry.getKey().toString(), (Map<?, ?>) entry.getValue());
-            } else {
-                section.set(entry.getKey().toString(), entry.getValue());
-            }
-        }
-
-        return section;
-    }
-
-    // Primitives
-    public String getString(String path) {
-        Object def = getDefault(path);
-        return getString(path, def != null ? def.toString() : null);
-    }
-
-    public String getString(String path, String def) {
-        Object val = get(path, def);
-        return (val != null) ? val.toString() : def;
-    }
-
-    public boolean isString(String path) {
-        Object val = get(path);
-        return val instanceof String;
-    }
-
-    public int getInt(String path) {
-        Object def = getDefault(path);
-        return getInt(path, (def instanceof Number) ? toInt(def) : 0);
-    }
-
-    public int getInt(String path, int def) {
-        Object val = get(path, def);
-        return (val instanceof Number) ? toInt(val) : def;
-    }
-
-    public boolean isInt(String path) {
-        Object val = get(path);
-        return val instanceof Integer;
-    }
-
-    public boolean getBoolean(String path) {
-        Object def = getDefault(path);
-        return getBoolean(path, (def instanceof Boolean) ? (Boolean) def : false);
-    }
-
-    public boolean getBoolean(String path, boolean def) {
-        Object val = get(path, def);
-        return (val instanceof Boolean) ? (Boolean) val : def;
-    }
-
-    public boolean isBoolean(String path) {
-        Object val = get(path);
-        return val instanceof Boolean;
-    }
-
-    public double getDouble(String path) {
-        Object def = getDefault(path);
-        return getDouble(path, (def instanceof Number) ? toDouble(def) : 0);
-    }
-
-    public double getDouble(String path, double def) {
-        Object val = get(path, def);
-        return (val instanceof Number) ? toDouble(val) : def;
-    }
-
-    public boolean isDouble(String path) {
-        Object val = get(path);
-        return val instanceof Double;
-    }
-
-    public long getLong(String path) {
-        Object def = getDefault(path);
-        return getLong(path, (def instanceof Number) ? toLong(def) : 0);
-    }
-
-    public long getLong(String path, long def) {
-        Object val = get(path, def);
-        return (val instanceof Number) ? toLong(val) : def;
-    }
-
-    public boolean isLong(String path) {
-        Object val = get(path);
-        return val instanceof Long;
-    }
-
-    // Java
-    public List<?> getList(String path) {
-        Object def = getDefault(path);
-        return getList(path, (def instanceof List) ? (List<?>) def : null);
-    }
-
-    public List<?> getList(String path, List<?> def) {
-        Object val = get(path, def);
-        return (List<?>) ((val instanceof List) ? val : def);
-    }
-
-    public boolean isList(String path) {
-        Object val = get(path);
-        return val instanceof List;
-    }
-
-    public List<String> getStringList(String path) {
-        List<?> list = getList(path);
-
-        if (list == null) {
-            return new ArrayList<String>(0);
-        }
-
-        List<String> result = new ArrayList<String>();
-
-        for (Object object : list) {
-            if ((object instanceof String) || (isPrimitiveWrapper(object))) {
-                result.add(String.valueOf(object));
-            }
-        }
-
-        return result;
-    }
-
-    public List<Integer> getIntegerList(String path) {
-        List<?> list = getList(path);
-
-        if (list == null) {
-            return new ArrayList<Integer>(0);
-        }
-
-        List<Integer> result = new ArrayList<Integer>();
-
-        for (Object object : list) {
-            if (object instanceof Integer) {
-                result.add((Integer) object);
-            } else if (object instanceof String) {
-                try {
-                    result.add(Integer.valueOf((String) object));
-                } catch (Exception ex) {
-                }
-            } else if (object instanceof Character) {
-                result.add((int) ((Character) object).charValue());
-            } else if (object instanceof Number) {
-                result.add(((Number) object).intValue());
-            }
-        }
-
-        return result;
-    }
-
-    public List<Boolean> getBooleanList(String path) {
-        List<?> list = getList(path);
-
-        if (list == null) {
-            return new ArrayList<Boolean>(0);
-        }
-
-        List<Boolean> result = new ArrayList<Boolean>();
-
-        for (Object object : list) {
-            if (object instanceof Boolean) {
-                result.add((Boolean) object);
-            } else if (object instanceof String) {
-                if (Boolean.TRUE.toString().equals(object)) {
-                    result.add(true);
-                } else if (Boolean.FALSE.toString().equals(object)) {
-                    result.add(false);
-                }
-            }
-        }
-
-        return result;
-    }
-
-    public List<Double> getDoubleList(String path) {
-        List<?> list = getList(path);
-
-        if (list == null) {
-            return new ArrayList<Double>(0);
-        }
-
-        List<Double> result = new ArrayList<Double>();
-
-        for (Object object : list) {
-            if (object instanceof Double) {
-                result.add((Double) object);
-            } else if (object instanceof String) {
-                try {
-                    result.add(Double.valueOf((String) object));
-                } catch (Exception ex) {
-                }
-            } else if (object instanceof Character) {
-                result.add((double) ((Character) object).charValue());
-            } else if (object instanceof Number) {
-                result.add(((Number) object).doubleValue());
-            }
-        }
-
-        return result;
-    }
-
-    public List<Float> getFloatList(String path) {
-        List<?> list = getList(path);
-
-        if (list == null) {
-            return new ArrayList<Float>(0);
-        }
-
-        List<Float> result = new ArrayList<Float>();
-
-        for (Object object : list) {
-            if (object instanceof Float) {
-                result.add((Float) object);
-            } else if (object instanceof String) {
-                try {
-                    result.add(Float.valueOf((String) object));
-                } catch (Exception ex) {
-                }
-            } else if (object instanceof Character) {
-                result.add((float) ((Character) object).charValue());
-            } else if (object instanceof Number) {
-                result.add(((Number) object).floatValue());
-            }
-        }
-
-        return result;
-    }
-
-    public List<Long> getLongList(String path) {
-        List<?> list = getList(path);
-
-        if (list == null) {
-            return new ArrayList<Long>(0);
-        }
-
-        List<Long> result = new ArrayList<Long>();
-
-        for (Object object : list) {
-            if (object instanceof Long) {
-                result.add((Long) object);
-            } else if (object instanceof String) {
-                try {
-                    result.add(Long.valueOf((String) object));
-                } catch (Exception ex) {
-                }
-            } else if (object instanceof Character) {
-                result.add((long) ((Character) object).charValue());
-            } else if (object instanceof Number) {
-                result.add(((Number) object).longValue());
-            }
-        }
-
-        return result;
-    }
-
-    public List<Byte> getByteList(String path) {
-        List<?> list = getList(path);
-
-        if (list == null) {
-            return new ArrayList<Byte>(0);
-        }
-
-        List<Byte> result = new ArrayList<Byte>();
-
-        for (Object object : list) {
-            if (object instanceof Byte) {
-                result.add((Byte) object);
-            } else if (object instanceof String) {
-                try {
-                    result.add(Byte.valueOf((String) object));
-                } catch (Exception ex) {
-                }
-            } else if (object instanceof Character) {
-                result.add((byte) ((Character) object).charValue());
-            } else if (object instanceof Number) {
-                result.add(((Number) object).byteValue());
-            }
-        }
-
-        return result;
-    }
-
-    public List<Character> getCharacterList(String path) {
-        List<?> list = getList(path);
-
-        if (list == null) {
-            return new ArrayList<Character>(0);
-        }
-
-        List<Character> result = new ArrayList<Character>();
-
-        for (Object object : list) {
-            if (object instanceof Character) {
-                result.add((Character) object);
-            } else if (object instanceof String) {
-                String str = (String) object;
-
-                if (str.length() == 1) {
-                    result.add(str.charAt(0));
-                }
-            } else if (object instanceof Number) {
-                result.add((char) ((Number) object).intValue());
-            }
-        }
-
-        return result;
-    }
-
-    public List<Short> getShortList(String path) {
-        List<?> list = getList(path);
-
-        if (list == null) {
-            return new ArrayList<Short>(0);
-        }
-
-        List<Short> result = new ArrayList<Short>();
-
-        for (Object object : list) {
-            if (object instanceof Short) {
-                result.add((Short) object);
-            } else if (object instanceof String) {
-                try {
-                    result.add(Short.valueOf((String) object));
-                } catch (Exception ex) {
-                }
-            } else if (object instanceof Character) {
-                result.add((short) ((Character) object).charValue());
-            } else if (object instanceof Number) {
-                result.add(((Number) object).shortValue());
-            }
-        }
-
-        return result;
-    }
-
-    public List<Map<?, ?>> getMapList(String path) {
-        List<?> list = getList(path);
-        List<Map<?, ?>> result = new ArrayList<Map<?, ?>>();
-
-        if (list == null) {
-            return result;
-        }
-
-        for (Object object : list) {
-            if (object instanceof Map) {
-                result.add((Map<?, ?>) object);
-            }
-        }
-
-        return result;
-    }
-
-    // Bukkit
-    public Vector getVector(String path) {
-        Object def = getDefault(path);
-        return getVector(path, (def instanceof Vector) ? (Vector) def : null);
-    }
-
-    public Vector getVector(String path, Vector def) {
-        Object val = get(path, def);
-        return (val instanceof Vector) ? (Vector) val : def;
-    }
-
-    public boolean isVector(String path) {
-        Object val = get(path);
-        return val instanceof Vector;
-    }
-
-    public OfflinePlayer getOfflinePlayer(String path) {
-        Object def = getDefault(path);
-        return getOfflinePlayer(path, (def instanceof OfflinePlayer) ? (OfflinePlayer) def : null);
-    }
-
-    public OfflinePlayer getOfflinePlayer(String path, OfflinePlayer def) {
-        Object val = get(path, def);
-        return (val instanceof OfflinePlayer) ? (OfflinePlayer) val : def;
-    }
-
-    public boolean isOfflinePlayer(String path) {
-        Object val = get(path);
-        return val instanceof OfflinePlayer;
-    }
-
-    public ItemStack getItemStack(String path) {
-        Object def = getDefault(path);
-        return getItemStack(path, (def instanceof ItemStack) ? (ItemStack) def : null);
-    }
-
-    public ItemStack getItemStack(String path, ItemStack def) {
-        Object val = get(path, def);
-        return (val instanceof ItemStack) ? (ItemStack) val : def;
-    }
-
-    public boolean isItemStack(String path) {
-        Object val = get(path);
-        return val instanceof ItemStack;
-    }
-
-    public Color getColor(String path) {
-        Object def = getDefault(path);
-        return getColor(path, (def instanceof Color) ? (Color) def : null);
-    }
-
-    public Color getColor(String path, Color def) {
-        Object val = get(path, def);
-        return (val instanceof Color) ? (Color) val : def;
-    }
-
-    public boolean isColor(String path) {
-        Object val = get(path);
-        return val instanceof Color;
-    }
-
-    public ConfigurationSection getConfigurationSection(String path) {
-        Object val = get(path, null);
-        if (val != null) {
-            return (val instanceof ConfigurationSection) ? (ConfigurationSection) val : null;
-        }
-
-        val = get(path, getDefault(path));
-        return (val instanceof ConfigurationSection) ? createSection(path) : null;
-    }
-
-    public boolean isConfigurationSection(String path) {
-        Object val = get(path);
-        return val instanceof ConfigurationSection;
-    }
-
-    protected boolean isPrimitiveWrapper(Object input) {
-        return input instanceof Integer || input instanceof Boolean ||
-                input instanceof Character || input instanceof Byte ||
-                input instanceof Short || input instanceof Double ||
-                input instanceof Long || input instanceof Float;
-    }
-
-    protected Object getDefault(String path) {
-        Validate.notNull(path, "Path cannot be null");
-
-        Configuration root = getRoot();
-        Configuration defaults = root == null ? null : root.getDefaults();
-        return (defaults == null) ? null : defaults.get(createPath(this, path));
-    }
-
-    protected void mapChildrenKeys(Set<String> output, ConfigurationSection section, boolean deep) {
-        if (section instanceof MemorySection) {
-            MemorySection sec = (MemorySection) section;
-
-            for (Map.Entry<String, Object> entry : sec.map.entrySet()) {
-                output.add(createPath(section, entry.getKey(), this));
-
-                if ((deep) && (entry.getValue() instanceof ConfigurationSection)) {
-                    ConfigurationSection subsection = (ConfigurationSection) entry.getValue();
-                    mapChildrenKeys(output, subsection, deep);
-                }
-            }
-        } else {
-            Set<String> keys = section.getKeys(deep);
-
-            for (String key : keys) {
-                output.add(createPath(section, key, this));
-            }
-        }
-    }
-
-    protected void mapChildrenValues(Map<String, Object> output, ConfigurationSection section, boolean deep) {
-        if (section instanceof MemorySection) {
-            MemorySection sec = (MemorySection) section;
-
-            for (Map.Entry<String, Object> entry : sec.map.entrySet()) {
-                output.put(createPath(section, entry.getKey(), this), entry.getValue());
-
-                if (entry.getValue() instanceof ConfigurationSection) {
-                    if (deep) {
-                        mapChildrenValues(output, (ConfigurationSection) entry.getValue(), deep);
-                    }
-                }
-            }
-        } else {
-            Map<String, Object> values = section.getValues(deep);
-
-            for (Map.Entry<String, Object> entry : values.entrySet()) {
-                output.put(createPath(section, entry.getKey(), this), entry.getValue());
-            }
-        }
-    }
-
-    /**
-     * Creates a full path to the given {@link ConfigurationSection} from its
-     * root {@link Configuration}.
-     * <p>
-     * You may use this method for any given {@link ConfigurationSection}, not
-     * only {@link MemorySection}.
-     *
-     * @param section Section to create a path for.
-     * @param key Name of the specified section.
-     * @return Full path of the section from its root.
-     */
-    public static String createPath(ConfigurationSection section, String key) {
-        return createPath(section, key, (section == null) ? null : section.getRoot());
-    }
-
-    /**
-     * Creates a relative path to the given {@link ConfigurationSection} from
-     * the given relative section.
-     * <p>
-     * You may use this method for any given {@link ConfigurationSection}, not
-     * only {@link MemorySection}.
-     *
-     * @param section Section to create a path for.
-     * @param key Name of the specified section.
-     * @param relativeTo Section to create the path relative to.
-     * @return Full path of the section from its root.
-     */
-    public static String createPath(ConfigurationSection section, String key, ConfigurationSection relativeTo) {
-        Validate.notNull(section, "Cannot create path without a section");
-        Configuration root = section.getRoot();
-        if (root == null) {
-            throw new IllegalStateException("Cannot create path without a root");
-        }
-        char separator = root.options().pathSeparator();
-
-        StringBuilder builder = new StringBuilder();
-        if (section != null) {
-            for (ConfigurationSection parent = section; (parent != null) && (parent != relativeTo); parent = parent.getParent()) {
-                if (builder.length() > 0) {
-                    builder.insert(0, separator);
-                }
-
-                builder.insert(0, parent.getName());
-            }
-        }
-
-        if ((key != null) && (key.length() > 0)) {
-            if (builder.length() > 0) {
-                builder.append(separator);
-            }
-
-            builder.append(key);
-        }
-
-        return builder.toString();
-    }
-
-    @Override
-    public String toString() {
-        Configuration root = getRoot();
-        return new StringBuilder()
-            .append(getClass().getSimpleName())
-            .append("[path='")
-            .append(getCurrentPath())
-            .append("', root='")
-            .append(root == null ? null : root.getClass().getSimpleName())
-            .append("']")
-            .toString();
-    }
-}
diff --git a/src/main/java/org/bukkit/configuration/file/FileConfiguration.java b/src/main/java/org/bukkit/configuration/file/FileConfiguration.java
deleted file mode 100644
index 5c1a3fd..0000000
--- a/src/main/java/org/bukkit/configuration/file/FileConfiguration.java
+++ /dev/null
@@ -1,248 +0,0 @@
-package org.bukkit.configuration.file;
-
-import com.google.common.base.Charsets;
-import com.google.common.io.Files;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.configuration.InvalidConfigurationException;
-
-import java.io.BufferedReader;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.OutputStreamWriter;
-import java.io.Reader;
-import java.io.Writer;
-import java.nio.charset.Charset;
-
-import org.bukkit.configuration.Configuration;
-import org.bukkit.configuration.MemoryConfiguration;
-
-/**
- * This is a base class for all File based implementations of {@link
- * Configuration}
- */
-public abstract class FileConfiguration extends MemoryConfiguration {
-
-    /**
-     * Creates an empty {@link FileConfiguration} with no default values.
-     */
-    public FileConfiguration() {
-        super();
-    }
-
-    /**
-     * Creates an empty {@link FileConfiguration} using the specified {@link
-     * Configuration} as a source for all default values.
-     *
-     * @param defaults Default value provider
-     */
-    public FileConfiguration(Configuration defaults) {
-        super(defaults);
-    }
-
-    /**
-     * Saves this {@link FileConfiguration} to the specified location.
-     * <p>
-     * If the file does not exist, it will be created. If already exists, it
-     * will be overwritten. If it cannot be overwritten or created, an
-     * exception will be thrown.
-     * <p>
-     * This method will save using the system default encoding, or possibly
-     * using UTF8.
-     *
-     * @param file File to save to.
-     * @throws IOException Thrown when the given file cannot be written to for
-     *     any reason.
-     * @throws IllegalArgumentException Thrown when file is null.
-     */
-    public void save(File file) throws IOException {
-        Validate.notNull(file, "File cannot be null");
-
-        Files.createParentDirs(file);
-
-        String data = saveToString();
-
-        Writer writer = new OutputStreamWriter(new FileOutputStream(file), Charsets.UTF_8);
-
-        try {
-            writer.write(data);
-        } finally {
-            writer.close();
-        }
-    }
-
-    /**
-     * Saves this {@link FileConfiguration} to the specified location.
-     * <p>
-     * If the file does not exist, it will be created. If already exists, it
-     * will be overwritten. If it cannot be overwritten or created, an
-     * exception will be thrown.
-     * <p>
-     * This method will save using the system default encoding, or possibly
-     * using UTF8.
-     *
-     * @param file File to save to.
-     * @throws IOException Thrown when the given file cannot be written to for
-     *     any reason.
-     * @throws IllegalArgumentException Thrown when file is null.
-     */
-    public void save(String file) throws IOException {
-        Validate.notNull(file, "File cannot be null");
-
-        save(new File(file));
-    }
-
-    /**
-     * Saves this {@link FileConfiguration} to a string, and returns it.
-     *
-     * @return String containing this configuration.
-     */
-    public abstract String saveToString();
-
-    /**
-     * Loads this {@link FileConfiguration} from the specified location.
-     * <p>
-     * All the values contained within this configuration will be removed,
-     * leaving only settings and defaults, and the new values will be loaded
-     * from the given file.
-     * <p>
-     * If the file cannot be loaded for any reason, an exception will be
-     * thrown.
-     *
-     * @param file File to load from.
-     * @throws FileNotFoundException Thrown when the given file cannot be
-     *     opened.
-     * @throws IOException Thrown when the given file cannot be read.
-     * @throws InvalidConfigurationException Thrown when the given file is not
-     *     a valid Configuration.
-     * @throws IllegalArgumentException Thrown when file is null.
-     */
-    public void load(File file) throws FileNotFoundException, IOException, InvalidConfigurationException {
-        Validate.notNull(file, "File cannot be null");
-
-        final FileInputStream stream = new FileInputStream(file);
-
-        load(new InputStreamReader(stream, Charsets.UTF_8));
-    }
-
-    /**
-     * Loads this {@link FileConfiguration} from the specified stream.
-     * <p>
-     * All the values contained within this configuration will be removed,
-     * leaving only settings and defaults, and the new values will be loaded
-     * from the given stream.
-     *
-     * @param stream Stream to load from
-     * @throws IOException Thrown when the given file cannot be read.
-     * @throws InvalidConfigurationException Thrown when the given file is not
-     *     a valid Configuration.
-     * @throws IllegalArgumentException Thrown when stream is null.
-     * @deprecated This does not consider encoding
-     * @see #load(Reader)
-     */
-    @Deprecated
-    public void load(InputStream stream) throws IOException, InvalidConfigurationException {
-        Validate.notNull(stream, "Stream cannot be null");
-
-        load(new InputStreamReader(stream, Charsets.UTF_8));
-    }
-
-    /**
-     * Loads this {@link FileConfiguration} from the specified reader.
-     * <p>
-     * All the values contained within this configuration will be removed,
-     * leaving only settings and defaults, and the new values will be loaded
-     * from the given stream.
-     *
-     * @param reader the reader to load from
-     * @throws IOException thrown when underlying reader throws an IOException
-     * @throws InvalidConfigurationException thrown when the reader does not
-     *      represent a valid Configuration
-     * @throws IllegalArgumentException thrown when reader is null
-     */
-    public void load(Reader reader) throws IOException, InvalidConfigurationException {
-        BufferedReader input = reader instanceof BufferedReader ? (BufferedReader) reader : new BufferedReader(reader);
-
-        StringBuilder builder = new StringBuilder();
-
-        try {
-            String line;
-
-            while ((line = input.readLine()) != null) {
-                builder.append(line);
-                builder.append('\n');
-            }
-        } finally {
-            input.close();
-        }
-
-        loadFromString(builder.toString());
-    }
-
-    /**
-     * Loads this {@link FileConfiguration} from the specified location.
-     * <p>
-     * All the values contained within this configuration will be removed,
-     * leaving only settings and defaults, and the new values will be loaded
-     * from the given file.
-     * <p>
-     * If the file cannot be loaded for any reason, an exception will be
-     * thrown.
-     *
-     * @param file File to load from.
-     * @throws FileNotFoundException Thrown when the given file cannot be
-     *     opened.
-     * @throws IOException Thrown when the given file cannot be read.
-     * @throws InvalidConfigurationException Thrown when the given file is not
-     *     a valid Configuration.
-     * @throws IllegalArgumentException Thrown when file is null.
-     */
-    public void load(String file) throws FileNotFoundException, IOException, InvalidConfigurationException {
-        Validate.notNull(file, "File cannot be null");
-
-        load(new File(file));
-    }
-
-    /**
-     * Loads this {@link FileConfiguration} from the specified string, as
-     * opposed to from file.
-     * <p>
-     * All the values contained within this configuration will be removed,
-     * leaving only settings and defaults, and the new values will be loaded
-     * from the given string.
-     * <p>
-     * If the string is invalid in any way, an exception will be thrown.
-     *
-     * @param contents Contents of a Configuration to load.
-     * @throws InvalidConfigurationException Thrown if the specified string is
-     *     invalid.
-     * @throws IllegalArgumentException Thrown if contents is null.
-     */
-    public abstract void loadFromString(String contents) throws InvalidConfigurationException;
-
-    /**
-     * Compiles the header for this {@link FileConfiguration} and returns the
-     * result.
-     * <p>
-     * This will use the header from {@link #options()} -&gt; {@link
-     * FileConfigurationOptions#header()}, respecting the rules of {@link
-     * FileConfigurationOptions#copyHeader()} if set.
-     *
-     * @return Compiled header
-     */
-    protected abstract String buildHeader();
-
-    @Override
-    public FileConfigurationOptions options() {
-        if (options == null) {
-            options = new FileConfigurationOptions(this);
-        }
-
-        return (FileConfigurationOptions) options;
-    }
-}
\ No newline at end of file
diff --git a/src/main/java/org/bukkit/configuration/file/FileConfigurationOptions.java b/src/main/java/org/bukkit/configuration/file/FileConfigurationOptions.java
deleted file mode 100644
index ccf81e0..0000000
--- a/src/main/java/org/bukkit/configuration/file/FileConfigurationOptions.java
+++ /dev/null
@@ -1,118 +0,0 @@
-package org.bukkit.configuration.file;
-
-import org.bukkit.configuration.*;
-
-/**
- * Various settings for controlling the input and output of a {@link
- * FileConfiguration}
- */
-public class FileConfigurationOptions extends MemoryConfigurationOptions {
-    private String header = null;
-    private boolean copyHeader = true;
-
-    protected FileConfigurationOptions(MemoryConfiguration configuration) {
-        super(configuration);
-    }
-
-    @Override
-    public FileConfiguration configuration() {
-        return (FileConfiguration) super.configuration();
-    }
-
-    @Override
-    public FileConfigurationOptions copyDefaults(boolean value) {
-        super.copyDefaults(value);
-        return this;
-    }
-
-    @Override
-    public FileConfigurationOptions pathSeparator(char value) {
-        super.pathSeparator(value);
-        return this;
-    }
-
-    /**
-     * Gets the header that will be applied to the top of the saved output.
-     * <p>
-     * This header will be commented out and applied directly at the top of
-     * the generated output of the {@link FileConfiguration}. It is not
-     * required to include a newline at the end of the header as it will
-     * automatically be applied, but you may include one if you wish for extra
-     * spacing.
-     * <p>
-     * Null is a valid value which will indicate that no header is to be
-     * applied. The default value is null.
-     *
-     * @return Header
-     */
-    public String header() {
-        return header;
-    }
-
-    /**
-     * Sets the header that will be applied to the top of the saved output.
-     * <p>
-     * This header will be commented out and applied directly at the top of
-     * the generated output of the {@link FileConfiguration}. It is not
-     * required to include a newline at the end of the header as it will
-     * automatically be applied, but you may include one if you wish for extra
-     * spacing.
-     * <p>
-     * Null is a valid value which will indicate that no header is to be
-     * applied.
-     *
-     * @param value New header
-     * @return This object, for chaining
-     */
-    public FileConfigurationOptions header(String value) {
-        this.header = value;
-        return this;
-    }
-
-    /**
-     * Gets whether or not the header should be copied from a default source.
-     * <p>
-     * If this is true, if a default {@link FileConfiguration} is passed to
-     * {@link
-     * FileConfiguration#setDefaults(org.bukkit.configuration.Configuration)}
-     * then upon saving it will use the header from that config, instead of
-     * the one provided here.
-     * <p>
-     * If no default is set on the configuration, or the default is not of
-     * type FileConfiguration, or that config has no header ({@link #header()}
-     * returns null) then the header specified in this configuration will be
-     * used.
-     * <p>
-     * Defaults to true.
-     *
-     * @return Whether or not to copy the header
-     */
-    public boolean copyHeader() {
-        return copyHeader;
-    }
-
-    /**
-     * Sets whether or not the header should be copied from a default source.
-     * <p>
-     * If this is true, if a default {@link FileConfiguration} is passed to
-     * {@link
-     * FileConfiguration#setDefaults(org.bukkit.configuration.Configuration)}
-     * then upon saving it will use the header from that config, instead of
-     * the one provided here.
-     * <p>
-     * If no default is set on the configuration, or the default is not of
-     * type FileConfiguration, or that config has no header ({@link #header()}
-     * returns null) then the header specified in this configuration will be
-     * used.
-     * <p>
-     * Defaults to true.
-     *
-     * @param value Whether or not to copy the header
-     * @return This object, for chaining
-     */
-    public FileConfigurationOptions copyHeader(boolean value) {
-        copyHeader = value;
-
-        return this;
-    }
-}
diff --git a/src/main/java/org/bukkit/configuration/file/YamlConfiguration.java b/src/main/java/org/bukkit/configuration/file/YamlConfiguration.java
deleted file mode 100644
index c7f2808..0000000
--- a/src/main/java/org/bukkit/configuration/file/YamlConfiguration.java
+++ /dev/null
@@ -1,248 +0,0 @@
-package org.bukkit.configuration.file;
-
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.Reader;
-import java.util.Map;
-import java.util.logging.Level;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.Bukkit;
-import org.bukkit.configuration.Configuration;
-import org.bukkit.configuration.ConfigurationSection;
-import org.bukkit.configuration.InvalidConfigurationException;
-import org.yaml.snakeyaml.DumperOptions;
-import org.yaml.snakeyaml.Yaml;
-import org.yaml.snakeyaml.error.YAMLException;
-import org.yaml.snakeyaml.representer.Representer;
-
-/**
- * An implementation of {@link Configuration} which saves all files in Yaml.
- * Note that this implementation is not synchronized.
- */
-public class YamlConfiguration extends FileConfiguration {
-    protected static final String COMMENT_PREFIX = "# ";
-    protected static final String BLANK_CONFIG = "{}\n";
-    private final DumperOptions yamlOptions = new DumperOptions();
-    private final Representer yamlRepresenter = new YamlRepresenter();
-    private final Yaml yaml = new Yaml(new YamlConstructor(), yamlRepresenter, yamlOptions);
-
-    @Override
-    public String saveToString() {
-        yamlOptions.setIndent(options().indent());
-        yamlOptions.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);
-        yamlRepresenter.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);
-
-        String header = buildHeader();
-        String dump = yaml.dump(getValues(false));
-
-        if (dump.equals(BLANK_CONFIG)) {
-            dump = "";
-        }
-
-        return header + dump;
-    }
-
-    @Override
-    public void loadFromString(String contents) throws InvalidConfigurationException {
-        Validate.notNull(contents, "Contents cannot be null");
-
-        Map<?, ?> input;
-        try {
-            input = (Map<?, ?>) yaml.load(contents);
-        } catch (YAMLException e) {
-            throw new InvalidConfigurationException(e);
-        } catch (ClassCastException e) {
-            throw new InvalidConfigurationException("Top level is not a Map.");
-        }
-
-        String header = parseHeader(contents);
-        if (header.length() > 0) {
-            options().header(header);
-        }
-
-        if (input != null) {
-            convertMapsToSections(input, this);
-        }
-    }
-
-    protected void convertMapsToSections(Map<?, ?> input, ConfigurationSection section) {
-        for (Map.Entry<?, ?> entry : input.entrySet()) {
-            String key = entry.getKey().toString();
-            Object value = entry.getValue();
-
-            if (value instanceof Map) {
-                convertMapsToSections((Map<?, ?>) value, section.createSection(key));
-            } else {
-                section.set(key, value);
-            }
-        }
-    }
-
-    protected String parseHeader(String input) {
-        String[] lines = input.split("\r?\n", -1);
-        StringBuilder result = new StringBuilder();
-        boolean readingHeader = true;
-        boolean foundHeader = false;
-
-        for (int i = 0; (i < lines.length) && (readingHeader); i++) {
-            String line = lines[i];
-
-            if (line.startsWith(COMMENT_PREFIX)) {
-                if (i > 0) {
-                    result.append("\n");
-                }
-
-                if (line.length() > COMMENT_PREFIX.length()) {
-                    result.append(line.substring(COMMENT_PREFIX.length()));
-                }
-
-                foundHeader = true;
-            } else if ((foundHeader) && (line.length() == 0)) {
-                result.append("\n");
-            } else if (foundHeader) {
-                readingHeader = false;
-            }
-        }
-
-        return result.toString();
-    }
-
-    @Override
-    protected String buildHeader() {
-        String header = options().header();
-
-        if (options().copyHeader()) {
-            Configuration def = getDefaults();
-
-            if ((def != null) && (def instanceof FileConfiguration)) {
-                FileConfiguration filedefaults = (FileConfiguration) def;
-                String defaultsHeader = filedefaults.buildHeader();
-
-                if ((defaultsHeader != null) && (defaultsHeader.length() > 0)) {
-                    return defaultsHeader;
-                }
-            }
-        }
-
-        if (header == null) {
-            return "";
-        }
-
-        StringBuilder builder = new StringBuilder();
-        String[] lines = header.split("\r?\n", -1);
-        boolean startedHeader = false;
-
-        for (int i = lines.length - 1; i >= 0; i--) {
-            builder.insert(0, "\n");
-
-            if ((startedHeader) || (lines[i].length() != 0)) {
-                builder.insert(0, lines[i]);
-                builder.insert(0, COMMENT_PREFIX);
-                startedHeader = true;
-            }
-        }
-
-        return builder.toString();
-    }
-
-    @Override
-    public YamlConfigurationOptions options() {
-        if (options == null) {
-            options = new YamlConfigurationOptions(this);
-        }
-
-        return (YamlConfigurationOptions) options;
-    }
-
-    /**
-     * Creates a new {@link YamlConfiguration}, loading from the given file.
-     * <p>
-     * Any errors loading the Configuration will be logged and then ignored.
-     * If the specified input is not a valid config, a blank config will be
-     * returned.
-     * <p>
-     * The encoding used may follow the system dependent default.
-     *
-     * @param file Input file
-     * @return Resulting configuration
-     * @throws IllegalArgumentException Thrown if file is null
-     */
-    public static YamlConfiguration loadConfiguration(File file) {
-        Validate.notNull(file, "File cannot be null");
-
-        YamlConfiguration config = new YamlConfiguration();
-
-        try {
-            config.load(file);
-        } catch (FileNotFoundException ex) {
-        } catch (IOException ex) {
-            Bukkit.getLogger().log(Level.SEVERE, "Cannot load " + file, ex);
-        } catch (InvalidConfigurationException ex) {
-            Bukkit.getLogger().log(Level.SEVERE, "Cannot load " + file , ex);
-        }
-
-        return config;
-    }
-
-    /**
-     * Creates a new {@link YamlConfiguration}, loading from the given stream.
-     * <p>
-     * Any errors loading the Configuration will be logged and then ignored.
-     * If the specified input is not a valid config, a blank config will be
-     * returned.
-     *
-     * @param stream Input stream
-     * @return Resulting configuration
-     * @throws IllegalArgumentException Thrown if stream is null
-     * @deprecated does not properly consider encoding
-     * @see #load(InputStream)
-     * @see #loadConfiguration(Reader)
-     */
-    @Deprecated
-    public static YamlConfiguration loadConfiguration(InputStream stream) {
-        Validate.notNull(stream, "Stream cannot be null");
-
-        YamlConfiguration config = new YamlConfiguration();
-
-        try {
-            config.load(stream);
-        } catch (IOException ex) {
-            Bukkit.getLogger().log(Level.SEVERE, "Cannot load configuration from stream", ex);
-        } catch (InvalidConfigurationException ex) {
-            Bukkit.getLogger().log(Level.SEVERE, "Cannot load configuration from stream", ex);
-        }
-
-        return config;
-    }
-
-
-    /**
-     * Creates a new {@link YamlConfiguration}, loading from the given reader.
-     * <p>
-     * Any errors loading the Configuration will be logged and then ignored.
-     * If the specified input is not a valid config, a blank config will be
-     * returned.
-     *
-     * @param reader input
-     * @return resulting configuration
-     * @throws IllegalArgumentException Thrown if stream is null
-     */
-    public static YamlConfiguration loadConfiguration(Reader reader) {
-        Validate.notNull(reader, "Stream cannot be null");
-
-        YamlConfiguration config = new YamlConfiguration();
-
-        try {
-            config.load(reader);
-        } catch (IOException ex) {
-            Bukkit.getLogger().log(Level.SEVERE, "Cannot load configuration from stream", ex);
-        } catch (InvalidConfigurationException ex) {
-            Bukkit.getLogger().log(Level.SEVERE, "Cannot load configuration from stream", ex);
-        }
-
-        return config;
-    }
-}
diff --git a/src/main/java/org/bukkit/configuration/file/YamlConfigurationOptions.java b/src/main/java/org/bukkit/configuration/file/YamlConfigurationOptions.java
deleted file mode 100644
index 57894e3..0000000
--- a/src/main/java/org/bukkit/configuration/file/YamlConfigurationOptions.java
+++ /dev/null
@@ -1,71 +0,0 @@
-package org.bukkit.configuration.file;
-
-import org.apache.commons.lang.Validate;
-
-/**
- * Various settings for controlling the input and output of a {@link
- * YamlConfiguration}
- */
-public class YamlConfigurationOptions extends FileConfigurationOptions {
-    private int indent = 2;
-
-    protected YamlConfigurationOptions(YamlConfiguration configuration) {
-        super(configuration);
-    }
-
-    @Override
-    public YamlConfiguration configuration() {
-        return (YamlConfiguration) super.configuration();
-    }
-
-    @Override
-    public YamlConfigurationOptions copyDefaults(boolean value) {
-        super.copyDefaults(value);
-        return this;
-    }
-
-    @Override
-    public YamlConfigurationOptions pathSeparator(char value) {
-        super.pathSeparator(value);
-        return this;
-    }
-
-    @Override
-    public YamlConfigurationOptions header(String value) {
-        super.header(value);
-        return this;
-    }
-
-    @Override
-    public YamlConfigurationOptions copyHeader(boolean value) {
-        super.copyHeader(value);
-        return this;
-    }
-
-    /**
-     * Gets how much spaces should be used to indent each line.
-     * <p>
-     * The minimum value this may be is 2, and the maximum is 9.
-     *
-     * @return How much to indent by
-     */
-    public int indent() {
-        return indent;
-    }
-
-    /**
-     * Sets how much spaces should be used to indent each line.
-     * <p>
-     * The minimum value this may be is 2, and the maximum is 9.
-     *
-     * @param value New indent
-     * @return This object, for chaining
-     */
-    public YamlConfigurationOptions indent(int value) {
-        Validate.isTrue(value >= 2, "Indent must be at least 2 characters");
-        Validate.isTrue(value <= 9, "Indent cannot be greater than 9 characters");
-
-        this.indent = value;
-        return this;
-    }
-}
diff --git a/src/main/java/org/bukkit/configuration/file/YamlConstructor.java b/src/main/java/org/bukkit/configuration/file/YamlConstructor.java
deleted file mode 100644
index 73ad722..0000000
--- a/src/main/java/org/bukkit/configuration/file/YamlConstructor.java
+++ /dev/null
@@ -1,49 +0,0 @@
-package org.bukkit.configuration.file;
-
-import java.util.LinkedHashMap;
-import java.util.Map;
-
-import org.yaml.snakeyaml.nodes.Node;
-import org.yaml.snakeyaml.constructor.SafeConstructor;
-import org.yaml.snakeyaml.error.YAMLException;
-import org.yaml.snakeyaml.nodes.Tag;
-
-import org.bukkit.configuration.serialization.ConfigurationSerialization;
-
-public class YamlConstructor extends SafeConstructor {
-
-    public YamlConstructor() {
-        this.yamlConstructors.put(Tag.MAP, new ConstructCustomObject());
-    }
-
-    private class ConstructCustomObject extends ConstructYamlMap {
-        @Override
-        public Object construct(Node node) {
-            if (node.isTwoStepsConstruction()) {
-                throw new YAMLException("Unexpected referential mapping structure. Node: " + node);
-            }
-
-            Map<?, ?> raw = (Map<?, ?>) super.construct(node);
-
-            if (raw.containsKey(ConfigurationSerialization.SERIALIZED_TYPE_KEY)) {
-                Map<String, Object> typed = new LinkedHashMap<String, Object>(raw.size());
-                for (Map.Entry<?, ?> entry : raw.entrySet()) {
-                    typed.put(entry.getKey().toString(), entry.getValue());
-                }
-
-                try {
-                    return ConfigurationSerialization.deserializeObject(typed);
-                } catch (IllegalArgumentException ex) {
-                    throw new YAMLException("Could not deserialize object", ex);
-                }
-            }
-
-            return raw;
-        }
-
-        @Override
-        public void construct2ndStep(Node node, Object object) {
-            throw new YAMLException("Unexpected referential mapping structure. Node: " + node);
-        }
-    }
-}
diff --git a/src/main/java/org/bukkit/configuration/file/YamlRepresenter.java b/src/main/java/org/bukkit/configuration/file/YamlRepresenter.java
deleted file mode 100644
index bc9c098..0000000
--- a/src/main/java/org/bukkit/configuration/file/YamlRepresenter.java
+++ /dev/null
@@ -1,38 +0,0 @@
-package org.bukkit.configuration.file;
-
-import java.util.LinkedHashMap;
-import java.util.Map;
-
-import org.bukkit.configuration.ConfigurationSection;
-import org.bukkit.configuration.serialization.ConfigurationSerializable;
-import org.bukkit.configuration.serialization.ConfigurationSerialization;
-
-import org.yaml.snakeyaml.nodes.Node;
-import org.yaml.snakeyaml.representer.Representer;
-
-public class YamlRepresenter extends Representer {
-
-    public YamlRepresenter() {
-        this.multiRepresenters.put(ConfigurationSection.class, new RepresentConfigurationSection());
-        this.multiRepresenters.put(ConfigurationSerializable.class, new RepresentConfigurationSerializable());
-    }
-
-    private class RepresentConfigurationSection extends RepresentMap {
-        @Override
-        public Node representData(Object data) {
-            return super.representData(((ConfigurationSection) data).getValues(false));
-        }
-    }
-
-    private class RepresentConfigurationSerializable extends RepresentMap {
-        @Override
-        public Node representData(Object data) {
-            ConfigurationSerializable serializable = (ConfigurationSerializable) data;
-            Map<String, Object> values = new LinkedHashMap<String, Object>();
-            values.put(ConfigurationSerialization.SERIALIZED_TYPE_KEY, ConfigurationSerialization.getAlias(serializable.getClass()));
-            values.putAll(serializable.serialize());
-
-            return super.representData(values);
-        }
-    }
-}
diff --git a/src/main/java/org/bukkit/configuration/serialization/ConfigurationSerializable.java b/src/main/java/org/bukkit/configuration/serialization/ConfigurationSerializable.java
deleted file mode 100644
index 74b73f9..0000000
--- a/src/main/java/org/bukkit/configuration/serialization/ConfigurationSerializable.java
+++ /dev/null
@@ -1,35 +0,0 @@
-package org.bukkit.configuration.serialization;
-
-import java.util.Map;
-
-/**
- * Represents an object that may be serialized.
- * <p>
- * These objects MUST implement one of the following, in addition to the
- * methods as defined by this interface:
- * <ul>
- * <li>A static method "deserialize" that accepts a single {@link Map}&lt;
- * {@link String}, {@link Object}&gt; and returns the class.</li>
- * <li>A static method "valueOf" that accepts a single {@link Map}&lt;{@link
- * String}, {@link Object}&gt; and returns the class.</li>
- * <li>A constructor that accepts a single {@link Map}&lt;{@link String},
- * {@link Object}&gt;.</li>
- * </ul>
- * In addition to implementing this interface, you must register the class
- * with {@link ConfigurationSerialization#registerClass(Class)}.
- *
- * @see DelegateDeserialization
- * @see SerializableAs
- */
-public interface ConfigurationSerializable {
-
-    /**
-     * Creates a Map representation of this class.
-     * <p>
-     * This class must provide a method to restore this class, as defined in
-     * the {@link ConfigurationSerializable} interface javadocs.
-     *
-     * @return Map containing the current state of this class
-     */
-    public Map<String, Object> serialize();
-}
diff --git a/src/main/java/org/bukkit/configuration/serialization/ConfigurationSerialization.java b/src/main/java/org/bukkit/configuration/serialization/ConfigurationSerialization.java
deleted file mode 100644
index e5ddef2..0000000
--- a/src/main/java/org/bukkit/configuration/serialization/ConfigurationSerialization.java
+++ /dev/null
@@ -1,285 +0,0 @@
-package org.bukkit.configuration.serialization;
-
-import java.lang.reflect.Constructor;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.lang.reflect.Modifier;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.Color;
-import org.bukkit.FireworkEffect;
-import org.bukkit.Location;
-import org.bukkit.block.banner.Pattern;
-import org.bukkit.configuration.Configuration;
-import org.bukkit.inventory.ItemStack;
-import org.bukkit.potion.PotionEffect;
-import org.bukkit.util.BlockVector;
-import org.bukkit.util.Vector;
-
-/**
- * Utility class for storing and retrieving classes for {@link Configuration}.
- */
-public class ConfigurationSerialization {
-    public static final String SERIALIZED_TYPE_KEY = "==";
-    private final Class<? extends ConfigurationSerializable> clazz;
-    private static Map<String, Class<? extends ConfigurationSerializable>> aliases = new HashMap<String, Class<? extends ConfigurationSerializable>>();
-
-    static {
-        registerClass(Vector.class);
-        registerClass(BlockVector.class);
-        registerClass(ItemStack.class);
-        registerClass(Color.class);
-        registerClass(PotionEffect.class);
-        registerClass(FireworkEffect.class);
-        registerClass(Pattern.class);
-        registerClass(Location.class);
-    }
-
-    protected ConfigurationSerialization(Class<? extends ConfigurationSerializable> clazz) {
-        this.clazz = clazz;
-    }
-
-    protected Method getMethod(String name, boolean isStatic) {
-        try {
-            Method method = clazz.getDeclaredMethod(name, Map.class);
-
-            if (!ConfigurationSerializable.class.isAssignableFrom(method.getReturnType())) {
-                return null;
-            }
-            if (Modifier.isStatic(method.getModifiers()) != isStatic) {
-                return null;
-            }
-
-            return method;
-        } catch (NoSuchMethodException ex) {
-            return null;
-        } catch (SecurityException ex) {
-            return null;
-        }
-    }
-
-    protected Constructor<? extends ConfigurationSerializable> getConstructor() {
-        try {
-            return clazz.getConstructor(Map.class);
-        } catch (NoSuchMethodException ex) {
-            return null;
-        } catch (SecurityException ex) {
-            return null;
-        }
-    }
-
-    protected ConfigurationSerializable deserializeViaMethod(Method method, Map<String, ?> args) {
-        try {
-            ConfigurationSerializable result = (ConfigurationSerializable) method.invoke(null, args);
-
-            if (result == null) {
-                Logger.getLogger(ConfigurationSerialization.class.getName()).log(Level.SEVERE, "Could not call method '" + method.toString() + "' of " + clazz + " for deserialization: method returned null");
-            } else {
-                return result;
-            }
-        } catch (Throwable ex) {
-            Logger.getLogger(ConfigurationSerialization.class.getName()).log(
-                    Level.SEVERE,
-                    "Could not call method '" + method.toString() + "' of " + clazz + " for deserialization",
-                    ex instanceof InvocationTargetException ? ex.getCause() : ex);
-        }
-
-        return null;
-    }
-
-    protected ConfigurationSerializable deserializeViaCtor(Constructor<? extends ConfigurationSerializable> ctor, Map<String, ?> args) {
-        try {
-            return ctor.newInstance(args);
-        } catch (Throwable ex) {
-            Logger.getLogger(ConfigurationSerialization.class.getName()).log(
-                    Level.SEVERE,
-                    "Could not call constructor '" + ctor.toString() + "' of " + clazz + " for deserialization",
-                    ex instanceof InvocationTargetException ? ex.getCause() : ex);
-        }
-
-        return null;
-    }
-
-    public ConfigurationSerializable deserialize(Map<String, ?> args) {
-        Validate.notNull(args, "Args must not be null");
-
-        ConfigurationSerializable result = null;
-        Method method = null;
-
-        if (result == null) {
-            method = getMethod("deserialize", true);
-
-            if (method != null) {
-                result = deserializeViaMethod(method, args);
-            }
-        }
-
-        if (result == null) {
-            method = getMethod("valueOf", true);
-
-            if (method != null) {
-                result = deserializeViaMethod(method, args);
-            }
-        }
-
-        if (result == null) {
-            Constructor<? extends ConfigurationSerializable> constructor = getConstructor();
-
-            if (constructor != null) {
-                result = deserializeViaCtor(constructor, args);
-            }
-        }
-
-        return result;
-    }
-
-    /**
-     * Attempts to deserialize the given arguments into a new instance of the
-     * given class.
-     * <p>
-     * The class must implement {@link ConfigurationSerializable}, including
-     * the extra methods as specified in the javadoc of
-     * ConfigurationSerializable.
-     * <p>
-     * If a new instance could not be made, an example being the class not
-     * fully implementing the interface, null will be returned.
-     *
-     * @param args Arguments for deserialization
-     * @param clazz Class to deserialize into
-     * @return New instance of the specified class
-     */
-    public static ConfigurationSerializable deserializeObject(Map<String, ?> args, Class<? extends ConfigurationSerializable> clazz) {
-        return new ConfigurationSerialization(clazz).deserialize(args);
-    }
-
-    /**
-     * Attempts to deserialize the given arguments into a new instance of the
-     * given class.
-     * <p>
-     * The class must implement {@link ConfigurationSerializable}, including
-     * the extra methods as specified in the javadoc of
-     * ConfigurationSerializable.
-     * <p>
-     * If a new instance could not be made, an example being the class not
-     * fully implementing the interface, null will be returned.
-     *
-     * @param args Arguments for deserialization
-     * @return New instance of the specified class
-     */
-    public static ConfigurationSerializable deserializeObject(Map<String, ?> args) {
-        Class<? extends ConfigurationSerializable> clazz = null;
-
-        if (args.containsKey(SERIALIZED_TYPE_KEY)) {
-            try {
-                String alias = (String) args.get(SERIALIZED_TYPE_KEY);
-
-                if (alias == null) {
-                    throw new IllegalArgumentException("Cannot have null alias");
-                }
-                clazz = getClassByAlias(alias);
-                if (clazz == null) {
-                    throw new IllegalArgumentException("Specified class does not exist ('" + alias + "')");
-                }
-            } catch (ClassCastException ex) {
-                ex.fillInStackTrace();
-                throw ex;
-            }
-        } else {
-            throw new IllegalArgumentException("Args doesn't contain type key ('" + SERIALIZED_TYPE_KEY + "')");
-        }
-
-        return new ConfigurationSerialization(clazz).deserialize(args);
-    }
-
-    /**
-     * Registers the given {@link ConfigurationSerializable} class by its
-     * alias
-     *
-     * @param clazz Class to register
-     */
-    public static void registerClass(Class<? extends ConfigurationSerializable> clazz) {
-        DelegateDeserialization delegate = clazz.getAnnotation(DelegateDeserialization.class);
-
-        if (delegate == null) {
-            registerClass(clazz, getAlias(clazz));
-            registerClass(clazz, clazz.getName());
-        }
-    }
-
-    /**
-     * Registers the given alias to the specified {@link
-     * ConfigurationSerializable} class
-     *
-     * @param clazz Class to register
-     * @param alias Alias to register as
-     * @see SerializableAs
-     */
-    public static void registerClass(Class<? extends ConfigurationSerializable> clazz, String alias) {
-        aliases.put(alias, clazz);
-    }
-
-    /**
-     * Unregisters the specified alias to a {@link ConfigurationSerializable}
-     *
-     * @param alias Alias to unregister
-     */
-    public static void unregisterClass(String alias) {
-        aliases.remove(alias);
-    }
-
-    /**
-     * Unregisters any aliases for the specified {@link
-     * ConfigurationSerializable} class
-     *
-     * @param clazz Class to unregister
-     */
-    public static void unregisterClass(Class<? extends ConfigurationSerializable> clazz) {
-        while (aliases.values().remove(clazz)) {
-            ;
-        }
-    }
-
-    /**
-     * Attempts to get a registered {@link ConfigurationSerializable} class by
-     * its alias
-     *
-     * @param alias Alias of the serializable
-     * @return Registered class, or null if not found
-     */
-    public static Class<? extends ConfigurationSerializable> getClassByAlias(String alias) {
-        return aliases.get(alias);
-    }
-
-    /**
-     * Gets the correct alias for the given {@link ConfigurationSerializable}
-     * class
-     *
-     * @param clazz Class to get alias for
-     * @return Alias to use for the class
-     */
-    public static String getAlias(Class<? extends ConfigurationSerializable> clazz) {
-        DelegateDeserialization delegate = clazz.getAnnotation(DelegateDeserialization.class);
-
-        if (delegate != null) {
-            if ((delegate.value() == null) || (delegate.value() == clazz)) {
-                delegate = null;
-            } else {
-                return getAlias(delegate.value());
-            }
-        }
-
-        if (delegate == null) {
-            SerializableAs alias = clazz.getAnnotation(SerializableAs.class);
-
-            if ((alias != null) && (alias.value() != null)) {
-                return alias.value();
-            }
-        }
-
-        return clazz.getName();
-    }
-}
diff --git a/src/main/java/org/bukkit/configuration/serialization/DelegateDeserialization.java b/src/main/java/org/bukkit/configuration/serialization/DelegateDeserialization.java
deleted file mode 100644
index 1cfae94..0000000
--- a/src/main/java/org/bukkit/configuration/serialization/DelegateDeserialization.java
+++ /dev/null
@@ -1,22 +0,0 @@
-package org.bukkit.configuration.serialization;
-
-import java.lang.annotation.ElementType;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.lang.annotation.Target;
-
-/**
- * Applies to a {@link ConfigurationSerializable} that will delegate all
- * deserialization to another {@link ConfigurationSerializable}.
- */
-@Retention(RetentionPolicy.RUNTIME)
-@Target(ElementType.TYPE)
-public @interface DelegateDeserialization {
-    /**
-     * Which class should be used as a delegate for this classes
-     * deserialization
-     *
-     * @return Delegate class
-     */
-    public Class<? extends ConfigurationSerializable> value();
-}
diff --git a/src/main/java/org/bukkit/configuration/serialization/SerializableAs.java b/src/main/java/org/bukkit/configuration/serialization/SerializableAs.java
deleted file mode 100644
index c5ee998..0000000
--- a/src/main/java/org/bukkit/configuration/serialization/SerializableAs.java
+++ /dev/null
@@ -1,34 +0,0 @@
-package org.bukkit.configuration.serialization;
-
-import java.lang.annotation.ElementType;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.lang.annotation.Target;
-
-/**
- * Represents an "alias" that a {@link ConfigurationSerializable} may be
- * stored as.
- * If this is not present on a {@link ConfigurationSerializable} class, it
- * will use the fully qualified name of the class.
- * <p>
- * This value will be stored in the configuration so that the configuration
- * deserialization can determine what type it is.
- * <p>
- * Using this annotation on any other class than a {@link
- * ConfigurationSerializable} will have no effect.
- *
- * @see ConfigurationSerialization#registerClass(Class, String)
- */
-@Retention(RetentionPolicy.RUNTIME)
-@Target(ElementType.TYPE)
-public @interface SerializableAs {
-    /**
-     * This is the name your class will be stored and retrieved as.
-     * <p>
-     * This name MUST be unique. We recommend using names such as
-     * "MyPluginThing" instead of "Thing".
-     *
-     * @return Name to serialize the class as.
-     */
-    public String value();
-}
diff --git a/src/main/java/org/bukkit/conversations/BooleanPrompt.java b/src/main/java/org/bukkit/conversations/BooleanPrompt.java
deleted file mode 100644
index 3f2c97f..0000000
--- a/src/main/java/org/bukkit/conversations/BooleanPrompt.java
+++ /dev/null
@@ -1,36 +0,0 @@
-package org.bukkit.conversations;
-
-import org.apache.commons.lang.ArrayUtils;
-import org.apache.commons.lang.BooleanUtils;
-
-/**
- * BooleanPrompt is the base class for any prompt that requires a boolean
- * response from the user.
- */
-public abstract class BooleanPrompt extends ValidatingPrompt{
-
-    public BooleanPrompt() {
-        super();
-    }
-
-    @Override
-    protected boolean isInputValid(ConversationContext context, String input) {
-        String[] accepted = {"true", "false", "on", "off", "yes", "no"};
-        return ArrayUtils.contains(accepted, input.toLowerCase());
-    }
-
-    @Override
-    protected Prompt acceptValidatedInput(ConversationContext context, String input) {
-        return acceptValidatedInput(context, BooleanUtils.toBoolean(input));
-    }
-
-    /**
-     * Override this method to perform some action with the user's boolean
-     * response.
-     *
-     * @param context Context information about the conversation.
-     * @param input The user's boolean response.
-     * @return The next {@link Prompt} in the prompt graph.
-     */
-    protected abstract Prompt acceptValidatedInput(ConversationContext context, boolean input);
-}
diff --git a/src/main/java/org/bukkit/conversations/Conversable.java b/src/main/java/org/bukkit/conversations/Conversable.java
deleted file mode 100644
index 55674b5..0000000
--- a/src/main/java/org/bukkit/conversations/Conversable.java
+++ /dev/null
@@ -1,57 +0,0 @@
-package org.bukkit.conversations;
-
-import org.bukkit.command.CommandSender;
-
-/**
- * The Conversable interface is used to indicate objects that can have
- * conversations.
- */
-public interface Conversable {
-
-    /**
-     * Tests to see of a Conversable object is actively engaged in a
-     * conversation.
-     *
-     * @return True if a conversation is in progress
-     */
-    public boolean isConversing();
-
-    /**
-     * Accepts input into the active conversation. If no conversation is in
-     * progress, this method does nothing.
-     *
-     * @param input The input message into the conversation
-     */
-    public void acceptConversationInput(String input);
-
-    /**
-     * Enters into a dialog with a Conversation object.
-     *
-     * @param conversation The conversation to begin
-     * @return True if the conversation should proceed, false if it has been
-     *     enqueued
-     */
-    public boolean beginConversation(Conversation conversation);
-
-    /**
-     * Abandons an active conversation.
-     *
-     * @param conversation The conversation to abandon
-     */
-    public void abandonConversation(Conversation conversation);
-
-    /**
-     * Abandons an active conversation.
-     *
-     * @param conversation The conversation to abandon
-     * @param details Details about why the conversation was abandoned
-     */
-    public void abandonConversation(Conversation conversation, ConversationAbandonedEvent details);
-
-    /**
-     * Sends this sender a message raw
-     *
-     * @param message Message to be displayed
-     */
-    public void sendRawMessage(String message);
-}
diff --git a/src/main/java/org/bukkit/conversations/Conversation.java b/src/main/java/org/bukkit/conversations/Conversation.java
deleted file mode 100644
index d4c1f6d..0000000
--- a/src/main/java/org/bukkit/conversations/Conversation.java
+++ /dev/null
@@ -1,297 +0,0 @@
-package org.bukkit.conversations;
-
-import org.bukkit.plugin.Plugin;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-/**
- * The Conversation class is responsible for tracking the current state of a
- * conversation, displaying prompts to the user, and dispatching the user's
- * response to the appropriate place. Conversation objects are not typically
- * instantiated directly. Instead a {@link ConversationFactory} is used to
- * construct identical conversations on demand.
- * <p>
- * Conversation flow consists of a directed graph of {@link Prompt} objects.
- * Each time a prompt gets input from the user, it must return the next prompt
- * in the graph. Since each Prompt chooses the next Prompt, complex
- * conversation trees can be implemented where the nature of the player's
- * response directs the flow of the conversation.
- * <p>
- * Each conversation has a {@link ConversationPrefix} that prepends all output
- * from the conversation to the player. The ConversationPrefix can be used to
- * display the plugin name or conversation status as the conversation evolves.
- * <p>
- * Each conversation has a timeout measured in the number of inactive seconds
- * to wait before abandoning the conversation. If the inactivity timeout is
- * reached, the conversation is abandoned and the user's incoming and outgoing
- * chat is returned to normal.
- * <p>
- * You should not construct a conversation manually. Instead, use the {@link
- * ConversationFactory} for access to all available options.
- */
-public class Conversation {
-
-    private Prompt firstPrompt;
-    private boolean abandoned;
-    protected Prompt currentPrompt;
-    protected ConversationContext context;
-    protected boolean modal;
-    protected boolean localEchoEnabled;
-    protected ConversationPrefix prefix;
-    protected List<ConversationCanceller> cancellers;
-    protected List<ConversationAbandonedListener> abandonedListeners;
-
-    /**
-     * Initializes a new Conversation.
-     *
-     * @param plugin The plugin that owns this conversation.
-     * @param forWhom The entity for whom this conversation is mediating.
-     * @param firstPrompt The first prompt in the conversation graph.
-     */
-    public Conversation(Plugin plugin, Conversable forWhom, Prompt firstPrompt) {
-        this(plugin, forWhom, firstPrompt, new HashMap<Object, Object>());
-    }
-
-    /**
-     * Initializes a new Conversation.
-     *
-     * @param plugin The plugin that owns this conversation.
-     * @param forWhom The entity for whom this conversation is mediating.
-     * @param firstPrompt The first prompt in the conversation graph.
-     * @param initialSessionData Any initial values to put in the conversation
-     *     context sessionData map.
-     */
-    public Conversation(Plugin plugin, Conversable forWhom, Prompt firstPrompt, Map<Object, Object> initialSessionData) {
-        this.firstPrompt = firstPrompt;
-        this.context = new ConversationContext(plugin, forWhom, initialSessionData);
-        this.modal = true;
-        this.localEchoEnabled = true;
-        this.prefix = new NullConversationPrefix();
-        this.cancellers = new ArrayList<ConversationCanceller>();
-        this.abandonedListeners = new ArrayList<ConversationAbandonedListener>();
-    }
-
-    /**
-     * Gets the entity for whom this conversation is mediating.
-     *
-     * @return The entity.
-     */
-    public Conversable getForWhom() {
-        return context.getForWhom();
-    }
-
-    /**
-     * Gets the modality of this conversation. If a conversation is modal, all
-     * messages directed to the player are suppressed for the duration of the
-     * conversation.
-     *
-     * @return The conversation modality.
-     */
-    public boolean isModal() {
-        return modal;
-    }
-
-    /**
-     * Sets the modality of this conversation.  If a conversation is modal,
-     * all messages directed to the player are suppressed for the duration of
-     * the conversation.
-     *
-     * @param modal The new conversation modality.
-     */
-    void setModal(boolean modal) {
-        this.modal = modal;
-    }
-
-    /**
-     * Gets the status of local echo for this conversation. If local echo is
-     * enabled, any text submitted to a conversation gets echoed back into the
-     * submitter's chat window.
-     *
-     * @return The status of local echo.
-     */
-    public boolean isLocalEchoEnabled() {
-        return localEchoEnabled;
-    }
-
-    /**
-     * Sets the status of local echo for this conversation. If local echo is
-     * enabled, any text submitted to a conversation gets echoed back into the
-     * submitter's chat window.
-     *
-     * @param localEchoEnabled The status of local echo.
-     */
-    public void setLocalEchoEnabled(boolean localEchoEnabled) {
-        this.localEchoEnabled = localEchoEnabled;
-    }
-
-    /**
-     * Gets the {@link ConversationPrefix} that prepends all output from this
-     * conversation.
-     *
-     * @return The ConversationPrefix in use.
-     */
-    public ConversationPrefix getPrefix() {
-        return prefix;
-    }
-
-    /**
-     * Sets the {@link ConversationPrefix} that prepends all output from this
-     * conversation.
-     *
-     * @param prefix The ConversationPrefix to use.
-     */
-    void setPrefix(ConversationPrefix prefix) {
-        this.prefix = prefix;
-    }
-
-    /**
-     * Adds a {@link ConversationCanceller} to the cancellers collection.
-     *
-     * @param canceller The {@link ConversationCanceller} to add.
-     */
-    void addConversationCanceller(ConversationCanceller canceller) {
-        canceller.setConversation(this);
-        this.cancellers.add(canceller);
-    }
-
-    /**
-     * Gets the list of {@link ConversationCanceller}s
-     *
-     * @return The list.
-     */
-    public List<ConversationCanceller> getCancellers() {
-        return cancellers;
-    }
-
-    /**
-     * Returns the Conversation's {@link ConversationContext}.
-     *
-     * @return The ConversationContext.
-     */
-    public ConversationContext getContext() {
-        return context;
-    }
-
-    /**
-     * Displays the first prompt of this conversation and begins redirecting
-     * the user's chat responses.
-     */
-    public void begin() {
-        if (currentPrompt == null) {
-            abandoned = false;
-            currentPrompt = firstPrompt;
-            context.getForWhom().beginConversation(this);
-        }
-    }
-
-    /**
-     * Returns Returns the current state of the conversation.
-     *
-     * @return The current state of the conversation.
-     */
-    public ConversationState getState() {
-        if (currentPrompt != null) {
-            return ConversationState.STARTED;
-        } else if (abandoned) {
-            return ConversationState.ABANDONED;
-        } else {
-            return ConversationState.UNSTARTED;
-        }
-    }
-
-    /**
-     * Passes player input into the current prompt. The next prompt (as
-     * determined by the current prompt) is then displayed to the user.
-     *
-     * @param input The user's chat text.
-     */
-    public void acceptInput(String input) {
-        if (currentPrompt != null) {
-
-            // Echo the user's input
-            if (localEchoEnabled) {
-                context.getForWhom().sendRawMessage(prefix.getPrefix(context) + input);
-            }
-
-            // Test for conversation abandonment based on input
-            for(ConversationCanceller canceller : cancellers) {
-                if (canceller.cancelBasedOnInput(context, input)) {
-                    abandon(new ConversationAbandonedEvent(this, canceller));
-                    return;
-                }
-            }
-
-            // Not abandoned, output the next prompt
-            currentPrompt = currentPrompt.acceptInput(context, input);
-            outputNextPrompt();
-        }
-    }
-
-    /**
-     * Adds a {@link ConversationAbandonedListener}.
-     *
-     * @param listener The listener to add.
-     */
-    public synchronized void addConversationAbandonedListener(ConversationAbandonedListener listener) {
-        abandonedListeners.add(listener);
-    }
-
-    /**
-     * Removes a {@link ConversationAbandonedListener}.
-     *
-     * @param listener The listener to remove.
-     */
-    public synchronized void removeConversationAbandonedListener(ConversationAbandonedListener listener) {
-        abandonedListeners.remove(listener);
-    }
-
-    /**
-     * Abandons and resets the current conversation. Restores the user's
-     * normal chat behavior.
-     */
-    public void abandon() {
-        abandon(new ConversationAbandonedEvent(this, new ManuallyAbandonedConversationCanceller()));
-    }
-
-    /**
-     * Abandons and resets the current conversation. Restores the user's
-     * normal chat behavior.
-     *
-     * @param details Details about why the conversation was abandoned
-     */
-    public synchronized void abandon(ConversationAbandonedEvent details) {
-        if (!abandoned) {
-            abandoned = true;
-            currentPrompt = null;
-            context.getForWhom().abandonConversation(this);
-            for (ConversationAbandonedListener listener : abandonedListeners) {
-                listener.conversationAbandoned(details);
-            }
-        }
-    }
-
-    /**
-     * Displays the next user prompt and abandons the conversation if the next
-     * prompt is null.
-     */
-    public void outputNextPrompt() {
-        if (currentPrompt == null) {
-            abandon(new ConversationAbandonedEvent(this));
-        } else {
-            context.getForWhom().sendRawMessage(prefix.getPrefix(context) + currentPrompt.getPromptText(context));
-            if (!currentPrompt.blocksForInput(context)) {
-                currentPrompt = currentPrompt.acceptInput(context, null);
-                outputNextPrompt();
-            }
-        }
-    }
-
-    public enum ConversationState {
-        UNSTARTED,
-        STARTED,
-        ABANDONED
-    }
-}
diff --git a/src/main/java/org/bukkit/conversations/ConversationAbandonedEvent.java b/src/main/java/org/bukkit/conversations/ConversationAbandonedEvent.java
deleted file mode 100644
index 63c4a2a..0000000
--- a/src/main/java/org/bukkit/conversations/ConversationAbandonedEvent.java
+++ /dev/null
@@ -1,53 +0,0 @@
-package org.bukkit.conversations;
-
-import java.util.EventObject;
-
-/**
- * ConversationAbandonedEvent contains information about an abandoned
- * conversation.
- */
-public class ConversationAbandonedEvent extends EventObject {
-
-    private ConversationContext context;
-    private ConversationCanceller canceller;
-
-    public ConversationAbandonedEvent(Conversation conversation) {
-        this(conversation, null);
-    }
-
-    public ConversationAbandonedEvent(Conversation conversation, ConversationCanceller canceller) {
-        super(conversation);
-        this.context = conversation.getContext();
-        this.canceller = canceller;
-    }
-
-    /**
-     * Gets the object that caused the conversation to be abandoned.
-     *
-     * @return The object that abandoned the conversation.
-     */
-    public ConversationCanceller getCanceller() {
-        return canceller;
-    }
-
-    /**
-     * Gets the abandoned conversation's conversation context.
-     *
-     * @return The abandoned conversation's conversation context.
-     */
-    public ConversationContext getContext() {
-        return context;
-    }
-
-    /**
-     * Indicates how the conversation was abandoned - naturally as part of the
-     * prompt chain or prematurely via a {@link ConversationCanceller}.
-     *
-     * @return True if the conversation is abandoned gracefully by a {@link
-     *     Prompt} returning null or the next prompt. False of the
-     *     conversations is abandoned prematurely by a ConversationCanceller.
-     */
-    public boolean gracefulExit() {
-        return canceller == null;
-    }
-}
diff --git a/src/main/java/org/bukkit/conversations/ConversationAbandonedListener.java b/src/main/java/org/bukkit/conversations/ConversationAbandonedListener.java
deleted file mode 100644
index dc046b1..0000000
--- a/src/main/java/org/bukkit/conversations/ConversationAbandonedListener.java
+++ /dev/null
@@ -1,15 +0,0 @@
-package org.bukkit.conversations;
-
-import java.util.EventListener;
-
-/**
- */
-public interface ConversationAbandonedListener extends EventListener {
-    /**
-     * Called whenever a {@link Conversation} is abandoned.
-     *
-     * @param abandonedEvent Contains details about the abandoned
-     *     conversation.
-     */
-    public void conversationAbandoned(ConversationAbandonedEvent abandonedEvent);
-}
diff --git a/src/main/java/org/bukkit/conversations/ConversationCanceller.java b/src/main/java/org/bukkit/conversations/ConversationCanceller.java
deleted file mode 100644
index db43bb1..0000000
--- a/src/main/java/org/bukkit/conversations/ConversationCanceller.java
+++ /dev/null
@@ -1,34 +0,0 @@
-package org.bukkit.conversations;
-
-/**
- * A ConversationCanceller is a class that cancels an active {@link
- * Conversation}. A Conversation can have more than one ConversationCanceller.
- */
-public interface ConversationCanceller extends Cloneable {
-
-    /**
-     * Sets the conversation this ConversationCanceller can optionally cancel.
-     *
-     * @param conversation A conversation.
-     */
-    public void setConversation(Conversation conversation);
-
-    /**
-     * Cancels a conversation based on user input.
-     *
-     * @param context Context information about the conversation.
-     * @param input The input text from the user.
-     * @return True to cancel the conversation, False otherwise.
-     */
-    public boolean cancelBasedOnInput(ConversationContext context, String input);
-
-    /**
-     * Allows the {@link ConversationFactory} to duplicate this
-     * ConversationCanceller when creating a new {@link Conversation}.
-     * <p>
-     * Implementing this method should reset any internal object state.
-     *
-     * @return A clone.
-     */
-    public ConversationCanceller clone();
-}
diff --git a/src/main/java/org/bukkit/conversations/ConversationContext.java b/src/main/java/org/bukkit/conversations/ConversationContext.java
deleted file mode 100644
index 4f33ff4..0000000
--- a/src/main/java/org/bukkit/conversations/ConversationContext.java
+++ /dev/null
@@ -1,71 +0,0 @@
-package org.bukkit.conversations;
-
-import org.bukkit.plugin.Plugin;
-
-import java.util.Map;
-
-/**
- * A ConversationContext provides continuity between nodes in the prompt graph
- * by giving the developer access to the subject of the conversation and a
- * generic map for storing values that are shared between all {@link Prompt}
- * invocations.
- */
-public class ConversationContext {
-    private Conversable forWhom;
-    private Map<Object, Object> sessionData;
-    private Plugin plugin;
-
-    /**
-     * @param plugin The owning plugin.
-     * @param forWhom The subject of the conversation.
-     * @param initialSessionData Any initial values to put in the sessionData
-     *     map.
-     */
-    public ConversationContext(Plugin plugin, Conversable forWhom, Map<Object, Object> initialSessionData) {
-        this.plugin = plugin;
-        this.forWhom = forWhom;
-        this.sessionData = initialSessionData;
-    }
-
-    /**
-     * Gets the plugin that owns this conversation.
-     *
-     * @return The owning plugin.
-     */
-    public Plugin getPlugin() {
-        return plugin;
-    }
-
-    /**
-     * Gets the subject of the conversation.
-     *
-     * @return The subject of the conversation.
-     */
-    public Conversable getForWhom() {
-        return forWhom;
-    }
-
-    /**
-     * Gets session data shared between all {@link Prompt} invocations. Use
-     * this as a way to pass data through each Prompt as the conversation
-     * develops.
-     *
-     * @param key The session data key.
-     * @return The requested session data.
-     */
-    public Object getSessionData(Object key) {
-        return sessionData.get(key);
-    }
-
-    /**
-     * Sets session data shared between all {@link Prompt} invocations. Use
-     * this as a way to pass data through each prompt as the conversation
-     * develops.
-     *
-     * @param key The session data key.
-     * @param value The session data value.
-     */
-    public void setSessionData(Object key, Object value) {
-        sessionData.put(key, value);
-    }
-}
diff --git a/src/main/java/org/bukkit/conversations/ConversationFactory.java b/src/main/java/org/bukkit/conversations/ConversationFactory.java
deleted file mode 100644
index e7cbd52..0000000
--- a/src/main/java/org/bukkit/conversations/ConversationFactory.java
+++ /dev/null
@@ -1,228 +0,0 @@
-package org.bukkit.conversations;
-
-import org.bukkit.entity.Player;
-import org.bukkit.plugin.Plugin;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-/**
- * A ConversationFactory is responsible for creating a {@link Conversation}
- * from a predefined template. A ConversationFactory is typically created when
- * a plugin is instantiated and builds a Conversation each time a user
- * initiates a conversation with the plugin. Each Conversation maintains its
- * own state and calls back as needed into the plugin.
- * <p>
- * The ConversationFactory implements a fluid API, allowing parameters to be
- * set as an extension to the constructor.
- */
-public class ConversationFactory {
-
-    protected Plugin plugin;
-    protected boolean isModal;
-    protected boolean localEchoEnabled;
-    protected ConversationPrefix prefix;
-    protected Prompt firstPrompt;
-    protected Map<Object, Object> initialSessionData;
-    protected String playerOnlyMessage;
-    protected List<ConversationCanceller> cancellers;
-    protected List<ConversationAbandonedListener> abandonedListeners;
-
-    /**
-     * Constructs a ConversationFactory.
-     *
-     * @param plugin The plugin that owns the factory.
-     */
-    public ConversationFactory(Plugin plugin)
-    {
-        this.plugin = plugin;
-        isModal = true;
-        localEchoEnabled = true;
-        prefix = new NullConversationPrefix();
-        firstPrompt = Prompt.END_OF_CONVERSATION;
-        initialSessionData = new HashMap<Object, Object>();
-        playerOnlyMessage = null;
-        cancellers = new ArrayList<ConversationCanceller>();
-        abandonedListeners = new ArrayList<ConversationAbandonedListener>();
-    }
-
-    /**
-     * Sets the modality of all {@link Conversation}s created by this factory.
-     * If a conversation is modal, all messages directed to the player are
-     * suppressed for the duration of the conversation.
-     * <p>
-     * The default is True.
-     *
-     * @param modal The modality of all conversations to be created.
-     * @return This object.
-     */
-    public ConversationFactory withModality(boolean modal)
-    {
-        isModal = modal;
-        return this;
-    }
-
-    /**
-     * Sets the local echo status for all {@link Conversation}s created by
-     * this factory. If local echo is enabled, any text submitted to a
-     * conversation gets echoed back into the submitter's chat window.
-     *
-     * @param localEchoEnabled The status of local echo.
-     * @return This object.
-     */
-    public ConversationFactory withLocalEcho(boolean localEchoEnabled) {
-        this.localEchoEnabled = localEchoEnabled;
-        return this;
-    }
-
-    /**
-     * Sets the {@link ConversationPrefix} that prepends all output from all
-     * generated conversations.
-     * <p>
-     * The default is a {@link NullConversationPrefix};
-     *
-     * @param prefix The ConversationPrefix to use.
-     * @return This object.
-     */
-    public ConversationFactory withPrefix(ConversationPrefix prefix) {
-        this.prefix = prefix;
-        return this;
-    }
-
-    /**
-     * Sets the number of inactive seconds to wait before automatically
-     * abandoning all generated conversations.
-     * <p>
-     * The default is 600 seconds (5 minutes).
-     *
-     * @param timeoutSeconds The number of seconds to wait.
-     * @return This object.
-     */
-    public ConversationFactory withTimeout(int timeoutSeconds) {
-        return withConversationCanceller(new InactivityConversationCanceller(plugin, timeoutSeconds));
-    }
-
-    /**
-     * Sets the first prompt to use in all generated conversations.
-     * <p>
-     * The default is Prompt.END_OF_CONVERSATION.
-     *
-     * @param firstPrompt The first prompt.
-     * @return This object.
-     */
-    public ConversationFactory withFirstPrompt(Prompt firstPrompt) {
-        this.firstPrompt = firstPrompt;
-        return this;
-    }
-
-    /**
-     * Sets any initial data with which to populate the conversation context
-     * sessionData map.
-     *
-     * @param initialSessionData The conversation context's initial
-     *     sessionData.
-     * @return This object.
-     */
-    public ConversationFactory withInitialSessionData(Map<Object, Object> initialSessionData) {
-        this.initialSessionData = initialSessionData;
-        return this;
-    }
-
-    /**
-     * Sets the player input that, when received, will immediately terminate
-     * the conversation.
-     *
-     * @param escapeSequence Input to terminate the conversation.
-     * @return This object.
-     */
-    public ConversationFactory withEscapeSequence(String escapeSequence) {
-        return withConversationCanceller(new ExactMatchConversationCanceller(escapeSequence));
-    }
-
-
-    /**
-     * Adds a {@link ConversationCanceller} to constructed conversations.
-     *
-     * @param canceller The {@link ConversationCanceller} to add.
-     * @return This object.
-     */
-    public ConversationFactory withConversationCanceller(ConversationCanceller canceller) {
-        cancellers.add(canceller);
-        return this;
-    }
-
-    /**
-     * Prevents this factory from creating a conversation for non-player
-     * {@link Conversable} objects.
-     *
-     * @param playerOnlyMessage The message to return to a non-play in lieu of
-     *     starting a conversation.
-     * @return This object.
-     */
-    public ConversationFactory thatExcludesNonPlayersWithMessage(String playerOnlyMessage) {
-        this.playerOnlyMessage = playerOnlyMessage;
-        return this;
-    }
-
-    /**
-     * Adds a {@link ConversationAbandonedListener} to all conversations
-     * constructed by this factory.
-     *
-     * @param listener The listener to add.
-     * @return This object.
-     */
-    public ConversationFactory addConversationAbandonedListener(ConversationAbandonedListener listener) {
-        abandonedListeners.add(listener);
-        return this;
-    }
-
-    /**
-     * Constructs a {@link Conversation} in accordance with the defaults set
-     * for this factory.
-     *
-     * @param forWhom The entity for whom the new conversation is mediating.
-     * @return A new conversation.
-     */
-    public Conversation buildConversation(Conversable forWhom) {
-        //Abort conversation construction if we aren't supposed to talk to non-players
-        if (playerOnlyMessage != null && !(forWhom instanceof Player)) {
-            return new Conversation(plugin, forWhom, new NotPlayerMessagePrompt());
-        }
-
-        //Clone any initial session data
-        Map<Object, Object> copiedInitialSessionData = new HashMap<Object, Object>();
-        copiedInitialSessionData.putAll(initialSessionData);
-
-        //Build and return a conversation
-        Conversation conversation = new Conversation(plugin, forWhom, firstPrompt, copiedInitialSessionData);
-        conversation.setModal(isModal);
-        conversation.setLocalEchoEnabled(localEchoEnabled);
-        conversation.setPrefix(prefix);
-
-        //Clone the conversation cancellers
-        for (ConversationCanceller canceller : cancellers) {
-            conversation.addConversationCanceller(canceller.clone());
-        }
-
-        //Add the ConversationAbandonedListeners
-        for (ConversationAbandonedListener listener : abandonedListeners) {
-            conversation.addConversationAbandonedListener(listener);
-        }
-
-        return conversation;
-    }
-
-    private class NotPlayerMessagePrompt extends MessagePrompt {
-
-        public String getPromptText(ConversationContext context) {
-            return playerOnlyMessage;
-        }
-
-        @Override
-        protected Prompt getNextPrompt(ConversationContext context) {
-            return Prompt.END_OF_CONVERSATION;
-        }
-    }
-}
diff --git a/src/main/java/org/bukkit/conversations/ConversationPrefix.java b/src/main/java/org/bukkit/conversations/ConversationPrefix.java
deleted file mode 100644
index 9889f17..0000000
--- a/src/main/java/org/bukkit/conversations/ConversationPrefix.java
+++ /dev/null
@@ -1,19 +0,0 @@
-package org.bukkit.conversations;
-
-import org.bukkit.command.CommandSender;
-
-/**
- * A ConversationPrefix implementation prepends all output from the
- * conversation to the player. The ConversationPrefix can be used to display
- * the plugin name or conversation status as the conversation evolves.
- */
-public interface ConversationPrefix {
-
-    /**
-     * Gets the prefix to use before each message to the player.
-     *
-     * @param context Context information about the conversation.
-     * @return The prefix text.
-     */
-    String getPrefix(ConversationContext context);
-}
diff --git a/src/main/java/org/bukkit/conversations/ExactMatchConversationCanceller.java b/src/main/java/org/bukkit/conversations/ExactMatchConversationCanceller.java
deleted file mode 100644
index 327b9d9..0000000
--- a/src/main/java/org/bukkit/conversations/ExactMatchConversationCanceller.java
+++ /dev/null
@@ -1,29 +0,0 @@
-package org.bukkit.conversations;
-
-/**
- * An ExactMatchConversationCanceller cancels a conversation if the user
- * enters an exact input string
- */
-public class ExactMatchConversationCanceller implements ConversationCanceller {
-    private String escapeSequence;
-
-    /**
-     * Builds an ExactMatchConversationCanceller.
-     *
-     * @param escapeSequence The string that, if entered by the user, will
-     *     cancel the conversation.
-     */
-    public ExactMatchConversationCanceller(String escapeSequence) {
-        this.escapeSequence = escapeSequence;
-    }
-    
-    public void setConversation(Conversation conversation) {}
-
-    public boolean cancelBasedOnInput(ConversationContext context, String input) {
-        return input.equals(escapeSequence);
-    }
-
-    public ConversationCanceller clone() {
-        return new ExactMatchConversationCanceller(escapeSequence);
-    }
-}
diff --git a/src/main/java/org/bukkit/conversations/FixedSetPrompt.java b/src/main/java/org/bukkit/conversations/FixedSetPrompt.java
deleted file mode 100644
index b867c11..0000000
--- a/src/main/java/org/bukkit/conversations/FixedSetPrompt.java
+++ /dev/null
@@ -1,46 +0,0 @@
-package org.bukkit.conversations;
-
-import org.apache.commons.lang.StringUtils;
-
-import java.util.Arrays;
-import java.util.List;
-
-/**
- * FixedSetPrompt is the base class for any prompt that requires a fixed set
- * response from the user.
- */
-public abstract class FixedSetPrompt extends ValidatingPrompt {
-    
-    protected List<String> fixedSet;
-
-    /**
-     * Creates a FixedSetPrompt from a set of strings.
-     * <p>
-     * foo = new FixedSetPrompt("bar", "cheese", "panda");
-     *
-     * @param fixedSet A fixed set of strings, one of which the user must
-     *     type.
-     */
-    public FixedSetPrompt(String... fixedSet) {
-        super();
-        this.fixedSet = Arrays.asList(fixedSet);
-    }
-
-    private FixedSetPrompt() {}
-
-    @Override
-    protected boolean isInputValid(ConversationContext context, String input) {
-        return fixedSet.contains(input);
-    }
-
-    /**
-     * Utility function to create a formatted string containing all the
-     * options declared in the constructor.
-     *
-     * @return the options formatted like "[bar, cheese, panda]" if bar,
-     *     cheese, and panda were the options used
-     */
-    protected String formatFixedSet() {
-        return "[" + StringUtils.join(fixedSet, ", ") + "]";
-    }
-}
diff --git a/src/main/java/org/bukkit/conversations/InactivityConversationCanceller.java b/src/main/java/org/bukkit/conversations/InactivityConversationCanceller.java
deleted file mode 100644
index 760a518..0000000
--- a/src/main/java/org/bukkit/conversations/InactivityConversationCanceller.java
+++ /dev/null
@@ -1,79 +0,0 @@
-package org.bukkit.conversations;
-
-import org.bukkit.Server;
-import org.bukkit.plugin.Plugin;
-
-/**
- * An InactivityConversationCanceller will cancel a {@link Conversation} after
- * a period of inactivity by the user.
- */
-public class InactivityConversationCanceller implements ConversationCanceller {
-    protected Plugin plugin;
-    protected int timeoutSeconds;
-    protected Conversation conversation;
-    private int taskId = -1;
-
-    /**
-     * Creates an InactivityConversationCanceller.
-     *
-     * @param plugin The owning plugin.
-     * @param timeoutSeconds The number of seconds of inactivity to wait.
-     */
-    public InactivityConversationCanceller(Plugin plugin, int timeoutSeconds) {
-        this.plugin = plugin;
-        this.timeoutSeconds = timeoutSeconds;
-    }
-
-    public void setConversation(Conversation conversation) {
-        this.conversation = conversation;
-        startTimer();
-    }
-
-    public boolean cancelBasedOnInput(ConversationContext context, String input) {
-        // Reset the inactivity timer
-        stopTimer();
-        startTimer();
-        return false;
-    }
-
-    public ConversationCanceller clone() {
-        return new InactivityConversationCanceller(plugin, timeoutSeconds);
-    }
-
-    /**
-     * Starts an inactivity timer.
-     */
-    private void startTimer() {
-        taskId = plugin.getServer().getScheduler().scheduleSyncDelayedTask(plugin, new Runnable() {
-            public void run() {
-                if (conversation.getState() == Conversation.ConversationState.UNSTARTED) {
-                    startTimer();
-                } else if (conversation.getState() ==  Conversation.ConversationState.STARTED) {
-                    cancelling(conversation);
-                    conversation.abandon(new ConversationAbandonedEvent(conversation, InactivityConversationCanceller.this));
-                }
-            }
-        }, timeoutSeconds * 20);
-    }
-
-    /**
-     * Stops the active inactivity timer.
-     */
-    private void stopTimer() {
-        if (taskId != -1) {
-            plugin.getServer().getScheduler().cancelTask(taskId);
-            taskId = -1;
-        }
-    }
-
-    /**
-     * Subclasses of InactivityConversationCanceller can override this method
-     * to take additional actions when the inactivity timer abandons the
-     * conversation.
-     *
-     * @param conversation The conversation being abandoned.
-     */
-    protected void cancelling(Conversation conversation) {
-
-    }
-}
diff --git a/src/main/java/org/bukkit/conversations/ManuallyAbandonedConversationCanceller.java b/src/main/java/org/bukkit/conversations/ManuallyAbandonedConversationCanceller.java
deleted file mode 100644
index 3e80de1..0000000
--- a/src/main/java/org/bukkit/conversations/ManuallyAbandonedConversationCanceller.java
+++ /dev/null
@@ -1,20 +0,0 @@
-package org.bukkit.conversations;
-
-/**
- * The ManuallyAbandonedConversationCanceller is only used as part of a {@link
- * ConversationAbandonedEvent} to indicate that the conversation was manually
- * abandoned by programmatically calling the abandon() method on it.
- */
-public class ManuallyAbandonedConversationCanceller implements ConversationCanceller{
-    public void setConversation(Conversation conversation) {
-        throw new UnsupportedOperationException();
-    }
-
-    public boolean cancelBasedOnInput(ConversationContext context, String input) {
-        throw new UnsupportedOperationException();
-    }
-
-    public ConversationCanceller clone() {
-        throw new UnsupportedOperationException();
-    }
-}
diff --git a/src/main/java/org/bukkit/conversations/MessagePrompt.java b/src/main/java/org/bukkit/conversations/MessagePrompt.java
deleted file mode 100644
index fa1775a..0000000
--- a/src/main/java/org/bukkit/conversations/MessagePrompt.java
+++ /dev/null
@@ -1,42 +0,0 @@
-package org.bukkit.conversations;
-
-/**
- * MessagePrompt is the base class for any prompt that only displays a message
- * to the user and requires no input.
- */
-public abstract class MessagePrompt implements Prompt{
-
-    public MessagePrompt() {
-        super();
-    }
-
-    /**
-     * Message prompts never wait for user input before continuing.
-     *
-     * @param context Context information about the conversation.
-     * @return Always false.
-     */
-    public boolean blocksForInput(ConversationContext context) {
-        return false;
-    }
-
-    /**
-     * Accepts and ignores any user input, returning the next prompt in the
-     * prompt graph instead.
-     *
-     * @param context Context information about the conversation.
-     * @param input Ignored.
-     * @return The next prompt in the prompt graph.
-     */
-    public Prompt acceptInput(ConversationContext context, String input) {
-        return getNextPrompt(context);
-    }
-
-    /**
-     * Override this method to return the next prompt in the prompt graph.
-     *
-     * @param context Context information about the conversation.
-     * @return The next prompt in the prompt graph.
-     */
-    protected abstract Prompt getNextPrompt(ConversationContext context);
-}
diff --git a/src/main/java/org/bukkit/conversations/NullConversationPrefix.java b/src/main/java/org/bukkit/conversations/NullConversationPrefix.java
deleted file mode 100644
index 7d8a7d8..0000000
--- a/src/main/java/org/bukkit/conversations/NullConversationPrefix.java
+++ /dev/null
@@ -1,20 +0,0 @@
-package org.bukkit.conversations;
-
-import org.bukkit.command.CommandSender;
-
-/**
- * NullConversationPrefix is a {@link ConversationPrefix} implementation that
- * displays nothing in front of conversation output.
- */
-public class NullConversationPrefix implements ConversationPrefix{
-
-    /**
-     * Prepends each conversation message with an empty string.
-     *
-     * @param context Context information about the conversation.
-     * @return An empty string.
-     */
-    public String getPrefix(ConversationContext context) {
-        return "";
-    }
-}
diff --git a/src/main/java/org/bukkit/conversations/NumericPrompt.java b/src/main/java/org/bukkit/conversations/NumericPrompt.java
deleted file mode 100644
index f0fdea1..0000000
--- a/src/main/java/org/bukkit/conversations/NumericPrompt.java
+++ /dev/null
@@ -1,83 +0,0 @@
-package org.bukkit.conversations;
-
-import org.apache.commons.lang.math.NumberUtils;
-
-/**
- * NumericPrompt is the base class for any prompt that requires a {@link
- * Number} response from the user.
- */
-public abstract class NumericPrompt extends ValidatingPrompt{
-    public NumericPrompt() {
-        super();
-    }
-
-    @Override
-    protected boolean isInputValid(ConversationContext context, String input) {
-        return NumberUtils.isNumber(input) && isNumberValid(context, NumberUtils.createNumber(input));
-    }
-
-    /**
-     * Override this method to do further validation on the numeric player
-     * input after the input has been determined to actually be a number.
-     *
-     * @param context Context information about the conversation.
-     * @param input The number the player provided.
-     * @return The validity of the player's input.
-     */
-    protected boolean isNumberValid(ConversationContext context, Number input) {
-        return true;
-    }
-
-    @Override
-    protected Prompt acceptValidatedInput(ConversationContext context, String input) {
-        try
-        {
-            return acceptValidatedInput(context, NumberUtils.createNumber(input));
-        } catch (NumberFormatException e) {
-            return acceptValidatedInput(context, NumberUtils.INTEGER_ZERO);
-        }
-    }
-
-    /**
-     * Override this method to perform some action with the user's integer
-     * response.
-     *
-     * @param context Context information about the conversation.
-     * @param input The user's response as a {@link Number}.
-     * @return The next {@link Prompt} in the prompt graph.
-     */
-    protected abstract Prompt acceptValidatedInput(ConversationContext context, Number input);
-
-    @Override
-    protected String getFailedValidationText(ConversationContext context, String invalidInput) {
-        if (NumberUtils.isNumber(invalidInput)) {
-            return getFailedValidationText(context, NumberUtils.createNumber(invalidInput));
-        } else {
-            return getInputNotNumericText(context, invalidInput);
-        }
-    }
-
-    /**
-     * Optionally override this method to display an additional message if the
-     * user enters an invalid number.
-     *
-     * @param context Context information about the conversation.
-     * @param invalidInput The invalid input provided by the user.
-     * @return A message explaining how to correct the input.
-     */
-    protected String getInputNotNumericText(ConversationContext context, String invalidInput) {
-        return null;
-    }
-
-    /**
-     * Optionally override this method to display an additional message if the
-     * user enters an invalid numeric input.
-     *
-     * @param context Context information about the conversation.
-     * @param invalidInput The invalid input provided by the user.
-     * @return A message explaining how to correct the input.
-     */
-    protected String getFailedValidationText(ConversationContext context, Number invalidInput) {
-        return null;
-    }
-}
diff --git a/src/main/java/org/bukkit/conversations/PlayerNamePrompt.java b/src/main/java/org/bukkit/conversations/PlayerNamePrompt.java
deleted file mode 100644
index feeb715..0000000
--- a/src/main/java/org/bukkit/conversations/PlayerNamePrompt.java
+++ /dev/null
@@ -1,38 +0,0 @@
-package org.bukkit.conversations;
-
-import org.bukkit.entity.Player;
-import org.bukkit.plugin.Plugin;
-
-/**
- * PlayerNamePrompt is the base class for any prompt that requires the player
- * to enter another player's name.
- */
-public abstract class PlayerNamePrompt extends ValidatingPrompt{
-    private Plugin plugin;
-
-    public PlayerNamePrompt(Plugin plugin) {
-        super();
-        this.plugin = plugin;
-    }
-
-    @Override
-    protected boolean isInputValid(ConversationContext context, String input) {
-        return plugin.getServer().getPlayer(input) != null;
-        
-    }
-
-    @Override
-    protected Prompt acceptValidatedInput(ConversationContext context, String input) {
-        return acceptValidatedInput(context, plugin.getServer().getPlayer(input));
-    }
-
-    /**
-     * Override this method to perform some action with the user's player name
-     * response.
-     *
-     * @param context Context information about the conversation.
-     * @param input The user's player name response.
-     * @return The next {@link Prompt} in the prompt graph.
-     */
-    protected abstract Prompt acceptValidatedInput(ConversationContext context, Player input);
-}
diff --git a/src/main/java/org/bukkit/conversations/PluginNameConversationPrefix.java b/src/main/java/org/bukkit/conversations/PluginNameConversationPrefix.java
deleted file mode 100644
index 2290979..0000000
--- a/src/main/java/org/bukkit/conversations/PluginNameConversationPrefix.java
+++ /dev/null
@@ -1,40 +0,0 @@
-package org.bukkit.conversations;
-
-import org.bukkit.ChatColor;
-import org.bukkit.command.CommandSender;
-import org.bukkit.plugin.Plugin;
-
-/**
- * PluginNameConversationPrefix is a {@link ConversationPrefix} implementation
- * that displays the plugin name in front of conversation output.
- */
-public class PluginNameConversationPrefix implements ConversationPrefix {
-    
-    protected String separator;
-    protected ChatColor prefixColor;
-    protected Plugin plugin;
-    
-    private String cachedPrefix;
-    
-    public PluginNameConversationPrefix(Plugin plugin) {
-        this(plugin, " > ", ChatColor.LIGHT_PURPLE);
-    }
-    
-    public PluginNameConversationPrefix(Plugin plugin, String separator, ChatColor prefixColor) {
-        this.separator = separator;
-        this.prefixColor = prefixColor;
-        this.plugin = plugin;
-
-        cachedPrefix = prefixColor + plugin.getDescription().getName() + separator + ChatColor.WHITE;
-    }
-
-    /**
-     * Prepends each conversation message with the plugin name.
-     *
-     * @param context Context information about the conversation.
-     * @return An empty string.
-     */
-    public String getPrefix(ConversationContext context) {
-        return cachedPrefix;
-    }
-}
diff --git a/src/main/java/org/bukkit/conversations/Prompt.java b/src/main/java/org/bukkit/conversations/Prompt.java
deleted file mode 100644
index 7519c84..0000000
--- a/src/main/java/org/bukkit/conversations/Prompt.java
+++ /dev/null
@@ -1,45 +0,0 @@
-package org.bukkit.conversations;
-
-/**
- * A Prompt is the main constituent of a {@link Conversation}. Each prompt
- * displays text to the user and optionally waits for a user's response.
- * Prompts are chained together into a directed graph that represents the
- * conversation flow. To halt a conversation, END_OF_CONVERSATION is returned
- * in liu of another Prompt object.
- */
-public interface Prompt extends Cloneable {
-
-    /**
-     * A convenience constant for indicating the end of a conversation.
-     */
-    static final Prompt END_OF_CONVERSATION = null;
-
-    /**
-     * Gets the text to display to the user when this prompt is first
-     * presented.
-     *
-     * @param context Context information about the conversation.
-     * @return The text to display.
-     */
-    String getPromptText(ConversationContext context);
-
-    /**
-     * Checks to see if this prompt implementation should wait for user input
-     * or immediately display the next prompt.
-     *
-     * @param context Context information about the conversation.
-     * @return If true, the {@link Conversation} will wait for input before
-     *     continuing.
-     */
-    boolean blocksForInput(ConversationContext context);
-
-    /**
-     * Accepts and processes input from the user. Using the input, the next
-     * Prompt in the prompt graph is returned.
-     *
-     * @param context Context information about the conversation.
-     * @param input The input text from the user.
-     * @return The next Prompt in the prompt graph.
-     */
-    Prompt acceptInput(ConversationContext context, String input);
-}
diff --git a/src/main/java/org/bukkit/conversations/RegexPrompt.java b/src/main/java/org/bukkit/conversations/RegexPrompt.java
deleted file mode 100644
index a3c7d1f..0000000
--- a/src/main/java/org/bukkit/conversations/RegexPrompt.java
+++ /dev/null
@@ -1,28 +0,0 @@
-package org.bukkit.conversations;
-
-import java.util.regex.Pattern;
-
-/**
- * RegexPrompt is the base class for any prompt that requires an input
- * validated by a regular expression.
- */
-public abstract class RegexPrompt extends ValidatingPrompt {
-
-    private Pattern pattern;
-
-    public RegexPrompt(String regex) {
-        this(Pattern.compile(regex));
-    }
-
-    public RegexPrompt(Pattern pattern) {
-        super();
-        this.pattern = pattern;
-    }
-
-    private RegexPrompt() {}
-
-    @Override
-    protected boolean isInputValid(ConversationContext context, String input) {
-        return pattern.matcher(input).matches();
-    }
-}
diff --git a/src/main/java/org/bukkit/conversations/StringPrompt.java b/src/main/java/org/bukkit/conversations/StringPrompt.java
deleted file mode 100644
index 2934459..0000000
--- a/src/main/java/org/bukkit/conversations/StringPrompt.java
+++ /dev/null
@@ -1,18 +0,0 @@
-package org.bukkit.conversations;
-
-/**
- * StringPrompt is the base class for any prompt that accepts an arbitrary
- * string from the user.
- */
-public abstract class StringPrompt implements Prompt{
-
-    /**
-     * Ensures that the prompt waits for the user to provide input.
-     *
-     * @param context Context information about the conversation.
-     * @return True.
-     */
-    public boolean blocksForInput(ConversationContext context) {
-        return true;
-    }
-}
diff --git a/src/main/java/org/bukkit/conversations/ValidatingPrompt.java b/src/main/java/org/bukkit/conversations/ValidatingPrompt.java
deleted file mode 100644
index f41adb4..0000000
--- a/src/main/java/org/bukkit/conversations/ValidatingPrompt.java
+++ /dev/null
@@ -1,78 +0,0 @@
-package org.bukkit.conversations;
-
-import org.bukkit.ChatColor;
-
-/**
- * ValidatingPrompt is the base class for any prompt that requires validation.
- * ValidatingPrompt will keep replaying the prompt text until the user enters
- * a valid response.
- */
-public abstract class ValidatingPrompt implements Prompt {
-    public ValidatingPrompt() {
-        super();
-    }
-
-    /**
-     * Accepts and processes input from the user and validates it. If
-     * validation fails, this prompt is returned for re-execution, otherwise
-     * the next Prompt in the prompt graph is returned.
-     *
-     * @param context Context information about the conversation.
-     * @param input The input text from the user.
-     * @return This prompt or the next Prompt in the prompt graph.
-     */
-    public Prompt acceptInput(ConversationContext context, String input) {
-        if (isInputValid(context, input)) {
-            return acceptValidatedInput(context, input);
-        } else {
-            String failPrompt = getFailedValidationText(context, input);
-            if (failPrompt != null) {
-                context.getForWhom().sendRawMessage(ChatColor.RED + failPrompt);
-            }
-            // Redisplay this prompt to the user to re-collect input
-            return this;
-        }
-    }
-
-    /**
-     * Ensures that the prompt waits for the user to provide input.
-     *
-     * @param context Context information about the conversation.
-     * @return True.
-     */
-    public boolean blocksForInput(ConversationContext context) {
-        return true;
-    }
-
-    /**
-     * Override this method to check the validity of the player's input.
-     *
-     * @param context Context information about the conversation.
-     * @param input The player's raw console input.
-     * @return True or false depending on the validity of the input.
-     */
-    protected abstract boolean isInputValid(ConversationContext context, String input);
-
-    /**
-     * Override this method to accept and processes the validated input from
-     * the user. Using the input, the next Prompt in the prompt graph should
-     * be returned.
-     *
-     * @param context Context information about the conversation.
-     * @param input The validated input text from the user.
-     * @return The next Prompt in the prompt graph.
-     */
-    protected abstract Prompt acceptValidatedInput(ConversationContext context, String input);
-
-    /**
-     * Optionally override this method to display an additional message if the
-     * user enters an invalid input.
-     *
-     * @param context Context information about the conversation.
-     * @param invalidInput The invalid input provided by the user.
-     * @return A message explaining how to correct the input.
-     */
-    protected String getFailedValidationText(ConversationContext context, String invalidInput) {
-        return null;
-    }
-}
diff --git a/src/main/java/org/bukkit/enchantments/Enchantment.java b/src/main/java/org/bukkit/enchantments/Enchantment.java
deleted file mode 100644
index a23ee5c..0000000
--- a/src/main/java/org/bukkit/enchantments/Enchantment.java
+++ /dev/null
@@ -1,307 +0,0 @@
-package org.bukkit.enchantments;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import org.bukkit.command.defaults.EnchantCommand;
-import org.bukkit.inventory.ItemStack;
-
-/**
- * The various type of enchantments that may be added to armour or weapons
- */
-public abstract class Enchantment {
-    /**
-     * Provides protection against environmental damage
-     */
-    public static final Enchantment PROTECTION_ENVIRONMENTAL = new EnchantmentWrapper(0);
-
-    /**
-     * Provides protection against fire damage
-     */
-    public static final Enchantment PROTECTION_FIRE = new EnchantmentWrapper(1);
-
-    /**
-     * Provides protection against fall damage
-     */
-    public static final Enchantment PROTECTION_FALL = new EnchantmentWrapper(2);
-
-    /**
-     * Provides protection against explosive damage
-     */
-    public static final Enchantment PROTECTION_EXPLOSIONS = new EnchantmentWrapper(3);
-
-    /**
-     * Provides protection against projectile damage
-     */
-    public static final Enchantment PROTECTION_PROJECTILE = new EnchantmentWrapper(4);
-
-    /**
-     * Decreases the rate of air loss whilst underwater
-     */
-    public static final Enchantment OXYGEN = new EnchantmentWrapper(5);
-
-    /**
-     * Increases the speed at which a player may mine underwater
-     */
-    public static final Enchantment WATER_WORKER = new EnchantmentWrapper(6);
-
-    /**
-     * Damages the attacker
-     */
-    public static final Enchantment THORNS = new EnchantmentWrapper(7);
-
-    /**
-     * Increases walking speed while in water
-     */
-    public static final Enchantment DEPTH_STRIDER = new EnchantmentWrapper(8);
-
-    /**
-     * Freezes any still water adjacent to ice / frost which player is walking on
-     */
-    public static final Enchantment FROST_WALKER = new EnchantmentWrapper(9);
-
-    /**
-     * Increases damage against all targets
-     */
-    public static final Enchantment DAMAGE_ALL = new EnchantmentWrapper(16);
-
-    /**
-     * Increases damage against undead targets
-     */
-    public static final Enchantment DAMAGE_UNDEAD = new EnchantmentWrapper(17);
-
-    /**
-     * Increases damage against arthropod targets
-     */
-    public static final Enchantment DAMAGE_ARTHROPODS = new EnchantmentWrapper(18);
-
-    /**
-     * All damage to other targets will knock them back when hit
-     */
-    public static final Enchantment KNOCKBACK = new EnchantmentWrapper(19);
-
-    /**
-     * When attacking a target, has a chance to set them on fire
-     */
-    public static final Enchantment FIRE_ASPECT = new EnchantmentWrapper(20);
-
-    /**
-     * Provides a chance of gaining extra loot when killing monsters
-     */
-    public static final Enchantment LOOT_BONUS_MOBS = new EnchantmentWrapper(21);
-
-    /**
-     * Increases the rate at which you mine/dig
-     */
-    public static final Enchantment DIG_SPEED = new EnchantmentWrapper(32);
-
-    /**
-     * Allows blocks to drop themselves instead of fragments (for example,
-     * stone instead of cobblestone)
-     */
-    public static final Enchantment SILK_TOUCH = new EnchantmentWrapper(33);
-
-    /**
-     * Decreases the rate at which a tool looses durability
-     */
-    public static final Enchantment DURABILITY = new EnchantmentWrapper(34);
-
-    /**
-     * Provides a chance of gaining extra loot when destroying blocks
-     */
-    public static final Enchantment LOOT_BONUS_BLOCKS = new EnchantmentWrapper(35);
-
-    /**
-     * Provides extra damage when shooting arrows from bows
-     */
-    public static final Enchantment ARROW_DAMAGE = new EnchantmentWrapper(48);
-
-    /**
-     * Provides a knockback when an entity is hit by an arrow from a bow
-     */
-    public static final Enchantment ARROW_KNOCKBACK = new EnchantmentWrapper(49);
-
-    /**
-     * Sets entities on fire when hit by arrows shot from a bow
-     */
-    public static final Enchantment ARROW_FIRE = new EnchantmentWrapper(50);
-
-    /**
-     * Provides infinite arrows when shooting a bow
-     */
-    public static final Enchantment ARROW_INFINITE = new EnchantmentWrapper(51);
-
-    /**
-     * Decreases odds of catching worthless junk
-     */
-    public static final Enchantment LUCK = new EnchantmentWrapper(61);
-
-    /**
-     * Increases rate of fish biting your hook
-     */
-    public static final Enchantment LURE = new EnchantmentWrapper(62);
-
-    /**
-     * Allows mending the item using experience orbs
-     */
-    public static final Enchantment MENDING = new EnchantmentWrapper(70);
-
-    private static final Map<Integer, Enchantment> byId = new HashMap<Integer, Enchantment>();
-    private static final Map<String, Enchantment> byName = new HashMap<String, Enchantment>();
-    private static boolean acceptingNew = true;
-    private final int id;
-
-    public Enchantment(int id) {
-        this.id = id;
-    }
-
-    /**
-     * Gets the unique ID of this enchantment
-     *
-     * @return Unique ID
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public int getId() {
-        return id;
-    }
-
-    /**
-     * Gets the unique name of this enchantment
-     *
-     * @return Unique name
-     */
-    public abstract String getName();
-
-    /**
-     * Gets the maximum level that this Enchantment may become.
-     *
-     * @return Maximum level of the Enchantment
-     */
-    public abstract int getMaxLevel();
-
-    /**
-     * Gets the level that this Enchantment should start at
-     *
-     * @return Starting level of the Enchantment
-     */
-    public abstract int getStartLevel();
-
-    /**
-     * Gets the type of {@link ItemStack} that may fit this Enchantment.
-     *
-     * @return Target type of the Enchantment
-     */
-    public abstract EnchantmentTarget getItemTarget();
-
-    /**
-     * Check if this enchantment conflicts with another enchantment.
-     *
-     * @param other The enchantment to check against
-     * @return True if there is a conflict.
-     */
-    public abstract boolean conflictsWith(Enchantment other);
-
-    /**
-     * Checks if this Enchantment may be applied to the given {@link
-     * ItemStack}.
-     * <p>
-     * This does not check if it conflicts with any enchantments already
-     * applied to the item.
-     *
-     * @param item Item to test
-     * @return True if the enchantment may be applied, otherwise False
-     */
-    public abstract boolean canEnchantItem(ItemStack item);
-
-    @Override
-    public boolean equals(Object obj) {
-        if (obj == null) {
-            return false;
-        }
-        if (!(obj instanceof Enchantment)) {
-            return false;
-        }
-        final Enchantment other = (Enchantment) obj;
-        if (this.id != other.id) {
-            return false;
-        }
-        return true;
-    }
-
-    @Override
-    public int hashCode() {
-        return id;
-    }
-
-    @Override
-    public String toString() {
-        return "Enchantment[" + id + ", " + getName() + "]";
-    }
-
-    /**
-     * Registers an enchantment with the given ID and object.
-     * <p>
-     * Generally not to be used from within a plugin.
-     *
-     * @param enchantment Enchantment to register
-     */
-    public static void registerEnchantment(Enchantment enchantment) {
-        if (byId.containsKey(enchantment.id) || byName.containsKey(enchantment.getName())) {
-            throw new IllegalArgumentException("Cannot set already-set enchantment");
-        } else if (!isAcceptingRegistrations()) {
-            throw new IllegalStateException("No longer accepting new enchantments (can only be done by the server implementation)");
-        }
-
-        byId.put(enchantment.id, enchantment);
-        byName.put(enchantment.getName(), enchantment);
-    }
-
-    /**
-     * Checks if this is accepting Enchantment registrations.
-     *
-     * @return True if the server Implementation may add enchantments
-     */
-    public static boolean isAcceptingRegistrations() {
-        return acceptingNew;
-    }
-
-    /**
-     * Stops accepting any enchantment registrations
-     */
-    public static void stopAcceptingRegistrations() {
-        acceptingNew = false;
-        EnchantCommand.buildEnchantments();
-    }
-
-    /**
-     * Gets the Enchantment at the specified ID
-     *
-     * @param id ID to fetch
-     * @return Resulting Enchantment, or null if not found
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public static Enchantment getById(int id) {
-        return byId.get(id);
-    }
-
-    /**
-     * Gets the Enchantment at the specified name
-     *
-     * @param name Name to fetch
-     * @return Resulting Enchantment, or null if not found
-     */
-    public static Enchantment getByName(String name) {
-        return byName.get(name);
-    }
-
-    /**
-     * Gets an array of all the registered {@link Enchantment}s
-     *
-     * @return Array of enchantments
-     */
-    public static Enchantment[] values() {
-        return byId.values().toArray(new Enchantment[byId.size()]);
-    }
-}
diff --git a/src/main/java/org/bukkit/enchantments/EnchantmentTarget.java b/src/main/java/org/bukkit/enchantments/EnchantmentTarget.java
deleted file mode 100644
index d9b98ed..0000000
--- a/src/main/java/org/bukkit/enchantments/EnchantmentTarget.java
+++ /dev/null
@@ -1,172 +0,0 @@
-package org.bukkit.enchantments;
-
-import org.bukkit.Material;
-import org.bukkit.inventory.ItemStack;
-
-/**
- * Represents the applicable target for a {@link Enchantment}
- */
-public enum EnchantmentTarget {
-    /**
-     * Allows the Enchantment to be placed on all items
-     */
-    ALL {
-        @Override
-        public boolean includes(Material item) {
-            return true;
-        }
-    },
-
-    /**
-     * Allows the Enchantment to be placed on armor
-     */
-    ARMOR {
-        @Override
-        public boolean includes(Material item) {
-            return ARMOR_FEET.includes(item)
-                || ARMOR_LEGS.includes(item)
-                || ARMOR_HEAD.includes(item)
-                || ARMOR_TORSO.includes(item);
-        }
-    },
-
-    /**
-     * Allows the Enchantment to be placed on feet slot armor
-     */
-    ARMOR_FEET {
-        @Override
-        public boolean includes(Material item) {
-            return item.equals(Material.LEATHER_BOOTS)
-                || item.equals(Material.CHAINMAIL_BOOTS)
-                || item.equals(Material.IRON_BOOTS)
-                || item.equals(Material.DIAMOND_BOOTS)
-                || item.equals(Material.GOLD_BOOTS);
-        }
-    },
-
-    /**
-     * Allows the Enchantment to be placed on leg slot armor
-     */
-    ARMOR_LEGS {
-        @Override
-        public boolean includes(Material item) {
-            return item.equals(Material.LEATHER_LEGGINGS)
-                || item.equals(Material.CHAINMAIL_LEGGINGS)
-                || item.equals(Material.IRON_LEGGINGS)
-                || item.equals(Material.DIAMOND_LEGGINGS)
-                || item.equals(Material.GOLD_LEGGINGS);
-        }
-    },
-
-    /**
-     * Allows the Enchantment to be placed on torso slot armor
-     */
-    ARMOR_TORSO {
-        @Override
-        public boolean includes(Material item) {
-            return item.equals(Material.LEATHER_CHESTPLATE)
-                || item.equals(Material.CHAINMAIL_CHESTPLATE)
-                || item.equals(Material.IRON_CHESTPLATE)
-                || item.equals(Material.DIAMOND_CHESTPLATE)
-                || item.equals(Material.GOLD_CHESTPLATE);
-        }
-    },
-
-    /**
-     * Allows the Enchantment to be placed on head slot armor
-     */
-    ARMOR_HEAD {
-        @Override
-        public boolean includes(Material item) {
-            return item.equals(Material.LEATHER_HELMET)
-                || item.equals(Material.CHAINMAIL_HELMET)
-                || item.equals(Material.DIAMOND_HELMET)
-                || item.equals(Material.IRON_HELMET)
-                || item.equals(Material.GOLD_HELMET);
-        }
-    },
-
-    /**
-     * Allows the Enchantment to be placed on weapons (swords)
-     */
-    WEAPON {
-        @Override
-        public boolean includes(Material item) {
-            return item.equals(Material.WOOD_SWORD)
-                || item.equals(Material.STONE_SWORD)
-                || item.equals(Material.IRON_SWORD)
-                || item.equals(Material.DIAMOND_SWORD)
-                || item.equals(Material.GOLD_SWORD);
-        }
-    },
-
-    /**
-     * Allows the Enchantment to be placed on tools (spades, pickaxe, hoes,
-     * axes)
-     */
-    TOOL {
-        @Override
-        public boolean includes(Material item) {
-            return item.equals(Material.WOOD_SPADE)
-                || item.equals(Material.STONE_SPADE)
-                || item.equals(Material.IRON_SPADE)
-                || item.equals(Material.DIAMOND_SPADE)
-                || item.equals(Material.GOLD_SPADE)
-                || item.equals(Material.WOOD_PICKAXE)
-                || item.equals(Material.STONE_PICKAXE)
-                || item.equals(Material.IRON_PICKAXE)
-                || item.equals(Material.DIAMOND_PICKAXE)
-                || item.equals(Material.GOLD_PICKAXE)
-                || item.equals(Material.WOOD_HOE)         // NOTE: No vanilla enchantments for this
-                || item.equals(Material.STONE_HOE)        // NOTE: No vanilla enchantments for this
-                || item.equals(Material.IRON_HOE)         // NOTE: No vanilla enchantments for this
-                || item.equals(Material.DIAMOND_HOE)      // NOTE: No vanilla enchantments for this
-                || item.equals(Material.GOLD_HOE)         // NOTE: No vanilla enchantments for this
-                || item.equals(Material.WOOD_AXE)
-                || item.equals(Material.STONE_AXE)
-                || item.equals(Material.IRON_AXE)
-                || item.equals(Material.DIAMOND_AXE)
-                || item.equals(Material.GOLD_AXE)
-                || item.equals(Material.SHEARS)           // NOTE: No vanilla enchantments for this
-                || item.equals(Material.FLINT_AND_STEEL); // NOTE: No vanilla enchantments for this
-        }
-    },
-
-    /**
-     * Allows the Enchantment to be placed on bows.
-     */
-    BOW {
-        @Override
-        public boolean includes(Material item) {
-            return item.equals(Material.BOW);
-        }
-    },
-
-    /**
-     * Allows the Enchantment to be placed on fishing rods.
-     */
-    FISHING_ROD {
-        @Override
-        public boolean includes(Material item) {
-            return item.equals(Material.FISHING_ROD);
-        }
-    };
-
-    /**
-     * Check whether this target includes the specified item.
-     *
-     * @param item The item to check
-     * @return True if the target includes the item
-     */
-    public abstract boolean includes(Material item);
-
-    /**
-     * Check whether this target includes the specified item.
-     *
-     * @param item The item to check
-     * @return True if the target includes the item
-     */
-    public boolean includes(ItemStack item) {
-        return includes(item.getType());
-    }
-}
diff --git a/src/main/java/org/bukkit/enchantments/EnchantmentWrapper.java b/src/main/java/org/bukkit/enchantments/EnchantmentWrapper.java
deleted file mode 100644
index 6a0aeb3..0000000
--- a/src/main/java/org/bukkit/enchantments/EnchantmentWrapper.java
+++ /dev/null
@@ -1,51 +0,0 @@
-package org.bukkit.enchantments;
-
-import org.bukkit.inventory.ItemStack;
-
-/**
- * A simple wrapper for ease of selecting {@link Enchantment}s
- */
-public class EnchantmentWrapper extends Enchantment {
-    public EnchantmentWrapper(int id) {
-        super(id);
-    }
-
-    /**
-     * Gets the enchantment bound to this wrapper
-     *
-     * @return Enchantment
-     */
-    public Enchantment getEnchantment() {
-        return Enchantment.getById(getId());
-    }
-
-    @Override
-    public int getMaxLevel() {
-        return getEnchantment().getMaxLevel();
-    }
-
-    @Override
-    public int getStartLevel() {
-        return getEnchantment().getStartLevel();
-    }
-
-    @Override
-    public EnchantmentTarget getItemTarget() {
-        return getEnchantment().getItemTarget();
-    }
-
-    @Override
-    public boolean canEnchantItem(ItemStack item) {
-        return getEnchantment().canEnchantItem(item);
-    }
-
-    @Override
-    public String getName() {
-        return getEnchantment().getName();
-    }
-
-    @Override
-    public boolean conflictsWith(Enchantment other) {
-        return getEnchantment().conflictsWith(other);
-    }
-}
diff --git a/src/main/java/org/bukkit/entity/Ageable.java b/src/main/java/org/bukkit/entity/Ageable.java
deleted file mode 100644
index e9fccb2..0000000
--- a/src/main/java/org/bukkit/entity/Ageable.java
+++ /dev/null
@@ -1,67 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * Represents an entity that can age and breed.
- */
-public interface Ageable extends Creature {    
-    /**
-     * Gets the age of this animal.
-     *
-     * @return Age
-     */
-    public int getAge();
-
-    /**
-     * Sets the age of this animal.
-     *
-     * @param age New age
-     */
-    public void setAge(int age);
-
-    /**
-     * Lock the age of the animal, setting this will prevent the animal from
-     * maturing or getting ready for mating.
-     *
-     * @param lock new lock
-     */
-    public void setAgeLock(boolean lock);
-
-    /**
-     * Gets the current agelock.
-     *
-     * @return the current agelock
-     */
-    public boolean getAgeLock();
-
-    /**
-     * Sets the age of the animal to a baby
-     */
-    public void setBaby();
-
-    /**
-     * Sets the age of the animal to an adult
-     */
-    public void setAdult();
-
-    /**
-     * Returns true if the animal is an adult.
-     *
-     * @return return true if the animal is an adult
-     */
-    public boolean isAdult();
-    
-    /**
-     * Return the ability to breed of the animal.
-     *
-     * @return the ability to breed of the animal
-     */
-    public boolean canBreed();
-
-    /**
-     * Set breedability of the animal, if the animal is a baby and set to
-     * breed it will instantly grow up.
-     *
-     * @param breed breedability of the animal
-     */
-    public void setBreed(boolean breed);
-}
diff --git a/src/main/java/org/bukkit/entity/Ambient.java b/src/main/java/org/bukkit/entity/Ambient.java
deleted file mode 100644
index 779e389..0000000
--- a/src/main/java/org/bukkit/entity/Ambient.java
+++ /dev/null
@@ -1,6 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * Represents an ambient mob
- */
-public interface Ambient extends LivingEntity {}
diff --git a/src/main/java/org/bukkit/entity/AnimalTamer.java b/src/main/java/org/bukkit/entity/AnimalTamer.java
deleted file mode 100644
index 5f74f0d..0000000
--- a/src/main/java/org/bukkit/entity/AnimalTamer.java
+++ /dev/null
@@ -1,20 +0,0 @@
-package org.bukkit.entity;
-
-import java.util.UUID;
-
-public interface AnimalTamer {
-
-    /**
-     * This is the name of the specified AnimalTamer.
-     *
-     * @return The name to reference on tamed animals or null if a name cannot be obtained
-     */
-    public String getName();
-
-    /**
-     * This is the UUID of the specified AnimalTamer.
-     *
-     * @return The UUID to reference on tamed animals
-     */
-    public UUID getUniqueId();
-}
diff --git a/src/main/java/org/bukkit/entity/Animals.java b/src/main/java/org/bukkit/entity/Animals.java
deleted file mode 100644
index f0dc157..0000000
--- a/src/main/java/org/bukkit/entity/Animals.java
+++ /dev/null
@@ -1,6 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * Represents an Animal.
- */
-public interface Animals extends Ageable {}
diff --git a/src/main/java/org/bukkit/entity/AreaEffectCloud.java b/src/main/java/org/bukkit/entity/AreaEffectCloud.java
deleted file mode 100644
index f88be2f..0000000
--- a/src/main/java/org/bukkit/entity/AreaEffectCloud.java
+++ /dev/null
@@ -1,225 +0,0 @@
-package org.bukkit.entity;
-
-import java.util.List;
-import org.bukkit.Color;
-import org.bukkit.Particle;
-import org.bukkit.potion.PotionData;
-import org.bukkit.potion.PotionEffect;
-import org.bukkit.potion.PotionEffectType;
-import org.bukkit.projectiles.ProjectileSource;
-
-/**
- * Represents an area effect cloud which will imbue a potion effect onto
- * entities which enter it.
- */
-public interface AreaEffectCloud extends Entity {
-
-    /**
-     * Gets the duration which this cloud will exist for (in ticks).
-     *
-     * @return cloud duration
-     */
-    int getDuration();
-
-    /**
-     * Sets the duration which this cloud will exist for (in ticks).
-     *
-     * @param duration cloud duration
-     */
-    void setDuration(int duration);
-
-    /**
-     * Gets the time which an entity has to be exposed to the cloud before the
-     * effect is applied.
-     *
-     * @return wait time
-     */
-    int getWaitTime();
-
-    /**
-     * Sets the time which an entity has to be exposed to the cloud before the
-     * effect is applied.
-     *
-     * @param waitTime wait time
-     */
-    void setWaitTime(int waitTime);
-
-    /**
-     * Gets the time that an entity will be immune from subsequent exposure.
-     *
-     * @return reapplication delay
-     */
-    int getReapplicationDelay();
-
-    /**
-     * Sets the time that an entity will be immune from subsequent exposure.
-     *
-     * @param delay reapplication delay
-     */
-    void setReapplicationDelay(int delay);
-
-    /**
-     * Gets the amount that the duration of this cloud will decrease by when it
-     * applies an effect to an entity.
-     *
-     * @return duration on use delta
-     */
-    int getDurationOnUse();
-
-    /**
-     * Sets the amount that the duration of this cloud will decrease by when it
-     * applies an effect to an entity.
-     *
-     * @param duration duration on use delta
-     */
-    void setDurationOnUse(int duration);
-
-    /**
-     * Gets the initial radius of the cloud.
-     *
-     * @return radius
-     */
-    float getRadius();
-
-    /**
-     * Sets the initial radius of the cloud.
-     *
-     * @param radius radius
-     */
-    void setRadius(float radius);
-
-    /**
-     * Gets the amount that the radius of this cloud will decrease by when it
-     * applies an effect to an entity.
-     *
-     * @return radius on use delta
-     */
-    float getRadiusOnUse();
-
-    /**
-     * Sets the amount that the radius of this cloud will decrease by when it
-     * applies an effect to an entity.
-     *
-     * @param radius radius on use delta
-     */
-    void setRadiusOnUse(float radius);
-
-    /**
-     * Gets the amount that the radius of this cloud will decrease by each tick.
-     *
-     * @return radius per tick delta
-     */
-    float getRadiusPerTick();
-
-    /**
-     * Gets the amount that the radius of this cloud will decrease by each tick.
-     *
-     * @param radius per tick delta
-     */
-    void setRadiusPerTick(float radius);
-
-    /**
-     * Gets the particle which this cloud will be composed of
-     *
-     * @return particle the set particle type
-     */
-    Particle getParticle();
-
-    /**
-     * Sets the particle which this cloud will be composed of
-     *
-     * @param particle the new particle type
-     */
-    void setParticle(Particle particle);
-
-    /**
-     * Sets the underlying potion data
-     *
-     * @param data PotionData to set the base potion state to
-     */
-    void setBasePotionData(PotionData data);
-
-    /**
-     * Returns the potion data about the base potion
-     *
-     * @return a PotionData object
-     */
-    PotionData getBasePotionData();
-
-    /**
-     * Checks for the presence of custom potion effects.
-     *
-     * @return true if custom potion effects are applied
-     */
-    boolean hasCustomEffects();
-
-    /**
-     * Gets an immutable list containing all custom potion effects applied to
-     * this cloud.
-     * <p>
-     * Plugins should check that hasCustomEffects() returns true before calling
-     * this method.
-     *
-     * @return the immutable list of custom potion effects
-     */
-    List<PotionEffect> getCustomEffects();
-
-    /**
-     * Adds a custom potion effect to this cloud.
-     *
-     * @param effect the potion effect to add
-     * @param overwrite true if any existing effect of the same type should be
-     * overwritten
-     * @return true if the effect was added as a result of this call
-     */
-    boolean addCustomEffect(PotionEffect effect, boolean overwrite);
-
-    /**
-     * Removes a custom potion effect from this cloud.
-     *
-     * @param type the potion effect type to remove
-     * @return true if the an effect was removed as a result of this call
-     */
-    boolean removeCustomEffect(PotionEffectType type);
-
-    /**
-     * Checks for a specific custom potion effect type on this cloud.
-     *
-     * @param type the potion effect type to check for
-     * @return true if the potion has this effect
-     */
-    boolean hasCustomEffect(PotionEffectType type);
-
-    /**
-     * Removes all custom potion effects from this cloud.
-     */
-    void clearCustomEffects();
-
-    /**
-     * Gets the color of this cloud. Will be applied as a tint to its particles.
-     *
-     * @return cloud color
-     */
-    Color getColor();
-
-    /**
-     * Sets the color of this cloud. Will be applied as a tint to its particles.
-     *
-     * @param color cloud color
-     */
-    void setColor(Color color);
-
-    /**
-     * Retrieve the original source of this cloud.
-     * 
-     * @return the {@link ProjectileSource} that threw the LingeringPotion
-     */
-    public ProjectileSource getSource();
-
-    /**
-     * Set the original source of this cloud.
-     *
-     * @param source the {@link ProjectileSource} that threw the LingeringPotion
-     */
-    public void setSource(ProjectileSource source);
-}
diff --git a/src/main/java/org/bukkit/entity/ArmorStand.java b/src/main/java/org/bukkit/entity/ArmorStand.java
deleted file mode 100644
index ad77d59..0000000
--- a/src/main/java/org/bukkit/entity/ArmorStand.java
+++ /dev/null
@@ -1,277 +0,0 @@
-package org.bukkit.entity;
-
-import org.bukkit.inventory.ItemStack;
-import org.bukkit.util.EulerAngle;
-
-public interface ArmorStand extends LivingEntity {
-
-    /**
-     * Returns the item the armor stand is
-     * currently holding
-     *
-     * @return the held item
-     */
-    ItemStack getItemInHand();
-
-    /**
-     * Sets the item the armor stand is currently
-     * holding
-     *
-     * @param item the item to hold
-     */
-    void setItemInHand(ItemStack item);
-
-    /**
-     * Returns the item currently being worn
-     * by the armor stand on its feet
-     *
-     * @return the worn item
-     */
-    ItemStack getBoots();
-
-    /**
-     * Sets the item currently being worn
-     * by the armor stand on its feet
-     *
-     * @param item the item to wear
-     */
-    void setBoots(ItemStack item);
-
-    /**
-     * Returns the item currently being worn
-     * by the armor stand on its legs
-     *
-     * @return the worn item
-     */
-    ItemStack getLeggings();
-
-    /**
-     * Sets the item currently being worn
-     * by the armor stand on its legs
-     *
-     * @param item the item to wear
-     */
-    void setLeggings(ItemStack item);
-
-    /**
-     * Returns the item currently being worn
-     * by the armor stand on its chest
-     *
-     * @return the worn item
-     */
-    ItemStack getChestplate();
-
-    /**
-     * Sets the item currently being worn
-     * by the armor stand on its chest
-     *
-     * @param item the item to wear
-     */
-    void setChestplate(ItemStack item);
-
-    /**
-     * Returns the item currently being worn
-     * by the armor stand on its head
-     *
-     * @return the worn item
-     */
-    ItemStack getHelmet();
-
-    /**
-     * Sets the item currently being worn
-     * by the armor stand on its head
-     *
-     * @param item the item to wear
-     */
-    void setHelmet(ItemStack item);
-
-    /**
-     * Returns the armor stand's body's
-     * current pose as a {@link org.bukkit.util.EulerAngle}
-     *
-     * @return the current pose
-     */
-    EulerAngle getBodyPose();
-
-    /**
-     * Sets the armor stand's body's
-     * current pose as a {@link org.bukkit.util.EulerAngle}
-     *
-     * @param pose the current pose
-     */
-    void setBodyPose(EulerAngle pose);
-
-    /**
-     * Returns the armor stand's left arm's
-     * current pose as a {@link org.bukkit.util.EulerAngle}
-     *
-     * @return the current pose
-     */
-    EulerAngle getLeftArmPose();
-
-    /**
-     * Sets the armor stand's left arm's
-     * current pose as a {@link org.bukkit.util.EulerAngle}
-     *
-     * @param pose the current pose
-     */
-    void setLeftArmPose(EulerAngle pose);
-
-    /**
-     * Returns the armor stand's right arm's
-     * current pose as a {@link org.bukkit.util.EulerAngle}
-     *
-     * @return the current pose
-     */
-    EulerAngle getRightArmPose();
-
-    /**
-     * Sets the armor stand's right arm's
-     * current pose as a {@link org.bukkit.util.EulerAngle}
-     *
-     * @param pose the current pose
-     */
-    void setRightArmPose(EulerAngle pose);
-
-    /**
-     * Returns the armor stand's left leg's
-     * current pose as a {@link org.bukkit.util.EulerAngle}
-     *
-     * @return the current pose
-     */
-    EulerAngle getLeftLegPose();
-
-    /**
-     * Sets the armor stand's left leg's
-     * current pose as a {@link org.bukkit.util.EulerAngle}
-     *
-     * @param pose the current pose
-     */
-    void setLeftLegPose(EulerAngle pose);
-
-    /**
-     * Returns the armor stand's right leg's
-     * current pose as a {@link org.bukkit.util.EulerAngle}
-     *
-     * @return the current pose
-     */
-    EulerAngle getRightLegPose();
-
-    /**
-     * Sets the armor stand's right leg's
-     * current pose as a {@link org.bukkit.util.EulerAngle}
-     *
-     * @param pose the current pose
-     */
-    void setRightLegPose(EulerAngle pose);
-
-    /**
-     * Returns the armor stand's head's
-     * current pose as a {@link org.bukkit.util.EulerAngle}
-     *
-     * @return the current pose
-     */
-    EulerAngle getHeadPose();
-
-    /**
-     * Sets the armor stand's head's
-     * current pose as a {@link org.bukkit.util.EulerAngle}
-     *
-     * @param pose the current pose
-     */
-    void setHeadPose(EulerAngle pose);
-
-    /**
-     * Returns whether the armor stand has
-     * a base plate
-     *
-     * @return whether it has a base plate
-     */
-    boolean hasBasePlate();
-
-    /**
-     * Sets whether the armor stand has a
-     * base plate
-     *
-     * @param basePlate whether is has a base plate
-     */
-    void setBasePlate(boolean basePlate);
-
-    /**
-     * Returns whether gravity applies to
-     * this armor stand
-     *
-     * @return whether gravity applies
-     */
-    boolean hasGravity();
-
-    /**
-     * Sets whether gravity applies to
-     * this armor stand
-     *
-     * @param gravity whether gravity should apply
-     */
-    void setGravity(boolean gravity);
-
-    /**
-     * Returns whether the armor stand should be
-     * visible or not
-     *
-     * @return whether the stand is visible or not
-     */
-    boolean isVisible();
-
-    /**
-     * Sets whether the armor stand should be
-     * visible or not
-     *
-     * @param visible whether the stand is visible or not
-     */
-    void setVisible(boolean visible);
-
-    /**
-     * Returns whether this armor stand has arms
-     *
-     * @return whether this has arms or not
-     */
-    boolean hasArms();
-
-    /**
-     * Sets whether this armor stand has arms
-     *
-     * @param arms whether this has arms or not
-     */
-    void setArms(boolean arms);
-
-    /**
-     * Returns whether this armor stand is scaled
-     * down
-     *
-     * @return whether this is scaled down
-     */
-    boolean isSmall();
-
-    /**
-     * Sets whether this armor stand is scaled
-     * down
-     *
-     * @param small whether this is scaled down
-     */
-    void setSmall(boolean small);
-
-    /**
-     * Returns whether this armor stand is a marker,
-     * meaning it has a very small collision box
-     *
-     * @return whether this is a marker
-     */
-    boolean isMarker();
-
-    /**
-     * Sets whether this armor stand is a marker,
-     * meaning it has a very small collision box
-     *
-     * @param marker whether this is a marker
-     */
-    void setMarker(boolean marker);
-}
diff --git a/src/main/java/org/bukkit/entity/Arrow.java b/src/main/java/org/bukkit/entity/Arrow.java
deleted file mode 100644
index e49eef0..0000000
--- a/src/main/java/org/bukkit/entity/Arrow.java
+++ /dev/null
@@ -1,42 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * Represents an arrow.
- */
-public interface Arrow extends Projectile {
-
-    /**
-     * Gets the knockback strength for an arrow, which is the
-     * {@link org.bukkit.enchantments.Enchantment#KNOCKBACK KnockBack} level
-     * of the bow that shot it.
-     *
-     * @return the knockback strength value
-     */
-    public int getKnockbackStrength();
-
-    /**
-     * Sets the knockback strength for an arrow.
-     *
-     * @param knockbackStrength the knockback strength value
-     */
-    public void setKnockbackStrength(int knockbackStrength);
-
-    /**
-     * Gets whether this arrow is critical.
-     * <p>
-     * Critical arrows have increased damage and cause particle effects.
-     * <p>
-     * Critical arrows generally occur when a player fully draws a bow before
-     * firing.
-     *
-     * @return true if it is critical
-     */
-    public boolean isCritical();
-
-    /**
-     * Sets whether or not this arrow should be critical.
-     *
-     * @param critical whether or not it should be critical
-     */
-    public void setCritical(boolean critical);
-}
diff --git a/src/main/java/org/bukkit/entity/Bat.java b/src/main/java/org/bukkit/entity/Bat.java
deleted file mode 100644
index bd73f22..0000000
--- a/src/main/java/org/bukkit/entity/Bat.java
+++ /dev/null
@@ -1,27 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * Represents a Bat
- */
-public interface Bat extends Ambient {
-
-    /**
-     * Checks the current waking state of this bat.
-     * <p>
-     * This does not imply any persistence of state past the method call.
-     *
-     * @return true if the bat is awake or false if it is currently hanging
-     *     from a block
-     */
-    boolean isAwake();
-
-    /**
-     * This method modifies the current waking state of this bat.
-     * <p>
-     * This does not prevent a bat from spontaneously awaking itself, or from
-     * reattaching itself to a block.
-     *
-     * @param state the new state
-     */
-    void setAwake(boolean state);
-}
diff --git a/src/main/java/org/bukkit/entity/Blaze.java b/src/main/java/org/bukkit/entity/Blaze.java
deleted file mode 100644
index 7a5505b..0000000
--- a/src/main/java/org/bukkit/entity/Blaze.java
+++ /dev/null
@@ -1,8 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * Represents a Blaze monster
- */
-public interface Blaze extends Monster {
-
-}
diff --git a/src/main/java/org/bukkit/entity/Boat.java b/src/main/java/org/bukkit/entity/Boat.java
deleted file mode 100644
index db02115..0000000
--- a/src/main/java/org/bukkit/entity/Boat.java
+++ /dev/null
@@ -1,104 +0,0 @@
-package org.bukkit.entity;
-
-import org.bukkit.TreeSpecies;
-
-/**
- * Represents a boat entity.
- */
-public interface Boat extends Vehicle {
-
-    /**
-     * Gets the wood type of the boat.
-     * 
-     * @return the wood type
-     */
-    TreeSpecies getWoodType();
-
-    /**
-     * Sets the wood type of the boat.
-     * 
-     * @param species the new wood type
-     */
-    void setWoodType(TreeSpecies species);
-
-    /**
-     * Gets the maximum speed of a boat. The speed is unrelated to the
-     * velocity.
-     *
-     * @return The max speed.
-     * @deprecated boats are complex and many of these methods do not work correctly across multiple versions.
-     */
-    @Deprecated
-    public double getMaxSpeed();
-
-    /**
-     * Sets the maximum speed of a boat. Must be nonnegative. Default is 0.4D.
-     *
-     * @param speed The max speed.
-     * @deprecated boats are complex and many of these methods do not work correctly across multiple versions.
-     */
-    @Deprecated
-    public void setMaxSpeed(double speed);
-
-    /**
-     * Gets the deceleration rate (newSpeed = curSpeed * rate) of occupied
-     * boats. The default is 0.2.
-     *
-     * @return The rate of deceleration
-     * @deprecated boats are complex and many of these methods do not work correctly across multiple versions.
-     */
-    @Deprecated
-    public double getOccupiedDeceleration();
-
-    /**
-     * Sets the deceleration rate (newSpeed = curSpeed * rate) of occupied
-     * boats. Setting this to a higher value allows for quicker acceleration.
-     * The default is 0.2.
-     *
-     * @param rate deceleration rate
-     * @deprecated boats are complex and many of these methods do not work correctly across multiple versions.
-     */
-    @Deprecated
-    public void setOccupiedDeceleration(double rate);
-
-    /**
-     * Gets the deceleration rate (newSpeed = curSpeed * rate) of unoccupied
-     * boats. The default is -1. Values below 0 indicate that no additional
-     * deceleration is imposed.
-     *
-     * @return The rate of deceleration
-     * @deprecated boats are complex and many of these methods do not work correctly across multiple versions.
-     */
-    @Deprecated
-    public double getUnoccupiedDeceleration();
-
-    /**
-     * Sets the deceleration rate (newSpeed = curSpeed * rate) of unoccupied
-     * boats. Setting this to a higher value allows for quicker deceleration
-     * of boats when a player disembarks. The default is -1. Values below 0
-     * indicate that no additional deceleration is imposed.
-     *
-     * @param rate deceleration rate
-     * @deprecated boats are complex and many of these methods do not work correctly across multiple versions.
-     */
-    @Deprecated
-    public void setUnoccupiedDeceleration(double rate);
-
-    /**
-     * Get whether boats can work on land.
-     *
-     * @return whether boats can work on land
-     * @deprecated boats are complex and many of these methods do not work correctly across multiple versions.
-     */
-    @Deprecated
-    public boolean getWorkOnLand();
-
-    /**
-     * Set whether boats can work on land.
-     *
-     * @param workOnLand whether boats can work on land
-     * @deprecated boats are complex and many of these methods do not work correctly across multiple versions.
-     */
-    @Deprecated
-    public void setWorkOnLand(boolean workOnLand);
-}
diff --git a/src/main/java/org/bukkit/entity/CaveSpider.java b/src/main/java/org/bukkit/entity/CaveSpider.java
deleted file mode 100644
index 9c37646..0000000
--- a/src/main/java/org/bukkit/entity/CaveSpider.java
+++ /dev/null
@@ -1,6 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * Represents a Spider.
- */
-public interface CaveSpider extends Spider {}
diff --git a/src/main/java/org/bukkit/entity/Chicken.java b/src/main/java/org/bukkit/entity/Chicken.java
deleted file mode 100644
index cb3ec6e..0000000
--- a/src/main/java/org/bukkit/entity/Chicken.java
+++ /dev/null
@@ -1,6 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * Represents a Chicken.
- */
-public interface Chicken extends Animals {}
diff --git a/src/main/java/org/bukkit/entity/ComplexEntityPart.java b/src/main/java/org/bukkit/entity/ComplexEntityPart.java
deleted file mode 100644
index f4ab0bb..0000000
--- a/src/main/java/org/bukkit/entity/ComplexEntityPart.java
+++ /dev/null
@@ -1,14 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * Represents a single part of a {@link ComplexLivingEntity}
- */
-public interface ComplexEntityPart extends Entity {
-
-    /**
-     * Gets the parent {@link ComplexLivingEntity} of this part.
-     *
-     * @return Parent complex entity
-     */
-    public ComplexLivingEntity getParent();
-}
diff --git a/src/main/java/org/bukkit/entity/ComplexLivingEntity.java b/src/main/java/org/bukkit/entity/ComplexLivingEntity.java
deleted file mode 100644
index f74411c..0000000
--- a/src/main/java/org/bukkit/entity/ComplexLivingEntity.java
+++ /dev/null
@@ -1,16 +0,0 @@
-package org.bukkit.entity;
-
-import java.util.Set;
-
-/**
- * Represents a complex living entity - one that is made up of various smaller
- * parts
- */
-public interface ComplexLivingEntity extends LivingEntity {
-    /**
-     * Gets a list of parts that belong to this complex entity
-     *
-     * @return List of parts
-     */
-    public Set<ComplexEntityPart> getParts();
-}
diff --git a/src/main/java/org/bukkit/entity/Cow.java b/src/main/java/org/bukkit/entity/Cow.java
deleted file mode 100644
index cd4ed4d..0000000
--- a/src/main/java/org/bukkit/entity/Cow.java
+++ /dev/null
@@ -1,6 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * Represents a Cow.
- */
-public interface Cow extends Animals {}
diff --git a/src/main/java/org/bukkit/entity/Creature.java b/src/main/java/org/bukkit/entity/Creature.java
deleted file mode 100644
index f223f55..0000000
--- a/src/main/java/org/bukkit/entity/Creature.java
+++ /dev/null
@@ -1,26 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * Represents a Creature. Creatures are non-intelligent monsters or animals
- * which have very simple abilities.
- */
-public interface Creature extends LivingEntity {
-
-    /**
-     * Instructs this Creature to set the specified LivingEntity as its
-     * target.
-     * <p>
-     * Hostile creatures may attack their target, and friendly creatures may
-     * follow their target.
-     *
-     * @param target New LivingEntity to target, or null to clear the target
-     */
-    public void setTarget(LivingEntity target);
-
-    /**
-     * Gets the current target of this Creature
-     *
-     * @return Current target of this creature, or null if none exists
-     */
-    public LivingEntity getTarget();
-}
diff --git a/src/main/java/org/bukkit/entity/Creeper.java b/src/main/java/org/bukkit/entity/Creeper.java
deleted file mode 100644
index a2f7809..0000000
--- a/src/main/java/org/bukkit/entity/Creeper.java
+++ /dev/null
@@ -1,21 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * Represents a Creeper
- */
-public interface Creeper extends Monster {
-
-    /**
-     * Checks if this Creeper is powered (Electrocuted)
-     *
-     * @return true if this creeper is powered
-     */
-    public boolean isPowered();
-
-    /**
-     * Sets the Powered status of this Creeper
-     *
-     * @param value New Powered status
-     */
-    public void setPowered(boolean value);
-}
diff --git a/src/main/java/org/bukkit/entity/Damageable.java b/src/main/java/org/bukkit/entity/Damageable.java
deleted file mode 100644
index d0599cf..0000000
--- a/src/main/java/org/bukkit/entity/Damageable.java
+++ /dev/null
@@ -1,127 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * Represents an {@link Entity} that has health and can take damage.
- */
-public interface Damageable extends Entity {
-    /**
-     * Deals the given amount of damage to this entity.
-     *
-     * @param amount Amount of damage to deal
-     */
-    void damage(double amount);
-
-    /**
-     * This method exists for legacy reasons to provide backwards
-     * compatibility. It will not exist at runtime and should not be used
-     * under any circumstances.
-     * 
-     * @param amount Amount of damage to deal
-     */
-    @Deprecated
-    void _INVALID_damage(int amount);
-
-    /**
-     * Deals the given amount of damage to this entity, from a specified
-     * entity.
-     *
-     * @param amount Amount of damage to deal
-     * @param source Entity which to attribute this damage from
-     */
-    void damage(double amount, Entity source);
-
-    /**
-     * This method exists for legacy reasons to provide backwards
-     * compatibility. It will not exist at runtime and should not be used
-     * under any circumstances.
-     *
-     * @param amount Amount of damage to deal
-     * @param source Entity which to attribute this damage from
-     */
-    @Deprecated
-    void _INVALID_damage(int amount, Entity source);
-
-    /**
-     * Gets the entity's health from 0 to {@link #getMaxHealth()}, where 0 is dead.
-     *
-     * @return Health represented from 0 to max
-     */
-    double getHealth();
-
-    /**
-     * This method exists for legacy reasons to provide backwards
-     * compatibility. It will not exist at runtime and should not be used
-     * under any circumstances.
-     * 
-     * @return Health represented from 0 to max
-     */
-    @Deprecated
-    int _INVALID_getHealth();
-
-    /**
-     * Sets the entity's health from 0 to {@link #getMaxHealth()}, where 0 is
-     * dead.
-     *
-     * @param health New health represented from 0 to max
-     * @throws IllegalArgumentException Thrown if the health is {@literal < 0 or >}
-     *     {@link #getMaxHealth()}
-     */
-    void setHealth(double health);
-
-    /**
-     * This method exists for legacy reasons to provide backwards
-     * compatibility. It will not exist at runtime and should not be used
-     * under any circumstances.
-     *
-     * @param health New health represented from 0 to max
-     * @throws IllegalArgumentException Thrown if the health is {@literal < 0 or >}
-     *     {@link #getMaxHealth()}
-     */
-    @Deprecated
-    void _INVALID_setHealth(int health);
-
-    /**
-     * Gets the maximum health this entity has.
-     *
-     * @return Maximum health
-     */
-    double getMaxHealth();
-
-    /**
-     * This method exists for legacy reasons to provide backwards
-     * compatibility. It will not exist at runtime and should not be used
-     * under any circumstances.
-     * 
-     * @return Maximum health
-     */
-    @Deprecated
-    int _INVALID_getMaxHealth();
-
-    /**
-     * Sets the maximum health this entity can have.
-     * <p>
-     * If the health of the entity is above the value provided it will be set
-     * to that value.
-     * <p>
-     * Note: An entity with a health bar ({@link Player}, {@link EnderDragon},
-     * {@link Wither}, etc...} will have their bar scaled accordingly.
-     *
-     * @param health amount of health to set the maximum to
-     */
-    void setMaxHealth(double health);
-
-    /**
-     * This method exists for legacy reasons to provide backwards
-     * compatibility. It will not exist at runtime and should not be used
-     * under any circumstances.
-     *
-     * @param health amount of health to set the maximum to
-     */
-    @Deprecated
-    void _INVALID_setMaxHealth(int health);
-
-    /**
-     * Resets the max health to the original amount.
-     */
-    void resetMaxHealth();
-}
diff --git a/src/main/java/org/bukkit/entity/DragonFireball.java b/src/main/java/org/bukkit/entity/DragonFireball.java
deleted file mode 100644
index 6c475a3..0000000
--- a/src/main/java/org/bukkit/entity/DragonFireball.java
+++ /dev/null
@@ -1,3 +0,0 @@
-package org.bukkit.entity;
-
-public interface DragonFireball extends Fireball {}
diff --git a/src/main/java/org/bukkit/entity/Egg.java b/src/main/java/org/bukkit/entity/Egg.java
deleted file mode 100644
index 2dcc00b..0000000
--- a/src/main/java/org/bukkit/entity/Egg.java
+++ /dev/null
@@ -1,6 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * Represents a thrown egg.
- */
-public interface Egg extends Projectile {}
diff --git a/src/main/java/org/bukkit/entity/EnderCrystal.java b/src/main/java/org/bukkit/entity/EnderCrystal.java
deleted file mode 100644
index 684dd76..0000000
--- a/src/main/java/org/bukkit/entity/EnderCrystal.java
+++ /dev/null
@@ -1,41 +0,0 @@
-package org.bukkit.entity;
-
-import org.bukkit.Location;
-
-/**
- * A crystal that heals nearby EnderDragons
- */
-public interface EnderCrystal extends Entity {
-
-    /**
-     * Return whether or not this end crystal is showing the
-     * bedrock slate underneath it.
-     *
-     * @return true if the bottom is being shown
-     */
-    boolean isShowingBottom();
-
-    /**
-     * Sets whether or not this end crystal is showing the
-     * bedrock slate underneath it.
-     *
-     * @param showing whether the bedrock slate should be shown
-     */
-    void setShowingBottom(boolean showing);
-
-    /**
-     * Gets the location that this end crystal is pointing its beam to.
-     *
-     * @return the location that the beam is pointed to, or null if the beam is not shown
-     */
-    Location getBeamTarget();
-
-    /**
-     * Sets the location that this end crystal is pointing to. Passing a null
-     * value will remove the current beam.
-     *
-     * @param location the location to point the beam to
-     * @throws IllegalArgumentException for differing worlds
-     */
-    void setBeamTarget(Location location);
-}
diff --git a/src/main/java/org/bukkit/entity/EnderDragon.java b/src/main/java/org/bukkit/entity/EnderDragon.java
deleted file mode 100644
index 9b4b24e..0000000
--- a/src/main/java/org/bukkit/entity/EnderDragon.java
+++ /dev/null
@@ -1,78 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * Represents an Ender Dragon
- */
-public interface EnderDragon extends ComplexLivingEntity {
-
-    /**
-     * Represents a phase or action that an Ender Dragon can perform.
-     */
-    enum Phase {
-        /**
-         * The dragon will circle outside the ring of pillars if ender
-         * crystals remain or inside the ring if not.
-         */
-        CIRCLING,
-        /**
-         * The dragon will fly towards a targetted player and shoot a
-         * fireball when within 64 blocks.
-         */
-        STRAFING,
-        /**
-         * The dragon will fly towards the empty portal (approaching
-         * from the other side, if applicable).
-         */
-        FLY_TO_PORTAL,
-        /**
-         * The dragon will land on on the portal. If the dragon is not near
-         * the portal, it will fly to it before mounting.
-         */
-        LAND_ON_PORTAL,
-        /**
-         * The dragon will leave the portal.
-         */
-        LEAVE_PORTAL,
-        /**
-         * The dragon will attack with dragon breath at its current location.
-         */
-        BREATH_ATTACK,
-        /**
-         * The dragon will search for a player to attack with dragon breath.
-         * If no player is close enough to the dragon for 5 seconds, the 
-         * dragon will charge at a player within 150 blocks or will take off 
-         * and begin circling if no player is found.
-         */
-        SEARCH_FOR_BREATH_ATTACK_TARGET,
-        /**
-         * The dragon will roar before performing a breath attack.
-         */
-        ROAR_BEFORE_ATTACK,
-        /**
-         * The dragon will charge a player.
-         */
-        CHARGE_PLAYER,
-        /**
-         * The dragon will fly to the vicinity of the portal and die.
-         */
-        DYING,
-        /**
-         * The dragon will hover at its current location, not performing any actions.
-         */
-        HOVER
-    }
-
-    /**
-     * Gets the current phase that the dragon is performing.
-     *
-     * @return the current phase
-     */
-    Phase getPhase();
-
-    /**
-     * Sets the next phase for the dragon to perform.
-     *
-     * @param phase the next phase
-     */
-    void setPhase(Phase phase);
-}
diff --git a/src/main/java/org/bukkit/entity/EnderDragonPart.java b/src/main/java/org/bukkit/entity/EnderDragonPart.java
deleted file mode 100644
index 9516f56..0000000
--- a/src/main/java/org/bukkit/entity/EnderDragonPart.java
+++ /dev/null
@@ -1,8 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * Represents an ender dragon part
- */
-public interface EnderDragonPart extends ComplexEntityPart, Damageable {
-    public EnderDragon getParent();
-}
diff --git a/src/main/java/org/bukkit/entity/EnderPearl.java b/src/main/java/org/bukkit/entity/EnderPearl.java
deleted file mode 100644
index db18a90..0000000
--- a/src/main/java/org/bukkit/entity/EnderPearl.java
+++ /dev/null
@@ -1,8 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * Represents a thrown Ender Pearl entity
- */
-public interface EnderPearl extends Projectile {
-
-}
diff --git a/src/main/java/org/bukkit/entity/EnderSignal.java b/src/main/java/org/bukkit/entity/EnderSignal.java
deleted file mode 100644
index 3d2d76c..0000000
--- a/src/main/java/org/bukkit/entity/EnderSignal.java
+++ /dev/null
@@ -1,9 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * Represents an Ender Signal, which is often created upon throwing an ender
- * eye
- */
-public interface EnderSignal extends Entity {
-
-}
diff --git a/src/main/java/org/bukkit/entity/Enderman.java b/src/main/java/org/bukkit/entity/Enderman.java
deleted file mode 100644
index 0b66a92..0000000
--- a/src/main/java/org/bukkit/entity/Enderman.java
+++ /dev/null
@@ -1,23 +0,0 @@
-package org.bukkit.entity;
-
-import org.bukkit.material.MaterialData;
-
-/**
- * Represents an Enderman.
- */
-public interface Enderman extends Monster {
-
-    /**
-     * Get the id and data of the block that the Enderman is carrying.
-     *
-     * @return MaterialData containing the id and data of the block
-     */
-    public MaterialData getCarriedMaterial();
-
-    /**
-     * Set the id and data of the block that the Enderman is carring.
-     *
-     * @param material data to set the carried block to
-     */
-    public void setCarriedMaterial(MaterialData material);
-}
diff --git a/src/main/java/org/bukkit/entity/Endermite.java b/src/main/java/org/bukkit/entity/Endermite.java
deleted file mode 100644
index dc1fa54..0000000
--- a/src/main/java/org/bukkit/entity/Endermite.java
+++ /dev/null
@@ -1,4 +0,0 @@
-package org.bukkit.entity;
-
-public interface Endermite extends Monster {
-}
diff --git a/src/main/java/org/bukkit/entity/Entity.java b/src/main/java/org/bukkit/entity/Entity.java
deleted file mode 100644
index 2c10ce6..0000000
--- a/src/main/java/org/bukkit/entity/Entity.java
+++ /dev/null
@@ -1,392 +0,0 @@
-package org.bukkit.entity;
-
-import org.bukkit.Location;
-import org.bukkit.EntityEffect;
-import org.bukkit.Server;
-import org.bukkit.World;
-import org.bukkit.event.entity.EntityDamageEvent;
-import org.bukkit.metadata.Metadatable;
-import org.bukkit.util.Vector;
-
-import java.util.List;
-import java.util.UUID;
-import org.bukkit.command.CommandSender;
-import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;
-
-/**
- * Represents a base entity in the world
- */
-public interface Entity extends Metadatable, CommandSender {
-
-    /**
-     * Gets the entity's current position
-     *
-     * @return a new copy of Location containing the position of this entity
-     */
-    public Location getLocation();
-
-    /**
-     * Stores the entity's current position in the provided Location object.
-     * <p>
-     * If the provided Location is null this method does nothing and returns
-     * null.
-     *
-     * @param loc the location to copy into
-     * @return The Location object provided or null
-     */
-    public Location getLocation(Location loc);
-
-    /**
-     * Sets this entity's velocity
-     *
-     * @param velocity New velocity to travel with
-     */
-    public void setVelocity(Vector velocity);
-
-    /**
-     * Gets this entity's current velocity
-     *
-     * @return Current travelling velocity of this entity
-     */
-    public Vector getVelocity();
-
-    /**
-     * Returns true if the entity is supported by a block. This value is a
-     * state updated by the server and is not recalculated unless the entity
-     * moves.
-     *
-     * @return True if entity is on ground.
-     */
-    public boolean isOnGround();
-
-    /**
-     * Gets the current world this entity resides in
-     *
-     * @return World
-     */
-    public World getWorld();
-
-    /**
-     * Teleports this entity to the given location. If this entity is riding a
-     * vehicle, it will be dismounted prior to teleportation.
-     *
-     * @param location New location to teleport this entity to
-     * @return <code>true</code> if the teleport was successful
-     */
-    public boolean teleport(Location location);
-
-    /**
-     * Teleports this entity to the given location. If this entity is riding a
-     * vehicle, it will be dismounted prior to teleportation.
-     *
-     * @param location New location to teleport this entity to
-     * @param cause The cause of this teleportation
-     * @return <code>true</code> if the teleport was successful
-     */
-    public boolean teleport(Location location, TeleportCause cause);
-
-    /**
-     * Teleports this entity to the target Entity. If this entity is riding a
-     * vehicle, it will be dismounted prior to teleportation.
-     *
-     * @param destination Entity to teleport this entity to
-     * @return <code>true</code> if the teleport was successful
-     */
-    public boolean teleport(Entity destination);
-
-    /**
-     * Teleports this entity to the target Entity. If this entity is riding a
-     * vehicle, it will be dismounted prior to teleportation.
-     *
-     * @param destination Entity to teleport this entity to
-     * @param cause The cause of this teleportation
-     * @return <code>true</code> if the teleport was successful
-     */
-    public boolean teleport(Entity destination, TeleportCause cause);
-
-    /**
-     * Returns a list of entities within a bounding box centered around this
-     * entity
-     *
-     * @param x 1/2 the size of the box along x axis
-     * @param y 1/2 the size of the box along y axis
-     * @param z 1/2 the size of the box along z axis
-     * @return {@code List<Entity>} List of entities nearby
-     */
-    public List<org.bukkit.entity.Entity> getNearbyEntities(double x, double y, double z);
-
-    /**
-     * Returns a unique id for this entity
-     *
-     * @return Entity id
-     */
-    public int getEntityId();
-
-    /**
-     * Returns the entity's current fire ticks (ticks before the entity stops
-     * being on fire).
-     *
-     * @return int fireTicks
-     */
-    public int getFireTicks();
-
-    /**
-     * Returns the entity's maximum fire ticks.
-     *
-     * @return int maxFireTicks
-     */
-    public int getMaxFireTicks();
-
-    /**
-     * Sets the entity's current fire ticks (ticks before the entity stops
-     * being on fire).
-     *
-     * @param ticks Current ticks remaining
-     */
-    public void setFireTicks(int ticks);
-
-    /**
-     * Mark the entity's removal.
-     */
-    public void remove();
-
-    /**
-     * Returns true if this entity has been marked for removal.
-     *
-     * @return True if it is dead.
-     */
-    public boolean isDead();
-
-    /**
-     * Returns false if the entity has died or been despawned for some other
-     * reason.
-     *
-     * @return True if valid.
-     */
-    public boolean isValid();
-
-    /**
-     * Gets the {@link Server} that contains this Entity
-     *
-     * @return Server instance running this Entity
-     */
-    public Server getServer();
-
-    /**
-     * Gets the primary passenger of a vehicle. For vehicles that could have
-     * multiple passengers, this will only return the primary passenger.
-     *
-     * @return an entity
-     */
-    public abstract Entity getPassenger();
-
-    /**
-     * Set the passenger of a vehicle.
-     *
-     * @param passenger The new passenger.
-     * @return false if it could not be done for whatever reason
-     */
-    public abstract boolean setPassenger(Entity passenger);
-
-    /**
-     * Check if a vehicle has passengers.
-     *
-     * @return True if the vehicle has no passengers.
-     */
-    public abstract boolean isEmpty();
-
-    /**
-     * Eject any passenger.
-     *
-     * @return True if there was a passenger.
-     */
-    public abstract boolean eject();
-
-    /**
-     * Returns the distance this entity has fallen
-     *
-     * @return The distance.
-     */
-    public float getFallDistance();
-
-    /**
-     * Sets the fall distance for this entity
-     *
-     * @param distance The new distance.
-     */
-    public void setFallDistance(float distance);
-
-    /**
-     * Record the last {@link EntityDamageEvent} inflicted on this entity
-     *
-     * @param event a {@link EntityDamageEvent}
-     */
-    public void setLastDamageCause(EntityDamageEvent event);
-
-    /**
-     * Retrieve the last {@link EntityDamageEvent} inflicted on this entity.
-     * This event may have been cancelled.
-     *
-     * @return the last known {@link EntityDamageEvent} or null if hitherto
-     *     unharmed
-     */
-    public EntityDamageEvent getLastDamageCause();
-
-    /**
-     * Returns a unique and persistent id for this entity
-     *
-     * @return unique id
-     */
-    public UUID getUniqueId();
-
-    /**
-     * Gets the amount of ticks this entity has lived for.
-     * <p>
-     * This is the equivalent to "age" in entities.
-     *
-     * @return Age of entity
-     */
-    public int getTicksLived();
-
-    /**
-     * Sets the amount of ticks this entity has lived for.
-     * <p>
-     * This is the equivalent to "age" in entities. May not be less than one
-     * tick.
-     *
-     * @param value Age of entity
-     */
-    public void setTicksLived(int value);
-
-    /**
-     * Performs the specified {@link EntityEffect} for this entity.
-     * <p>
-     * This will be viewable to all players near the entity.
-     *
-     * @param type Effect to play.
-     */
-    public void playEffect(EntityEffect type);
-
-    /**
-     * Get the type of the entity.
-     *
-     * @return The entity type.
-     */
-    public EntityType getType();
-
-    /**
-     * Returns whether this entity is inside a vehicle.
-     *
-     * @return True if the entity is in a vehicle.
-     */
-    public boolean isInsideVehicle();
-
-    /**
-     * Leave the current vehicle. If the entity is currently in a vehicle (and
-     * is removed from it), true will be returned, otherwise false will be
-     * returned.
-     *
-     * @return True if the entity was in a vehicle.
-     */
-    public boolean leaveVehicle();
-
-    /**
-     * Get the vehicle that this player is inside. If there is no vehicle,
-     * null will be returned.
-     *
-     * @return The current vehicle.
-     */
-    public Entity getVehicle();
-
-    /**
-     * Sets a custom name on a mob. This name will be used in death messages
-     * and can be sent to the client as a nameplate over the mob.
-     * <p>
-     * Setting the name to null or an empty string will clear it.
-     * <p>
-     * This value has no effect on players, they will always use their real
-     * name.
-     *
-     * @param name the name to set
-     */
-    public void setCustomName(String name);
-
-    /**
-     * Gets the custom name on a mob. If there is no name this method will
-     * return null.
-     * <p>
-     * This value has no effect on players, they will always use their real
-     * name.
-     *
-     * @return name of the mob or null
-     */
-    public String getCustomName();
-
-    /**
-     * Sets whether or not to display the mob's custom name client side. The
-     * name will be displayed above the mob similarly to a player.
-     * <p>
-     * This value has no effect on players, they will always display their
-     * name.
-     *
-     * @param flag custom name or not
-     */
-    public void setCustomNameVisible(boolean flag);
-
-    /**
-     * Gets whether or not the mob's custom name is displayed client side.
-     * <p>
-     * This value has no effect on players, they will always display their
-     * name.
-     *
-     * @return if the custom name is displayed
-     */
-    public boolean isCustomNameVisible();
-
-    /**
-     * Sets whether the entity has a team colored (default: white) glow.
-     *
-     * @param flag if the entity is glowing
-     */
-    void setGlowing(boolean flag);
-
-    /**
-     * Gets whether the entity is glowing or not.
-     *
-     * @return whether the entity is glowing
-     */
-    boolean isGlowing();
-
-    /**
-     * Sets whether the entity is invulnerable or not.
-     * <p>
-     * When an entity is invulnerable it can only be damaged by players in
-     * creative mode.
-     *
-     * @param flag if the entity is invulnerable
-     */
-    public void setInvulnerable(boolean flag);
-
-    /**
-     * Gets whether the entity is invulnerable or not.
-     *
-     * @return whether the entity is
-     */
-    public boolean isInvulnerable();
-
-    /**
-     * Gets whether the entity is silent or not.
-     *
-     * @return whether the entity is silent.
-     */
-    public boolean isSilent();
-
-    /**
-     * Sets whether the entity is silent or not.
-     * <p>
-     * When an entity is silent it will not produce any sound.
-     *
-     * @param flag if the entity is silent
-     */
-    public void setSilent(boolean flag);
-}
diff --git a/src/main/java/org/bukkit/entity/EntityType.java b/src/main/java/org/bukkit/entity/EntityType.java
deleted file mode 100644
index c4c4ac8..0000000
--- a/src/main/java/org/bukkit/entity/EntityType.java
+++ /dev/null
@@ -1,306 +0,0 @@
-package org.bukkit.entity;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import org.bukkit.entity.minecart.CommandMinecart;
-import org.bukkit.entity.minecart.HopperMinecart;
-import org.bukkit.entity.minecart.SpawnerMinecart;
-import org.bukkit.entity.minecart.RideableMinecart;
-import org.bukkit.entity.minecart.ExplosiveMinecart;
-import org.bukkit.entity.minecart.PoweredMinecart;
-import org.bukkit.entity.minecart.StorageMinecart;
-import org.bukkit.inventory.ItemStack;
-import org.bukkit.Location;
-import org.bukkit.World;
-import org.bukkit.potion.PotionEffectType;
-
-public enum EntityType {
-
-    // These strings MUST match the strings in nms.EntityTypes and are case sensitive.
-    /**
-     * An item resting on the ground.
-     * <p>
-     * Spawn with {@link World#dropItem(Location, ItemStack)} or {@link
-     * World#dropItemNaturally(Location, ItemStack)}
-     */
-    DROPPED_ITEM("Item", Item.class, 1, false),
-    /**
-     * An experience orb.
-     */
-    EXPERIENCE_ORB("XPOrb", ExperienceOrb.class, 2),
-    /**
-     * A leash attached to a fencepost.
-     */
-    LEASH_HITCH("LeashKnot", LeashHitch.class, 8),
-    /**
-     * A painting on a wall.
-     */
-    PAINTING("Painting", Painting.class, 9),
-    /**
-     * An arrow projectile; may get stuck in the ground.
-     */
-    ARROW("Arrow", Arrow.class, 10),
-    /**
-     * A flying snowball.
-     */
-    SNOWBALL("Snowball", Snowball.class, 11),
-    /**
-     * A flying large fireball, as thrown by a Ghast for example.
-     */
-    FIREBALL("Fireball", LargeFireball.class, 12),
-    /**
-     * A flying small fireball, such as thrown by a Blaze or player.
-     */
-    SMALL_FIREBALL("SmallFireball", SmallFireball.class, 13),
-    /**
-     * A flying ender pearl.
-     */
-    ENDER_PEARL("ThrownEnderpearl", EnderPearl.class, 14),
-    /**
-     * An ender eye signal.
-     */
-    ENDER_SIGNAL("EyeOfEnderSignal", EnderSignal.class, 15),
-    /**
-     * A flying experience bottle.
-     */
-    THROWN_EXP_BOTTLE("ThrownExpBottle", ThrownExpBottle.class, 17),
-    /**
-     * An item frame on a wall.
-     */
-    ITEM_FRAME("ItemFrame", ItemFrame.class, 18),
-    /**
-     * A flying wither skull projectile.
-     */
-    WITHER_SKULL("WitherSkull", WitherSkull.class, 19),
-    /**
-     * Primed TNT that is about to explode.
-     */
-    PRIMED_TNT("PrimedTnt", TNTPrimed.class, 20),
-    /**
-     * A block that is going to or is about to fall.
-     */
-    FALLING_BLOCK("FallingSand", FallingBlock.class, 21, false),
-    /**
-     * Internal representation of a Firework once it has been launched.
-     */
-    FIREWORK("FireworksRocketEntity", Firework.class, 22, false),
-    /**
-     * Like {@link #ARROW} but tipped with a specific potion which is applied on contact.
-     */
-    TIPPED_ARROW("TippedArrow", TippedArrow.class, 23),
-    /**
-     * Like {@link #TIPPED_ARROW} but causes the {@link PotionEffectType#GLOWING} effect on all team members.
-     */
-    SPECTRAL_ARROW("SpectralArrow", SpectralArrow.class, 24),
-    /**
-     * Bullet fired by {@link #SHULKER}.
-     */
-    SHULKER_BULLET("ShulkerBullet", ShulkerBullet.class, 25),
-    /**
-     * Like {@link #FIREBALL} but with added effects.
-     */
-    DRAGON_FIREBALL("DragonFireball", DragonFireball.class, 26),
-    /**
-     * Mechanical entity with an inventory for placing weapons / armor into.
-     */
-    ARMOR_STAND("ArmorStand", ArmorStand.class, 30),
-    /**
-     * @see CommandMinecart
-     */
-    MINECART_COMMAND("MinecartCommandBlock", CommandMinecart.class, 40),
-    /**
-     * A placed boat.
-     */
-    BOAT("Boat", Boat.class, 41),
-    /**
-     * @see RideableMinecart
-     */
-    MINECART("MinecartRideable", RideableMinecart.class, 42),
-    /**
-     * @see StorageMinecart
-     */
-    MINECART_CHEST("MinecartChest", StorageMinecart.class, 43),
-    /**
-     * @see PoweredMinecart
-     */
-    MINECART_FURNACE("MinecartFurnace", PoweredMinecart.class, 44),
-    /**
-     * @see ExplosiveMinecart
-     */
-    MINECART_TNT("MinecartTNT", ExplosiveMinecart.class, 45),
-    /**
-     * @see HopperMinecart
-     */
-    MINECART_HOPPER("MinecartHopper", HopperMinecart.class, 46),
-    /**
-     * @see SpawnerMinecart
-     */
-    MINECART_MOB_SPAWNER("MinecartMobSpawner", SpawnerMinecart.class, 47),
-    CREEPER("Creeper", Creeper.class, 50),
-    SKELETON("Skeleton", Skeleton.class, 51),
-    SPIDER("Spider", Spider.class, 52),
-    GIANT("Giant", Giant.class, 53),
-    ZOMBIE("Zombie", Zombie.class, 54),
-    SLIME("Slime", Slime.class, 55),
-    GHAST("Ghast", Ghast.class, 56),
-    PIG_ZOMBIE("PigZombie", PigZombie.class, 57),
-    ENDERMAN("Enderman", Enderman.class, 58),
-    CAVE_SPIDER("CaveSpider", CaveSpider.class, 59),
-    SILVERFISH("Silverfish", Silverfish.class, 60),
-    BLAZE("Blaze", Blaze.class, 61),
-    MAGMA_CUBE("LavaSlime", MagmaCube.class, 62),
-    ENDER_DRAGON("EnderDragon", EnderDragon.class, 63),
-    WITHER("WitherBoss", Wither.class, 64),
-    BAT("Bat", Bat.class, 65),
-    WITCH("Witch", Witch.class, 66),
-    ENDERMITE("Endermite", Endermite.class, 67),
-    GUARDIAN("Guardian", Guardian.class, 68),
-    SHULKER("Shulker", Shulker.class, 69),
-    PIG("Pig", Pig.class, 90),
-    SHEEP("Sheep", Sheep.class, 91),
-    COW("Cow", Cow.class, 92),
-    CHICKEN("Chicken", Chicken.class, 93),
-    SQUID("Squid", Squid.class, 94),
-    WOLF("Wolf", Wolf.class, 95),
-    MUSHROOM_COW("MushroomCow", MushroomCow.class, 96),
-    SNOWMAN("SnowMan", Snowman.class, 97),
-    OCELOT("Ozelot", Ocelot.class, 98),
-    IRON_GOLEM("VillagerGolem", IronGolem.class, 99),
-    HORSE("EntityHorse", Horse.class, 100),
-    RABBIT("Rabbit", Rabbit.class, 101),
-    VILLAGER("Villager", Villager.class, 120),
-    ENDER_CRYSTAL("EnderCrystal", EnderCrystal.class, 200),
-    // These don't have an entity ID in nms.EntityTypes.
-    /**
-     * A flying splash potion
-     */
-    SPLASH_POTION(null, SplashPotion.class, -1, false),
-    /**
-     * A flying lingering potion
-     */
-    LINGERING_POTION(null, LingeringPotion.class, -1, false),
-    AREA_EFFECT_CLOUD(null, AreaEffectCloud.class, -1),
-    /**
-     * A flying chicken egg.
-     */
-    EGG(null, Egg.class, -1, false),
-    /**
-     * A fishing line and bobber.
-     */
-    FISHING_HOOK(null, Fish.class, -1, false),
-    /**
-     * A bolt of lightning.
-     * <p>
-     * Spawn with {@link World#strikeLightning(Location)}.
-     */
-    LIGHTNING(null, LightningStrike.class, -1, false),
-    WEATHER(null, Weather.class, -1, false),
-    PLAYER(null, Player.class, -1, false),
-    COMPLEX_PART(null, ComplexEntityPart.class, -1, false),
-    /**
-     * An unknown entity without an Entity Class
-     */
-    UNKNOWN(null, null, -1, false);
-
-    private String name;
-    private Class<? extends Entity> clazz;
-    private short typeId;
-    private boolean independent, living;
-
-    private static final Map<String, EntityType> NAME_MAP = new HashMap<String, EntityType>();
-    private static final Map<Short, EntityType> ID_MAP = new HashMap<Short, EntityType>();
-
-    static {
-        for (EntityType type : values()) {
-            if (type.name != null) {
-                NAME_MAP.put(type.name.toLowerCase(), type);
-            }
-            if (type.typeId > 0) {
-                ID_MAP.put(type.typeId, type);
-            }
-        }
-    }
-
-    private EntityType(String name, Class<? extends Entity> clazz, int typeId) {
-        this(name, clazz, typeId, true);
-    }
-
-    private EntityType(String name, Class<? extends Entity> clazz, int typeId, boolean independent) {
-        this.name = name;
-        this.clazz = clazz;
-        this.typeId = (short) typeId;
-        this.independent = independent;
-        if (clazz != null) {
-            this.living = LivingEntity.class.isAssignableFrom(clazz);
-        }
-    }
-
-    /**
-     *
-     * @return the entity type's name
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public String getName() {
-        return name;
-    }
-
-    public Class<? extends Entity> getEntityClass() {
-        return clazz;
-    }
-
-    /**
-     *
-     * @return the raw type id 
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public short getTypeId() {
-        return typeId;
-    }
-
-    /**
-     *
-     * @param name the entity type's name
-     * @return the matching entity type or null
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public static EntityType fromName(String name) {
-        if (name == null) {
-            return null;
-        }
-        return NAME_MAP.get(name.toLowerCase());
-    }
-
-    /**
-     *
-     * @param id the raw type id
-     * @return the matching entity type or null
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public static EntityType fromId(int id) {
-        if (id > Short.MAX_VALUE) {
-            return null;
-        }
-        return ID_MAP.get((short) id);
-    }
-
-    /**
-     * Some entities cannot be spawned using {@link
-     * World#spawnEntity(Location, EntityType)} or {@link
-     * World#spawn(Location, Class)}, usually because they require additional
-     * information in order to spawn.
-     *
-     * @return False if the entity type cannot be spawned
-     */
-    public boolean isSpawnable() {
-        return independent;
-    }
-
-    public boolean isAlive() {
-        return living;
-    }
-}
diff --git a/src/main/java/org/bukkit/entity/ExperienceOrb.java b/src/main/java/org/bukkit/entity/ExperienceOrb.java
deleted file mode 100644
index c286edf..0000000
--- a/src/main/java/org/bukkit/entity/ExperienceOrb.java
+++ /dev/null
@@ -1,21 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * Represents an Experience Orb.
- */
-public interface ExperienceOrb extends Entity {
-
-    /**
-     * Gets how much experience is contained within this orb
-     *
-     * @return Amount of experience
-     */
-    public int getExperience();
-
-    /**
-     * Sets how much experience is contained within this orb
-     *
-     * @param value Amount of experience
-     */
-    public void setExperience(int value);
-}
diff --git a/src/main/java/org/bukkit/entity/Explosive.java b/src/main/java/org/bukkit/entity/Explosive.java
deleted file mode 100644
index 48650f6..0000000
--- a/src/main/java/org/bukkit/entity/Explosive.java
+++ /dev/null
@@ -1,35 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * A representation of an explosive entity
- */
-public interface Explosive extends Entity {
-
-    /**
-     * Set the radius affected by this explosive's explosion
-     *
-     * @param yield The explosive yield
-     */
-    public void setYield(float yield);
-
-    /**
-     * Return the radius or yield of this explosive's explosion
-     *
-     * @return the radius of blocks affected
-     */
-    public float getYield();
-
-    /**
-     * Set whether or not this explosive's explosion causes fire
-     *
-     * @param isIncendiary Whether it should cause fire
-     */
-    public void setIsIncendiary(boolean isIncendiary);
-
-    /**
-     * Return whether or not this explosive creates a fire when exploding
-     *
-     * @return true if the explosive creates fire, false otherwise
-     */
-    public boolean isIncendiary();
-}
diff --git a/src/main/java/org/bukkit/entity/FallingBlock.java b/src/main/java/org/bukkit/entity/FallingBlock.java
deleted file mode 100644
index bc56fa2..0000000
--- a/src/main/java/org/bukkit/entity/FallingBlock.java
+++ /dev/null
@@ -1,62 +0,0 @@
-package org.bukkit.entity;
-
-import org.bukkit.Material;
-
-/**
- * Represents a falling block
- */
-public interface FallingBlock extends Entity {
-
-    /**
-     * Get the Material of the falling block
-     *
-     * @return Material of the block
-     */
-    Material getMaterial();
-
-    /**
-     * Get the ID of the falling block
-     *
-     * @return ID type of the block
-     * @deprecated Magic value
-     */
-    @Deprecated
-    int getBlockId();
-
-    /**
-     * Get the data for the falling block
-     *
-     * @return data of the block
-     * @deprecated Magic value
-     */
-    @Deprecated
-    byte getBlockData();
-
-    /**
-     * Get if the falling block will break into an item if it cannot be placed
-     *
-     * @return true if the block will break into an item when obstructed
-     */
-    boolean getDropItem();
-
-    /**
-     * Set if the falling block will break into an item if it cannot be placed
-     *
-     * @param drop true to break into an item when obstructed
-     */
-    void setDropItem(boolean drop);
-
-    /**
-     * Get the HurtEntities state of this block.
-     *
-     * @return whether entities will be damaged by this block.
-     */
-    boolean canHurtEntities();
-
-    /**
-     * Set the HurtEntities state of this block.
-     *
-     * @param hurtEntities whether entities will be damaged by this block.
-     */
-    void setHurtEntities(boolean hurtEntities);
-}
diff --git a/src/main/java/org/bukkit/entity/FallingSand.java b/src/main/java/org/bukkit/entity/FallingSand.java
deleted file mode 100644
index 758d47d..0000000
--- a/src/main/java/org/bukkit/entity/FallingSand.java
+++ /dev/null
@@ -1,9 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * Represents a falling block.
- *
- * @deprecated See {@link FallingBlock}
- */
-@Deprecated
-public interface FallingSand extends FallingBlock {}
diff --git a/src/main/java/org/bukkit/entity/Fireball.java b/src/main/java/org/bukkit/entity/Fireball.java
deleted file mode 100644
index 56ed578..0000000
--- a/src/main/java/org/bukkit/entity/Fireball.java
+++ /dev/null
@@ -1,24 +0,0 @@
-package org.bukkit.entity;
-
-import org.bukkit.util.Vector;
-
-/**
- * Represents a Fireball.
- */
-public interface Fireball extends Projectile, Explosive {
-
-    /**
-     * Fireballs fly straight and do not take setVelocity(...) well.
-     *
-     * @param direction the direction this fireball is flying toward
-     */
-    public void setDirection(Vector direction);
-
-    /**
-     * Retrieve the direction this fireball is heading toward
-     *
-     * @return the direction
-     */
-    public Vector getDirection();
-
-}
diff --git a/src/main/java/org/bukkit/entity/Firework.java b/src/main/java/org/bukkit/entity/Firework.java
deleted file mode 100644
index b8a8c07..0000000
--- a/src/main/java/org/bukkit/entity/Firework.java
+++ /dev/null
@@ -1,26 +0,0 @@
-package org.bukkit.entity;
-
-import org.bukkit.inventory.meta.FireworkMeta;
-
-public interface Firework extends Entity {
-
-    /**
-     * Get a copy of the fireworks meta
-     *
-     * @return A copy of the current Firework meta
-     */
-    FireworkMeta getFireworkMeta();
-
-    /**
-     * Apply the provided meta to the fireworks
-     *
-     * @param meta The FireworkMeta to apply
-     */
-    void setFireworkMeta(FireworkMeta meta);
-
-    /**
-     * Cause this firework to explode at earliest opportunity, as if it has no
-     * remaining fuse.
-     */
-    void detonate();
-}
diff --git a/src/main/java/org/bukkit/entity/Fish.java b/src/main/java/org/bukkit/entity/Fish.java
deleted file mode 100644
index 12ed1ed..0000000
--- a/src/main/java/org/bukkit/entity/Fish.java
+++ /dev/null
@@ -1,8 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * Represents a fishing hook.
- * @deprecated in favor of {@link FishHook}
- */
-public interface Fish extends FishHook {
-}
diff --git a/src/main/java/org/bukkit/entity/FishHook.java b/src/main/java/org/bukkit/entity/FishHook.java
deleted file mode 100644
index fdd48d0..0000000
--- a/src/main/java/org/bukkit/entity/FishHook.java
+++ /dev/null
@@ -1,32 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * Represents a fishing hook.
- */
-public interface FishHook extends Projectile {
-    /**
-     * Gets the chance of a fish biting.
-     * <p>
-     * 0.0 = No Chance.<br>
-     * 1.0 = Instant catch.
-     *
-     * @return chance the bite chance
-     * @deprecated has no effect in newer Minecraft versions
-     */
-    @Deprecated
-    public double getBiteChance();
-
-    /**
-     * Sets the chance of a fish biting.
-     * <p>
-     * 0.0 = No Chance.<br>
-     * 1.0 = Instant catch.
-     *
-     * @param chance the bite chance
-     * @throws IllegalArgumentException if the bite chance is not between 0
-     *     and 1
-     * @deprecated has no effect in newer Minecraft versions
-     */
-    @Deprecated
-    public void setBiteChance(double chance) throws IllegalArgumentException;
-}
diff --git a/src/main/java/org/bukkit/entity/Flying.java b/src/main/java/org/bukkit/entity/Flying.java
deleted file mode 100644
index 4f16a26..0000000
--- a/src/main/java/org/bukkit/entity/Flying.java
+++ /dev/null
@@ -1,6 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * Represents a Flying Entity.
- */
-public interface Flying extends LivingEntity {}
diff --git a/src/main/java/org/bukkit/entity/Ghast.java b/src/main/java/org/bukkit/entity/Ghast.java
deleted file mode 100644
index 3f5edf7..0000000
--- a/src/main/java/org/bukkit/entity/Ghast.java
+++ /dev/null
@@ -1,6 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * Represents a Ghast.
- */
-public interface Ghast extends Flying {}
diff --git a/src/main/java/org/bukkit/entity/Giant.java b/src/main/java/org/bukkit/entity/Giant.java
deleted file mode 100644
index 610de57..0000000
--- a/src/main/java/org/bukkit/entity/Giant.java
+++ /dev/null
@@ -1,6 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * Represents a Giant.
- */
-public interface Giant extends Monster {}
diff --git a/src/main/java/org/bukkit/entity/Golem.java b/src/main/java/org/bukkit/entity/Golem.java
deleted file mode 100644
index 4165977..0000000
--- a/src/main/java/org/bukkit/entity/Golem.java
+++ /dev/null
@@ -1,8 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * A mechanical creature that may harm enemies.
- */
-public interface Golem extends Creature {
-    
-}
diff --git a/src/main/java/org/bukkit/entity/Guardian.java b/src/main/java/org/bukkit/entity/Guardian.java
deleted file mode 100644
index 31f3c6a..0000000
--- a/src/main/java/org/bukkit/entity/Guardian.java
+++ /dev/null
@@ -1,18 +0,0 @@
-package org.bukkit.entity;
-
-public interface Guardian extends Monster {
-
-    /**
-     * Check if the Guardian is an elder Guardian
-     * 
-     * @return true if the Guardian is an Elder Guardian, false if not
-     */
-    public boolean isElder();
-
-    /**
-     * Set the Guardian to an elder Guardian or not
-     *
-     * @param shouldBeElder True if this Guardian should be a elder Guardian, false if not
-     */
-    public void setElder(boolean shouldBeElder);
-}
diff --git a/src/main/java/org/bukkit/entity/Hanging.java b/src/main/java/org/bukkit/entity/Hanging.java
deleted file mode 100644
index 67e9b61..0000000
--- a/src/main/java/org/bukkit/entity/Hanging.java
+++ /dev/null
@@ -1,22 +0,0 @@
-package org.bukkit.entity;
-
-import org.bukkit.block.BlockFace;
-import org.bukkit.material.Attachable;
-
-/**
- * Represents a Hanging entity
- */
-public interface Hanging extends Entity, Attachable {
-
-    /**
-     * Sets the direction of the hanging entity, potentially overriding rules
-     * of placement. Note that if the result is not valid the object would
-     * normally drop as an item.
-     *
-     * @param face The new direction.
-     * @param force Whether to force it.
-     * @return False if force was false and there was no block for it to
-     *     attach to in order to face the given direction.
-     */
-    public boolean setFacingDirection(BlockFace face, boolean force);
-}
diff --git a/src/main/java/org/bukkit/entity/Horse.java b/src/main/java/org/bukkit/entity/Horse.java
deleted file mode 100644
index e90d318..0000000
--- a/src/main/java/org/bukkit/entity/Horse.java
+++ /dev/null
@@ -1,256 +0,0 @@
-package org.bukkit.entity;
-
-import org.bukkit.inventory.HorseInventory;
-import org.bukkit.inventory.InventoryHolder;
-
-/**
- * Represents a Horse.
- */
-public interface Horse extends Animals, Vehicle, InventoryHolder, Tameable {
-
-    /**
-     * Represents the different types of horses that may exist.
-     */
-    public enum Variant {
-        /**
-         * A normal horse
-         */
-        HORSE,
-        /**
-         * A donkey
-         */
-        DONKEY,
-        /**
-         * A mule
-         */
-        MULE,
-        /**
-         * An undead horse
-         */
-        UNDEAD_HORSE,
-        /**
-         * A skeleton horse
-         */
-        SKELETON_HORSE,
-        ;
-    }
-
-    /**
-     * Represents the base color that the horse has.
-     */
-    public enum Color {
-        /**
-         * Snow white
-         */
-        WHITE,
-        /**
-         * Very light brown
-         */
-        CREAMY,
-        /**
-         * Chestnut
-         */
-        CHESTNUT,
-        /**
-         * Light brown
-         */
-        BROWN,
-        /**
-         * Pitch black
-         */
-        BLACK,
-        /**
-         * Gray
-         */
-        GRAY,
-        /**
-         * Dark brown
-         */
-        DARK_BROWN,
-        ;
-    }
-
-    /**
-     * Represents the style, or markings, that the horse has.
-     */
-    public enum Style {
-        /**
-         * No markings
-         */
-        NONE,
-        /**
-         * White socks or stripes
-         */
-        WHITE,
-        /**
-         * Milky splotches
-         */
-        WHITEFIELD,
-        /**
-         * Round white dots
-         */
-        WHITE_DOTS,
-        /**
-         * Small black dots
-         */
-        BLACK_DOTS,
-        ;
-    }
-
-    /**
-     * Gets the horse's variant.
-     * <p>
-     * A horse's variant defines its physical appearance and capabilities.
-     * Whether a horse is a regular horse, donkey, mule, or other kind of
-     * horse is determined using the variant.
-     *
-     * @return a {@link Variant} representing the horse's variant
-     */
-    public Variant getVariant();
-
-    /**
-     * Sets the horse's variant.
-     * <p>
-     * A horse's variant defines its physical appearance and capabilities.
-     * Whether a horse is a regular horse, donkey, mule, or other kind of
-     * horse can be set using the variant.
-     * <p>
-     * Setting a horse's variant does not change its attributes such as
-     * its owner and its tamed status, but changing a mule or donkey
-     * with a chest to another variant which does not support a chest
-     * will remove the chest and its contents.
-     *
-     * @param variant a {@link Variant} for this horse
-     */
-    public void setVariant(Variant variant);
-
-    /**
-     * Gets the horse's color.
-     * <p>
-     * Colors only apply to horses, not to donkeys, mules, skeleton horses
-     * or undead horses.
-     *
-     * @return a {@link Color} representing the horse's group
-     */
-    public Color getColor();
-
-    /**
-     * Sets the horse's color.
-     * <p>
-     * Attempting to set a color for any donkey, mule, skeleton horse or
-     * undead horse will not result in a change.
-     *
-     * @param color a {@link Color} for this horse
-     */
-    public void setColor(Color color);
-
-    /**
-     * Gets the horse's style.
-     * Styles determine what kind of markings or patterns a horse has.
-     * <p>
-     * Styles only apply to horses, not to donkeys, mules, skeleton horses
-     * or undead horses.
-     *
-     * @return a {@link Style} representing the horse's style
-     */
-    public Style getStyle();
-
-    /**
-     * Sets the style of this horse.
-     * Styles determine what kind of markings or patterns a horse has.
-     * <p>
-     * Attempting to set a style for any donkey, mule, skeleton horse or
-     * undead horse will not result in a change.
-     *
-     * @param style a {@link Style} for this horse
-     */
-    public void setStyle(Style style);
-
-    /**
-     * Gets whether the horse has a chest equipped.
-     *
-     * @return true if the horse has chest storage
-     */
-    public boolean isCarryingChest();
-
-    /**
-     * Sets whether the horse has a chest equipped.
-     * Removing a chest will also clear the chest's inventory.
-     *
-     * @param chest true if the horse should have a chest
-     */
-    public void setCarryingChest(boolean chest);
-
-    /**
-     * Gets the domestication level of this horse.
-     * <p>
-     * A higher domestication level indicates that the horse is closer to
-     * becoming tame. As the domestication level gets closer to the max
-     * domestication level, the chance of the horse becoming tame increases.
-     *
-     * @return domestication level
-     */
-    public int getDomestication();
-
-    /**
-     * Sets the domestication level of this horse.
-     * <p>
-     * Setting the domestication level to a high value will increase the
-     * horse's chances of becoming tame.
-     * <p>
-     * Domestication level must be greater than zero and no greater than
-     * the max domestication level of the horse, determined with
-     * {@link #getMaxDomestication()}
-     *
-     * @param level domestication level
-     */
-    public void setDomestication(int level);
-
-    /**
-     * Gets the maximum domestication level of this horse.
-     * <p>
-     * The higher this level is, the longer it will likely take
-     * for the horse to be tamed.
-     *
-     * @return the max domestication level
-     */
-    public int getMaxDomestication();
-
-    /**
-     * Sets the maximum domestication level of this horse.
-     * <p>
-     * Setting a higher max domestication will increase the amount of
-     * domesticating (feeding, riding, etc.) necessary in order to tame it,
-     * while setting a lower max value will have the opposite effect.
-     * <p>
-     * Maximum domestication must be greater than zero.
-     *
-     * @param level the max domestication level
-     */
-    public void setMaxDomestication(int level);
-
-    /**
-     * Gets the jump strength of this horse.
-     * <p>
-     * Jump strength defines how high the horse can jump. A higher jump strength
-     * increases how high a jump will go.
-     *
-     * @return the horse's jump strength
-     */
-    public double getJumpStrength();
-
-    /**
-     * Sets the jump strength of this horse.
-     * <p>
-     * A higher jump strength increases how high a jump will go.
-     * Setting a jump strength to 0 will result in no jump.
-     * You cannot set a jump strength to a value below 0 or
-     * above 2.
-     *
-     * @param strength jump strength for this horse
-     */
-    public void setJumpStrength(double strength);
-
-    @Override
-    public HorseInventory getInventory();
-}
diff --git a/src/main/java/org/bukkit/entity/HumanEntity.java b/src/main/java/org/bukkit/entity/HumanEntity.java
deleted file mode 100644
index be7c365..0000000
--- a/src/main/java/org/bukkit/entity/HumanEntity.java
+++ /dev/null
@@ -1,204 +0,0 @@
-package org.bukkit.entity;
-
-import org.bukkit.GameMode;
-import org.bukkit.Location;
-import org.bukkit.inventory.MainHand;
-import org.bukkit.inventory.Inventory;
-import org.bukkit.inventory.InventoryHolder;
-import org.bukkit.inventory.InventoryView;
-import org.bukkit.inventory.ItemStack;
-import org.bukkit.inventory.PlayerInventory;
-import org.bukkit.permissions.Permissible;
-
-/**
- * Represents a human entity, such as an NPC or a player
- */
-public interface HumanEntity extends LivingEntity, AnimalTamer, Permissible, InventoryHolder {
-
-    /**
-     * Returns the name of this player
-     *
-     * @return Player name
-     */
-    public String getName();
-
-    /**
-     * Get the player's inventory.
-     *
-     * @return The inventory of the player, this also contains the armor
-     *     slots.
-     */
-    public PlayerInventory getInventory();
-
-    /**
-     * Get the player's EnderChest inventory
-     *
-     * @return The EnderChest of the player
-     */
-    public Inventory getEnderChest();
-
-    /**
-     * Gets the player's selected main hand
-     *
-     * @return the players main hand
-     */
-    public MainHand getMainHand();
-
-    /**
-     * If the player currently has an inventory window open, this method will
-     * set a property of that window, such as the state of a progress bar.
-     *
-     * @param prop The property.
-     * @param value The value to set the property to.
-     * @return True if the property was successfully set.
-     */
-    public boolean setWindowProperty(InventoryView.Property prop, int value);
-
-    /**
-     * Gets the inventory view the player is currently viewing. If they do not
-     * have an inventory window open, it returns their internal crafting view.
-     *
-     * @return The inventory view.
-     */
-    public InventoryView getOpenInventory();
-
-    /**
-     * Opens an inventory window with the specified inventory on the top and
-     * the player's inventory on the bottom.
-     *
-     * @param inventory The inventory to open
-     * @return The newly opened inventory view
-     */
-    public InventoryView openInventory(Inventory inventory);
-
-    /**
-     * Opens an empty workbench inventory window with the player's inventory
-     * on the bottom.
-     *
-     * @param location The location to attach it to. If null, the player's
-     *     location is used.
-     * @param force If false, and there is no workbench block at the location,
-     *     no inventory will be opened and null will be returned.
-     * @return The newly opened inventory view, or null if it could not be
-     *     opened.
-     */
-    public InventoryView openWorkbench(Location location, boolean force);
-
-    /**
-     * Opens an empty enchanting inventory window with the player's inventory
-     * on the bottom.
-     *
-     * @param location The location to attach it to. If null, the player's
-     *     location is used.
-     * @param force If false, and there is no enchanting table at the
-     *     location, no inventory will be opened and null will be returned.
-     * @return The newly opened inventory view, or null if it could not be
-     *     opened.
-     */
-    public InventoryView openEnchanting(Location location, boolean force);
-
-    /**
-     * Opens an inventory window to the specified inventory view.
-     *
-     * @param inventory The view to open
-     */
-    public void openInventory(InventoryView inventory);
-
-    /**
-     * Starts a trade between the player and the villager.
-     *
-     * Note that only one player may trade with a villager at once. You must use
-     * the force parameter for this.
-     *
-     * @param trader The merchant to trade with. Cannot be null.
-     * @param force whether to force the trade even if another player is trading
-     * @return The newly opened inventory view, or null if it could not be
-     * opened.
-     */
-    public InventoryView openMerchant(Villager trader, boolean force);
-
-    /**
-     * Force-closes the currently open inventory view for this player, if any.
-     */
-    public void closeInventory();
-
-    /**
-     * Returns the ItemStack currently in your hand, can be empty.
-     *
-     * @return The ItemStack of the item you are currently holding.
-     * @deprecated Humans may now dual wield in their off hand, use explicit
-     * methods in {@link PlayerInventory}.
-     */
-    @Deprecated
-    public ItemStack getItemInHand();
-
-    /**
-     * Sets the item to the given ItemStack, this will replace whatever the
-     * user was holding.
-     *
-     * @param item The ItemStack which will end up in the hand
-     * @deprecated Humans may now dual wield in their off hand, use explicit
-     * methods in {@link PlayerInventory}.
-     */
-    @Deprecated
-    public void setItemInHand(ItemStack item);
-
-    /**
-     * Returns the ItemStack currently on your cursor, can be empty. Will
-     * always be empty if the player currently has no open window.
-     *
-     * @return The ItemStack of the item you are currently moving around.
-     */
-    public ItemStack getItemOnCursor();
-
-    /**
-     * Sets the item to the given ItemStack, this will replace whatever the
-     * user was moving. Will always be empty if the player currently has no
-     * open window.
-     *
-     * @param item The ItemStack which will end up in the hand
-     */
-    public void setItemOnCursor(ItemStack item);
-
-    /**
-     * Returns whether this player is slumbering.
-     *
-     * @return slumber state
-     */
-    public boolean isSleeping();
-
-    /**
-     * Get the sleep ticks of the player. This value may be capped.
-     *
-     * @return slumber ticks
-     */
-    public int getSleepTicks();
-
-    /**
-     * Gets this human's current {@link GameMode}
-     *
-     * @return Current game mode
-     */
-    public GameMode getGameMode();
-
-    /**
-     * Sets this human's current {@link GameMode}
-     *
-     * @param mode New game mode
-     */
-    public void setGameMode(GameMode mode);
-
-    /**
-     * Check if the player is currently blocking (ie with a sword).
-     *
-     * @return Whether they are blocking.
-     */
-    public boolean isBlocking();
-
-    /**
-     * Get the total amount of experience required for the player to level
-     *
-     * @return Experience required to level up
-     */
-    public int getExpToLevel();
-}
diff --git a/src/main/java/org/bukkit/entity/IronGolem.java b/src/main/java/org/bukkit/entity/IronGolem.java
deleted file mode 100644
index 655e37c..0000000
--- a/src/main/java/org/bukkit/entity/IronGolem.java
+++ /dev/null
@@ -1,22 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * An iron Golem that protects Villages.
- */
-public interface IronGolem extends Golem {
-
-    /**
-     * Gets whether this iron golem was built by a player.
-     *
-     * @return Whether this iron golem was built by a player
-     */
-    public boolean isPlayerCreated();
-
-    /**
-     * Sets whether this iron golem was built by a player or not.
-     *
-     * @param playerCreated true if you want to set the iron golem as being
-     *     player created, false if you want it to be a natural village golem.
-     */
-    public void setPlayerCreated(boolean playerCreated);
-}
diff --git a/src/main/java/org/bukkit/entity/Item.java b/src/main/java/org/bukkit/entity/Item.java
deleted file mode 100644
index 90260b7..0000000
--- a/src/main/java/org/bukkit/entity/Item.java
+++ /dev/null
@@ -1,37 +0,0 @@
-package org.bukkit.entity;
-
-import org.bukkit.inventory.ItemStack;
-
-/**
- * Represents an Item.
- */
-public interface Item extends Entity {
-
-    /**
-     * Gets the item stack associated with this item drop.
-     *
-     * @return An item stack.
-     */
-    public ItemStack getItemStack();
-
-    /**
-     * Sets the item stack associated with this item drop.
-     *
-     * @param stack An item stack.
-     */
-    public void setItemStack(ItemStack stack);
-
-    /**
-     * Gets the delay before this Item is available to be picked up by players
-     *
-     * @return Remaining delay
-     */
-    public int getPickupDelay();
-
-    /**
-     * Sets the delay before this Item is available to be picked up by players
-     *
-     * @param delay New delay
-     */
-    public void setPickupDelay(int delay);
-}
diff --git a/src/main/java/org/bukkit/entity/ItemFrame.java b/src/main/java/org/bukkit/entity/ItemFrame.java
deleted file mode 100644
index 8b86815..0000000
--- a/src/main/java/org/bukkit/entity/ItemFrame.java
+++ /dev/null
@@ -1,39 +0,0 @@
-package org.bukkit.entity;
-
-import org.bukkit.Rotation;
-import org.bukkit.inventory.ItemStack;
-
-/**
- * Represents an Item Frame
- */
-public interface ItemFrame extends Hanging {
-
-    /**
-     * Get the item in this frame
-     *
-     * @return a defensive copy the item in this item frame
-     */
-    public ItemStack getItem();
-
-    /**
-     * Set the item in this frame
-     *
-     * @param item the new item
-     */
-    public void setItem(ItemStack item);
-
-    /**
-     * Get the rotation of the frame's item
-     *
-     * @return the direction
-     */
-    public Rotation getRotation();
-
-    /**
-     * Set the rotation of the frame's item
-     *
-     * @param rotation the new rotation
-     * @throws IllegalArgumentException if rotation is null
-     */
-    public void setRotation(Rotation rotation) throws IllegalArgumentException;
-}
diff --git a/src/main/java/org/bukkit/entity/LargeFireball.java b/src/main/java/org/bukkit/entity/LargeFireball.java
deleted file mode 100644
index fc3a109..0000000
--- a/src/main/java/org/bukkit/entity/LargeFireball.java
+++ /dev/null
@@ -1,7 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * Represents a large {@link Fireball}
- */
-public interface LargeFireball extends Fireball {
-}
diff --git a/src/main/java/org/bukkit/entity/LeashHitch.java b/src/main/java/org/bukkit/entity/LeashHitch.java
deleted file mode 100644
index 9ac04c1..0000000
--- a/src/main/java/org/bukkit/entity/LeashHitch.java
+++ /dev/null
@@ -1,7 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * Represents a Leash Hitch on a fence
- */
-public interface LeashHitch extends Hanging {
-}
diff --git a/src/main/java/org/bukkit/entity/LightningStrike.java b/src/main/java/org/bukkit/entity/LightningStrike.java
deleted file mode 100644
index c8b5154..0000000
--- a/src/main/java/org/bukkit/entity/LightningStrike.java
+++ /dev/null
@@ -1,15 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * Represents an instance of a lightning strike. May or may not do damage.
- */
-public interface LightningStrike extends Weather {
-
-    /**
-     * Returns whether the strike is an effect that does no damage.
-     *
-     * @return whether the strike is an effect
-     */
-    public boolean isEffect();
-
-}
diff --git a/src/main/java/org/bukkit/entity/LingeringPotion.java b/src/main/java/org/bukkit/entity/LingeringPotion.java
deleted file mode 100644
index 5aca7cb..0000000
--- a/src/main/java/org/bukkit/entity/LingeringPotion.java
+++ /dev/null
@@ -1,6 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * Represents a thrown lingering potion bottle
- */
-public interface LingeringPotion extends ThrownPotion { }
diff --git a/src/main/java/org/bukkit/entity/LivingEntity.java b/src/main/java/org/bukkit/entity/LivingEntity.java
deleted file mode 100644
index 22de9f7..0000000
--- a/src/main/java/org/bukkit/entity/LivingEntity.java
+++ /dev/null
@@ -1,419 +0,0 @@
-package org.bukkit.entity;
-
-import java.util.Collection;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
-
-import org.bukkit.Location;
-import org.bukkit.Material;
-import org.bukkit.attribute.Attributable;
-import org.bukkit.block.Block;
-import org.bukkit.inventory.EntityEquipment;
-import org.bukkit.potion.PotionEffect;
-import org.bukkit.potion.PotionEffectType;
-import org.bukkit.projectiles.ProjectileSource;
-
-/**
- * Represents a living entity, such as a monster or player
- */
-public interface LivingEntity extends Attributable, Entity, Damageable, ProjectileSource {
-
-    /**
-     * Gets the height of the living entity's eyes above its Location.
-     *
-     * @return height of the living entity's eyes above its location
-     */
-    public double getEyeHeight();
-
-    /**
-     * Gets the height of the living entity's eyes above its Location.
-     *
-     * @param ignoreSneaking if set to true, the effects of sneaking will be
-     *     ignored
-     * @return height of the living entity's eyes above its location
-     */
-    public double getEyeHeight(boolean ignoreSneaking);
-
-    /**
-     * Get a Location detailing the current eye position of the living entity.
-     *
-     * @return a location at the eyes of the living entity
-     */
-    public Location getEyeLocation();
-
-    /**
-     * Gets all blocks along the living entity's line of sight.
-     * <p>
-     * This list contains all blocks from the living entity's eye position to
-     * target inclusive.
-     *
-     * @param transparent HashSet containing all transparent block IDs (set to
-     *     null for only air)
-     * @param maxDistance this is the maximum distance to scan (may be limited
-     *     by server by at least 100 blocks, no less)
-     * @return list containing all blocks along the living entity's line of
-     *     sight
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public List<Block> getLineOfSight(HashSet<Byte> transparent, int maxDistance);
-
-    /**
-     * Gets all blocks along the living entity's line of sight.
-     * <p>
-     * This list contains all blocks from the living entity's eye position to
-     * target inclusive.
-     *
-     * @param transparent HashSet containing all transparent block Materials (set to
-     *     null for only air)
-     * @param maxDistance this is the maximum distance to scan (may be limited
-     *     by server by at least 100 blocks, no less)
-     * @return list containing all blocks along the living entity's line of
-     *     sight
-     */
-    public List<Block> getLineOfSight(Set<Material> transparent, int maxDistance);
-
-    /**
-     * Gets the block that the living entity has targeted.
-     *
-     * @param transparent HashSet containing all transparent block IDs (set to
-     *     null for only air)
-     * @param maxDistance this is the maximum distance to scan (may be limited
-     *     by server by at least 100 blocks, no less)
-     * @return block that the living entity has targeted
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Block getTargetBlock(HashSet<Byte> transparent, int maxDistance);
-
-    /**
-     * Gets the block that the living entity has targeted.
-     *
-     * @param transparent HashSet containing all transparent block Materials (set to
-     *     null for only air)
-     * @param maxDistance this is the maximum distance to scan (may be limited
-     *     by server by at least 100 blocks, no less)
-     * @return block that the living entity has targeted
-     */
-    public Block getTargetBlock(Set<Material> transparent, int maxDistance);
-
-    /**
-     * Gets the last two blocks along the living entity's line of sight.
-     * <p>
-     * The target block will be the last block in the list.
-     *
-     * @param transparent HashSet containing all transparent block IDs (set to
-     *     null for only air)
-     * @param maxDistance this is the maximum distance to scan. This may be
-     *     further limited by the server, but never to less than 100 blocks
-     * @return list containing the last 2 blocks along the living entity's
-     *     line of sight
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public List<Block> getLastTwoTargetBlocks(HashSet<Byte> transparent, int maxDistance);
-
-    /**
-     * Gets the last two blocks along the living entity's line of sight.
-     * <p>
-     * The target block will be the last block in the list.
-     *
-     * @param transparent HashSet containing all transparent block Materials (set to
-     *     null for only air)
-     * @param maxDistance this is the maximum distance to scan. This may be
-     *     further limited by the server, but never to less than 100 blocks
-     * @return list containing the last 2 blocks along the living entity's
-     *     line of sight
-     */
-    public List<Block> getLastTwoTargetBlocks(Set<Material> transparent, int maxDistance);
-
-    /**
-     * Returns the amount of air that the living entity has remaining, in
-     * ticks.
-     *
-     * @return amount of air remaining
-     */
-    public int getRemainingAir();
-
-    /**
-     * Sets the amount of air that the living entity has remaining, in ticks.
-     *
-     * @param ticks amount of air remaining
-     */
-    public void setRemainingAir(int ticks);
-
-    /**
-     * Returns the maximum amount of air the living entity can have, in ticks.
-     *
-     * @return maximum amount of air
-     */
-    public int getMaximumAir();
-
-    /**
-     * Sets the maximum amount of air the living entity can have, in ticks.
-     *
-     * @param ticks maximum amount of air
-     */
-    public void setMaximumAir(int ticks);
-
-    /**
-     * Returns the living entity's current maximum no damage ticks.
-     * <p>
-     * This is the maximum duration in which the living entity will not take
-     * damage.
-     *
-     * @return maximum no damage ticks
-     */
-    public int getMaximumNoDamageTicks();
-
-    /**
-     * Sets the living entity's current maximum no damage ticks.
-     *
-     * @param ticks maximum amount of no damage ticks
-     */
-    public void setMaximumNoDamageTicks(int ticks);
-
-    /**
-     * Returns the living entity's last damage taken in the current no damage
-     * ticks time.
-     * <p>
-     * Only damage higher than this amount will further damage the living
-     * entity.
-     *
-     * @return damage taken since the last no damage ticks time period
-     */
-    public double getLastDamage();
-
-    /**
-     * This method exists for legacy reasons to provide backwards
-     * compatibility. It will not exist at runtime and should not be used
-     * under any circumstances.
-     * 
-     * @return damage taken since the last no damage ticks time period
-     */
-    @Deprecated
-    public int _INVALID_getLastDamage();
-
-    /**
-     * Sets the damage dealt within the current no damage ticks time period.
-     *
-     * @param damage amount of damage
-     */
-    public void setLastDamage(double damage);
-
-    /**
-     * This method exists for legacy reasons to provide backwards
-     * compatibility. It will not exist at runtime and should not be used
-     * under any circumstances.
-     * 
-     * @param damage amount of damage
-     */
-    @Deprecated
-    public void _INVALID_setLastDamage(int damage);
-
-    /**
-     * Returns the living entity's current no damage ticks.
-     *
-     * @return amount of no damage ticks
-     */
-    public int getNoDamageTicks();
-
-    /**
-     * Sets the living entity's current no damage ticks.
-     *
-     * @param ticks amount of no damage ticks
-     */
-    public void setNoDamageTicks(int ticks);
-
-    /**
-     * Gets the player identified as the killer of the living entity.
-     * <p>
-     * May be null.
-     *
-     * @return killer player, or null if none found
-     */
-    public Player getKiller();
-
-    /**
-     * Adds the given {@link PotionEffect} to the living entity.
-     * <p>
-     * Only one potion effect can be present for a given {@link
-     * PotionEffectType}.
-     *
-     * @param effect PotionEffect to be added
-     * @return whether the effect could be added
-     */
-    public boolean addPotionEffect(PotionEffect effect);
-
-    /**
-     * Adds the given {@link PotionEffect} to the living entity.
-     * <p>
-     * Only one potion effect can be present for a given {@link
-     * PotionEffectType}.
-     *
-     * @param effect PotionEffect to be added
-     * @param force whether conflicting effects should be removed
-     * @return whether the effect could be added
-     */
-    public boolean addPotionEffect(PotionEffect effect, boolean force);
-
-    /**
-     * Attempts to add all of the given {@link PotionEffect} to the living
-     * entity.
-     *
-     * @param effects the effects to add
-     * @return whether all of the effects could be added
-     */
-    public boolean addPotionEffects(Collection<PotionEffect> effects);
-
-    /**
-     * Returns whether the living entity already has an existing effect of
-     * the given {@link PotionEffectType} applied to it.
-     *
-     * @param type the potion type to check
-     * @return whether the living entity has this potion effect active on them
-     */
-    public boolean hasPotionEffect(PotionEffectType type);
-
-    /**
-     * Removes any effects present of the given {@link PotionEffectType}.
-     *
-     * @param type the potion type to remove
-     */
-    public void removePotionEffect(PotionEffectType type);
-
-    /**
-     * Returns all currently active {@link PotionEffect}s on the living
-     * entity.
-     *
-     * @return a collection of {@link PotionEffect}s
-     */
-    public Collection<PotionEffect> getActivePotionEffects();
-
-    /**
-     * Checks whether the living entity has block line of sight to another.
-     * <p>
-     * This uses the same algorithm that hostile mobs use to find the closest
-     * player.
-     *
-     * @param other the entity to determine line of sight to
-     * @return true if there is a line of sight, false if not
-     */
-    public boolean hasLineOfSight(Entity other);
-
-    /**
-     * Returns if the living entity despawns when away from players or not.
-     * <p>
-     * By default, animals are not removed while other mobs are.
-     *
-     * @return true if the living entity is removed when away from players
-     */
-    public boolean getRemoveWhenFarAway();
-
-    /**
-     * Sets whether or not the living entity despawns when away from players
-     * or not.
-     *
-     * @param remove the removal status
-     */
-    public void setRemoveWhenFarAway(boolean remove);
-
-    /**
-     * Gets the inventory with the equipment worn by the living entity.
-     *
-     * @return the living entity's inventory
-     */
-    public EntityEquipment getEquipment();
-
-    /**
-     * Sets whether or not the living entity can pick up items.
-     *
-     * @param pickup whether or not the living entity can pick up items
-     */
-    public void setCanPickupItems(boolean pickup);
-
-    /**
-     * Gets if the living entity can pick up items.
-     *
-     * @return whether or not the living entity can pick up items
-     */
-    public boolean getCanPickupItems();
-
-    /**
-     * Returns whether the entity is currently leashed.
-     *
-     * @return whether the entity is leashed
-     */
-    public boolean isLeashed();
-
-    /**
-     * Gets the entity that is currently leading this entity.
-     *
-     * @return the entity holding the leash
-     * @throws IllegalStateException if not currently leashed
-     */
-    public Entity getLeashHolder() throws IllegalStateException;
-
-    /**
-     * Sets the leash on this entity to be held by the supplied entity.
-     * <p>
-     * This method has no effect on EnderDragons, Withers, Players, or Bats.
-     * Non-living entities excluding leashes will not persist as leash
-     * holders.
-     *
-     * @param holder the entity to leash this entity to
-     * @return whether the operation was successful
-     */
-    public boolean setLeashHolder(Entity holder);
-
-    /**
-     * Checks to see if an entity is gliding, such as using an Elytra.
-     * @return True if this entity is gliding.
-     */
-    public boolean isGliding();
-
-    /**
-     * Makes entity start or stop gliding. This will work even if an Elytra
-     * is not equipped, but will be reverted by the server immediately after
-     * unless an event-cancelling mechanism is put in place.
-     * @param gliding True if the entity is gliding.
-     */
-    public void setGliding(boolean gliding);
-
-    /**
-     * Sets whether an entity will have AI.
-     *
-     * @param ai whether the mob will have AI or not.
-     */
-    void setAI(boolean ai);
-
-    /**
-     * Checks whether an entity has AI.
-     *
-     * @return true if the entity has AI, otherwise false.
-     */
-    boolean hasAI();
-
-    /**
-     * Set if this entity will be subject to collisions other entities.
-     * <p>
-     * Note that collisions are bidirectional, so this method would need to be
-     * set to false on both the collidee and the collidant to ensure no
-     * collisions take place.
-     *
-     * @param collidable collision status
-     */
-    void setCollidable(boolean collidable);
-
-    /**
-     * Gets if this entity is subject to collisions with other entities.
-     * <p>
-     * Please note that this method returns only the custom collidable state,
-     * not whether the entity is non-collidable for other reasons such as being
-     * dead.
-     *
-     * @return collision status
-     */
-    boolean isCollidable();
-}
diff --git a/src/main/java/org/bukkit/entity/MagmaCube.java b/src/main/java/org/bukkit/entity/MagmaCube.java
deleted file mode 100644
index 714b442..0000000
--- a/src/main/java/org/bukkit/entity/MagmaCube.java
+++ /dev/null
@@ -1,7 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * Represents a MagmaCube.
- */
-public interface MagmaCube extends Slime {
-}
diff --git a/src/main/java/org/bukkit/entity/Minecart.java b/src/main/java/org/bukkit/entity/Minecart.java
deleted file mode 100644
index ea64114..0000000
--- a/src/main/java/org/bukkit/entity/Minecart.java
+++ /dev/null
@@ -1,144 +0,0 @@
-package org.bukkit.entity;
-
-import org.bukkit.Material;
-import org.bukkit.material.MaterialData;
-import org.bukkit.util.Vector;
-
-/**
- * Represents a minecart entity.
- */
-public interface Minecart extends Vehicle {
-
-    /**
-     * This method exists for legacy reasons to provide backwards
-     * compatibility. It will not exist at runtime and should not be used
-     * under any circumstances.
-     *
-     * @param damage over 40 to "kill" a minecart
-     */
-    @Deprecated
-    public void _INVALID_setDamage(int damage);
-
-    /**
-     * Sets a minecart's damage.
-     *
-     * @param damage over 40 to "kill" a minecart
-     */
-    public void setDamage(double damage);
-
-    /**
-     * This method exists for legacy reasons to provide backwards
-     * compatibility. It will not exist at runtime and should not be used
-     * under any circumstances.
-     *
-     * @return The damage
-     */
-    @Deprecated
-    public int _INVALID_getDamage();
-
-    /**
-     * Gets a minecart's damage.
-     *
-     * @return The damage
-     */
-    public double getDamage();
-
-    /**
-     * Gets the maximum speed of a minecart. The speed is unrelated to the
-     * velocity.
-     *
-     * @return The max speed
-     */
-    public double getMaxSpeed();
-
-    /**
-     * Sets the maximum speed of a minecart. Must be nonnegative. Default is
-     * 0.4D.
-     *
-     * @param speed The max speed
-     */
-    public void setMaxSpeed(double speed);
-
-    /**
-     * Returns whether this minecart will slow down faster without a passenger
-     * occupying it
-     *
-     * @return Whether it decelerates faster
-     */
-    public boolean isSlowWhenEmpty();
-
-    /**
-     * Sets whether this minecart will slow down faster without a passenger
-     * occupying it
-     *
-     * @param slow Whether it will decelerate faster
-     */
-    public void setSlowWhenEmpty(boolean slow);
-
-    /**
-     * Gets the flying velocity modifier. Used for minecarts that are in
-     * mid-air. A flying minecart's velocity is multiplied by this factor each
-     * tick.
-     *
-     * @return The vector factor
-     */
-    public Vector getFlyingVelocityMod();
-
-    /**
-     * Sets the flying velocity modifier. Used for minecarts that are in
-     * mid-air. A flying minecart's velocity is multiplied by this factor each
-     * tick.
-     *
-     * @param flying velocity modifier vector
-     */
-    public void setFlyingVelocityMod(Vector flying);
-
-    /**
-     * Gets the derailed velocity modifier. Used for minecarts that are on the
-     * ground, but not on rails.
-     * <p>
-     * A derailed minecart's velocity is multiplied by this factor each tick.
-     *
-     * @return derailed visible speed
-     */
-    public Vector getDerailedVelocityMod();
-
-    /**
-     * Sets the derailed velocity modifier. Used for minecarts that are on the
-     * ground, but not on rails. A derailed minecart's velocity is multiplied
-     * by this factor each tick.
-     *
-     * @param derailed visible speed
-     */
-    public void setDerailedVelocityMod(Vector derailed);
-
-    /**
-     * Sets the display block for this minecart.
-     * Passing a null value will set the minecart to have no display block.
-     *
-     * @param material the material to set as display block.
-     */
-    public void setDisplayBlock(MaterialData material);
-
-    /**
-     * Gets the display block for this minecart.
-     * This function will return the type AIR if none is set.
-     *
-     * @return the block displayed by this minecart.
-     */
-    public MaterialData getDisplayBlock();
-
-    /**
-     * Sets the offset of the display block.
-     *
-     * @param offset the block offset to set for this minecart.
-     */
-    public void setDisplayBlockOffset(int offset);
-
-    /**
-     * Gets the offset of the display block.
-     * 
-     * @return the current block offset for this minecart.
-     */
-    public int getDisplayBlockOffset();
-}
diff --git a/src/main/java/org/bukkit/entity/Monster.java b/src/main/java/org/bukkit/entity/Monster.java
deleted file mode 100644
index fce2efd..0000000
--- a/src/main/java/org/bukkit/entity/Monster.java
+++ /dev/null
@@ -1,6 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * Represents a Monster.
- */
-public interface Monster extends Creature {}
diff --git a/src/main/java/org/bukkit/entity/MushroomCow.java b/src/main/java/org/bukkit/entity/MushroomCow.java
deleted file mode 100644
index 84154de..0000000
--- a/src/main/java/org/bukkit/entity/MushroomCow.java
+++ /dev/null
@@ -1,8 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * Represents a mushroom {@link Cow}
- */
-public interface MushroomCow extends Cow {
-
-}
diff --git a/src/main/java/org/bukkit/entity/NPC.java b/src/main/java/org/bukkit/entity/NPC.java
deleted file mode 100644
index 0c6b175..0000000
--- a/src/main/java/org/bukkit/entity/NPC.java
+++ /dev/null
@@ -1,8 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * Represents a non-player character
- */
-public interface NPC extends Creature {
-
-}
diff --git a/src/main/java/org/bukkit/entity/Ocelot.java b/src/main/java/org/bukkit/entity/Ocelot.java
deleted file mode 100644
index d5d034d..0000000
--- a/src/main/java/org/bukkit/entity/Ocelot.java
+++ /dev/null
@@ -1,83 +0,0 @@
-
-package org.bukkit.entity;
-
-/**
- * A wild tameable cat
- */
-public interface Ocelot extends Animals, Tameable {
-
-    /**
-     * Gets the current type of this cat.
-     *
-     * @return Type of the cat.
-     */
-    public Type getCatType();
-
-    /**
-     * Sets the current type of this cat.
-     *
-     * @param type New type of this cat.
-     */
-    public void setCatType(Type type);
-
-    /**
-     * Checks if this ocelot is sitting
-     *
-     * @return true if sitting
-     */
-    public boolean isSitting();
-
-    /**
-     * Sets if this ocelot is sitting. Will remove any path that the ocelot
-     * was following beforehand.
-     *
-     * @param sitting true if sitting
-     */
-    public void setSitting(boolean sitting);
-
-    /**
-     * Represents the various different cat types there are.
-     */
-    public enum Type {
-        WILD_OCELOT(0),
-        BLACK_CAT(1),
-        RED_CAT(2),
-        SIAMESE_CAT(3);
-
-        private static final Type[] types = new Type[Type.values().length];
-        private final int id;
-
-        static {
-            for (Type type : values()) {
-                types[type.getId()] = type;
-            }
-        }
-
-        private Type(int id) {
-            this.id = id;
-        }
-
-        /**
-         * Gets the ID of this cat type.
-         *
-         * @return Type ID.
-         * @deprecated Magic value
-         */
-        @Deprecated
-        public int getId() {
-            return id;
-        }
-
-        /**
-         * Gets a cat type by its ID.
-         *
-         * @param id ID of the cat type to get.
-         * @return Resulting type, or null if not found.
-         * @deprecated Magic value
-         */
-        @Deprecated
-        public static Type getType(int id) {
-            return (id >= types.length) ? null : types[id];
-        }
-    }
-}
diff --git a/src/main/java/org/bukkit/entity/Painting.java b/src/main/java/org/bukkit/entity/Painting.java
deleted file mode 100644
index 6afa117..0000000
--- a/src/main/java/org/bukkit/entity/Painting.java
+++ /dev/null
@@ -1,39 +0,0 @@
-package org.bukkit.entity;
-
-import org.bukkit.Art;
-import org.bukkit.event.hanging.HangingBreakEvent;
-
-/**
- * Represents a Painting.
- */
-public interface Painting extends Hanging {
-
-    /**
-     * Get the art on this painting
-     *
-     * @return The art
-     */
-    public Art getArt();
-
-    /**
-     * Set the art on this painting
-     *
-     * @param art The new art
-     * @return False if the new art won't fit at the painting's current
-     *     location
-     */
-    public boolean setArt(Art art);
-
-    /**
-     * Set the art on this painting
-     *
-     * @param art The new art
-     * @param force If true, force the new art regardless of whether it fits
-     *     at the current location. Note that forcing it where it can't fit
-     *     normally causes it to drop as an item unless you override this by
-     *     catching the {@link HangingBreakEvent}.
-     * @return False if force was false and the new art won't fit at the
-     *     painting's current location
-     */
-    public boolean setArt(Art art, boolean force);
-}
diff --git a/src/main/java/org/bukkit/entity/Pig.java b/src/main/java/org/bukkit/entity/Pig.java
deleted file mode 100644
index 28f59f2..0000000
--- a/src/main/java/org/bukkit/entity/Pig.java
+++ /dev/null
@@ -1,21 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * Represents a Pig.
- */
-public interface Pig extends Animals, Vehicle {
-
-    /**
-     * Check if the pig has a saddle.
-     *
-     * @return if the pig has been saddled.
-     */
-    public boolean hasSaddle();
-
-    /**
-     * Sets if the pig has a saddle or not
-     *
-     * @param saddled set if the pig has a saddle or not.
-     */
-    public void setSaddle(boolean saddled);
-}
diff --git a/src/main/java/org/bukkit/entity/PigZombie.java b/src/main/java/org/bukkit/entity/PigZombie.java
deleted file mode 100644
index 2f08672..0000000
--- a/src/main/java/org/bukkit/entity/PigZombie.java
+++ /dev/null
@@ -1,36 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * Represents a Pig Zombie.
- */
-public interface PigZombie extends Zombie {
-
-    /**
-     * Get the pig zombie's current anger level.
-     *
-     * @return The anger level.
-     */
-    int getAnger();
-
-    /**
-     * Set the pig zombie's current anger level.
-     *
-     * @param level The anger level. Higher levels of anger take longer to
-     *     wear off.
-     */
-    void setAnger(int level);
-
-    /**
-     * Shorthand; sets to either 0 or the default level.
-     *
-     * @param angry Whether the zombie should be angry.
-     */
-    void setAngry(boolean angry);
-
-    /**
-     * Shorthand; gets whether the zombie is angry.
-     *
-     * @return True if the zombie is angry, otherwise false.
-     */
-    boolean isAngry();
-}
diff --git a/src/main/java/org/bukkit/entity/Player.java b/src/main/java/org/bukkit/entity/Player.java
deleted file mode 100644
index 3be6fd8..0000000
--- a/src/main/java/org/bukkit/entity/Player.java
+++ /dev/null
@@ -1,1287 +0,0 @@
-package org.bukkit.entity;
-
-import java.net.InetSocketAddress;
-
-import org.bukkit.Achievement;
-import org.bukkit.ChatColor;
-import org.bukkit.Effect;
-import org.bukkit.GameMode;
-import org.bukkit.Instrument;
-import org.bukkit.Location;
-import org.bukkit.Material;
-import org.bukkit.Note;
-import org.bukkit.OfflinePlayer;
-import org.bukkit.Particle;
-import org.bukkit.Sound;
-import org.bukkit.Statistic;
-import org.bukkit.WeatherType;
-import org.bukkit.command.CommandSender;
-import org.bukkit.conversations.Conversable;
-import org.bukkit.map.MapView;
-import org.bukkit.plugin.messaging.PluginMessageRecipient;
-import org.bukkit.scoreboard.Scoreboard;
-
-import com.destroystokyo.paper.profile.AccountProfile; // Paper
-
-/**
- * Represents a player, connected or not
- */
-public interface Player extends HumanEntity, Conversable, CommandSender, OfflinePlayer, PluginMessageRecipient {
-
-    /**
-     * Gets the "friendly" name to display of this player. This may include
-     * color.
-     * <p>
-     * Note that this name will not be displayed in game, only in chat and
-     * places defined by plugins.
-     *
-     * @return the friendly name
-     */
-    public String getDisplayName();
-
-    /**
-     * Sets the "friendly" name to display of this player. This may include
-     * color.
-     * <p>
-     * Note that this name will not be displayed in game, only in chat and
-     * places defined by plugins.
-     *
-     * @param name The new display name.
-     */
-    public void setDisplayName(String name);
-
-    /**
-     * Gets the name that is shown on the player list.
-     *
-     * @return the player list name
-     */
-    public String getPlayerListName();
-
-    /**
-     * Sets the name that is shown on the in-game player list.
-     * <p>
-     * The name cannot be longer than 16 characters, but {@link ChatColor} is
-     * supported.
-     * <p>
-     * If the value is null, the name will be identical to {@link #getName()}.
-     * <p>
-     * This name is case sensitive and unique, two names with different casing
-     * will appear as two different people. If a player joins afterwards with
-     * a name that conflicts with a player's custom list name, the joining
-     * player's player list name will have a random number appended to it (1-2
-     * characters long in the default implementation). If the joining player's
-     * name is 15 or 16 characters long, part of the name will be truncated at
-     * the end to allow the addition of the two digits.
-     *
-     * @param name new player list name
-     * @throws IllegalArgumentException if the name is already used by someone
-     *     else
-     * @throws IllegalArgumentException if the length of the name is too long
-     */
-    public void setPlayerListName(String name);
-
-    /**
-     * Set the target of the player's compass.
-     *
-     * @param loc Location to point to
-     */
-    public void setCompassTarget(Location loc);
-
-    /**
-     * Get the previously set compass target.
-     *
-     * @return location of the target
-     */
-    public Location getCompassTarget();
-
-    /**
-     * Gets the socket address of this player
-     *
-     * @return the player's address
-     */
-    public InetSocketAddress getAddress();
-
-    /**
-     * Sends this sender a message raw
-     *
-     * @param message Message to be displayed
-     */
-    public void sendRawMessage(String message);
-
-    /**
-     * Kicks player with custom kick message.
-     *
-     * @param message kick message
-     */
-    public void kickPlayer(String message);
-
-    /**
-     * Says a message (or runs a command).
-     *
-     * @param msg message to print
-     */
-    public void chat(String msg);
-
-    /**
-     * Makes the player perform the given command
-     *
-     * @param command Command to perform
-     * @return true if the command was successful, otherwise false
-     */
-    public boolean performCommand(String command);
-
-    /**
-     * Returns if the player is in sneak mode
-     *
-     * @return true if player is in sneak mode
-     */
-    public boolean isSneaking();
-
-    /**
-     * Sets the sneak mode the player
-     *
-     * @param sneak true if player should appear sneaking
-     */
-    public void setSneaking(boolean sneak);
-
-    /**
-     * Gets whether the player is sprinting or not.
-     *
-     * @return true if player is sprinting.
-     */
-    public boolean isSprinting();
-
-    /**
-     * Sets whether the player is sprinting or not.
-     *
-     * @param sprinting true if the player should be sprinting
-     */
-    public void setSprinting(boolean sprinting);
-
-    /**
-     * Saves the players current location, health, inventory, motion, and
-     * other information into the username.dat file, in the world/player
-     * folder
-     */
-    public void saveData();
-
-    /**
-     * Loads the players current location, health, inventory, motion, and
-     * other information from the username.dat file, in the world/player
-     * folder.
-     * <p>
-     * Note: This will overwrite the players current inventory, health,
-     * motion, etc, with the state from the saved dat file.
-     */
-    public void loadData();
-
-    /**
-     * Sets whether the player is ignored as not sleeping. If everyone is
-     * either sleeping or has this flag set, then time will advance to the
-     * next day. If everyone has this flag set but no one is actually in bed,
-     * then nothing will happen.
-     *
-     * @param isSleeping Whether to ignore.
-     */
-    public void setSleepingIgnored(boolean isSleeping);
-
-    /**
-     * Returns whether the player is sleeping ignored.
-     *
-     * @return Whether player is ignoring sleep.
-     */
-    public boolean isSleepingIgnored();
-
-    /**
-     * Play a note for a player at a location. This requires a note block
-     * at the particular location (as far as the client is concerned). This
-     * will not work without a note block. This will not work with cake.
-     *
-     * @param loc The location of a note block.
-     * @param instrument The instrument ID.
-     * @param note The note ID.
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public void playNote(Location loc, byte instrument, byte note);
-
-    /**
-     * Play a note for a player at a location. This requires a note block
-     * at the particular location (as far as the client is concerned). This
-     * will not work without a note block. This will not work with cake.
-     *
-     * @param loc The location of a note block
-     * @param instrument The instrument
-     * @param note The note
-     */
-    public void playNote(Location loc, Instrument instrument, Note note);
-
-
-    /**
-     * Play a sound for a player at the location.
-     * <p>
-     * This function will fail silently if Location or Sound are null.
-     *
-     * @param location The location to play the sound
-     * @param sound The sound to play
-     * @param volume The volume of the sound
-     * @param pitch The pitch of the sound
-     */
-    public void playSound(Location location, Sound sound, float volume, float pitch);
-
-    /**
-     * Play a sound for a player at the location.
-     * <p>
-     * This function will fail silently if Location or Sound are null. No
-     * sound will be heard by the player if their client does not have the
-     * respective sound for the value passed.
-     *
-     * @param location the location to play the sound
-     * @param sound the internal sound name to play
-     * @param volume the volume of the sound
-     * @param pitch the pitch of the sound
-     */
-    public void playSound(Location location, String sound, float volume, float pitch);
-
-    /**
-     * Plays an effect to just this player.
-     *
-     * @param loc the location to play the effect at
-     * @param effect the {@link Effect}
-     * @param data a data bit needed for some effects
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public void playEffect(Location loc, Effect effect, int data);
-
-    /**
-     * Plays an effect to just this player.
-     *
-     * @param <T> the data based based on the type of the effect
-     * @param loc the location to play the effect at
-     * @param effect the {@link Effect}
-     * @param data a data bit needed for some effects
-     */
-    public <T> void playEffect(Location loc, Effect effect, T data);
-
-    /**
-     * Send a block change. This fakes a block change packet for a user at a
-     * certain location. This will not actually change the world in any way.
-     *
-     * @param loc The location of the changed block
-     * @param material The new block
-     * @param data The block data
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public void sendBlockChange(Location loc, Material material, byte data);
-
-    /**
-     * Send a chunk change. This fakes a chunk change packet for a user at a
-     * certain location. The updated cuboid must be entirely within a single
-     * chunk. This will not actually change the world in any way.
-     * <p>
-     * At least one of the dimensions of the cuboid must be even. The size of
-     * the data buffer must be 2.5*sx*sy*sz and formatted in accordance with
-     * the Packet51 format.
-     *
-     * @param loc The location of the cuboid
-     * @param sx The x size of the cuboid
-     * @param sy The y size of the cuboid
-     * @param sz The z size of the cuboid
-     * @param data The data to be sent
-     * @return true if the chunk change packet was sent
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public boolean sendChunkChange(Location loc, int sx, int sy, int sz, byte[] data);
-
-    /**
-     * Send a block change. This fakes a block change packet for a user at a
-     * certain location. This will not actually change the world in any way.
-     *
-     * @param loc The location of the changed block
-     * @param material The new block ID
-     * @param data The block data
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public void sendBlockChange(Location loc, int material, byte data);
-
-    /**
-     * Send a sign change. This fakes a sign change packet for a user at
-     * a certain location. This will not actually change the world in any way.
-     * This method will use a sign at the location's block or a faked sign
-     * sent via {@link #sendBlockChange(org.bukkit.Location, int, byte)} or
-     * {@link #sendBlockChange(org.bukkit.Location, org.bukkit.Material, byte)}.
-     * <p>
-     * If the client does not have a sign at the given location it will
-     * display an error message to the user.
-     *
-     * @param loc the location of the sign
-     * @param lines the new text on the sign or null to clear it
-     * @throws IllegalArgumentException if location is null
-     * @throws IllegalArgumentException if lines is non-null and has a length less than 4
-     */
-    public void sendSignChange(Location loc, String[] lines) throws IllegalArgumentException;
-
-    /**
-     * Render a map and send it to the player in its entirety. This may be
-     * used when streaming the map in the normal manner is not desirable.
-     *
-     * @param map The map to be sent
-     */
-    public void sendMap(MapView map);
-
-    /**
-     * Forces an update of the player's entire inventory.
-     *
-     * @deprecated This method should not be relied upon as it is a temporary
-     *     work-around for a larger, more complicated issue.
-     */
-    @Deprecated
-    public void updateInventory();
-
-    /**
-     * Awards the given achievement and any parent achievements that the
-     * player does not have.
-     *
-     * @param achievement Achievement to award
-     * @throws IllegalArgumentException if achievement is null
-     */
-    public void awardAchievement(Achievement achievement);
-
-    /**
-     * Removes the given achievement and any children achievements that the
-     * player has.
-     *
-     * @param achievement Achievement to remove
-     * @throws IllegalArgumentException if achievement is null
-     */
-    public void removeAchievement(Achievement achievement);
-
-    /**
-     * Gets whether this player has the given achievement.
-     *
-     * @param achievement the achievement to check
-     * @return whether the player has the achievement
-     * @throws IllegalArgumentException if achievement is null
-     */
-    public boolean hasAchievement(Achievement achievement);
-
-    /**
-     * Increments the given statistic for this player.
-     * <p>
-     * This is equivalent to the following code:
-     * <code>incrementStatistic(Statistic, 1)</code>
-     *
-     * @param statistic Statistic to increment
-     * @throws IllegalArgumentException if statistic is null
-     * @throws IllegalArgumentException if the statistic requires an
-     *     additional parameter
-     */
-    public void incrementStatistic(Statistic statistic) throws IllegalArgumentException;
-
-    /**
-     * Decrements the given statistic for this player.
-     * <p>
-     * This is equivalent to the following code:
-     * <code>decrementStatistic(Statistic, 1)</code>
-     *
-     * @param statistic Statistic to decrement
-     * @throws IllegalArgumentException if statistic is null
-     * @throws IllegalArgumentException if the statistic requires an
-     *     additional parameter
-     */
-    public void decrementStatistic(Statistic statistic) throws IllegalArgumentException;
-
-    /**
-     * Increments the given statistic for this player.
-     *
-     * @param statistic Statistic to increment
-     * @param amount Amount to increment this statistic by
-     * @throws IllegalArgumentException if statistic is null
-     * @throws IllegalArgumentException if amount is negative
-     * @throws IllegalArgumentException if the statistic requires an
-     *     additional parameter
-     */
-    public void incrementStatistic(Statistic statistic, int amount) throws IllegalArgumentException;
-
-    /**
-     * Decrements the given statistic for this player.
-     *
-     * @param statistic Statistic to decrement
-     * @param amount Amount to decrement this statistic by
-     * @throws IllegalArgumentException if statistic is null
-     * @throws IllegalArgumentException if amount is negative
-     * @throws IllegalArgumentException if the statistic requires an
-     *     additional parameter
-     */
-    public void decrementStatistic(Statistic statistic, int amount) throws IllegalArgumentException;
-
-    /**
-     * Sets the given statistic for this player.
-     *
-     * @param statistic Statistic to set
-     * @param newValue The value to set this statistic to
-     * @throws IllegalArgumentException if statistic is null
-     * @throws IllegalArgumentException if newValue is negative
-     * @throws IllegalArgumentException if the statistic requires an
-     *     additional parameter
-     */
-    public void setStatistic(Statistic statistic, int newValue) throws IllegalArgumentException;
-
-    /**
-     * Gets the value of the given statistic for this player.
-     *
-     * @param statistic Statistic to check
-     * @return the value of the given statistic
-     * @throws IllegalArgumentException if statistic is null
-     * @throws IllegalArgumentException if the statistic requires an
-     *     additional parameter
-     */
-    public int getStatistic(Statistic statistic) throws IllegalArgumentException;
-
-    /**
-     * Increments the given statistic for this player for the given material.
-     * <p>
-     * This is equivalent to the following code:
-     * <code>incrementStatistic(Statistic, Material, 1)</code>
-     *
-     * @param statistic Statistic to increment
-     * @param material Material to offset the statistic with
-     * @throws IllegalArgumentException if statistic is null
-     * @throws IllegalArgumentException if material is null
-     * @throws IllegalArgumentException if the given parameter is not valid
-     *     for the statistic
-     */
-    public void incrementStatistic(Statistic statistic, Material material) throws IllegalArgumentException;
-
-    /**
-     * Decrements the given statistic for this player for the given material.
-     * <p>
-     * This is equivalent to the following code:
-     * <code>decrementStatistic(Statistic, Material, 1)</code>
-     *
-     * @param statistic Statistic to decrement
-     * @param material Material to offset the statistic with
-     * @throws IllegalArgumentException if statistic is null
-     * @throws IllegalArgumentException if material is null
-     * @throws IllegalArgumentException if the given parameter is not valid
-     *     for the statistic
-     */
-    public void decrementStatistic(Statistic statistic, Material material) throws IllegalArgumentException;
-
-    /**
-     * Gets the value of the given statistic for this player.
-     *
-     * @param statistic Statistic to check
-     * @param material Material offset of the statistic
-     * @return the value of the given statistic
-     * @throws IllegalArgumentException if statistic is null
-     * @throws IllegalArgumentException if material is null
-     * @throws IllegalArgumentException if the given parameter is not valid
-     *     for the statistic
-     */
-    public int getStatistic(Statistic statistic, Material material) throws IllegalArgumentException;
-
-    /**
-     * Increments the given statistic for this player for the given material.
-     *
-     * @param statistic Statistic to increment
-     * @param material Material to offset the statistic with
-     * @param amount Amount to increment this statistic by
-     * @throws IllegalArgumentException if statistic is null
-     * @throws IllegalArgumentException if material is null
-     * @throws IllegalArgumentException if amount is negative
-     * @throws IllegalArgumentException if the given parameter is not valid
-     *     for the statistic
-     */
-    public void incrementStatistic(Statistic statistic, Material material, int amount) throws IllegalArgumentException;
-
-    /**
-     * Decrements the given statistic for this player for the given material.
-     *
-     * @param statistic Statistic to decrement
-     * @param material Material to offset the statistic with
-     * @param amount Amount to decrement this statistic by
-     * @throws IllegalArgumentException if statistic is null
-     * @throws IllegalArgumentException if material is null
-     * @throws IllegalArgumentException if amount is negative
-     * @throws IllegalArgumentException if the given parameter is not valid
-     *     for the statistic
-     */
-    public void decrementStatistic(Statistic statistic, Material material, int amount) throws IllegalArgumentException;
-
-    /**
-     * Sets the given statistic for this player for the given material.
-     *
-     * @param statistic Statistic to set
-     * @param material Material to offset the statistic with
-     * @param newValue The value to set this statistic to
-     * @throws IllegalArgumentException if statistic is null
-     * @throws IllegalArgumentException if material is null
-     * @throws IllegalArgumentException if newValue is negative
-     * @throws IllegalArgumentException if the given parameter is not valid
-     *     for the statistic
-     */
-    public void setStatistic(Statistic statistic, Material material, int newValue) throws IllegalArgumentException;
-
-    /**
-     * Increments the given statistic for this player for the given entity.
-     * <p>
-     * This is equivalent to the following code:
-     * <code>incrementStatistic(Statistic, EntityType, 1)</code>
-     *
-     * @param statistic Statistic to increment
-     * @param entityType EntityType to offset the statistic with
-     * @throws IllegalArgumentException if statistic is null
-     * @throws IllegalArgumentException if entityType is null
-     * @throws IllegalArgumentException if the given parameter is not valid
-     *     for the statistic
-     */
-    public void incrementStatistic(Statistic statistic, EntityType entityType) throws IllegalArgumentException;
-
-    /**
-     * Decrements the given statistic for this player for the given entity.
-     * <p>
-     * This is equivalent to the following code:
-     * <code>decrementStatistic(Statistic, EntityType, 1)</code>
-     *
-     * @param statistic Statistic to decrement
-     * @param entityType EntityType to offset the statistic with
-     * @throws IllegalArgumentException if statistic is null
-     * @throws IllegalArgumentException if entityType is null
-     * @throws IllegalArgumentException if the given parameter is not valid
-     *     for the statistic
-     */
-    public void decrementStatistic(Statistic statistic, EntityType entityType) throws IllegalArgumentException;
-
-    /**
-     * Gets the value of the given statistic for this player.
-     *
-     * @param statistic Statistic to check
-     * @param entityType EntityType offset of the statistic
-     * @return the value of the given statistic
-     * @throws IllegalArgumentException if statistic is null
-     * @throws IllegalArgumentException if entityType is null
-     * @throws IllegalArgumentException if the given parameter is not valid
-     *     for the statistic
-     */
-    public int getStatistic(Statistic statistic, EntityType entityType) throws IllegalArgumentException;
-
-    /**
-     * Increments the given statistic for this player for the given entity.
-     *
-     * @param statistic Statistic to increment
-     * @param entityType EntityType to offset the statistic with
-     * @param amount Amount to increment this statistic by
-     * @throws IllegalArgumentException if statistic is null
-     * @throws IllegalArgumentException if entityType is null
-     * @throws IllegalArgumentException if amount is negative
-     * @throws IllegalArgumentException if the given parameter is not valid
-     *     for the statistic
-     */
-    public void incrementStatistic(Statistic statistic, EntityType entityType, int amount) throws IllegalArgumentException;
-
-    /**
-     * Decrements the given statistic for this player for the given entity.
-     *
-     * @param statistic Statistic to decrement
-     * @param entityType EntityType to offset the statistic with
-     * @param amount Amount to decrement this statistic by
-     * @throws IllegalArgumentException if statistic is null
-     * @throws IllegalArgumentException if entityType is null
-     * @throws IllegalArgumentException if amount is negative
-     * @throws IllegalArgumentException if the given parameter is not valid
-     *     for the statistic
-     */
-    public void decrementStatistic(Statistic statistic, EntityType entityType, int amount);
-
-    /**
-     * Sets the given statistic for this player for the given entity.
-     *
-     * @param statistic Statistic to set
-     * @param entityType EntityType to offset the statistic with
-     * @param newValue The value to set this statistic to
-     * @throws IllegalArgumentException if statistic is null
-     * @throws IllegalArgumentException if entityType is null
-     * @throws IllegalArgumentException if newValue is negative
-     * @throws IllegalArgumentException if the given parameter is not valid
-     *     for the statistic
-     */
-    public void setStatistic(Statistic statistic, EntityType entityType, int newValue);
-
-    /**
-     * Sets the current time on the player's client. When relative is true the
-     * player's time will be kept synchronized to its world time with the
-     * specified offset.
-     * <p>
-     * When using non relative time the player's time will stay fixed at the
-     * specified time parameter. It's up to the caller to continue updating
-     * the player's time. To restore player time to normal use
-     * resetPlayerTime().
-     *
-     * @param time The current player's perceived time or the player's time
-     *     offset from the server time.
-     * @param relative When true the player time is kept relative to its world
-     *     time.
-     */
-    public void setPlayerTime(long time, boolean relative);
-
-    /**
-     * Returns the player's current timestamp.
-     *
-     * @return The player's time
-     */
-    public long getPlayerTime();
-
-    /**
-     * Returns the player's current time offset relative to server time, or
-     * the current player's fixed time if the player's time is absolute.
-     *
-     * @return The player's time
-     */
-    public long getPlayerTimeOffset();
-
-    /**
-     * Returns true if the player's time is relative to the server time,
-     * otherwise the player's time is absolute and will not change its current
-     * time unless done so with setPlayerTime().
-     *
-     * @return true if the player's time is relative to the server time.
-     */
-    public boolean isPlayerTimeRelative();
-
-    /**
-     * Restores the normal condition where the player's time is synchronized
-     * with the server time.
-     * <p>
-     * Equivalent to calling setPlayerTime(0, true).
-     */
-    public void resetPlayerTime();
-
-    /**
-     * Sets the type of weather the player will see.  When used, the weather
-     * status of the player is locked until {@link #resetPlayerWeather()} is
-     * used.
-     *
-     * @param type The WeatherType enum type the player should experience
-     */
-    public void setPlayerWeather(WeatherType type);
-
-    /**
-     * Returns the type of weather the player is currently experiencing.
-     *
-     * @return The WeatherType that the player is currently experiencing or
-     *     null if player is seeing server weather.
-     */
-    public WeatherType getPlayerWeather();
-
-    /**
-     * Restores the normal condition where the player's weather is controlled
-     * by server conditions.
-     */
-    public void resetPlayerWeather();
-
-    /**
-     * Gives the player the amount of experience specified.
-     *
-     * @param amount Exp amount to give
-     */
-    public void giveExp(int amount);
-
-    /**
-     * Gives the player the amount of experience levels specified. Levels can
-     * be taken by specifying a negative amount.
-     *
-     * @param amount amount of experience levels to give or take
-     */
-    public void giveExpLevels(int amount);
-
-    /**
-     * Gets the players current experience points towards the next level.
-     * <p>
-     * This is a percentage value. 0 is "no progress" and 1 is "next level".
-     *
-     * @return Current experience points
-     */
-    public float getExp();
-
-    /**
-     * Sets the players current experience points towards the next level
-     * <p>
-     * This is a percentage value. 0 is "no progress" and 1 is "next level".
-     *
-     * @param exp New experience points
-     */
-    public void setExp(float exp);
-
-    /**
-     * Gets the players current experience level
-     *
-     * @return Current experience level
-     */
-    public int getLevel();
-
-    /**
-     * Sets the players current experience level
-     *
-     * @param level New experience level
-     */
-    public void setLevel(int level);
-
-    /**
-     * Gets the players total experience points
-     *
-     * @return Current total experience points
-     */
-    public int getTotalExperience();
-
-    /**
-     * Sets the players current experience level
-     *
-     * @param exp New experience level
-     */
-    public void setTotalExperience(int exp);
-
-    /**
-     * Gets the players current exhaustion level.
-     * <p>
-     * Exhaustion controls how fast the food level drops. While you have a
-     * certain amount of exhaustion, your saturation will drop to zero, and
-     * then your food will drop to zero.
-     *
-     * @return Exhaustion level
-     */
-    public float getExhaustion();
-
-    /**
-     * Sets the players current exhaustion level
-     *
-     * @param value Exhaustion level
-     */
-    public void setExhaustion(float value);
-
-    /**
-     * Gets the players current saturation level.
-     * <p>
-     * Saturation is a buffer for food level. Your food level will not drop if
-     * you are saturated {@literal >} 0.
-     *
-     * @return Saturation level
-     */
-    public float getSaturation();
-
-    /**
-     * Sets the players current saturation level
-     *
-     * @param value Saturation level
-     */
-    public void setSaturation(float value);
-
-    /**
-     * Gets the players current food level
-     *
-     * @return Food level
-     */
-    public int getFoodLevel();
-
-    /**
-     * Sets the players current food level
-     *
-     * @param value New food level
-     */
-    public void setFoodLevel(int value);
-
-    /**
-     * Gets the Location where the player will spawn at their bed, null if
-     * they have not slept in one or their current bed spawn is invalid.
-     *
-     * @return Bed Spawn Location if bed exists, otherwise null.
-     */
-    public Location getBedSpawnLocation();
-
-    /**
-     * Sets the Location where the player will spawn at their bed.
-     *
-     * @param location where to set the respawn location
-     */
-    public void setBedSpawnLocation(Location location);
-
-    /**
-     * Sets the Location where the player will spawn at their bed.
-     *
-     * @param location where to set the respawn location
-     * @param force whether to forcefully set the respawn location even if a
-     *     valid bed is not present
-     */
-    public void setBedSpawnLocation(Location location, boolean force);
-
-    /**
-     * Determines if the Player is allowed to fly via jump key double-tap like
-     * in creative mode.
-     *
-     * @return True if the player is allowed to fly.
-     */
-    public boolean getAllowFlight();
-
-    /**
-     * Sets if the Player is allowed to fly via jump key double-tap like in
-     * creative mode.
-     *
-     * @param flight If flight should be allowed.
-     */
-    public void setAllowFlight(boolean flight);
-
-    /**
-     * Hides a player from this player
-     *
-     * @param player Player to hide
-     */
-    public void hidePlayer(Player player);
-
-    /**
-     * Allows this player to see a player that was previously hidden
-     *
-     * @param player Player to show
-     */
-    public void showPlayer(Player player);
-
-    /**
-     * Checks to see if a player has been hidden from this player
-     *
-     * @param player Player to check
-     * @return True if the provided player is not being hidden from this
-     *     player
-     */
-    public boolean canSee(Player player);
-
-    /**
-     * Checks to see if this player is currently standing on a block. This
-     * information may not be reliable, as it is a state provided by the
-     * client, and may therefore not be accurate.
-     *
-     * @return True if the player standing on a solid block, else false.
-     * @deprecated Inconsistent with {@link
-     *     org.bukkit.entity.Entity#isOnGround()}
-     */
-    @Deprecated
-    public boolean isOnGround();
-
-    /**
-     * Checks to see if this player is currently flying or not.
-     *
-     * @return True if the player is flying, else false.
-     */
-    public boolean isFlying();
-
-    /**
-     * Makes this player start or stop flying.
-     *
-     * @param value True to fly.
-     */
-    public void setFlying(boolean value);
-
-    /**
-     * Sets the speed at which a client will fly. Negative values indicate
-     * reverse directions.
-     *
-     * @param value The new speed, from -1 to 1.
-     * @throws IllegalArgumentException If new speed is less than -1 or
-     *     greater than 1
-     */
-    public void setFlySpeed(float value) throws IllegalArgumentException;
-
-    /**
-     * Sets the speed at which a client will walk. Negative values indicate
-     * reverse directions.
-     *
-     * @param value The new speed, from -1 to 1.
-     * @throws IllegalArgumentException If new speed is less than -1 or
-     *     greater than 1
-     */
-    public void setWalkSpeed(float value) throws IllegalArgumentException;
-
-    /**
-     * Gets the current allowed speed that a client can fly.
-     *
-     * @return The current allowed speed, from -1 to 1
-     */
-    public float getFlySpeed();
-
-    /**
-     * Gets the current allowed speed that a client can walk.
-     *
-     * @return The current allowed speed, from -1 to 1
-     */
-    public float getWalkSpeed();
-
-    /**
-     * Request that the player's client download and switch texture packs.
-     * <p>
-     * The player's client will download the new texture pack asynchronously
-     * in the background, and will automatically switch to it once the
-     * download is complete. If the client has downloaded and cached the same
-     * texture pack in the past, it will perform a quick timestamp check over
-     * the network to determine if the texture pack has changed and needs to
-     * be downloaded again. When this request is sent for the very first time
-     * from a given server, the client will first display a confirmation GUI
-     * to the player before proceeding with the download.
-     * <p>
-     * Notes:
-     * <ul>
-     * <li>Players can disable server textures on their client, in which
-     *     case this method will have no affect on them.
-     * <li>There is no concept of resetting texture packs back to default
-     *     within Minecraft, so players will have to relog to do so.
-     * </ul>
-     *
-     * @param url The URL from which the client will download the texture
-     *     pack. The string must contain only US-ASCII characters and should
-     *     be encoded as per RFC 1738.
-     * @throws IllegalArgumentException Thrown if the URL is null.
-     * @throws IllegalArgumentException Thrown if the URL is too long.
-     * @deprecated Minecraft no longer uses textures packs. Instead you
-     *     should use {@link #setResourcePack(String)}.
-     */
-    @Deprecated
-    public void setTexturePack(String url);
-
-    /**
-     * Request that the player's client download and switch resource packs.
-     * <p>
-     * The player's client will download the new resource pack asynchronously
-     * in the background, and will automatically switch to it once the
-     * download is complete. If the client has downloaded and cached the same
-     * resource pack in the past, it will perform a quick timestamp check
-     * over the network to determine if the resource pack has changed and
-     * needs to be downloaded again. When this request is sent for the very
-     * first time from a given server, the client will first display a
-     * confirmation GUI to the player before proceeding with the download.
-     * <p>
-     * Notes:
-     * <ul>
-     * <li>Players can disable server resources on their client, in which
-     *     case this method will have no affect on them.
-     * <li>There is no concept of resetting resource packs back to default
-     *     within Minecraft, so players will have to relog to do so.
-     * </ul>
-     *
-     * @param url The URL from which the client will download the resource
-     *     pack. The string must contain only US-ASCII characters and should
-     *     be encoded as per RFC 1738.
-     * @throws IllegalArgumentException Thrown if the URL is null.
-     * @throws IllegalArgumentException Thrown if the URL is too long. The
-     *     length restriction is an implementation specific arbitrary value.
-     */
-    public void setResourcePack(String url);
-
-    /**
-     * Gets the Scoreboard displayed to this player
-     *
-     * @return The current scoreboard seen by this player
-     */
-    public Scoreboard getScoreboard();
-
-    /**
-     * Sets the player's visible Scoreboard.
-     *
-     * @param scoreboard New Scoreboard for the player
-     * @throws IllegalArgumentException if scoreboard is null
-     * @throws IllegalArgumentException if scoreboard was not created by the
-     *     {@link org.bukkit.scoreboard.ScoreboardManager scoreboard manager}
-     * @throws IllegalStateException if this is a player that is not logged
-     *     yet or has logged out
-     */
-    public void setScoreboard(Scoreboard scoreboard) throws IllegalArgumentException, IllegalStateException;
-
-    /**
-     * Gets if the client is displayed a 'scaled' health, that is, health on a
-     * scale from 0-{@link #getHealthScale()}.
-     *
-     * @return if client health display is scaled
-     * @see Player#setHealthScaled(boolean)
-     */
-    public boolean isHealthScaled();
-
-    /**
-     * Sets if the client is displayed a 'scaled' health, that is, health on a
-     * scale from 0-{@link #getHealthScale()}.
-     * <p>
-     * Displayed health follows a simple formula <code>displayedHealth =
-     * getHealth() / getMaxHealth() * getHealthScale()</code>.
-     *
-     * @param scale if the client health display is scaled
-     */
-    public void setHealthScaled(boolean scale);
-
-    /**
-     * Sets the number to scale health to for the client; this will also
-     * {@link #setHealthScaled(boolean) setHealthScaled(true)}.
-     * <p>
-     * Displayed health follows a simple formula <code>displayedHealth =
-     * getHealth() / getMaxHealth() * getHealthScale()</code>.
-     *
-     * @param scale the number to scale health to
-     * @throws IllegalArgumentException if scale is &lt;0
-     * @throws IllegalArgumentException if scale is {@link Double#NaN}
-     * @throws IllegalArgumentException if scale is too high
-     */
-    public void setHealthScale(double scale) throws IllegalArgumentException;
-
-    /**
-     * Gets the number that health is scaled to for the client.
-     *
-     * @return the number that health would be scaled to for the client if
-     *     HealthScaling is set to true
-     * @see Player#setHealthScale(double)
-     * @see Player#setHealthScaled(boolean)
-     */
-    public double getHealthScale();
-
-    /**
-     * Gets the entity which is followed by the camera when in
-     * {@link GameMode#SPECTATOR}.
-     *
-     * @return the followed entity, or null if not in spectator mode or not
-     * following a specific entity.
-     */
-    public Entity getSpectatorTarget();
-
-    /**
-     * Sets the entity which is followed by the camera when in
-     * {@link GameMode#SPECTATOR}.
-     *
-     * @param entity the entity to follow or null to reset
-     * @throws IllegalStateException if the player is not in
-     * {@link GameMode#SPECTATOR}
-     */
-    public void setSpectatorTarget(Entity entity);
-
-    /**
-     * Sends a title and a subtitle message to the player. If either of these
-     * values are null, they will not be sent and the display will remain
-     * unchanged. If they are empty strings, the display will be updated as
-     * such. If the strings contain a new line, only the first line will be
-     * sent.
-     *
-     * @param title Title text
-     * @param subtitle Subtitle text
-     * @deprecated API subject to change
-     */
-    @Deprecated
-    public void sendTitle(String title, String subtitle);
-
-    /**
-     * Resets the title displayed to the player.
-     * @deprecated API subject to change.
-     */
-    @Deprecated
-    public void resetTitle();
-
-
-    /**
-     * Spawns the particle (the number of times specified by count)
-     * at the target location.
-     *
-     * @param particle the particle to spawn
-     * @param location the location to spawn at
-     * @param count the number of particles
-     */
-    public void spawnParticle(Particle particle, Location location, int count);
-
-    /**
-     * Spawns the particle (the number of times specified by count)
-     * at the target location.
-     *
-     * @param particle the particle to spawn
-     * @param x the position on the x axis to spawn at
-     * @param y the position on the y axis to spawn at
-     * @param z the position on the z axis to spawn at
-     * @param count the number of particles
-     */
-    public void spawnParticle(Particle particle, double x, double y, double z, int count);
-
-    /**
-     * Spawns the particle (the number of times specified by count)
-     * at the target location.
-     *
-     * @param particle the particle to spawn
-     * @param location the location to spawn at
-     * @param count the number of particles
-     * @param data the data to use for the particle or null,
-     *             the type of this depends on {@link Particle#getDataType()}
-     */
-    public <T> void spawnParticle(Particle particle, Location location, int count, T data);
-
-
-    /**
-     * Spawns the particle (the number of times specified by count)
-     * at the target location.
-     *
-     * @param particle the particle to spawn
-     * @param x the position on the x axis to spawn at
-     * @param y the position on the y axis to spawn at
-     * @param z the position on the z axis to spawn at
-     * @param count the number of particles
-     * @param data the data to use for the particle or null,
-     *             the type of this depends on {@link Particle#getDataType()}
-     */
-    public <T> void spawnParticle(Particle particle, double x, double y, double z, int count, T data);
-
-    /**
-     * Spawns the particle (the number of times specified by count)
-     * at the target location. The position of each particle will be
-     * randomized positively and negatively by the offset parameters
-     * on each axis.
-     *
-     * @param particle the particle to spawn
-     * @param location the location to spawn at
-     * @param count the number of particles
-     * @param offsetX the maximum random offset on the X axis
-     * @param offsetY the maximum random offset on the Y axis
-     * @param offsetZ the maximum random offset on the Z axis
-     */
-    public void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ);
-
-    /**
-     * Spawns the particle (the number of times specified by count)
-     * at the target location. The position of each particle will be
-     * randomized positively and negatively by the offset parameters
-     * on each axis.
-     *
-     * @param particle the particle to spawn
-     * @param x the position on the x axis to spawn at
-     * @param y the position on the y axis to spawn at
-     * @param z the position on the z axis to spawn at
-     * @param count the number of particles
-     * @param offsetX the maximum random offset on the X axis
-     * @param offsetY the maximum random offset on the Y axis
-     * @param offsetZ the maximum random offset on the Z axis
-     */
-    public void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ);
-
-    /**
-     * Spawns the particle (the number of times specified by count)
-     * at the target location. The position of each particle will be
-     * randomized positively and negatively by the offset parameters
-     * on each axis.
-     *
-     * @param particle the particle to spawn
-     * @param location the location to spawn at
-     * @param count the number of particles
-     * @param offsetX the maximum random offset on the X axis
-     * @param offsetY the maximum random offset on the Y axis
-     * @param offsetZ the maximum random offset on the Z axis
-     * @param data the data to use for the particle or null,
-     *             the type of this depends on {@link Particle#getDataType()}
-     */
-    public <T> void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ, T data);
-
-    /**
-     * Spawns the particle (the number of times specified by count)
-     * at the target location. The position of each particle will be
-     * randomized positively and negatively by the offset parameters
-     * on each axis.
-     *
-     * @param particle the particle to spawn
-     * @param x the position on the x axis to spawn at
-     * @param y the position on the y axis to spawn at
-     * @param z the position on the z axis to spawn at
-     * @param count the number of particles
-     * @param offsetX the maximum random offset on the X axis
-     * @param offsetY the maximum random offset on the Y axis
-     * @param offsetZ the maximum random offset on the Z axis
-     * @param data the data to use for the particle or null,
-     *             the type of this depends on {@link Particle#getDataType()}
-     */
-    public <T> void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ, T data);
-
-    /**
-     * Spawns the particle (the number of times specified by count)
-     * at the target location. The position of each particle will be
-     * randomized positively and negatively by the offset parameters
-     * on each axis.
-     *
-     * @param particle the particle to spawn
-     * @param location the location to spawn at
-     * @param count the number of particles
-     * @param offsetX the maximum random offset on the X axis
-     * @param offsetY the maximum random offset on the Y axis
-     * @param offsetZ the maximum random offset on the Z axis
-     * @param extra the extra data for this particle, depends on the
-     *              particle used (normally speed)
-     */
-    public void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ, double extra);
-
-    /**
-     * Spawns the particle (the number of times specified by count)
-     * at the target location. The position of each particle will be
-     * randomized positively and negatively by the offset parameters
-     * on each axis.
-     *
-     * @param particle the particle to spawn
-     * @param x the position on the x axis to spawn at
-     * @param y the position on the y axis to spawn at
-     * @param z the position on the z axis to spawn at
-     * @param count the number of particles
-     * @param offsetX the maximum random offset on the X axis
-     * @param offsetY the maximum random offset on the Y axis
-     * @param offsetZ the maximum random offset on the Z axis
-     * @param extra the extra data for this particle, depends on the
-     *              particle used (normally speed)
-     */
-    public void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ, double extra);
-
-    /**
-     * Spawns the particle (the number of times specified by count)
-     * at the target location. The position of each particle will be
-     * randomized positively and negatively by the offset parameters
-     * on each axis.
-     *
-     * @param particle the particle to spawn
-     * @param location the location to spawn at
-     * @param count the number of particles
-     * @param offsetX the maximum random offset on the X axis
-     * @param offsetY the maximum random offset on the Y axis
-     * @param offsetZ the maximum random offset on the Z axis
-     * @param extra the extra data for this particle, depends on the
-     *              particle used (normally speed)
-     * @param data the data to use for the particle or null,
-     *             the type of this depends on {@link Particle#getDataType()}
-     */
-    public <T> void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ, double extra, T data);
-
-    /**
-     * Spawns the particle (the number of times specified by count)
-     * at the target location. The position of each particle will be
-     * randomized positively and negatively by the offset parameters
-     * on each axis.
-     *
-     * @param particle the particle to spawn
-     * @param x the position on the x axis to spawn at
-     * @param y the position on the y axis to spawn at
-     * @param z the position on the z axis to spawn at
-     * @param count the number of particles
-     * @param offsetX the maximum random offset on the X axis
-     * @param offsetY the maximum random offset on the Y axis
-     * @param offsetZ the maximum random offset on the Z axis
-     * @param extra the extra data for this particle, depends on the
-     *              particle used (normally speed)
-     * @param data the data to use for the particle or null,
-     *             the type of this depends on {@link Particle#getDataType()}
-     */
-    public <T> void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ, double extra, T data);
-	
-	// Paper start
-   /**
-    * Return this player's profile
-    *
-    * @return this player's profile
-    */
-   @Override
-   public AccountProfile getAccount();
-   // Paper end
-
-}
diff --git a/src/main/java/org/bukkit/entity/PoweredMinecart.java b/src/main/java/org/bukkit/entity/PoweredMinecart.java
deleted file mode 100644
index 38240a9..0000000
--- a/src/main/java/org/bukkit/entity/PoweredMinecart.java
+++ /dev/null
@@ -1,9 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * @deprecated This class has been moved into a sub package; {@link
- * org.bukkit.entity.minecart.PoweredMinecart} should be used instead.
- * @see org.bukkit.entity.minecart.PoweredMinecart
- */
-@Deprecated
-public interface PoweredMinecart extends org.bukkit.entity.minecart.PoweredMinecart {}
diff --git a/src/main/java/org/bukkit/entity/Projectile.java b/src/main/java/org/bukkit/entity/Projectile.java
deleted file mode 100644
index a5599fa..0000000
--- a/src/main/java/org/bukkit/entity/Projectile.java
+++ /dev/null
@@ -1,60 +0,0 @@
-package org.bukkit.entity;
-
-import org.bukkit.projectiles.ProjectileSource;
-
-/**
- * Represents a shootable entity.
- */
-public interface Projectile extends Entity {
-
-    /**
-     * This method exists for legacy reasons to provide backwards
-     * compatibility. It will not exist at runtime and should not be used
-     * under any circumstances.
-     *
-     * @return the {@link LivingEntity} that shot this projectile
-     */
-    @Deprecated
-    public LivingEntity _INVALID_getShooter();
-
-    /**
-     * Retrieve the shooter of this projectile.
-     *
-     * @return the {@link ProjectileSource} that shot this projectile
-     */
-    public ProjectileSource getShooter();
-
-    /**
-     * This method exists for legacy reasons to provide backwards
-     * compatibility. It will not exist at runtime and should not be used
-     * under any circumstances.
-     *
-     * @param shooter the {@link LivingEntity} that shot this projectile
-     */
-    @Deprecated
-    public void _INVALID_setShooter(LivingEntity shooter);
-
-    /**
-     * Set the shooter of this projectile.
-     *
-     * @param source the {@link ProjectileSource} that shot this projectile
-     */
-    public void setShooter(ProjectileSource source);
-
-    /**
-     * Determine if this projectile should bounce or not when it hits.
-     * <p>
-     * If a small fireball does not bounce it will set the target on fire.
-     *
-     * @return true if it should bounce.
-     */
-    public boolean doesBounce();
-
-    /**
-     * Set whether or not this projectile should bounce or not when it hits
-     * something.
-     *
-     * @param doesBounce whether or not it should bounce.
-     */
-    public void setBounce(boolean doesBounce);
-}
diff --git a/src/main/java/org/bukkit/entity/Rabbit.java b/src/main/java/org/bukkit/entity/Rabbit.java
deleted file mode 100644
index 1c8d1fc..0000000
--- a/src/main/java/org/bukkit/entity/Rabbit.java
+++ /dev/null
@@ -1,49 +0,0 @@
-package org.bukkit.entity;
-
-public interface Rabbit extends Animals {
-
-    /**
-     * @return The type of rabbit.
-     */
-    public Type getRabbitType();
-
-    /**
-     * @param type Sets the type of rabbit for this entity.
-     */
-    public void setRabbitType(Type type);
-
-    /**
-     * Represents the various types a Rabbit might be.
-     */
-    public enum Type {
-
-        /**
-         * Chocolate colored rabbit.
-         */
-        BROWN,
-        /**
-         * Pure white rabbit.
-         */
-        WHITE,
-        /**
-         * Black rabbit.
-         */
-        BLACK,
-        /**
-         * Black with white patches, or white with black patches?
-         */
-        BLACK_AND_WHITE,
-        /**
-         * Golden bunny.
-         */
-        GOLD,
-        /**
-         * Salt and pepper colored, whatever that means.
-         */
-        SALT_AND_PEPPER,
-        /**
-         * Rabbit with pure white fur, blood red horizontal eyes, and is hostile to players.
-         */
-        THE_KILLER_BUNNY
-    }
-}
diff --git a/src/main/java/org/bukkit/entity/Sheep.java b/src/main/java/org/bukkit/entity/Sheep.java
deleted file mode 100644
index f4ce312..0000000
--- a/src/main/java/org/bukkit/entity/Sheep.java
+++ /dev/null
@@ -1,19 +0,0 @@
-package org.bukkit.entity;
-
-import org.bukkit.material.Colorable;
-
-/**
- * Represents a Sheep.
- */
-public interface Sheep extends Animals, Colorable {
-
-    /**
-     * @return Whether the sheep is sheared.
-     */
-    public boolean isSheared();
-
-    /**
-     * @param flag Whether to shear the sheep
-     */
-    public void setSheared(boolean flag);
-}
diff --git a/src/main/java/org/bukkit/entity/Shulker.java b/src/main/java/org/bukkit/entity/Shulker.java
deleted file mode 100644
index 92218cd..0000000
--- a/src/main/java/org/bukkit/entity/Shulker.java
+++ /dev/null
@@ -1,3 +0,0 @@
-package org.bukkit.entity;
-
-public interface Shulker extends Golem {}
diff --git a/src/main/java/org/bukkit/entity/ShulkerBullet.java b/src/main/java/org/bukkit/entity/ShulkerBullet.java
deleted file mode 100644
index f285c0a..0000000
--- a/src/main/java/org/bukkit/entity/ShulkerBullet.java
+++ /dev/null
@@ -1,18 +0,0 @@
-package org.bukkit.entity;
-
-public interface ShulkerBullet extends Projectile {
-
-    /**
-     * Retrieve the target of this bullet.
-     *
-     * @return the targeted entity
-     */
-    Entity getTarget();
-
-    /**
-     * Sets the target of this bullet
-     *
-     * @param target the entity to target
-     */
-    void setTarget(Entity target);
-}
diff --git a/src/main/java/org/bukkit/entity/Silverfish.java b/src/main/java/org/bukkit/entity/Silverfish.java
deleted file mode 100644
index fe01007..0000000
--- a/src/main/java/org/bukkit/entity/Silverfish.java
+++ /dev/null
@@ -1,6 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * Represents a Silverfish.
- */
-public interface Silverfish extends Monster {}
diff --git a/src/main/java/org/bukkit/entity/Skeleton.java b/src/main/java/org/bukkit/entity/Skeleton.java
deleted file mode 100644
index 02b76c3..0000000
--- a/src/main/java/org/bukkit/entity/Skeleton.java
+++ /dev/null
@@ -1,65 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * Represents a Skeleton.
- */
-public interface Skeleton extends Monster {
-
-    /**
-     * Gets the current type of this skeleton.
-     *
-     * @return Current type
-     */
-    public SkeletonType getSkeletonType();
-
-    /**
-     * Sets the new type of this skeleton.
-     *
-     * @param type New type
-     */
-    public void setSkeletonType(SkeletonType type);
-
-    /*
-     * Represents the various different Skeleton types.
-     */
-    public enum SkeletonType {
-        NORMAL(0),
-        WITHER(1);
-
-        private static final SkeletonType[] types = new SkeletonType[SkeletonType.values().length];
-        private final int id;
-
-        static {
-            for (SkeletonType type : values()) {
-                types[type.getId()] = type;
-            }
-        }
-
-        private SkeletonType(int id) {
-            this.id = id;
-        }
-
-        /**
-         * Gets the ID of this skeleton type.
-         *
-         * @return Skeleton type ID
-         * @deprecated Magic value
-         */
-        @Deprecated
-        public int getId() {
-            return id;
-        }
-
-        /**
-         * Gets a skeleton type by its ID.
-         *
-         * @param id ID of the skeleton type to get.
-         * @return Resulting skeleton type, or null if not found.
-         * @deprecated Magic value
-         */
-        @Deprecated
-        public static SkeletonType getType(int id) {
-            return (id >= types.length) ? null : types[id];
-        }
-    }
-}
diff --git a/src/main/java/org/bukkit/entity/Slime.java b/src/main/java/org/bukkit/entity/Slime.java
deleted file mode 100644
index cbf50c8..0000000
--- a/src/main/java/org/bukkit/entity/Slime.java
+++ /dev/null
@@ -1,17 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * Represents a Slime.
- */
-public interface Slime extends LivingEntity {
-
-    /**
-     * @return The size of the slime
-     */
-    public int getSize();
-
-    /**
-     * @param sz The new size of the slime.
-     */
-    public void setSize(int sz);
-}
diff --git a/src/main/java/org/bukkit/entity/SmallFireball.java b/src/main/java/org/bukkit/entity/SmallFireball.java
deleted file mode 100644
index 33f54d3..0000000
--- a/src/main/java/org/bukkit/entity/SmallFireball.java
+++ /dev/null
@@ -1,8 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * Represents a small {@link Fireball}
- */
-public interface SmallFireball extends Fireball {
-
-}
diff --git a/src/main/java/org/bukkit/entity/Snowball.java b/src/main/java/org/bukkit/entity/Snowball.java
deleted file mode 100644
index 8c6b433..0000000
--- a/src/main/java/org/bukkit/entity/Snowball.java
+++ /dev/null
@@ -1,6 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * Represents a snowball.
- */
-public interface Snowball extends Projectile {}
diff --git a/src/main/java/org/bukkit/entity/Snowman.java b/src/main/java/org/bukkit/entity/Snowman.java
deleted file mode 100644
index 818efe2..0000000
--- a/src/main/java/org/bukkit/entity/Snowman.java
+++ /dev/null
@@ -1,24 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * Represents a snowman entity
- */
-public interface Snowman extends Golem {
-
-    /**
-     * Gets whether this snowman is in "derp mode", meaning it is not wearing a
-     * pumpkin.
-     *
-     * @return True if the snowman is bald, false if it is wearing a pumpkin
-     */
-    boolean isDerp();
-
-    /**
-     * Sets whether this snowman is in "derp mode", meaning it is not wearing a
-     * pumpkin. NOTE: This value is not persisted to disk and will therefore
-     * reset when the chunk is reloaded.
-     *
-     * @param derpMode True to remove the pumpkin, false to add a pumpkin
-     */
-    void setDerp(boolean derpMode);
-}
diff --git a/src/main/java/org/bukkit/entity/SpectralArrow.java b/src/main/java/org/bukkit/entity/SpectralArrow.java
deleted file mode 100644
index 1a32341..0000000
--- a/src/main/java/org/bukkit/entity/SpectralArrow.java
+++ /dev/null
@@ -1,22 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * Represents a spectral arrow.
- */
-public interface SpectralArrow extends Arrow {
-
-    /**
-     * Returns the amount of time that this arrow will apply
-     * the glowing effect for.
-     * 
-     * @return the glowing effect ticks
-     */
-    int getGlowingTicks();
-
-    /**
-     * Sets the amount of time to apply the glowing effect for.
-     * 
-     * @param duration the glowing effect ticks
-     */
-    void setGlowingTicks(int duration);
-}
diff --git a/src/main/java/org/bukkit/entity/Spider.java b/src/main/java/org/bukkit/entity/Spider.java
deleted file mode 100644
index f9ee8cc..0000000
--- a/src/main/java/org/bukkit/entity/Spider.java
+++ /dev/null
@@ -1,6 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * Represents a Spider.
- */
-public interface Spider extends Monster {}
diff --git a/src/main/java/org/bukkit/entity/SplashPotion.java b/src/main/java/org/bukkit/entity/SplashPotion.java
deleted file mode 100644
index 2a21025..0000000
--- a/src/main/java/org/bukkit/entity/SplashPotion.java
+++ /dev/null
@@ -1,6 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * Represents a thrown splash potion bottle
- */
-public interface SplashPotion extends ThrownPotion { }
diff --git a/src/main/java/org/bukkit/entity/Squid.java b/src/main/java/org/bukkit/entity/Squid.java
deleted file mode 100644
index fb47968..0000000
--- a/src/main/java/org/bukkit/entity/Squid.java
+++ /dev/null
@@ -1,6 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * Represents a Squid.
- */
-public interface Squid extends WaterMob {}
diff --git a/src/main/java/org/bukkit/entity/StorageMinecart.java b/src/main/java/org/bukkit/entity/StorageMinecart.java
deleted file mode 100644
index 5436d70..0000000
--- a/src/main/java/org/bukkit/entity/StorageMinecart.java
+++ /dev/null
@@ -1,9 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * @deprecated This class has been moved into a sub package; {@link
- * org.bukkit.entity.minecart.StorageMinecart} should be used instead.
- * @see org.bukkit.entity.minecart.StorageMinecart
- */
-@Deprecated
-public interface StorageMinecart extends org.bukkit.entity.minecart.StorageMinecart {}
diff --git a/src/main/java/org/bukkit/entity/TNTPrimed.java b/src/main/java/org/bukkit/entity/TNTPrimed.java
deleted file mode 100644
index 3ce322d..0000000
--- a/src/main/java/org/bukkit/entity/TNTPrimed.java
+++ /dev/null
@@ -1,38 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * Represents a Primed TNT.
- */
-public interface TNTPrimed extends Explosive {
-
-    /**
-     * Set the number of ticks until the TNT blows up after being primed.
-     *
-     * @param fuseTicks The fuse ticks
-     */
-    public void setFuseTicks(int fuseTicks);
-
-    /**
-     * Retrieve the number of ticks until the explosion of this TNTPrimed
-     * entity
-     *
-     * @return the number of ticks until this TNTPrimed explodes
-     */
-    public int getFuseTicks();
-
-    /**
-     * Gets the source of this primed TNT. The source is the entity
-     * responsible for the creation of this primed TNT. (I.E. player ignites
-     * TNT with flint and steel.) Take note that this can be null if there is
-     * no suitable source. (created by the {@link
-     * org.bukkit.World#spawn(Location, Class)} method, for example.)
-     * <p>
-     * The source will become null if the chunk this primed TNT is in is
-     * unloaded then reloaded. If the source Entity becomes invalidated for
-     * any reason, such being removed from the world, the returned value will
-     * be null.
-     *
-     * @return the source of this primed TNT
-     */
-    public Entity getSource();
-}
diff --git a/src/main/java/org/bukkit/entity/Tameable.java b/src/main/java/org/bukkit/entity/Tameable.java
deleted file mode 100644
index 014885d..0000000
--- a/src/main/java/org/bukkit/entity/Tameable.java
+++ /dev/null
@@ -1,44 +0,0 @@
-package org.bukkit.entity;
-
-public interface Tameable {
-
-    /**
-     * Check if this is tamed
-     * <p>
-     * If something is tamed then a player can not tame it through normal
-     * methods, even if it does not belong to anyone in particular.
-     *
-     * @return true if this has been tamed
-     */
-    public boolean isTamed();
-
-    /**
-     * Sets if this has been tamed. Not necessary if the method setOwner has
-     * been used, as it tames automatically.
-     * <p>
-     * If something is tamed then a player can not tame it through normal
-     * methods, even if it does not belong to anyone in particular.
-     *
-     * @param tame true if tame
-     */
-    public void setTamed(boolean tame);
-
-    /**
-     * Gets the current owning AnimalTamer
-     *
-     * @return the owning AnimalTamer, or null if not owned
-     */
-    public AnimalTamer getOwner();
-
-    /**
-     * Set this to be owned by given AnimalTamer.
-     * <p>
-     * If the owner is not null, this will be tamed and will have any current
-     * path it is following removed. If the owner is set to null, this will be
-     * untamed, and the current owner removed.
-     *
-     * @param tamer the AnimalTamer who should own this
-     */
-    public void setOwner(AnimalTamer tamer);
-
-}
diff --git a/src/main/java/org/bukkit/entity/ThrownExpBottle.java b/src/main/java/org/bukkit/entity/ThrownExpBottle.java
deleted file mode 100644
index 671282e..0000000
--- a/src/main/java/org/bukkit/entity/ThrownExpBottle.java
+++ /dev/null
@@ -1,8 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * Represents a thrown Experience bottle.
- */
-public interface ThrownExpBottle extends Projectile {
-
-}
diff --git a/src/main/java/org/bukkit/entity/ThrownPotion.java b/src/main/java/org/bukkit/entity/ThrownPotion.java
deleted file mode 100644
index 81dcecb..0000000
--- a/src/main/java/org/bukkit/entity/ThrownPotion.java
+++ /dev/null
@@ -1,41 +0,0 @@
-package org.bukkit.entity;
-
-import java.util.Collection;
-
-import org.bukkit.inventory.ItemStack;
-import org.bukkit.potion.PotionEffect;
-
-/**
- * Represents a thrown potion bottle
- */
-public interface ThrownPotion extends Projectile {
-
-    /**
-     * Returns the effects that are applied by this potion.
-     *
-     * @return The potion effects
-     */
-    public Collection<PotionEffect> getEffects();
-
-    /**
-     * Returns a copy of the ItemStack for this thrown potion.
-     * <p>
-     * Altering this copy will not alter the thrown potion directly. If you want
-     * to alter the thrown potion, you must use the {@link
-     * #setItem(ItemStack) setItemStack} method.
-     *
-     * @return A copy of the ItemStack for this thrown potion.
-     */
-    public ItemStack getItem();
-
-    /**
-     * Set the ItemStack for this thrown potion.
-     * <p>
-     * The ItemStack must be of type {@link org.bukkit.Material#SPLASH_POTION}
-     * or {@link org.bukkit.Material#LINGERING_POTION}, otherwise an exception
-     * is thrown.
-     *
-     * @param item New ItemStack
-     */
-    public void setItem(ItemStack item);
-}
diff --git a/src/main/java/org/bukkit/entity/TippedArrow.java b/src/main/java/org/bukkit/entity/TippedArrow.java
deleted file mode 100644
index 8666617..0000000
--- a/src/main/java/org/bukkit/entity/TippedArrow.java
+++ /dev/null
@@ -1,78 +0,0 @@
-package org.bukkit.entity;
-
-import java.util.List;
-
-import org.bukkit.potion.PotionData;
-import org.bukkit.potion.PotionEffect;
-import org.bukkit.potion.PotionEffectType;
-
-public interface TippedArrow extends Arrow {
-
-    /**
-     * Sets the underlying potion data
-     *
-     * @param data PotionData to set the base potion state to
-     */
-    void setBasePotionData(PotionData data);
-
-    /**
-     * Returns the potion data about the base potion
-     *
-     * @return a PotionData object
-     */
-    PotionData getBasePotionData();
-
-    /**
-     * Checks for the presence of custom potion effects.
-     *
-     * @return true if custom potion effects are applied
-     */
-    boolean hasCustomEffects();
-
-    /**
-     * Gets an immutable list containing all custom potion effects applied to
-     * this arrow.
-     * <p>
-     * Plugins should check that hasCustomEffects() returns true before calling
-     * this method.
-     *
-     * @return the immutable list of custom potion effects
-     */
-    List<PotionEffect> getCustomEffects();
-
-    /**
-     * Adds a custom potion effect to this arrow.
-     *
-     * @param effect the potion effect to add
-     * @param overwrite true if any existing effect of the same type should be
-     * overwritten
-     * @return true if the effect was added as a result of this call
-     */
-    boolean addCustomEffect(PotionEffect effect, boolean overwrite);
-
-    /**
-     * Removes a custom potion effect from this arrow.
-     *
-     * @param type the potion effect type to remove
-     * @return true if the an effect was removed as a result of this call
-     * @throws IllegalArgumentException if this operation would leave the Arrow
-     * in a state with no Custom Effects and PotionType.UNCRAFTABLE
-     */
-    boolean removeCustomEffect(PotionEffectType type);
-
-    /**
-     * Checks for a specific custom potion effect type on this arrow.
-     *
-     * @param type the potion effect type to check for
-     * @return true if the potion has this effect
-     */
-    boolean hasCustomEffect(PotionEffectType type);
-
-    /**
-     * Removes all custom potion effects from this arrow.
-     *
-     * @throws IllegalArgumentException if this operation would leave the Arrow
-     * in a state with no Custom Effects and PotionType.UNCRAFTABLE
-     */
-    void clearCustomEffects();
-}
diff --git a/src/main/java/org/bukkit/entity/Vehicle.java b/src/main/java/org/bukkit/entity/Vehicle.java
deleted file mode 100644
index 7d7607c..0000000
--- a/src/main/java/org/bukkit/entity/Vehicle.java
+++ /dev/null
@@ -1,23 +0,0 @@
-package org.bukkit.entity;
-
-import org.bukkit.util.Vector;
-
-/**
- * Represents a vehicle entity.
- */
-public interface Vehicle extends Entity {
-
-    /**
-     * Gets the vehicle's velocity.
-     *
-     * @return velocity vector
-     */
-    public Vector getVelocity();
-
-    /**
-     * Sets the vehicle's velocity.
-     *
-     * @param vel velocity vector
-     */
-    public void setVelocity(Vector vel);
-}
diff --git a/src/main/java/org/bukkit/entity/Villager.java b/src/main/java/org/bukkit/entity/Villager.java
deleted file mode 100644
index 6d62079..0000000
--- a/src/main/java/org/bukkit/entity/Villager.java
+++ /dev/null
@@ -1,158 +0,0 @@
-package org.bukkit.entity;
-
-import java.util.List;
-import org.bukkit.inventory.Inventory;
-import org.bukkit.inventory.InventoryHolder;
-import org.bukkit.inventory.MerchantRecipe;
-
-/**
- * Represents a villager NPC
- */
-public interface Villager extends Ageable, NPC, InventoryHolder {
-
-    /**
-     * Gets the current profession of this villager.
-     *
-     * @return Current profession.
-     */
-    public Profession getProfession();
-
-    /**
-     * Sets the new profession of this villager.
-     *
-     * @param profession New profession.
-     */
-    public void setProfession(Profession profession);
-
-    /**
-     * Get a list of trades currently available from this villager.
-     *
-     * @return an immutable list of trades
-     */
-    List<MerchantRecipe> getRecipes();
-
-    /**
-     * Set the list of trades currently available from this villager.
-     * <br>
-     * This will not change the selected trades of players currently trading
-     * with this villager.
-     *
-     * @param recipes a list of recipes
-     */
-    void setRecipes(List<MerchantRecipe> recipes);
-
-    /**
-     * Get the recipe at a certain index of this villager's trade list.
-     *
-     * @param i the index
-     * @return the recipe
-     * @throws IndexOutOfBoundsException
-     */
-    MerchantRecipe getRecipe(int i) throws IndexOutOfBoundsException;
-
-    /**
-     * Set the recipe at a certain index of this villager's trade list.
-     *
-     * @param i the index
-     * @param recipe the recipe
-     * @throws IndexOutOfBoundsException
-     */
-    void setRecipe(int i, MerchantRecipe recipe) throws IndexOutOfBoundsException;
-
-    /**
-     * Get the number of trades this villager currently has available.
-     *
-     * @return the recipe count
-     */
-    int getRecipeCount();
-
-    /**
-     * Gets this villager's inventory.
-     * <br>
-     * Note that this inventory is not the Merchant inventory, rather, it is the
-     * items that a villager might have collected (from harvesting crops, etc.)
-     *
-     * {@inheritDoc}
-     */
-    @Override
-    Inventory getInventory();
-
-    /**
-     * Gets whether this villager is currently trading.
-     *
-     * @return whether the villager is trading
-     */
-    boolean isTrading();
-
-    /**
-     * Gets the player this villager is trading with, or null if it is not
-     * currently trading.
-     *
-     * @return the trader, or null
-     */
-    HumanEntity getTrader();
-
-    /**
-     * Gets this villager's riches, the number of emeralds this villager has
-     * been given.
-     *
-     * @return the villager's riches
-     */
-    int getRiches();
-
-    /**
-     * Sets this villager's riches.
-     *
-     * @see Villager#getRiches()
-     *
-     * @param riches the new riches
-     */
-    void setRiches(int riches);
-
-    /**
-     * Represents the various different Villager professions there may be.
-     */
-    public enum Profession {
-        FARMER(0),
-        LIBRARIAN(1),
-        PRIEST(2),
-        BLACKSMITH(3),
-        BUTCHER(4);
-
-        private static final Profession[] professions = new Profession[Profession.values().length];
-        private final int id;
-
-        static {
-            for (Profession type : values()) {
-                professions[type.getId()] = type;
-            }
-        }
-
-        private Profession(int id) {
-            this.id = id;
-        }
-
-        /**
-         * Gets the ID of this profession.
-         *
-         * @return Profession ID.
-         * @deprecated Magic value
-         */
-        @Deprecated
-        public int getId() {
-            return id;
-        }
-
-        /**
-         * Gets a profession by its ID.
-         *
-         * @param id ID of the profession to get.
-         * @return Resulting profession, or null if not found.
-         * @deprecated Magic value
-         */
-        @Deprecated
-        public static Profession getProfession(int id) {
-            return (id >= professions.length) ? null : professions[id];
-        }
-    }
-}
diff --git a/src/main/java/org/bukkit/entity/WaterMob.java b/src/main/java/org/bukkit/entity/WaterMob.java
deleted file mode 100644
index 3e89ca0..0000000
--- a/src/main/java/org/bukkit/entity/WaterMob.java
+++ /dev/null
@@ -1,6 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * Represents a Water Mob
- */
-public interface WaterMob extends LivingEntity {}
diff --git a/src/main/java/org/bukkit/entity/Weather.java b/src/main/java/org/bukkit/entity/Weather.java
deleted file mode 100644
index 6d77851..0000000
--- a/src/main/java/org/bukkit/entity/Weather.java
+++ /dev/null
@@ -1,6 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * Represents a Weather related entity, such as a storm
- */
-public interface Weather extends Entity {}
diff --git a/src/main/java/org/bukkit/entity/Witch.java b/src/main/java/org/bukkit/entity/Witch.java
deleted file mode 100644
index 9c5dc1f..0000000
--- a/src/main/java/org/bukkit/entity/Witch.java
+++ /dev/null
@@ -1,7 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * Represents a Witch
- */
-public interface Witch extends Monster {
-}
diff --git a/src/main/java/org/bukkit/entity/Wither.java b/src/main/java/org/bukkit/entity/Wither.java
deleted file mode 100644
index 0922c5c..0000000
--- a/src/main/java/org/bukkit/entity/Wither.java
+++ /dev/null
@@ -1,7 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * Represents a Wither boss
- */
-public interface Wither extends Monster {
-}
diff --git a/src/main/java/org/bukkit/entity/WitherSkull.java b/src/main/java/org/bukkit/entity/WitherSkull.java
deleted file mode 100644
index 33d20ab..0000000
--- a/src/main/java/org/bukkit/entity/WitherSkull.java
+++ /dev/null
@@ -1,21 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * Represents a wither skull {@link Fireball}.
- */
-public interface WitherSkull extends Fireball {
-
-    /**
-     * Sets the charged status of the wither skull.
-     *
-     * @param charged whether it should be charged
-     */
-    public void setCharged(boolean charged);
-
-    /**
-     * Gets whether or not the wither skull is charged.
-     *
-     * @return whether the wither skull is charged
-     */
-    public boolean isCharged();
-}
diff --git a/src/main/java/org/bukkit/entity/Wolf.java b/src/main/java/org/bukkit/entity/Wolf.java
deleted file mode 100644
index 9d5a896..0000000
--- a/src/main/java/org/bukkit/entity/Wolf.java
+++ /dev/null
@@ -1,56 +0,0 @@
-package org.bukkit.entity;
-
-import org.bukkit.DyeColor;
-
-/**
- * Represents a Wolf
- */
-public interface Wolf extends Animals, Tameable {
-
-    /**
-     * Checks if this wolf is angry
-     *
-     * @return Anger true if angry
-     */
-    public boolean isAngry();
-
-    /**
-     * Sets the anger of this wolf.
-     * <p>
-     * An angry wolf can not be fed or tamed, and will actively look for
-     * targets to attack.
-     *
-     * @param angry true if angry
-     */
-    public void setAngry(boolean angry);
-
-    /**
-     * Checks if this wolf is sitting
-     *
-     * @return true if sitting
-     */
-    public boolean isSitting();
-
-    /**
-     * Sets if this wolf is sitting.
-     * <p>
-     * Will remove any path that the wolf was following beforehand.
-     *
-     * @param sitting true if sitting
-     */
-    public void setSitting(boolean sitting);
-
-    /**
-     * Get the collar color of this wolf
-     *
-     * @return the color of the collar
-     */
-    public DyeColor getCollarColor();
-
-    /**
-     * Set the collar color of this wolf
-     *
-     * @param color the color to apply
-     */
-    public void setCollarColor(DyeColor color);
-}
diff --git a/src/main/java/org/bukkit/entity/Zombie.java b/src/main/java/org/bukkit/entity/Zombie.java
deleted file mode 100644
index 3bd53e1..0000000
--- a/src/main/java/org/bukkit/entity/Zombie.java
+++ /dev/null
@@ -1,52 +0,0 @@
-package org.bukkit.entity;
-
-/**
- * Represents a Zombie.
- */
-public interface Zombie extends Monster {
-
-    /**
-     * Gets whether the zombie is a baby
-     *
-     * @return Whether the zombie is a baby
-     */
-    public boolean isBaby();
-
-    /**
-     * Sets whether the zombie is a baby
-     *
-     * @param flag Whether the zombie is a baby
-     */
-    public void setBaby(boolean flag);
-
-    /**
-     * Gets whether the zombie is a villager
-     *
-     * @return Whether the zombie is a villager
-     */
-    public boolean isVillager();
-
-    /**
-     * Sets whether the zombie is a villager
-     *
-     * @param flag Whether the zombie is a villager
-     * @deprecated Defaults to a basic villager
-     */
-    @Deprecated
-    public void setVillager(boolean flag);
-
-    /**
-     * Sets whether the zombie is a villager
-     *
-     * @param profession the profession of the villager or null to clear
-     */
-    public void setVillagerProfession(Villager.Profession profession);
-
-    /**
-     * Returns the villager profession of the zombie if the
-     * zombie is a villager
-     *
-     * @return the profession or null
-     */
-    public Villager.Profession getVillagerProfession();
-}
diff --git a/src/main/java/org/bukkit/entity/minecart/CommandMinecart.java b/src/main/java/org/bukkit/entity/minecart/CommandMinecart.java
deleted file mode 100644
index e502680..0000000
--- a/src/main/java/org/bukkit/entity/minecart/CommandMinecart.java
+++ /dev/null
@@ -1,36 +0,0 @@
-package org.bukkit.entity.minecart;
-
-import org.bukkit.command.CommandSender;
-import org.bukkit.entity.Minecart;
-
-public interface CommandMinecart extends Minecart, CommandSender {
-
-    /**
-     * Gets the command that this CommandMinecart will run when activated.
-     * This will never return null.  If the CommandMinecart does not have a
-     * command, an empty String will be returned instead.
-     *
-     * @return Command that this CommandMinecart will run when powered.
-     */
-    public String getCommand();
-
-    /**
-     * Sets the command that this CommandMinecart will run when activated.
-     * Setting the command to null is the same as setting it to an empty
-     * String.
-     *
-     * @param command Command that this CommandMinecart will run when
-     *     activated.
-     */
-    public void setCommand(String command);
-
-    /**
-     * Sets the name of this CommandMinecart.  The name is used with commands
-     * that this CommandMinecart executes.  Setting the name to null is the
-     * same as setting it to "@".
-     *
-     * @param name New name for this CommandMinecart.
-     */
-    public void setName(String name);
-
-}
diff --git a/src/main/java/org/bukkit/entity/minecart/ExplosiveMinecart.java b/src/main/java/org/bukkit/entity/minecart/ExplosiveMinecart.java
deleted file mode 100644
index a4411da..0000000
--- a/src/main/java/org/bukkit/entity/minecart/ExplosiveMinecart.java
+++ /dev/null
@@ -1,9 +0,0 @@
-package org.bukkit.entity.minecart;
-
-import org.bukkit.entity.Minecart;
-
-/**
- * Represents a Minecart with TNT inside it that can explode when triggered.
- */
-public interface ExplosiveMinecart extends Minecart {
-}
diff --git a/src/main/java/org/bukkit/entity/minecart/HopperMinecart.java b/src/main/java/org/bukkit/entity/minecart/HopperMinecart.java
deleted file mode 100644
index 0330431..0000000
--- a/src/main/java/org/bukkit/entity/minecart/HopperMinecart.java
+++ /dev/null
@@ -1,25 +0,0 @@
-package org.bukkit.entity.minecart;
-
-import org.bukkit.entity.Minecart;
-import org.bukkit.inventory.InventoryHolder;
-
-/**
- * Represents a Minecart with a Hopper inside it
- */
-public interface HopperMinecart extends Minecart, InventoryHolder {
-
-    /**
-     * Checks whether or not this Minecart will pick up 
-     * items into its inventory.
-     * 
-     * @return true if the Minecart will pick up items
-     */
-    boolean isEnabled();
-
-    /**
-     * Sets whether this Minecart will pick up items.
-     * 
-     * @param enabled new enabled state
-     */
-    void setEnabled(boolean enabled);
-}
diff --git a/src/main/java/org/bukkit/entity/minecart/PoweredMinecart.java b/src/main/java/org/bukkit/entity/minecart/PoweredMinecart.java
deleted file mode 100644
index 57e8b1d..0000000
--- a/src/main/java/org/bukkit/entity/minecart/PoweredMinecart.java
+++ /dev/null
@@ -1,10 +0,0 @@
-package org.bukkit.entity.minecart;
-
-import org.bukkit.entity.Minecart;
-
-/**
- * Represents a powered minecart. A powered minecart moves on its own when a
- * player deposits {@link org.bukkit.Material#COAL fuel}.
- */
-public interface PoweredMinecart extends Minecart {
-}
diff --git a/src/main/java/org/bukkit/entity/minecart/RideableMinecart.java b/src/main/java/org/bukkit/entity/minecart/RideableMinecart.java
deleted file mode 100644
index 1b82645..0000000
--- a/src/main/java/org/bukkit/entity/minecart/RideableMinecart.java
+++ /dev/null
@@ -1,14 +0,0 @@
-package org.bukkit.entity.minecart;
-
-import org.bukkit.entity.Minecart;
-
-/**
- * Represents a minecart that can have certain {@link
- * org.bukkit.entity.Entity entities} as passengers. Normal passengers
- * include all {@link org.bukkit.entity.LivingEntity living entities} with
- * the exception of {@link org.bukkit.entity.IronGolem iron golems}.
- * Non-player entities that meet normal passenger criteria automatically
- * mount these minecarts when close enough.
- */
-public interface RideableMinecart extends Minecart {
-}
diff --git a/src/main/java/org/bukkit/entity/minecart/SpawnerMinecart.java b/src/main/java/org/bukkit/entity/minecart/SpawnerMinecart.java
deleted file mode 100644
index 0ce3592..0000000
--- a/src/main/java/org/bukkit/entity/minecart/SpawnerMinecart.java
+++ /dev/null
@@ -1,10 +0,0 @@
-package org.bukkit.entity.minecart;
-
-import org.bukkit.entity.Minecart;
-
-/**
- * Represents a Minecart with an {@link org.bukkit.block.CreatureSpawner
- * entity spawner} inside it.
- */
-public interface SpawnerMinecart extends Minecart {
-}
diff --git a/src/main/java/org/bukkit/entity/minecart/StorageMinecart.java b/src/main/java/org/bukkit/entity/minecart/StorageMinecart.java
deleted file mode 100644
index 4f04ab4..0000000
--- a/src/main/java/org/bukkit/entity/minecart/StorageMinecart.java
+++ /dev/null
@@ -1,12 +0,0 @@
-package org.bukkit.entity.minecart;
-
-import org.bukkit.entity.Minecart;
-import org.bukkit.inventory.InventoryHolder;
-
-/**
- * Represents a minecart with a chest. These types of {@link Minecart
- * minecarts} have their own inventory that can be accessed using methods
- * from the {@link InventoryHolder} interface.
- */
-public interface StorageMinecart extends Minecart, InventoryHolder {
-}
diff --git a/src/main/java/org/bukkit/event/Cancellable.java b/src/main/java/org/bukkit/event/Cancellable.java
deleted file mode 100644
index 799b0b0..0000000
--- a/src/main/java/org/bukkit/event/Cancellable.java
+++ /dev/null
@@ -1,20 +0,0 @@
-package org.bukkit.event;
-
-public interface Cancellable {
-
-    /**
-     * Gets the cancellation state of this event. A cancelled event will not
-     * be executed in the server, but will still pass to other plugins
-     *
-     * @return true if this event is cancelled
-     */
-    public boolean isCancelled();
-
-    /**
-     * Sets the cancellation state of this event. A cancelled event will not
-     * be executed in the server, but will still pass to other plugins.
-     *
-     * @param cancel true if you wish to cancel this event
-     */
-    public void setCancelled(boolean cancel);
-}
diff --git a/src/main/java/org/bukkit/event/Event.java b/src/main/java/org/bukkit/event/Event.java
deleted file mode 100644
index 6677e1b..0000000
--- a/src/main/java/org/bukkit/event/Event.java
+++ /dev/null
@@ -1,98 +0,0 @@
-package org.bukkit.event;
-
-import org.bukkit.plugin.PluginManager;
-
-/**
- * Represents an event.
- *
- * All events require a static method named getHandlerList() which returns the same {@link HandlerList} as {@link #getHandlers()}.
- *
- * @see PluginManager#callEvent(Event)
- * @see PluginManager#registerEvents(Listener,Plugin)
- */
-public abstract class Event {
-    private String name;
-    private final boolean async;
-
-    /**
-     * The default constructor is defined for cleaner code. This constructor
-     * assumes the event is synchronous.
-     */
-    public Event() {
-        this(false);
-    }
-
-    /**
-     * This constructor is used to explicitly declare an event as synchronous
-     * or asynchronous.
-     *
-     * @param isAsync true indicates the event will fire asynchronously, false
-     *     by default from default constructor
-     */
-    public Event(boolean isAsync) {
-        this.async = isAsync;
-    }
-
-    /**
-     * Convenience method for providing a user-friendly identifier. By
-     * default, it is the event's class's {@linkplain Class#getSimpleName()
-     * simple name}.
-     *
-     * @return name of this event
-     */
-    public String getEventName() {
-        if (name == null) {
-            name = getClass().getSimpleName();
-        }
-        return name;
-    }
-
-    public abstract HandlerList getHandlers();
-
-    /**
-     * Any custom event that should not by synchronized with other events must
-     * use the specific constructor. These are the caveats of using an
-     * asynchronous event:
-     * <ul>
-     * <li>The event is never fired from inside code triggered by a
-     *     synchronous event. Attempting to do so results in an {@link
-     *     java.lang.IllegalStateException}.
-     * <li>However, asynchronous event handlers may fire synchronous or
-     *     asynchronous events
-     * <li>The event may be fired multiple times simultaneously and in any
-     *     order.
-     * <li>Any newly registered or unregistered handler is ignored after an
-     *     event starts execution.
-     * <li>The handlers for this event may block for any length of time.
-     * <li>Some implementations may selectively declare a specific event use
-     *     as asynchronous. This behavior should be clearly defined.
-     * <li>Asynchronous calls are not calculated in the plugin timing system.
-     * </ul>
-     *
-     * @return false by default, true if the event fires asynchronously
-     */
-    public final boolean isAsynchronous() {
-        return async;
-    }
-
-    public enum Result {
-
-        /**
-         * Deny the event. Depending on the event, the action indicated by the
-         * event will either not take place or will be reverted. Some actions
-         * may not be denied.
-         */
-        DENY,
-        /**
-         * Neither deny nor allow the event. The server will proceed with its
-         * normal handling.
-         */
-        DEFAULT,
-        /**
-         * Allow / Force the event. The action indicated by the event will
-         * take place if possible, even if the server would not normally allow
-         * the action. Some actions may not be allowed.
-         */
-        ALLOW;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/EventException.java b/src/main/java/org/bukkit/event/EventException.java
deleted file mode 100644
index 84638e8..0000000
--- a/src/main/java/org/bukkit/event/EventException.java
+++ /dev/null
@@ -1,53 +0,0 @@
-package org.bukkit.event;
-
-public class EventException extends Exception {
-    private static final long serialVersionUID = 3532808232324183999L;
-    private final Throwable cause;
-
-    /**
-     * Constructs a new EventException based on the given Exception
-     *
-     * @param throwable Exception that triggered this Exception
-     */
-    public EventException(Throwable throwable) {
-        cause = throwable;
-    }
-
-    /**
-     * Constructs a new EventException
-     */
-    public EventException() {
-        cause = null;
-    }
-
-    /**
-     * Constructs a new EventException with the given message
-     *
-     * @param cause The exception that caused this
-     * @param message The message
-     */
-    public EventException(Throwable cause, String message) {
-        super(message);
-        this.cause = cause;
-    }
-
-    /**
-     * Constructs a new EventException with the given message
-     *
-     * @param message The message
-     */
-    public EventException(String message) {
-        super(message);
-        cause = null;
-    }
-
-    /**
-     * If applicable, returns the Exception that triggered this Exception
-     *
-     * @return Inner exception, or null if one does not exist
-     */
-    @Override
-    public Throwable getCause() {
-        return cause;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/EventHandler.java b/src/main/java/org/bukkit/event/EventHandler.java
deleted file mode 100644
index 4c9fb3c..0000000
--- a/src/main/java/org/bukkit/event/EventHandler.java
+++ /dev/null
@@ -1,41 +0,0 @@
-package org.bukkit.event;
-
-import java.lang.annotation.ElementType;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.lang.annotation.Target;
-
-/**
- * An annotation to mark methods as being event handler methods
- */
-@Target(ElementType.METHOD)
-@Retention(RetentionPolicy.RUNTIME)
-public @interface EventHandler {
-
-    /**
-     * Define the priority of the event.
-     * <p>
-     * First priority to the last priority executed:
-     * <ol>
-     * <li>LOWEST
-     * <li>LOW
-     * <li>NORMAL
-     * <li>HIGH
-     * <li>HIGHEST
-     * <li>MONITOR
-     * </ol>
-     * 
-     * @return the priority
-     */
-    EventPriority priority() default EventPriority.NORMAL;
-
-    /**
-     * Define if the handler ignores a cancelled event.
-     * <p>
-     * If ignoreCancelled is true and the event is cancelled, the method is
-     * not called. Otherwise, the method is always called.
-     * 
-     * @return whether cancelled events should be ignored
-     */
-    boolean ignoreCancelled() default false;
-}
diff --git a/src/main/java/org/bukkit/event/EventPriority.java b/src/main/java/org/bukkit/event/EventPriority.java
deleted file mode 100644
index 61ffa50..0000000
--- a/src/main/java/org/bukkit/event/EventPriority.java
+++ /dev/null
@@ -1,47 +0,0 @@
-package org.bukkit.event;
-
-/**
- * Represents an event's priority in execution
- */
-public enum EventPriority {
-
-    /**
-     * Event call is of very low importance and should be ran first, to allow
-     * other plugins to further customise the outcome
-     */
-    LOWEST(0),
-    /**
-     * Event call is of low importance
-     */
-    LOW(1),
-    /**
-     * Event call is neither important nor unimportant, and may be ran
-     * normally
-     */
-    NORMAL(2),
-    /**
-     * Event call is of high importance
-     */
-    HIGH(3),
-    /**
-     * Event call is critical and must have the final say in what happens
-     * to the event
-     */
-    HIGHEST(4),
-    /**
-     * Event is listened to purely for monitoring the outcome of an event.
-     * <p>
-     * No modifications to the event should be made under this priority
-     */
-    MONITOR(5);
-
-    private final int slot;
-
-    private EventPriority(int slot) {
-        this.slot = slot;
-    }
-
-    public int getSlot() {
-        return slot;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/HandlerList.java b/src/main/java/org/bukkit/event/HandlerList.java
deleted file mode 100644
index 7d5efff..0000000
--- a/src/main/java/org/bukkit/event/HandlerList.java
+++ /dev/null
@@ -1,231 +0,0 @@
-package org.bukkit.event;
-
-import org.bukkit.plugin.Plugin;
-import org.bukkit.plugin.RegisteredListener;
-
-import java.util.*;
-import java.util.Map.Entry;
-
-/**
- * A list of event handlers, stored per-event. Based on lahwran's fevents.
- */
-public class HandlerList {
-
-    /**
-     * Handler array. This field being an array is the key to this system's
-     * speed.
-     */
-    private volatile RegisteredListener[] handlers = null;
-
-    /**
-     * Dynamic handler lists. These are changed using register() and
-     * unregister() and are automatically baked to the handlers array any time
-     * they have changed.
-     */
-    private final EnumMap<EventPriority, ArrayList<RegisteredListener>> handlerslots;
-
-    /**
-     * List of all HandlerLists which have been created, for use in bakeAll()
-     */
-    private static ArrayList<HandlerList> allLists = new ArrayList<HandlerList>();
-
-    /**
-     * Bake all handler lists. Best used just after all normal event
-     * registration is complete, ie just after all plugins are loaded if
-     * you're using fevents in a plugin system.
-     */
-    public static void bakeAll() {
-        synchronized (allLists) {
-            for (HandlerList h : allLists) {
-                h.bake();
-            }
-        }
-    }
-
-    /**
-     * Unregister all listeners from all handler lists.
-     */
-    public static void unregisterAll() {
-        synchronized (allLists) {
-            for (HandlerList h : allLists) {
-                synchronized (h) {
-                    for (List<RegisteredListener> list : h.handlerslots.values()) {
-                        list.clear();
-                    }
-                    h.handlers = null;
-                }
-            }
-        }
-    }
-
-    /**
-     * Unregister a specific plugin's listeners from all handler lists.
-     *
-     * @param plugin plugin to unregister
-     */
-    public static void unregisterAll(Plugin plugin) {
-        synchronized (allLists) {
-            for (HandlerList h : allLists) {
-                h.unregister(plugin);
-            }
-        }
-    }
-
-    /**
-     * Unregister a specific listener from all handler lists.
-     *
-     * @param listener listener to unregister
-     */
-    public static void unregisterAll(Listener listener) {
-        synchronized (allLists) {
-            for (HandlerList h : allLists) {
-                h.unregister(listener);
-            }
-        }
-    }
-
-    /**
-     * Create a new handler list and initialize using EventPriority.
-     * <p>
-     * The HandlerList is then added to meta-list for use in bakeAll()
-     */
-    public HandlerList() {
-        handlerslots = new EnumMap<EventPriority, ArrayList<RegisteredListener>>(EventPriority.class);
-        for (EventPriority o : EventPriority.values()) {
-            handlerslots.put(o, new ArrayList<RegisteredListener>());
-        }
-        synchronized (allLists) {
-            allLists.add(this);
-        }
-    }
-
-    /**
-     * Register a new listener in this handler list
-     *
-     * @param listener listener to register
-     */
-    public synchronized void register(RegisteredListener listener) {
-        if (handlerslots.get(listener.getPriority()).contains(listener))
-            throw new IllegalStateException("This listener is already registered to priority " + listener.getPriority().toString());
-        handlers = null;
-        handlerslots.get(listener.getPriority()).add(listener);
-    }
-
-    /**
-     * Register a collection of new listeners in this handler list
-     *
-     * @param listeners listeners to register
-     */
-    public void registerAll(Collection<RegisteredListener> listeners) {
-        for (RegisteredListener listener : listeners) {
-            register(listener);
-        }
-    }
-
-    /**
-     * Remove a listener from a specific order slot
-     *
-     * @param listener listener to remove
-     */
-    public synchronized void unregister(RegisteredListener listener) {
-        if (handlerslots.get(listener.getPriority()).remove(listener)) {
-            handlers = null;
-        }
-    }
-
-    /**
-     * Remove a specific plugin's listeners from this handler
-     *
-     * @param plugin plugin to remove
-     */
-    public synchronized void unregister(Plugin plugin) {
-        boolean changed = false;
-        for (List<RegisteredListener> list : handlerslots.values()) {
-            for (ListIterator<RegisteredListener> i = list.listIterator(); i.hasNext();) {
-                if (i.next().getPlugin().equals(plugin)) {
-                    i.remove();
-                    changed = true;
-                }
-            }
-        }
-        if (changed) handlers = null;
-    }
-
-    /**
-     * Remove a specific listener from this handler
-     *
-     * @param listener listener to remove
-     */
-    public synchronized void unregister(Listener listener) {
-        boolean changed = false;
-        for (List<RegisteredListener> list : handlerslots.values()) {
-            for (ListIterator<RegisteredListener> i = list.listIterator(); i.hasNext();) {
-                if (i.next().getListener().equals(listener)) {
-                    i.remove();
-                    changed = true;
-                }
-            }
-        }
-        if (changed) handlers = null;
-    }
-
-    /**
-     * Bake HashMap and ArrayLists to 2d array - does nothing if not necessary
-     */
-    public synchronized void bake() {
-        if (handlers != null) return; // don't re-bake when still valid
-        List<RegisteredListener> entries = new ArrayList<RegisteredListener>();
-        for (Entry<EventPriority, ArrayList<RegisteredListener>> entry : handlerslots.entrySet()) {
-            entries.addAll(entry.getValue());
-        }
-        handlers = entries.toArray(new RegisteredListener[entries.size()]);
-    }
-
-    /**
-     * Get the baked registered listeners associated with this handler list
-     *
-     * @return the array of registered listeners
-     */
-    public RegisteredListener[] getRegisteredListeners() {
-        RegisteredListener[] handlers;
-        while ((handlers = this.handlers) == null) bake(); // This prevents fringe cases of returning null
-        return handlers;
-    }
-
-    /**
-     * Get a specific plugin's registered listeners associated with this
-     * handler list
-     *
-     * @param plugin the plugin to get the listeners of
-     * @return the list of registered listeners
-     */
-    public static ArrayList<RegisteredListener> getRegisteredListeners(Plugin plugin) {
-        ArrayList<RegisteredListener> listeners = new ArrayList<RegisteredListener>();
-        synchronized (allLists) {
-            for (HandlerList h : allLists) {
-                synchronized (h) {
-                    for (List<RegisteredListener> list : h.handlerslots.values()) {
-                        for (RegisteredListener listener : list) {
-                            if (listener.getPlugin().equals(plugin)) {
-                                listeners.add(listener);
-                            }
-                        }
-                    }
-                }
-            }
-        }
-        return listeners;
-    }
-
-    /**
-     * Get a list of all handler lists for every event type
-     *
-     * @return the list of all handler lists
-     */
-    @SuppressWarnings("unchecked")
-    public static ArrayList<HandlerList> getHandlerLists() {
-        synchronized (allLists) {
-            return (ArrayList<HandlerList>) allLists.clone();
-        }
-    }
-}
diff --git a/src/main/java/org/bukkit/event/Listener.java b/src/main/java/org/bukkit/event/Listener.java
deleted file mode 100644
index ff083e6..0000000
--- a/src/main/java/org/bukkit/event/Listener.java
+++ /dev/null
@@ -1,6 +0,0 @@
-package org.bukkit.event;
-
-/**
- * Simple interface for tagging all EventListeners
- */
-public interface Listener {}
diff --git a/src/main/java/org/bukkit/event/block/Action.java b/src/main/java/org/bukkit/event/block/Action.java
deleted file mode 100644
index 25d26e3..0000000
--- a/src/main/java/org/bukkit/event/block/Action.java
+++ /dev/null
@@ -1,33 +0,0 @@
-package org.bukkit.event.block;
-
-public enum Action {
-
-    /**
-     * Left-clicking a block
-     */
-    LEFT_CLICK_BLOCK,
-    /**
-     * Right-clicking a block
-     */
-    RIGHT_CLICK_BLOCK,
-    /**
-     * Left-clicking the air
-     */
-    LEFT_CLICK_AIR,
-    /**
-     * Right-clicking the air
-     */
-    RIGHT_CLICK_AIR,
-    /**
-     * Stepping onto or into a block (Ass-pressure)
-     *
-     * Examples:
-     * <ul>
-     * <li>Jumping on soil
-     * <li>Standing on pressure plate
-     * <li>Triggering redstone ore
-     * <li>Triggering tripwire
-     * </ul>
-     */
-    PHYSICAL,
-}
diff --git a/src/main/java/org/bukkit/event/block/BlockBreakEvent.java b/src/main/java/org/bukkit/event/block/BlockBreakEvent.java
deleted file mode 100644
index a011f61..0000000
--- a/src/main/java/org/bukkit/event/block/BlockBreakEvent.java
+++ /dev/null
@@ -1,55 +0,0 @@
-package org.bukkit.event.block;
-
-import org.bukkit.block.Block;
-import org.bukkit.entity.Player;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a block is broken by a player.
- * <p>
- * If you wish to have the block drop experience, you must set the experience
- * value above 0. By default, experience will be set in the event if:
- * <ol>
- * <li>The player is not in creative or adventure mode
- * <li>The player can loot the block (ie: does not destroy it completely, by
- *     using the correct tool)
- * <li>The player does not have silk touch
- * <li>The block drops experience in vanilla Minecraft
- * </ol>
- * <p>
- * Note:
- * Plugins wanting to simulate a traditional block drop should set the block
- * to air and utilize their own methods for determining what the default drop
- * for the block being broken is and what to do about it, if anything.
- * <p>
- * If a Block Break event is cancelled, the block will not break and
- * experience will not drop.
- */
-public class BlockBreakEvent extends BlockExpEvent implements Cancellable {
-    private final Player player;
-    private boolean cancel;
-
-    public BlockBreakEvent(final Block theBlock, final Player player) {
-        super(theBlock, 0);
-
-        this.player = player;
-    }
-
-    /**
-     * Gets the Player that is breaking the block involved in this event.
-     *
-     * @return The Player that is breaking the block involved in this event
-     */
-    public Player getPlayer() {
-        return player;
-    }
-
-    public boolean isCancelled() {
-        return cancel;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancel = cancel;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/block/BlockBurnEvent.java b/src/main/java/org/bukkit/event/block/BlockBurnEvent.java
deleted file mode 100644
index 1592a15..0000000
--- a/src/main/java/org/bukkit/event/block/BlockBurnEvent.java
+++ /dev/null
@@ -1,38 +0,0 @@
-package org.bukkit.event.block;
-
-import org.bukkit.block.Block;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a block is destroyed as a result of being burnt by fire.
- * <p>
- * If a Block Burn event is cancelled, the block will not be destroyed as a
- * result of being burnt by fire.
- */
-public class BlockBurnEvent extends BlockEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private boolean cancelled;
-
-    public BlockBurnEvent(final Block block) {
-        super(block);
-        this.cancelled = false;
-    }
-
-    public boolean isCancelled() {
-        return cancelled;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancelled = cancel;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/block/BlockCanBuildEvent.java b/src/main/java/org/bukkit/event/block/BlockCanBuildEvent.java
deleted file mode 100644
index 613feb9..0000000
--- a/src/main/java/org/bukkit/event/block/BlockCanBuildEvent.java
+++ /dev/null
@@ -1,93 +0,0 @@
-package org.bukkit.event.block;
-
-import org.bukkit.block.Block;
-import org.bukkit.Material;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when we try to place a block, to see if we can build it here or not.
- * <p>
- * Note:
- * <ul>
- * <li>The Block returned by getBlock() is the block we are trying to place
- *     on, not the block we are trying to place.
- * <li>If you want to figure out what is being placed, use {@link
- *     #getMaterial()} or {@link #getMaterialId()} instead.
- * </ul>
- */
-public class BlockCanBuildEvent extends BlockEvent {
-    private static final HandlerList handlers = new HandlerList();
-    protected boolean buildable;
-
-    /**
-     *
-     * @deprecated Magic value
-     */
-    @Deprecated
-    protected int material;
-
-    /**
-     *
-     * @deprecated Magic value
-     * @param block the block involved in this event
-     * @param id the id of the block to place
-     * @param canBuild whether we can build 
-     */
-    @Deprecated
-    public BlockCanBuildEvent(final Block block, final int id, final boolean canBuild) {
-        super(block);
-        buildable = canBuild;
-        material = id;
-    }
-
-    /**
-     * Gets whether or not the block can be built here.
-     * <p>
-     * By default, returns Minecraft's answer on whether the block can be
-     * built here or not.
-     *
-     * @return boolean whether or not the block can be built
-     */
-    public boolean isBuildable() {
-        return buildable;
-    }
-
-    /**
-     * Sets whether the block can be built here or not.
-     *
-     * @param cancel true if you want to allow the block to be built here
-     *     despite Minecraft's default behaviour
-     */
-    public void setBuildable(boolean cancel) {
-        this.buildable = cancel;
-    }
-
-    /**
-     * Gets the Material that we are trying to place.
-     *
-     * @return The Material that we are trying to place
-     */
-    public Material getMaterial() {
-        return Material.getMaterial(material);
-    }
-
-    /**
-     * Gets the Material ID for the Material that we are trying to place.
-     *
-     * @return The Material ID for the Material that we are trying to place
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public int getMaterialId() {
-        return material;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/block/BlockDamageEvent.java b/src/main/java/org/bukkit/event/block/BlockDamageEvent.java
deleted file mode 100644
index d80e00e..0000000
--- a/src/main/java/org/bukkit/event/block/BlockDamageEvent.java
+++ /dev/null
@@ -1,83 +0,0 @@
-package org.bukkit.event.block;
-
-import org.bukkit.block.Block;
-import org.bukkit.entity.Player;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-import org.bukkit.inventory.ItemStack;
-
-/**
- * Called when a block is damaged by a player.
- * <p>
- * If a Block Damage event is cancelled, the block will not be damaged.
- */
-public class BlockDamageEvent extends BlockEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private final Player player;
-    private boolean instaBreak;
-    private boolean cancel;
-    private final ItemStack itemstack;
-
-    public BlockDamageEvent(final Player player, final Block block, final ItemStack itemInHand, final boolean instaBreak) {
-        super(block);
-        this.instaBreak = instaBreak;
-        this.player = player;
-        this.itemstack = itemInHand;
-        this.cancel = false;
-    }
-
-    /**
-     * Gets the player damaging the block involved in this event.
-     *
-     * @return The player damaging the block involved in this event
-     */
-    public Player getPlayer() {
-        return player;
-    }
-
-    /**
-     * Gets if the block is set to instantly break when damaged by the player.
-     *
-     * @return true if the block should instantly break when damaged by the
-     *     player
-     */
-    public boolean getInstaBreak() {
-        return instaBreak;
-    }
-
-    /**
-     * Sets if the block should instantly break when damaged by the player.
-     *
-     * @param bool true if you want the block to instantly break when damaged
-     *     by the player
-     */
-    public void setInstaBreak(boolean bool) {
-        this.instaBreak = bool;
-    }
-
-    /**
-     * Gets the ItemStack for the item currently in the player's hand.
-     *
-     * @return The ItemStack for the item currently in the player's hand
-     */
-    public ItemStack getItemInHand() {
-        return itemstack;
-    }
-
-    public boolean isCancelled() {
-        return cancel;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancel = cancel;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/block/BlockDispenseEvent.java b/src/main/java/org/bukkit/event/block/BlockDispenseEvent.java
deleted file mode 100644
index 16ee59b..0000000
--- a/src/main/java/org/bukkit/event/block/BlockDispenseEvent.java
+++ /dev/null
@@ -1,84 +0,0 @@
-package org.bukkit.event.block;
-
-import org.bukkit.block.Block;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-import org.bukkit.inventory.ItemStack;
-import org.bukkit.util.Vector;
-
-/**
- * Called when an item is dispensed from a block.
- * <p>
- * If a Block Dispense event is cancelled, the block will not dispense the
- * item.
- */
-public class BlockDispenseEvent extends BlockEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private boolean cancelled = false;
-    private ItemStack item;
-    private Vector velocity;
-
-    public BlockDispenseEvent(final Block block, final ItemStack dispensed, final Vector velocity) {
-        super(block);
-        this.item = dispensed;
-        this.velocity = velocity;
-    }
-
-    /**
-     * Gets the item that is being dispensed. Modifying the returned item will
-     * have no effect, you must use {@link
-     * #setItem(org.bukkit.inventory.ItemStack)} instead.
-     *
-     * @return An ItemStack for the item being dispensed
-     */
-    public ItemStack getItem() {
-        return item.clone();
-    }
-
-    /**
-     * Sets the item being dispensed.
-     *
-     * @param item the item being dispensed
-     */
-    public void setItem(ItemStack item) {
-        this.item = item;
-    }
-
-    /**
-     * Gets the velocity.
-     * <p>
-     * Note: Modifying the returned Vector will not change the velocity, you
-     * must use {@link #setVelocity(org.bukkit.util.Vector)} instead.
-     *
-     * @return A Vector for the dispensed item's velocity
-     */
-    public Vector getVelocity() {
-        return velocity.clone();
-    }
-
-    /**
-     * Sets the velocity of the item being dispensed.
-     *
-     * @param vel the velocity of the item being dispensed
-     */
-    public void setVelocity(Vector vel) {
-        velocity = vel;
-    }
-
-    public boolean isCancelled() {
-        return cancelled;
-    }
-
-    public void setCancelled(boolean cancel) {
-        cancelled = cancel;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/block/BlockEvent.java b/src/main/java/org/bukkit/event/block/BlockEvent.java
deleted file mode 100644
index 2405205..0000000
--- a/src/main/java/org/bukkit/event/block/BlockEvent.java
+++ /dev/null
@@ -1,24 +0,0 @@
-package org.bukkit.event.block;
-
-import org.bukkit.block.Block;
-import org.bukkit.event.Event;
-
-/**
- * Represents a block related event.
- */
-public abstract class BlockEvent extends Event {
-    protected Block block;
-
-    public BlockEvent(final Block theBlock) {
-        block = theBlock;
-    }
-
-    /**
-     * Gets the block involved in this event.
-     *
-     * @return The Block which block is involved in this event
-     */
-    public final Block getBlock() {
-        return block;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/block/BlockExpEvent.java b/src/main/java/org/bukkit/event/block/BlockExpEvent.java
deleted file mode 100644
index 08636a2..0000000
--- a/src/main/java/org/bukkit/event/block/BlockExpEvent.java
+++ /dev/null
@@ -1,45 +0,0 @@
-package org.bukkit.event.block;
-
-import org.bukkit.block.Block;
-import org.bukkit.event.HandlerList;
-
-/**
- * An event that's called when a block yields experience.
- */
-public class BlockExpEvent extends BlockEvent {
-    private static final HandlerList handlers = new HandlerList();
-    private int exp;
-
-    public BlockExpEvent(Block block, int exp) {
-        super(block);
-
-        this.exp = exp;
-    }
-
-    /**
-     * Get the experience dropped by the block after the event has processed
-     *
-     * @return The experience to drop
-     */
-    public int getExpToDrop() {
-        return exp;
-    }
-
-    /**
-     * Set the amount of experience dropped by the block after the event has
-     * processed
-     *
-     * @param exp 1 or higher to drop experience, else nothing will drop
-     */
-    public void setExpToDrop(int exp) {
-        this.exp = exp;
-    }
-
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/block/BlockExplodeEvent.java b/src/main/java/org/bukkit/event/block/BlockExplodeEvent.java
deleted file mode 100644
index 5f15e29..0000000
--- a/src/main/java/org/bukkit/event/block/BlockExplodeEvent.java
+++ /dev/null
@@ -1,69 +0,0 @@
-package org.bukkit.event.block;
-
-import org.bukkit.block.Block;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-import java.util.List;
-
-/**
- * Called when a block explodes
- */
-public class BlockExplodeEvent extends BlockEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private boolean cancel;
-    private final List<Block> blocks;
-    private float yield;
-
-    public BlockExplodeEvent(final Block what, final List<Block> blocks, final float yield) {
-        super(what);
-        this.blocks = blocks;
-        this.yield = yield;
-        this.cancel = false;
-    }
-
-    public boolean isCancelled() {
-        return cancel;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancel = cancel;
-    }
-
-    /**
-     * Returns the list of blocks that would have been removed or were removed
-     * from the explosion event.
-     *
-     * @return All blown-up blocks
-     */
-    public List<Block> blockList() {
-        return blocks;
-    }
-
-    /**
-     * Returns the percentage of blocks to drop from this explosion
-     *
-     * @return The yield.
-     */
-    public float getYield() {
-        return yield;
-    }
-
-    /**
-     * Sets the percentage of blocks to drop from this explosion
-     *
-     * @param yield The new yield percentage
-     */
-    public void setYield(float yield) {
-        this.yield = yield;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/block/BlockFadeEvent.java b/src/main/java/org/bukkit/event/block/BlockFadeEvent.java
deleted file mode 100644
index 673bc5f..0000000
--- a/src/main/java/org/bukkit/event/block/BlockFadeEvent.java
+++ /dev/null
@@ -1,59 +0,0 @@
-package org.bukkit.event.block;
-
-import org.bukkit.block.Block;
-import org.bukkit.block.BlockState;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a block fades, melts or disappears based on world conditions
- * <p>
- * Examples:
- * <ul>
- * <li>Snow melting due to being near a light source.
- * <li>Ice melting due to being near a light source.
- * <li>Fire burning out after time, without destroying fuel block.
- * </ul>
- * <p>
- * If a Block Fade event is cancelled, the block will not fade, melt or
- * disappear.
- */
-public class BlockFadeEvent extends BlockEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private boolean cancelled;
-    private final BlockState newState;
-
-    public BlockFadeEvent(final Block block, final BlockState newState) {
-        super(block);
-        this.newState = newState;
-        this.cancelled = false;
-    }
-
-    /**
-     * Gets the state of the block that will be fading, melting or
-     * disappearing.
-     *
-     * @return The block state of the block that will be fading, melting or
-     *     disappearing
-     */
-    public BlockState getNewState() {
-        return newState;
-    }
-
-    public boolean isCancelled() {
-        return cancelled;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancelled = cancel;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/block/BlockFormEvent.java b/src/main/java/org/bukkit/event/block/BlockFormEvent.java
deleted file mode 100644
index df0401f..0000000
--- a/src/main/java/org/bukkit/event/block/BlockFormEvent.java
+++ /dev/null
@@ -1,39 +0,0 @@
-package org.bukkit.event.block;
-
-import org.bukkit.block.Block;
-import org.bukkit.block.BlockState;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a block is formed or spreads based on world conditions.
- * <p>
- * Use {@link BlockSpreadEvent} to catch blocks that actually spread and don't
- * just "randomly" form.
- * <p>
- * Examples:
- * <ul>
- * <li>Snow forming due to a snow storm.
- * <li>Ice forming in a snowy Biome like Taiga or Tundra.
- * </ul>
- * <p>
- * If a Block Form event is cancelled, the block will not be formed.
- *
- * @see BlockSpreadEvent
- */
-public class BlockFormEvent extends BlockGrowEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-
-    public BlockFormEvent(final Block block, final BlockState newState) {
-        super(block, newState);
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/block/BlockFromToEvent.java b/src/main/java/org/bukkit/event/block/BlockFromToEvent.java
deleted file mode 100644
index f976bea..0000000
--- a/src/main/java/org/bukkit/event/block/BlockFromToEvent.java
+++ /dev/null
@@ -1,71 +0,0 @@
-package org.bukkit.event.block;
-
-import org.bukkit.block.Block;
-import org.bukkit.block.BlockFace;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Represents events with a source block and a destination block, currently
- * only applies to liquid (lava and water) and teleporting dragon eggs.
- * <p>
- * If a Block From To event is cancelled, the block will not move (the liquid
- * will not flow).
- */
-public class BlockFromToEvent extends BlockEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    protected Block to;
-    protected BlockFace face;
-    protected boolean cancel;
-
-    public BlockFromToEvent(final Block block, final BlockFace face) {
-        super(block);
-        this.face = face;
-        this.cancel = false;
-    }
-
-    public BlockFromToEvent(final Block block, final Block toBlock) {
-        super(block);
-        this.to = toBlock;
-        this.face = BlockFace.SELF;
-        this.cancel = false;
-    }
-
-    /**
-     * Gets the BlockFace that the block is moving to.
-     *
-     * @return The BlockFace that the block is moving to
-     */
-    public BlockFace getFace() {
-        return face;
-    }
-
-    /**
-     * Convenience method for getting the faced Block.
-     *
-     * @return The faced Block
-     */
-    public Block getToBlock() {
-        if (to == null) {
-            to = block.getRelative(face);
-        }
-        return to;
-    }
-
-    public boolean isCancelled() {
-        return cancel;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancel = cancel;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/block/BlockGrowEvent.java b/src/main/java/org/bukkit/event/block/BlockGrowEvent.java
deleted file mode 100644
index 2a959fd..0000000
--- a/src/main/java/org/bukkit/event/block/BlockGrowEvent.java
+++ /dev/null
@@ -1,56 +0,0 @@
-package org.bukkit.event.block;
-
-import org.bukkit.block.Block;
-import org.bukkit.block.BlockState;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a block grows naturally in the world.
- * <p>
- * Examples:
- * <ul>
- * <li>Wheat
- * <li>Sugar Cane
- * <li>Cactus
- * <li>Watermelon
- * <li>Pumpkin
- * </ul>
- * <p>
- * If a Block Grow event is cancelled, the block will not grow.
- */
-public class BlockGrowEvent extends BlockEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private final BlockState newState;
-    private boolean cancelled = false;
-
-    public BlockGrowEvent(final Block block, final BlockState newState) {
-        super(block);
-        this.newState = newState;
-    }
-
-    /**
-     * Gets the state of the block where it will form or spread to.
-     *
-     * @return The block state for this events block
-     */
-    public BlockState getNewState() {
-        return newState;
-    }
-
-    public boolean isCancelled() {
-        return cancelled;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancelled = cancel;
-    }
-
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/block/BlockIgniteEvent.java b/src/main/java/org/bukkit/event/block/BlockIgniteEvent.java
deleted file mode 100644
index 5ea8b07..0000000
--- a/src/main/java/org/bukkit/event/block/BlockIgniteEvent.java
+++ /dev/null
@@ -1,134 +0,0 @@
-package org.bukkit.event.block;
-
-import org.bukkit.block.Block;
-import org.bukkit.entity.Entity;
-import org.bukkit.entity.Player;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a block is ignited. If you want to catch when a Player places
- * fire, you need to use {@link BlockPlaceEvent}.
- * <p>
- * If a Block Ignite event is cancelled, the block will not be ignited.
- */
-public class BlockIgniteEvent extends BlockEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private final IgniteCause cause;
-    private final Entity ignitingEntity;
-    private final Block ignitingBlock;
-    private boolean cancel;
-
-    @Deprecated
-    public BlockIgniteEvent(final Block theBlock, final IgniteCause cause, final Player thePlayer) {
-        this(theBlock, cause, (Entity) thePlayer);
-    }
-
-    public BlockIgniteEvent(final Block theBlock, final IgniteCause cause, final Entity ignitingEntity) {
-        this(theBlock, cause, ignitingEntity, null);
-    }
-
-    public BlockIgniteEvent(final Block theBlock, final IgniteCause cause, final Block ignitingBlock) {
-        this(theBlock, cause, null, ignitingBlock);
-    }
-
-    public BlockIgniteEvent(final Block theBlock, final IgniteCause cause, final Entity ignitingEntity, final Block ignitingBlock) {
-        super(theBlock);
-        this.cause = cause;
-        this.ignitingEntity = ignitingEntity;
-        this.ignitingBlock = ignitingBlock;
-        this.cancel = false;
-    }
-
-    public boolean isCancelled() {
-        return cancel;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancel = cancel;
-    }
-
-    /**
-     * Gets the cause of block ignite.
-     *
-     * @return An IgniteCause value detailing the cause of block ignition
-     */
-    public IgniteCause getCause() {
-        return cause;
-    }
-
-    /**
-     * Gets the player who ignited this block
-     *
-     * @return The Player that placed/ignited the fire block, or null if not ignited by a Player.
-     */
-    public Player getPlayer() {
-        if (ignitingEntity instanceof Player) {
-            return (Player) ignitingEntity;
-        }
-
-        return null;
-    }
-
-    /**
-     * Gets the entity who ignited this block
-     *
-     * @return The Entity that placed/ignited the fire block, or null if not ignited by a Entity.
-     */
-    public Entity getIgnitingEntity() {
-        return ignitingEntity;
-    }
-
-    /**
-     * Gets the block who ignited this block
-     *
-     * @return The Block that placed/ignited the fire block, or null if not ignited by a Block.
-     */
-    public Block getIgnitingBlock() {
-        return ignitingBlock;
-    }
-
-    /**
-     * An enum to specify the cause of the ignite
-     */
-    public enum IgniteCause {
-
-        /**
-         * Block ignition caused by lava.
-         */
-        LAVA,
-        /**
-         * Block ignition caused by a player or dispenser using flint-and-steel.
-         */
-        FLINT_AND_STEEL,
-        /**
-         * Block ignition caused by dynamic spreading of fire.
-         */
-        SPREAD,
-        /**
-         * Block ignition caused by lightning.
-         */
-        LIGHTNING,
-        /**
-         * Block ignition caused by an entity using a fireball.
-         */
-        FIREBALL,
-        /**
-         * Block ignition caused by an Ender Crystal.
-         */
-        ENDER_CRYSTAL,
-        /**
-         * Block ignition caused by explosion.
-         */
-        EXPLOSION,
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/block/BlockMultiPlaceEvent.java b/src/main/java/org/bukkit/event/block/BlockMultiPlaceEvent.java
deleted file mode 100644
index d16e4be..0000000
--- a/src/main/java/org/bukkit/event/block/BlockMultiPlaceEvent.java
+++ /dev/null
@@ -1,36 +0,0 @@
-package org.bukkit.event.block;
-
-import com.google.common.collect.ImmutableList;
-import org.bukkit.block.Block;
-import org.bukkit.block.BlockState;
-import org.bukkit.entity.Player;
-import org.bukkit.inventory.ItemStack;
-
-import java.util.List;
-
-/**
- * Fired when a single block placement action of a player triggers the
- * creation of multiple blocks(e.g. placing a bed block). The block returned
- * by {@link #getBlockPlaced()} and its related methods is the block where
- * the placed block would exist if the placement only affected a single
- * block.
- */
-public class BlockMultiPlaceEvent extends BlockPlaceEvent {
-    private final List<BlockState> states;
-
-    public BlockMultiPlaceEvent(List<BlockState> states, Block clicked, ItemStack itemInHand, Player thePlayer, boolean canBuild) {
-        super(states.get(0).getBlock(), states.get(0), clicked, itemInHand, thePlayer, canBuild);
-        this.states = ImmutableList.copyOf(states);
-    }
-
-    /**
-     * Gets a list of blockstates for all blocks which were replaced by the
-     * placement of the new blocks. Most of these blocks will just have a
-     * Material type of AIR.
-     *
-     * @return immutable list of replaced BlockStates
-     */
-    public List<BlockState> getReplacedBlockStates() {
-        return states;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/block/BlockPhysicsEvent.java b/src/main/java/org/bukkit/event/block/BlockPhysicsEvent.java
deleted file mode 100644
index 01a545b..0000000
--- a/src/main/java/org/bukkit/event/block/BlockPhysicsEvent.java
+++ /dev/null
@@ -1,64 +0,0 @@
-package org.bukkit.event.block;
-
-import org.bukkit.block.Block;
-import org.bukkit.Material;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Thrown when a block physics check is called
- */
-public class BlockPhysicsEvent extends BlockEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private final int changed;
-    private boolean cancel = false;
-
-    /**
-     *
-     * @deprecated Magic value
-     * @param block the block involved in this event
-     * @param changed the changed block's type id
-     */
-    @Deprecated
-    public BlockPhysicsEvent(final Block block, final int changed) {
-        super(block);
-        this.changed = changed;
-    }
-
-    /**
-     * Gets the type of block that changed, causing this event
-     *
-     * @return Changed block's type id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public int getChangedTypeId() {
-        return changed;
-    }
-
-    /**
-     * Gets the type of block that changed, causing this event
-     *
-     * @return Changed block's type
-     */
-    public Material getChangedType() {
-        return Material.getMaterial(changed);
-    }
-
-    public boolean isCancelled() {
-        return cancel;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancel = cancel;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/block/BlockPistonEvent.java b/src/main/java/org/bukkit/event/block/BlockPistonEvent.java
deleted file mode 100644
index 074d71c..0000000
--- a/src/main/java/org/bukkit/event/block/BlockPistonEvent.java
+++ /dev/null
@@ -1,48 +0,0 @@
-package org.bukkit.event.block;
-
-import org.bukkit.Material;
-import org.bukkit.block.Block;
-import org.bukkit.block.BlockFace;
-import org.bukkit.event.Cancellable;
-
-/**
- * Called when a piston block is triggered
- */
-public abstract class BlockPistonEvent extends BlockEvent implements Cancellable {
-    private boolean cancelled;
-    private final BlockFace direction;
-
-    public BlockPistonEvent(final Block block, final BlockFace direction) {
-        super(block);
-        this.direction = direction;
-    }
-
-    public boolean isCancelled() {
-        return this.cancelled;
-    }
-
-    public void setCancelled(boolean cancelled) {
-        this.cancelled = cancelled;
-    }
-
-    /**
-     * Returns true if the Piston in the event is sticky.
-     *
-     * @return stickiness of the piston
-     */
-    public boolean isSticky() {
-        return block.getType() == Material.PISTON_STICKY_BASE || block.getType() == Material.PISTON_MOVING_PIECE;
-    }
-
-    /**
-     * Return the direction in which the piston will operate.
-     *
-     * @return direction of the piston
-     */
-    public BlockFace getDirection() {
-        // Both are meh!
-        // return ((PistonBaseMaterial) block.getType().getNewData(block.getData())).getFacing();
-        // return ((PistonBaseMaterial) block.getState().getData()).getFacing();
-        return direction;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/block/BlockPistonExtendEvent.java b/src/main/java/org/bukkit/event/block/BlockPistonExtendEvent.java
deleted file mode 100644
index 682ce60..0000000
--- a/src/main/java/org/bukkit/event/block/BlockPistonExtendEvent.java
+++ /dev/null
@@ -1,70 +0,0 @@
-package org.bukkit.event.block;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-
-import org.bukkit.block.Block;
-import org.bukkit.block.BlockFace;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a piston extends
- */
-public class BlockPistonExtendEvent extends BlockPistonEvent {
-    private static final HandlerList handlers = new HandlerList();
-    private final int length;
-    private List<Block> blocks;
-
-    @Deprecated
-    public BlockPistonExtendEvent(final Block block, final int length, final BlockFace direction) {
-        super(block, direction);
-
-        this.length = length;
-    }
-
-    public BlockPistonExtendEvent(final Block block, final List<Block> blocks, final BlockFace direction) {
-        super(block, direction);
-
-        this.length = blocks.size();
-        this.blocks = blocks;
-    }
-
-    /**
-     * Get the amount of blocks which will be moved while extending.
-     *
-     * @return the amount of moving blocks
-     * @deprecated slime blocks make the value of this method
-     *          inaccurate due to blocks being pushed at the side
-     */
-    @Deprecated
-    public int getLength() {
-        return this.length;
-    }
-
-    /**
-     * Get an immutable list of the blocks which will be moved by the
-     * extending.
-     *
-     * @return Immutable list of the moved blocks.
-     */
-    public List<Block> getBlocks() {
-        if (blocks == null) {
-            ArrayList<Block> tmp = new ArrayList<Block>();
-            for (int i = 0; i < this.getLength(); i++) {
-                tmp.add(block.getRelative(getDirection(), i + 1));
-            }
-            blocks = Collections.unmodifiableList(tmp);
-        }
-        return blocks;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/block/BlockPistonRetractEvent.java b/src/main/java/org/bukkit/event/block/BlockPistonRetractEvent.java
deleted file mode 100644
index 6d42917..0000000
--- a/src/main/java/org/bukkit/event/block/BlockPistonRetractEvent.java
+++ /dev/null
@@ -1,51 +0,0 @@
-package org.bukkit.event.block;
-
-import java.util.List;
-import org.bukkit.Location;
-import org.bukkit.block.Block;
-import org.bukkit.block.BlockFace;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a piston retracts
- */
-public class BlockPistonRetractEvent extends BlockPistonEvent {
-    private static final HandlerList handlers = new HandlerList();
-    private List<Block> blocks;
-    
-    public BlockPistonRetractEvent(final Block block, final List<Block> blocks, final BlockFace direction) {
-        super(block, direction);
-        
-        this.blocks = blocks;
-    }
-
-    /**
-     * Gets the location where the possible moving block might be if the
-     * retracting piston is sticky.
-     *
-     * @return The possible location of the possibly moving block.
-     */
-    @Deprecated
-    public Location getRetractLocation() {
-        return getBlock().getRelative(getDirection(), 2).getLocation();
-    }
-    
-    /**
-     * Get an immutable list of the blocks which will be moved by the
-     * extending.
-     *
-     * @return Immutable list of the moved blocks.
-     */
-    public List<Block> getBlocks() {
-        return blocks;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/block/BlockPlaceEvent.java b/src/main/java/org/bukkit/event/block/BlockPlaceEvent.java
deleted file mode 100644
index 0ee9e46..0000000
--- a/src/main/java/org/bukkit/event/block/BlockPlaceEvent.java
+++ /dev/null
@@ -1,137 +0,0 @@
-package org.bukkit.event.block;
-
-import org.bukkit.block.Block;
-import org.bukkit.block.BlockState;
-import org.bukkit.entity.Player;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-import org.bukkit.inventory.EquipmentSlot;
-import org.bukkit.inventory.ItemStack;
-
-/**
- * Called when a block is placed by a player.
- * <p>
- * If a Block Place event is cancelled, the block will not be placed.
- */
-public class BlockPlaceEvent extends BlockEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    protected boolean cancel;
-    protected boolean canBuild;
-    protected Block placedAgainst;
-    protected BlockState replacedBlockState;
-    protected ItemStack itemInHand;
-    protected Player player;
-    protected EquipmentSlot hand;
-
-    @Deprecated
-    public BlockPlaceEvent(final Block placedBlock, final BlockState replacedBlockState, final Block placedAgainst, final ItemStack itemInHand, final Player thePlayer, final boolean canBuild) {
-        this(placedBlock, replacedBlockState, placedAgainst, itemInHand, thePlayer, canBuild, EquipmentSlot.HAND);
-    }
-
-    public BlockPlaceEvent(final Block placedBlock, final BlockState replacedBlockState, final Block placedAgainst, final ItemStack itemInHand, final Player thePlayer, final boolean canBuild, final EquipmentSlot hand) {
-        super(placedBlock);
-        this.placedAgainst = placedAgainst;
-        this.itemInHand = itemInHand;
-        this.player = thePlayer;
-        this.replacedBlockState = replacedBlockState;
-        this.canBuild = canBuild;
-        this.hand = hand;
-        cancel = false;
-    }
-
-    public boolean isCancelled() {
-        return cancel;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancel = cancel;
-    }
-
-    /**
-     * Gets the player who placed the block involved in this event.
-     *
-     * @return The Player who placed the block involved in this event
-     */
-    public Player getPlayer() {
-        return player;
-    }
-
-    /**
-     * Clarity method for getting the placed block. Not really needed except
-     * for reasons of clarity.
-     *
-     * @return The Block that was placed
-     */
-    public Block getBlockPlaced() {
-        return getBlock();
-    }
-
-    /**
-     * Gets the BlockState for the block which was replaced. Material type air
-     * mostly.
-     *
-     * @return The BlockState for the block which was replaced.
-     */
-    public BlockState getBlockReplacedState() {
-        return this.replacedBlockState;
-    }
-
-    /**
-     * Gets the block that this block was placed against
-     *
-     * @return Block the block that the new block was placed against
-     */
-    public Block getBlockAgainst() {
-        return placedAgainst;
-    }
-
-    /**
-     * Gets the item in the player's hand when they placed the block.
-     *
-     * @return The ItemStack for the item in the player's hand when they
-     *     placed the block
-     */
-    public ItemStack getItemInHand() {
-        return itemInHand;
-    }
-
-    /**
-     * Gets the hand which placed the block
-     * @return Main or off-hand, depending on which hand was used to place the block
-     */
-    public EquipmentSlot getHand() {
-        return this.hand;
-    }
-
-    /**
-     * Gets the value whether the player would be allowed to build here.
-     * Defaults to spawn if the server was going to stop them (such as, the
-     * player is in Spawn). Note that this is an entirely different check
-     * than BLOCK_CANBUILD, as this refers to a player, not universe-physics
-     * rule like cactus on dirt.
-     *
-     * @return boolean whether the server would allow a player to build here
-     */
-    public boolean canBuild() {
-        return this.canBuild;
-    }
-
-    /**
-     * Sets the canBuild state of this event. Set to true if you want the
-     * player to be able to build.
-     *
-     * @param canBuild true if you want the player to be able to build
-     */
-    public void setBuild(boolean canBuild) {
-        this.canBuild = canBuild;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/block/BlockRedstoneEvent.java b/src/main/java/org/bukkit/event/block/BlockRedstoneEvent.java
deleted file mode 100644
index 625ec90..0000000
--- a/src/main/java/org/bukkit/event/block/BlockRedstoneEvent.java
+++ /dev/null
@@ -1,55 +0,0 @@
-package org.bukkit.event.block;
-
-import org.bukkit.block.Block;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a redstone current changes
- */
-public class BlockRedstoneEvent extends BlockEvent {
-    private static final HandlerList handlers = new HandlerList();
-    private final int oldCurrent;
-    private int newCurrent;
-
-    public BlockRedstoneEvent(final Block block, final int oldCurrent, final int newCurrent) {
-        super(block);
-        this.oldCurrent = oldCurrent;
-        this.newCurrent = newCurrent;
-    }
-
-    /**
-     * Gets the old current of this block
-     *
-     * @return The previous current
-     */
-    public int getOldCurrent() {
-        return oldCurrent;
-    }
-
-    /**
-     * Gets the new current of this block
-     *
-     * @return The new current
-     */
-    public int getNewCurrent() {
-        return newCurrent;
-    }
-
-    /**
-     * Sets the new current of this block
-     *
-     * @param newCurrent The new current to set
-     */
-    public void setNewCurrent(int newCurrent) {
-        this.newCurrent = newCurrent;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/block/BlockSpreadEvent.java b/src/main/java/org/bukkit/event/block/BlockSpreadEvent.java
deleted file mode 100644
index a1fb363..0000000
--- a/src/main/java/org/bukkit/event/block/BlockSpreadEvent.java
+++ /dev/null
@@ -1,49 +0,0 @@
-package org.bukkit.event.block;
-
-import org.bukkit.block.Block;
-import org.bukkit.block.BlockState;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a block spreads based on world conditions.
- * <p>
- * Use {@link BlockFormEvent} to catch blocks that "randomly" form instead of
- * actually spread.
- * <p>
- * Examples:
- * <ul>
- * <li>Mushrooms spreading.
- * <li>Fire spreading.
- * </ul>
- * <p>
- * If a Block Spread event is cancelled, the block will not spread.
- *
- * @see BlockFormEvent
- */
-public class BlockSpreadEvent extends BlockFormEvent {
-    private static final HandlerList handlers = new HandlerList();
-    private final Block source;
-
-    public BlockSpreadEvent(final Block block, final Block source, final BlockState newState) {
-        super(block, newState);
-        this.source = source;
-    }
-
-    /**
-     * Gets the source block involved in this event.
-     *
-     * @return the Block for the source block involved in this event.
-     */
-    public Block getSource() {
-        return source;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/block/CauldronLevelChangeEvent.java b/src/main/java/org/bukkit/event/block/CauldronLevelChangeEvent.java
deleted file mode 100644
index 3a0fbba..0000000
--- a/src/main/java/org/bukkit/event/block/CauldronLevelChangeEvent.java
+++ /dev/null
@@ -1,110 +0,0 @@
-package org.bukkit.event.block;
-
-import com.google.common.base.Preconditions;
-import org.bukkit.block.Block;
-import org.bukkit.entity.Entity;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-public class CauldronLevelChangeEvent extends BlockEvent implements Cancellable {
-
-    private static final HandlerList handlers = new HandlerList();
-    private boolean cancelled;
-    //
-    private final Entity entity;
-    private final ChangeReason reason;
-    private final int oldLevel;
-    private int newLevel;
-
-    public CauldronLevelChangeEvent(Block block, Entity entity, ChangeReason reason, int oldLevel, int newLevel) {
-        super(block);
-        this.entity = entity;
-        this.reason = reason;
-        this.oldLevel = oldLevel;
-        this.newLevel = newLevel;
-    }
-
-    /**
-     * Get entity which did this. May be null.
-     *
-     * @return acting entity
-     */
-    public Entity getEntity() {
-        return entity;
-    }
-
-    public ChangeReason getReason() {
-        return reason;
-    }
-
-    public int getOldLevel() {
-        return oldLevel;
-    }
-
-    public int getNewLevel() {
-        return newLevel;
-    }
-
-    public void setNewLevel(int newLevel) {
-        Preconditions.checkArgument(0 <= newLevel && newLevel <= 3, "Cauldron level out of bounds 0 <= %s <= 3", newLevel);
-        this.newLevel = newLevel;
-    }
-
-    @Override
-    public boolean isCancelled() {
-        return cancelled;
-    }
-
-    @Override
-    public void setCancelled(boolean cancelled) {
-        this.cancelled = cancelled;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-
-    public enum ChangeReason {
-        /**
-         * Player emptying the cauldron by filling their bucket.
-         */
-        BUCKET_FILL,
-        /**
-         * Player filling the cauldron by emptying their bucket.
-         */
-        BUCKET_EMPTY,
-        /**
-         * Player emptying the cauldron by filling their bottle.
-         */
-        BOTTLE_FILL,
-        /**
-         * Player filling the cauldron by emptying their bottle.
-         */
-        BOTTLE_EMPTY,
-        /**
-         * Player cleaning their banner.
-         */
-        BANNER_WASH,
-        /**
-         * Player cleaning their armor.
-         */
-        ARMOR_WASH,
-        /**
-         * Entity being extinguished.
-         */
-        EXTINGUISH,
-        /**
-         * Evaporating due to biome dryness.
-         */
-        EVAPORATE,
-        /**
-         * Unknown.
-         */
-        UNKNOWN
-    }
-}
diff --git a/src/main/java/org/bukkit/event/block/EntityBlockFormEvent.java b/src/main/java/org/bukkit/event/block/EntityBlockFormEvent.java
deleted file mode 100644
index 4ce034f..0000000
--- a/src/main/java/org/bukkit/event/block/EntityBlockFormEvent.java
+++ /dev/null
@@ -1,33 +0,0 @@
-package org.bukkit.event.block;
-
-import org.bukkit.block.Block;
-import org.bukkit.block.BlockState;
-import org.bukkit.entity.Entity;
-
-/**
- * Called when a block is formed by entities.
- * <p>
- * Examples:
- * <ul>
- * <li>Snow formed by a {@link org.bukkit.entity.Snowman}.
- * <li>Frosted Ice formed by the Frost Walker enchantment.
- * </ul>
- */
-public class EntityBlockFormEvent extends BlockFormEvent {
-    private final Entity entity;
-
-    public EntityBlockFormEvent(final Entity entity, final Block block, final BlockState blockstate) {
-        super(block, blockstate);
-
-        this.entity = entity;
-    }
-
-    /**
-     * Get the entity that formed the block.
-     *
-     * @return Entity involved in event
-     */
-    public Entity getEntity() {
-        return entity;
-    }
-}
\ No newline at end of file
diff --git a/src/main/java/org/bukkit/event/block/LeavesDecayEvent.java b/src/main/java/org/bukkit/event/block/LeavesDecayEvent.java
deleted file mode 100644
index 84d8cfd..0000000
--- a/src/main/java/org/bukkit/event/block/LeavesDecayEvent.java
+++ /dev/null
@@ -1,36 +0,0 @@
-package org.bukkit.event.block;
-
-import org.bukkit.block.Block;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when leaves are decaying naturally.
- * <p>
- * If a Leaves Decay event is cancelled, the leaves will not decay.
- */
-public class LeavesDecayEvent extends BlockEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private boolean cancel = false;
-
-    public LeavesDecayEvent(final Block block) {
-        super(block);
-    }
-
-    public boolean isCancelled() {
-        return cancel;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancel = cancel;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/block/NotePlayEvent.java b/src/main/java/org/bukkit/event/block/NotePlayEvent.java
deleted file mode 100644
index d4d4381..0000000
--- a/src/main/java/org/bukkit/event/block/NotePlayEvent.java
+++ /dev/null
@@ -1,83 +0,0 @@
-package org.bukkit.event.block;
-
-import org.bukkit.Instrument;
-import org.bukkit.Note;
-import org.bukkit.block.Block;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a note block is being played through player interaction or a
- * redstone current.
- */
-public class NotePlayEvent extends BlockEvent implements Cancellable {
-
-    private static HandlerList handlers = new HandlerList();
-    private Instrument instrument;
-    private Note note;
-    private boolean cancelled = false;
-
-    public NotePlayEvent(Block block, Instrument instrument, Note note) {
-        super(block);
-        this.instrument = instrument;
-        this.note = note;
-    }
-
-    public boolean isCancelled() {
-        return cancelled;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancelled = cancel;
-    }
-
-    /**
-     * Gets the {@link Instrument} to be used.
-     *
-     * @return the Instrument;
-     */
-    public Instrument getInstrument() {
-        return instrument;
-    }
-
-    /**
-     * Gets the {@link Note} to be played.
-     *
-     * @return the Note.
-     */
-    public Note getNote() {
-        return note;
-    }
-
-    /**
-     * Overrides the {@link Instrument} to be used.
-     *
-     * @param instrument the Instrument. Has no effect if null.
-     */
-    public void setInstrument(Instrument instrument) {
-        if (instrument != null) {
-            this.instrument = instrument;
-        }
-
-    }
-
-    /**
-     * Overrides the {@link Note} to be played.
-     *
-     * @param note the Note. Has no effect if null.
-     */
-    public void setNote(Note note) {
-        if (note != null) {
-            this.note = note;
-        }
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/block/SignChangeEvent.java b/src/main/java/org/bukkit/event/block/SignChangeEvent.java
deleted file mode 100644
index 83188cf..0000000
--- a/src/main/java/org/bukkit/event/block/SignChangeEvent.java
+++ /dev/null
@@ -1,84 +0,0 @@
-package org.bukkit.event.block;
-
-import org.bukkit.block.Block;
-import org.bukkit.entity.Player;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a sign is changed by a player.
- * <p>
- * If a Sign Change event is cancelled, the sign will not be changed.
- */
-public class SignChangeEvent extends BlockEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private boolean cancel = false;
-    private final Player player;
-    private final String[] lines;
-
-    public SignChangeEvent(final Block theBlock, final Player thePlayer, final String[] theLines) {
-        super(theBlock);
-        this.player = thePlayer;
-        this.lines = theLines;
-    }
-
-    /**
-     * Gets the player changing the sign involved in this event.
-     *
-     * @return the Player involved in this event
-     */
-    public Player getPlayer() {
-        return player;
-    }
-
-    /**
-     * Gets all of the lines of text from the sign involved in this event.
-     *
-     * @return the String array for the sign's lines new text
-     */
-    public String[] getLines() {
-        return lines;
-    }
-
-    /**
-     * Gets a single line of text from the sign involved in this event.
-     *
-     * @param index index of the line to get
-     * @return the String containing the line of text associated with the
-     *     provided index
-     * @throws IndexOutOfBoundsException thrown when the provided index is {@literal > 3
-     *     or < 0}
-     */
-    public String getLine(int index) throws IndexOutOfBoundsException {
-        return lines[index];
-    }
-
-    /**
-     * Sets a single line for the sign involved in this event
-     *
-     * @param index index of the line to set
-     * @param line text to set
-     * @throws IndexOutOfBoundsException thrown when the provided index is {@literal > 3
-     *     or < 0}
-     */
-    public void setLine(int index, String line) throws IndexOutOfBoundsException {
-        lines[index] = line;
-    }
-
-    public boolean isCancelled() {
-        return cancel;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancel = cancel;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/enchantment/EnchantItemEvent.java b/src/main/java/org/bukkit/event/enchantment/EnchantItemEvent.java
deleted file mode 100644
index de28f1d..0000000
--- a/src/main/java/org/bukkit/event/enchantment/EnchantItemEvent.java
+++ /dev/null
@@ -1,121 +0,0 @@
-package org.bukkit.event.enchantment;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import org.bukkit.block.Block;
-import org.bukkit.enchantments.Enchantment;
-import org.bukkit.entity.Player;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-import org.bukkit.event.inventory.InventoryEvent;
-import org.bukkit.inventory.InventoryView;
-import org.bukkit.inventory.ItemStack;
-
-/**
- * Called when an ItemStack is successfully enchanted (currently at
- * enchantment table)
- */
-public class EnchantItemEvent extends InventoryEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private final Block table;
-    private final ItemStack item;
-    private int level;
-    private boolean cancelled;
-    private final Map<Enchantment,Integer> enchants;
-    private final Player enchanter;
-    private int button;
-
-    public EnchantItemEvent(final Player enchanter, final InventoryView view, final Block table, final ItemStack item, final int level, final Map<Enchantment, Integer> enchants, final int i) {
-        super(view);
-        this.enchanter = enchanter;
-        this.table = table;
-        this.item = item;
-        this.level = level;
-        this.enchants = new HashMap<Enchantment, Integer>(enchants);
-        this.cancelled = false;
-        this.button = i;
-    }
-
-    /**
-     * Gets the player enchanting the item
-     *
-     * @return enchanting player
-     */
-    public Player getEnchanter() {
-        return enchanter;
-    }
-
-    /**
-     * Gets the block being used to enchant the item
-     *
-     * @return the block used for enchanting
-     */
-    public Block getEnchantBlock() {
-        return table;
-    }
-
-    /**
-     * Gets the item to be enchanted (can be modified)
-     *
-     * @return ItemStack of item
-     */
-    public ItemStack getItem() {
-        return item;
-    }
-
-    /**
-     * Get cost in exp levels of the enchantment
-     *
-     * @return experience level cost
-     */
-    public int getExpLevelCost() {
-        return level;
-    }
-
-    /**
-     * Set cost in exp levels of the enchantment
-     *
-     * @param level - cost in levels
-     */
-    public void setExpLevelCost(int level) {
-        this.level = level;
-    }
-
-    /**
-     * Get map of enchantment (levels, keyed by type) to be added to item
-     * (modify map returned to change values). Note: Any enchantments not
-     * allowed for the item will be ignored
-     *
-     * @return map of enchantment levels, keyed by enchantment
-     */
-    public Map<Enchantment, Integer> getEnchantsToAdd() {
-        return enchants;
-    }
-
-    /**
-     * Which button was pressed to initiate the enchanting.
-     *
-     * @return The button index (0, 1, or 2).
-     */
-    public int whichButton() {
-        return button;
-    }
-
-    public boolean isCancelled() {
-        return cancelled;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancelled = cancel;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/enchantment/PrepareItemEnchantEvent.java b/src/main/java/org/bukkit/event/enchantment/PrepareItemEnchantEvent.java
deleted file mode 100644
index 6c0aa9f..0000000
--- a/src/main/java/org/bukkit/event/enchantment/PrepareItemEnchantEvent.java
+++ /dev/null
@@ -1,96 +0,0 @@
-package org.bukkit.event.enchantment;
-
-import org.bukkit.block.Block;
-import org.bukkit.entity.Player;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-import org.bukkit.event.inventory.InventoryEvent;
-import org.bukkit.inventory.InventoryView;
-import org.bukkit.inventory.ItemStack;
-
-/**
- * Called when an ItemStack is inserted in an enchantment table - can be
- * called multiple times
- */
-public class PrepareItemEnchantEvent extends InventoryEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private final Block table;
-    private final ItemStack item;
-    private final int[] levelsOffered;
-    private final int bonus;
-    private boolean cancelled;
-    private final Player enchanter;
-
-    public PrepareItemEnchantEvent(final Player enchanter, InventoryView view, final Block table, final ItemStack item, final int[] levelsOffered, final int bonus) {
-        super(view);
-        this.enchanter = enchanter;
-        this.table = table;
-        this.item = item;
-        this.levelsOffered = levelsOffered;
-        this.bonus = bonus;
-        this.cancelled = false;
-    }
-
-    /**
-     * Gets the player enchanting the item
-     *
-     * @return enchanting player
-     */
-    public Player getEnchanter() {
-        return enchanter;
-    }
-
-    /**
-     * Gets the block being used to enchant the item
-     *
-     * @return the block used for enchanting
-     */
-    public Block getEnchantBlock() {
-        return table;
-    }
-
-    /**
-     * Gets the item to be enchanted (can be modified)
-     *
-     * @return ItemStack of item
-     */
-    public ItemStack getItem() {
-        return item;
-    }
-
-    /**
-     * Get list of offered exp level costs of the enchantment (modify values
-     * to change offer)
-     *
-     * @return experience level costs offered
-     */
-    public int[] getExpLevelCostsOffered() {
-        return levelsOffered;
-    }
-
-    /**
-     * Get enchantment bonus in effect - corresponds to number of bookshelves
-     *
-     * @return enchantment bonus
-     */
-    public int getEnchantmentBonus() {
-        return bonus;
-    }
-
-    public boolean isCancelled() {
-        return cancelled;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancelled = cancel;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/entity/AreaEffectCloudApplyEvent.java b/src/main/java/org/bukkit/event/entity/AreaEffectCloudApplyEvent.java
deleted file mode 100644
index 849b69f..0000000
--- a/src/main/java/org/bukkit/event/entity/AreaEffectCloudApplyEvent.java
+++ /dev/null
@@ -1,55 +0,0 @@
-package org.bukkit.event.entity;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-import java.util.Map;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.entity.AreaEffectCloud;
-import org.bukkit.entity.LivingEntity;
-import org.bukkit.entity.ThrownPotion;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a lingering potion applies it's effects. Happens
- * once every 5 ticks
- */
-public class AreaEffectCloudApplyEvent extends EntityEvent {
-    private static final HandlerList handlers = new HandlerList();
-    private final List<LivingEntity> affectedEntities;
-
-    public AreaEffectCloudApplyEvent(final AreaEffectCloud entity, final List<LivingEntity> affectedEntities) {
-        super(entity);
-        this.affectedEntities = affectedEntities;
-    }
-
-    @Override
-    public AreaEffectCloud getEntity() {
-        return (AreaEffectCloud) entity;
-    }
-
-    /**
-     * Retrieves a mutable list of the effected entities
-     * <p>
-     * It is important to note that not every entity in this list
-     * is guaranteed to be effected.  The cloud may die during the
-     * application of its effects due to the depletion of {@link AreaEffectCloud#getDurationOnUse()}
-     * or {@link AreaEffectCloud#getRadiusOnUse()}
-     *
-     * @return the affected entity list
-     */
-    public List<LivingEntity> getAffectedEntities() {
-        return affectedEntities;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/entity/CreatureSpawnEvent.java b/src/main/java/org/bukkit/event/entity/CreatureSpawnEvent.java
deleted file mode 100644
index b5778f5..0000000
--- a/src/main/java/org/bukkit/event/entity/CreatureSpawnEvent.java
+++ /dev/null
@@ -1,180 +0,0 @@
-package org.bukkit.event.entity;
-
-import org.bukkit.Location;
-import org.bukkit.entity.Entity;
-import org.bukkit.entity.LivingEntity;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a creature is spawned into a world.
- * <p>
- * If a Creature Spawn event is cancelled, the creature will not spawn.
- */
-public class CreatureSpawnEvent extends EntityEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private boolean canceled;
-    private final SpawnReason spawnReason;
-
-    public CreatureSpawnEvent(final LivingEntity spawnee, final SpawnReason spawnReason) {
-        super(spawnee);
-        this.spawnReason = spawnReason;
-    }
-
-    public boolean isCancelled() {
-        return canceled;
-    }
-
-    public void setCancelled(boolean cancel) {
-        canceled = cancel;
-    }
-
-    @Override
-    public LivingEntity getEntity() {
-        return (LivingEntity) entity;
-    }
-
-    /**
-     * Gets the location at which the creature is spawning.
-     *
-     * @return The location at which the creature is spawning
-     */
-    public Location getLocation() {
-        return getEntity().getLocation();
-    }
-
-    /**
-     * Gets the reason for why the creature is being spawned.
-     *
-     * @return A SpawnReason value detailing the reason for the creature being
-     *     spawned
-     */
-    public SpawnReason getSpawnReason() {
-        return spawnReason;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-
-    /**
-     * An enum to specify the type of spawning
-     */
-    public enum SpawnReason {
-
-        /**
-         * When something spawns from natural means
-         */
-        NATURAL,
-        /**
-         * When an entity spawns as a jockey of another entity (mostly spider
-         * jockeys)
-         */
-        JOCKEY,
-        /**
-         * When a creature spawns due to chunk generation
-         */
-        CHUNK_GEN,
-        /**
-         * When a creature spawns from a spawner
-         */
-        SPAWNER,
-        /**
-         * When a creature spawns from an egg
-         */
-        EGG,
-        /**
-         * When a creature spawns from a Spawner Egg
-         */
-        SPAWNER_EGG,
-        /**
-         * When a creature spawns because of a lightning strike
-         */
-        LIGHTNING,
-        /**
-         * When a creature is spawned by a player that is sleeping
-         *
-         * @deprecated No longer used
-         */
-        @Deprecated
-        BED,
-        /**
-         * When a snowman is spawned by being built
-         */
-        BUILD_SNOWMAN,
-        /**
-         * When an iron golem is spawned by being built
-         */
-        BUILD_IRONGOLEM,
-        /**
-         * When a wither boss is spawned by being built
-         */
-        BUILD_WITHER,
-        /**
-         * When an iron golem is spawned to defend a village
-         */
-        VILLAGE_DEFENSE,
-        /**
-         * When a zombie is spawned to invade a village
-         */
-        VILLAGE_INVASION,
-        /**
-         * When an animal breeds to create a child
-         */
-        BREEDING,
-        /**
-         * When a slime splits
-         */
-        SLIME_SPLIT,
-        /**
-         * When an entity calls for reinforcements
-         */
-        REINFORCEMENTS,
-        /**
-         * When a creature is spawned by nether portal
-         */
-        NETHER_PORTAL,
-        /**
-         * When a creature is spawned by a dispenser dispensing an egg
-         */
-        DISPENSE_EGG,
-        /**
-         * When a zombie infects a villager
-         */
-        INFECTION,
-        /**
-         * When a villager is cured from infection
-         */
-        CURED,
-        /**
-         * When an ocelot has a baby spawned along with them
-         */
-        OCELOT_BABY,
-        /**
-         * When a silverfish spawns from a block
-         */
-        SILVERFISH_BLOCK,
-        /**
-         * When an entity spawns as a mount of another entity (mostly chicken
-         * jockeys)
-         */
-        MOUNT,
-        /**
-         * When an entity spawns as a trap for players approaching
-         */
-        TRAP,
-        /**
-         * When a creature is spawned by plugins
-         */
-        CUSTOM,
-        /**
-         * When an entity is missing a SpawnReason
-         */
-        DEFAULT
-    }
-}
diff --git a/src/main/java/org/bukkit/event/entity/CreeperPowerEvent.java b/src/main/java/org/bukkit/event/entity/CreeperPowerEvent.java
deleted file mode 100644
index b103a6a..0000000
--- a/src/main/java/org/bukkit/event/entity/CreeperPowerEvent.java
+++ /dev/null
@@ -1,93 +0,0 @@
-package org.bukkit.event.entity;
-
-import org.bukkit.entity.Creeper;
-import org.bukkit.entity.LightningStrike;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a Creeper is struck by lightning.
- * <p>
- * If a Creeper Power event is cancelled, the Creeper will not be powered.
- */
-public class CreeperPowerEvent extends EntityEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private boolean canceled;
-    private final PowerCause cause;
-    private LightningStrike bolt;
-
-    public CreeperPowerEvent(final Creeper creeper, final LightningStrike bolt, final PowerCause cause) {
-        this(creeper, cause);
-        this.bolt = bolt;
-    }
-
-    public CreeperPowerEvent(final Creeper creeper, final PowerCause cause) {
-        super(creeper);
-        this.cause = cause;
-    }
-
-    public boolean isCancelled() {
-        return canceled;
-    }
-
-    public void setCancelled(boolean cancel) {
-        canceled = cancel;
-    }
-
-    @Override
-    public Creeper getEntity() {
-        return (Creeper) entity;
-    }
-
-    /**
-     * Gets the lightning bolt which is striking the Creeper.
-     *
-     * @return The Entity for the lightning bolt which is striking the Creeper
-     */
-    public LightningStrike getLightning() {
-        return bolt;
-    }
-
-    /**
-     * Gets the cause of the creeper being (un)powered.
-     *
-     * @return A PowerCause value detailing the cause of change in power.
-     */
-    public PowerCause getCause() {
-        return cause;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-
-    /**
-     * An enum to specify the cause of the change in power
-     */
-    public enum PowerCause {
-
-        /**
-         * Power change caused by a lightning bolt
-         * <p>
-         * Powered state: true
-         */
-        LIGHTNING,
-        /**
-         * Power change caused by something else (probably a plugin)
-         * <p>
-         * Powered state: true
-         */
-        SET_ON,
-        /**
-         * Power change caused by something else (probably a plugin)
-         * <p>
-         * Powered state: false
-         */
-        SET_OFF
-    }
-}
diff --git a/src/main/java/org/bukkit/event/entity/EnderDragonChangePhaseEvent.java b/src/main/java/org/bukkit/event/entity/EnderDragonChangePhaseEvent.java
deleted file mode 100644
index 92b9615..0000000
--- a/src/main/java/org/bukkit/event/entity/EnderDragonChangePhaseEvent.java
+++ /dev/null
@@ -1,76 +0,0 @@
-package org.bukkit.event.entity;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.entity.EnderDragon;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when an EnderDragon switches controller phase.
- */
-public class EnderDragonChangePhaseEvent extends EntityEvent implements Cancellable {
-
-    private static final HandlerList handlers = new HandlerList();
-    private boolean cancel;
-    private final EnderDragon.Phase currentPhase;
-    private EnderDragon.Phase newPhase;
-
-    public EnderDragonChangePhaseEvent(EnderDragon enderDragon, EnderDragon.Phase currentPhase, EnderDragon.Phase newPhase) {
-        super(enderDragon);
-        this.currentPhase = currentPhase;
-        this.setNewPhase(newPhase);
-    }
-
-    @Override
-    public EnderDragon getEntity() {
-        return (EnderDragon) entity;
-    }
-
-    /**
-     * Gets the current phase that the dragon is in. This method will return null 
-     * when a dragon is first spawned and hasn't yet been assigned a phase.
-     * 
-     * @return the current dragon phase
-     */
-    public EnderDragon.Phase getCurrentPhase() {
-        return currentPhase;
-    }
-
-    /**
-     * Gets the new phase that the dragon will switch to.
-     * 
-     * @return the new dragon phase
-     */
-    public EnderDragon.Phase getNewPhase() {
-        return newPhase;
-    }
-
-    /**
-     * Sets the new phase for the ender dragon.
-     * 
-     * @param newPhase the new dragon phase
-     */
-    public void setNewPhase(EnderDragon.Phase newPhase) {
-        Validate.notNull(newPhase, "New dragon phase cannot be null");
-        this.newPhase = newPhase;
-    }
-
-    @Override
-    public boolean isCancelled() {
-        return cancel;
-    }
-
-    @Override
-    public void setCancelled(boolean cancel) {
-        this.cancel = cancel;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/entity/EntityBreakDoorEvent.java b/src/main/java/org/bukkit/event/entity/EntityBreakDoorEvent.java
deleted file mode 100644
index 2cbbc69..0000000
--- a/src/main/java/org/bukkit/event/entity/EntityBreakDoorEvent.java
+++ /dev/null
@@ -1,22 +0,0 @@
-package org.bukkit.event.entity;
-
-import org.bukkit.Material;
-import org.bukkit.block.Block;
-import org.bukkit.entity.Entity;
-import org.bukkit.entity.LivingEntity;
-
-/**
- * Called when an {@link Entity} breaks a door
- * <p>
- * Cancelling the event will cause the event to be delayed
- */
-public class EntityBreakDoorEvent extends EntityChangeBlockEvent {
-    public EntityBreakDoorEvent(final LivingEntity entity, final Block targetBlock) {
-        super(entity, targetBlock, Material.AIR, (byte) 0);
-    }
-
-    @Override
-    public LivingEntity getEntity() {
-        return (LivingEntity) entity;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/entity/EntityChangeBlockEvent.java b/src/main/java/org/bukkit/event/entity/EntityChangeBlockEvent.java
deleted file mode 100644
index 41be9ca..0000000
--- a/src/main/java/org/bukkit/event/entity/EntityChangeBlockEvent.java
+++ /dev/null
@@ -1,95 +0,0 @@
-package org.bukkit.event.entity;
-
-import org.bukkit.Material;
-import org.bukkit.block.Block;
-import org.bukkit.entity.Entity;
-import org.bukkit.entity.LivingEntity;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when any Entity, excluding players, changes a block.
- */
-public class EntityChangeBlockEvent extends EntityEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private final Block block;
-    private boolean cancel;
-    private final Material to;
-    private final byte data;
-
-    /**
-     *
-     * @param what the LivingEntity causing the change
-     * @param block the block (before the change)
-     * @param to the future material being changed to
-     * @deprecated Provided as a backward compatibility before the data byte
-     *     was provided, and type increased to all entities
-     */
-    @Deprecated
-    public EntityChangeBlockEvent(final LivingEntity what, final Block block, final Material to) {
-        this (what, block, to, (byte) 0);
-    }
-
-    /**
-     *
-     * @param what the Entity causing the change
-     * @param block the block (before the change)
-     * @param to the future material being changed to
-     * @param data the future block data
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public EntityChangeBlockEvent(final Entity what, final Block block, final Material to, final byte data) {
-        super(what);
-        this.block = block;
-        this.cancel = false;
-        this.to = to;
-        this.data = data;
-    }
-
-    /**
-     * Gets the block the entity is changing
-     *
-     * @return the block that is changing
-     */
-    public Block getBlock() {
-        return block;
-    }
-
-    public boolean isCancelled() {
-        return cancel;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancel = cancel;
-    }
-
-    /**
-     * Gets the Material that the block is changing into
-     *
-     * @return the material that the block is changing into
-     */
-    public Material getTo() {
-        return to;
-    }
-
-    /**
-     * Gets the data for the block that would be changed into
-     *
-     * @return the data for the block that would be changed into
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public byte getData() {
-        return data;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/entity/EntityCombustByBlockEvent.java b/src/main/java/org/bukkit/event/entity/EntityCombustByBlockEvent.java
deleted file mode 100644
index c84bda9..0000000
--- a/src/main/java/org/bukkit/event/entity/EntityCombustByBlockEvent.java
+++ /dev/null
@@ -1,27 +0,0 @@
-package org.bukkit.event.entity;
-
-import org.bukkit.block.Block;
-import org.bukkit.entity.Entity;
-
-/**
- * Called when a block causes an entity to combust.
- */
-public class EntityCombustByBlockEvent extends EntityCombustEvent {
-    private final Block combuster;
-
-    public EntityCombustByBlockEvent(final Block combuster, final Entity combustee, final int duration) {
-        super(combustee, duration);
-        this.combuster = combuster;
-    }
-
-    /**
-     * The combuster can be lava or a block that is on fire.
-     * <p>
-     * WARNING: block may be null.
-     *
-     * @return the Block that set the combustee alight.
-     */
-    public Block getCombuster() {
-        return combuster;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/entity/EntityCombustByEntityEvent.java b/src/main/java/org/bukkit/event/entity/EntityCombustByEntityEvent.java
deleted file mode 100644
index 639567b..0000000
--- a/src/main/java/org/bukkit/event/entity/EntityCombustByEntityEvent.java
+++ /dev/null
@@ -1,24 +0,0 @@
-package org.bukkit.event.entity;
-
-import org.bukkit.entity.Entity;
-
-/**
- * Called when an entity causes another entity to combust.
- */
-public class EntityCombustByEntityEvent extends EntityCombustEvent {
-    private final Entity combuster;
-
-    public EntityCombustByEntityEvent(final Entity combuster, final Entity combustee, final int duration) {
-        super(combustee, duration);
-        this.combuster = combuster;
-    }
-
-    /**
-     * Get the entity that caused the combustion event.
-     *
-     * @return the Entity that set the combustee alight.
-     */
-    public Entity getCombuster() {
-        return combuster;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/entity/EntityCombustEvent.java b/src/main/java/org/bukkit/event/entity/EntityCombustEvent.java
deleted file mode 100644
index 43c4482..0000000
--- a/src/main/java/org/bukkit/event/entity/EntityCombustEvent.java
+++ /dev/null
@@ -1,59 +0,0 @@
-package org.bukkit.event.entity;
-
-import org.bukkit.entity.Entity;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when an entity combusts.
- * <p>
- * If an Entity Combust event is cancelled, the entity will not combust.
- */
-public class EntityCombustEvent extends EntityEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private int duration;
-    private boolean cancel;
-
-    public EntityCombustEvent(final Entity combustee, final int duration) {
-        super(combustee);
-        this.duration = duration;
-        this.cancel = false;
-    }
-
-    public boolean isCancelled() {
-        return cancel;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancel = cancel;
-    }
-
-    /**
-     * @return the amount of time (in seconds) the combustee should be alight
-     *     for
-     */
-    public int getDuration() {
-        return duration;
-    }
-
-    /**
-     * The number of seconds the combustee should be alight for.
-     * <p>
-     * This value will only ever increase the combustion time, not decrease
-     * existing combustion times.
-     *
-     * @param duration the time in seconds to be alight for.
-     */
-    public void setDuration(int duration) {
-        this.duration = duration;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/entity/EntityCreatePortalEvent.java b/src/main/java/org/bukkit/event/entity/EntityCreatePortalEvent.java
deleted file mode 100644
index 286c206..0000000
--- a/src/main/java/org/bukkit/event/entity/EntityCreatePortalEvent.java
+++ /dev/null
@@ -1,65 +0,0 @@
-package org.bukkit.event.entity;
-
-import java.util.List;
-import org.bukkit.PortalType;
-import org.bukkit.block.BlockState;
-import org.bukkit.entity.LivingEntity;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Thrown when a Living Entity creates a portal in a world.
- */
-public class EntityCreatePortalEvent extends EntityEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private final List<BlockState> blocks;
-    private boolean cancelled = false;
-    private PortalType type = PortalType.CUSTOM;
-
-    public EntityCreatePortalEvent(final LivingEntity what, final List<BlockState> blocks, final PortalType type) {
-        super(what);
-
-        this.blocks = blocks;
-        this.type = type;
-    }
-
-    @Override
-    public LivingEntity getEntity() {
-        return (LivingEntity) entity;
-    }
-
-    /**
-     * Gets a list of all blocks associated with the portal.
-     *
-     * @return List of blocks that will be changed.
-     */
-    public List<BlockState> getBlocks() {
-        return blocks;
-    }
-
-    public boolean isCancelled() {
-        return cancelled;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancelled = cancel;
-    }
-
-    /**
-     * Gets the type of portal that is trying to be created.
-     *
-     * @return Type of portal.
-     */
-    public PortalType getPortalType() {
-        return type;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/entity/EntityDamageByBlockEvent.java b/src/main/java/org/bukkit/event/entity/EntityDamageByBlockEvent.java
deleted file mode 100644
index 2ff121e..0000000
--- a/src/main/java/org/bukkit/event/entity/EntityDamageByBlockEvent.java
+++ /dev/null
@@ -1,39 +0,0 @@
-package org.bukkit.event.entity;
-
-import java.util.Map;
-
-import com.google.common.base.Function;
-import org.bukkit.block.Block;
-import org.bukkit.entity.Entity;
-
-/**
- * Called when an entity is damaged by a block
- */
-public class EntityDamageByBlockEvent extends EntityDamageEvent {
-    private final Block damager;
-
-    @Deprecated
-    public EntityDamageByBlockEvent(final Block damager, final Entity damagee, final DamageCause cause, final int damage) {
-        this(damager, damagee, cause, (double) damage);
-    }
-
-    @Deprecated
-    public EntityDamageByBlockEvent(final Block damager, final Entity damagee, final DamageCause cause, final double damage) {
-        super(damagee, cause, damage);
-        this.damager = damager;
-    }
-
-    public EntityDamageByBlockEvent(final Block damager, final Entity damagee, final DamageCause cause, final Map<DamageModifier, Double> modifiers, final Map<DamageModifier, ? extends Function<? super Double, Double>> modifierFunctions) {
-        super(damagee, cause, modifiers, modifierFunctions);
-        this.damager = damager;
-    }
-
-    /**
-     * Returns the block that damaged the player.
-     *
-     * @return Block that damaged the player
-     */
-    public Block getDamager() {
-        return damager;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/entity/EntityDamageByEntityEvent.java b/src/main/java/org/bukkit/event/entity/EntityDamageByEntityEvent.java
deleted file mode 100644
index 49e74c3..0000000
--- a/src/main/java/org/bukkit/event/entity/EntityDamageByEntityEvent.java
+++ /dev/null
@@ -1,38 +0,0 @@
-package org.bukkit.event.entity;
-
-import java.util.Map;
-
-import com.google.common.base.Function;
-import org.bukkit.entity.Entity;
-
-/**
- * Called when an entity is damaged by an entity
- */
-public class EntityDamageByEntityEvent extends EntityDamageEvent {
-    private final Entity damager;
-
-    @Deprecated
-    public EntityDamageByEntityEvent(final Entity damager, final Entity damagee, final DamageCause cause, final int damage) {
-        this(damager, damagee, cause, (double) damage);
-    }
-
-    @Deprecated
-    public EntityDamageByEntityEvent(final Entity damager, final Entity damagee, final DamageCause cause, final double damage) {
-        super(damagee, cause, damage);
-        this.damager = damager;
-    }
-
-    public EntityDamageByEntityEvent(final Entity damager, final Entity damagee, final DamageCause cause, final Map<DamageModifier, Double> modifiers, final Map<DamageModifier, ? extends Function<? super Double, Double>> modifierFunctions) {
-        super(damagee, cause, modifiers, modifierFunctions);
-        this.damager = damager;
-    }
-
-    /**
-     * Returns the entity that damaged the defender.
-     *
-     * @return Entity that damaged the defender.
-     */
-    public Entity getDamager() {
-        return damager;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/entity/EntityDamageEvent.java b/src/main/java/org/bukkit/event/entity/EntityDamageEvent.java
deleted file mode 100644
index 3a5a42a..0000000
--- a/src/main/java/org/bukkit/event/entity/EntityDamageEvent.java
+++ /dev/null
@@ -1,429 +0,0 @@
-package org.bukkit.event.entity;
-
-import java.util.EnumMap;
-import java.util.Map;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.entity.Entity;
-import org.bukkit.entity.Player;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-import org.bukkit.util.NumberConversions;
-
-import com.google.common.base.Function;
-import com.google.common.base.Functions;
-import com.google.common.collect.ImmutableMap;
-
-/**
- * Stores data for damage events
- */
-public class EntityDamageEvent extends EntityEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private static final DamageModifier[] MODIFIERS = DamageModifier.values();
-    private static final Function<? super Double, Double> ZERO = Functions.constant(-0.0);
-    private final Map<DamageModifier, Double> modifiers;
-    private final Map<DamageModifier, ? extends Function<? super Double, Double>> modifierFunctions;
-    private final Map<DamageModifier, Double> originals;
-    private boolean cancelled;
-    private final DamageCause cause;
-
-    @Deprecated
-    public EntityDamageEvent(final Entity damagee, final DamageCause cause, final int damage) {
-        this(damagee, cause, (double) damage);
-    }
-
-    @Deprecated
-    public EntityDamageEvent(final Entity damagee, final DamageCause cause, final double damage) {
-        this(damagee, cause, new EnumMap<DamageModifier, Double>(ImmutableMap.of(DamageModifier.BASE, damage)), new EnumMap<DamageModifier, Function<? super Double, Double>>(ImmutableMap.of(DamageModifier.BASE, ZERO)));
-    }
-
-    public EntityDamageEvent(final Entity damagee, final DamageCause cause, final Map<DamageModifier, Double> modifiers, final Map<DamageModifier, ? extends Function<? super Double, Double>> modifierFunctions) {
-        super(damagee);
-        Validate.isTrue(modifiers.containsKey(DamageModifier.BASE), "BASE DamageModifier missing");
-        Validate.isTrue(!modifiers.containsKey(null), "Cannot have null DamageModifier");
-        Validate.noNullElements(modifiers.values(), "Cannot have null modifier values");
-        Validate.isTrue(modifiers.keySet().equals(modifierFunctions.keySet()), "Must have a modifier function for each DamageModifier");
-        Validate.noNullElements(modifierFunctions.values(), "Cannot have null modifier function");
-        this.originals = new EnumMap<DamageModifier, Double>(modifiers);
-        this.cause = cause;
-        this.modifiers = modifiers;
-        this.modifierFunctions = modifierFunctions;
-    }
-
-    public boolean isCancelled() {
-        return cancelled;
-    }
-
-    public void setCancelled(boolean cancel) {
-        cancelled = cancel;
-    }
-
-    /**
-     * Gets the original damage for the specified modifier, as defined at this
-     * event's construction.
-     *
-     * @param type the modifier
-     * @return the original damage
-     * @throws IllegalArgumentException if type is null
-     */
-    public double getOriginalDamage(DamageModifier type) throws IllegalArgumentException {
-        final Double damage = originals.get(type);
-        if (damage != null) {
-            return damage;
-        }
-        if (type == null) {
-            throw new IllegalArgumentException("Cannot have null DamageModifier");
-        }
-        return 0;
-    }
-
-    /**
-     * Sets the damage for the specified modifier.
-     *
-     * @param type the damage modifier
-     * @param damage the scalar value of the damage's modifier
-     * @see #getFinalDamage()
-     * @throws IllegalArgumentException if type is null
-     * @throws UnsupportedOperationException if the caller does not support
-     *     the particular DamageModifier, or to rephrase, when {@link
-     *     #isApplicable(DamageModifier)} returns false
-     */
-    public void setDamage(DamageModifier type, double damage) throws IllegalArgumentException, UnsupportedOperationException {
-        if (!modifiers.containsKey(type)) {
-            throw type == null ? new IllegalArgumentException("Cannot have null DamageModifier") : new UnsupportedOperationException(type + " is not applicable to " + getEntity());
-        }
-        modifiers.put(type, damage);
-    }
-
-    /**
-     * Gets the damage change for some modifier
-     *
-     * @param type the damage modifier
-     * @return The raw amount of damage caused by the event
-     * @throws IllegalArgumentException if type is null
-     * @see DamageModifier#BASE
-     */
-    public double getDamage(DamageModifier type) throws IllegalArgumentException {
-        Validate.notNull(type, "Cannot have null DamageModifier");
-        final Double damage = modifiers.get(type);
-        return damage == null ? 0 : damage;
-    }
-
-    /**
-     * This checks to see if a particular modifier is valid for this event's
-     * caller, such that, {@link #setDamage(DamageModifier, double)} will not
-     * throw an {@link UnsupportedOperationException}.
-     * <p>
-     * {@link DamageModifier#BASE} is always applicable.
-     *
-     * @param type the modifier
-     * @return true if the modifier is supported by the caller, false otherwise
-     * @throws IllegalArgumentException if type is null
-     */
-    public boolean isApplicable(DamageModifier type) throws IllegalArgumentException {
-        Validate.notNull(type, "Cannot have null DamageModifier");
-        return modifiers.containsKey(type);
-    }
-
-    /**
-     * Gets the raw amount of damage caused by the event
-     *
-     * @return The raw amount of damage caused by the event
-     * @see DamageModifier#BASE
-     */
-    public double getDamage() {
-        return getDamage(DamageModifier.BASE);
-    }
-
-    /**
-     * Gets the amount of damage caused by the event after all damage
-     * reduction is applied.
-     *
-     * @return the amount of damage caused by the event
-     */
-    public final double getFinalDamage() {
-        double damage = 0;
-        for (DamageModifier modifier : MODIFIERS) {
-            damage += getDamage(modifier);
-        }
-        return damage;
-    }
-
-    /**
-     * This method exists for legacy reasons to provide backwards
-     * compatibility. It will not exist at runtime and should not be used
-     * under any circumstances.
-     * 
-     * @return the (rounded) damage
-     */
-    @Deprecated
-    public int _INVALID_getDamage() {
-        return NumberConversions.ceil(getDamage());
-    }
-
-    /**
-     * Sets the raw amount of damage caused by the event.
-     * <p>
-     * For compatibility this also recalculates the modifiers and scales
-     * them by the difference between the modifier for the previous damage
-     * value and the new one.
-     *
-     * @param damage The raw amount of damage caused by the event
-     */
-    public void setDamage(double damage) {
-        // These have to happen in the same order as the server calculates them, keep the enum sorted
-        double remaining = damage;
-        double oldRemaining = getDamage(DamageModifier.BASE);
-        for (DamageModifier modifier : MODIFIERS) {
-            if (!isApplicable(modifier)) {
-                continue;
-            }
-
-            Function<? super Double, Double> modifierFunction = modifierFunctions.get(modifier);
-            double newVanilla = modifierFunction.apply(remaining);
-            double oldVanilla = modifierFunction.apply(oldRemaining);
-            double difference = oldVanilla - newVanilla;
-
-            // Don't allow value to cross zero, assume zero values should be negative
-            double old = getDamage(modifier);
-            if (old > 0) {
-                setDamage(modifier, Math.max(0, old - difference));
-            } else {
-                setDamage(modifier, Math.min(0, old - difference));
-            }
-            remaining += newVanilla;
-            oldRemaining += oldVanilla;
-        }
-
-        setDamage(DamageModifier.BASE, damage);
-    }
-
-    /**
-     * This method exists for legacy reasons to provide backwards
-     * compatibility. It will not exist at runtime and should not be used
-     * under any circumstances.
-     * 
-     * @param damage the new damage value
-     */
-    @Deprecated
-    public void _INVALID_setDamage(int damage) {
-        setDamage(damage);
-    }
-
-    /**
-     * Gets the cause of the damage.
-     *
-     * @return A DamageCause value detailing the cause of the damage.
-     */
-    public DamageCause getCause() {
-        return cause;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-
-    /**
-     * An enum to specify the types of modifier
-     */
-    public enum DamageModifier {
-        /**
-         * This represents the amount of damage being done, also known as the
-         * raw {@link EntityDamageEvent#getDamage()}.
-         */
-        BASE,
-        /**
-         * This represents the damage reduced by a wearing a helmet when hit
-         * by a falling block.
-         */
-        HARD_HAT,
-        /**
-         * This represents  the damage reduction caused by blocking, only present for
-         * {@link Player Players}.
-         */
-        BLOCKING,
-        /**
-         * This represents the damage reduction caused by wearing armor.
-         */
-        ARMOR,
-        /**
-         * This represents the damage reduction caused by the Resistance potion effect.
-         */
-        RESISTANCE,
-        /**
-         * This represents the damage reduction caused by the combination of:
-         * <ul>
-         * <li>
-         *     Armor enchantments
-         * </li><li>
-         *     Witch's potion resistance
-         * </li>
-         * </ul>
-         */
-        MAGIC,
-        /**
-         * This represents the damage reduction caused by the absorption potion
-         * effect.
-         */
-        ABSORPTION,
-        ;
-    }
-
-    /**
-     * An enum to specify the cause of the damage
-     */
-    public enum DamageCause {
-
-        /**
-         * Damage caused when an entity contacts a block such as a Cactus.
-         * <p>
-         * Damage: 1 (Cactus)
-         */
-        CONTACT,
-        /**
-         * Damage caused when an entity attacks another entity.
-         * <p>
-         * Damage: variable
-         */
-        ENTITY_ATTACK,
-        /**
-         * Damage caused when attacked by a projectile.
-         * <p>
-         * Damage: variable
-         */
-        PROJECTILE,
-        /**
-         * Damage caused by being put in a block
-         * <p>
-         * Damage: 1
-         */
-        SUFFOCATION,
-        /**
-         * Damage caused when an entity falls a distance greater than 3 blocks
-         * <p>
-         * Damage: fall height - 3.0
-         */
-        FALL,
-        /**
-         * Damage caused by direct exposure to fire
-         * <p>
-         * Damage: 1
-         */
-        FIRE,
-        /**
-         * Damage caused due to burns caused by fire
-         * <p>
-         * Damage: 1
-         */
-        FIRE_TICK,
-        /**
-         * Damage caused due to a snowman melting
-         * <p>
-         * Damage: 1
-         */
-        MELTING,
-        /**
-         * Damage caused by direct exposure to lava
-         * <p>
-         * Damage: 4
-         */
-        LAVA,
-        /**
-         * Damage caused by running out of air while in water
-         * <p>
-         * Damage: 2
-         */
-        DROWNING,
-        /**
-         * Damage caused by being in the area when a block explodes.
-         * <p>
-         * Damage: variable
-         */
-        BLOCK_EXPLOSION,
-        /**
-         * Damage caused by being in the area when an entity, such as a
-         * Creeper, explodes.
-         * <p>
-         * Damage: variable
-         */
-        ENTITY_EXPLOSION,
-        /**
-         * Damage caused by falling into the void
-         * <p>
-         * Damage: 4 for players
-         */
-        VOID,
-        /**
-         * Damage caused by being struck by lightning
-         * <p>
-         * Damage: 5
-         */
-        LIGHTNING,
-        /**
-         * Damage caused by committing suicide using the command "/kill"
-         * <p>
-         * Damage: 1000
-         */
-        SUICIDE,
-        /**
-         * Damage caused by starving due to having an empty hunger bar
-         * <p>
-         * Damage: 1
-         */
-        STARVATION,
-        /**
-         * Damage caused due to an ongoing poison effect
-         * <p>
-         * Damage: 1
-         */
-        POISON,
-        /**
-         * Damage caused by being hit by a damage potion or spell
-         * <p>
-         * Damage: variable
-         */
-        MAGIC,
-        /**
-         * Damage caused by Wither potion effect
-         */
-        WITHER,
-        /**
-         * Damage caused by being hit by a falling block which deals damage
-         * <p>
-         * <b>Note:</b> Not every block deals damage
-         * <p>
-         * Damage: variable
-         */
-        FALLING_BLOCK,
-        /**
-         * Damage caused in retaliation to another attack by the Thorns
-         * enchantment.
-         * <p>
-         * Damage: 1-4 (Thorns)
-         */
-        THORNS,
-        /**
-         * Damage caused by a dragon breathing fire.
-         * <p>
-         * Damage: variable
-         */
-        DRAGON_BREATH,
-        /**
-         * Custom damage.
-         * <p>
-         * Damage: variable
-         */
-        CUSTOM,
-        /**
-         * Damage caused when an entity runs into a wall.
-         * <p>
-         * Damage: variable
-         */
-        FLY_INTO_WALL
-    }
-}
diff --git a/src/main/java/org/bukkit/event/entity/EntityDeathEvent.java b/src/main/java/org/bukkit/event/entity/EntityDeathEvent.java
deleted file mode 100644
index ab9e81f..0000000
--- a/src/main/java/org/bukkit/event/entity/EntityDeathEvent.java
+++ /dev/null
@@ -1,72 +0,0 @@
-package org.bukkit.event.entity;
-
-import java.util.List;
-import org.bukkit.entity.LivingEntity;
-import org.bukkit.event.HandlerList;
-import org.bukkit.inventory.ItemStack;
-
-/**
- * Thrown whenever a LivingEntity dies
- */
-public class EntityDeathEvent extends EntityEvent {
-    private static final HandlerList handlers = new HandlerList();
-    private final List<ItemStack> drops;
-    private int dropExp = 0;
-
-    public EntityDeathEvent(final LivingEntity entity, final List<ItemStack> drops) {
-        this(entity, drops, 0);
-    }
-
-    public EntityDeathEvent(final LivingEntity what, final List<ItemStack> drops, final int droppedExp) {
-        super(what);
-        this.drops = drops;
-        this.dropExp = droppedExp;
-    }
-
-    @Override
-    public LivingEntity getEntity() {
-        return (LivingEntity) entity;
-    }
-
-    /**
-     * Gets how much EXP should be dropped from this death.
-     * <p>
-     * This does not indicate how much EXP should be taken from the entity in
-     * question, merely how much should be created after its death.
-     *
-     * @return Amount of EXP to drop.
-     */
-    public int getDroppedExp() {
-        return dropExp;
-    }
-
-    /**
-     * Sets how much EXP should be dropped from this death.
-     * <p>
-     * This does not indicate how much EXP should be taken from the entity in
-     * question, merely how much should be created after its death.
-     *
-     * @param exp Amount of EXP to drop.
-     */
-    public void setDroppedExp(int exp) {
-        this.dropExp = exp;
-    }
-
-    /**
-     * Gets all the items which will drop when the entity dies
-     *
-     * @return Items to drop when the entity dies
-     */
-    public List<ItemStack> getDrops() {
-        return drops;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/entity/EntityEvent.java b/src/main/java/org/bukkit/event/entity/EntityEvent.java
deleted file mode 100644
index c9a4ab3..0000000
--- a/src/main/java/org/bukkit/event/entity/EntityEvent.java
+++ /dev/null
@@ -1,34 +0,0 @@
-package org.bukkit.event.entity;
-
-import org.bukkit.entity.Entity;
-import org.bukkit.entity.EntityType;
-import org.bukkit.event.Event;
-
-/**
- * Represents an Entity-related event
- */
-public abstract class EntityEvent extends Event {
-    protected Entity entity;
-
-    public EntityEvent(final Entity what) {
-        entity = what;
-    }
-
-    /**
-     * Returns the Entity involved in this event
-     *
-     * @return Entity who is involved in this event
-     */
-    public Entity getEntity() {
-        return entity;
-    }
-
-    /**
-     * Gets the EntityType of the Entity involved in this event.
-     *
-     * @return EntityType of the Entity involved in this event
-     */
-    public EntityType getEntityType() {
-        return entity.getType();
-    }
-}
diff --git a/src/main/java/org/bukkit/event/entity/EntityExplodeEvent.java b/src/main/java/org/bukkit/event/entity/EntityExplodeEvent.java
deleted file mode 100644
index 287035d..0000000
--- a/src/main/java/org/bukkit/event/entity/EntityExplodeEvent.java
+++ /dev/null
@@ -1,85 +0,0 @@
-package org.bukkit.event.entity;
-
-import org.bukkit.Location;
-import org.bukkit.block.Block;
-import org.bukkit.entity.Entity;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-import java.util.List;
-
-/**
- * Called when an entity explodes
- */
-public class EntityExplodeEvent extends EntityEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private boolean cancel;
-    private final Location location;
-    private final List<Block> blocks;
-    private float yield;
-
-    public EntityExplodeEvent(final Entity what, final Location location, final List<Block> blocks, final float yield) {
-        super(what);
-        this.location = location;
-        this.blocks = blocks;
-        this.yield = yield;
-        this.cancel = false;
-    }
-
-    public boolean isCancelled() {
-        return cancel;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancel = cancel;
-    }
-
-    /**
-     * Returns the list of blocks that would have been removed or were removed
-     * from the explosion event.
-     *
-     * @return All blown-up blocks
-     */
-    public List<Block> blockList() {
-        return blocks;
-    }
-
-    /**
-     * Returns the location where the explosion happened.
-     * <p>
-     * It is not possible to get this value from the Entity as the Entity no
-     * longer exists in the world.
-     *
-     * @return The location of the explosion
-     */
-    public Location getLocation() {
-        return location;
-    }
-
-    /**
-     * Returns the percentage of blocks to drop from this explosion
-     *
-     * @return The yield.
-     */
-    public float getYield() {
-        return yield;
-    }
-
-    /**
-     * Sets the percentage of blocks to drop from this explosion
-     *
-     * @param yield The new yield percentage
-     */
-    public void setYield(float yield) {
-        this.yield = yield;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/entity/EntityInteractEvent.java b/src/main/java/org/bukkit/event/entity/EntityInteractEvent.java
deleted file mode 100644
index 1c4e100..0000000
--- a/src/main/java/org/bukkit/event/entity/EntityInteractEvent.java
+++ /dev/null
@@ -1,46 +0,0 @@
-package org.bukkit.event.entity;
-
-import org.bukkit.block.Block;
-import org.bukkit.entity.Entity;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when an entity interacts with an object
- */
-public class EntityInteractEvent extends EntityEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    protected Block block;
-    private boolean cancelled;
-
-    public EntityInteractEvent(final Entity entity, final Block block) {
-        super(entity);
-        this.block = block;
-    }
-
-    public boolean isCancelled() {
-        return cancelled;
-    }
-
-    public void setCancelled(boolean cancel) {
-        cancelled = cancel;
-    }
-
-    /**
-     * Returns the involved block
-     *
-     * @return the block clicked with this item.
-     */
-    public Block getBlock() {
-        return block;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/entity/EntityPortalEnterEvent.java b/src/main/java/org/bukkit/event/entity/EntityPortalEnterEvent.java
deleted file mode 100644
index 87d57b0..0000000
--- a/src/main/java/org/bukkit/event/entity/EntityPortalEnterEvent.java
+++ /dev/null
@@ -1,36 +0,0 @@
-package org.bukkit.event.entity;
-
-import org.bukkit.entity.Entity;
-import org.bukkit.Location;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when an entity comes into contact with a portal
- */
-public class EntityPortalEnterEvent extends EntityEvent {
-    private static final HandlerList handlers = new HandlerList();
-    private final Location location;
-
-    public EntityPortalEnterEvent(final Entity entity, final Location location) {
-        super(entity);
-        this.location = location;
-    }
-
-    /**
-     * Gets the portal block the entity is touching
-     *
-     * @return The portal block the entity is touching
-     */
-    public Location getLocation() {
-        return location;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/entity/EntityPortalEvent.java b/src/main/java/org/bukkit/event/entity/EntityPortalEvent.java
deleted file mode 100644
index 835c054..0000000
--- a/src/main/java/org/bukkit/event/entity/EntityPortalEvent.java
+++ /dev/null
@@ -1,82 +0,0 @@
-package org.bukkit.event.entity;
-
-import org.bukkit.Location;
-import org.bukkit.TravelAgent;
-import org.bukkit.entity.Entity;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a non-player entity is about to teleport because it is in
- * contact with a portal.
- * <p>
- * For players see {@link org.bukkit.event.player.PlayerPortalEvent}
- */
-public class EntityPortalEvent extends EntityTeleportEvent {
-    private static final HandlerList handlers = new HandlerList();
-    protected boolean useTravelAgent = true;
-    protected TravelAgent travelAgent;
-
-    public EntityPortalEvent(final Entity entity, final Location from, final Location to, final TravelAgent pta) {
-        super(entity, from, to);
-        this.travelAgent = pta;
-    }
-
-    /**
-     * Sets whether or not the Travel Agent will be used.
-     * <p>
-     * If this is set to true, the TravelAgent will try to find a Portal at
-     * the {@link #getTo()} Location, and will try to create one if there is
-     * none.
-     * <p>
-     * If this is set to false, the {@link #getEntity()} will only be
-     * teleported to the {@link #getTo()} Location.
-     *
-     * @param useTravelAgent whether to use the Travel Agent
-     */
-    public void useTravelAgent(boolean useTravelAgent) {
-        this.useTravelAgent = useTravelAgent;
-    }
-
-    /**
-     * Gets whether or not the Travel Agent will be used.
-     * <p>
-     * If this is set to true, the TravelAgent will try to find a Portal at
-     * the {@link #getTo()} Location, and will try to create one if there is
-     * none.
-     * <p>
-     * If this is set to false, the {@link #getEntity()} will only be
-     * teleported to the {@link #getTo()} Location.
-     *
-     * @return whether to use the Travel Agent
-     */
-    public boolean useTravelAgent() {
-        return useTravelAgent;
-    }
-
-    /**
-     * Gets the Travel Agent used (or not) in this event.
-     *
-     * @return the Travel Agent used (or not) in this event
-     */
-    public TravelAgent getPortalTravelAgent() {
-        return this.travelAgent;
-    }
-
-    /**
-     * Sets the Travel Agent used (or not) in this event.
-     *
-     * @param travelAgent the Travel Agent used (or not) in this event
-     */
-    public void setPortalTravelAgent(TravelAgent travelAgent) {
-        this.travelAgent = travelAgent;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
\ No newline at end of file
diff --git a/src/main/java/org/bukkit/event/entity/EntityPortalExitEvent.java b/src/main/java/org/bukkit/event/entity/EntityPortalExitEvent.java
deleted file mode 100644
index 41edef6..0000000
--- a/src/main/java/org/bukkit/event/entity/EntityPortalExitEvent.java
+++ /dev/null
@@ -1,62 +0,0 @@
-package org.bukkit.event.entity;
-
-import org.bukkit.Location;
-import org.bukkit.entity.Entity;
-import org.bukkit.event.HandlerList;
-import org.bukkit.util.Vector;
-
-/**
- * Called before an entity exits a portal.
- * <p>
- * This event allows you to modify the velocity of the entity after they have
- * successfully exited the portal.
- */
-public class EntityPortalExitEvent extends EntityTeleportEvent {
-    private static final HandlerList handlers = new HandlerList();
-    private Vector before;
-    private Vector after;
-
-    public EntityPortalExitEvent(final Entity entity, final Location from, final Location to, final Vector before, final Vector after) {
-        super(entity, from, to);
-        this.before = before;
-        this.after = after;
-    }
-
-    /**
-     * Gets a copy of the velocity that the entity has before entering the
-     * portal.
-     *
-     * @return velocity of entity before entering the portal
-     */
-    public Vector getBefore() {
-        return this.before.clone();
-    }
-
-    /**
-     * Gets a copy of the velocity that the entity will have after exiting the
-     * portal.
-     *
-     * @return velocity of entity after exiting the portal
-     */
-    public Vector getAfter() {
-        return this.after.clone();
-    }
-
-    /**
-     * Sets the velocity that the entity will have after exiting the portal.
-     * 
-     * @param after the velocity after exiting the portal
-     */
-    public void setAfter(Vector after) {
-        this.after = after.clone();
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
\ No newline at end of file
diff --git a/src/main/java/org/bukkit/event/entity/EntityRegainHealthEvent.java b/src/main/java/org/bukkit/event/entity/EntityRegainHealthEvent.java
deleted file mode 100644
index a7b3517..0000000
--- a/src/main/java/org/bukkit/event/entity/EntityRegainHealthEvent.java
+++ /dev/null
@@ -1,143 +0,0 @@
-package org.bukkit.event.entity;
-
-import org.bukkit.entity.Entity;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-import org.bukkit.util.NumberConversions;
-
-/**
- * Stores data for health-regain events
- */
-public class EntityRegainHealthEvent extends EntityEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private boolean cancelled;
-    private double amount;
-    private final RegainReason regainReason;
-
-    @Deprecated
-    public EntityRegainHealthEvent(final Entity entity, final int amount, final RegainReason regainReason) {
-        this(entity, (double) amount, regainReason);
-    }
-
-    public EntityRegainHealthEvent(final Entity entity, final double amount, final RegainReason regainReason) {
-        super(entity);
-        this.amount = amount;
-        this.regainReason = regainReason;
-    }
-
-    /**
-     * Gets the amount of regained health
-     *
-     * @return The amount of health regained
-     */
-    public double getAmount() {
-        return amount;
-    }
-
-    /**
-     * This method exists for legacy reasons to provide backwards
-     * compatibility. It will not exist at runtime and should not be used
-     * under any circumstances.
-     * 
-     * @return the (rounded) amount regained
-     */
-    @Deprecated
-    public int _INVALID_getAmount() {
-        return NumberConversions.ceil(getAmount());
-    }
-
-    /**
-     * Sets the amount of regained health
-     *
-     * @param amount the amount of health the entity will regain
-     */
-    public void setAmount(double amount) {
-        this.amount = amount;
-    }
-
-    /**
-     * This method exists for legacy reasons to provide backwards
-     * compatibility. It will not exist at runtime and should not be used
-     * under any circumstances.
-     * 
-     * @param amount the amount that will be regained
-     */
-    @Deprecated
-    public void _INVALID_setAmount(int amount) {
-        setAmount(amount);
-    }
-
-    @Override
-    public boolean isCancelled() {
-        return cancelled;
-    }
-
-    @Override
-    public void setCancelled(boolean cancel) {
-        cancelled = cancel;
-    }
-
-    /**
-     * Gets the reason for why the entity is regaining health
-     *
-     * @return A RegainReason detailing the reason for the entity regaining
-     *     health
-     */
-    public RegainReason getRegainReason() {
-        return regainReason;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-
-    /**
-     * An enum to specify the type of health regaining that is occurring
-     */
-    public enum RegainReason {
-
-        /**
-         * When a player regains health from regenerating due to Peaceful mode
-         * (difficulty=0)
-         */
-        REGEN,
-        /**
-         * When a player regains health from regenerating due to their hunger
-         * being satisfied
-         */
-        SATIATED,
-        /**
-         * When a player regains health from eating consumables
-         */
-        EATING,
-        /**
-         * When an ender dragon regains health from an ender crystal
-         */
-        ENDER_CRYSTAL,
-        /**
-         * When a player is healed by a potion or spell
-         */
-        MAGIC,
-        /**
-         * When a player is healed over time by a potion or spell
-         */
-        MAGIC_REGEN,
-        /**
-         * When a wither is filling its health during spawning
-         */
-        WITHER_SPAWN,
-        /**
-         * When an entity is damaged by the Wither potion effect
-         */
-        WITHER,
-        /**
-         * Any other reason not covered by the reasons above
-         */
-        CUSTOM
-    }
-}
diff --git a/src/main/java/org/bukkit/event/entity/EntityShootBowEvent.java b/src/main/java/org/bukkit/event/entity/EntityShootBowEvent.java
deleted file mode 100644
index f8c91a1..0000000
--- a/src/main/java/org/bukkit/event/entity/EntityShootBowEvent.java
+++ /dev/null
@@ -1,84 +0,0 @@
-package org.bukkit.event.entity;
-
-import org.bukkit.entity.Entity;
-import org.bukkit.entity.LivingEntity;
-import org.bukkit.entity.Projectile;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-import org.bukkit.inventory.ItemStack;
-
-/**
- * Called when a LivingEntity shoots a bow firing an arrow
- */
-public class EntityShootBowEvent extends EntityEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private final ItemStack bow;
-    private Entity projectile;
-    private final float force;
-    private boolean cancelled;
-
-    public EntityShootBowEvent(final LivingEntity shooter, final ItemStack bow, final Projectile projectile, final float force) {
-        super(shooter);
-        this.bow = bow;
-        this.projectile = projectile;
-        this.force = force;
-    }
-
-    @Override
-    public LivingEntity getEntity() {
-        return (LivingEntity) entity;
-    }
-
-    /**
-     * Gets the bow ItemStack used to fire the arrow.
-     *
-     * @return the bow involved in this event
-     */
-    public ItemStack getBow() {
-        return bow;
-    }
-
-    /**
-     * Gets the projectile which will be launched by this event
-     *
-     * @return the launched projectile
-     */
-    public Entity getProjectile() {
-        return projectile;
-    }
-
-    /**
-     * Replaces the projectile which will be launched
-     *
-     * @param projectile the new projectile
-     */
-    public void setProjectile(Entity projectile) {
-        this.projectile = projectile;
-    }
-
-    /**
-     * Gets the force the arrow was launched with
-     *
-     * @return bow shooting force, up to 1.0
-     */
-    public float getForce() {
-        return force;
-    }
-
-    public boolean isCancelled() {
-        return cancelled;
-    }
-
-    public void setCancelled(boolean cancel) {
-        cancelled = cancel;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/entity/EntityTameEvent.java b/src/main/java/org/bukkit/event/entity/EntityTameEvent.java
deleted file mode 100644
index f105817..0000000
--- a/src/main/java/org/bukkit/event/entity/EntityTameEvent.java
+++ /dev/null
@@ -1,51 +0,0 @@
-package org.bukkit.event.entity;
-
-import org.bukkit.entity.AnimalTamer;
-import org.bukkit.entity.LivingEntity;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Thrown when a LivingEntity is tamed
- */
-public class EntityTameEvent extends EntityEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private boolean cancelled;
-    private final AnimalTamer owner;
-
-    public EntityTameEvent(final LivingEntity entity, final AnimalTamer owner) {
-        super(entity);
-        this.owner = owner;
-    }
-
-    @Override
-    public LivingEntity getEntity() {
-        return (LivingEntity) entity;
-    }
-
-    public boolean isCancelled() {
-        return cancelled;
-    }
-
-    public void setCancelled(boolean cancel) {
-        cancelled = cancel;
-    }
-
-    /**
-     * Gets the owning AnimalTamer
-     *
-     * @return the owning AnimalTamer
-     */
-    public AnimalTamer getOwner() {
-        return owner;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/entity/EntityTargetEvent.java b/src/main/java/org/bukkit/event/entity/EntityTargetEvent.java
deleted file mode 100644
index cf67251..0000000
--- a/src/main/java/org/bukkit/event/entity/EntityTargetEvent.java
+++ /dev/null
@@ -1,150 +0,0 @@
-package org.bukkit.event.entity;
-
-import org.bukkit.entity.Entity;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a creature targets or untargets another entity
- */
-public class EntityTargetEvent extends EntityEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private boolean cancel = false;
-    private Entity target;
-    private final TargetReason reason;
-
-    public EntityTargetEvent(final Entity entity, final Entity target, final TargetReason reason) {
-        super(entity);
-        this.target = target;
-        this.reason = reason;
-    }
-
-    public boolean isCancelled() {
-        return cancel;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancel = cancel;
-    }
-
-    /**
-     * Returns the reason for the targeting
-     *
-     * @return The reason
-     */
-    public TargetReason getReason() {
-        return reason;
-    }
-
-    /**
-     * Get the entity that this is targeting.
-     * <p>
-     * This will be null in the case that the event is called when the mob
-     * forgets its target.
-     *
-     * @return The entity
-     */
-    public Entity getTarget() {
-        return target;
-    }
-
-    /**
-     * Set the entity that you want the mob to target instead.
-     * <p>
-     * It is possible to be null, null will cause the entity to be
-     * target-less.
-     * <p>
-     * This is different from cancelling the event. Cancelling the event will
-     * cause the entity to keep an original target, while setting to be null
-     * will cause the entity to be reset.
-     *
-     * @param target The entity to target
-     */
-    public void setTarget(Entity target) {
-        this.target = target;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-
-    /**
-     * An enum to specify the reason for the targeting
-     */
-    public enum TargetReason {
-
-        /**
-         * When the entity's target has died, and so it no longer targets it
-         */
-        TARGET_DIED,
-        /**
-         * When the entity doesn't have a target, so it attacks the nearest
-         * player
-         */
-        CLOSEST_PLAYER,
-        /**
-         * When the target attacks the entity, so entity targets it
-         */
-        TARGET_ATTACKED_ENTITY,
-        /**
-         * When the target attacks a fellow pig zombie, so the whole group
-         * will target him with this reason.
-         */
-        PIG_ZOMBIE_TARGET,
-        /**
-         * When the target is forgotten for whatever reason.
-         * <p>
-         * Currently only occurs in with spiders when there is a high
-         * brightness.
-         */
-        FORGOT_TARGET,
-        /**
-         * When the target attacks the owner of the entity, so the entity
-         * targets it.
-         */
-        TARGET_ATTACKED_OWNER,
-        /**
-         * When the owner of the entity attacks the target attacks, so the
-         * entity targets it.
-         */
-        OWNER_ATTACKED_TARGET,
-        /**
-         * When the entity has no target, so the entity randomly chooses one.
-         */
-        RANDOM_TARGET,
-        /**
-         * When an entity selects a target while defending a village.
-         */
-        DEFEND_VILLAGE,
-        /**
-         * When the target attacks a nearby entity of the same type, so the entity targets it
-         */
-        TARGET_ATTACKED_NEARBY_ENTITY,
-        /**
-         * When a zombie targeting an entity summons reinforcements, so the reinforcements target the same entity
-         */
-        REINFORCEMENT_TARGET,
-        /**
-         * When an entity targets another entity after colliding with it.
-         */
-        COLLISION,
-        /**
-         * For custom calls to the event.
-         */
-        CUSTOM,
-        /**
-         * When the entity doesn't have a target, so it attacks the nearest
-         * entity
-         */
-        CLOSEST_ENTITY,
-        /**
-         * A currently unknown reason for the entity changing target.
-         */
-        UNKNOWN;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/entity/EntityTargetLivingEntityEvent.java b/src/main/java/org/bukkit/event/entity/EntityTargetLivingEntityEvent.java
deleted file mode 100644
index cd9aea1..0000000
--- a/src/main/java/org/bukkit/event/entity/EntityTargetLivingEntityEvent.java
+++ /dev/null
@@ -1,34 +0,0 @@
-package org.bukkit.event.entity;
-
-import org.bukkit.entity.Entity;
-import org.bukkit.entity.LivingEntity;
-
-/**
- * Called when an Entity targets a {@link LivingEntity} and can only target
- * LivingEntity's.
- */
-public class EntityTargetLivingEntityEvent extends EntityTargetEvent{
-    public EntityTargetLivingEntityEvent(final Entity entity, final LivingEntity target, final TargetReason reason) {
-        super(entity, target, reason);
-    }
-
-    public LivingEntity getTarget() {
-        return (LivingEntity) super.getTarget();
-    }
-
-    /**
-     * Set the Entity that you want the mob to target.
-     * <p>
-     * It is possible to be null, null will cause the entity to be
-     * target-less.
-     * <p>
-     * Must be a LivingEntity, or null.
-     *
-     * @param target The entity to target
-     */
-    public void setTarget(Entity target) {
-        if (target == null || target instanceof LivingEntity) {
-            super.setTarget(target);
-        }
-    }
-}
diff --git a/src/main/java/org/bukkit/event/entity/EntityTeleportEvent.java b/src/main/java/org/bukkit/event/entity/EntityTeleportEvent.java
deleted file mode 100644
index 619f8d4..0000000
--- a/src/main/java/org/bukkit/event/entity/EntityTeleportEvent.java
+++ /dev/null
@@ -1,77 +0,0 @@
-package org.bukkit.event.entity;
-
-import org.bukkit.Location;
-import org.bukkit.entity.Entity;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Thrown when a non-player entity (such as an Enderman) tries to teleport
- * from one location to another.
- */
-public class EntityTeleportEvent extends EntityEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private boolean cancel;
-    private Location from;
-    private Location to;
-
-    public EntityTeleportEvent(Entity what, Location from, Location to) {
-        super(what);
-        this.from = from;
-        this.to = to;
-        this.cancel = false;
-    }
-
-    public boolean isCancelled() {
-        return cancel;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancel = cancel;
-    }
-
-    /**
-     * Gets the location that this entity moved from
-     *
-     * @return Location this entity moved from
-     */
-    public Location getFrom() {
-        return from;
-    }
-
-    /**
-     * Sets the location that this entity moved from
-     *
-     * @param from New location this entity moved from
-     */
-    public void setFrom(Location from) {
-        this.from = from;
-    }
-
-    /**
-     * Gets the location that this entity moved to
-     *
-     * @return Location the entity moved to
-     */
-    public Location getTo() {
-        return to;
-    }
-
-    /**
-     * Sets the location that this entity moved to
-     *
-     * @param to New Location this entity moved to
-     */
-    public void setTo(Location to) {
-        this.to = to;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
\ No newline at end of file
diff --git a/src/main/java/org/bukkit/event/entity/EntityToggleGlideEvent.java b/src/main/java/org/bukkit/event/entity/EntityToggleGlideEvent.java
deleted file mode 100644
index 67fbf8f..0000000
--- a/src/main/java/org/bukkit/event/entity/EntityToggleGlideEvent.java
+++ /dev/null
@@ -1,50 +0,0 @@
-package org.bukkit.event.entity;
-
-import org.bukkit.entity.LivingEntity;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Sent when an entity's gliding status is toggled with an Elytra.
- * Examples of when this event would be called:
- * <ul>
- *     <li>Player presses the jump key while in midair and using an Elytra</li>
- *     <li>Player lands on ground while they are gliding (with an Elytra)</li>
- * </ul>
- * This can be visually estimated by the animation in which a player turns horizontal.
- */
-public class EntityToggleGlideEvent extends EntityEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-
-    private boolean cancel = false;
-    private final boolean isGliding;
-
-    public EntityToggleGlideEvent(LivingEntity who, final boolean isGliding) {
-        super(who);
-        this.isGliding = isGliding;
-    }
-
-    @Override
-    public boolean isCancelled() {
-        return cancel;
-    }
-
-    @Override
-    public void setCancelled(boolean cancel) {
-        this.cancel = cancel;
-    }
-
-    public boolean isGliding() {
-        return isGliding;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-
-}
diff --git a/src/main/java/org/bukkit/event/entity/EntityUnleashEvent.java b/src/main/java/org/bukkit/event/entity/EntityUnleashEvent.java
deleted file mode 100644
index da7e46c..0000000
--- a/src/main/java/org/bukkit/event/entity/EntityUnleashEvent.java
+++ /dev/null
@@ -1,52 +0,0 @@
-package org.bukkit.event.entity;
-
-import org.bukkit.entity.Entity;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called immediately prior to an entity being unleashed.
- */
-public class EntityUnleashEvent extends EntityEvent {
-    private static final HandlerList handlers = new HandlerList();
-    private final UnleashReason reason;
-
-    public EntityUnleashEvent(Entity entity, UnleashReason reason) {
-        super(entity);
-        this.reason = reason;
-    }
-
-    /**
-     * Returns the reason for the unleashing.
-     *
-     * @return The reason
-     */
-    public UnleashReason getReason() {
-        return reason;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-
-    public enum UnleashReason {
-        /**
-         * When the entity's leashholder has died or logged out, and so is
-         * unleashed
-         */
-        HOLDER_GONE,
-        /**
-         * When the entity's leashholder attempts to unleash it
-         */
-        PLAYER_UNLEASH,
-        /**
-         * When the entity's leashholder is more than 10 blocks away
-         */
-        DISTANCE,
-        UNKNOWN;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/entity/ExpBottleEvent.java b/src/main/java/org/bukkit/event/entity/ExpBottleEvent.java
deleted file mode 100644
index 4f64424..0000000
--- a/src/main/java/org/bukkit/event/entity/ExpBottleEvent.java
+++ /dev/null
@@ -1,75 +0,0 @@
-package org.bukkit.event.entity;
-
-import org.bukkit.entity.ThrownExpBottle;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a ThrownExpBottle hits and releases experience.
- */
-public class ExpBottleEvent extends ProjectileHitEvent {
-    private static final HandlerList handlers = new HandlerList();
-    private int exp;
-    private boolean showEffect = true;
-
-    public ExpBottleEvent(final ThrownExpBottle bottle, final int exp) {
-        super(bottle);
-        this.exp = exp;
-    }
-
-    @Override
-    public ThrownExpBottle getEntity() {
-        return (ThrownExpBottle) entity;
-    }
-
-    /**
-     * This method indicates if the particle effect should be shown.
-     *
-     * @return true if the effect will be shown, false otherwise
-     */
-    public boolean getShowEffect() {
-        return this.showEffect;
-    }
-
-    /**
-     * This method sets if the particle effect will be shown.
-     * <p>
-     * This does not change the experience created.
-     *
-     * @param showEffect true indicates the effect will be shown, false
-     *     indicates no effect will be shown
-     */
-    public void setShowEffect(final boolean showEffect) {
-        this.showEffect = showEffect;
-    }
-
-    /**
-     * This method retrieves the amount of experience to be created.
-     * <p>
-     * The number indicates a total amount to be divided into orbs.
-     *
-     * @return the total amount of experience to be created
-     */
-    public int getExperience() {
-        return exp;
-    }
-
-    /**
-     * This method sets the amount of experience to be created.
-     * <p>
-     * The number indicates a total amount to be divided into orbs.
-     *
-     * @param exp the total amount of experience to be created
-     */
-    public void setExperience(final int exp) {
-        this.exp = exp;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/entity/ExplosionPrimeEvent.java b/src/main/java/org/bukkit/event/entity/ExplosionPrimeEvent.java
deleted file mode 100644
index 7ca6a55..0000000
--- a/src/main/java/org/bukkit/event/entity/ExplosionPrimeEvent.java
+++ /dev/null
@@ -1,80 +0,0 @@
-package org.bukkit.event.entity;
-
-import org.bukkit.entity.Entity;
-import org.bukkit.entity.Explosive;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when an entity has made a decision to explode.
- */
-public class ExplosionPrimeEvent extends EntityEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private boolean cancel;
-    private float radius;
-    private boolean fire;
-
-    public ExplosionPrimeEvent(final Entity what, final float radius, final boolean fire) {
-        super(what);
-        this.cancel = false;
-        this.radius = radius;
-        this.fire = fire;
-    }
-
-    public ExplosionPrimeEvent(final Explosive explosive) {
-        this(explosive, explosive.getYield(), explosive.isIncendiary());
-    }
-
-    public boolean isCancelled() {
-        return cancel;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancel = cancel;
-    }
-
-    /**
-     * Gets the radius of the explosion
-     *
-     * @return returns the radius of the explosion
-     */
-    public float getRadius() {
-        return radius;
-    }
-
-    /**
-     * Sets the radius of the explosion
-     *
-     * @param radius the radius of the explosion
-     */
-    public void setRadius(float radius) {
-        this.radius = radius;
-    }
-
-    /**
-     * Gets whether this explosion will create fire or not
-     *
-     * @return true if this explosion will create fire
-     */
-    public boolean getFire() {
-        return fire;
-    }
-
-    /**
-     * Sets whether this explosion will create fire or not
-     *
-     * @param fire true if you want this explosion to create fire
-     */
-    public void setFire(boolean fire) {
-        this.fire = fire;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/entity/FireworkExplodeEvent.java b/src/main/java/org/bukkit/event/entity/FireworkExplodeEvent.java
deleted file mode 100644
index 81b1c48..0000000
--- a/src/main/java/org/bukkit/event/entity/FireworkExplodeEvent.java
+++ /dev/null
@@ -1,49 +0,0 @@
-package org.bukkit.event.entity;
-
-import org.bukkit.entity.Firework;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a firework explodes.
- */
-public class FireworkExplodeEvent extends EntityEvent implements Cancellable {
-
-    private static final HandlerList handlers = new HandlerList();
-    private boolean cancel;
-
-    public FireworkExplodeEvent(final Firework what) {
-        super(what);
-    }
-
-    @Override
-    public boolean isCancelled() {
-        return cancel;
-    }
-
-    /**
-     * Set the cancelled state of this event. If the firework explosion is
-     * cancelled, the firework will still be removed, but no particles will be
-     * displayed.
-     *
-     * @param cancel whether to cancel or not.
-     */
-    @Override
-    public void setCancelled(boolean cancel) {
-        this.cancel = cancel;
-    }
-
-    @Override
-    public Firework getEntity() {
-        return (Firework) super.getEntity();
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/entity/FoodLevelChangeEvent.java b/src/main/java/org/bukkit/event/entity/FoodLevelChangeEvent.java
deleted file mode 100644
index f6e2472..0000000
--- a/src/main/java/org/bukkit/event/entity/FoodLevelChangeEvent.java
+++ /dev/null
@@ -1,67 +0,0 @@
-package org.bukkit.event.entity;
-
-import org.bukkit.entity.HumanEntity;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a human entity's food level changes
- */
-public class FoodLevelChangeEvent extends EntityEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private boolean cancel = false;
-    private int level;
-
-    public FoodLevelChangeEvent(final HumanEntity what, final int level) {
-        super(what);
-        this.level = level;
-    }
-
-    @Override
-    public HumanEntity getEntity() {
-        return (HumanEntity) entity;
-    }
-
-    /**
-     * Gets the resultant food level that the entity involved in this event
-     * should be set to.
-     * <p>
-     * Where 20 is a full food bar and 0 is an empty one.
-     *
-     * @return The resultant food level
-     */
-    public int getFoodLevel() {
-        return level;
-    }
-
-    /**
-     * Sets the resultant food level that the entity involved in this event
-     * should be set to
-     *
-     * @param level the resultant food level that the entity involved in this
-     *     event should be set to
-     */
-    public void setFoodLevel(int level) {
-        if (level > 20) level = 20;
-        else if (level < 0) level = 0;
-
-        this.level = level;
-    }
-
-    public boolean isCancelled() {
-        return cancel;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancel = cancel;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/entity/HorseJumpEvent.java b/src/main/java/org/bukkit/event/entity/HorseJumpEvent.java
deleted file mode 100644
index 21ebab6..0000000
--- a/src/main/java/org/bukkit/event/entity/HorseJumpEvent.java
+++ /dev/null
@@ -1,84 +0,0 @@
-package org.bukkit.event.entity;
-
-import org.bukkit.entity.Horse;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a horse jumps.
- */
-public class HorseJumpEvent extends EntityEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private boolean cancelled;
-    private float power;
-
-    public HorseJumpEvent(final Horse horse, final float power) {
-        super(horse);
-        this.power = power;
-    }
-
-    public boolean isCancelled() {
-        return cancelled;
-    }
-
-    /**
-     * @deprecated horse jumping was moved client side.
-     */
-    @Deprecated
-    public void setCancelled(boolean cancel) {
-        cancelled = cancel;
-    }
-
-    @Override
-    public Horse getEntity() {
-        return (Horse) entity;
-    }
-
-    /**
-     * Gets the power of the jump.
-     * <p>
-     * Power is a value that defines how much of the horse's jump strength
-     * should be used for the jump. Power is effectively multiplied times
-     * the horse's jump strength to determine how high the jump is; 0
-     * represents no jump strength while 1 represents full jump strength.
-     * Setting power to a value above 1 will use additional jump strength
-     * that the horse does not usually have.
-     * <p>
-     * Power does not affect how high the horse is capable of jumping, only
-     * how much of its jumping capability will be used in this jump. To set
-     * the horse's overall jump strength, see {@link
-     * Horse#setJumpStrength(double)}.
-     *
-     * @return jump strength
-     */
-    public float getPower() {
-        return power;
-    }
-
-    /**
-     * Sets the power of the jump.
-     * <p>
-     * Jump power can be set to a value above 1.0 which will increase the
-     * strength of this jump above the horse's actual jump strength.
-     * <p>
-     * Setting the jump power to 0 will result in the jump animation still
-     * playing, but the horse not leaving the ground. Only canceling this
-     * event will result in no jump animation at all.
-     *
-     * @param power power of the jump
-     * @deprecated horse jumping was moved client side.
-     */
-    @Deprecated
-    public void setPower(float power) {
-        this.power = power;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/entity/ItemDespawnEvent.java b/src/main/java/org/bukkit/event/entity/ItemDespawnEvent.java
deleted file mode 100644
index 356e4bd..0000000
--- a/src/main/java/org/bukkit/event/entity/ItemDespawnEvent.java
+++ /dev/null
@@ -1,55 +0,0 @@
-package org.bukkit.event.entity;
-
-import org.bukkit.Location;
-import org.bukkit.entity.Item;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * This event is called when a {@link org.bukkit.entity.Item} is removed from
- * the world because it has existed for 5 minutes.
- * <p>
- * Cancelling the event results in the item being allowed to exist for 5 more
- * minutes. This behavior is not guaranteed and may change in future versions.
- */
-public class ItemDespawnEvent extends EntityEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private boolean canceled;
-    private final Location location;
-
-    public ItemDespawnEvent(final Item despawnee, final Location loc) {
-        super(despawnee);
-        location = loc;
-    }
-
-    public boolean isCancelled() {
-        return canceled;
-    }
-
-    public void setCancelled(boolean cancel) {
-        canceled = cancel;
-    }
-
-    @Override
-    public Item getEntity() {
-        return (Item) entity;
-    }
-
-    /**
-     * Gets the location at which the item is despawning.
-     *
-     * @return The location at which the item is despawning
-     */
-    public Location getLocation() {
-        return location;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/entity/ItemMergeEvent.java b/src/main/java/org/bukkit/event/entity/ItemMergeEvent.java
deleted file mode 100644
index dadf221..0000000
--- a/src/main/java/org/bukkit/event/entity/ItemMergeEvent.java
+++ /dev/null
@@ -1,50 +0,0 @@
-package org.bukkit.event.entity;
-
-import org.bukkit.entity.Item;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-public class ItemMergeEvent extends EntityEvent implements Cancellable {
-
-    private static final HandlerList handlers = new HandlerList();
-    private boolean cancelled;
-    private final Item target;
-
-    public ItemMergeEvent(Item item, Item target) {
-        super(item);
-        this.target = target;
-    }
-
-    @Override
-    public boolean isCancelled() {
-        return cancelled;
-    }
-
-    @Override
-    public void setCancelled(boolean cancelled) {
-        this.cancelled = cancelled;
-    }
-
-    @Override
-    public Item getEntity() {
-        return (Item) entity;
-    }
-
-    /**
-     * Gets the Item entity the main Item is being merged into.
-     *
-     * @return The Item being merged with
-     */
-    public Item getTarget() {
-        return target;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/entity/ItemSpawnEvent.java b/src/main/java/org/bukkit/event/entity/ItemSpawnEvent.java
deleted file mode 100644
index bafd934..0000000
--- a/src/main/java/org/bukkit/event/entity/ItemSpawnEvent.java
+++ /dev/null
@@ -1,51 +0,0 @@
-package org.bukkit.event.entity;
-
-import org.bukkit.entity.Item;
-import org.bukkit.Location;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when an item is spawned into a world
- */
-public class ItemSpawnEvent extends EntityEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private final Location location;
-    private boolean canceled;
-
-    public ItemSpawnEvent(final Item spawnee, final Location loc) {
-        super(spawnee);
-        this.location = loc;
-    }
-
-    public boolean isCancelled() {
-        return canceled;
-    }
-
-    public void setCancelled(boolean cancel) {
-        canceled = cancel;
-    }
-
-    @Override
-    public Item getEntity() {
-        return (Item) entity;
-    }
-
-    /**
-     * Gets the location at which the item is spawning.
-     *
-     * @return The location at which the item is spawning
-     */
-    public Location getLocation() {
-        return location;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/entity/LingeringPotionSplashEvent.java b/src/main/java/org/bukkit/event/entity/LingeringPotionSplashEvent.java
deleted file mode 100644
index 09861a5..0000000
--- a/src/main/java/org/bukkit/event/entity/LingeringPotionSplashEvent.java
+++ /dev/null
@@ -1,58 +0,0 @@
-package org.bukkit.event.entity;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Map;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.entity.AreaEffectCloud;
-import org.bukkit.entity.LingeringPotion;
-import org.bukkit.entity.LivingEntity;
-import org.bukkit.entity.ThrownPotion;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a splash potion hits an area
- */
-public class LingeringPotionSplashEvent extends ProjectileHitEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private boolean cancelled;
-    private final AreaEffectCloud entity;
-
-    public LingeringPotionSplashEvent(final ThrownPotion potion, final AreaEffectCloud entity) {
-        super(potion);
-        this.entity = entity;
-    }
-
-    @Override
-    public LingeringPotion getEntity() {
-        return (LingeringPotion) super.getEntity();
-    }
-
-    /**
-     * Gets the AreaEffectCloud spawned
-     *
-     * @return The spawned AreaEffectCloud
-     */
-    public AreaEffectCloud getAreaEffectCloud() {
-        return entity;
-    }
-
-    public boolean isCancelled() {
-        return cancelled;
-    }
-
-    public void setCancelled(boolean cancel) {
-        cancelled = cancel;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/entity/PigZapEvent.java b/src/main/java/org/bukkit/event/entity/PigZapEvent.java
deleted file mode 100644
index aa80ebf..0000000
--- a/src/main/java/org/bukkit/event/entity/PigZapEvent.java
+++ /dev/null
@@ -1,64 +0,0 @@
-package org.bukkit.event.entity;
-
-import org.bukkit.entity.LightningStrike;
-import org.bukkit.entity.Pig;
-import org.bukkit.entity.PigZombie;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Stores data for pigs being zapped
- */
-public class PigZapEvent extends EntityEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private boolean canceled;
-    private final PigZombie pigzombie;
-    private final LightningStrike bolt;
-
-    public PigZapEvent(final Pig pig, final LightningStrike bolt, final PigZombie pigzombie) {
-        super(pig);
-        this.bolt = bolt;
-        this.pigzombie = pigzombie;
-    }
-
-    public boolean isCancelled() {
-        return canceled;
-    }
-
-    public void setCancelled(boolean cancel) {
-        canceled = cancel;
-    }
-
-    @Override
-    public Pig getEntity() {
-        return (Pig) entity;
-    }
-
-    /**
-     * Gets the bolt which is striking the pig.
-     *
-     * @return lightning entity
-     */
-    public LightningStrike getLightning() {
-        return bolt;
-    }
-
-    /**
-     * Gets the zombie pig that will replace the pig, provided the event is
-     * not cancelled first.
-     *
-     * @return resulting entity
-     */
-    public PigZombie getPigZombie() {
-        return pigzombie;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/entity/PlayerDeathEvent.java b/src/main/java/org/bukkit/event/entity/PlayerDeathEvent.java
deleted file mode 100644
index aad0354..0000000
--- a/src/main/java/org/bukkit/event/entity/PlayerDeathEvent.java
+++ /dev/null
@@ -1,161 +0,0 @@
-package org.bukkit.event.entity;
-
-import java.util.List;
-
-import org.bukkit.entity.Player;
-import org.bukkit.inventory.ItemStack;
-
-/**
- * Thrown whenever a {@link Player} dies
- */
-public class PlayerDeathEvent extends EntityDeathEvent {
-    private int newExp = 0;
-    private String deathMessage = "";
-    private int newLevel = 0;
-    private int newTotalExp = 0;
-    private boolean keepLevel = false;
-    private boolean keepInventory = false;
-
-    public PlayerDeathEvent(final Player player, final List<ItemStack> drops, final int droppedExp, final String deathMessage) {
-        this(player, drops, droppedExp, 0, deathMessage);
-    }
-
-    public PlayerDeathEvent(final Player player, final List<ItemStack> drops, final int droppedExp, final int newExp, final String deathMessage) {
-        this(player, drops, droppedExp, newExp, 0, 0, deathMessage);
-    }
-
-    public PlayerDeathEvent(final Player player, final List<ItemStack> drops, final int droppedExp, final int newExp, final int newTotalExp, final int newLevel, final String deathMessage) {
-        super(player, drops, droppedExp);
-        this.newExp = newExp;
-        this.newTotalExp = newTotalExp;
-        this.newLevel = newLevel;
-        this.deathMessage = deathMessage;
-    }
-
-    @Override
-    public Player getEntity() {
-        return (Player) entity;
-    }
-
-    /**
-     * Set the death message that will appear to everyone on the server.
-     *
-     * @param deathMessage Message to appear to other players on the server.
-     */
-    public void setDeathMessage(String deathMessage) {
-        this.deathMessage = deathMessage;
-    }
-
-    /**
-     * Get the death message that will appear to everyone on the server.
-     *
-     * @return Message to appear to other players on the server.
-     */
-    public String getDeathMessage() {
-        return deathMessage;
-    }
-
-    /**
-     * Gets how much EXP the Player should have at respawn.
-     * <p>
-     * This does not indicate how much EXP should be dropped, please see
-     * {@link #getDroppedExp()} for that.
-     *
-     * @return New EXP of the respawned player
-     */
-    public int getNewExp() {
-        return newExp;
-    }
-
-    /**
-     * Sets how much EXP the Player should have at respawn.
-     * <p>
-     * This does not indicate how much EXP should be dropped, please see
-     * {@link #setDroppedExp(int)} for that.
-     *
-     * @param exp New EXP of the respawned player
-     */
-    public void setNewExp(int exp) {
-        newExp = exp;
-    }
-
-    /**
-     * Gets the Level the Player should have at respawn.
-     *
-     * @return New Level of the respawned player
-     */
-    public int getNewLevel() {
-        return newLevel;
-    }
-
-    /**
-     * Sets the Level the Player should have at respawn.
-     *
-     * @param level New Level of the respawned player
-     */
-    public void setNewLevel(int level) {
-        newLevel = level;
-    }
-
-    /**
-     * Gets the Total EXP the Player should have at respawn.
-     *
-     * @return New Total EXP of the respawned player
-     */
-    public int getNewTotalExp() {
-        return newTotalExp;
-    }
-
-    /**
-     * Sets the Total EXP the Player should have at respawn.
-     *
-     * @param totalExp New Total EXP of the respawned player
-     */
-    public void setNewTotalExp(int totalExp) {
-        newTotalExp = totalExp;
-    }
-
-    /**
-     * Gets if the Player should keep all EXP at respawn.
-     * <p>
-     * This flag overrides other EXP settings
-     *
-     * @return True if Player should keep all pre-death exp
-     */
-    public boolean getKeepLevel() {
-        return keepLevel;
-    }
-
-    /**
-     * Sets if the Player should keep all EXP at respawn.
-     * <p>
-     * This overrides all other EXP settings
-     * <p>
-     * This doesn't prevent prevent the EXP from dropping.
-     * {@link #setDroppedExp(int)} should be used stop the
-     * EXP from dropping.
-     *
-     * @param keepLevel True to keep all current value levels
-     */
-    public void setKeepLevel(boolean keepLevel) {
-        this.keepLevel = keepLevel;
-    }
-
-    /**
-     * Sets if the Player keeps inventory on death.
-     *
-     * @param keepInventory True to keep the inventory
-     */
-    public void setKeepInventory(boolean keepInventory) {
-        this.keepInventory = keepInventory;
-    }
-
-    /**
-     * Gets if the Player keeps inventory on death.
-     *
-     * @return True if the player keeps inventory on death
-     */
-    public boolean getKeepInventory() {
-        return keepInventory;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/entity/PlayerLeashEntityEvent.java b/src/main/java/org/bukkit/event/entity/PlayerLeashEntityEvent.java
deleted file mode 100644
index 74d458a..0000000
--- a/src/main/java/org/bukkit/event/entity/PlayerLeashEntityEvent.java
+++ /dev/null
@@ -1,68 +0,0 @@
-package org.bukkit.event.entity;
-
-import org.bukkit.entity.Entity;
-import org.bukkit.entity.Player;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.Event;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called immediately prior to a creature being leashed by a player.
- */
-public class PlayerLeashEntityEvent extends Event implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private final Entity leashHolder;
-    private final Entity entity;
-    private boolean cancelled = false;
-    private final Player player;
-
-    public PlayerLeashEntityEvent(Entity what, Entity leashHolder, Player leasher) {
-        this.leashHolder = leashHolder;
-        this.entity = what;
-        this.player = leasher;
-    }
-
-    /**
-     * Returns the entity that is holding the leash.
-     *
-     * @return The leash holder
-     */
-    public Entity getLeashHolder() {
-        return leashHolder;
-    }
-
-    /**
-     * Returns the entity being leashed.
-     *
-     * @return The entity
-     */
-    public Entity getEntity() {
-        return entity;
-    }
-
-    /**
-     * Returns the player involved in this event
-     *
-     * @return Player who is involved in this event
-     */
-    public final Player getPlayer() {
-        return player;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-
-    public boolean isCancelled() {
-        return this.cancelled;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancelled  = cancel;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/entity/PotionSplashEvent.java b/src/main/java/org/bukkit/event/entity/PotionSplashEvent.java
deleted file mode 100644
index b9840de..0000000
--- a/src/main/java/org/bukkit/event/entity/PotionSplashEvent.java
+++ /dev/null
@@ -1,94 +0,0 @@
-package org.bukkit.event.entity;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Map;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.entity.LivingEntity;
-import org.bukkit.entity.ThrownPotion;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a splash potion hits an area
- */
-public class PotionSplashEvent extends ProjectileHitEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private boolean cancelled;
-    private final Map<LivingEntity, Double> affectedEntities;
-
-    public PotionSplashEvent(final ThrownPotion potion, final Map<LivingEntity, Double> affectedEntities) {
-        super(potion);
-
-        this.affectedEntities = affectedEntities;
-    }
-
-    @Override
-    public ThrownPotion getEntity() {
-        return (ThrownPotion) entity;
-    }
-
-    /**
-     * Gets the potion which caused this event
-     *
-     * @return The thrown potion entity
-     */
-    public ThrownPotion getPotion() {
-        return (ThrownPotion) getEntity();
-    }
-
-    /**
-     * Retrieves a list of all effected entities
-     *
-     * @return A fresh copy of the affected entity list
-     */
-    public Collection<LivingEntity> getAffectedEntities() {
-        return new ArrayList<LivingEntity>(affectedEntities.keySet());
-    }
-
-    /**
-     * Gets the intensity of the potion's effects for given entity; This
-     * depends on the distance to the impact center
-     *
-     * @param entity Which entity to get intensity for
-     * @return intensity relative to maximum effect; 0.0: not affected; 1.0:
-     *     fully hit by potion effects
-     */
-    public double getIntensity(LivingEntity entity) {
-        Double intensity = affectedEntities.get(entity);
-        return intensity != null ? intensity : 0.0;
-    }
-
-    /**
-     * Overwrites the intensity for a given entity
-     *
-     * @param entity For which entity to define a new intensity
-     * @param intensity relative to maximum effect
-     */
-    public void setIntensity(LivingEntity entity, double intensity) {
-        Validate.notNull(entity, "You must specify a valid entity.");
-        if (intensity <= 0.0) {
-            affectedEntities.remove(entity);
-        } else {
-            affectedEntities.put(entity, Math.min(intensity, 1.0));
-        }
-    }
-
-    public boolean isCancelled() {
-        return cancelled;
-    }
-
-    public void setCancelled(boolean cancel) {
-        cancelled = cancel;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/entity/ProjectileHitEvent.java b/src/main/java/org/bukkit/event/entity/ProjectileHitEvent.java
deleted file mode 100644
index 25ae832..0000000
--- a/src/main/java/org/bukkit/event/entity/ProjectileHitEvent.java
+++ /dev/null
@@ -1,30 +0,0 @@
-package org.bukkit.event.entity;
-
-import org.bukkit.entity.Projectile;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a projectile hits an object
- */
-public class ProjectileHitEvent extends EntityEvent {
-    private static final HandlerList handlers = new HandlerList();
-
-    public ProjectileHitEvent(final Projectile projectile) {
-        super(projectile);
-    }
-
-    @Override
-    public Projectile getEntity() {
-        return (Projectile) entity;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-
-}
diff --git a/src/main/java/org/bukkit/event/entity/ProjectileLaunchEvent.java b/src/main/java/org/bukkit/event/entity/ProjectileLaunchEvent.java
deleted file mode 100644
index 0c9190c..0000000
--- a/src/main/java/org/bukkit/event/entity/ProjectileLaunchEvent.java
+++ /dev/null
@@ -1,40 +0,0 @@
-package org.bukkit.event.entity;
-
-import org.bukkit.entity.Entity;
-import org.bukkit.entity.Projectile;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a projectile is launched.
- */
-public class ProjectileLaunchEvent extends EntityEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private boolean cancelled;
-
-    public ProjectileLaunchEvent(Entity what) {
-        super(what);
-    }
-
-    public boolean isCancelled() {
-        return cancelled;
-    }
-
-    public void setCancelled(boolean cancel) {
-        cancelled = cancel;
-    }
-
-    @Override
-    public Projectile getEntity() {
-        return (Projectile) entity;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/entity/SheepDyeWoolEvent.java b/src/main/java/org/bukkit/event/entity/SheepDyeWoolEvent.java
deleted file mode 100644
index 4c17fea..0000000
--- a/src/main/java/org/bukkit/event/entity/SheepDyeWoolEvent.java
+++ /dev/null
@@ -1,62 +0,0 @@
-package org.bukkit.event.entity;
-
-import org.bukkit.DyeColor;
-import org.bukkit.entity.Sheep;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a sheep's wool is dyed
- */
-public class SheepDyeWoolEvent extends EntityEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private boolean cancel;
-    private DyeColor color;
-
-    public SheepDyeWoolEvent(final Sheep sheep, final DyeColor color) {
-        super(sheep);
-        this.cancel = false;
-        this.color = color;
-    }
-
-    public boolean isCancelled() {
-        return cancel;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancel = cancel;
-    }
-
-    @Override
-    public Sheep getEntity() {
-        return (Sheep) entity;
-    }
-
-    /**
-     * Gets the DyeColor the sheep is being dyed
-     *
-     * @return the DyeColor the sheep is being dyed
-     */
-    public DyeColor getColor() {
-        return color;
-    }
-
-    /**
-     * Sets the DyeColor the sheep is being dyed
-     *
-     * @param color the DyeColor the sheep will be dyed
-     */
-    public void setColor(DyeColor color) {
-        this.color = color;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-
-}
diff --git a/src/main/java/org/bukkit/event/entity/SheepRegrowWoolEvent.java b/src/main/java/org/bukkit/event/entity/SheepRegrowWoolEvent.java
deleted file mode 100644
index e836f7b..0000000
--- a/src/main/java/org/bukkit/event/entity/SheepRegrowWoolEvent.java
+++ /dev/null
@@ -1,41 +0,0 @@
-package org.bukkit.event.entity;
-
-import org.bukkit.entity.Sheep;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a sheep regrows its wool
- */
-public class SheepRegrowWoolEvent extends EntityEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private boolean cancel;
-
-    public SheepRegrowWoolEvent(final Sheep sheep) {
-        super(sheep);
-        this.cancel = false;
-    }
-
-    public boolean isCancelled() {
-        return cancel;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancel = cancel;
-    }
-
-    @Override
-    public Sheep getEntity() {
-        return (Sheep) entity;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-
-}
diff --git a/src/main/java/org/bukkit/event/entity/SlimeSplitEvent.java b/src/main/java/org/bukkit/event/entity/SlimeSplitEvent.java
deleted file mode 100644
index 4b99587..0000000
--- a/src/main/java/org/bukkit/event/entity/SlimeSplitEvent.java
+++ /dev/null
@@ -1,59 +0,0 @@
-package org.bukkit.event.entity;
-
-import org.bukkit.entity.Slime;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a Slime splits into smaller Slimes upon death
- */
-public class SlimeSplitEvent extends EntityEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private boolean cancel = false;
-    private int count;
-
-    public SlimeSplitEvent(final Slime slime, final int count) {
-        super(slime);
-        this.count = count;
-    }
-
-    public boolean isCancelled() {
-        return cancel;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancel = cancel;
-    }
-
-    @Override
-    public Slime getEntity() {
-        return (Slime) entity;
-    }
-
-    /**
-     * Gets the amount of smaller slimes to spawn
-     *
-     * @return the amount of slimes to spawn
-     */
-    public int getCount() {
-        return count;
-    }
-
-    /**
-     * Sets how many smaller slimes will spawn on the split
-     *
-     * @param count the amount of slimes to spawn
-     */
-    public void setCount(int count) {
-        this.count = count;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
\ No newline at end of file
diff --git a/src/main/java/org/bukkit/event/entity/VillagerAcquireTradeEvent.java b/src/main/java/org/bukkit/event/entity/VillagerAcquireTradeEvent.java
deleted file mode 100644
index a63271e..0000000
--- a/src/main/java/org/bukkit/event/entity/VillagerAcquireTradeEvent.java
+++ /dev/null
@@ -1,64 +0,0 @@
-package org.bukkit.event.entity;
-
-import org.bukkit.entity.Villager;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-import org.bukkit.inventory.MerchantRecipe;
-
-/**
- * Called whenever a villager acquires a new trade.
- */
-public class VillagerAcquireTradeEvent extends EntityEvent implements Cancellable {
-
-    private static final HandlerList handlers = new HandlerList();
-    private boolean cancelled;
-    //
-    private MerchantRecipe recipe;
-
-    public VillagerAcquireTradeEvent(Villager what, MerchantRecipe recipe) {
-        super(what);
-        this.recipe = recipe;
-    }
-
-    /**
-     * Get the recipe to be acquired.
-     *
-     * @return the new recipe
-     */
-    public MerchantRecipe getRecipe() {
-        return recipe;
-    }
-
-    /**
-     * Set the recipe to be acquired.
-     *
-     * @param recipe the new recipe
-     */
-    public void setRecipe(MerchantRecipe recipe) {
-        this.recipe = recipe;
-    }
-
-    @Override
-    public boolean isCancelled() {
-        return cancelled;
-    }
-
-    @Override
-    public void setCancelled(boolean cancel) {
-        this.cancelled = cancel;
-    }
-
-    @Override
-    public Villager getEntity() {
-        return (Villager) super.getEntity();
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/entity/VillagerReplenishTradeEvent.java b/src/main/java/org/bukkit/event/entity/VillagerReplenishTradeEvent.java
deleted file mode 100644
index 1bb39ca..0000000
--- a/src/main/java/org/bukkit/event/entity/VillagerReplenishTradeEvent.java
+++ /dev/null
@@ -1,89 +0,0 @@
-package org.bukkit.event.entity;
-
-import org.bukkit.entity.Villager;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-import org.bukkit.inventory.MerchantRecipe;
-
-/**
- * Called when a villager's trade's maximum uses is increased, due to a player's
- * trade.
- *
- * @see MerchantRecipe#getMaxUses()
- */
-public class VillagerReplenishTradeEvent extends EntityEvent implements Cancellable {
-
-    private static final HandlerList handlers = new HandlerList();
-    private boolean cancelled;
-    //
-    private MerchantRecipe recipe;
-    private int bonus;
-
-    public VillagerReplenishTradeEvent(Villager what, MerchantRecipe recipe, int bonus) {
-        super(what);
-        this.recipe = recipe;
-        this.bonus = bonus;
-    }
-
-    /**
-     * Get the recipe to replenish.
-     *
-     * @return the replenished recipe
-     */
-    public MerchantRecipe getRecipe() {
-        return recipe;
-    }
-
-    /**
-     * Set the recipe to replenish.
-     *
-     * @param recipe the replenished recipe
-     */
-    public void setRecipe(MerchantRecipe recipe) {
-        this.recipe = recipe;
-    }
-
-    /**
-     * Get the bonus uses added. The maximum uses of the recipe will be
-     * increased by this number.
-     *
-     * @return the extra uses added
-     */
-    public int getBonus() {
-        return bonus;
-    }
-
-    /**
-     * Set the bonus uses added.
-     *
-     * @see VillagerReplenishTradeEvent#getBonus()
-     * @param bonus the extra uses added
-     */
-    public void setBonus(int bonus) {
-        this.bonus = bonus;
-    }
-
-    @Override
-    public boolean isCancelled() {
-        return cancelled;
-    }
-
-    @Override
-    public void setCancelled(boolean cancel) {
-        this.cancelled = cancel;
-    }
-
-    @Override
-    public Villager getEntity() {
-        return (Villager) super.getEntity();
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/hanging/HangingBreakByEntityEvent.java b/src/main/java/org/bukkit/event/hanging/HangingBreakByEntityEvent.java
deleted file mode 100644
index 80851ed..0000000
--- a/src/main/java/org/bukkit/event/hanging/HangingBreakByEntityEvent.java
+++ /dev/null
@@ -1,25 +0,0 @@
-package org.bukkit.event.hanging;
-
-import org.bukkit.entity.Entity;
-import org.bukkit.entity.Hanging;
-
-/**
- * Triggered when a hanging entity is removed by an entity
- */
-public class HangingBreakByEntityEvent extends HangingBreakEvent {
-    private final Entity remover;
-
-    public HangingBreakByEntityEvent(final Hanging hanging, final Entity remover) {
-        super(hanging, HangingBreakEvent.RemoveCause.ENTITY);
-        this.remover = remover;
-    }
-
-    /**
-     * Gets the entity that removed the hanging entity
-     *
-     * @return the entity that removed the hanging entity
-     */
-    public Entity getRemover() {
-        return remover;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/hanging/HangingBreakEvent.java b/src/main/java/org/bukkit/event/hanging/HangingBreakEvent.java
deleted file mode 100644
index 87bbdcb..0000000
--- a/src/main/java/org/bukkit/event/hanging/HangingBreakEvent.java
+++ /dev/null
@@ -1,71 +0,0 @@
-package org.bukkit.event.hanging;
-
-import org.bukkit.entity.Hanging;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Triggered when a hanging entity is removed
- */
-public class HangingBreakEvent extends HangingEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private boolean cancelled;
-    private final HangingBreakEvent.RemoveCause cause;
-
-    public HangingBreakEvent(final Hanging hanging, final HangingBreakEvent.RemoveCause cause) {
-        super(hanging);
-        this.cause = cause;
-    }
-
-    /**
-     * Gets the cause for the hanging entity's removal
-     *
-     * @return the RemoveCause for the hanging entity's removal
-     */
-    public HangingBreakEvent.RemoveCause getCause() {
-        return cause;
-    }
-
-    public boolean isCancelled() {
-        return cancelled;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancelled = cancel;
-    }
-
-    /**
-     * An enum to specify the cause of the removal
-     */
-    public enum RemoveCause {
-        /**
-         * Removed by an entity
-         */
-        ENTITY,
-        /**
-         * Removed by an explosion
-         */
-        EXPLOSION,
-        /**
-         * Removed by placing a block on it
-         */
-        OBSTRUCTION,
-        /**
-         * Removed by destroying the block behind it, etc
-         */
-        PHYSICS,
-        /**
-         * Removed by an uncategorised cause
-         */
-        DEFAULT,
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/hanging/HangingEvent.java b/src/main/java/org/bukkit/event/hanging/HangingEvent.java
deleted file mode 100644
index b370afe..0000000
--- a/src/main/java/org/bukkit/event/hanging/HangingEvent.java
+++ /dev/null
@@ -1,24 +0,0 @@
-package org.bukkit.event.hanging;
-
-import org.bukkit.entity.Hanging;
-import org.bukkit.event.Event;
-
-/**
- * Represents a hanging entity-related event.
- */
-public abstract class HangingEvent extends Event {
-    protected Hanging hanging;
-
-    protected HangingEvent(final Hanging painting) {
-        this.hanging = painting;
-    }
-
-    /**
-     * Gets the hanging entity involved in this event.
-     *
-     * @return the hanging entity
-     */
-    public Hanging getEntity() {
-        return hanging;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/hanging/HangingPlaceEvent.java b/src/main/java/org/bukkit/event/hanging/HangingPlaceEvent.java
deleted file mode 100644
index b511c55..0000000
--- a/src/main/java/org/bukkit/event/hanging/HangingPlaceEvent.java
+++ /dev/null
@@ -1,70 +0,0 @@
-package org.bukkit.event.hanging;
-
-import org.bukkit.block.Block;
-import org.bukkit.block.BlockFace;
-import org.bukkit.entity.Hanging;
-import org.bukkit.entity.Player;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Triggered when a hanging entity is created in the world
- */
-public class HangingPlaceEvent extends HangingEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private boolean cancelled;
-    private final Player player;
-    private final Block block;
-    private final BlockFace blockFace;
-
-    public HangingPlaceEvent(final Hanging hanging, final Player player, final Block block, final BlockFace blockFace) {
-        super(hanging);
-        this.player = player;
-        this.block = block;
-        this.blockFace = blockFace;
-    }
-
-    /**
-     * Returns the player placing the hanging entity
-     *
-     * @return the player placing the hanging entity
-     */
-    public Player getPlayer() {
-        return player;
-    }
-
-    /**
-     * Returns the block that the hanging entity was placed on
-     *
-     * @return the block that the hanging entity was placed on
-     */
-    public Block getBlock() {
-        return block;
-    }
-
-    /**
-     * Returns the face of the block that the hanging entity was placed on
-     *
-     * @return the face of the block that the hanging entity was placed on
-     */
-    public BlockFace getBlockFace() {
-        return blockFace;
-    }
-
-    public boolean isCancelled() {
-        return cancelled;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancelled = cancel;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/inventory/BrewEvent.java b/src/main/java/org/bukkit/event/inventory/BrewEvent.java
deleted file mode 100644
index 2295c2d..0000000
--- a/src/main/java/org/bukkit/event/inventory/BrewEvent.java
+++ /dev/null
@@ -1,48 +0,0 @@
-package org.bukkit.event.inventory;
-
-import org.bukkit.block.Block;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-import org.bukkit.event.block.BlockEvent;
-import org.bukkit.inventory.BrewerInventory;
-
-/**
- * Called when the brewing of the contents inside the Brewing Stand is
- * complete.
- */
-public class BrewEvent extends BlockEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private BrewerInventory contents;
-    private boolean cancelled;
-
-    public BrewEvent(Block brewer, BrewerInventory contents) {
-        super(brewer);
-        this.contents = contents;
-    }
-
-    /**
-     * Gets the contents of the Brewing Stand.
-     *
-     * @return the contents
-     */
-    public BrewerInventory getContents() {
-        return contents;
-    }
-
-    public boolean isCancelled() {
-        return cancelled;
-    }
-
-    public void setCancelled(boolean cancel) {
-        cancelled = cancel;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/inventory/ClickType.java b/src/main/java/org/bukkit/event/inventory/ClickType.java
deleted file mode 100644
index a7440aa..0000000
--- a/src/main/java/org/bukkit/event/inventory/ClickType.java
+++ /dev/null
@@ -1,115 +0,0 @@
-package org.bukkit.event.inventory;
-
-/**
- * What the client did to trigger this action (not the result).
- */
-public enum ClickType {
-
-    /**
-     * The left (or primary) mouse button.
-     */
-    LEFT,
-    /**
-     * Holding shift while pressing the left mouse button.
-     */
-    SHIFT_LEFT,
-    /**
-     * The right mouse button.
-     */
-    RIGHT,
-    /**
-     * Holding shift while pressing the right mouse button.
-     */
-    SHIFT_RIGHT,
-    /**
-     * Clicking the left mouse button on the grey area around the inventory.
-     */
-    WINDOW_BORDER_LEFT,
-    /**
-     * Clicking the right mouse button on the grey area around the inventory.
-     */
-    WINDOW_BORDER_RIGHT,
-    /**
-     * The middle mouse button, or a "scrollwheel click".
-     */
-    MIDDLE,
-    /**
-     * One of the number keys 1-9, correspond to slots on the hotbar.
-     */
-    NUMBER_KEY,
-    /**
-     * Pressing the left mouse button twice in quick succession.
-     */
-    DOUBLE_CLICK,
-    /**
-     * The "Drop" key (defaults to Q).
-     */
-    DROP,
-    /**
-     * Holding Ctrl while pressing the "Drop" key (defaults to Q).
-     */
-    CONTROL_DROP,
-    /**
-     * Any action done with the Creative inventory open.
-     */
-    CREATIVE,
-    /**
-     * A type of inventory manipulation not yet recognized by Bukkit.
-     * <p>
-     * This is only for transitional purposes on a new Minecraft update, and
-     * should never be relied upon.
-     * <p>
-     * Any ClickType.UNKNOWN is called on a best-effort basis.
-     */
-    UNKNOWN,
-    ;
-
-    /**
-     * Gets whether this ClickType represents the pressing of a key on a
-     * keyboard.
-     *
-     * @return true if this ClickType represents the pressing of a key
-     */
-    public boolean isKeyboardClick() {
-        return (this == ClickType.NUMBER_KEY) || (this == ClickType.DROP) || (this == ClickType.CONTROL_DROP);
-    }
-
-    /**
-     * Gets whether this ClickType represents an action that can only be
-     * performed by a Player in creative mode.
-     *
-     * @return true if this action requires Creative mode
-     */
-    public boolean isCreativeAction() {
-        // Why use middle click?
-        return (this == ClickType.MIDDLE) || (this == ClickType.CREATIVE);
-    }
-
-    /**
-     * Gets whether this ClickType represents a right click.
-     *
-     * @return true if this ClickType represents a right click
-     */
-    public boolean isRightClick() {
-        return (this == ClickType.RIGHT) || (this == ClickType.SHIFT_RIGHT);
-    }
-
-    /**
-     * Gets whether this ClickType represents a left click.
-     *
-     * @return true if this ClickType represents a left click
-     */
-    public boolean isLeftClick() {
-        return (this == ClickType.LEFT) || (this == ClickType.SHIFT_LEFT) || (this == ClickType.DOUBLE_CLICK) || (this == ClickType.CREATIVE);
-    }
-
-    /**
-     * Gets whether this ClickType indicates that the shift key was pressed
-     * down when the click was made.
-     *
-     * @return true if the action uses Shift.
-     */
-    public boolean isShiftClick() {
-        return (this == ClickType.SHIFT_LEFT) || (this == ClickType.SHIFT_RIGHT) || (this == ClickType.CONTROL_DROP);
-    }
-}
diff --git a/src/main/java/org/bukkit/event/inventory/CraftItemEvent.java b/src/main/java/org/bukkit/event/inventory/CraftItemEvent.java
deleted file mode 100644
index ba3f5e5..0000000
--- a/src/main/java/org/bukkit/event/inventory/CraftItemEvent.java
+++ /dev/null
@@ -1,40 +0,0 @@
-package org.bukkit.event.inventory;
-
-import org.bukkit.event.inventory.InventoryType.SlotType;
-import org.bukkit.inventory.CraftingInventory;
-import org.bukkit.inventory.InventoryView;
-import org.bukkit.inventory.Recipe;
-
-/**
- * Called when the recipe of an Item is completed inside a crafting matrix.
- */
-public class CraftItemEvent extends InventoryClickEvent {
-    private Recipe recipe;
-
-    @Deprecated
-    public CraftItemEvent(Recipe recipe, InventoryView what, SlotType type, int slot, boolean right, boolean shift) {
-        this(recipe, what, type, slot, right ? (shift ? ClickType.SHIFT_RIGHT : ClickType.RIGHT) : (shift ? ClickType.SHIFT_LEFT : ClickType.LEFT), InventoryAction.PICKUP_ALL);
-    }
-
-    public CraftItemEvent(Recipe recipe, InventoryView what, SlotType type, int slot, ClickType click, InventoryAction action) {
-        super(what, type, slot, click, action);
-        this.recipe = recipe;
-    }
-
-    public CraftItemEvent(Recipe recipe, InventoryView what, SlotType type, int slot, ClickType click, InventoryAction action, int key) {
-        super(what, type, slot, click, action, key);
-        this.recipe = recipe;
-    }
-
-    /**
-     * @return A copy of the current recipe on the crafting matrix.
-     */
-    public Recipe getRecipe() {
-        return recipe;
-    }
-
-    @Override
-    public CraftingInventory getInventory() {
-        return (CraftingInventory) super.getInventory();
-    }
-}
diff --git a/src/main/java/org/bukkit/event/inventory/DragType.java b/src/main/java/org/bukkit/event/inventory/DragType.java
deleted file mode 100644
index 72c2bed..0000000
--- a/src/main/java/org/bukkit/event/inventory/DragType.java
+++ /dev/null
@@ -1,17 +0,0 @@
-package org.bukkit.event.inventory;
-
-/**
- * Represents the effect of a drag that will be applied to an Inventory in an
- * InventoryDragEvent.
- */
-public enum DragType {
-    /**
-     * One item from the cursor is placed in each selected slot.
-     */
-    SINGLE,
-    /**
-     * The cursor is split evenly across all selected slots, not to exceed the
-     * Material's max stack size, with the remainder going to the cursor.
-     */
-    EVEN,
-}
diff --git a/src/main/java/org/bukkit/event/inventory/FurnaceBurnEvent.java b/src/main/java/org/bukkit/event/inventory/FurnaceBurnEvent.java
deleted file mode 100644
index 7cc7739..0000000
--- a/src/main/java/org/bukkit/event/inventory/FurnaceBurnEvent.java
+++ /dev/null
@@ -1,88 +0,0 @@
-package org.bukkit.event.inventory;
-
-import org.bukkit.block.Block;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-import org.bukkit.event.block.BlockEvent;
-import org.bukkit.inventory.ItemStack;
-
-/**
- * Called when an ItemStack is successfully burned as fuel in a furnace.
- */
-public class FurnaceBurnEvent extends BlockEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private final ItemStack fuel;
-    private int burnTime;
-    private boolean cancelled;
-    private boolean burning;
-
-    public FurnaceBurnEvent(final Block furnace, final ItemStack fuel, final int burnTime) {
-        super(furnace);
-        this.fuel = fuel;
-        this.burnTime = burnTime;
-        this.cancelled = false;
-        this.burning = true;
-    }
-
-    /**
-     * Gets the fuel ItemStack for this event
-     *
-     * @return the fuel ItemStack
-     */
-    public ItemStack getFuel() {
-        return fuel;
-    }
-
-    /**
-     * Gets the burn time for this fuel
-     *
-     * @return the burn time for this fuel
-     */
-    public int getBurnTime() {
-        return burnTime;
-    }
-
-    /**
-     * Sets the burn time for this fuel
-     *
-     * @param burnTime the burn time for this fuel
-     */
-    public void setBurnTime(int burnTime) {
-        this.burnTime = burnTime;
-    }
-
-    /**
-     * Gets whether the furnace's fuel is burning or not.
-     *
-     * @return whether the furnace's fuel is burning or not.
-     */
-    public boolean isBurning() {
-        return this.burning;
-    }
-
-    /**
-     * Sets whether the furnace's fuel is burning or not.
-     *
-     * @param burning true if the furnace's fuel is burning
-     */
-    public void setBurning(boolean burning) {
-        this.burning = burning;
-    }
-
-    public boolean isCancelled() {
-        return cancelled;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancelled = cancel;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/inventory/FurnaceExtractEvent.java b/src/main/java/org/bukkit/event/inventory/FurnaceExtractEvent.java
deleted file mode 100644
index b7381fa..0000000
--- a/src/main/java/org/bukkit/event/inventory/FurnaceExtractEvent.java
+++ /dev/null
@@ -1,49 +0,0 @@
-package org.bukkit.event.inventory;
-
-import org.bukkit.Material;
-import org.bukkit.block.Block;
-import org.bukkit.entity.Player;
-import org.bukkit.event.block.BlockExpEvent;
-
-/**
- * This event is called when a player takes items out of the furnace
- */
-public class FurnaceExtractEvent extends BlockExpEvent {
-    private final Player player;
-    private final Material itemType;
-    private final int itemAmount;
-
-    public FurnaceExtractEvent(Player player, Block block, Material itemType, int itemAmount, int exp) {
-        super(block, exp);
-        this.player = player;
-        this.itemType = itemType;
-        this.itemAmount = itemAmount;
-    }
-
-    /**
-     * Get the player that triggered the event
-     *
-     * @return the relevant player
-     */
-    public Player getPlayer() {
-        return player;
-    }
-
-    /**
-     * Get the Material of the item being retrieved
-     *
-     * @return the material of the item
-     */
-    public Material getItemType() {
-        return itemType;
-    }
-
-    /**
-     * Get the item count being retrieved
-     *
-     * @return the amount of the item
-     */
-    public int getItemAmount() {
-        return itemAmount;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/inventory/FurnaceSmeltEvent.java b/src/main/java/org/bukkit/event/inventory/FurnaceSmeltEvent.java
deleted file mode 100644
index 5ad3179..0000000
--- a/src/main/java/org/bukkit/event/inventory/FurnaceSmeltEvent.java
+++ /dev/null
@@ -1,68 +0,0 @@
-package org.bukkit.event.inventory;
-
-import org.bukkit.block.Block;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-import org.bukkit.event.block.BlockEvent;
-import org.bukkit.inventory.ItemStack;
-
-/**
- * Called when an ItemStack is successfully smelted in a furnace.
- */
-public class FurnaceSmeltEvent extends BlockEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private final ItemStack source;
-    private ItemStack result;
-    private boolean cancelled;
-
-    public FurnaceSmeltEvent(final Block furnace, final ItemStack source, final ItemStack result) {
-        super(furnace);
-        this.source = source;
-        this.result = result;
-        this.cancelled = false;
-    }
-
-    /**
-     * Gets the smelted ItemStack for this event
-     *
-     * @return smelting source ItemStack
-     */
-    public ItemStack getSource() {
-        return source;
-    }
-
-    /**
-     * Gets the resultant ItemStack for this event
-     *
-     * @return smelting result ItemStack
-     */
-    public ItemStack getResult() {
-        return result;
-    }
-
-    /**
-     * Sets the resultant ItemStack for this event
-     *
-     * @param result new result ItemStack
-     */
-    public void setResult(ItemStack result) {
-        this.result = result;
-    }
-
-    public boolean isCancelled() {
-        return cancelled;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancelled = cancel;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/inventory/InventoryAction.java b/src/main/java/org/bukkit/event/inventory/InventoryAction.java
deleted file mode 100644
index a7bc694..0000000
--- a/src/main/java/org/bukkit/event/inventory/InventoryAction.java
+++ /dev/null
@@ -1,91 +0,0 @@
-package org.bukkit.event.inventory;
-
-/**
- * An estimation of what the result will be.
- */
-public enum InventoryAction {
-
-    /**
-     * Nothing will happen from the click.
-     * <p>
-     * There may be cases where nothing will happen and this is value is not
-     * provided, but it is guaranteed that this value is accurate when given.
-     */
-    NOTHING,
-    /**
-     * All of the items on the clicked slot are moved to the cursor.
-     */
-    PICKUP_ALL,
-    /**
-     * Some of the items on the clicked slot are moved to the cursor.
-     */
-    PICKUP_SOME,
-    /**
-     * Half of the items on the clicked slot are moved to the cursor.
-     */
-    PICKUP_HALF,
-    /**
-     * One of the items on the clicked slot are moved to the cursor.
-     */
-    PICKUP_ONE,
-    /**
-     * All of the items on the cursor are moved to the clicked slot.
-     */
-    PLACE_ALL,
-    /**
-     * Some of the items from the cursor are moved to the clicked slot
-     * (usually up to the max stack size).
-     */
-    PLACE_SOME,
-    /**
-     * A single item from the cursor is moved to the clicked slot.
-     */
-    PLACE_ONE,
-    /**
-     * The clicked item and the cursor are exchanged.
-     */
-    SWAP_WITH_CURSOR,
-    /**
-     * The entire cursor item is dropped.
-     */
-    DROP_ALL_CURSOR,
-    /**
-     * One item is dropped from the cursor.
-     */
-    DROP_ONE_CURSOR,
-    /**
-     * The entire clicked slot is dropped.
-     */
-    DROP_ALL_SLOT,
-    /**
-     * One item is dropped from the clicked slot.
-     */
-    DROP_ONE_SLOT,
-    /**
-     * The item is moved to the opposite inventory if a space is found.
-     */
-    MOVE_TO_OTHER_INVENTORY,
-    /**
-     * The clicked item is moved to the hotbar, and the item currently there
-     * is re-added to the player's inventory.
-     */
-    HOTBAR_MOVE_AND_READD,
-    /**
-     * The clicked slot and the picked hotbar slot are swapped.
-     */
-    HOTBAR_SWAP,
-    /**
-     * A max-size stack of the clicked item is put on the cursor.
-     */
-    CLONE_STACK,
-    /**
-     * The inventory is searched for the same material, and they are put on
-     * the cursor up to {@link org.bukkit.Material#getMaxStackSize()}.
-     */
-    COLLECT_TO_CURSOR,
-    /**
-     * An unrecognized ClickType.
-     */
-    UNKNOWN,
-    ;
-}
diff --git a/src/main/java/org/bukkit/event/inventory/InventoryClickEvent.java b/src/main/java/org/bukkit/event/inventory/InventoryClickEvent.java
deleted file mode 100644
index 28198b8..0000000
--- a/src/main/java/org/bukkit/event/inventory/InventoryClickEvent.java
+++ /dev/null
@@ -1,229 +0,0 @@
-package org.bukkit.event.inventory;
-
-import org.bukkit.inventory.Inventory;
-import org.bukkit.inventory.InventoryView;
-import org.bukkit.entity.HumanEntity;
-import org.bukkit.entity.Player;
-import org.bukkit.event.HandlerList;
-import org.bukkit.event.inventory.InventoryType.SlotType;
-import org.bukkit.Location;
-import org.bukkit.inventory.ItemStack;
-import org.bukkit.scheduler.BukkitScheduler;
-import org.bukkit.plugin.Plugin;
-
-/**
- * This event is called when a player clicks a slot in an inventory.
- * <p>
- * Because InventoryClickEvent occurs within a modification of the Inventory,
- * not all Inventory related methods are safe to use.
- * <p>
- * The following should never be invoked by an EventHandler for
- * InventoryClickEvent using the HumanEntity or InventoryView associated with
- * this event:
- * <ul>
- * <li>{@link HumanEntity#closeInventory()}
- * <li>{@link HumanEntity#openInventory(Inventory)}
- * <li>{@link HumanEntity#openWorkbench(Location, boolean)}
- * <li>{@link HumanEntity#openEnchanting(Location, boolean)}
- * <li>{@link InventoryView#close()}
- * </ul>
- * To invoke one of these methods, schedule a task using 
- * {@link BukkitScheduler#runTask(Plugin, Runnable)}, which will run the task
- * on the next tick. Also be aware that this is not an exhaustive list, and
- * other methods could potentially create issues as well.
- * <p>
- * Assuming the EntityHuman associated with this event is an instance of a
- * Player, manipulating the MaxStackSize or contents of an Inventory will
- * require an Invocation of {@link Player#updateInventory()}.
- * <p>
- * Modifications to slots that are modified by the results of this
- * InventoryClickEvent can be overwritten. To change these slots, this event
- * should be cancelled and all desired changes to the inventory applied.
- * Alternatively, scheduling a task using {@link BukkitScheduler#runTask(
- * Plugin, Runnable)}, which would execute the task on the next tick, would
- * work as well.
- */
-public class InventoryClickEvent extends InventoryInteractEvent {
-    private static final HandlerList handlers = new HandlerList();
-    private final ClickType click;
-    private final InventoryAction action;
-    private SlotType slot_type;
-    private int whichSlot;
-    private int rawSlot;
-    private ItemStack current = null;
-    private int hotbarKey = -1;
-
-    @Deprecated
-    public InventoryClickEvent(InventoryView view, SlotType type, int slot, boolean right, boolean shift) {
-        this(view, type, slot, right ? (shift ? ClickType.SHIFT_RIGHT : ClickType.RIGHT) : (shift ? ClickType.SHIFT_LEFT : ClickType.LEFT), InventoryAction.SWAP_WITH_CURSOR);
-    }
-
-    public InventoryClickEvent(InventoryView view, SlotType type, int slot, ClickType click, InventoryAction action) {
-        super(view);
-        this.slot_type = type;
-        this.rawSlot = slot;
-        this.whichSlot = view.convertSlot(slot);
-        this.click = click;
-        this.action = action;
-    }
-
-    public InventoryClickEvent(InventoryView view, SlotType type, int slot, ClickType click, InventoryAction action, int key) {
-        this(view, type, slot, click, action);
-        this.hotbarKey = key;
-    }
-
-    /**
-     * Gets the type of slot that was clicked.
-     *
-     * @return the slot type
-     */
-    public SlotType getSlotType() {
-        return slot_type;
-    }
-
-    /**
-     * Gets the current ItemStack on the cursor.
-     *
-     * @return the cursor ItemStack
-     */
-    public ItemStack getCursor() {
-        return getView().getCursor();
-    }
-
-    /**
-     * Gets the ItemStack currently in the clicked slot.
-     *
-     * @return the item in the clicked
-     */
-    public ItemStack getCurrentItem() {
-        if (slot_type == SlotType.OUTSIDE) {
-            return current;
-        }
-        return getView().getItem(rawSlot);
-    }
-
-    /**
-     * Gets whether or not the ClickType for this event represents a right
-     * click.
-     *
-     * @return true if the ClickType uses the right mouse button.
-     * @see ClickType#isRightClick()
-     */
-    public boolean isRightClick() {
-        return click.isRightClick();
-    }
-
-    /**
-     * Gets whether or not the ClickType for this event represents a left
-     * click.
-     *
-     * @return true if the ClickType uses the left mouse button.
-     * @see ClickType#isLeftClick()
-     */
-    public boolean isLeftClick() {
-        return click.isLeftClick();
-    }
-
-    /**
-     * Gets whether the ClickType for this event indicates that the key was
-     * pressed down when the click was made.
-     *
-     * @return true if the ClickType uses Shift or Ctrl.
-     * @see ClickType#isShiftClick()
-     */
-    public boolean isShiftClick() {
-        return click.isShiftClick();
-    }
-
-    /**
-     * Sets the item on the cursor.
-     *
-     * @param stack the new cursor item
-     * @deprecated This changes the ItemStack in their hand before any
-     *     calculations are applied to the Inventory, which has a tendency to
-     *     create inconsistencies between the Player and the server, and to
-     *     make unexpected changes in the behavior of the clicked Inventory.
-     */
-    @Deprecated
-    public void setCursor(ItemStack stack) {
-        getView().setCursor(stack);
-    }
-
-    /**
-     * Sets the ItemStack currently in the clicked slot.
-     *
-     * @param stack the item to be placed in the current slot
-     */
-    public void setCurrentItem(ItemStack stack) {
-        if (slot_type == SlotType.OUTSIDE) {
-            current = stack;
-        } else {
-            getView().setItem(rawSlot, stack);
-        }
-    }
-
-    /**
-     * The slot number that was clicked, ready for passing to
-     * {@link Inventory#getItem(int)}. Note that there may be two slots with
-     * the same slot number, since a view links two different inventories.
-     *
-     * @return The slot number.
-     */
-    public int getSlot() {
-        return whichSlot;
-    }
-
-    /**
-     * The raw slot number clicked, ready for passing to {@link InventoryView
-     * #getItem(int)} This slot number is unique for the view.
-     *
-     * @return the slot number
-     */
-    public int getRawSlot() {
-        return rawSlot;
-    }
-
-    /**
-     * If the ClickType is NUMBER_KEY, this method will return the index of
-     * the pressed key (0-8).
-     *
-     * @return the number on the key minus 1 (range 0-8); or -1 if not
-     *     a NUMBER_KEY action
-     */
-    public int getHotbarButton() {
-        return hotbarKey;
-    }
-
-    /**
-     * Gets the InventoryAction that triggered this event.
-     * <p>
-     * This action cannot be changed, and represents what the normal outcome
-     * of the event will be. To change the behavior of this
-     * InventoryClickEvent, changes must be manually applied.
-     *
-     * @return the InventoryAction that triggered this event.
-     */
-    public InventoryAction getAction() {
-        return action;
-    }
-
-    /**
-     * Gets the ClickType for this event.
-     * <p>
-     * This is insulated against changes to the inventory by other plugins.
-     *
-     * @return the type of inventory click
-     */
-    public ClickType getClick() {
-        return click;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/inventory/InventoryCloseEvent.java b/src/main/java/org/bukkit/event/inventory/InventoryCloseEvent.java
deleted file mode 100644
index 19889b2..0000000
--- a/src/main/java/org/bukkit/event/inventory/InventoryCloseEvent.java
+++ /dev/null
@@ -1,35 +0,0 @@
-
-package org.bukkit.event.inventory;
-
-import org.bukkit.entity.HumanEntity;
-import org.bukkit.event.HandlerList;
-import org.bukkit.inventory.InventoryView;
-
-/**
- * Represents a player related inventory event
- */
-public class InventoryCloseEvent extends InventoryEvent {
-    private static final HandlerList handlers = new HandlerList();
-
-    public InventoryCloseEvent(InventoryView transaction) {
-        super(transaction);
-    }
-
-    /**
-     * Returns the player involved in this event
-     *
-     * @return Player who is involved in this event
-     */
-    public final HumanEntity getPlayer() {
-        return transaction.getPlayer();
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/inventory/InventoryCreativeEvent.java b/src/main/java/org/bukkit/event/inventory/InventoryCreativeEvent.java
deleted file mode 100644
index da7dffc..0000000
--- a/src/main/java/org/bukkit/event/inventory/InventoryCreativeEvent.java
+++ /dev/null
@@ -1,27 +0,0 @@
-package org.bukkit.event.inventory;
-
-import org.bukkit.event.inventory.InventoryType.SlotType;
-import org.bukkit.inventory.InventoryView;
-import org.bukkit.inventory.ItemStack;
-
-/**
- * This event is called when a player in creative mode puts down or picks up
- * an item in their inventory / hotbar and when they drop items from their
- * Inventory while in creative mode.
- */
-public class InventoryCreativeEvent extends InventoryClickEvent {
-    private ItemStack item;
-
-    public InventoryCreativeEvent(InventoryView what, SlotType type, int slot, ItemStack newItem) {
-        super(what, type, slot, ClickType.CREATIVE, InventoryAction.PLACE_ALL);
-        this.item = newItem;
-    }
-
-    public ItemStack getCursor() {
-        return item;
-    }
-
-    public void setCursor(ItemStack item) {
-        this.item = item;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/inventory/InventoryDragEvent.java b/src/main/java/org/bukkit/event/inventory/InventoryDragEvent.java
deleted file mode 100644
index e7e54a7..0000000
--- a/src/main/java/org/bukkit/event/inventory/InventoryDragEvent.java
+++ /dev/null
@@ -1,164 +0,0 @@
-package org.bukkit.event.inventory;
-
-import java.util.Collections;
-import java.util.Map;
-import java.util.Set;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.Location;
-import org.bukkit.entity.HumanEntity;
-import org.bukkit.entity.Player;
-import org.bukkit.event.HandlerList;
-import org.bukkit.inventory.Inventory;
-import org.bukkit.inventory.InventoryView;
-import org.bukkit.inventory.ItemStack;
-import org.bukkit.plugin.Plugin;
-import org.bukkit.scheduler.BukkitScheduler;
-
-import com.google.common.collect.ImmutableSet;
-
-/**
- * This event is called when the player drags an item in their cursor across
- * the inventory. The ItemStack is distributed across the slots the
- * HumanEntity dragged over. The method of distribution is described by the 
- * DragType returned by {@link #getType()}.
- * <p>
- * Canceling this event will result in none of the changes described in
- * {@link #getNewItems()} being applied to the Inventory.
- * <p>
- * Because InventoryDragEvent occurs within a modification of the Inventory,
- * not all Inventory related methods are safe to use.
- * <p>
- * The following should never be invoked by an EventHandler for
- * InventoryDragEvent using the HumanEntity or InventoryView associated with
- * this event.
- * <ul>
- * <li>{@link HumanEntity#closeInventory()}
- * <li>{@link HumanEntity#openInventory(Inventory)}
- * <li>{@link HumanEntity#openWorkbench(Location, boolean)}
- * <li>{@link HumanEntity#openEnchanting(Location, boolean)}
- * <li>{@link InventoryView#close()}
- * </ul>
- * To invoke one of these methods, schedule a task using 
- * {@link BukkitScheduler#runTask(Plugin, Runnable)}, which will run the task
- * on the next tick.  Also be aware that this is not an exhaustive list, and
- * other methods could potentially create issues as well.
- * <p>
- * Assuming the EntityHuman associated with this event is an instance of a
- * Player, manipulating the MaxStackSize or contents of an Inventory will
- * require an Invocation of {@link Player#updateInventory()}.
- * <p>
- * Any modifications to slots that are modified by the results of this
- * InventoryDragEvent will be overwritten. To change these slots, this event
- * should be cancelled and the changes applied. Alternatively, scheduling a
- * task using {@link BukkitScheduler#runTask(Plugin, Runnable)}, which would
- * execute the task on the next tick, would work as well.
- */
-public class InventoryDragEvent extends InventoryInteractEvent {
-    private static final HandlerList handlers = new HandlerList();
-    private final DragType type;
-    private final Map<Integer, ItemStack> addedItems;
-    private final Set<Integer> containerSlots;
-    private final ItemStack oldCursor;
-    private ItemStack newCursor;
-
-    public InventoryDragEvent(InventoryView what, ItemStack newCursor, ItemStack oldCursor, boolean right, Map<Integer, ItemStack> slots) {
-        super(what);
-
-        Validate.notNull(oldCursor);
-        Validate.notNull(slots);
-
-        type = right ? DragType.SINGLE : DragType.EVEN;
-        this.newCursor = newCursor;
-        this.oldCursor = oldCursor;
-        this.addedItems = slots;
-        ImmutableSet.Builder<Integer> b = ImmutableSet.builder();
-        for (Integer slot : slots.keySet()) {
-            b.add(what.convertSlot(slot));
-        }
-        this.containerSlots = b.build();
-    }
-
-    /**
-     * Gets all items to be added to the inventory in this drag.
-     *
-     * @return map from raw slot id to new ItemStack
-     */
-    public Map<Integer, ItemStack> getNewItems() {
-        return Collections.unmodifiableMap(addedItems);
-    }
-
-    /**
-     * Gets the raw slot ids to be changed in this drag.
-     *
-     * @return list of raw slot ids, suitable for getView().getItem(int)
-     */
-    public Set<Integer> getRawSlots() {
-        return addedItems.keySet();
-    }
-
-    /**
-     * Gets the slots to be changed in this drag.
-     *
-     * @return list of converted slot ids, suitable for {@link
-     *     org.bukkit.inventory.Inventory#getItem(int)}.
-     */
-    public Set<Integer> getInventorySlots() {
-        return containerSlots;
-    }
-
-    /**
-     * Gets the result cursor after the drag is done. The returned value is
-     * mutable.
-     *
-     * @return the result cursor
-     */
-    public ItemStack getCursor() {
-        return newCursor;
-    }
-
-    /**
-     * Sets the result cursor after the drag is done.
-     * <p>
-     * Changing this item stack changes the cursor item. Note that changing
-     * the affected "dragged" slots does not change this ItemStack, nor does
-     * changing this ItemStack affect the "dragged" slots.
-     *
-     * @param newCursor the new cursor ItemStack
-     */
-    public void setCursor(ItemStack newCursor) {
-        this.newCursor = newCursor;
-    }
-
-    /**
-     * Gets an ItemStack representing the cursor prior to any modifications
-     * as a result of this drag.
-     *
-     * @return the original cursor
-     */
-    public ItemStack getOldCursor() {
-        return oldCursor.clone();
-    }
-
-    /**
-     * Gets the DragType that describes the behavior of ItemStacks placed
-     * after this InventoryDragEvent.
-     * <p>
-     * The ItemStacks and the raw slots that they're being applied to can be
-     * found using {@link #getNewItems()}.
-     *
-     * @return the DragType of this InventoryDragEvent
-     */
-    public DragType getType() {
-        return type;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/inventory/InventoryEvent.java b/src/main/java/org/bukkit/event/inventory/InventoryEvent.java
deleted file mode 100644
index 973c392..0000000
--- a/src/main/java/org/bukkit/event/inventory/InventoryEvent.java
+++ /dev/null
@@ -1,59 +0,0 @@
-
-package org.bukkit.event.inventory;
-
-import java.util.List;
-
-import org.bukkit.event.HandlerList;
-import org.bukkit.entity.HumanEntity;
-import org.bukkit.event.Event;
-import org.bukkit.inventory.Inventory;
-import org.bukkit.inventory.InventoryView;
-
-/**
- * Represents a player related inventory event
- */
-public class InventoryEvent extends Event {
-    private static final HandlerList handlers = new HandlerList();
-    protected InventoryView transaction;
-
-    public InventoryEvent(InventoryView transaction) {
-        this.transaction = transaction;
-    }
-
-    /**
-     * Gets the primary Inventory involved in this transaction
-     *
-     * @return The upper inventory.
-     */
-    public Inventory getInventory() {
-        return transaction.getTopInventory();
-    }
-
-    /**
-     * Gets the list of players viewing the primary (upper) inventory involved
-     * in this event
-     *
-     * @return A list of people viewing.
-     */
-    public List<HumanEntity> getViewers() {
-        return transaction.getTopInventory().getViewers();
-    }
-
-    /**
-     * Gets the view object itself
-     *
-     * @return InventoryView
-     */
-    public InventoryView getView() {
-        return transaction;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/inventory/InventoryInteractEvent.java b/src/main/java/org/bukkit/event/inventory/InventoryInteractEvent.java
deleted file mode 100644
index 8624f8d..0000000
--- a/src/main/java/org/bukkit/event/inventory/InventoryInteractEvent.java
+++ /dev/null
@@ -1,78 +0,0 @@
-package org.bukkit.event.inventory;
-
-import org.bukkit.entity.HumanEntity;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.Event.Result;
-import org.bukkit.inventory.InventoryView;
-import org.bukkit.inventory.ItemStack;
-
-/**
- * An abstract base class for events that describe an interaction between a
- * HumanEntity and the contents of an Inventory.
- */
-public abstract class InventoryInteractEvent extends InventoryEvent implements Cancellable {
-    private Result result = Result.DEFAULT;
-
-    public InventoryInteractEvent(InventoryView transaction) {
-        super(transaction);
-    }
-
-    /**
-     * Gets the player who performed the click.
-     *
-     * @return The clicking player.
-     */
-    public HumanEntity getWhoClicked() {
-        return getView().getPlayer();
-    }
-
-    /**
-     * Sets the result of this event. This will change whether or not this
-     * event is considered cancelled.
-     *
-     * @see #isCancelled()
-     * @param newResult the new {@link Result} for this event
-     */
-    public void setResult(Result newResult) {
-        result = newResult;
-    }
-
-    /**
-     * Gets the {@link Result} of this event. The Result describes the
-     * behavior that will be applied to the inventory in relation to this
-     * event.
-     *
-     * @return the Result of this event.
-     */
-    public Result getResult() {
-        return result;
-    }
-
-    /**
-     * Gets whether or not this event is cancelled. This is based off of the
-     * Result value returned by {@link #getResult()}.  Result.ALLOW and
-     * Result.DEFAULT will result in a returned value of false, but
-     * Result.DENY will result in a returned value of true.
-     * <p>
-     * {@inheritDoc}
-     *
-     * @return whether the event is cancelled
-     */
-    public boolean isCancelled() {
-        return getResult() == Result.DENY;
-    }
-
-    /**
-     * Proxy method to {@link #setResult(Event.Result)} for the Cancellable
-     * interface. {@link #setResult(Event.Result)} is preferred, as it allows
-     * you to specify the Result beyond Result.DENY and Result.ALLOW.
-     * <p>
-     * {@inheritDoc}
-     *
-     * @param toCancel result becomes DENY if true, ALLOW if false
-     */
-    public void setCancelled(boolean toCancel) {
-        setResult(toCancel ? Result.DENY : Result.ALLOW);
-    }
-
-}
diff --git a/src/main/java/org/bukkit/event/inventory/InventoryMoveItemEvent.java b/src/main/java/org/bukkit/event/inventory/InventoryMoveItemEvent.java
deleted file mode 100644
index 06ec99a..0000000
--- a/src/main/java/org/bukkit/event/inventory/InventoryMoveItemEvent.java
+++ /dev/null
@@ -1,108 +0,0 @@
-package org.bukkit.event.inventory;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.Event;
-import org.bukkit.event.HandlerList;
-import org.bukkit.inventory.Inventory;
-import org.bukkit.inventory.ItemStack;
-
-/**
- * Called when some entity or block (e.g. hopper) tries to move items directly
- * from one inventory to another.
- * <p>
- * When this event is called, the initiator may already have removed the item
- * from the source inventory and is ready to move it into the destination
- * inventory.
- * <p>
- * If this event is cancelled, the items will be returned to the source
- * inventory, if needed.
- * <p>
- * If this event is not cancelled, the initiator will try to put the ItemStack
- * into the destination inventory. If this is not possible and the ItemStack
- * has not been modified, the source inventory slot will be restored to its
- * former state. Otherwise any additional items will be discarded.
- */
-public class InventoryMoveItemEvent extends Event implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private boolean cancelled;
-    private final Inventory sourceInventory;
-    private final Inventory destinationInventory;
-    private ItemStack itemStack;
-    private final boolean didSourceInitiate;
-
-    public InventoryMoveItemEvent(final Inventory sourceInventory, final ItemStack itemStack, final Inventory destinationInventory, final boolean didSourceInitiate) {
-        Validate.notNull(itemStack, "ItemStack cannot be null");
-        this.sourceInventory = sourceInventory;
-        this.itemStack = itemStack;
-        this.destinationInventory = destinationInventory;
-        this.didSourceInitiate = didSourceInitiate;
-    }
-
-    /**
-     * Gets the Inventory that the ItemStack is being taken from
-     *
-     * @return Inventory that the ItemStack is being taken from
-     */
-    public Inventory getSource() {
-        return sourceInventory;
-    }
-
-    /**
-     * Gets the ItemStack being moved; if modified, the original item will not
-     * be removed from the source inventory.
-     *
-     * @return ItemStack
-     */
-    public ItemStack getItem() {
-        return itemStack.clone();
-    }
-
-    /**
-     * Sets the ItemStack being moved; if this is different from the original
-     * ItemStack, the original item will not be removed from the source
-     * inventory.
-     *
-     * @param itemStack The ItemStack
-     */
-    public void setItem(ItemStack itemStack) {
-        Validate.notNull(itemStack, "ItemStack cannot be null.  Cancel the event if you want nothing to be transferred.");
-        this.itemStack = itemStack.clone();
-    }
-
-    /**
-     * Gets the Inventory that the ItemStack is being put into
-     *
-     * @return Inventory that the ItemStack is being put into
-     */
-    public Inventory getDestination() {
-        return destinationInventory;
-    }
-
-    /**
-     * Gets the Inventory that initiated the transfer. This will always be
-     * either the destination or source Inventory.
-     *
-     * @return Inventory that initiated the transfer
-     */
-    public Inventory getInitiator() {
-        return didSourceInitiate ? sourceInventory : destinationInventory;
-    }
-
-    public boolean isCancelled() {
-        return cancelled;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancelled = cancel;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/inventory/InventoryOpenEvent.java b/src/main/java/org/bukkit/event/inventory/InventoryOpenEvent.java
deleted file mode 100644
index c3570aa..0000000
--- a/src/main/java/org/bukkit/event/inventory/InventoryOpenEvent.java
+++ /dev/null
@@ -1,63 +0,0 @@
-package org.bukkit.event.inventory;
-
-import org.bukkit.inventory.InventoryView;
-import org.bukkit.entity.HumanEntity;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Represents a player related inventory event
- */
-public class InventoryOpenEvent extends InventoryEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private boolean cancelled;
-
-    public InventoryOpenEvent(InventoryView transaction) {
-        super(transaction);
-        this.cancelled = false;
-    }
-
-    /**
-     * Returns the player involved in this event
-     *
-     * @return Player who is involved in this event
-     */
-    public final HumanEntity getPlayer() {
-        return transaction.getPlayer();
-    }
-
-    /**
-     * Gets the cancellation state of this event. A cancelled event will not
-     * be executed in the server, but will still pass to other plugins.
-     * <p>
-     * If an inventory open event is cancelled, the inventory screen will not
-     * show.
-     *
-     * @return true if this event is cancelled
-     */
-    public boolean isCancelled() {
-        return cancelled;
-    }
-
-    /**
-     * Sets the cancellation state of this event. A cancelled event will not
-     * be executed in the server, but will still pass to other plugins.
-     * <p>
-     * If an inventory open event is cancelled, the inventory screen will not
-     * show.
-     *
-     * @param cancel true if you wish to cancel this event
-     */
-    public void setCancelled(boolean cancel) {
-        cancelled = cancel;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/inventory/InventoryPickupItemEvent.java b/src/main/java/org/bukkit/event/inventory/InventoryPickupItemEvent.java
deleted file mode 100644
index af6ad5b..0000000
--- a/src/main/java/org/bukkit/event/inventory/InventoryPickupItemEvent.java
+++ /dev/null
@@ -1,58 +0,0 @@
-package org.bukkit.event.inventory;
-
-import org.bukkit.entity.Item;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.Event;
-import org.bukkit.event.HandlerList;
-import org.bukkit.inventory.Inventory;
-
-/**
- * Called when a hopper or hopper minecart picks up a dropped item.
- */
-public class InventoryPickupItemEvent extends Event implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private boolean cancelled;
-    private final Inventory inventory;
-    private final Item item;
-
-    public InventoryPickupItemEvent(final Inventory inventory, final Item item) {
-        super();
-        this.inventory = inventory;
-        this.item = item;
-    }
-
-    /**
-     * Gets the Inventory that picked up the item
-     *
-     * @return Inventory
-     */
-    public Inventory getInventory() {
-        return inventory;
-    }
-
-    /**
-     * Gets the Item entity that was picked up
-     *
-     * @return Item
-     */
-    public Item getItem() {
-        return item;
-    }
-
-    public boolean isCancelled() {
-        return cancelled;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancelled = cancel;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/inventory/InventoryType.java b/src/main/java/org/bukkit/event/inventory/InventoryType.java
deleted file mode 100644
index 43be533..0000000
--- a/src/main/java/org/bukkit/event/inventory/InventoryType.java
+++ /dev/null
@@ -1,125 +0,0 @@
-package org.bukkit.event.inventory;
-
-public enum InventoryType {
-
-    /**
-     * A chest inventory, with 0, 9, 18, 27, 36, 45, or 54 slots of type
-     * CONTAINER.
-     */
-    CHEST(27,"Chest"),
-    /**
-     * A dispenser inventory, with 9 slots of type CONTAINER.
-     */
-    DISPENSER(9,"Dispenser"),
-    /**
-     * A dropper inventory, with 9 slots of type CONTAINER.
-     */
-    DROPPER(9, "Dropper"),
-    /**
-     * A furnace inventory, with a RESULT slot, a CRAFTING slot, and a FUEL
-     * slot.
-     */
-    FURNACE(3,"Furnace"),
-    /**
-     * A workbench inventory, with 9 CRAFTING slots and a RESULT slot.
-     */
-    WORKBENCH(10,"Crafting"),
-    /**
-     * A player's crafting inventory, with 4 CRAFTING slots and a RESULT slot.
-     * Also implies that the 4 ARMOR slots are accessible.
-     */
-    CRAFTING(5,"Crafting"),
-    /**
-     * An enchantment table inventory, with two CRAFTING slots and three
-     * enchanting buttons.
-     */
-    ENCHANTING(2,"Enchanting"),
-    /**
-     * A brewing stand inventory, with one FUEL slot and three CRAFTING slots.
-     */
-    BREWING(5,"Brewing"),
-    /**
-     * A player's inventory, with 9 QUICKBAR slots, 27 CONTAINER slots, 4 ARMOR
-     * slots and 1 offhand slot. The ARMOR and offhand slots may not be visible
-     * to the player, though.
-     */
-    PLAYER(41,"Player"),
-    /**
-     * The creative mode inventory, with only 9 QUICKBAR slots and nothing
-     * else. (The actual creative interface with the items is client-side and
-     * cannot be altered by the server.)
-     */
-    CREATIVE(9,"Creative"),
-    /**
-     * The merchant inventory, with 2 TRADE-IN slots, and 1 RESULT slot.
-     */
-    MERCHANT(3,"Villager"),
-    /**
-     * The ender chest inventory, with 27 slots.
-     */
-    ENDER_CHEST(27,"Ender Chest"),
-    /**
-     * An anvil inventory, with 2 CRAFTING slots and 1 RESULT slot
-     */
-    ANVIL(3, "Repairing"),
-    /**
-     * A beacon inventory, with 1 CRAFTING slot
-     */
-    BEACON(1, "container.beacon"),
-    /**
-     * A hopper inventory, with 5 slots of type CONTAINER.
-     */
-    HOPPER(5, "Item Hopper"),
-    ;
-
-    private final int size;
-    private final String title;
-
-    private InventoryType(int defaultSize, String defaultTitle) {
-        size = defaultSize;
-        title = defaultTitle;
-    }
-
-    public int getDefaultSize() {
-        return size;
-    }
-
-    public String getDefaultTitle() {
-        return title;
-    }
-
-    public enum SlotType {
-        /**
-         * A result slot in a furnace or crafting inventory.
-         */
-        RESULT,
-        /**
-         * A slot in the crafting matrix, or the input slot in a furnace
-         * inventory, the potion slot in the brewing stand, or the enchanting
-         * slot.
-         */
-        CRAFTING,
-        /**
-         * An armour slot in the player's inventory.
-         */
-        ARMOR,
-        /**
-         * A regular slot in the container or the player's inventory; anything
-         * not covered by the other enum values.
-         */
-        CONTAINER,
-        /**
-         * A slot in the bottom row or quickbar.
-         */
-        QUICKBAR,
-        /**
-         * A pseudo-slot representing the area outside the inventory window.
-         */
-        OUTSIDE,
-        /**
-         * The fuel slot in a furnace inventory, or the ingredient slot in a
-         * brewing stand inventory.
-         */
-        FUEL;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/inventory/PrepareAnvilEvent.java b/src/main/java/org/bukkit/event/inventory/PrepareAnvilEvent.java
deleted file mode 100644
index ce49676..0000000
--- a/src/main/java/org/bukkit/event/inventory/PrepareAnvilEvent.java
+++ /dev/null
@@ -1,47 +0,0 @@
-package org.bukkit.event.inventory;
-
-import org.bukkit.event.HandlerList;
-import org.bukkit.inventory.AnvilInventory;
-import org.bukkit.inventory.InventoryView;
-import org.bukkit.inventory.ItemStack;
-
-/**
- * Called when an item is put in a slot for repair by an anvil.
- */
-public class PrepareAnvilEvent extends InventoryEvent {
-
-    private static final HandlerList handlers = new HandlerList();
-    private ItemStack result;
-
-    public PrepareAnvilEvent(InventoryView inventory, ItemStack result) {
-        super(inventory);
-        this.result = result;
-    }
-
-    @Override
-    public AnvilInventory getInventory() {
-        return (AnvilInventory) super.getInventory();
-    }
-
-    /**
-     * Get result item, may be null.
-     *
-     * @return result item
-     */
-    public ItemStack getResult() {
-        return result;
-    }
-
-    public void setResult(ItemStack result) {
-        this.result = result;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/inventory/PrepareItemCraftEvent.java b/src/main/java/org/bukkit/event/inventory/PrepareItemCraftEvent.java
deleted file mode 100644
index 5731190..0000000
--- a/src/main/java/org/bukkit/event/inventory/PrepareItemCraftEvent.java
+++ /dev/null
@@ -1,56 +0,0 @@
-package org.bukkit.event.inventory;
-
-import org.bukkit.event.HandlerList;
-import org.bukkit.inventory.CraftingInventory;
-import org.bukkit.inventory.InventoryView;
-import org.bukkit.inventory.Recipe;
-
-public class PrepareItemCraftEvent extends InventoryEvent {
-    private static final HandlerList handlers = new HandlerList();
-    private boolean repair;
-    private CraftingInventory matrix;
-
-    public PrepareItemCraftEvent(CraftingInventory what, InventoryView view, boolean isRepair) {
-        super(view);
-        this.matrix = what;
-        this.repair = isRepair;
-    }
-
-    /**
-     * Get the recipe that has been formed. If this event was triggered by a
-     * tool repair, this will be a temporary shapeless recipe representing the
-     * repair.
-     *
-     * @return The recipe being crafted.
-     */
-    public Recipe getRecipe() {
-        return matrix.getRecipe();
-    }
-
-    /**
-     * @return The crafting inventory on which the recipe was formed.
-     */
-    @Override
-    public CraftingInventory getInventory() {
-        return matrix;
-    }
-
-    /**
-     * Check if this event was triggered by a tool repair operation rather
-     * than a crafting recipe.
-     *
-     * @return True if this is a repair.
-     */
-    public boolean isRepair() {
-        return repair;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/player/AsyncPlayerChatEvent.java b/src/main/java/org/bukkit/event/player/AsyncPlayerChatEvent.java
deleted file mode 100644
index a796292..0000000
--- a/src/main/java/org/bukkit/event/player/AsyncPlayerChatEvent.java
+++ /dev/null
@@ -1,140 +0,0 @@
-package org.bukkit.event.player;
-
-import java.util.IllegalFormatException;
-import java.util.Set;
-
-import org.bukkit.entity.Player;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * This event will sometimes fire synchronously, depending on how it was
- * triggered.
- * <p>
- * The constructor provides a boolean to indicate if the event was fired
- * synchronously or asynchronously. When asynchronous, this event can be
- * called from any thread, sans the main thread, and has limited access to the
- * API.
- * <p>
- * If a player is the direct cause of this event by an incoming packet, this
- * event will be asynchronous. If a plugin triggers this event by compelling a
- * player to chat, this event will be synchronous.
- * <p>
- * Care should be taken to check {@link #isAsynchronous()} and treat the event
- * appropriately.
- */
-public class AsyncPlayerChatEvent extends PlayerEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private boolean cancel = false;
-    private String message;
-    private String format = "<%1$s> %2$s";
-    private final Set<Player> recipients;
-
-    /**
-     *
-     * @param async This changes the event to a synchronous state.
-     * @param who the chat sender
-     * @param message the message sent
-     * @param players the players to receive the message. This may be a lazy
-     *     or unmodifiable collection.
-     */
-    public AsyncPlayerChatEvent(final boolean async, final Player who, final String message, final Set<Player> players) {
-        super(who, async);
-        this.message = message;
-        recipients = players;
-    }
-
-    /**
-     * Gets the message that the player is attempting to send. This message
-     * will be used with {@link #getFormat()}.
-     *
-     * @return Message the player is attempting to send
-     */
-    public String getMessage() {
-        return message;
-    }
-
-    /**
-     * Sets the message that the player will send. This message will be used
-     * with {@link #getFormat()}.
-     *
-     * @param message New message that the player will send
-     */
-    public void setMessage(String message) {
-        this.message = message;
-    }
-
-    /**
-     * Gets the format to use to display this chat message.
-     * <p>
-     * When this event finishes execution, the first format parameter is the
-     * {@link Player#getDisplayName()} and the second parameter is {@link
-     * #getMessage()}
-     *
-     * @return {@link String#format(String, Object...)} compatible format
-     *     string
-     */
-    public String getFormat() {
-        return format;
-    }
-
-    /**
-     * Sets the format to use to display this chat message.
-     * <p>
-     * When this event finishes execution, the first format parameter is the
-     * {@link Player#getDisplayName()} and the second parameter is {@link
-     * #getMessage()}
-     *
-     * @param format {@link String#format(String, Object...)} compatible
-     *     format string
-     * @throws IllegalFormatException if the underlying API throws the
-     *     exception
-     * @throws NullPointerException if format is null
-     * @see String#format(String, Object...)
-     */
-    public void setFormat(final String format) throws IllegalFormatException, NullPointerException {
-        // Oh for a better way to do this!
-        try {
-            String.format(format, player, message);
-        } catch (RuntimeException ex) {
-            ex.fillInStackTrace();
-            throw ex;
-        }
-
-        this.format = format;
-    }
-
-    /**
-     * Gets a set of recipients that this chat message will be displayed to.
-     * <p>
-     * The set returned is not guaranteed to be mutable and may auto-populate
-     * on access. Any listener accessing the returned set should be aware that
-     * it may reduce performance for a lazy set implementation.
-     * <p>
-     * Listeners should be aware that modifying the list may throw {@link
-     * UnsupportedOperationException} if the event caller provides an
-     * unmodifiable set.
-     *
-     * @return All Players who will see this chat message
-     */
-    public Set<Player> getRecipients() {
-        return recipients;
-    }
-
-    public boolean isCancelled() {
-        return cancel ;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancel = cancel;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/player/AsyncPlayerPreLoginEvent.java b/src/main/java/org/bukkit/event/player/AsyncPlayerPreLoginEvent.java
deleted file mode 100644
index 1d57188..0000000
--- a/src/main/java/org/bukkit/event/player/AsyncPlayerPreLoginEvent.java
+++ /dev/null
@@ -1,201 +0,0 @@
-package org.bukkit.event.player;
-
-import java.net.InetAddress;
-import java.util.UUID;
-
-import org.bukkit.event.Event;
-import org.bukkit.event.HandlerList;
-
-/**
- * Stores details for players attempting to log in.
- * <p>
- * This event is asynchronous, and not run using main thread.
- */
-public class AsyncPlayerPreLoginEvent extends Event {
-    private static final HandlerList handlers = new HandlerList();
-    private Result result;
-    private String message;
-    private final String name;
-    private final InetAddress ipAddress;
-    private final UUID uniqueId;
-
-    @Deprecated
-    public AsyncPlayerPreLoginEvent(final String name, final InetAddress ipAddress) {
-        this(name, ipAddress, null);
-    }
-
-    public AsyncPlayerPreLoginEvent(final String name, final InetAddress ipAddress, final UUID uniqueId) {
-        super(true);
-        this.result = Result.ALLOWED;
-        this.message = "";
-        this.name = name;
-        this.ipAddress = ipAddress;
-        this.uniqueId = uniqueId;
-    }
-
-    /**
-     * Gets the current result of the login, as an enum
-     *
-     * @return Current Result of the login
-     */
-    public Result getLoginResult() {
-        return result;
-    }
-
-    /**
-     * Gets the current result of the login, as an enum
-     *
-     * @return Current Result of the login
-     * @deprecated This method uses a deprecated enum from {@link
-     *     PlayerPreLoginEvent}
-     * @see #getLoginResult()
-     */
-    @Deprecated
-    public PlayerPreLoginEvent.Result getResult() {
-        return result == null ? null : result.old();
-    }
-
-    /**
-     * Sets the new result of the login, as an enum
-     *
-     * @param result New result to set
-     */
-    public void setLoginResult(final Result result) {
-        this.result = result;
-    }
-
-    /**
-     * Sets the new result of the login, as an enum
-     *
-     * @param result New result to set
-     * @deprecated This method uses a deprecated enum from {@link
-     *     PlayerPreLoginEvent}
-     * @see #setLoginResult(Result)
-     */
-    @Deprecated
-    public void setResult(final PlayerPreLoginEvent.Result result) {
-        this.result = result == null ? null : Result.valueOf(result.name());
-    }
-
-    /**
-     * Gets the current kick message that will be used if getResult() !=
-     * Result.ALLOWED
-     *
-     * @return Current kick message
-     */
-    public String getKickMessage() {
-        return message;
-    }
-
-    /**
-     * Sets the kick message to display if getResult() != Result.ALLOWED
-     *
-     * @param message New kick message
-     */
-    public void setKickMessage(final String message) {
-        this.message = message;
-    }
-
-    /**
-     * Allows the player to log in
-     */
-    public void allow() {
-        result = Result.ALLOWED;
-        message = "";
-    }
-
-    /**
-     * Disallows the player from logging in, with the given reason
-     *
-     * @param result New result for disallowing the player
-     * @param message Kick message to display to the user
-     */
-    public void disallow(final Result result, final String message) {
-        this.result = result;
-        this.message = message;
-    }
-
-    /**
-     * Disallows the player from logging in, with the given reason
-     *
-     * @param result New result for disallowing the player
-     * @param message Kick message to display to the user
-     * @deprecated This method uses a deprecated enum from {@link
-     *     PlayerPreLoginEvent}
-     * @see #disallow(Result, String)
-     */
-    @Deprecated
-    public void disallow(final PlayerPreLoginEvent.Result result, final String message) {
-        this.result = result == null ? null : Result.valueOf(result.name());
-        this.message = message;
-    }
-
-    /**
-     * Gets the player's name.
-     *
-     * @return the player's name
-     */
-    public String getName() {
-        return name;
-    }
-
-    /**
-     * Gets the player IP address.
-     *
-     * @return The IP address
-     */
-    public InetAddress getAddress() {
-        return ipAddress;
-    }
-
-    /**
-     * Gets the player's unique ID.
-     *
-     * @return The unique ID
-     */
-    public UUID getUniqueId() {
-        return uniqueId;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-
-    /**
-     * Basic kick reasons for communicating to plugins
-     */
-    public enum Result {
-
-        /**
-         * The player is allowed to log in
-         */
-        ALLOWED,
-        /**
-         * The player is not allowed to log in, due to the server being full
-         */
-        KICK_FULL,
-        /**
-         * The player is not allowed to log in, due to them being banned
-         */
-        KICK_BANNED,
-        /**
-         * The player is not allowed to log in, due to them not being on the
-         * white list
-         */
-        KICK_WHITELIST,
-        /**
-         * The player is not allowed to log in, for reasons undefined
-         */
-        KICK_OTHER;
-
-        @Deprecated
-        private PlayerPreLoginEvent.Result old() {
-            return PlayerPreLoginEvent.Result.valueOf(name());
-        }
-    }
-}
diff --git a/src/main/java/org/bukkit/event/player/PlayerAchievementAwardedEvent.java b/src/main/java/org/bukkit/event/player/PlayerAchievementAwardedEvent.java
deleted file mode 100644
index e33fade..0000000
--- a/src/main/java/org/bukkit/event/player/PlayerAchievementAwardedEvent.java
+++ /dev/null
@@ -1,46 +0,0 @@
-package org.bukkit.event.player;
-
-import org.bukkit.Achievement;
-import org.bukkit.entity.Player;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a player earns an achievement.
- */
-public class PlayerAchievementAwardedEvent extends PlayerEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private final Achievement achievement;
-    private boolean isCancelled = false;
-
-    public PlayerAchievementAwardedEvent(Player player, Achievement achievement) {
-        super(player);
-        this.achievement = achievement;
-    }
-
-    /**
-     * Gets the Achievement being awarded.
-     *
-     * @return the achievement being awarded
-     */
-    public Achievement getAchievement() {
-        return achievement;
-    }
-
-    public boolean isCancelled() {
-        return isCancelled;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.isCancelled = cancel;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/player/PlayerAnimationEvent.java b/src/main/java/org/bukkit/event/player/PlayerAnimationEvent.java
deleted file mode 100644
index cabe77d..0000000
--- a/src/main/java/org/bukkit/event/player/PlayerAnimationEvent.java
+++ /dev/null
@@ -1,52 +0,0 @@
-package org.bukkit.event.player;
-
-import org.bukkit.entity.Player;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Represents a player animation event
- */
-public class PlayerAnimationEvent extends PlayerEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private final PlayerAnimationType animationType;
-    private boolean isCancelled = false;
-
-    /**
-     * Construct a new PlayerAnimation event
-     *
-     * @param player The player instance
-     */
-    public PlayerAnimationEvent(final Player player) {
-        super(player);
-
-        // Only supported animation type for now:
-        animationType = PlayerAnimationType.ARM_SWING;
-    }
-
-    /**
-     * Get the type of this animation event
-     *
-     * @return the animation type
-     */
-    public PlayerAnimationType getAnimationType() {
-        return animationType;
-    }
-
-    public boolean isCancelled() {
-        return this.isCancelled;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.isCancelled = cancel;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/player/PlayerAnimationType.java b/src/main/java/org/bukkit/event/player/PlayerAnimationType.java
deleted file mode 100644
index ea4bf26..0000000
--- a/src/main/java/org/bukkit/event/player/PlayerAnimationType.java
+++ /dev/null
@@ -1,8 +0,0 @@
-package org.bukkit.event.player;
-
-/**
- * Different types of player animations
- */
-public enum PlayerAnimationType {
-    ARM_SWING
-}
diff --git a/src/main/java/org/bukkit/event/player/PlayerArmorStandManipulateEvent.java b/src/main/java/org/bukkit/event/player/PlayerArmorStandManipulateEvent.java
deleted file mode 100644
index 577b284..0000000
--- a/src/main/java/org/bukkit/event/player/PlayerArmorStandManipulateEvent.java
+++ /dev/null
@@ -1,75 +0,0 @@
-package org.bukkit.event.player;
-
-import org.bukkit.inventory.EquipmentSlot;
-import org.bukkit.entity.Player;
-import org.bukkit.entity.ArmorStand;
-import org.bukkit.event.HandlerList;
-import org.bukkit.inventory.ItemStack;
-
-/**
- * Called when a player interacts with an armor stand and will either swap, retrieve or place an item.
- */
-public class PlayerArmorStandManipulateEvent extends PlayerInteractEntityEvent {
-
-    private static final HandlerList handlers = new HandlerList();
-
-    private final ItemStack playerItem;
-    private final ItemStack armorStandItem;
-    private final EquipmentSlot slot;
-
-    public PlayerArmorStandManipulateEvent(final Player who, final ArmorStand clickedEntity, final ItemStack playerItem, final ItemStack armorStandItem, final EquipmentSlot slot) {
-        super(who, clickedEntity);
-        this.playerItem = playerItem;
-        this.armorStandItem = armorStandItem;
-        this.slot = slot;
-    }
-
-    /**
-     * Returns the item held by the player. If this Item is null and the armor stand Item is also null,
-     * there will be no transaction between the player and the armor stand.
-     * If the Player's item is null, but the armor stand item is not then the player will obtain the armor stand item.
-     * In the case that the Player's item is not null, but the armor stand item is null, the players item will be placed on the armor stand.
-     * If both items are not null, the items will be swapped.
-     * In the case that the event is cancelled the original items will remain the same.
-     * @return the item held by the player.
-     */
-    public ItemStack getPlayerItem() {
-        return this.playerItem;
-    }
-
-    /**
-     * Returns the item held by the armor stand.
-     * If this Item is null and the player's Item is also null, there will be no transaction between the player and the armor stand.
-     * If the Player's item is null, but the armor stand item is not then the player will obtain the armor stand item.
-     * In the case that the Player's item is not null, but the armor stand item is null, the players item will be placed on the armor stand.
-     * If both items are not null, the items will be swapped.
-     * In the case that the event is cancelled the original items will remain the same.
-     * @return the item held by the armor stand.
-     */
-    public ItemStack getArmorStandItem() {
-        return this.armorStandItem;
-    }
-
-    /**
-     * Returns the raw item slot of the armor stand in this event.
-     *
-     * @return the index of the item obtained or placed of the armor stand.
-     */
-    public EquipmentSlot getSlot() {
-        return this.slot;
-    }
-
-    @Override
-    public ArmorStand getRightClicked() {
-        return (ArmorStand) this.clickedEntity;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/player/PlayerBedEnterEvent.java b/src/main/java/org/bukkit/event/player/PlayerBedEnterEvent.java
deleted file mode 100644
index 09f1a66..0000000
--- a/src/main/java/org/bukkit/event/player/PlayerBedEnterEvent.java
+++ /dev/null
@@ -1,46 +0,0 @@
-package org.bukkit.event.player;
-
-import org.bukkit.block.Block;
-import org.bukkit.entity.Player;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * This event is fired when the player is almost about to enter the bed.
- */
-public class PlayerBedEnterEvent extends PlayerEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private boolean cancel = false;
-    private final Block bed;
-
-    public PlayerBedEnterEvent(final Player who, final Block bed) {
-        super(who);
-        this.bed = bed;
-    }
-
-    public boolean isCancelled() {
-        return cancel;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancel = cancel;
-    }
-
-    /**
-     * Returns the bed block involved in this event.
-     *
-     * @return the bed block involved in this event
-     */
-    public Block getBed() {
-        return bed;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/player/PlayerBedLeaveEvent.java b/src/main/java/org/bukkit/event/player/PlayerBedLeaveEvent.java
deleted file mode 100644
index 628ab0b..0000000
--- a/src/main/java/org/bukkit/event/player/PlayerBedLeaveEvent.java
+++ /dev/null
@@ -1,36 +0,0 @@
-package org.bukkit.event.player;
-
-import org.bukkit.block.Block;
-import org.bukkit.entity.Player;
-import org.bukkit.event.HandlerList;
-
-/**
- * This event is fired when the player is leaving a bed.
- */
-public class PlayerBedLeaveEvent extends PlayerEvent {
-    private static final HandlerList handlers = new HandlerList();
-    private final Block bed;
-
-    public PlayerBedLeaveEvent(final Player who, final Block bed) {
-        super(who);
-        this.bed = bed;
-    }
-
-    /**
-     * Returns the bed block involved in this event.
-     *
-     * @return the bed block involved in this event
-     */
-    public Block getBed() {
-        return bed;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/player/PlayerBucketEmptyEvent.java b/src/main/java/org/bukkit/event/player/PlayerBucketEmptyEvent.java
deleted file mode 100644
index 8fb121a..0000000
--- a/src/main/java/org/bukkit/event/player/PlayerBucketEmptyEvent.java
+++ /dev/null
@@ -1,28 +0,0 @@
-package org.bukkit.event.player;
-
-import org.bukkit.Material;
-import org.bukkit.block.Block;
-import org.bukkit.block.BlockFace;
-import org.bukkit.entity.Player;
-import org.bukkit.event.HandlerList;
-import org.bukkit.inventory.ItemStack;
-
-/**
- * Called when a player empties a bucket
- */
-public class PlayerBucketEmptyEvent extends PlayerBucketEvent {
-    private static final HandlerList handlers = new HandlerList();
-
-    public PlayerBucketEmptyEvent(final Player who, final Block blockClicked, final BlockFace blockFace, final Material bucket, final ItemStack itemInHand) {
-        super(who, blockClicked, blockFace, bucket, itemInHand);
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/player/PlayerBucketEvent.java b/src/main/java/org/bukkit/event/player/PlayerBucketEvent.java
deleted file mode 100644
index d32c55e..0000000
--- a/src/main/java/org/bukkit/event/player/PlayerBucketEvent.java
+++ /dev/null
@@ -1,80 +0,0 @@
-package org.bukkit.event.player;
-
-import org.bukkit.Material;
-import org.bukkit.block.Block;
-import org.bukkit.block.BlockFace;
-import org.bukkit.entity.Player;
-import org.bukkit.event.Cancellable;
-import org.bukkit.inventory.ItemStack;
-
-/**
- * Called when a player interacts with a Bucket
- */
-public abstract class PlayerBucketEvent extends PlayerEvent implements Cancellable {
-    private ItemStack itemStack;
-    private boolean cancelled = false;
-    private final Block blockClicked;
-    private final BlockFace blockFace;
-    private final Material bucket;
-
-    public PlayerBucketEvent(final Player who, final Block blockClicked, final BlockFace blockFace, final Material bucket, final ItemStack itemInHand) {
-        super(who);
-        this.blockClicked = blockClicked;
-        this.blockFace = blockFace;
-        this.itemStack = itemInHand;
-        this.bucket = bucket;
-    }
-
-    /**
-     * Returns the bucket used in this event
-     *
-     * @return the used bucket
-     */
-    public Material getBucket() {
-        return bucket;
-    }
-
-    /**
-     * Get the resulting item in hand after the bucket event
-     *
-     * @return Itemstack hold in hand after the event.
-     */
-    public ItemStack getItemStack() {
-        return itemStack;
-    }
-
-    /**
-     * Set the item in hand after the event
-     *
-     * @param itemStack the new held itemstack after the bucket event.
-     */
-    public void setItemStack(ItemStack itemStack) {
-        this.itemStack = itemStack;
-    }
-
-    /**
-     * Return the block clicked
-     *
-     * @return the blicked block
-     */
-    public Block getBlockClicked() {
-        return blockClicked;
-    }
-
-    /**
-     * Get the face on the clicked block
-     *
-     * @return the clicked face
-     */
-    public BlockFace getBlockFace() {
-        return blockFace;
-    }
-
-    public boolean isCancelled() {
-        return cancelled;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancelled = cancel;
-    }
-}
\ No newline at end of file
diff --git a/src/main/java/org/bukkit/event/player/PlayerBucketFillEvent.java b/src/main/java/org/bukkit/event/player/PlayerBucketFillEvent.java
deleted file mode 100644
index 94e042a..0000000
--- a/src/main/java/org/bukkit/event/player/PlayerBucketFillEvent.java
+++ /dev/null
@@ -1,28 +0,0 @@
-package org.bukkit.event.player;
-
-import org.bukkit.Material;
-import org.bukkit.block.Block;
-import org.bukkit.block.BlockFace;
-import org.bukkit.entity.Player;
-import org.bukkit.event.HandlerList;
-import org.bukkit.inventory.ItemStack;
-
-/**
- * Called when a player fills a bucket
- */
-public class PlayerBucketFillEvent extends PlayerBucketEvent {
-    private static final HandlerList handlers = new HandlerList();
-
-    public PlayerBucketFillEvent(final Player who, final Block blockClicked, final BlockFace blockFace, final Material bucket, final ItemStack itemInHand) {
-        super(who, blockClicked, blockFace, bucket, itemInHand);
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/player/PlayerChangedMainHandEvent.java b/src/main/java/org/bukkit/event/player/PlayerChangedMainHandEvent.java
deleted file mode 100644
index 2a15446..0000000
--- a/src/main/java/org/bukkit/event/player/PlayerChangedMainHandEvent.java
+++ /dev/null
@@ -1,39 +0,0 @@
-package org.bukkit.event.player;
-
-import org.bukkit.entity.Player;
-import org.bukkit.event.HandlerList;
-import org.bukkit.inventory.MainHand;
-
-/**
- * Called when a player changes their main hand in the client settings.
- */
-public class PlayerChangedMainHandEvent extends PlayerEvent {
-
-    private static final HandlerList handlers = new HandlerList();
-    //
-    private final MainHand mainHand;
-
-    public PlayerChangedMainHandEvent(Player who, MainHand mainHand) {
-        super(who);
-        this.mainHand = mainHand;
-    }
-
-    /**
-     * Gets the new main hand of the player. The old hand is still momentarily
-     * available via {@link Player#getMainHand()}.
-     *
-     * @return the new {@link MainHand} of the player
-     */
-    public MainHand getMainHand() {
-        return mainHand;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/player/PlayerChangedWorldEvent.java b/src/main/java/org/bukkit/event/player/PlayerChangedWorldEvent.java
deleted file mode 100644
index 76c9c20..0000000
--- a/src/main/java/org/bukkit/event/player/PlayerChangedWorldEvent.java
+++ /dev/null
@@ -1,36 +0,0 @@
-package org.bukkit.event.player;
-
-import org.bukkit.World;
-import org.bukkit.entity.Player;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a player switches to another world.
- */
-public class PlayerChangedWorldEvent extends PlayerEvent {
-    private static final HandlerList handlers = new HandlerList();
-    private final World from;
-
-    public PlayerChangedWorldEvent(final Player player, final World from) {
-        super(player);
-        this.from = from;
-    }
-
-    /**
-     * Gets the world the player is switching from.
-     *
-     * @return  player's previous world
-     */
-    public World getFrom() {
-        return from;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/player/PlayerChannelEvent.java b/src/main/java/org/bukkit/event/player/PlayerChannelEvent.java
deleted file mode 100644
index 054efbc..0000000
--- a/src/main/java/org/bukkit/event/player/PlayerChannelEvent.java
+++ /dev/null
@@ -1,31 +0,0 @@
-package org.bukkit.event.player;
-
-import org.bukkit.entity.Player;
-import org.bukkit.event.HandlerList;
-
-/**
- * This event is called after a player registers or unregisters a new plugin
- * channel.
- */
-public abstract class PlayerChannelEvent extends PlayerEvent {
-    private static final HandlerList handlers = new HandlerList();
-    private final String channel;
-
-    public PlayerChannelEvent(final Player player, final String channel) {
-        super(player);
-        this.channel = channel;
-    }
-
-    public final String getChannel() {
-        return channel;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/player/PlayerChatEvent.java b/src/main/java/org/bukkit/event/player/PlayerChatEvent.java
deleted file mode 100644
index 1fb5cd7..0000000
--- a/src/main/java/org/bukkit/event/player/PlayerChatEvent.java
+++ /dev/null
@@ -1,125 +0,0 @@
-package org.bukkit.event.player;
-
-import java.util.HashSet;
-import java.util.Set;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.Warning;
-import org.bukkit.entity.Player;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Holds information for player chat and commands
- *
- * @deprecated This event will fire from the main thread and allows the use of
- *     all of the Bukkit API, unlike the {@link AsyncPlayerChatEvent}.
- *     <p>
- *     Listening to this event forces chat to wait for the main thread which
- *     causes delays for chat. {@link AsyncPlayerChatEvent} is the encouraged
- *     alternative for thread safe implementations.
- */
-@Deprecated
-@Warning(reason="Listening to this event forces chat to wait for the main thread, delaying chat messages.")
-public class PlayerChatEvent extends PlayerEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private boolean cancel = false;
-    private String message;
-    private String format;
-    private final Set<Player> recipients;
-
-    public PlayerChatEvent(final Player player, final String message) {
-        super(player);
-        this.message = message;
-        this.format = "<%1$s> %2$s";
-        this.recipients = new HashSet<Player>(player.getServer().getOnlinePlayers());
-    }
-
-    public PlayerChatEvent(final Player player, final String message, final String format, final Set<Player> recipients) {
-        super(player);
-        this.message = message;
-        this.format = format;
-        this.recipients = recipients;
-    }
-
-    public boolean isCancelled() {
-        return cancel;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancel = cancel;
-    }
-
-    /**
-     * Gets the message that the player is attempting to send
-     *
-     * @return Message the player is attempting to send
-     */
-    public String getMessage() {
-        return message;
-    }
-
-    /**
-     * Sets the message that the player will send
-     *
-     * @param message New message that the player will send
-     */
-    public void setMessage(String message) {
-        this.message = message;
-    }
-
-    /**
-     * Sets the player that this message will display as, or command will be
-     * executed as
-     *
-     * @param player New player which this event will execute as
-     */
-    public void setPlayer(final Player player) {
-        Validate.notNull(player, "Player cannot be null");
-        this.player = player;
-    }
-
-    /**
-     * Gets the format to use to display this chat message
-     *
-     * @return String.Format compatible format string
-     */
-    public String getFormat() {
-        return format;
-    }
-
-    /**
-     * Sets the format to use to display this chat message
-     *
-     * @param format String.Format compatible format string
-     */
-    public void setFormat(final String format) {
-        // Oh for a better way to do this!
-        try {
-            String.format(format, player, message);
-        } catch (RuntimeException ex) {
-            ex.fillInStackTrace();
-            throw ex;
-        }
-
-        this.format = format;
-    }
-
-    /**
-     * Gets a set of recipients that this chat message will be displayed to
-     *
-     * @return All Players who will see this chat message
-     */
-    public Set<Player> getRecipients() {
-        return recipients;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/player/PlayerChatTabCompleteEvent.java b/src/main/java/org/bukkit/event/player/PlayerChatTabCompleteEvent.java
deleted file mode 100644
index 7241a9b..0000000
--- a/src/main/java/org/bukkit/event/player/PlayerChatTabCompleteEvent.java
+++ /dev/null
@@ -1,70 +0,0 @@
-package org.bukkit.event.player;
-
-import java.util.Collection;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.entity.Player;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a player attempts to tab-complete a chat message.
- */
-public class PlayerChatTabCompleteEvent extends PlayerEvent {
-    private static final HandlerList handlers = new HandlerList();
-    private final String message;
-    private final String lastToken;
-    private final Collection<String> completions;
-
-    public PlayerChatTabCompleteEvent(final Player who, final String message, final Collection<String> completions) {
-        super(who);
-        Validate.notNull(message, "Message cannot be null");
-        Validate.notNull(completions, "Completions cannot be null");
-        this.message = message;
-        int i = message.lastIndexOf(' ');
-        if (i < 0) {
-            this.lastToken = message;
-        } else {
-            this.lastToken = message.substring(i + 1);
-        }
-        this.completions = completions;
-    }
-
-    /**
-     * Gets the chat message being tab-completed.
-     *
-     * @return the chat message
-     */
-    public String getChatMessage() {
-        return message;
-    }
-
-    /**
-     * Gets the last 'token' of the message being tab-completed.
-     * <p>
-     * The token is the substring starting with the character after the last
-     * space in the message.
-     *
-     * @return The last token for the chat message
-     */
-    public String getLastToken() {
-        return lastToken;
-    }
-
-    /**
-     * This is the collection of completions for this event.
-     *
-     * @return the current completions
-     */
-    public Collection<String> getTabCompletions() {
-        return completions;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/player/PlayerCommandPreprocessEvent.java b/src/main/java/org/bukkit/event/player/PlayerCommandPreprocessEvent.java
deleted file mode 100644
index 1ec8173..0000000
--- a/src/main/java/org/bukkit/event/player/PlayerCommandPreprocessEvent.java
+++ /dev/null
@@ -1,172 +0,0 @@
-package org.bukkit.event.player;
-
-import java.util.HashSet;
-import java.util.Set;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.entity.Player;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * This event is called whenever a player runs a command (by placing a slash
- * at the start of their message). It is called early in the command handling
- * process, and modifications in this event (via {@link #setMessage(String)})
- * will be shown in the behavior.
- * <p>
- * Many plugins will have <b>no use for this event</b>, and you should
- * attempt to avoid using it if it is not necessary.
- * <p>
- * Some examples of valid uses for this event are:
- * <ul>
- * <li>Logging executed commands to a separate file
- * <li>Variable substitution. For example, replacing
- *     <code>${nearbyPlayer}</code> with the name of the nearest other
- *     player, or simulating the <code>@a</code> and <code>@p</code>
- *     decorators used by Command Blocks in plugins that do not handle it.
- * <li>Conditionally blocking commands belonging to other plugins. For
- *     example, blocking the use of the <code>/home</code> command in a
- *     combat arena.
- * <li>Per-sender command aliases. For example, after a player runs the
- *     command <code>/calias cr gamemode creative</code>, the next time they
- *     run <code>/cr</code>, it gets replaced into
- *     <code>/gamemode creative</code>. (Global command aliases should be
- *     done by registering the alias.)
- * </ul>
- * <p>
- * Examples of incorrect uses are:
- * <ul>
- * <li>Using this event to run command logic
- * </ul>
- * <p>
- * If the event is cancelled, processing of the command will halt.
- * <p>
- * The state of whether or not there is a slash (<code>/</code>) at the
- * beginning of the message should be preserved. If a slash is added or
- * removed, unexpected behavior may result.
- */
-public class PlayerCommandPreprocessEvent extends PlayerEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private boolean cancel = false;
-    private String message;
-    private String format = "<%1$s> %2$s";
-    private final Set<Player> recipients;
-
-    public PlayerCommandPreprocessEvent(final Player player, final String message) {
-        super(player);
-        this.recipients = new HashSet<Player>(player.getServer().getOnlinePlayers());
-        this.message = message;
-    }
-
-    public PlayerCommandPreprocessEvent(final Player player, final String message, final Set<Player> recipients) {
-        super(player);
-        this.recipients = recipients;
-        this.message = message;
-    }
-
-    public boolean isCancelled() {
-        return cancel;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancel = cancel;
-    }
-
-    /**
-     * Gets the command that the player is attempting to send.
-     * <p>
-     * All commands begin with a special character; implementations do not
-     * consider the first character when executing the content.
-     *
-     * @return Message the player is attempting to send
-     */
-    public String getMessage() {
-        return message;
-    }
-
-    /**
-     * Sets the command that the player will send.
-     * <p>
-     * All commands begin with a special character; implementations do not
-     * consider the first character when executing the content.
-     *
-     * @param command New message that the player will send
-     * @throws IllegalArgumentException if command is null or empty
-     */
-    public void setMessage(String command) throws IllegalArgumentException {
-        Validate.notNull(command, "Command cannot be null");
-        Validate.notEmpty(command, "Command cannot be empty");
-        this.message = command;
-    }
-
-    /**
-     * Sets the player that this command will be executed as.
-     *
-     * @param player New player which this event will execute as
-     * @throws IllegalArgumentException if the player provided is null
-     */
-    public void setPlayer(final Player player) throws IllegalArgumentException {
-        Validate.notNull(player, "Player cannot be null");
-        this.player = player;
-    }
-
-    /**
-     * Gets the format to use to display this chat message
-     *
-     * @deprecated This method is provided for backward compatibility with no
-     *     guarantee to the use of the format.
-     * @return String.Format compatible format string
-     */
-    @Deprecated
-    public String getFormat() {
-        return format;
-    }
-
-    /**
-     * Sets the format to use to display this chat message
-     *
-     * @deprecated This method is provided for backward compatibility with no
-     *     guarantee to the effect of modifying the format.
-     * @param format String.Format compatible format string
-     */
-    @Deprecated
-    public void setFormat(final String format) {
-        // Oh for a better way to do this!
-        try {
-            String.format(format, player, message);
-        } catch (RuntimeException ex) {
-            ex.fillInStackTrace();
-            throw ex;
-        }
-
-        this.format = format;
-    }
-
-    /**
-     * Gets a set of recipients that this chat message will be displayed to.
-     * <p>
-     * The set returned is not guaranteed to be mutable and may auto-populate
-     * on access. Any listener accessing the returned set should be aware that
-     * it may reduce performance for a lazy set implementation. Listeners
-     * should be aware that modifying the list may throw {@link
-     * UnsupportedOperationException} if the event caller provides an
-     * unmodifiable set.
-     *
-     * @deprecated This method is provided for backward compatibility with no
-     *     guarantee to the effect of viewing or modifying the set.
-     * @return All Players who will see this chat message
-     */
-    @Deprecated
-    public Set<Player> getRecipients() {
-        return recipients;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/player/PlayerDropItemEvent.java b/src/main/java/org/bukkit/event/player/PlayerDropItemEvent.java
deleted file mode 100644
index 5b41b65..0000000
--- a/src/main/java/org/bukkit/event/player/PlayerDropItemEvent.java
+++ /dev/null
@@ -1,46 +0,0 @@
-package org.bukkit.event.player;
-
-import org.bukkit.entity.Item;
-import org.bukkit.entity.Player;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Thrown when a player drops an item from their inventory
- */
-public class PlayerDropItemEvent extends PlayerEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private final Item drop;
-    private boolean cancel = false;
-
-    public PlayerDropItemEvent(final Player player, final Item drop) {
-        super(player);
-        this.drop = drop;
-    }
-
-    /**
-     * Gets the ItemDrop created by the player
-     *
-     * @return ItemDrop created by the player
-     */
-    public Item getItemDrop() {
-        return drop;
-    }
-
-    public boolean isCancelled() {
-        return cancel;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancel = cancel;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/player/PlayerEditBookEvent.java b/src/main/java/org/bukkit/event/player/PlayerEditBookEvent.java
deleted file mode 100644
index ea7ecef..0000000
--- a/src/main/java/org/bukkit/event/player/PlayerEditBookEvent.java
+++ /dev/null
@@ -1,124 +0,0 @@
-package org.bukkit.event.player;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.Bukkit;
-import org.bukkit.entity.Player;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-import org.bukkit.inventory.meta.BookMeta;
-
-/**
- * Called when a player edits or signs a book and quill item. If the event is
- * cancelled, no changes are made to the BookMeta
- */
-public class PlayerEditBookEvent extends PlayerEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-
-    private final BookMeta previousBookMeta;
-    private final int slot;
-    private BookMeta newBookMeta;
-    private boolean isSigning;
-    private boolean cancel;
-
-    public PlayerEditBookEvent(Player who, int slot, BookMeta previousBookMeta, BookMeta newBookMeta, boolean isSigning) {
-        super(who);
-
-        Validate.isTrue(slot >= 0 && slot <=8, "Slot must be in range 0-8 inclusive");
-        Validate.notNull(previousBookMeta, "Previous book meta must not be null");
-        Validate.notNull(newBookMeta, "New book meta must not be null");
-
-        Bukkit.getItemFactory().equals(previousBookMeta, newBookMeta);
-
-        this.previousBookMeta = previousBookMeta;
-        this.newBookMeta = newBookMeta;
-        this.slot = slot;
-        this.isSigning = isSigning;
-        this.cancel = false;
-    }
-
-    /**
-     * Gets the book meta currently on the book.
-     * <p>
-     * Note: this is a copy of the book meta. You cannot use this object to
-     * change the existing book meta.
-     *
-     * @return the book meta currently on the book
-     */
-    public BookMeta getPreviousBookMeta() {
-        return previousBookMeta.clone();
-    }
-
-    /**
-     * Gets the book meta that the player is attempting to add to the book.
-     * <p>
-     * Note: this is a copy of the proposed new book meta. Use {@link
-     * #setNewBookMeta(BookMeta)} to change what will actually be added to the
-     * book.
-     *
-     * @return the book meta that the player is attempting to add
-     */
-    public BookMeta getNewBookMeta() {
-        return newBookMeta.clone();
-    }
-
-    /**
-     * Gets the inventory slot number for the book item that triggered this
-     * event.
-     * <p>
-     * This is a slot number on the player's hotbar in the range 0-8.
-     *
-     * @return the inventory slot number that the book item occupies
-     */
-    public int getSlot() {
-        return slot;
-    }
-
-    /**
-     * Sets the book meta that will actually be added to the book.
-     *
-     * @param newBookMeta new book meta
-     * @throws IllegalArgumentException if the new book meta is null
-     */
-    public void setNewBookMeta(BookMeta newBookMeta) throws IllegalArgumentException {
-        Validate.notNull(newBookMeta, "New book meta must not be null");
-        Bukkit.getItemFactory().equals(newBookMeta, null);
-        this.newBookMeta = newBookMeta.clone();
-    }
-
-    /**
-     * Gets whether or not the book is being signed. If a book is signed the
-     * Material changes from BOOK_AND_QUILL to WRITTEN_BOOK.
-     *
-     * @return true if the book is being signed
-     */
-    public boolean isSigning() {
-        return isSigning;
-    }
-
-    /**
-     * Sets whether or not the book is being signed. If a book is signed the
-     * Material changes from BOOK_AND_QUILL to WRITTEN_BOOK.
-     *
-     * @param signing whether or not the book is being signed.
-     */
-    public void setSigning(boolean signing) {
-        isSigning = signing;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-
-    public boolean isCancelled() {
-        return cancel;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancel = cancel;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/player/PlayerEggThrowEvent.java b/src/main/java/org/bukkit/event/player/PlayerEggThrowEvent.java
deleted file mode 100644
index 4b5075b..0000000
--- a/src/main/java/org/bukkit/event/player/PlayerEggThrowEvent.java
+++ /dev/null
@@ -1,109 +0,0 @@
-package org.bukkit.event.player;
-
-import org.bukkit.entity.Egg;
-import org.bukkit.entity.EntityType;
-import org.bukkit.entity.Player;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a player throws an egg and it might hatch
- */
-public class PlayerEggThrowEvent extends PlayerEvent {
-    private static final HandlerList handlers = new HandlerList();
-    private final Egg egg;
-    private boolean hatching;
-    private EntityType hatchType;
-    private byte numHatches;
-
-    public PlayerEggThrowEvent(final Player player, final Egg egg, final boolean hatching, final byte numHatches, final EntityType hatchingType) {
-        super(player);
-        this.egg = egg;
-        this.hatching = hatching;
-        this.numHatches = numHatches;
-        this.hatchType = hatchingType;
-    }
-
-    /**
-     * Gets the egg involved in this event.
-     *
-     * @return the egg involved in this event
-     */
-    public Egg getEgg() {
-        return egg;
-    }
-
-    /**
-     * Gets whether the egg is hatching or not. Will be what the server
-     * would've done without interaction.
-     *
-     * @return boolean Whether the egg is going to hatch or not
-     */
-    public boolean isHatching() {
-        return hatching;
-    }
-
-    /**
-     * Sets whether the egg will hatch or not.
-     *
-     * @param hatching true if you want the egg to hatch, false if you want it
-     *     not to
-     */
-    public void setHatching(boolean hatching) {
-        this.hatching = hatching;
-    }
-
-    /**
-     * Get the type of the mob being hatched (EntityType.CHICKEN by default)
-     *
-     * @return The type of the mob being hatched by the egg
-     */
-    public EntityType getHatchingType() {
-        return hatchType;
-    }
-
-    /**
-     * Change the type of mob being hatched by the egg
-     *
-     * @param hatchType The type of the mob being hatched by the egg
-     */
-    public void setHatchingType(EntityType hatchType) {
-        if(!hatchType.isSpawnable()) throw new IllegalArgumentException("Can't spawn that entity type from an egg!");
-        this.hatchType = hatchType;
-    }
-
-    /**
-     * Get the number of mob hatches from the egg. By default the number will
-     * be the number the server would've done
-     * <ul>
-     * <li>7/8 chance of being 0
-     * <li>31/256 ~= 1/8 chance to be 1
-     * <li>1/256 chance to be 4
-     * </ul>
-     *
-     * @return The number of mobs going to be hatched by the egg
-     */
-    public byte getNumHatches() {
-        return numHatches;
-    }
-
-    /**
-     * Change the number of mobs coming out of the hatched egg
-     * <p>
-     * The boolean hatching will override this number. Ie. If hatching =
-     * false, this number will not matter
-     *
-     * @param numHatches The number of mobs coming out of the egg
-     */
-    public void setNumHatches(byte numHatches) {
-        this.numHatches = numHatches;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/player/PlayerEvent.java b/src/main/java/org/bukkit/event/player/PlayerEvent.java
deleted file mode 100644
index 0d4833f..0000000
--- a/src/main/java/org/bukkit/event/player/PlayerEvent.java
+++ /dev/null
@@ -1,30 +0,0 @@
-package org.bukkit.event.player;
-
-import org.bukkit.entity.Player;
-import org.bukkit.event.Event;
-
-/**
- * Represents a player related event
- */
-public abstract class PlayerEvent extends Event {
-    protected Player player;
-
-    public PlayerEvent(final Player who) {
-        player = who;
-    }
-
-    PlayerEvent(final Player who, boolean async) {
-        super(async);
-        player = who;
-
-    }
-
-    /**
-     * Returns the player involved in this event
-     *
-     * @return Player who is involved in this event
-     */
-    public final Player getPlayer() {
-        return player;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/player/PlayerExpChangeEvent.java b/src/main/java/org/bukkit/event/player/PlayerExpChangeEvent.java
deleted file mode 100644
index f37491d..0000000
--- a/src/main/java/org/bukkit/event/player/PlayerExpChangeEvent.java
+++ /dev/null
@@ -1,44 +0,0 @@
-package org.bukkit.event.player;
-
-import org.bukkit.entity.Player;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a players experience changes naturally
- */
-public class PlayerExpChangeEvent extends PlayerEvent {
-    private static final HandlerList handlers = new HandlerList();
-    private int exp;
-
-    public PlayerExpChangeEvent(final Player player, final int expAmount) {
-         super(player);
-         exp = expAmount;
-    }
-
-    /**
-     * Get the amount of experience the player will receive
-     *
-     * @return The amount of experience
-     */
-    public int getAmount() {
-        return exp;
-    }
-
-    /**
-     * Set the amount of experience the player will receive
-     *
-     * @param amount The amount of experience to set
-     */
-    public void setAmount(int amount) {
-        exp = amount;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/player/PlayerFishEvent.java b/src/main/java/org/bukkit/event/player/PlayerFishEvent.java
deleted file mode 100644
index 4d6b29a..0000000
--- a/src/main/java/org/bukkit/event/player/PlayerFishEvent.java
+++ /dev/null
@@ -1,142 +0,0 @@
-package org.bukkit.event.player;
-
-import org.bukkit.entity.Fish;
-import org.bukkit.entity.Player;
-import org.bukkit.event.Cancellable;
-import org.bukkit.entity.Entity;
-import org.bukkit.event.HandlerList;
-
-/**
- * Thrown when a player is fishing
- */
-public class PlayerFishEvent extends PlayerEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private final Entity entity;
-    private boolean cancel = false;
-    private int exp;
-    private final State state;
-    private final Fish hookEntity;
-
-    /**
-     * @deprecated replaced by {@link #PlayerFishEvent(Player, Entity, Fish,
-     *     State)} to include the {@link Fish} hook entity.
-     * @param player the player fishing
-     * @param entity the caught entity
-     * @param state the state of fishing
-     */
-    @Deprecated
-    public PlayerFishEvent(final Player player, final Entity entity, final State state) {
-        this(player, entity, null, state);
-    }
-
-    public PlayerFishEvent(final Player player, final Entity entity, final Fish hookEntity, final State state) {
-        super(player);
-        this.entity = entity;
-        this.hookEntity = hookEntity;
-        this.state = state;
-    }
-
-    /**
-     * Gets the entity caught by the player.
-     * <p>
-     * If player has fished successfully, the result may be cast to {@link
-     * org.bukkit.entity.Item}.
-     *
-     * @return Entity caught by the player, Entity if fishing, and null if
-     *     bobber has gotten stuck in the ground or nothing has been caught
-     */
-    public Entity getCaught() {
-        return entity;
-    }
-
-    /**
-     * Gets the fishing hook.
-     *
-     * @return Fish the entity representing the fishing hook/bobber.
-     */
-    public Fish getHook() {
-        return hookEntity;
-    }
-
-    public boolean isCancelled() {
-        return cancel;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancel = cancel;
-    }
-
-    /**
-     * Gets the amount of experience received when fishing.
-     * <p>
-     * Note: This value has no default effect unless the event state is {@link
-     * State#CAUGHT_FISH}.
-     *
-     * @return the amount of experience to drop
-     */
-    public int getExpToDrop() {
-        return exp;
-    }
-
-    /**
-     * Sets the amount of experience received when fishing.
-     * <p>
-     * Note: This value has no default effect unless the event state is {@link
-     * State#CAUGHT_FISH}.
-     *
-     * @param amount the amount of experience to drop
-     */
-    public void setExpToDrop(int amount) {
-        exp = amount;
-    }
-
-    /**
-     * Gets the state of the fishing
-     *
-     * @return A State detailing the state of the fishing
-     */
-    public State getState() {
-        return state;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-
-    /**
-     * An enum to specify the state of the fishing
-     */
-    public enum State {
-
-        /**
-         * When a player is fishing, ie casting the line out.
-         */
-        FISHING,
-        /**
-         * When a player has successfully caught a fish and is reeling it in.
-         */
-        CAUGHT_FISH,
-        /**
-         * When a player has successfully caught an entity
-         */
-        CAUGHT_ENTITY,
-        /**
-         * When a bobber is stuck in the ground
-         */
-        IN_GROUND,
-        /**
-         * When a player fails to catch anything while fishing usually due to
-         * poor aiming or timing
-         */
-        FAILED_ATTEMPT,
-        /**
-         * Called when there is a bite on the hook and it is ready to be reeled in.
-         */
-        BITE
-    }
-}
diff --git a/src/main/java/org/bukkit/event/player/PlayerGameModeChangeEvent.java b/src/main/java/org/bukkit/event/player/PlayerGameModeChangeEvent.java
deleted file mode 100644
index 8c9afa8..0000000
--- a/src/main/java/org/bukkit/event/player/PlayerGameModeChangeEvent.java
+++ /dev/null
@@ -1,46 +0,0 @@
-package org.bukkit.event.player;
-
-import org.bukkit.GameMode;
-import org.bukkit.entity.Player;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when the GameMode of the player is changed.
- */
-public class PlayerGameModeChangeEvent extends PlayerEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private boolean cancelled;
-    private final GameMode newGameMode;
-
-    public PlayerGameModeChangeEvent(final Player player, final GameMode newGameMode) {
-        super(player);
-        this.newGameMode = newGameMode;
-    }
-
-    public boolean isCancelled() {
-        return cancelled;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancelled = cancel;
-    }
-
-    /**
-     * Gets the GameMode the player is switched to.
-     *
-     * @return  player's new GameMode
-     */
-    public GameMode getNewGameMode() {
-        return newGameMode;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/player/PlayerInteractAtEntityEvent.java b/src/main/java/org/bukkit/event/player/PlayerInteractAtEntityEvent.java
deleted file mode 100644
index 15f9624..0000000
--- a/src/main/java/org/bukkit/event/player/PlayerInteractAtEntityEvent.java
+++ /dev/null
@@ -1,38 +0,0 @@
-package org.bukkit.event.player;
-
-import org.bukkit.entity.Entity;
-import org.bukkit.entity.Player;
-import org.bukkit.event.HandlerList;
-import org.bukkit.inventory.EquipmentSlot;
-import org.bukkit.util.Vector;
-
-/**
- * Represents an event that is called when a player right clicks an entity
- * with a location on the entity the was clicked.
- */
-public class PlayerInteractAtEntityEvent extends PlayerInteractEntityEvent {
-    private static final HandlerList handlers = new HandlerList();
-    private final Vector position;
-
-    public PlayerInteractAtEntityEvent(Player who, Entity clickedEntity, Vector position) {
-        this(who, clickedEntity, position, EquipmentSlot.HAND);
-    }
-
-    public PlayerInteractAtEntityEvent(Player who, Entity clickedEntity, Vector position, EquipmentSlot hand) {
-        super(who, clickedEntity, hand);
-        this.position = position;
-    }
-
-    public Vector getClickedPosition() {
-        return position.clone();
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/player/PlayerInteractEntityEvent.java b/src/main/java/org/bukkit/event/player/PlayerInteractEntityEvent.java
deleted file mode 100644
index 9460957..0000000
--- a/src/main/java/org/bukkit/event/player/PlayerInteractEntityEvent.java
+++ /dev/null
@@ -1,62 +0,0 @@
-package org.bukkit.event.player;
-
-import org.bukkit.entity.Entity;
-import org.bukkit.entity.Player;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-import org.bukkit.inventory.EquipmentSlot;
-
-/**
- * Represents an event that is called when a player right clicks an entity.
- */
-public class PlayerInteractEntityEvent extends PlayerEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    protected Entity clickedEntity;
-    boolean cancelled = false;
-    private EquipmentSlot hand;
-
-    public PlayerInteractEntityEvent(final Player who, final Entity clickedEntity) {
-        this(who, clickedEntity, EquipmentSlot.HAND);
-    }
-
-    public PlayerInteractEntityEvent(final Player who, final Entity clickedEntity, final EquipmentSlot hand) {
-        super(who);
-        this.clickedEntity = clickedEntity;
-        this.hand = hand;
-    }
-
-    public boolean isCancelled() {
-        return cancelled;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancelled = cancel;
-    }
-
-    /**
-     * Gets the entity that was rightclicked by the player.
-     *
-     * @return entity right clicked by player
-     */
-    public Entity getRightClicked() {
-        return this.clickedEntity;
-    }
-
-    /**
-     * The hand used to perform this interaction.
-     *
-     * @return the hand used to interact
-     */
-    public EquipmentSlot getHand() {
-        return hand;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/player/PlayerInteractEvent.java b/src/main/java/org/bukkit/event/player/PlayerInteractEvent.java
deleted file mode 100644
index 818b481..0000000
--- a/src/main/java/org/bukkit/event/player/PlayerInteractEvent.java
+++ /dev/null
@@ -1,207 +0,0 @@
-package org.bukkit.event.player;
-
-import org.bukkit.block.Block;
-import org.bukkit.block.BlockFace;
-import org.bukkit.event.HandlerList;
-import org.bukkit.inventory.ItemStack;
-import org.bukkit.Material;
-import org.bukkit.entity.Player;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.block.Action;
-import org.bukkit.inventory.EquipmentSlot;
-
-/**
- * Called when a player interacts with an object or air.
- * <p>
- * This event will fire as cancelled if the vanilla behavior
- * is to do nothing (e.g interacting with air)
- */
-public class PlayerInteractEvent extends PlayerEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    protected ItemStack item;
-    protected Action action;
-    protected Block blockClicked;
-    protected BlockFace blockFace;
-    private Result useClickedBlock;
-    private Result useItemInHand;
-    private EquipmentSlot hand;
-
-    public PlayerInteractEvent(final Player who, final Action action, final ItemStack item, final Block clickedBlock, final BlockFace clickedFace) {
-        this(who, action, item, clickedBlock, clickedFace, EquipmentSlot.HAND);
-    }
-
-    public PlayerInteractEvent(final Player who, final Action action, final ItemStack item, final Block clickedBlock, final BlockFace clickedFace, final EquipmentSlot hand) {
-        super(who);
-        this.action = action;
-        this.item = item;
-        this.blockClicked = clickedBlock;
-        this.blockFace = clickedFace;
-        this.hand = hand;
-
-        useItemInHand = Result.DEFAULT;
-        useClickedBlock = clickedBlock == null ? Result.DENY : Result.ALLOW;
-    }
-
-    /**
-     * Returns the action type
-     *
-     * @return Action returns the type of interaction
-     */
-    public Action getAction() {
-        return action;
-    }
-
-    /**
-     * Gets the cancellation state of this event. Set to true if you want to
-     * prevent buckets from placing water and so forth
-     *
-     * @return boolean cancellation state
-     */
-    public boolean isCancelled() {
-        return useInteractedBlock() == Result.DENY;
-    }
-
-    /**
-     * Sets the cancellation state of this event. A canceled event will not be
-     * executed in the server, but will still pass to other plugins
-     * <p>
-     * Canceling this event will prevent use of food (player won't lose the
-     * food item), prevent bows/snowballs/eggs from firing, etc. (player won't
-     * lose the ammo)
-     *
-     * @param cancel true if you wish to cancel this event
-     */
-    public void setCancelled(boolean cancel) {
-        setUseInteractedBlock(cancel ? Result.DENY : useInteractedBlock() == Result.DENY ? Result.DEFAULT : useInteractedBlock());
-        setUseItemInHand(cancel ? Result.DENY : useItemInHand() == Result.DENY ? Result.DEFAULT : useItemInHand());
-    }
-
-    /**
-     * Returns the item in hand represented by this event
-     *
-     * @return ItemStack the item used
-     */
-    public ItemStack getItem() {
-        return this.item;
-    }
-
-    /**
-     * Convenience method. Returns the material of the item represented by
-     * this event
-     *
-     * @return Material the material of the item used
-     */
-    public Material getMaterial() {
-        if (!hasItem()) {
-            return Material.AIR;
-        }
-
-        return item.getType();
-    }
-
-    /**
-     * Check if this event involved a block
-     *
-     * @return boolean true if it did
-     */
-    public boolean hasBlock() {
-        return this.blockClicked != null;
-    }
-
-    /**
-     * Check if this event involved an item
-     *
-     * @return boolean true if it did
-     */
-    public boolean hasItem() {
-        return this.item != null;
-    }
-
-    /**
-     * Convenience method to inform the user whether this was a block
-     * placement event.
-     *
-     * @return boolean true if the item in hand was a block
-     */
-    public boolean isBlockInHand() {
-        if (!hasItem()) {
-            return false;
-        }
-
-        return item.getType().isBlock();
-    }
-
-    /**
-     * Returns the clicked block
-     *
-     * @return Block returns the block clicked with this item.
-     */
-    public Block getClickedBlock() {
-        return blockClicked;
-    }
-
-    /**
-     * Returns the face of the block that was clicked
-     *
-     * @return BlockFace returns the face of the block that was clicked
-     */
-    public BlockFace getBlockFace() {
-        return blockFace;
-    }
-
-    /**
-     * This controls the action to take with the block (if any) that was
-     * clicked on. This event gets processed for all blocks, but most don't
-     * have a default action
-     *
-     * @return the action to take with the interacted block
-     */
-    public Result useInteractedBlock() {
-        return useClickedBlock;
-    }
-
-    /**
-     * @param useInteractedBlock the action to take with the interacted block
-     */
-    public void setUseInteractedBlock(Result useInteractedBlock) {
-        this.useClickedBlock = useInteractedBlock;
-    }
-
-    /**
-     * This controls the action to take with the item the player is holding.
-     * This includes both blocks and items (such as flint and steel or
-     * records). When this is set to default, it will be allowed if no action
-     * is taken on the interacted block.
-     *
-     * @return the action to take with the item in hand
-     */
-    public Result useItemInHand() {
-        return useItemInHand;
-    }
-
-    /**
-     * @param useItemInHand the action to take with the item in hand
-     */
-    public void setUseItemInHand(Result useItemInHand) {
-        this.useItemInHand = useItemInHand;
-    }
-
-    /**
-     * The hand used to perform this interaction. May be null in the case of
-     * {@link Action#PHYSICAL}.
-     *
-     * @return the hand used to interact. May be null.
-     */
-    public EquipmentSlot getHand() {
-        return hand;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/player/PlayerInventoryEvent.java b/src/main/java/org/bukkit/event/player/PlayerInventoryEvent.java
deleted file mode 100644
index 2ec69d7..0000000
--- a/src/main/java/org/bukkit/event/player/PlayerInventoryEvent.java
+++ /dev/null
@@ -1,44 +0,0 @@
-package org.bukkit.event.player;
-
-import org.bukkit.entity.Player;
-import org.bukkit.event.HandlerList;
-import org.bukkit.event.inventory.InventoryClickEvent;
-import org.bukkit.event.inventory.InventoryOpenEvent;
-import org.bukkit.inventory.Inventory;
-
-/**
- * Represents a player related inventory event; note that this event never
- * actually did anything
- *
- * @deprecated Use {@link InventoryClickEvent} or {@link InventoryOpenEvent}
- *     instead, or one of the other inventory events in {@link
- *     org.bukkit.event.inventory}.
- */
-@Deprecated
-public class PlayerInventoryEvent extends PlayerEvent {
-    private static final HandlerList handlers = new HandlerList();
-    protected Inventory inventory;
-
-    public PlayerInventoryEvent(final Player player, final Inventory inventory) {
-        super(player);
-        this.inventory = inventory;
-    }
-
-    /**
-     * Gets the Inventory involved in this event
-     *
-     * @return Inventory
-     */
-    public Inventory getInventory() {
-        return inventory;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/player/PlayerItemBreakEvent.java b/src/main/java/org/bukkit/event/player/PlayerItemBreakEvent.java
deleted file mode 100644
index 176cd91..0000000
--- a/src/main/java/org/bukkit/event/player/PlayerItemBreakEvent.java
+++ /dev/null
@@ -1,39 +0,0 @@
-package org.bukkit.event.player;
-
-import org.bukkit.entity.Player;
-import org.bukkit.event.HandlerList;
-import org.bukkit.inventory.ItemStack;
-
-/**
- * Fired when a player's item breaks (such as a shovel or flint and steel).
- * <p>
- * The item that's breaking will exist in the inventory with a stack size of
- * 0. After the event, the item's durability will be reset to 0.
- */
-public class PlayerItemBreakEvent extends PlayerEvent {
-    private static final HandlerList handlers = new HandlerList();
-    private final ItemStack brokenItem;
-
-    public PlayerItemBreakEvent(final Player player, final ItemStack brokenItem) {
-        super(player);
-        this.brokenItem = brokenItem;
-    }
-
-    /**
-     * Gets the item that broke
-     *
-     * @return The broken item
-     */
-    public ItemStack getBrokenItem() {
-        return brokenItem;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/player/PlayerItemConsumeEvent.java b/src/main/java/org/bukkit/event/player/PlayerItemConsumeEvent.java
deleted file mode 100644
index 8ab76b1..0000000
--- a/src/main/java/org/bukkit/event/player/PlayerItemConsumeEvent.java
+++ /dev/null
@@ -1,74 +0,0 @@
-package org.bukkit.event.player;
-
-import org.bukkit.Material;
-import org.bukkit.entity.Player;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-import org.bukkit.inventory.ItemStack;
-
-/**
- * This event will fire when a player is finishing consuming an item (food,
- * potion, milk bucket).
- * <br>
- * If the ItemStack is modified the server will use the effects of the new
- * item and not remove the original one from the player's inventory.
- * <br>
- * If the event is cancelled the effect will not be applied and the item will
- * not be removed from the player's inventory.
- */
-public class PlayerItemConsumeEvent extends PlayerEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private boolean isCancelled = false;
-    private ItemStack item;
-
-    /**
-     * @param player the player consuming
-     * @param item the ItemStack being consumed
-     */
-    public PlayerItemConsumeEvent(final Player player, final ItemStack item) {
-        super(player);
-
-        this.item = item;
-    }
-
-    /**
-     * Gets the item that is being consumed. Modifying the returned item will
-     * have no effect, you must use {@link
-     * #setItem(org.bukkit.inventory.ItemStack)} instead.
-     *
-     * @return an ItemStack for the item being consumed
-     */
-    public ItemStack getItem() {
-        return item.clone();
-    }
-
-    /**
-     * Set the item being consumed
-     *
-     * @param item the item being consumed
-     */
-    public void setItem(ItemStack item) {
-        if (item == null) {
-            this.item = new ItemStack(Material.AIR);
-        } else {
-            this.item = item;
-        }
-    }
-
-    public boolean isCancelled() {
-        return this.isCancelled;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.isCancelled = cancel;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/player/PlayerItemHeldEvent.java b/src/main/java/org/bukkit/event/player/PlayerItemHeldEvent.java
deleted file mode 100644
index f0d055a..0000000
--- a/src/main/java/org/bukkit/event/player/PlayerItemHeldEvent.java
+++ /dev/null
@@ -1,56 +0,0 @@
-package org.bukkit.event.player;
-
-import org.bukkit.entity.Player;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Fired when a player changes their currently held item
- */
-public class PlayerItemHeldEvent extends PlayerEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private boolean cancel = false;
-    private final int previous;
-    private final int current;
-
-    public PlayerItemHeldEvent(final Player player, final int previous, final int current) {
-        super(player);
-        this.previous = previous;
-        this.current = current;
-    }
-
-    /**
-     * Gets the previous held slot index
-     *
-     * @return Previous slot index
-     */
-    public int getPreviousSlot() {
-        return previous;
-    }
-
-    /**
-     * Gets the new held slot index
-     *
-     * @return New slot index
-     */
-    public int getNewSlot() {
-        return current;
-    }
-
-    public boolean isCancelled() {
-        return cancel;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancel = cancel;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/player/PlayerJoinEvent.java b/src/main/java/org/bukkit/event/player/PlayerJoinEvent.java
deleted file mode 100644
index e7481f9..0000000
--- a/src/main/java/org/bukkit/event/player/PlayerJoinEvent.java
+++ /dev/null
@@ -1,44 +0,0 @@
-package org.bukkit.event.player;
-
-import org.bukkit.entity.Player;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a player joins a server
- */
-public class PlayerJoinEvent extends PlayerEvent {
-    private static final HandlerList handlers = new HandlerList();
-    private String joinMessage;
-
-    public PlayerJoinEvent(final Player playerJoined, final String joinMessage) {
-        super(playerJoined);
-        this.joinMessage = joinMessage;
-    }
-
-    /**
-     * Gets the join message to send to all online players
-     *
-     * @return string join message
-     */
-    public String getJoinMessage() {
-        return joinMessage;
-    }
-
-    /**
-     * Sets the join message to send to all online players
-     *
-     * @param joinMessage join message
-     */
-    public void setJoinMessage(String joinMessage) {
-        this.joinMessage = joinMessage;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/player/PlayerKickEvent.java b/src/main/java/org/bukkit/event/player/PlayerKickEvent.java
deleted file mode 100644
index 39e81b6..0000000
--- a/src/main/java/org/bukkit/event/player/PlayerKickEvent.java
+++ /dev/null
@@ -1,75 +0,0 @@
-package org.bukkit.event.player;
-
-import org.bukkit.entity.Player;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a player gets kicked from the server
- */
-public class PlayerKickEvent extends PlayerEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private String leaveMessage;
-    private String kickReason;
-    private Boolean cancel;
-
-    public PlayerKickEvent(final Player playerKicked, final String kickReason, final String leaveMessage) {
-        super(playerKicked);
-        this.kickReason = kickReason;
-        this.leaveMessage = leaveMessage;
-        this.cancel = false;
-    }
-
-    /**
-     * Gets the reason why the player is getting kicked
-     *
-     * @return string kick reason
-     */
-    public String getReason() {
-        return kickReason;
-    }
-
-    /**
-     * Gets the leave message send to all online players
-     *
-     * @return string kick reason
-     */
-    public String getLeaveMessage() {
-        return leaveMessage;
-    }
-
-    public boolean isCancelled() {
-        return cancel;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancel = cancel;
-    }
-
-    /**
-     * Sets the reason why the player is getting kicked
-     *
-     * @param kickReason kick reason
-     */
-    public void setReason(String kickReason) {
-        this.kickReason = kickReason;
-    }
-
-    /**
-     * Sets the leave message send to all online players
-     *
-     * @param leaveMessage leave message
-     */
-    public void setLeaveMessage(String leaveMessage) {
-        this.leaveMessage = leaveMessage;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/player/PlayerLevelChangeEvent.java b/src/main/java/org/bukkit/event/player/PlayerLevelChangeEvent.java
deleted file mode 100644
index 730a776..0000000
--- a/src/main/java/org/bukkit/event/player/PlayerLevelChangeEvent.java
+++ /dev/null
@@ -1,46 +0,0 @@
-package org.bukkit.event.player;
-
-import org.bukkit.entity.Player;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a players level changes
- */
-public class PlayerLevelChangeEvent extends PlayerEvent {
-    private static final HandlerList handlers = new HandlerList();
-    private final int oldLevel;
-    private final int newLevel;
-
-    public PlayerLevelChangeEvent(final Player player, final int oldLevel, final int newLevel) {
-         super(player);
-         this.oldLevel = oldLevel;
-         this.newLevel = newLevel;
-    }
-
-    /**
-     * Gets the old level of the player
-     *
-     * @return The old level of the player
-     */
-    public int getOldLevel() {
-        return oldLevel;
-    }
-
-    /**
-     * Gets the new level of the player
-     *
-     * @return The new (current) level of the player
-     */
-    public int getNewLevel() {
-        return newLevel;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/player/PlayerLoginEvent.java b/src/main/java/org/bukkit/event/player/PlayerLoginEvent.java
deleted file mode 100644
index 68834dd..0000000
--- a/src/main/java/org/bukkit/event/player/PlayerLoginEvent.java
+++ /dev/null
@@ -1,194 +0,0 @@
-package org.bukkit.event.player;
-
-import java.net.InetAddress;
-
-import org.bukkit.entity.Player;
-import org.bukkit.event.HandlerList;
-
-/**
- * Stores details for players attempting to log in
- */
-public class PlayerLoginEvent extends PlayerEvent {
-    private static final HandlerList handlers = new HandlerList();
-    private final InetAddress address;
-    private final String hostname;
-    private Result result = Result.ALLOWED;
-    private String message = "";
-
-    /**
-     * @deprecated Address should be provided in other constructor
-     * @param player The {@link Player} for this event
-     */
-    @Deprecated
-    public PlayerLoginEvent(final Player player) {
-        this(player, "", null);
-    }
-
-    /**
-     * @deprecated Address should be provided in other constructor
-     * @param player The {@link Player} for this event
-     * @param hostname The hostname that was used to connect to the server
-     */
-    @Deprecated
-    public PlayerLoginEvent(final Player player, final String hostname) {
-        this(player, hostname, null);
-    }
-
-    /**
-     * This constructor defaults message to an empty string, and result to
-     * ALLOWED
-     *
-     * @param player The {@link Player} for this event
-     * @param hostname The hostname that was used to connect to the server
-     * @param address The address the player used to connect, provided for
-     *     timing issues
-     */
-    public PlayerLoginEvent(final Player player, final String hostname, final InetAddress address) {
-        super(player);
-        this.hostname = hostname;
-        this.address = address;
-    }
-
-    /**
-     * @deprecated Address and hostname should be provided in other
-     *     constructor
-     * @param player The {@link Player} for this event
-     * @param result The result status for this event
-     * @param message The message to be displayed if result denies login
-     */
-    @Deprecated
-    public PlayerLoginEvent(final Player player, final Result result, final String message) {
-        this(player, "", null, result, message);
-    }
-
-    /**
-     * This constructor pre-configures the event with a result and message
-     *
-     * @param player The {@link Player} for this event
-     * @param hostname The hostname that was used to connect to the server
-     * @param address The address the player used to connect, provided for
-     *     timing issues
-     * @param result The result status for this event
-     * @param message The message to be displayed if result denies login
-     */
-    public PlayerLoginEvent(final Player player, String hostname, final InetAddress address, final Result result, final String message) {
-        this(player, hostname, address);
-        this.result = result;
-        this.message = message;
-    }
-
-    /**
-     * Gets the current result of the login, as an enum
-     *
-     * @return Current Result of the login
-     */
-    public Result getResult() {
-        return result;
-    }
-
-    /**
-     * Sets the new result of the login, as an enum
-     *
-     * @param result New result to set
-     */
-    public void setResult(final Result result) {
-        this.result = result;
-    }
-
-    /**
-     * Gets the current kick message that will be used if getResult() !=
-     * Result.ALLOWED
-     *
-     * @return Current kick message
-     */
-    public String getKickMessage() {
-        return message;
-    }
-
-    /**
-     * Sets the kick message to display if getResult() != Result.ALLOWED
-     *
-     * @param message New kick message
-     */
-    public void setKickMessage(final String message) {
-        this.message = message;
-    }
-
-    /**
-     * Gets the hostname that the player used to connect to the server, or
-     * blank if unknown
-     *
-     * @return The hostname
-     */
-    public String getHostname() {
-        return hostname;
-    }
-
-    /**
-     * Allows the player to log in
-     */
-    public void allow() {
-        result = Result.ALLOWED;
-        message = "";
-    }
-
-    /**
-     * Disallows the player from logging in, with the given reason
-     *
-     * @param result New result for disallowing the player
-     * @param message Kick message to display to the user
-     */
-    public void disallow(final Result result, final String message) {
-        this.result = result;
-        this.message = message;
-    }
-
-    /**
-     * Gets the {@link InetAddress} for the Player associated with this event.
-     * This method is provided as a workaround for player.getAddress()
-     * returning null during PlayerLoginEvent.
-     *
-     * @return The address for this player. For legacy compatibility, this may
-     *     be null.
-     */
-    public InetAddress getAddress() {
-        return address;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-
-    /**
-     * Basic kick reasons for communicating to plugins
-     */
-    public enum Result {
-
-        /**
-         * The player is allowed to log in
-         */
-        ALLOWED,
-        /**
-         * The player is not allowed to log in, due to the server being full
-         */
-        KICK_FULL,
-        /**
-         * The player is not allowed to log in, due to them being banned
-         */
-        KICK_BANNED,
-        /**
-         * The player is not allowed to log in, due to them not being on the
-         * white list
-         */
-        KICK_WHITELIST,
-        /**
-         * The player is not allowed to log in, for reasons undefined
-         */
-        KICK_OTHER
-    }
-}
diff --git a/src/main/java/org/bukkit/event/player/PlayerMoveEvent.java b/src/main/java/org/bukkit/event/player/PlayerMoveEvent.java
deleted file mode 100644
index d56b7e4..0000000
--- a/src/main/java/org/bukkit/event/player/PlayerMoveEvent.java
+++ /dev/null
@@ -1,103 +0,0 @@
-package org.bukkit.event.player;
-
-import com.google.common.base.Preconditions;
-import org.bukkit.Location;
-import org.bukkit.entity.Player;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Holds information for player movement events
- */
-public class PlayerMoveEvent extends PlayerEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private boolean cancel = false;
-    private Location from;
-    private Location to;
-
-    public PlayerMoveEvent(final Player player, final Location from, final Location to) {
-        super(player);
-        this.from = from;
-        this.to = to;
-    }
-
-    /**
-     * Gets the cancellation state of this event. A cancelled event will not
-     * be executed in the server, but will still pass to other plugins
-     * <p>
-     * If a move or teleport event is cancelled, the player will be moved or
-     * teleported back to the Location as defined by getFrom(). This will not
-     * fire an event
-     *
-     * @return true if this event is cancelled
-     */
-    public boolean isCancelled() {
-        return cancel;
-    }
-
-    /**
-     * Sets the cancellation state of this event. A cancelled event will not
-     * be executed in the server, but will still pass to other plugins
-     * <p>
-     * If a move or teleport event is cancelled, the player will be moved or
-     * teleported back to the Location as defined by getFrom(). This will not
-     * fire an event
-     *
-     * @param cancel true if you wish to cancel this event
-     */
-    public void setCancelled(boolean cancel) {
-        this.cancel = cancel;
-    }
-
-    /**
-     * Gets the location this player moved from
-     *
-     * @return Location the player moved from
-     */
-    public Location getFrom() {
-        return from;
-    }
-
-    /**
-     * Sets the location to mark as where the player moved from
-     *
-     * @param from New location to mark as the players previous location
-     */
-    public void setFrom(Location from) {
-        validateLocation(from);
-        this.from = from;
-    }
-
-    /**
-     * Gets the location this player moved to
-     *
-     * @return Location the player moved to
-     */
-    public Location getTo() {
-        return to;
-    }
-
-    /**
-     * Sets the location that this player will move to
-     *
-     * @param to New Location this player will move to
-     */
-    public void setTo(Location to) {
-        validateLocation(to);
-        this.to = to;
-    }
-
-    private void validateLocation(Location loc) {
-        Preconditions.checkArgument(loc != null, "Cannot use null location!");
-        Preconditions.checkArgument(loc.getWorld() != null, "Cannot use null location with null world!");
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/player/PlayerPickupArrowEvent.java b/src/main/java/org/bukkit/event/player/PlayerPickupArrowEvent.java
deleted file mode 100644
index 97399ed..0000000
--- a/src/main/java/org/bukkit/event/player/PlayerPickupArrowEvent.java
+++ /dev/null
@@ -1,27 +0,0 @@
-package org.bukkit.event.player;
-
-import org.bukkit.entity.Arrow;
-import org.bukkit.entity.Item;
-import org.bukkit.entity.Player;
-
-/**
- * Thrown when a player picks up an arrow from the ground.
- */
-public class PlayerPickupArrowEvent extends PlayerPickupItemEvent {
-
-    private final Arrow arrow;
-
-    public PlayerPickupArrowEvent(final Player player, final Item item, final Arrow arrow) {
-        super(player, item, 0);
-        this.arrow = arrow;
-    }
-
-    /**
-     * Get the arrow being picked up by the player
-     *
-     * @return The arrow being picked up
-     */
-    public Arrow getArrow() {
-        return arrow;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/player/PlayerPickupItemEvent.java b/src/main/java/org/bukkit/event/player/PlayerPickupItemEvent.java
deleted file mode 100644
index dfba816..0000000
--- a/src/main/java/org/bukkit/event/player/PlayerPickupItemEvent.java
+++ /dev/null
@@ -1,57 +0,0 @@
-package org.bukkit.event.player;
-
-import org.bukkit.entity.Item;
-import org.bukkit.entity.Player;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Thrown when a player picks an item up from the ground
- */
-public class PlayerPickupItemEvent extends PlayerEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private final Item item;
-    private boolean cancel = false;
-    private final int remaining;
-
-    public PlayerPickupItemEvent(final Player player, final Item item, final int remaining) {
-        super(player);
-        this.item = item;
-        this.remaining = remaining;
-    }
-
-    /**
-     * Gets the Item picked up by the player.
-     *
-     * @return Item
-     */
-    public Item getItem() {
-        return item;
-    }
-
-    /**
-     * Gets the amount remaining on the ground, if any
-     *
-     * @return amount remaining on the ground
-     */
-    public int getRemaining() {
-        return remaining;
-    }
-
-    public boolean isCancelled() {
-        return cancel;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancel = cancel;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/player/PlayerPortalEvent.java b/src/main/java/org/bukkit/event/player/PlayerPortalEvent.java
deleted file mode 100644
index 93752f7..0000000
--- a/src/main/java/org/bukkit/event/player/PlayerPortalEvent.java
+++ /dev/null
@@ -1,87 +0,0 @@
-package org.bukkit.event.player;
-
-import org.bukkit.Location;
-import org.bukkit.TravelAgent;
-import org.bukkit.entity.Player;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a player is about to teleport because it is in contact with a
- * portal.
- * <p>
- * For other entities see {@link org.bukkit.event.entity.EntityPortalEvent}
- */
-public class PlayerPortalEvent extends PlayerTeleportEvent {
-    private static final HandlerList handlers = new HandlerList();
-    protected boolean useTravelAgent = true;
-    protected TravelAgent travelAgent;
-
-    public PlayerPortalEvent(final Player player, final Location from, final Location to, final TravelAgent pta) {
-        super(player, from, to);
-        this.travelAgent = pta;
-    }
-
-    public PlayerPortalEvent(Player player, Location from, Location to, TravelAgent pta, TeleportCause cause) {
-        super(player, from, to, cause);
-        this.travelAgent = pta;
-    }
-
-    /**
-     * Sets whether or not the Travel Agent will be used.
-     * <p>
-     * If this is set to true, the TravelAgent will try to find a Portal at
-     * the {@link #getTo()} Location, and will try to create one if there is
-     * none.
-     * <p>
-     * If this is set to false, the {@link #getPlayer()} will only be
-     * teleported to the {@link #getTo()} Location.
-     *
-     * @param useTravelAgent whether to use the Travel Agent
-     */
-    public void useTravelAgent(boolean useTravelAgent) {
-        this.useTravelAgent = useTravelAgent;
-    }
-
-    /**
-     * Gets whether or not the Travel Agent will be used.
-     * <p>
-     * If this is set to true, the TravelAgent will try to find a Portal at
-     * the {@link #getTo()} Location, and will try to create one if there is
-     * none.
-     * <p>
-     * If this is set to false, the {@link #getPlayer()}} will only be
-     * teleported to the {@link #getTo()} Location.
-     *
-     * @return whether to use the Travel Agent
-     */
-    public boolean useTravelAgent() {
-        return useTravelAgent && travelAgent != null;
-    }
-
-    /**
-     * Gets the Travel Agent used (or not) in this event.
-     *
-     * @return the Travel Agent used (or not) in this event
-     */
-    public TravelAgent getPortalTravelAgent() {
-        return this.travelAgent;
-    }
-
-    /**
-     * Sets the Travel Agent used (or not) in this event.
-     *
-     * @param travelAgent the Travel Agent used (or not) in this event
-     */
-    public void setPortalTravelAgent(TravelAgent travelAgent) {
-        this.travelAgent = travelAgent;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
\ No newline at end of file
diff --git a/src/main/java/org/bukkit/event/player/PlayerPreLoginEvent.java b/src/main/java/org/bukkit/event/player/PlayerPreLoginEvent.java
deleted file mode 100644
index e8553f0..0000000
--- a/src/main/java/org/bukkit/event/player/PlayerPreLoginEvent.java
+++ /dev/null
@@ -1,159 +0,0 @@
-package org.bukkit.event.player;
-
-import java.net.InetAddress;
-import java.util.UUID;
-
-import org.bukkit.Warning;
-import org.bukkit.event.Event;
-import org.bukkit.event.HandlerList;
-
-/**
- * Stores details for players attempting to log in
- *
- * @deprecated This event causes synchronization from the login thread; {@link
- *     AsyncPlayerPreLoginEvent} is preferred to keep the secondary threads
- *     asynchronous.
- */
-@Deprecated
-@Warning(reason="This event causes a login thread to synchronize with the main thread")
-public class PlayerPreLoginEvent extends Event {
-    private static final HandlerList handlers = new HandlerList();
-    private Result result;
-    private String message;
-    private final String name;
-    private final InetAddress ipAddress;
-    private final UUID uniqueId;
-
-    @Deprecated
-    public PlayerPreLoginEvent(final String name, final InetAddress ipAddress) {
-        this(name, ipAddress, null);
-    }
-
-    public PlayerPreLoginEvent(final String name, final InetAddress ipAddress, final UUID uniqueId) {
-        this.result = Result.ALLOWED;
-        this.message = "";
-        this.name = name;
-        this.ipAddress = ipAddress;
-        this.uniqueId = uniqueId;
-    }
-
-    /**
-     * Gets the current result of the login, as an enum
-     *
-     * @return Current Result of the login
-     */
-    public Result getResult() {
-        return result;
-    }
-
-    /**
-     * Sets the new result of the login, as an enum
-     *
-     * @param result New result to set
-     */
-    public void setResult(final Result result) {
-        this.result = result;
-    }
-
-    /**
-     * Gets the current kick message that will be used if getResult() !=
-     * Result.ALLOWED
-     *
-     * @return Current kick message
-     */
-    public String getKickMessage() {
-        return message;
-    }
-
-    /**
-     * Sets the kick message to display if getResult() != Result.ALLOWED
-     *
-     * @param message New kick message
-     */
-    public void setKickMessage(final String message) {
-        this.message = message;
-    }
-
-    /**
-     * Allows the player to log in
-     */
-    public void allow() {
-        result = Result.ALLOWED;
-        message = "";
-    }
-
-    /**
-     * Disallows the player from logging in, with the given reason
-     *
-     * @param result New result for disallowing the player
-     * @param message Kick message to display to the user
-     */
-    public void disallow(final Result result, final String message) {
-        this.result = result;
-        this.message = message;
-    }
-
-    /**
-     * Gets the player's name.
-     *
-     * @return the player's name
-     */
-    public String getName() {
-        return name;
-    }
-
-    /**
-     * Gets the player IP address.
-     *
-     * @return The IP address
-     */
-    public InetAddress getAddress() {
-        return ipAddress;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    /**
-     * Gets the player's unique ID.
-     *
-     * @return The unique ID
-     */
-    public UUID getUniqueId() {
-        return uniqueId;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-
-    /**
-     * Basic kick reasons for communicating to plugins
-     */
-    public enum Result {
-
-        /**
-         * The player is allowed to log in
-         */
-        ALLOWED,
-        /**
-         * The player is not allowed to log in, due to the server being full
-         */
-        KICK_FULL,
-        /**
-         * The player is not allowed to log in, due to them being banned
-         */
-        KICK_BANNED,
-        /**
-         * The player is not allowed to log in, due to them not being on the
-         * white list
-         */
-        KICK_WHITELIST,
-        /**
-         * The player is not allowed to log in, for reasons undefined
-         */
-        KICK_OTHER
-    }
-}
diff --git a/src/main/java/org/bukkit/event/player/PlayerQuitEvent.java b/src/main/java/org/bukkit/event/player/PlayerQuitEvent.java
deleted file mode 100644
index 5c8dc1b..0000000
--- a/src/main/java/org/bukkit/event/player/PlayerQuitEvent.java
+++ /dev/null
@@ -1,44 +0,0 @@
-package org.bukkit.event.player;
-
-import org.bukkit.entity.Player;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a player leaves a server
- */
-public class PlayerQuitEvent extends PlayerEvent {
-    private static final HandlerList handlers = new HandlerList();
-    private String quitMessage;
-
-    public PlayerQuitEvent(final Player who, final String quitMessage) {
-        super(who);
-        this.quitMessage = quitMessage;
-    }
-
-    /**
-     * Gets the quit message to send to all online players
-     *
-     * @return string quit message
-     */
-    public String getQuitMessage() {
-        return quitMessage;
-    }
-
-    /**
-     * Sets the quit message to send to all online players
-     *
-     * @param quitMessage quit message
-     */
-    public void setQuitMessage(String quitMessage) {
-        this.quitMessage = quitMessage;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/player/PlayerRegisterChannelEvent.java b/src/main/java/org/bukkit/event/player/PlayerRegisterChannelEvent.java
deleted file mode 100644
index 442ac7f..0000000
--- a/src/main/java/org/bukkit/event/player/PlayerRegisterChannelEvent.java
+++ /dev/null
@@ -1,13 +0,0 @@
-package org.bukkit.event.player;
-
-import org.bukkit.entity.Player;
-
-/**
- * This is called immediately after a player registers for a plugin channel.
- */
-public class PlayerRegisterChannelEvent extends PlayerChannelEvent {
-
-    public PlayerRegisterChannelEvent(final Player player, final String channel) {
-        super(player, channel);
-    }
-}
diff --git a/src/main/java/org/bukkit/event/player/PlayerResourcePackStatusEvent.java b/src/main/java/org/bukkit/event/player/PlayerResourcePackStatusEvent.java
deleted file mode 100644
index 4c49801..0000000
--- a/src/main/java/org/bukkit/event/player/PlayerResourcePackStatusEvent.java
+++ /dev/null
@@ -1,61 +0,0 @@
-package org.bukkit.event.player;
-
-import org.bukkit.entity.Player;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a player takes action on a resource pack request sent via
- * {@link Player#setResourcePack(java.lang.String)}.
- */
-public class PlayerResourcePackStatusEvent extends PlayerEvent {
-
-    private static final HandlerList handlers = new HandlerList();
-    private final Status status;
-
-    public PlayerResourcePackStatusEvent(final Player who, Status resourcePackStatus) {
-        super(who);
-        this.status = resourcePackStatus;
-    }
-
-    /**
-     * Gets the status of this pack.
-     *
-     * @return the current status
-     */
-    public Status getStatus() {
-        return status;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-
-    /**
-     * Status of the resource pack.
-     */
-    public enum Status {
-
-        /**
-         * The resource pack has been successfully downloaded and applied to the
-         * client.
-         */
-        SUCCESSFULLY_LOADED,
-        /**
-         * The client refused to accept the resource pack.
-         */
-        DECLINED,
-        /**
-         * The client accepted the pack, but download failed.
-         */
-        FAILED_DOWNLOAD,
-        /**
-         * The client accepted the pack and is beginning a download of it.
-         */
-        ACCEPTED;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/player/PlayerRespawnEvent.java b/src/main/java/org/bukkit/event/player/PlayerRespawnEvent.java
deleted file mode 100644
index 35900dd..0000000
--- a/src/main/java/org/bukkit/event/player/PlayerRespawnEvent.java
+++ /dev/null
@@ -1,60 +0,0 @@
-package org.bukkit.event.player;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.Location;
-import org.bukkit.entity.Player;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a player respawns.
- */
-public class PlayerRespawnEvent extends PlayerEvent {
-    private static final HandlerList handlers = new HandlerList();
-    private Location respawnLocation;
-    private final boolean isBedSpawn;
-
-    public PlayerRespawnEvent(final Player respawnPlayer, final Location respawnLocation, final boolean isBedSpawn) {
-        super(respawnPlayer);
-        this.respawnLocation = respawnLocation;
-        this.isBedSpawn = isBedSpawn;
-    }
-
-    /**
-     * Gets the current respawn location
-     *
-     * @return Location current respawn location
-     */
-    public Location getRespawnLocation() {
-        return this.respawnLocation;
-    }
-
-    /**
-     * Sets the new respawn location
-     *
-     * @param respawnLocation new location for the respawn
-     */
-    public void setRespawnLocation(Location respawnLocation) {
-        Validate.notNull(respawnLocation, "Respawn location can not be null");
-        Validate.notNull(respawnLocation.getWorld(), "Respawn world can not be null");
-
-        this.respawnLocation = respawnLocation;
-    }
-
-    /**
-     * Gets whether the respawn location is the player's bed.
-     *
-     * @return true if the respawn location is the player's bed.
-     */
-    public boolean isBedSpawn() {
-        return this.isBedSpawn;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/player/PlayerShearEntityEvent.java b/src/main/java/org/bukkit/event/player/PlayerShearEntityEvent.java
deleted file mode 100644
index 38afb3c..0000000
--- a/src/main/java/org/bukkit/event/player/PlayerShearEntityEvent.java
+++ /dev/null
@@ -1,48 +0,0 @@
-package org.bukkit.event.player;
-
-import org.bukkit.entity.Entity;
-import org.bukkit.entity.Player;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a player shears an entity
- */
-public class PlayerShearEntityEvent extends PlayerEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private boolean cancel;
-    private final Entity what;
-
-    public PlayerShearEntityEvent(final Player who, final Entity what) {
-        super(who);
-        this.cancel = false;
-        this.what = what;
-    }
-
-    public boolean isCancelled() {
-        return cancel;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancel = cancel;
-    }
-
-    /**
-     * Gets the entity the player is shearing
-     *
-     * @return the entity the player is shearing
-     */
-    public Entity getEntity() {
-        return what;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-
-}
diff --git a/src/main/java/org/bukkit/event/player/PlayerStatisticIncrementEvent.java b/src/main/java/org/bukkit/event/player/PlayerStatisticIncrementEvent.java
deleted file mode 100644
index 3b64d70..0000000
--- a/src/main/java/org/bukkit/event/player/PlayerStatisticIncrementEvent.java
+++ /dev/null
@@ -1,116 +0,0 @@
-package org.bukkit.event.player;
-
-import org.bukkit.Material;
-import org.bukkit.Statistic;
-import org.bukkit.entity.EntityType;
-import org.bukkit.entity.Player;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a player statistic is incremented.
- * <p>
- * This event is not called for {@link org.bukkit.Statistic#PLAY_ONE_TICK} or
- * movement based statistics.
- *
- */
-public class PlayerStatisticIncrementEvent extends PlayerEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    protected final Statistic statistic;
-    private final int initialValue;
-    private final int newValue;
-    private boolean isCancelled = false;
-    private final EntityType entityType;
-    private final Material material;
-
-    public PlayerStatisticIncrementEvent(Player player, Statistic statistic, int initialValue, int newValue) {
-        super (player);
-        this.statistic = statistic;
-        this.initialValue = initialValue;
-        this.newValue = newValue;
-        this.entityType = null;
-        this.material = null;
-    }
-
-    public PlayerStatisticIncrementEvent(Player player, Statistic statistic, int initialValue, int newValue, EntityType entityType) {
-        super (player);
-        this.statistic = statistic;
-        this.initialValue = initialValue;
-        this.newValue = newValue;
-        this.entityType = entityType;
-        this.material = null;
-    }
-
-    public PlayerStatisticIncrementEvent(Player player, Statistic statistic, int initialValue, int newValue, Material material) {
-        super (player);
-        this.statistic = statistic;
-        this.initialValue = initialValue;
-        this.newValue = newValue;
-        this.entityType = null;
-        this.material = material;
-    }
-
-    /**
-     * Gets the statistic that is being incremented.
-     *
-     * @return the incremented statistic
-     */
-    public Statistic getStatistic() {
-        return statistic;
-    }
-
-    /**
-     * Gets the previous value of the statistic.
-     *
-     * @return the previous value of the statistic
-     */
-    public int getPreviousValue() {
-        return initialValue;
-    }
-
-    /**
-     * Gets the new value of the statistic.
-     *
-     * @return the new value of the statistic
-     */
-    public int getNewValue() {
-        return newValue;
-    }
-
-    /**
-     * Gets the EntityType if {@link #getStatistic() getStatistic()} is an
-     * entity statistic otherwise returns null.
-     *
-     * @return the EntityType of the statistic
-     */
-    public EntityType getEntityType() {
-        return entityType;
-    }
-
-    /**
-     * Gets the Material if {@link #getStatistic() getStatistic()} is a block
-     * or item statistic otherwise returns null.
-     *
-     * @return the Material of the statistic
-     */
-    public Material getMaterial() {
-        return material;
-    }
-
-    public boolean isCancelled() {
-        return isCancelled;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.isCancelled = cancel;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/player/PlayerSwapHandItemsEvent.java b/src/main/java/org/bukkit/event/player/PlayerSwapHandItemsEvent.java
deleted file mode 100644
index 483eb17..0000000
--- a/src/main/java/org/bukkit/event/player/PlayerSwapHandItemsEvent.java
+++ /dev/null
@@ -1,81 +0,0 @@
-package org.bukkit.event.player;
-
-import org.bukkit.entity.Player;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-import org.bukkit.inventory.ItemStack;
-
-/**
- * Called when a player swap items between main hand and off hand using the
- * hotkey.
- */
-public class PlayerSwapHandItemsEvent extends PlayerEvent implements Cancellable {
-
-    private static final HandlerList handlers = new HandlerList();
-    //
-    private ItemStack mainHandItem;
-    private ItemStack offHandItem;
-    private boolean cancelled;
-
-    public PlayerSwapHandItemsEvent(Player player, ItemStack mainHandItem, ItemStack offHandItem) {
-        super(player);
-
-        this.mainHandItem = mainHandItem;
-        this.offHandItem = offHandItem;
-    }
-
-    /**
-     * Gets the item switched to the main hand.
-     *
-     * @return item in the main hand
-     */
-    public ItemStack getMainHandItem() {
-        return mainHandItem;
-    }
-
-    /**
-     * Sets the item in the main hand.
-     *
-     * @param mainHandItem new item in the main hand
-     */
-    public void setMainHandItem(ItemStack mainHandItem) {
-        this.mainHandItem = mainHandItem;
-    }
-
-    /**
-     * Gets the item switched to the off hand.
-     *
-     * @return item in the off hand
-     */
-    public ItemStack getOffHandItem() {
-        return offHandItem;
-    }
-
-    /**
-     * Sets the item in the off hand.
-     *
-     * @param offHandItem new item in the off hand
-     */
-    public void setOffHandItem(ItemStack offHandItem) {
-        this.offHandItem = offHandItem;
-    }
-
-    @Override
-    public boolean isCancelled() {
-        return cancelled;
-    }
-
-    @Override
-    public void setCancelled(boolean cancel) {
-        this.cancelled = cancel;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/player/PlayerTeleportEvent.java b/src/main/java/org/bukkit/event/player/PlayerTeleportEvent.java
deleted file mode 100644
index d7f3af7..0000000
--- a/src/main/java/org/bukkit/event/player/PlayerTeleportEvent.java
+++ /dev/null
@@ -1,88 +0,0 @@
-package org.bukkit.event.player;
-
-import org.bukkit.Location;
-import org.bukkit.entity.Player;
-import org.bukkit.event.HandlerList;
-
-/**
- * Holds information for player teleport events
- */
-public class PlayerTeleportEvent extends PlayerMoveEvent {
-    private static final HandlerList handlers = new HandlerList();
-    private TeleportCause cause = TeleportCause.UNKNOWN;
-
-    public PlayerTeleportEvent(final Player player, final Location from, final Location to) {
-        super(player, from, to);
-    }
-
-    public PlayerTeleportEvent(final Player player, final Location from, final Location to, final TeleportCause cause) {
-        this(player, from, to);
-
-        this.cause = cause;
-    }
-
-    /**
-     * Gets the cause of this teleportation event
-     *
-     * @return Cause of the event
-     */
-    public TeleportCause getCause() {
-        return cause;
-    }
-
-    public enum TeleportCause {
-        /**
-         * Indicates the teleporation was caused by a player throwing an Ender
-         * Pearl
-         */
-        ENDER_PEARL,
-        /**
-         * Indicates the teleportation was caused by a player executing a
-         * command
-         */
-        COMMAND,
-        /**
-         * Indicates the teleportation was caused by a plugin
-         */
-        PLUGIN,
-        /**
-         * Indicates the teleportation was caused by a player entering a
-         * Nether portal
-         */
-        NETHER_PORTAL,
-        /**
-         * Indicates the teleportation was caused by a player entering an End
-         * portal
-         */
-        END_PORTAL,
-        /**
-         * Indicates the teleportation was caused by a player teleporting to a
-         * Entity/Player via the specatator menu
-         */
-        SPECTATE,
-        /**
-         * Indicates the teleportation was caused by a player entering an End
-         * gateway
-         */
-        END_GATEWAY,
-        /**
-         * Indicates the teleportation was caused by a player consuming chorus
-         * fruit
-         */
-        CHORUS_FRUIT,
-        /**
-         * Indicates the teleportation was caused by an event not covered by
-         * this enum
-         */
-        UNKNOWN;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/player/PlayerToggleFlightEvent.java b/src/main/java/org/bukkit/event/player/PlayerToggleFlightEvent.java
deleted file mode 100644
index 1c5ec37..0000000
--- a/src/main/java/org/bukkit/event/player/PlayerToggleFlightEvent.java
+++ /dev/null
@@ -1,45 +0,0 @@
-package org.bukkit.event.player;
-
-import org.bukkit.entity.Player;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a player toggles their flying state
- */
-public class PlayerToggleFlightEvent extends PlayerEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private final boolean isFlying;
-    private boolean cancel = false;
-
-    public PlayerToggleFlightEvent(final Player player, final boolean isFlying) {
-        super(player);
-        this.isFlying = isFlying;
-    }
-
-    /**
-     * Returns whether the player is trying to start or stop flying.
-     *
-     * @return flying state
-     */
-    public boolean isFlying() {
-        return isFlying;
-    }
-
-    public boolean isCancelled() {
-        return cancel;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancel = cancel;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/player/PlayerToggleSneakEvent.java b/src/main/java/org/bukkit/event/player/PlayerToggleSneakEvent.java
deleted file mode 100644
index 667acad..0000000
--- a/src/main/java/org/bukkit/event/player/PlayerToggleSneakEvent.java
+++ /dev/null
@@ -1,45 +0,0 @@
-package org.bukkit.event.player;
-
-import org.bukkit.entity.Player;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a player toggles their sneaking state
- */
-public class PlayerToggleSneakEvent extends PlayerEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private final boolean isSneaking;
-    private boolean cancel = false;
-
-    public PlayerToggleSneakEvent(final Player player, final boolean isSneaking) {
-        super(player);
-        this.isSneaking = isSneaking;
-    }
-
-    /**
-     * Returns whether the player is now sneaking or not.
-     *
-     * @return sneaking state
-     */
-    public boolean isSneaking() {
-        return isSneaking;
-    }
-
-    public boolean isCancelled() {
-        return cancel;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancel = cancel;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/player/PlayerToggleSprintEvent.java b/src/main/java/org/bukkit/event/player/PlayerToggleSprintEvent.java
deleted file mode 100644
index cf065e1..0000000
--- a/src/main/java/org/bukkit/event/player/PlayerToggleSprintEvent.java
+++ /dev/null
@@ -1,45 +0,0 @@
-package org.bukkit.event.player;
-
-import org.bukkit.entity.Player;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a player toggles their sprinting state
- */
-public class PlayerToggleSprintEvent extends PlayerEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private final boolean isSprinting;
-    private boolean cancel = false;
-
-    public PlayerToggleSprintEvent(final Player player, final boolean isSprinting) {
-        super(player);
-        this.isSprinting = isSprinting;
-    }
-
-    /**
-     * Gets whether the player is now sprinting or not.
-     *
-     * @return sprinting state
-     */
-    public boolean isSprinting() {
-        return isSprinting;
-    }
-
-    public boolean isCancelled() {
-        return cancel;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancel = cancel;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
\ No newline at end of file
diff --git a/src/main/java/org/bukkit/event/player/PlayerUnleashEntityEvent.java b/src/main/java/org/bukkit/event/player/PlayerUnleashEntityEvent.java
deleted file mode 100644
index f6aebef..0000000
--- a/src/main/java/org/bukkit/event/player/PlayerUnleashEntityEvent.java
+++ /dev/null
@@ -1,36 +0,0 @@
-package org.bukkit.event.player;
-
-import org.bukkit.entity.Entity;
-import org.bukkit.entity.Player;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.entity.EntityUnleashEvent;
-
-/**
- * Called prior to an entity being unleashed due to a player's action.
- */
-public class PlayerUnleashEntityEvent extends EntityUnleashEvent implements Cancellable {
-    private final Player player;
-    private boolean cancelled = false;
-
-    public PlayerUnleashEntityEvent(Entity entity, Player player) {
-        super(entity, UnleashReason.PLAYER_UNLEASH);
-        this.player = player;
-    }
-
-    /**
-     * Returns the player who is unleashing the entity.
-     *
-     * @return The player
-     */
-    public Player getPlayer() {
-        return player;
-    }
-
-    public boolean isCancelled() {
-        return cancelled;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancelled = cancel;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/player/PlayerUnregisterChannelEvent.java b/src/main/java/org/bukkit/event/player/PlayerUnregisterChannelEvent.java
deleted file mode 100644
index 11c77e3..0000000
--- a/src/main/java/org/bukkit/event/player/PlayerUnregisterChannelEvent.java
+++ /dev/null
@@ -1,13 +0,0 @@
-package org.bukkit.event.player;
-
-import org.bukkit.entity.Player;
-
-/**
- * This is called immediately after a player unregisters for a plugin channel.
- */
-public class PlayerUnregisterChannelEvent extends PlayerChannelEvent {
-
-    public PlayerUnregisterChannelEvent(final Player player, final String channel) {
-        super(player, channel);
-    }
-}
diff --git a/src/main/java/org/bukkit/event/player/PlayerVelocityEvent.java b/src/main/java/org/bukkit/event/player/PlayerVelocityEvent.java
deleted file mode 100644
index 69d2fce..0000000
--- a/src/main/java/org/bukkit/event/player/PlayerVelocityEvent.java
+++ /dev/null
@@ -1,55 +0,0 @@
-package org.bukkit.event.player;
-
-import org.bukkit.entity.Player;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-import org.bukkit.util.Vector;
-
-/**
- * Called when the velocity of a player changes.
- */
-public class PlayerVelocityEvent extends PlayerEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private boolean cancel = false;
-    private Vector velocity;
-
-    public PlayerVelocityEvent(final Player player, final Vector velocity) {
-        super(player);
-        this.velocity = velocity;
-    }
-
-    public boolean isCancelled() {
-        return cancel;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancel = cancel;
-    }
-
-    /**
-     * Gets the velocity vector that will be sent to the player
-     *
-     * @return Vector the player will get
-     */
-    public Vector getVelocity() {
-        return velocity;
-    }
-
-    /**
-     * Sets the velocity vector that will be sent to the player
-     *
-     * @param velocity The velocity vector that will be sent to the player
-     */
-    public void setVelocity(Vector velocity) {
-        this.velocity = velocity;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/server/MapInitializeEvent.java b/src/main/java/org/bukkit/event/server/MapInitializeEvent.java
deleted file mode 100644
index 8834489..0000000
--- a/src/main/java/org/bukkit/event/server/MapInitializeEvent.java
+++ /dev/null
@@ -1,34 +0,0 @@
-package org.bukkit.event.server;
-
-import org.bukkit.event.HandlerList;
-import org.bukkit.map.MapView;
-
-/**
- * Called when a map is initialized.
- */
-public class MapInitializeEvent extends ServerEvent {
-    private static final HandlerList handlers = new HandlerList();
-    private final MapView mapView;
-
-    public MapInitializeEvent(final MapView mapView) {
-        this.mapView = mapView;
-    }
-
-    /**
-     * Gets the map initialized in this event.
-     *
-     * @return Map for this event
-     */
-    public MapView getMap() {
-        return mapView;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/server/PluginDisableEvent.java b/src/main/java/org/bukkit/event/server/PluginDisableEvent.java
deleted file mode 100644
index 932c4fd..0000000
--- a/src/main/java/org/bukkit/event/server/PluginDisableEvent.java
+++ /dev/null
@@ -1,24 +0,0 @@
-package org.bukkit.event.server;
-
-import org.bukkit.event.HandlerList;
-import org.bukkit.plugin.Plugin;
-
-/**
- * Called when a plugin is disabled.
- */
-public class PluginDisableEvent extends PluginEvent {
-    private static final HandlerList handlers = new HandlerList();
-
-    public PluginDisableEvent(final Plugin plugin) {
-        super(plugin);
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/server/PluginEnableEvent.java b/src/main/java/org/bukkit/event/server/PluginEnableEvent.java
deleted file mode 100644
index 865316d..0000000
--- a/src/main/java/org/bukkit/event/server/PluginEnableEvent.java
+++ /dev/null
@@ -1,24 +0,0 @@
-package org.bukkit.event.server;
-
-import org.bukkit.event.HandlerList;
-import org.bukkit.plugin.Plugin;
-
-/**
- * Called when a plugin is enabled.
- */
-public class PluginEnableEvent extends PluginEvent {
-    private static final HandlerList handlers = new HandlerList();
-
-    public PluginEnableEvent(final Plugin plugin) {
-        super(plugin);
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/server/PluginEvent.java b/src/main/java/org/bukkit/event/server/PluginEvent.java
deleted file mode 100644
index 1ad656d..0000000
--- a/src/main/java/org/bukkit/event/server/PluginEvent.java
+++ /dev/null
@@ -1,23 +0,0 @@
-package org.bukkit.event.server;
-
-import org.bukkit.plugin.Plugin;
-
-/**
- * Used for plugin enable and disable events
- */
-public abstract class PluginEvent extends ServerEvent {
-    private final Plugin plugin;
-
-    public PluginEvent(final Plugin plugin) {
-        this.plugin = plugin;
-    }
-
-    /**
-     * Gets the plugin involved in this event
-     *
-     * @return Plugin for this event
-     */
-    public Plugin getPlugin() {
-        return plugin;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/server/RemoteServerCommandEvent.java b/src/main/java/org/bukkit/event/server/RemoteServerCommandEvent.java
deleted file mode 100644
index 2a49237..0000000
--- a/src/main/java/org/bukkit/event/server/RemoteServerCommandEvent.java
+++ /dev/null
@@ -1,25 +0,0 @@
-package org.bukkit.event.server;
-
-import org.bukkit.command.CommandSender;
-import org.bukkit.event.HandlerList;
-
-/**
- * This event is called when a command is recieved over RCON. See the javadocs
- * of {@link ServerCommandEvent} for more information.
- */
-public class RemoteServerCommandEvent extends ServerCommandEvent {
-    private static final HandlerList handlers = new HandlerList();
-
-    public RemoteServerCommandEvent(final CommandSender sender, final String command) {
-        super(sender, command);
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/server/ServerCommandEvent.java b/src/main/java/org/bukkit/event/server/ServerCommandEvent.java
deleted file mode 100644
index 10ea0f0..0000000
--- a/src/main/java/org/bukkit/event/server/ServerCommandEvent.java
+++ /dev/null
@@ -1,98 +0,0 @@
-package org.bukkit.event.server;
-
-import org.bukkit.command.CommandSender;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * This event is called when a command is run from the server console. It is
- * called early in the command handling process, and modifications in this
- * event (via {@link #setCommand(String)}) will be shown in the behavior.
- * <p>
- * Many plugins will have <b>no use for this event</b>, and you should
- * attempt to avoid using it if it is not necessary.
- * <p>
- * Some examples of valid uses for this event are:
- * <ul>
- * <li>Logging executed commands to a separate file
- * <li>Variable substitution. For example, replacing <code>${ip:Steve}</code>
- *     with the connection IP of the player named Steve, or simulating the
- *     <code>@a</code> and <code>@p</code> decorators used by Command Blocks
- *     for plugins that do not handle it.
- * <li>Conditionally blocking commands belonging to other plugins.
- * <li>Per-sender command aliases. For example, after the console runs the
- *     command <code>/calias cr gamemode creative</code>, the next time they
- *     run <code>/cr</code>, it gets replaced into
- *     <code>/gamemode creative</code>. (Global command aliases should be
- *     done by registering the alias.)
- * </ul>
- * <p>
- * Examples of incorrect uses are:
- * <ul>
- * <li>Using this event to run command logic
- * </ul>
- * <p>
- * If the event is cancelled, processing of the command will halt.
- * <p>
- * The state of whether or not there is a slash (<code>/</code>) at the
- * beginning of the message should be preserved. If a slash is added or
- * removed, unexpected behavior may result.
- */
-public class ServerCommandEvent extends ServerEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private String command;
-    private final CommandSender sender;
-    private boolean cancel = false;
-
-    public ServerCommandEvent(final CommandSender sender, final String command) {
-        this.command = command;
-        this.sender = sender;
-    }
-
-    /**
-     * Gets the command that the user is attempting to execute from the
-     * console
-     *
-     * @return Command the user is attempting to execute
-     */
-    public String getCommand() {
-        return command;
-    }
-
-    /**
-     * Sets the command that the server will execute
-     *
-     * @param message New message that the server will execute
-     */
-    public void setCommand(String message) {
-        this.command = message;
-    }
-
-    /**
-     * Get the command sender.
-     *
-     * @return The sender
-     */
-    public CommandSender getSender() {
-        return sender;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-
-    @Override
-    public boolean isCancelled() {
-        return cancel;
-    }
-
-    @Override
-    public void setCancelled(boolean cancel) {
-        this.cancel = cancel;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/server/ServerEvent.java b/src/main/java/org/bukkit/event/server/ServerEvent.java
deleted file mode 100644
index eb00d6a..0000000
--- a/src/main/java/org/bukkit/event/server/ServerEvent.java
+++ /dev/null
@@ -1,9 +0,0 @@
-package org.bukkit.event.server;
-
-import org.bukkit.event.Event;
-
-/**
- * Miscellaneous server events
- */
-public abstract class ServerEvent extends Event {
-}
diff --git a/src/main/java/org/bukkit/event/server/ServerListPingEvent.java b/src/main/java/org/bukkit/event/server/ServerListPingEvent.java
deleted file mode 100644
index 343f238..0000000
--- a/src/main/java/org/bukkit/event/server/ServerListPingEvent.java
+++ /dev/null
@@ -1,146 +0,0 @@
-package org.bukkit.event.server;
-
-import java.net.InetAddress;
-import java.util.Iterator;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.entity.Player;
-import org.bukkit.event.HandlerList;
-import org.bukkit.util.CachedServerIcon;
-
-/**
- * Called when a server list ping is coming in. Displayed players can be
- * checked and removed by {@link #iterator() iterating} over this event.
- */
-public class ServerListPingEvent extends ServerEvent implements Iterable<Player> {
-    private static final int MAGIC_PLAYER_COUNT = Integer.MIN_VALUE;
-    private static final HandlerList handlers = new HandlerList();
-    private final InetAddress address;
-    private String motd;
-    private final int numPlayers;
-    private int maxPlayers;
-
-    public ServerListPingEvent(final InetAddress address, final String motd, final int numPlayers, final int maxPlayers) {
-        Validate.isTrue(numPlayers >= 0, "Cannot have negative number of players online", numPlayers);
-        this.address = address;
-        this.motd = motd;
-        this.numPlayers = numPlayers;
-        this.maxPlayers = maxPlayers;
-    }
-
-    /**
-     * This constructor is intended for implementations that provide the
-     * {@link #iterator()} method, thus provided the {@link #getNumPlayers()}
-     * count.
-     * 
-     * @param address the address of the pinger
-     * @param motd the message of the day
-     * @param maxPlayers the max number of players
-     */
-    protected ServerListPingEvent(final InetAddress address, final String motd, final int maxPlayers) {
-        this.numPlayers = MAGIC_PLAYER_COUNT;
-        this.address = address;
-        this.motd = motd;
-        this.maxPlayers = maxPlayers;
-    }
-
-    /**
-     * Get the address the ping is coming from.
-     *
-     * @return the address
-     */
-    public InetAddress getAddress() {
-        return address;
-    }
-
-    /**
-     * Get the message of the day message.
-     *
-     * @return the message of the day
-     */
-    public String getMotd() {
-        return motd;
-    }
-
-    /**
-     * Change the message of the day message.
-     *
-     * @param motd the message of the day
-     */
-    public void setMotd(String motd) {
-        this.motd = motd;
-    }
-
-    /**
-     * Get the number of players sent.
-     *
-     * @return the number of players
-     */
-    public int getNumPlayers() {
-        int numPlayers = this.numPlayers;
-        if (numPlayers == MAGIC_PLAYER_COUNT) {
-            numPlayers = 0;
-            for (@SuppressWarnings("unused") final Player player : this) {
-                numPlayers++;
-            }
-        }
-        return numPlayers;
-    }
-
-    /**
-     * Get the maximum number of players sent.
-     *
-     * @return the maximum number of players
-     */
-    public int getMaxPlayers() {
-        return maxPlayers;
-    }
-
-    /**
-     * Set the maximum number of players sent.
-     *
-     * @param maxPlayers the maximum number of player
-     */
-    public void setMaxPlayers(int maxPlayers) {
-        this.maxPlayers = maxPlayers;
-    }
-
-    /**
-     * Sets the server-icon sent to the client.
-     *
-     * @param icon the icon to send to the client
-     * @throws IllegalArgumentException if the {@link CachedServerIcon} is not
-     *     created by the caller of this event; null may be accepted for some
-     *     implementations
-     * @throws UnsupportedOperationException if the caller of this event does
-     *     not support setting the server icon
-     */
-    public void setServerIcon(CachedServerIcon icon) throws IllegalArgumentException, UnsupportedOperationException {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-
-    /**
-     * {@inheritDoc}
-     * <p>
-     * Calling the {@link Iterator#remove()} method will force that particular
-     * player to not be displayed on the player list, decrease the size
-     * returned by {@link #getNumPlayers()}, and will not be returned again by
-     * any new iterator.
-     *
-     * @throws UnsupportedOperationException if the caller of this event does
-     *     not support removing players
-     */
-    @Override
-    public Iterator<Player> iterator() throws UnsupportedOperationException {
-        throw new UnsupportedOperationException();
-    }
-}
diff --git a/src/main/java/org/bukkit/event/server/ServiceEvent.java b/src/main/java/org/bukkit/event/server/ServiceEvent.java
deleted file mode 100644
index 69bf872..0000000
--- a/src/main/java/org/bukkit/event/server/ServiceEvent.java
+++ /dev/null
@@ -1,19 +0,0 @@
-package org.bukkit.event.server;
-
-import org.bukkit.plugin.RegisteredServiceProvider;
-
-/**
- * An event relating to a registered service. This is called in a {@link
- * org.bukkit.plugin.ServicesManager}
- */
-public abstract class ServiceEvent extends ServerEvent {
-    private final RegisteredServiceProvider<?> provider;
-
-    public ServiceEvent(final RegisteredServiceProvider<?> provider) {
-        this.provider = provider;
-    }
-
-    public RegisteredServiceProvider<?> getProvider() {
-        return provider;
-    }
-}
\ No newline at end of file
diff --git a/src/main/java/org/bukkit/event/server/ServiceRegisterEvent.java b/src/main/java/org/bukkit/event/server/ServiceRegisterEvent.java
deleted file mode 100644
index 7dfadde..0000000
--- a/src/main/java/org/bukkit/event/server/ServiceRegisterEvent.java
+++ /dev/null
@@ -1,27 +0,0 @@
-package org.bukkit.event.server;
-
-import org.bukkit.event.HandlerList;
-import org.bukkit.plugin.RegisteredServiceProvider;
-
-/**
- * This event is called when a service is registered.
- * <p>
- * Warning: The order in which register and unregister events are called
- * should not be relied upon.
- */
-public class ServiceRegisterEvent extends ServiceEvent {
-    private static final HandlerList handlers = new HandlerList();
-
-    public ServiceRegisterEvent(RegisteredServiceProvider<?> registeredProvider) {
-        super(registeredProvider);
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/server/ServiceUnregisterEvent.java b/src/main/java/org/bukkit/event/server/ServiceUnregisterEvent.java
deleted file mode 100644
index db61d23..0000000
--- a/src/main/java/org/bukkit/event/server/ServiceUnregisterEvent.java
+++ /dev/null
@@ -1,27 +0,0 @@
-package org.bukkit.event.server;
-
-import org.bukkit.event.HandlerList;
-import org.bukkit.plugin.RegisteredServiceProvider;
-
-/**
- * This event is called when a service is unregistered.
- * <p>
- * Warning: The order in which register and unregister events are called
- * should not be relied upon.
- */
-public class ServiceUnregisterEvent extends ServiceEvent {
-    private static final HandlerList handlers = new HandlerList();
-
-    public ServiceUnregisterEvent(RegisteredServiceProvider<?> serviceProvider) {
-        super(serviceProvider);
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/server/TabCompleteEvent.java b/src/main/java/org/bukkit/event/server/TabCompleteEvent.java
deleted file mode 100644
index 6ac437d..0000000
--- a/src/main/java/org/bukkit/event/server/TabCompleteEvent.java
+++ /dev/null
@@ -1,89 +0,0 @@
-package org.bukkit.event.server;
-
-import java.util.List;
-import org.apache.commons.lang.Validate;
-import org.bukkit.command.CommandSender;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.Event;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a {@link CommandSender} of any description (ie: player or
- * console) attempts to tab complete.
- */
-public class TabCompleteEvent extends Event implements Cancellable {
-
-    private static final HandlerList handlers = new HandlerList();
-    //
-    private final CommandSender sender;
-    private final String buffer;
-    private List<String> completions;
-    private boolean cancelled;
-
-    public TabCompleteEvent(CommandSender sender, String buffer, List<String> completions) {
-        Validate.notNull(sender, "sender");
-        Validate.notNull(buffer, "buffer");
-        Validate.notNull(completions, "completions");
-
-        this.sender = sender;
-        this.buffer = buffer;
-        this.completions = completions;
-    }
-
-    /**
-     * Get the sender completing this command.
-     *
-     * @return the {@link CommandSender} instance
-     */
-    public CommandSender getSender() {
-        return sender;
-    }
-
-    /**
-     * Return the entire buffer which formed the basis of this completion.
-     *
-     * @return command buffer, as entered
-     */
-    public String getBuffer() {
-        return buffer;
-    }
-
-    /**
-     * The list of completions which will be offered to the sender, in order.
-     * This list is mutable and reflects what will be offered.
-     *
-     * @return a list of offered completions
-     */
-    public List<String> getCompletions() {
-        return completions;
-    }
-
-    /**
-     * Set the completions offered, overriding any already set.
-     *
-     * @param completions the new completions
-     */
-    public void setCompletions(List<String> completions) {
-        Validate.notNull(completions);
-        this.completions = completions;
-    }
-
-    @Override
-    public boolean isCancelled() {
-        return cancelled;
-    }
-
-    @Override
-    public void setCancelled(boolean cancelled) {
-        this.cancelled = cancelled;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/vehicle/VehicleBlockCollisionEvent.java b/src/main/java/org/bukkit/event/vehicle/VehicleBlockCollisionEvent.java
deleted file mode 100644
index b643b57..0000000
--- a/src/main/java/org/bukkit/event/vehicle/VehicleBlockCollisionEvent.java
+++ /dev/null
@@ -1,36 +0,0 @@
-package org.bukkit.event.vehicle;
-
-import org.bukkit.block.Block;
-import org.bukkit.entity.Vehicle;
-import org.bukkit.event.HandlerList;
-
-/**
- * Raised when a vehicle collides with a block.
- */
-public class VehicleBlockCollisionEvent extends VehicleCollisionEvent {
-    private static final HandlerList handlers = new HandlerList();
-    private final Block block;
-
-    public VehicleBlockCollisionEvent(final Vehicle vehicle, final Block block) {
-        super(vehicle);
-        this.block = block;
-    }
-
-    /**
-     * Gets the block the vehicle collided with
-     *
-     * @return the block the vehicle collided with
-     */
-    public Block getBlock() {
-        return block;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/vehicle/VehicleCollisionEvent.java b/src/main/java/org/bukkit/event/vehicle/VehicleCollisionEvent.java
deleted file mode 100644
index 9dd0579..0000000
--- a/src/main/java/org/bukkit/event/vehicle/VehicleCollisionEvent.java
+++ /dev/null
@@ -1,12 +0,0 @@
-package org.bukkit.event.vehicle;
-
-import org.bukkit.entity.Vehicle;
-
-/**
- * Raised when a vehicle collides.
- */
-public abstract class VehicleCollisionEvent extends VehicleEvent {
-    public VehicleCollisionEvent(final Vehicle vehicle) {
-        super(vehicle);
-    }
-}
diff --git a/src/main/java/org/bukkit/event/vehicle/VehicleCreateEvent.java b/src/main/java/org/bukkit/event/vehicle/VehicleCreateEvent.java
deleted file mode 100644
index 22eda72..0000000
--- a/src/main/java/org/bukkit/event/vehicle/VehicleCreateEvent.java
+++ /dev/null
@@ -1,24 +0,0 @@
-package org.bukkit.event.vehicle;
-
-import org.bukkit.entity.Vehicle;
-import org.bukkit.event.HandlerList;
-
-/**
- * Raised when a vehicle is created.
- */
-public class VehicleCreateEvent extends VehicleEvent {
-    private static final HandlerList handlers = new HandlerList();
-
-    public VehicleCreateEvent(final Vehicle vehicle) {
-        super(vehicle);
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/vehicle/VehicleDamageEvent.java b/src/main/java/org/bukkit/event/vehicle/VehicleDamageEvent.java
deleted file mode 100644
index c7b9c1a..0000000
--- a/src/main/java/org/bukkit/event/vehicle/VehicleDamageEvent.java
+++ /dev/null
@@ -1,96 +0,0 @@
-package org.bukkit.event.vehicle;
-
-import org.bukkit.entity.Entity;
-import org.bukkit.entity.Vehicle;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-import org.bukkit.util.NumberConversions;
-
-/**
- * Raised when a vehicle receives damage.
- */
-public class VehicleDamageEvent extends VehicleEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private final Entity attacker;
-    private double damage;
-    private boolean cancelled;
-
-    @Deprecated
-    public VehicleDamageEvent(final Vehicle vehicle, final Entity attacker, final int damage) {
-        this(vehicle, attacker, (double) damage);
-    }
-
-    public VehicleDamageEvent(final Vehicle vehicle, final Entity attacker, final double damage) {
-        super(vehicle);
-        this.attacker = attacker;
-        this.damage = damage;
-    }
-
-    /**
-     * Gets the Entity that is attacking the vehicle
-     *
-     * @return the Entity that is attacking the vehicle
-     */
-    public Entity getAttacker() {
-        return attacker;
-    }
-
-    /**
-     * Gets the damage done to the vehicle
-     *
-     * @return the damage done to the vehicle
-     */
-    public double getDamage() {
-        return damage;
-    }
-
-    /**
-     * This method exists for legacy reasons to provide backwards
-     * compatibility. It will not exist at runtime and should not be used
-     * under any circumstances.
-     * 
-     * @return the damage
-     */
-    @Deprecated
-    public int _INVALID_getDamage() {
-        return NumberConversions.ceil(getDamage());
-    }
-
-    /**
-     * Sets the damage done to the vehicle
-     *
-     * @param damage The damage
-     */
-    public void setDamage(double damage) {
-        this.damage = damage;
-    }
-
-    /**
-     * This method exists for legacy reasons to provide backwards
-     * compatibility. It will not exist at runtime and should not be used
-     * under any circumstances.
-     * 
-     * @param damage the damage
-     */
-    @Deprecated
-    public void _INVALID_setDamage(int damage) {
-        setDamage(damage);
-    }
-
-    public boolean isCancelled() {
-        return cancelled;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancelled = cancel;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/vehicle/VehicleDestroyEvent.java b/src/main/java/org/bukkit/event/vehicle/VehicleDestroyEvent.java
deleted file mode 100644
index f1176fd..0000000
--- a/src/main/java/org/bukkit/event/vehicle/VehicleDestroyEvent.java
+++ /dev/null
@@ -1,48 +0,0 @@
-package org.bukkit.event.vehicle;
-
-import org.bukkit.entity.Entity;
-import org.bukkit.entity.Vehicle;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Raised when a vehicle is destroyed, which could be caused by either a
- * player or the environment. This is not raised if the boat is simply
- * 'removed' due to other means.
- */
-public class VehicleDestroyEvent extends VehicleEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private final Entity attacker;
-    private boolean cancelled;
-
-    public VehicleDestroyEvent(final Vehicle vehicle, final Entity attacker) {
-        super(vehicle);
-        this.attacker = attacker;
-    }
-
-    /**
-     * Gets the Entity that has destroyed the vehicle, potentially null
-     *
-     * @return the Entity that has destroyed the vehicle, potentially null
-     */
-    public Entity getAttacker() {
-        return attacker;
-    }
-
-    public boolean isCancelled() {
-        return cancelled;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancelled = cancel;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/vehicle/VehicleEnterEvent.java b/src/main/java/org/bukkit/event/vehicle/VehicleEnterEvent.java
deleted file mode 100644
index 85c9b21..0000000
--- a/src/main/java/org/bukkit/event/vehicle/VehicleEnterEvent.java
+++ /dev/null
@@ -1,46 +0,0 @@
-package org.bukkit.event.vehicle;
-
-import org.bukkit.entity.Entity;
-import org.bukkit.entity.Vehicle;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Raised when an entity enters a vehicle.
- */
-public class VehicleEnterEvent extends VehicleEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private boolean cancelled;
-    private final Entity entered;
-
-    public VehicleEnterEvent(final Vehicle vehicle, final Entity entered) {
-        super(vehicle);
-        this.entered = entered;
-    }
-
-    /**
-     * Gets the Entity that entered the vehicle.
-     *
-     * @return the Entity that entered the vehicle
-     */
-    public Entity getEntered() {
-        return entered;
-    }
-
-    public boolean isCancelled() {
-        return cancelled;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancelled = cancel;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/vehicle/VehicleEntityCollisionEvent.java b/src/main/java/org/bukkit/event/vehicle/VehicleEntityCollisionEvent.java
deleted file mode 100644
index 4d4d0e2..0000000
--- a/src/main/java/org/bukkit/event/vehicle/VehicleEntityCollisionEvent.java
+++ /dev/null
@@ -1,59 +0,0 @@
-package org.bukkit.event.vehicle;
-
-import org.bukkit.entity.Entity;
-import org.bukkit.entity.Vehicle;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Raised when a vehicle collides with an entity.
- */
-public class VehicleEntityCollisionEvent extends VehicleCollisionEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private final Entity entity;
-    private boolean cancelled = false;
-    private boolean cancelledPickup = false;
-    private boolean cancelledCollision = false;
-
-    public VehicleEntityCollisionEvent(final Vehicle vehicle, final Entity entity) {
-        super(vehicle);
-        this.entity = entity;
-    }
-
-    public Entity getEntity() {
-        return entity;
-    }
-
-    public boolean isCancelled() {
-        return cancelled;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancelled = cancel;
-    }
-
-    public boolean isPickupCancelled() {
-        return cancelledPickup;
-    }
-
-    public void setPickupCancelled(boolean cancel) {
-        cancelledPickup = cancel;
-    }
-
-    public boolean isCollisionCancelled() {
-        return cancelledCollision;
-    }
-
-    public void setCollisionCancelled(boolean cancel) {
-        cancelledCollision = cancel;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/vehicle/VehicleEvent.java b/src/main/java/org/bukkit/event/vehicle/VehicleEvent.java
deleted file mode 100644
index b8255c0..0000000
--- a/src/main/java/org/bukkit/event/vehicle/VehicleEvent.java
+++ /dev/null
@@ -1,24 +0,0 @@
-package org.bukkit.event.vehicle;
-
-import org.bukkit.entity.Vehicle;
-import org.bukkit.event.Event;
-
-/**
- * Represents a vehicle-related event.
- */
-public abstract class VehicleEvent extends Event {
-    protected Vehicle vehicle;
-
-    public VehicleEvent(final Vehicle vehicle) {
-        this.vehicle = vehicle;
-    }
-
-    /**
-     * Get the vehicle.
-     *
-     * @return the vehicle
-     */
-    public final Vehicle getVehicle() {
-        return vehicle;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/vehicle/VehicleExitEvent.java b/src/main/java/org/bukkit/event/vehicle/VehicleExitEvent.java
deleted file mode 100644
index 364451b..0000000
--- a/src/main/java/org/bukkit/event/vehicle/VehicleExitEvent.java
+++ /dev/null
@@ -1,46 +0,0 @@
-package org.bukkit.event.vehicle;
-
-import org.bukkit.entity.LivingEntity;
-import org.bukkit.entity.Vehicle;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Raised when a living entity exits a vehicle.
- */
-public class VehicleExitEvent extends VehicleEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private boolean cancelled;
-    private final LivingEntity exited;
-
-    public VehicleExitEvent(final Vehicle vehicle, final LivingEntity exited) {
-        super(vehicle);
-        this.exited = exited;
-    }
-
-    /**
-     * Get the living entity that exited the vehicle.
-     *
-     * @return The entity.
-     */
-    public LivingEntity getExited() {
-        return exited;
-    }
-
-    public boolean isCancelled() {
-        return cancelled;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancelled = cancel;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/vehicle/VehicleMoveEvent.java b/src/main/java/org/bukkit/event/vehicle/VehicleMoveEvent.java
deleted file mode 100644
index 9a13e29..0000000
--- a/src/main/java/org/bukkit/event/vehicle/VehicleMoveEvent.java
+++ /dev/null
@@ -1,49 +0,0 @@
-package org.bukkit.event.vehicle;
-
-import org.bukkit.Location;
-import org.bukkit.entity.Vehicle;
-import org.bukkit.event.HandlerList;
-
-/**
- * Raised when a vehicle moves.
- */
-public class VehicleMoveEvent extends VehicleEvent {
-    private static final HandlerList handlers = new HandlerList();
-    private final Location from;
-    private final Location to;
-
-    public VehicleMoveEvent(final Vehicle vehicle, final Location from, final Location to) {
-        super(vehicle);
-
-        this.from = from;
-        this.to = to;
-    }
-
-    /**
-     * Get the previous position.
-     *
-     * @return Old position.
-     */
-    public Location getFrom() {
-        return from;
-    }
-
-    /**
-     * Get the next position.
-     *
-     * @return New position.
-     */
-    public Location getTo() {
-        return to;
-    }
-
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/vehicle/VehicleUpdateEvent.java b/src/main/java/org/bukkit/event/vehicle/VehicleUpdateEvent.java
deleted file mode 100644
index eebfdb1..0000000
--- a/src/main/java/org/bukkit/event/vehicle/VehicleUpdateEvent.java
+++ /dev/null
@@ -1,24 +0,0 @@
-package org.bukkit.event.vehicle;
-
-import org.bukkit.entity.Vehicle;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a vehicle updates
- */
-public class VehicleUpdateEvent extends VehicleEvent {
-    private static final HandlerList handlers = new HandlerList();
-
-    public VehicleUpdateEvent(final Vehicle vehicle) {
-        super(vehicle);
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/weather/LightningStrikeEvent.java b/src/main/java/org/bukkit/event/weather/LightningStrikeEvent.java
deleted file mode 100644
index 66fd763..0000000
--- a/src/main/java/org/bukkit/event/weather/LightningStrikeEvent.java
+++ /dev/null
@@ -1,46 +0,0 @@
-package org.bukkit.event.weather;
-
-import org.bukkit.World;
-import org.bukkit.entity.LightningStrike;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Stores data for lightning striking
- */
-public class LightningStrikeEvent extends WeatherEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private boolean canceled;
-    private final LightningStrike bolt;
-
-    public LightningStrikeEvent(final World world, final LightningStrike bolt) {
-        super(world);
-        this.bolt = bolt;
-    }
-
-    public boolean isCancelled() {
-        return canceled;
-    }
-
-    public void setCancelled(boolean cancel) {
-        canceled = cancel;
-    }
-
-    /**
-     * Gets the bolt which is striking the earth.
-     *
-     * @return lightning entity
-     */
-    public LightningStrike getLightning() {
-        return bolt;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/weather/ThunderChangeEvent.java b/src/main/java/org/bukkit/event/weather/ThunderChangeEvent.java
deleted file mode 100644
index 5e3716e..0000000
--- a/src/main/java/org/bukkit/event/weather/ThunderChangeEvent.java
+++ /dev/null
@@ -1,45 +0,0 @@
-package org.bukkit.event.weather;
-
-import org.bukkit.World;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Stores data for thunder state changing in a world
- */
-public class ThunderChangeEvent extends WeatherEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private boolean canceled;
-    private final boolean to;
-
-    public ThunderChangeEvent(final World world, final boolean to) {
-        super(world);
-        this.to = to;
-    }
-
-    public boolean isCancelled() {
-        return canceled;
-    }
-
-    public void setCancelled(boolean cancel) {
-        canceled = cancel;
-    }
-
-    /**
-     * Gets the state of thunder that the world is being set to
-     *
-     * @return true if the weather is being set to thundering, false otherwise
-     */
-    public boolean toThunderState() {
-        return to;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/weather/WeatherChangeEvent.java b/src/main/java/org/bukkit/event/weather/WeatherChangeEvent.java
deleted file mode 100644
index 5d1234e..0000000
--- a/src/main/java/org/bukkit/event/weather/WeatherChangeEvent.java
+++ /dev/null
@@ -1,45 +0,0 @@
-package org.bukkit.event.weather;
-
-import org.bukkit.World;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Stores data for weather changing in a world
- */
-public class WeatherChangeEvent extends WeatherEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private boolean canceled;
-    private final boolean to;
-
-    public WeatherChangeEvent(final World world, final boolean to) {
-        super(world);
-        this.to = to;
-    }
-
-    public boolean isCancelled() {
-        return canceled;
-    }
-
-    public void setCancelled(boolean cancel) {
-        canceled = cancel;
-    }
-
-    /**
-     * Gets the state of weather that the world is being set to
-     *
-     * @return true if the weather is being set to raining, false otherwise
-     */
-    public boolean toWeatherState() {
-        return to;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/weather/WeatherEvent.java b/src/main/java/org/bukkit/event/weather/WeatherEvent.java
deleted file mode 100644
index 0cae9bc..0000000
--- a/src/main/java/org/bukkit/event/weather/WeatherEvent.java
+++ /dev/null
@@ -1,24 +0,0 @@
-package org.bukkit.event.weather;
-
-import org.bukkit.World;
-import org.bukkit.event.Event;
-
-/**
- * Represents a Weather-related event
- */
-public abstract class WeatherEvent extends Event {
-    protected World world;
-
-    public WeatherEvent(final World where) {
-        world = where;
-    }
-
-    /**
-     * Returns the World where this event is occurring
-     *
-     * @return World this event is occurring in
-     */
-    public final World getWorld() {
-        return world;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/world/ChunkEvent.java b/src/main/java/org/bukkit/event/world/ChunkEvent.java
deleted file mode 100644
index 4710d40..0000000
--- a/src/main/java/org/bukkit/event/world/ChunkEvent.java
+++ /dev/null
@@ -1,24 +0,0 @@
-package org.bukkit.event.world;
-
-import org.bukkit.Chunk;
-
-/**
- * Represents a Chunk related event
- */
-public abstract class ChunkEvent extends WorldEvent {
-    protected Chunk chunk;
-
-    protected ChunkEvent(final Chunk chunk) {
-        super(chunk.getWorld());
-        this.chunk = chunk;
-    }
-
-    /**
-     * Gets the chunk being loaded/unloaded
-     *
-     * @return Chunk that triggered this event
-     */
-    public Chunk getChunk() {
-        return chunk;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/world/ChunkLoadEvent.java b/src/main/java/org/bukkit/event/world/ChunkLoadEvent.java
deleted file mode 100644
index a45b1cd..0000000
--- a/src/main/java/org/bukkit/event/world/ChunkLoadEvent.java
+++ /dev/null
@@ -1,37 +0,0 @@
-package org.bukkit.event.world;
-
-import org.bukkit.Chunk;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a chunk is loaded
- */
-public class ChunkLoadEvent extends ChunkEvent {
-    private static final HandlerList handlers = new HandlerList();
-    private final boolean newChunk;
-
-    public ChunkLoadEvent(final Chunk chunk, final boolean newChunk) {
-        super(chunk);
-        this.newChunk = newChunk;
-    }
-
-    /**
-     * Gets if this chunk was newly created or not.
-     * <p>
-     * Note that if this chunk is new, it will not be populated at this time.
-     *
-     * @return true if the chunk is new, otherwise false
-     */
-    public boolean isNewChunk() {
-        return newChunk;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/world/ChunkPopulateEvent.java b/src/main/java/org/bukkit/event/world/ChunkPopulateEvent.java
deleted file mode 100644
index 705d955..0000000
--- a/src/main/java/org/bukkit/event/world/ChunkPopulateEvent.java
+++ /dev/null
@@ -1,28 +0,0 @@
-package org.bukkit.event.world;
-
-import org.bukkit.Chunk;
-import org.bukkit.event.HandlerList;
-import org.bukkit.generator.BlockPopulator;
-
-/**
- * Thrown when a new chunk has finished being populated.
- * <p>
- * If your intent is to populate the chunk using this event, please see {@link
- * BlockPopulator}
- */
-public class ChunkPopulateEvent extends ChunkEvent {
-    private static final HandlerList handlers = new HandlerList();
-
-    public ChunkPopulateEvent(final Chunk chunk) {
-        super(chunk);
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/world/ChunkUnloadEvent.java b/src/main/java/org/bukkit/event/world/ChunkUnloadEvent.java
deleted file mode 100644
index f59d091..0000000
--- a/src/main/java/org/bukkit/event/world/ChunkUnloadEvent.java
+++ /dev/null
@@ -1,34 +0,0 @@
-package org.bukkit.event.world;
-
-import org.bukkit.Chunk;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a chunk is unloaded
- */
-public class ChunkUnloadEvent extends ChunkEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private boolean cancel = false;
-
-    public ChunkUnloadEvent(final Chunk chunk) {
-        super(chunk);
-    }
-
-    public boolean isCancelled() {
-        return cancel;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancel = cancel;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/world/PortalCreateEvent.java b/src/main/java/org/bukkit/event/world/PortalCreateEvent.java
deleted file mode 100644
index d83d7a9..0000000
--- a/src/main/java/org/bukkit/event/world/PortalCreateEvent.java
+++ /dev/null
@@ -1,77 +0,0 @@
-package org.bukkit.event.world;
-
-import org.bukkit.block.Block;
-import org.bukkit.World;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-import java.util.ArrayList;
-import java.util.Collection;
-
-/**
- * Called when a portal is created
- */
-public class PortalCreateEvent extends WorldEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private boolean cancel = false;
-    private final ArrayList<Block> blocks = new ArrayList<Block>();
-    private CreateReason reason = CreateReason.FIRE;
-
-    public PortalCreateEvent(final Collection<Block> blocks, final World world, CreateReason reason) {
-        super(world);
-
-        this.blocks.addAll(blocks);
-        this.reason = reason;
-    }
-
-    /**
-     * Gets an array list of all the blocks associated with the created portal
-     *
-     * @return array list of all the blocks associated with the created portal
-     */
-    public ArrayList<Block> getBlocks() {
-        return this.blocks;
-    }
-
-    public boolean isCancelled() {
-        return cancel;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancel = cancel;
-    }
-
-    /**
-     * Gets the reason for the portal's creation
-     *
-     * @return CreateReason for the portal's creation
-     */
-    public CreateReason getReason() {
-        return reason;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-
-    /**
-     * An enum to specify the various reasons for a portal's creation
-     */
-    public enum CreateReason {
-        /**
-         * When a portal is created 'traditionally' due to a portal frame
-         * being set on fire.
-         */
-        FIRE,
-        /**
-         * When a portal is created as a destination for an existing portal
-         * when using the custom PortalTravelAgent
-         */
-        OBC_DESTINATION
-    }
-}
diff --git a/src/main/java/org/bukkit/event/world/SpawnChangeEvent.java b/src/main/java/org/bukkit/event/world/SpawnChangeEvent.java
deleted file mode 100644
index e99c3c0..0000000
--- a/src/main/java/org/bukkit/event/world/SpawnChangeEvent.java
+++ /dev/null
@@ -1,37 +0,0 @@
-package org.bukkit.event.world;
-
-import org.bukkit.World;
-import org.bukkit.Location;
-import org.bukkit.event.HandlerList;
-
-/**
- * An event that is called when a world's spawn changes. The world's previous
- * spawn location is included.
- */
-public class SpawnChangeEvent extends WorldEvent {
-    private static final HandlerList handlers = new HandlerList();
-    private final Location previousLocation;
-
-    public SpawnChangeEvent(final World world, final Location previousLocation) {
-        super(world);
-        this.previousLocation = previousLocation;
-    }
-
-    /**
-     * Gets the previous spawn location
-     *
-     * @return Location that used to be spawn
-     */
-    public Location getPreviousLocation() {
-        return previousLocation;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/world/StructureGrowEvent.java b/src/main/java/org/bukkit/event/world/StructureGrowEvent.java
deleted file mode 100644
index 62d300d..0000000
--- a/src/main/java/org/bukkit/event/world/StructureGrowEvent.java
+++ /dev/null
@@ -1,96 +0,0 @@
-package org.bukkit.event.world;
-
-import java.util.List;
-import org.bukkit.Location;
-import org.bukkit.TreeType;
-import org.bukkit.block.BlockState;
-import org.bukkit.entity.Player;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Event that is called when an organic structure attempts to grow (Sapling {@literal ->}
- * Tree), (Mushroom {@literal ->} Huge Mushroom), naturally or using bonemeal.
- */
-public class StructureGrowEvent extends WorldEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private boolean cancelled = false;
-    private final Location location;
-    private final TreeType species;
-    private final boolean bonemeal;
-    private final Player player;
-    private final List<BlockState> blocks;
-
-    public StructureGrowEvent(final Location location, final TreeType species, final boolean bonemeal, final Player player, final List<BlockState> blocks) {
-        super(location.getWorld());
-        this.location = location;
-        this.species = species;
-        this.bonemeal = bonemeal;
-        this.player = player;
-        this.blocks = blocks;
-    }
-
-    /**
-     * Gets the location of the structure.
-     *
-     * @return Location of the structure
-     */
-    public Location getLocation() {
-        return location;
-    }
-
-    /**
-     * Gets the species type (birch, normal, pine, red mushroom, brown
-     * mushroom)
-     *
-     * @return Structure species
-     */
-    public TreeType getSpecies() {
-        return species;
-    }
-
-    /**
-     * Checks if structure was grown using bonemeal.
-     *
-     * @return True if the structure was grown using bonemeal.
-     */
-    public boolean isFromBonemeal() {
-        return bonemeal;
-    }
-
-    /**
-     * Gets the player that created the structure.
-     *
-     * @return Player that created the structure, null if was not created
-     *     manually
-     */
-    public Player getPlayer() {
-        return player;
-    }
-
-    /**
-     * Gets an ArrayList of all blocks associated with the structure.
-     *
-     * @return ArrayList of all blocks associated with the structure.
-     */
-    public List<BlockState> getBlocks() {
-        return blocks;
-    }
-
-    public boolean isCancelled() {
-        return cancelled;
-    }
-
-    public void setCancelled(boolean cancel) {
-        cancelled = cancel;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/world/WorldEvent.java b/src/main/java/org/bukkit/event/world/WorldEvent.java
deleted file mode 100644
index bd89b81..0000000
--- a/src/main/java/org/bukkit/event/world/WorldEvent.java
+++ /dev/null
@@ -1,24 +0,0 @@
-package org.bukkit.event.world;
-
-import org.bukkit.World;
-import org.bukkit.event.Event;
-
-/**
- * Represents events within a world
- */
-public abstract class WorldEvent extends Event {
-    private final World world;
-
-    public WorldEvent(final World world) {
-        this.world = world;
-    }
-
-    /**
-     * Gets the world primarily involved with this event
-     *
-     * @return World which caused this event
-     */
-    public World getWorld() {
-        return world;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/world/WorldInitEvent.java b/src/main/java/org/bukkit/event/world/WorldInitEvent.java
deleted file mode 100644
index 6bf13e0..0000000
--- a/src/main/java/org/bukkit/event/world/WorldInitEvent.java
+++ /dev/null
@@ -1,24 +0,0 @@
-package org.bukkit.event.world;
-
-import org.bukkit.World;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a World is initializing
- */
-public class WorldInitEvent extends WorldEvent {
-    private static final HandlerList handlers = new HandlerList();
-
-    public WorldInitEvent(final World world) {
-        super(world);
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/world/WorldLoadEvent.java b/src/main/java/org/bukkit/event/world/WorldLoadEvent.java
deleted file mode 100644
index c5545aa1..0000000
--- a/src/main/java/org/bukkit/event/world/WorldLoadEvent.java
+++ /dev/null
@@ -1,24 +0,0 @@
-package org.bukkit.event.world;
-
-import org.bukkit.World;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a World is loaded
- */
-public class WorldLoadEvent extends WorldEvent {
-    private static final HandlerList handlers = new HandlerList();
-
-    public WorldLoadEvent(final World world) {
-        super(world);
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/world/WorldSaveEvent.java b/src/main/java/org/bukkit/event/world/WorldSaveEvent.java
deleted file mode 100644
index d46b413..0000000
--- a/src/main/java/org/bukkit/event/world/WorldSaveEvent.java
+++ /dev/null
@@ -1,24 +0,0 @@
-package org.bukkit.event.world;
-
-import org.bukkit.World;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a World is saved.
- */
-public class WorldSaveEvent extends WorldEvent {
-    private static final HandlerList handlers = new HandlerList();
-
-    public WorldSaveEvent(final World world) {
-        super(world);
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/event/world/WorldUnloadEvent.java b/src/main/java/org/bukkit/event/world/WorldUnloadEvent.java
deleted file mode 100644
index 110544b..0000000
--- a/src/main/java/org/bukkit/event/world/WorldUnloadEvent.java
+++ /dev/null
@@ -1,34 +0,0 @@
-package org.bukkit.event.world;
-
-import org.bukkit.World;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.HandlerList;
-
-/**
- * Called when a World is unloaded
- */
-public class WorldUnloadEvent extends WorldEvent implements Cancellable {
-    private static final HandlerList handlers = new HandlerList();
-    private boolean isCancelled;
-
-    public WorldUnloadEvent(final World world) {
-        super(world);
-    }
-
-    public boolean isCancelled() {
-        return this.isCancelled;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.isCancelled = cancel;
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/main/java/org/bukkit/generator/BlockPopulator.java b/src/main/java/org/bukkit/generator/BlockPopulator.java
deleted file mode 100644
index 6a70bdb..0000000
--- a/src/main/java/org/bukkit/generator/BlockPopulator.java
+++ /dev/null
@@ -1,29 +0,0 @@
-package org.bukkit.generator;
-
-import java.util.Random;
-import org.bukkit.Chunk;
-import org.bukkit.World;
-
-/**
- * A block populator is responsible for generating a small area of blocks.
- * <p>
- * For example, generating glowstone inside the nether or generating dungeons
- * full of treasure
- */
-public abstract class BlockPopulator {
-
-    /**
-     * Populates an area of blocks at or around the given chunk.
-     * <p>
-     * The chunks on each side of the specified chunk must already exist; that
-     * is, there must be one north, east, south and west of the specified
-     * chunk. The "corner" chunks may not exist, in which scenario the
-     * populator should record any changes required for those chunks and
-     * perform the changes when they are ready.
-     *
-     * @param world The world to generate in
-     * @param random The random generator to use
-     * @param source The chunk to generate for
-     */
-    public abstract void populate(World world, Random random, Chunk source);
-}
diff --git a/src/main/java/org/bukkit/generator/ChunkGenerator.java b/src/main/java/org/bukkit/generator/ChunkGenerator.java
deleted file mode 100644
index 5137024..0000000
--- a/src/main/java/org/bukkit/generator/ChunkGenerator.java
+++ /dev/null
@@ -1,495 +0,0 @@
-package org.bukkit.generator;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Random;
-import org.bukkit.Bukkit;
-import org.bukkit.Location;
-import org.bukkit.Material;
-import org.bukkit.World;
-import org.bukkit.block.Biome;
-import org.bukkit.block.Block;
-import org.bukkit.material.MaterialData;
-
-/**
- * A chunk generator is responsible for the initial shaping of an entire
- * chunk. For example, the nether chunk generator should shape netherrack and
- * soulsand
- */
-public abstract class ChunkGenerator {
-
-    /**
-     * Interface to biome section for chunk to be generated: initialized with
-     * default values for world type and seed.
-     * <p>
-     * Custom generator is free to access and tailor values during
-     * generateBlockSections() or generateExtBlockSections().
-     */
-    public interface BiomeGrid {
-
-        /**
-         * Get biome at x, z within chunk being generated
-         *
-         * @param x - 0-15
-         * @param z - 0-15
-         * @return Biome value
-         */
-        Biome getBiome(int x, int z);
-
-        /**
-         * Set biome at x, z within chunk being generated
-         *
-         * @param x - 0-15
-         * @param z - 0-15
-         * @param bio - Biome value
-         */
-        void setBiome(int x, int z, Biome bio);
-    }
-    @Deprecated
-    /**
-     * Shapes the chunk for the given coordinates.
-     * <p>
-     * This method should return a byte[32768] in the following format:
-     * <pre>
-     * for (int x = 0; x &lt; 16; x++) {
-     *     for (int z = 0; z &lt; 16; z++) {
-     *         for (int y = 0; y &lt; 128; y++) {
-     *             // result[(x * 16 + z) * 128 + y] = ??;
-     *         }
-     *     }
-     * }
-     * </pre>
-     * <p>
-     * Note that this method should <b>never</b> attempt to get the Chunk at
-     * the passed coordinates, as doing so may cause an infinite loop
-     * <p>
-     * Note this deprecated method will only be called when both
-     * generateExtBlockSections() and generateBlockSections() are
-     * unimplemented and return null.
-     *
-     * @param world The world this chunk will be used for
-     * @param random The random generator to use
-     * @param x The X-coordinate of the chunk
-     * @param z The Z-coordinate of the chunk
-     * @return byte[] containing the types for each block created by this
-     *     generator
-     */
-    public byte[] generate(World world, Random random, int x, int z) {
-        throw new UnsupportedOperationException("Custom generator is missing required methods: generate(), generateBlockSections() and generateExtBlockSections()");
-    }
-
-    /**
-     * Shapes the chunk for the given coordinates, with extended block IDs
-     * supported (0-4095).
-     * <p>
-     * As of 1.2, chunks are represented by a vertical array of chunk
-     * sections, each of which is 16 x 16 x 16 blocks. If a section is empty
-     * (all zero), the section does not need to be supplied, reducing memory
-     * usage.
-     * <p>
-     * This method must return a short[][] array in the following format:
-     * <pre>
-     *     short[][] result = new short[world-height / 16][];
-     * </pre>
-     * Each section {@code (sectionID = (Y>>4))} that has blocks needs to be allocated
-     * space for the 4096 blocks in that section:
-     * <pre>
-     *     result[sectionID] = new short[4096];
-     * </pre>
-     * while sections that are not populated can be left null.
-     * <p>
-     * Setting a block at X, Y, Z within the chunk can be done with the
-     * following mapping function:
-     * <pre>
-     *    void setBlock(short[][] result, int x, int y, int z, short blkid) {
-     *        {@code if (result[y >> 4] == null) {}
-     *            {@code result[y >> 4] = new short[4096];}
-     *        }
-     *        {@code result[y >> 4][((y & 0xF) << 8) | (z << 4) | x] = blkid;}
-     *    }
-     * </pre>
-     * while reading a block ID can be done with the following mapping
-     * function:
-     * <pre>
-     *    short getBlock(short[][] result, int x, int y, int z) {
-     *        {@code if (result[y >> 4] == null) {}
-     *            return (short)0;
-     *        }
-     *        {@code return result[y >> 4][((y & 0xF) << 8) | (z << 4) | x];}
-     *    }
-     * </pre>
-     * while sections that are not populated can be left null.
-     * <p>
-     * Setting a block at X, Y, Z within the chunk can be done with the
-     * following mapping function:
-     * <pre>
-     *    void setBlock(short[][] result, int x, int y, int z, short blkid) {
-     *        {@code if (result[y >> 4) == null) {}
-     *            {@code result[y >> 4] = new short[4096];}
-     *        }
-     *        {@code result[y >> 4][((y & 0xF) << 8) | (z << 4) | x] = blkid;}
-     *    }
-     * </pre>
-     * while reading a block ID can be done with the following mapping
-     * function:
-     * <pre>
-     *    short getBlock(short[][] result, int x, int y, int z) {
-     *        {@code if (result[y >> 4) == null) {}
-     *            return (short)0;
-     *        }
-     *        {@code return result[y >> 4][((y & 0xF) << 8) | (z << 4) | x];}
-     *    }
-     * </pre>
-     * <p>
-     * Note that this method should <b>never</b> attempt to get the Chunk at
-     * the passed coordinates, as doing so may cause an infinite loop
-     * <p>
-     * Note generators that do not return block IDs above 255 should not
-     * implement this method, or should have it return null (which will result
-     * in the generateBlockSections() method being called).
-     *
-     * @param world The world this chunk will be used for
-     * @param random The random generator to use
-     * @param x The X-coordinate of the chunk
-     * @param z The Z-coordinate of the chunk
-     * @param biomes Proposed biome values for chunk - can be updated by
-     *     generator
-     * @return short[][] containing the types for each block created by this
-     *     generator
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public short[][] generateExtBlockSections(World world, Random random, int x, int z, BiomeGrid biomes) {
-        return null; // Default - returns null, which drives call to generateBlockSections()
-    }
-
-    /**
-     * Shapes the chunk for the given coordinates.
-     * <p>
-     * As of 1.2, chunks are represented by a vertical array of chunk
-     * sections, each of which is 16 x 16 x 16 blocks.  If a section is empty
-     * (all zero), the section does not need to be supplied, reducing memory
-     * usage.
-     * <p>
-     * This method must return a byte[][] array in the following format:
-     * <pre>
-     *     byte[][] result = new byte[world-height / 16][];
-     * </pre>
-     * Each section {@code (sectionID = (Y>>4))} that has blocks needs to be allocated
-     * space for the 4096 blocks in that section:
-     * <pre>
-     *     result[sectionID] = new byte[4096];
-     * </pre>
-     * while sections that are not populated can be left null.
-     * <p>
-     * Setting a block at X, Y, Z within the chunk can be done with the
-     * following mapping function:
-     * <pre>
-     *    void setBlock(byte[][] result, int x, int y, int z, byte blkid) {
-     *        {@code if (result[y >> 4) == null) {}
-     *            {@code result[y >> 4] = new byte[4096];}
-     *        }
-     *        {@code result[y >> 4][((y & 0xF) << 8) | (z << 4) | x] = blkid;}
-     *    }
-     * </pre>
-     * while reading a block ID can be done with the following mapping
-     * function:
-     * <pre>
-     *    byte getBlock(byte[][] result, int x, int y, int z) {
-     *        {@code if (result[y >> 4) == null) {}
-     *            return (byte)0;
-     *        }
-     *        {@code return result[y >> 4][((y & 0xF) << 8) | (z << 4) | x];}
-     *    }
-     * </pre>
-     *
-     * Note that this method should <b>never</b> attempt to get the Chunk at
-     * the passed coordinates, as doing so may cause an infinite loop
-     *
-     * @param world The world this chunk will be used for
-     * @param random The random generator to use
-     * @param x The X-coordinate of the chunk
-     * @param z The Z-coordinate of the chunk
-     * @param biomes Proposed biome values for chunk - can be updated by
-     *     generator
-     * @return short[][] containing the types for each block created by this
-     *     generator
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public byte[][] generateBlockSections(World world, Random random, int x, int z, BiomeGrid biomes) {
-        return null; // Default - returns null, which drives call to generate()
-    }
-
-    /**
-     * Shapes the chunk for the given coordinates.
-     * 
-     * This method must return a ChunkData.
-     * <p>
-     * Notes:
-     * <p>
-     * This method should <b>never</b> attempt to get the Chunk at
-     * the passed coordinates, as doing so may cause an infinite loop
-     * <p>
-     * This method should <b>never</b> modify a ChunkData after it has
-     * been returned.
-     * <p>
-     * This method <b>must</b> return a ChunkData returned by {@link ChunkGenerator#createChunkData(org.bukkit.World)}
-     * 
-     * @param world The world this chunk will be used for
-     * @param random The random generator to use
-     * @param x The X-coordinate of the chunk
-     * @param z The Z-coordinate of the chunk
-     * @param biome Proposed biome values for chunk - can be updated by
-     *     generator
-     * @return ChunkData containing the types for each block created by this
-     *     generator
-     */
-    public ChunkData generateChunkData(World world, Random random, int x, int z, BiomeGrid biome) {
-        return null; // Default - returns null, which drives call to generateExtBlockSections()
-    }
-
-    /**
-     * Create a ChunkData for a world.
-     * @param world the world the ChunkData is for
-     * @return a new ChunkData for world
-     */
-    protected final ChunkData createChunkData(World world) {
-        return Bukkit.getServer().createChunkData(world);
-    }
-
-    /**
-     * Tests if the specified location is valid for a natural spawn position
-     *
-     * @param world The world we're testing on
-     * @param x X-coordinate of the block to test
-     * @param z Z-coordinate of the block to test
-     * @return true if the location is valid, otherwise false
-     */
-    public boolean canSpawn(World world, int x, int z) {
-        Block highest = world.getBlockAt(x, world.getHighestBlockYAt(x, z), z);
-
-        switch (world.getEnvironment()) {
-        case NETHER:
-            return true;
-        case THE_END:
-            return highest.getType() != Material.AIR && highest.getType() != Material.WATER && highest.getType() != Material.LAVA;
-        case NORMAL:
-        default:
-            return highest.getType() == Material.SAND || highest.getType() == Material.GRAVEL;
-        }
-    }
-
-    /**
-     * Gets a list of default {@link BlockPopulator}s to apply to a given
-     * world
-     *
-     * @param world World to apply to
-     * @return List containing any amount of BlockPopulators
-     */
-    public List<BlockPopulator> getDefaultPopulators(World world) {
-        return new ArrayList<BlockPopulator>();
-    }
-
-    /**
-     * Gets a fixed spawn location to use for a given world.
-     * <p>
-     * A null value is returned if a world should not use a fixed spawn point,
-     * and will instead attempt to find one randomly.
-     *
-     * @param world The world to locate a spawn point for
-     * @param random Random generator to use in the calculation
-     * @return Location containing a new spawn point, otherwise null
-     */
-    public Location getFixedSpawnLocation(World world, Random random) {
-        return null;
-    }
-
-    /**
-     * Data for a Chunk.
-     */
-    public static interface ChunkData {
-        /**
-         * Get the maximum height for the chunk.
-         * 
-         * Setting blocks at or above this height will do nothing.
-         * 
-         * @return the maximum height
-         */
-        public int getMaxHeight();
-
-        /**
-         * Set the block at x,y,z in the chunk data to material.
-         *
-         * Note: setting blocks outside the chunk's bounds does nothing.
-         *
-         * @param x the x location in the chunk from 0-15 inclusive
-         * @param y the y location in the chunk from 0 (inclusive) - maxHeight (exclusive)
-         * @param z the z location in the chunk from 0-15 inclusive
-         * @param material the type to set the block to
-         */
-        public void setBlock(int x, int y, int z, Material material);
-
-        /**
-         * Set the block at x,y,z in the chunk data to material.
-         *
-         * Setting blocks outside the chunk's bounds does nothing.
-         *
-         * @param x the x location in the chunk from 0-15 inclusive
-         * @param y the y location in the chunk from 0 (inclusive) - maxHeight (exclusive)
-         * @param z the z location in the chunk from 0-15 inclusive
-         * @param material the type to set the block to
-         */
-        public void setBlock(int x, int y, int z, MaterialData material);
-        
-        /**
-         * Set a region of this chunk from xMin, yMin, zMin (inclusive)
-         * to xMax, yMax, zMax (exclusive) to material.
-         *
-         * Setting blocks outside the chunk's bounds does nothing.
-         *
-         * @param xMin minimum x location (inclusive) in the chunk to set
-         * @param yMin minimum y location (inclusive) in the chunk to set
-         * @param zMin minimum z location (inclusive) in the chunk to set
-         * @param xMax maximum x location (exclusive) in the chunk to set
-         * @param yMax maximum y location (exclusive) in the chunk to set
-         * @param zMax maximum z location (exclusive) in the chunk to set
-         * @param material the type to set the blocks to
-         */
-        public void setRegion(int xMin, int yMin, int zMin, int xMax, int yMax, int zMax, Material material);
-        
-        /**
-         * Set a region of this chunk from xMin, yMin, zMin (inclusive)
-         * to xMax, yMax, zMax (exclusive) to material.
-         *
-         * Setting blocks outside the chunk's bounds does nothing.
-         *
-         * @param xMin minimum x location (inclusive) in the chunk to set
-         * @param yMin minimum y location (inclusive) in the chunk to set
-         * @param zMin minimum z location (inclusive) in the chunk to set
-         * @param xMax maximum x location (exclusive) in the chunk to set
-         * @param yMax maximum y location (exclusive) in the chunk to set
-         * @param zMax maximum z location (exclusive) in the chunk to set
-         * @param material the type to set the blocks to
-         */
-        public void setRegion(int xMin, int yMin, int zMin, int xMax, int yMax, int zMax, MaterialData material);
-        
-        /**
-         * Get the type of the block at x, y, z.
-         *
-         * Getting blocks outside the chunk's bounds returns air.
-         *
-         * @param x the x location in the chunk from 0-15 inclusive
-         * @param y the y location in the chunk from 0 (inclusive) - maxHeight (exclusive)
-         * @param z the z location in the chunk from 0-15 inclusive
-         * @return the type of the block or Material.AIR if x, y or z are outside the chunk's bounds
-         */
-        public Material getType(int x, int y, int z);
-        
-        /**
-         * Get the type and data of the block at x, y ,z.
-         *
-         * Getting blocks outside the chunk's bounds returns air.
-         *
-         * @param x the x location in the chunk from 0-15 inclusive
-         * @param y the y location in the chunk from 0 (inclusive) - maxHeight (exclusive)
-         * @param z the z location in the chunk from 0-15 inclusive
-         * @return the type and data of the block or the MaterialData for air if x, y or z are outside the chunk's bounds
-         */
-        public MaterialData getTypeAndData(int x, int y, int z);
-        
-        /**
-         * Set a region of this chunk from xMin, yMin, zMin (inclusive)
-         * to xMax, yMax, zMax (exclusive) to block id.
-         *
-         * Setting blocks outside the chunk's bounds does nothing.
-         *
-         * @param xMin minimum x location (inclusive) in the chunk to set
-         * @param yMin minimum y location (inclusive) in the chunk to set
-         * @param zMin minimum z location (inclusive) in the chunk to set
-         * @param xMax maximum x location (exclusive) in the chunk to set
-         * @param yMax maximum y location (exclusive) in the chunk to set
-         * @param zMax maximum z location (exclusive) in the chunk to set
-         * @param blockId the block id to set the blocks to
-         * @deprecated Uses magic values.
-         */
-        @Deprecated
-        public void setRegion(int xMin, int yMin, int zMin, int xMax, int yMax, int zMax, int blockId);
-        
-        /**
-         * Set a region of this chunk from xMin, yMin, zMin (inclusive)
-         * to xMax, yMax, zMax (exclusive) to block id and data.
-         *
-         * Setting blocks outside the chunk's bounds does nothing.
-         *
-         * @param xMin minimum x location (inclusive) in the chunk to set
-         * @param yMin minimum y location (inclusive) in the chunk to set
-         * @param zMin minimum z location (inclusive) in the chunk to set
-         * @param xMax maximum x location (exclusive) in the chunk to set
-         * @param yMax maximum y location (exclusive) in the chunk to set
-         * @param zMax maximum z location (exclusive) in the chunk to set
-         * @param blockId the block id to set the blocks to
-         * @param data the block data to set the blocks to
-         * @deprecated Uses magic values.
-         */
-        @Deprecated
-        public void setRegion(int xMin, int yMin, int zMin, int xMax, int yMax, int zMax, int blockId, int data);
-        
-        /**
-         * Set the block at x,y,z in the chunk data to blockId.
-         *
-         * Setting blocks outside the chunk's bounds does nothing.
-         *
-         * @param x the x location in the chunk from 0-15 inclusive
-         * @param y the y location in the chunk from 0 (inclusive) - maxHeight (exclusive)
-         * @param z the z location in the chunk from 0-15 inclusive
-         * @param blockId the blockId to set the block to
-         * @deprecated Uses magic values
-         */
-        @Deprecated
-        public void setBlock(int x, int y, int z, int blockId);
-        
-        /**
-         * Set the block at x,y,z in the chunk data to blockId.
-         *
-         * Setting blocks outside the chunk's bounds does nothing.
-         *
-         * @param x the x location in the chunk from 0-15 inclusive
-         * @param y the y location in the chunk from 0 (inclusive) - maxHeight (exclusive)
-         * @param z the z location in the chunk from 0-15 inclusive
-         * @param blockId the blockId to set the block to
-         * @param data the block data to set the block to
-         * @deprecated Uses magic values
-         */
-        @Deprecated
-        public void setBlock(int x, int y, int z, int blockId, byte data);
-        
-        /**
-         * Get the blockId at x,y,z in the chunk data.
-         *
-         * Getting blocks outside the chunk's bounds returns 0.
-         *
-         * @param x the x location in the chunk from 0-15 inclusive
-         * @param y the y location in the chunk from 0 (inclusive) - maxHeight (exclusive)
-         * @param z the z location in the chunk from 0-15 inclusive
-         * @return the block id or 0 if x, y or z are outside the chunk's bounds
-         * @deprecated Uses magic values
-         */
-        @Deprecated
-        public int getTypeId(int x, int y, int z);
-        
-        /**
-         * Get the block data at x,y,z in the chunk data.
-         *
-         * Getting blocks outside the chunk's bounds returns 0.
-         *
-         * @param x the x location in the chunk from 0-15 inclusive
-         * @param y the y location in the chunk from 0 (inclusive) - maxHeight (exclusive)
-         * @param z the z location in the chunk from 0-15 inclusive
-         * @return the block data value or air if x, y or z are outside the chunk's bounds
-         * @deprecated Uses magic values
-         */
-        @Deprecated
-        public byte getData(int x, int y, int z);
-    }
-}
diff --git a/src/main/java/org/bukkit/help/GenericCommandHelpTopic.java b/src/main/java/org/bukkit/help/GenericCommandHelpTopic.java
deleted file mode 100644
index 3e85e77..0000000
--- a/src/main/java/org/bukkit/help/GenericCommandHelpTopic.java
+++ /dev/null
@@ -1,80 +0,0 @@
-package org.bukkit.help;
-
-import org.bukkit.ChatColor;
-import org.bukkit.command.Command;
-import org.bukkit.command.CommandSender;
-import org.apache.commons.lang.StringUtils;
-import org.bukkit.command.ConsoleCommandSender;
-import org.bukkit.command.PluginCommand;
-import org.bukkit.command.defaults.VanillaCommand;
-import org.bukkit.help.HelpTopic;
-
-/**
- * Lacking an alternative, the help system will create instances of
- * GenericCommandHelpTopic for each command in the server's CommandMap. You
- * can use this class as a base class for custom help topics, or as an example
- * for how to write your own.
- */
-public class GenericCommandHelpTopic extends HelpTopic {
-
-    protected Command command;
-
-    public GenericCommandHelpTopic(Command command) {
-        this.command = command;
-
-        if (command.getLabel().startsWith("/")) {
-            name = command.getLabel();
-        } else {
-            name = "/" + command.getLabel();
-        }
-
-        // The short text is the first line of the description
-        int i = command.getDescription().indexOf("\n");
-        if (i > 1) {
-            shortText = command.getDescription().substring(0, i - 1);
-        } else {
-            shortText = command.getDescription();
-        }
-
-        // Build full text
-        StringBuffer sb = new StringBuffer();
-
-        sb.append(ChatColor.GOLD);
-        sb.append("Description: ");
-        sb.append(ChatColor.WHITE);
-        sb.append(command.getDescription());
-
-        sb.append("\n");
-
-        sb.append(ChatColor.GOLD);
-        sb.append("Usage: ");
-        sb.append(ChatColor.WHITE);
-        sb.append(command.getUsage().replace("<command>", name.substring(1)));
-
-        if (command.getAliases().size() > 0) {
-            sb.append("\n");
-            sb.append(ChatColor.GOLD);
-            sb.append("Aliases: ");
-            sb.append(ChatColor.WHITE);
-            sb.append(ChatColor.WHITE + StringUtils.join(command.getAliases(), ", "));
-        }
-        fullText = sb.toString();
-    }
-
-    public boolean canSee(CommandSender sender) {
-        if (!command.isRegistered() && !(command instanceof VanillaCommand)) {
-            // Unregistered commands should not show up in the help (ignore VanillaCommands)
-            return false;
-        }
-
-        if (sender instanceof ConsoleCommandSender) {
-            return true;
-        }
-
-        if (amendedPermission != null) {
-            return sender.hasPermission(amendedPermission);
-        } else {
-            return command.testPermissionSilent(sender);
-        }
-    }
-}
diff --git a/src/main/java/org/bukkit/help/HelpMap.java b/src/main/java/org/bukkit/help/HelpMap.java
deleted file mode 100644
index 43017c8..0000000
--- a/src/main/java/org/bukkit/help/HelpMap.java
+++ /dev/null
@@ -1,79 +0,0 @@
-package org.bukkit.help;
-
-import java.util.Collection;
-import java.util.List;
-
-/**
- * The HelpMap tracks all help topics registered in a Bukkit server. When the
- * server starts up or is reloaded, help is processed and topics are added in
- * the following order:
- * 
- * <ol>
- * <li>General topics are loaded from the help.yml
- * <li>Plugins load and optionally call {@code addTopic()}
- * <li>Registered plugin commands are processed by {@link HelpTopicFactory}
- *     objects to create topics
- * <li>Topic contents are amended as directed in help.yml
- * </ol>
- */
-public interface HelpMap {
-    /**
-     * Returns a help topic for a given topic name.
-     *
-     * @param topicName The help topic name to look up.
-     * @return A {@link HelpTopic} object matching the topic name or null if
-     *     none can be found.
-     */
-    public HelpTopic getHelpTopic(String topicName);
-
-    /**
-     * Returns a collection of all the registered help topics.
-     *
-     * @return All the registered help topics.
-     */
-    public Collection<HelpTopic> getHelpTopics();
-    
-    /**
-     * Adds a topic to the server's help index.
-     *
-     * @param topic The new help topic to add.
-     */
-    public void addTopic(HelpTopic topic);
-
-    /**
-     * Clears out the contents of the help index. Normally called during
-     * server reload.
-     */
-    public void clear();
-
-    /**
-     * Associates a {@link HelpTopicFactory} object with given command base
-     * class. Plugins typically call this method during {@code onLoad()}. Once
-     * registered, the custom HelpTopicFactory will be used to create a custom
-     * {@link HelpTopic} for all commands deriving from the {@code
-     * commandClass} base class, or all commands deriving from {@link
-     * org.bukkit.command.PluginCommand} who's executor derives from {@code
-     * commandClass} base class.
-     *
-     * @param commandClass The class for which the custom HelpTopicFactory
-     *     applies. Must derive from either {@link org.bukkit.command.Command}
-     *     or {@link org.bukkit.command.CommandExecutor}.
-     * @param factory The {@link HelpTopicFactory} implementation to associate
-     *     with the {@code commandClass}.
-     * @throws IllegalArgumentException Thrown if {@code commandClass} does
-     *     not derive from a legal base class.
-     */
-    public void registerHelpTopicFactory(Class<?> commandClass, HelpTopicFactory<?> factory);
-
-    /**
-     * Gets the list of plugins the server administrator has chosen to exclude
-     * from the help index. Plugin authors who choose to directly extend
-     * {@link org.bukkit.command.Command} instead of {@link
-     * org.bukkit.command.PluginCommand} will need to check this collection in
-     * their {@link HelpTopicFactory} implementations to ensure they meet the
-     * server administrator's expectations.
-     *
-     * @return A list of plugins that should be excluded from the help index.
-     */
-    public List<String> getIgnoredPlugins();
-}
diff --git a/src/main/java/org/bukkit/help/HelpTopic.java b/src/main/java/org/bukkit/help/HelpTopic.java
deleted file mode 100644
index a2ba5f5..0000000
--- a/src/main/java/org/bukkit/help/HelpTopic.java
+++ /dev/null
@@ -1,121 +0,0 @@
-package org.bukkit.help;
-
-import org.bukkit.command.CommandSender;
-import org.bukkit.entity.Player;
-
-/**
- * HelpTopic implementations are displayed to the user when the user uses the
- * /help command.
- * <p>
- * Custom implementations of this class can work at two levels. A simple
- * implementation only needs to set the value of {@code name}, {@code
- * shortText}, and {@code fullText} in the constructor. This base class will
- * take care of the rest.
- * <p>
- * Complex implementations can be created by overriding the behavior of all
- * the methods in this class.
- */
-public abstract class HelpTopic {
-    protected String name;
-    protected String shortText;
-    protected String fullText;
-    protected String amendedPermission;
-    
-    /**
-     * Determines if a {@link Player} is allowed to see this help topic.
-     * <p>
-     * HelpTopic implementations should take server administrator wishes into
-     * account as set by the {@link HelpTopic#amendCanSee(String)} function.
-     *
-     * @param player The Player in question.
-     * @return True of the Player can see this help topic, false otherwise.
-     */
-    public abstract boolean canSee(CommandSender player);
-
-    /**
-     * Allows the server administrator to override the permission required to
-     * see a help topic.
-     * <p>
-     * HelpTopic implementations should take this into account when
-     * determining topic visibility on the {@link
-     * HelpTopic#canSee(org.bukkit.command.CommandSender)} function.
-     *
-     * @param amendedPermission The permission node the server administrator
-     *     wishes to apply to this topic.
-     */
-    public void amendCanSee(String amendedPermission) {
-        this.amendedPermission = amendedPermission;
-    }
-
-    /**
-     * Returns the name of this help topic.
-     *
-     * @return The topic name.
-     */
-    public String getName() {
-        return name;
-    }
-
-    /**
-     * Returns a brief description that will be displayed in the topic index.
-     *
-     * @return A brief topic description.
-     */
-    public String getShortText() {
-        return shortText;
-    }
-
-    /**
-     * Returns the full description of this help topic that is displayed when
-     * the user requests this topic's details.
-     * <p>
-     * The result will be paginated to properly fit the user's client.
-     *
-     * @param forWho The player or console requesting the full text. Useful
-     *     for further security trimming the command's full text based on
-     *     sub-permissions in custom implementations.
-     *
-     * @return A full topic description.
-     */
-    public String getFullText(CommandSender forWho) {
-        return fullText;
-    }
-
-    /**
-     * Allows the server admin (or another plugin) to add or replace the
-     * contents of a help topic.
-     * <p>
-     * A null in either parameter will leave that part of the topic unchanged.
-     * In either amending parameter, the string {@literal <text>} is replaced
-     * with the existing contents in the help topic. Use this to append or
-     * prepend additional content into an automatically generated help topic.
-     *
-     * @param amendedShortText The new topic short text to use, or null to
-     *     leave alone.
-     * @param amendedFullText The new topic full text to use, or null to leave
-     *     alone.
-     */
-    public void amendTopic(String amendedShortText, String amendedFullText) {
-        shortText = applyAmendment(shortText, amendedShortText);
-        fullText = applyAmendment(fullText, amendedFullText);
-    }
-
-    /**
-     * Developers implementing their own custom HelpTopic implementations can
-     * use this utility method to ensure their implementations comply with the
-     * expected behavior of the {@link HelpTopic#amendTopic(String, String)}
-     * method.
-     *
-     * @param baseText The existing text of the help topic.
-     * @param amendment The amending text from the amendTopic() method.
-     * @return The application of the amending text to the existing text,
-     *     according to the expected rules of amendTopic().
-     */
-    protected String applyAmendment(String baseText, String amendment) {
-        if (amendment == null) {
-            return baseText;
-        } else {
-            return amendment.replaceAll("<text>", baseText);
-        }
-    }
-}
diff --git a/src/main/java/org/bukkit/help/HelpTopicComparator.java b/src/main/java/org/bukkit/help/HelpTopicComparator.java
deleted file mode 100644
index 3e43eb3..0000000
--- a/src/main/java/org/bukkit/help/HelpTopicComparator.java
+++ /dev/null
@@ -1,48 +0,0 @@
-package org.bukkit.help;
-
-import org.bukkit.help.HelpTopic;
-
-import java.util.Comparator;
-
-/**
- * Used to impose a custom total ordering on help topics.
- * <p>
- * All topics are listed in alphabetic order, but topics that start with a
- * slash come after topics that don't.
- */
-public class HelpTopicComparator implements Comparator<HelpTopic> {
-    
-    // Singleton implementations
-    private static final TopicNameComparator tnc = new TopicNameComparator();
-    public static TopicNameComparator topicNameComparatorInstance() {
-        return tnc;
-    }
-    
-    private static final HelpTopicComparator htc = new HelpTopicComparator();
-    public static HelpTopicComparator helpTopicComparatorInstance() {
-        return htc;
-    }
-    
-    private HelpTopicComparator() {}
-
-    public int compare(HelpTopic lhs, HelpTopic rhs) {
-        return tnc.compare(lhs.getName(), rhs.getName());
-    }
-
-    public static class TopicNameComparator implements Comparator<String> {
-        private TopicNameComparator(){}
-        
-        public int compare(String lhs, String rhs) {
-            boolean lhsStartSlash = lhs.startsWith("/");
-            boolean rhsStartSlash = rhs.startsWith("/");
-            
-            if (lhsStartSlash && !rhsStartSlash) {
-                return 1;
-            } else if (!lhsStartSlash && rhsStartSlash) {
-                return -1;
-            } else {
-                return lhs.compareToIgnoreCase(rhs);
-            }
-        }
-    }
-}
diff --git a/src/main/java/org/bukkit/help/HelpTopicFactory.java b/src/main/java/org/bukkit/help/HelpTopicFactory.java
deleted file mode 100644
index 87d3697..0000000
--- a/src/main/java/org/bukkit/help/HelpTopicFactory.java
+++ /dev/null
@@ -1,42 +0,0 @@
-package org.bukkit.help;
-
-import org.bukkit.command.Command;
-
-/**
- * A HelpTopicFactory is used to create custom {@link HelpTopic} objects from
- * commands that inherit from a common base class or have executors that
- * inherit from a common base class. You can use a custom HelpTopic to change
- * the way all the commands in your plugin display in the help. If your plugin
- * implements a complex permissions system, a custom help topic may also be
- * appropriate.
- * <p>
- * To automatically bind your plugin's commands to your custom HelpTopic
- * implementation, first make sure all your commands or executors derive from
- * a custom base class (it doesn't have to do anything). Next implement a
- * custom HelpTopicFactory that accepts your custom command base class and
- * instantiates an instance of your custom HelpTopic from it. Finally,
- * register your HelpTopicFactory against your command base class using the
- * {@link HelpMap#registerHelpTopicFactory(Class, HelpTopicFactory)} method.
- * <p>
- * As the help system iterates over all registered commands to make help
- * topics, it first checks to see if there is a HelpTopicFactory registered
- * for the command's base class. If so, the factory is used to make a help
- * topic rather than a generic help topic. If no factory is found for the
- * command's base class and the command derives from {@link
- * org.bukkit.command.PluginCommand}, then the type of the command's executor
- * is inspected looking for a registered HelpTopicFactory. Finally, if no
- * factory is found, a generic help topic is created for the command.
- *
- * @param <TCommand> The base class for your custom commands.
- */
-public interface HelpTopicFactory<TCommand extends Command> {
-    /**
-     * This method accepts a command deriving from a custom command base class
-     * and constructs a custom HelpTopic for it.
-     *
-     * @param command The custom command to build a help topic for.
-     * @return A new custom help topic or {@code null} to intentionally NOT
-     *     create a topic.
-     */
-    public HelpTopic createTopic(TCommand command);
-}
diff --git a/src/main/java/org/bukkit/help/IndexHelpTopic.java b/src/main/java/org/bukkit/help/IndexHelpTopic.java
deleted file mode 100644
index c474031..0000000
--- a/src/main/java/org/bukkit/help/IndexHelpTopic.java
+++ /dev/null
@@ -1,112 +0,0 @@
-package org.bukkit.help;
-
-import org.bukkit.ChatColor;
-import org.bukkit.command.CommandSender;
-import org.bukkit.command.ConsoleCommandSender;
-import org.bukkit.entity.Player;
-import org.bukkit.util.ChatPaginator;
-
-import java.util.Collection;
-
-/**
- * This help topic generates a list of other help topics. This class is useful
- * for adding your own index help topics. To enforce a particular order, use a
- * sorted collection.
- * <p>
- * If a preamble is provided to the constructor, that text will be displayed
- * before the first item in the index.
- */
-public class IndexHelpTopic extends HelpTopic {
-
-    protected String permission;
-    protected String preamble;
-    protected Collection<HelpTopic> allTopics;
-
-    public IndexHelpTopic(String name, String shortText, String permission, Collection<HelpTopic> topics) {
-        this(name, shortText, permission, topics, null);
-    }
-
-    public IndexHelpTopic(String name, String shortText, String permission, Collection<HelpTopic> topics, String preamble) {
-        this.name = name;
-        this.shortText = shortText;
-        this.permission = permission;
-        this.preamble = preamble;
-        setTopicsCollection(topics);
-    }
-
-    /**
-     * Sets the contents of the internal allTopics collection.
-     *
-     * @param topics The topics to set.
-     */
-    protected void setTopicsCollection(Collection<HelpTopic> topics) {
-        this.allTopics = topics;
-    }
-
-    public boolean canSee(CommandSender sender) {
-        if (sender instanceof ConsoleCommandSender) {
-            return true;
-        }
-        if (permission == null) {
-            return true;
-        }
-        return sender.hasPermission(permission);
-    }
-
-    @Override
-    public void amendCanSee(String amendedPermission) {
-        permission = amendedPermission;
-    }
-
-    public String getFullText(CommandSender sender) {
-        StringBuilder sb = new StringBuilder();
-
-        if (preamble != null) {
-            sb.append(buildPreamble(sender));
-            sb.append("\n");
-        }
-
-        for (HelpTopic topic : allTopics) {
-            if (topic.canSee(sender)) {
-                String lineStr = buildIndexLine(sender, topic).replace("\n", ". ");
-                if (sender instanceof Player && lineStr.length() > ChatPaginator.GUARANTEED_NO_WRAP_CHAT_PAGE_WIDTH) {
-                    sb.append(lineStr.substring(0, ChatPaginator.GUARANTEED_NO_WRAP_CHAT_PAGE_WIDTH - 3));
-                    sb.append("...");
-                } else {
-                    sb.append(lineStr);
-                }
-                sb.append("\n");
-            }
-        }
-        return sb.toString();
-    }
-
-    /**
-     * Builds the topic preamble. Override this method to change how the index
-     * preamble looks.
-     *
-     * @param sender The command sender requesting the preamble.
-     * @return The topic preamble.
-     */
-    protected String buildPreamble(CommandSender sender) {
-        return ChatColor.GRAY + preamble;
-    }
-
-    /**
-     * Builds individual lines in the index topic. Override this method to
-     * change how index lines are rendered.
-     *
-     * @param sender The command sender requesting the index line.
-     * @param topic  The topic to render into an index line.
-     * @return The rendered index line.
-     */
-    protected String buildIndexLine(CommandSender sender, HelpTopic topic) {
-        StringBuilder line = new StringBuilder();
-        line.append(ChatColor.GOLD);
-        line.append(topic.getName());
-        line.append(": ");
-        line.append(ChatColor.WHITE);
-        line.append(topic.getShortText());
-        return line.toString();
-    }
-}
diff --git a/src/main/java/org/bukkit/inventory/AnvilInventory.java b/src/main/java/org/bukkit/inventory/AnvilInventory.java
deleted file mode 100644
index 70fae71..0000000
--- a/src/main/java/org/bukkit/inventory/AnvilInventory.java
+++ /dev/null
@@ -1,7 +0,0 @@
-package org.bukkit.inventory;
-
-/**
- * Interface to the inventory of an Anvil.
- */
-public interface AnvilInventory extends Inventory {
-}
diff --git a/src/main/java/org/bukkit/inventory/BeaconInventory.java b/src/main/java/org/bukkit/inventory/BeaconInventory.java
deleted file mode 100644
index 2f8769e..0000000
--- a/src/main/java/org/bukkit/inventory/BeaconInventory.java
+++ /dev/null
@@ -1,21 +0,0 @@
-package org.bukkit.inventory;
-
-/**
- * Interface to the inventory of a Beacon.
- */
-public interface BeaconInventory extends Inventory {
-
-    /**
-     * Set the item powering the beacon.
-     *
-     * @param item The new item
-     */
-    void setItem(ItemStack item);
-
-    /**
-     * Get the item powering the beacon.
-     *
-     * @return The current item.
-     */
-    ItemStack getItem();
-}
diff --git a/src/main/java/org/bukkit/inventory/BrewerInventory.java b/src/main/java/org/bukkit/inventory/BrewerInventory.java
deleted file mode 100644
index 3aaf17e..0000000
--- a/src/main/java/org/bukkit/inventory/BrewerInventory.java
+++ /dev/null
@@ -1,41 +0,0 @@
-package org.bukkit.inventory;
-
-import org.bukkit.Material;
-import org.bukkit.block.BrewingStand;
-
-/**
- * Interface to the inventory of a Brewing Stand.
- */
-public interface BrewerInventory extends Inventory {
-
-    /**
-     * Get the current ingredient for brewing.
-     *
-     * @return The ingredient.
-     */
-    ItemStack getIngredient();
-
-    /**
-     * Set the current ingredient for brewing.
-     *
-     * @param ingredient The ingredient
-     */
-    void setIngredient(ItemStack ingredient);
-
-    /**
-     * Get the current fuel for brewing.
-     *
-     * @return The fuel
-     */
-    ItemStack getFuel();
-
-    /**
-     * Set the current fuel for brewing. Generally only
-     * {@link Material#BLAZE_POWDER} will be of use.
-     *
-     * @param fuel The fuel
-     */
-    void setFuel(ItemStack fuel);
-
-    BrewingStand getHolder();
-}
diff --git a/src/main/java/org/bukkit/inventory/CraftingInventory.java b/src/main/java/org/bukkit/inventory/CraftingInventory.java
deleted file mode 100644
index f71533c..0000000
--- a/src/main/java/org/bukkit/inventory/CraftingInventory.java
+++ /dev/null
@@ -1,45 +0,0 @@
-package org.bukkit.inventory;
-
-/**
- * Interface to the crafting inventories
- */
-public interface CraftingInventory extends Inventory {
-
-    /**
-     * Check what item is in the result slot of this crafting inventory.
-     *
-     * @return The result item.
-     */
-    ItemStack getResult();
-
-    /**
-     * Get the contents of the crafting matrix.
-     *
-     * @return The contents.
-     */
-    ItemStack[] getMatrix();
-
-    /**
-     * Set the item in the result slot of the crafting inventory.
-     *
-     * @param newResult The new result item.
-     */
-    void setResult(ItemStack newResult);
-
-    /**
-     * Replace the contents of the crafting matrix
-     *
-     * @param contents The new contents.
-     * @throws IllegalArgumentException if the length of contents is greater
-     *     than the size of the crafting matrix.
-     */
-    void setMatrix(ItemStack[] contents);
-
-    /**
-     * Get the current recipe formed on the crafting inventory, if any.
-     *
-     * @return The recipe, or null if the current contents don't match any
-     *     recipe.
-     */
-    Recipe getRecipe();
-}
\ No newline at end of file
diff --git a/src/main/java/org/bukkit/inventory/DoubleChestInventory.java b/src/main/java/org/bukkit/inventory/DoubleChestInventory.java
deleted file mode 100644
index c03ad53..0000000
--- a/src/main/java/org/bukkit/inventory/DoubleChestInventory.java
+++ /dev/null
@@ -1,25 +0,0 @@
-package org.bukkit.inventory;
-
-import org.bukkit.block.DoubleChest;
-
-/**
- * Interface to the inventory of a Double Chest.
- */
-public interface DoubleChestInventory extends Inventory {
-
-    /**
-     * Get the left half of this double chest.
-     *
-     * @return The left side inventory
-     */
-    Inventory getLeftSide();
-
-    /**
-     * Get the right side of this double chest.
-     *
-     * @return The right side inventory
-     */
-    Inventory getRightSide();
-
-    DoubleChest getHolder();
-}
diff --git a/src/main/java/org/bukkit/inventory/EnchantingInventory.java b/src/main/java/org/bukkit/inventory/EnchantingInventory.java
deleted file mode 100644
index 6551a16..0000000
--- a/src/main/java/org/bukkit/inventory/EnchantingInventory.java
+++ /dev/null
@@ -1,35 +0,0 @@
-package org.bukkit.inventory;
-
-/**
- * Interface to the inventory of an Enchantment Table.
- */
-public interface EnchantingInventory extends Inventory {
-
-    /**
-     * Set the item being enchanted.
-     *
-     * @param item The new item
-     */
-    void setItem(ItemStack item);
-
-    /**
-     * Get the item being enchanted.
-     *
-     * @return The current item.
-     */
-    ItemStack getItem();
-
-    /**
-     * Set the secondary item being used for the enchant.
-     *
-     * @param item The new item
-     */
-    void setSecondary(ItemStack item);
-
-    /**
-     * Get the secondary item being used for the enchant.
-     *
-     * @return The second item
-     */
-    ItemStack getSecondary();
-}
diff --git a/src/main/java/org/bukkit/inventory/EntityEquipment.java b/src/main/java/org/bukkit/inventory/EntityEquipment.java
deleted file mode 100644
index da1eb4e..0000000
--- a/src/main/java/org/bukkit/inventory/EntityEquipment.java
+++ /dev/null
@@ -1,323 +0,0 @@
-package org.bukkit.inventory;
-
-import org.bukkit.entity.Entity;
-
-/**
- * An interface to a creatures inventory
- */
-public interface EntityEquipment {
-
-    /**
-     * Gets a copy of the item the entity is currently holding
-     * in their main hand.
-     *
-     * @return the currently held item
-     */
-    ItemStack getItemInMainHand();
-
-    /**
-     * Sets the item the entity is holding in their main hand.
-     *
-     * @param item The item to put into the entities hand
-     */
-    void setItemInMainHand(ItemStack item);
-
-    /**
-     * Gets a copy of the item the entity is currently holding
-     * in their off hand.
-     *
-     * @return the currently held item
-     */
-    ItemStack getItemInOffHand();
-
-    /**
-     * Sets the item the entity is holding in their off hand.
-     *
-     * @param item The item to put into the entities hand
-     */
-    void setItemInOffHand(ItemStack item);
-
-    /**
-     * Gets a copy of the item the entity is currently holding
-     *
-     * @deprecated entities can duel wield now use the methods for the
-     *      specific hand instead
-     * @see #getItemInMainHand()
-     * @see #getItemInOffHand()
-     * @return the currently held item
-     */
-    @Deprecated
-    ItemStack getItemInHand();
-
-    /**
-     * Sets the item the entity is holding
-     *
-     * @deprecated entities can duel wield now use the methods for the
-     *      specific hand instead
-     * @see #setItemInMainHand(ItemStack)
-     * @see #setItemInOffHand(ItemStack)
-     * @param stack The item to put into the entities hand
-     */
-    @Deprecated
-    void setItemInHand(ItemStack stack);
-
-    /**
-     * Gets a copy of the helmet currently being worn by the entity
-     *
-     * @return The helmet being worn
-     */
-    ItemStack getHelmet();
-
-    /**
-     * Sets the helmet worn by the entity
-     *
-     * @param helmet The helmet to put on the entity
-     */
-    void setHelmet(ItemStack helmet);
-
-    /**
-     * Gets a copy of the chest plate currently being worn by the entity
-     *
-     * @return The chest plate being worn
-     */
-    ItemStack getChestplate();
-
-    /**
-     * Sets the chest plate worn by the entity
-     *
-     * @param chestplate The chest plate to put on the entity
-     */
-    void setChestplate(ItemStack chestplate);
-
-    /**
-     * Gets a copy of the leggings currently being worn by the entity
-     *
-     * @return The leggings being worn
-     */
-    ItemStack getLeggings();
-
-    /**
-     * Sets the leggings worn by the entity
-     *
-     * @param leggings The leggings to put on the entity
-     */
-    void setLeggings(ItemStack leggings);
-
-    /**
-     * Gets a copy of the boots currently being worn by the entity
-     *
-     * @return The boots being worn
-     */
-    ItemStack getBoots();
-
-    /**
-     * Sets the boots worn by the entity
-     *
-     * @param boots The boots to put on the entity
-     */
-    void setBoots(ItemStack boots);
-
-    /**
-     * Gets a copy of all worn armor
-     *
-     * @return The array of worn armor
-     */
-    ItemStack[] getArmorContents();
-
-    /**
-     * Sets the entities armor to the provided array of ItemStacks
-     *
-     * @param items The items to set the armor as
-     */
-    void setArmorContents(ItemStack[] items);
-
-    /**
-     * Clears the entity of all armor and held items
-     */
-    void clear();
-
-    /**
-     * @deprecated entities can duel wield now use the methods for the specific
-     * hand instead
-     * @see #getItemInMainHandDropChance()
-     * @see #getItemInOffHandDropChance()
-     * @return drop chance
-     */
-    @Deprecated
-    float getItemInHandDropChance();
-
-    /**
-     * @deprecated entities can duel wield now use the methods for the specific
-     * hand instead
-     * @see #setItemInMainHandDropChance(float)
-     * @see #setItemInOffHandDropChance(float)
-     * @param chance drop chance
-     */
-    @Deprecated
-    void setItemInHandDropChance(float chance);
-
-    /**
-     * Gets the chance of the main hand item being dropped upon this creature's
-     * death.
-     *
-     * <ul>
-     * <li>A drop chance of 0F will never drop
-     * <li>A drop chance of 1F will always drop
-     * </ul>
-     *
-     * @return chance of the currently held item being dropped (1 for players)
-     */
-    float getItemInMainHandDropChance();
-
-    /**
-     * Sets the chance of the item this creature is currently holding in their
-     * main hand being dropped upon this creature's death.
-     *
-     * <ul>
-     * <li>A drop chance of 0F will never drop
-     * <li>A drop chance of 1F will always drop
-     * </ul>
-     *
-     * @param chance the chance of the main hand item being dropped
-     * @throws UnsupportedOperationException when called on players
-     */
-    void setItemInMainHandDropChance(float chance);
-
-    /**
-     * Gets the chance of the off hand item being dropped upon this creature's
-     * death.
-     *
-     * <ul>
-     * <li>A drop chance of 0F will never drop
-     * <li>A drop chance of 1F will always drop
-     * </ul>
-     *
-     * @return chance of the off hand item being dropped (1 for players)
-     */
-    float getItemInOffHandDropChance();
-
-    /**
-     * Sets the chance of the off hand item being dropped upon this creature's
-     * death.
-     *
-     * <ul>
-     * <li>A drop chance of 0F will never drop
-     * <li>A drop chance of 1F will always drop
-     * </ul>
-     *
-     * @param chance the chance of off hand item being dropped
-     * @throws UnsupportedOperationException when called on players
-     */
-    void setItemInOffHandDropChance(float chance);
-
-    /**
-     * Gets the chance of the helmet being dropped upon this creature's death.
-     *
-     * <ul>
-     * <li>A drop chance of 0F will never drop
-     * <li>A drop chance of 1F will always drop
-     * </ul>
-     *
-     * @return the chance of the helmet being dropped (1 for players)
-     */
-    float getHelmetDropChance();
-
-    /**
-     * Sets the chance of the helmet being dropped upon this creature's death.
-     * 
-     * <ul>
-     * <li>A drop chance of 0F will never drop
-     * <li>A drop chance of 1F will always drop
-     * </ul>
-     *
-     * @param chance of the helmet being dropped
-     * @throws UnsupportedOperationException when called on players
-     */
-    void setHelmetDropChance(float chance);
-
-    /**
-     * Gets the chance of the chest plate being dropped upon this creature's
-     * death.
-     * 
-     * <ul>
-     * <li>A drop chance of 0F will never drop
-     * <li>A drop chance of 1F will always drop
-     * </ul>
-     *
-     * @return the chance of the chest plate being dropped (1 for players)
-     */
-    float getChestplateDropChance();
-
-    /**
-     * Sets the chance of the chest plate being dropped upon this creature's
-     * death.
-     * 
-     * <ul>
-     * <li>A drop chance of 0F will never drop
-     * <li>A drop chance of 1F will always drop
-     * </ul>
-     *
-     * @param chance of the chest plate being dropped
-     * @throws UnsupportedOperationException when called on players
-     */
-    void setChestplateDropChance(float chance);
-
-    /**
-     * Gets the chance of the leggings being dropped upon this creature's
-     * death.
-     * 
-     * <ul>
-     * <li>A drop chance of 0F will never drop
-     * <li>A drop chance of 1F will always drop
-     * </ul>
-     *
-     * @return the chance of the leggings being dropped (1 for players)
-     */
-    float getLeggingsDropChance();
-
-    /**
-     * Sets the chance of the leggings being dropped upon this creature's
-     * death.
-     * 
-     * <ul>
-     * <li>A drop chance of 0F will never drop
-     * <li>A drop chance of 1F will always drop
-     * </ul>
-     *
-     * @param chance chance of the leggings being dropped
-     * @throws UnsupportedOperationException when called on players
-     */
-    void setLeggingsDropChance(float chance);
-
-    /**
-     * Gets the chance of the boots being dropped upon this creature's death.
-     * 
-     * <ul>
-     * <li>A drop chance of 0F will never drop
-     * <li>A drop chance of 1F will always drop
-     * </ul>
-     *
-     * @return the chance of the boots being dropped (1 for players)
-     */
-    float getBootsDropChance();
-
-    /**
-     * Sets the chance of the boots being dropped upon this creature's death.
-     * 
-     * <ul>
-     * <li>A drop chance of 0F will never drop
-     * <li>A drop chance of 1F will always drop
-     * </ul>
-     *
-     * @param chance of the boots being dropped
-     * @throws UnsupportedOperationException when called on players
-     */
-    void setBootsDropChance(float chance);
-
-    /**
-     * Get the entity this EntityEquipment belongs to
-     *
-     * @return the entity this EntityEquipment belongs to
-     */
-    Entity getHolder();
-}
diff --git a/src/main/java/org/bukkit/inventory/EquipmentSlot.java b/src/main/java/org/bukkit/inventory/EquipmentSlot.java
deleted file mode 100644
index 1e7d771..0000000
--- a/src/main/java/org/bukkit/inventory/EquipmentSlot.java
+++ /dev/null
@@ -1,11 +0,0 @@
-package org.bukkit.inventory;
-
-public enum EquipmentSlot {
-
-    HAND,
-    OFF_HAND,
-    FEET,
-    LEGS,
-    CHEST,
-    HEAD
-}
diff --git a/src/main/java/org/bukkit/inventory/FurnaceInventory.java b/src/main/java/org/bukkit/inventory/FurnaceInventory.java
deleted file mode 100644
index 93b41d3..0000000
--- a/src/main/java/org/bukkit/inventory/FurnaceInventory.java
+++ /dev/null
@@ -1,53 +0,0 @@
-package org.bukkit.inventory;
-
-import org.bukkit.block.Furnace;
-
-/**
- * Interface to the inventory of a Furnace.
- */
-public interface FurnaceInventory extends Inventory {
-
-    /**
-     * Get the current item in the result slot.
-     *
-     * @return The item
-     */
-    ItemStack getResult();
-
-    /**
-     * Get the current fuel.
-     *
-     * @return The item
-     */
-    ItemStack getFuel();
-
-    /**
-     * Get the item currently smelting.
-     *
-     * @return The item
-     */
-    ItemStack getSmelting();
-
-    /**
-     * Set the current fuel.
-     *
-     * @param stack The item
-     */
-    void setFuel(ItemStack stack);
-
-    /**
-     * Set the current item in the result slot.
-     *
-     * @param stack The item
-     */
-    void setResult(ItemStack stack);
-
-    /**
-     * Set the item currently smelting.
-     *
-     * @param stack The item
-     */
-    void setSmelting(ItemStack stack);
-
-    Furnace getHolder();
-}
diff --git a/src/main/java/org/bukkit/inventory/FurnaceRecipe.java b/src/main/java/org/bukkit/inventory/FurnaceRecipe.java
deleted file mode 100644
index b1774d6..0000000
--- a/src/main/java/org/bukkit/inventory/FurnaceRecipe.java
+++ /dev/null
@@ -1,146 +0,0 @@
-package org.bukkit.inventory;
-
-import org.bukkit.Material;
-import org.bukkit.material.MaterialData;
-
-/**
- * Represents a smelting recipe.
- */
-public class FurnaceRecipe implements Recipe {
-    private ItemStack output;
-    private ItemStack ingredient;
-    private float experience;
-
-    /**
-     * Create a furnace recipe to craft the specified ItemStack.
-     *
-     * @param result The item you want the recipe to create.
-     * @param source The input material.
-     */
-    public FurnaceRecipe(ItemStack result, Material source) {
-        this(result, source, 0, 0);
-    }
-
-    /**
-     * Create a furnace recipe to craft the specified ItemStack.
-     *
-     * @param result The item you want the recipe to create.
-     * @param source The input material.
-     */
-    public FurnaceRecipe(ItemStack result, MaterialData source) {
-        this(result, source.getItemType(), source.getData(), 0);
-    }
-
-    /**
-     * Create a furnace recipe to craft the specified ItemStack.
-     *
-     * @param result The item you want the recipe to create.
-     * @param source The input material.
-     * @param experience The experience given by this recipe
-     */
-    public FurnaceRecipe(ItemStack result, MaterialData source, float experience) {
-        this(result, source.getItemType(), source.getData(), experience);
-    }
-
-    /**
-     * Create a furnace recipe to craft the specified ItemStack.
-     *
-     * @param result The item you want the recipe to create.
-     * @param source The input material.
-     * @param data The data value. (Note: This is currently ignored by the
-     *     CraftBukkit server.)
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public FurnaceRecipe(ItemStack result, Material source, int data) {
-        this(result, source, data, 0);
-    }
-
-    /**
-     * Create a furnace recipe to craft the specified ItemStack.
-     *
-     * @param result The item you want the recipe to create.
-     * @param source The input material.
-     * @param data The data value. (Note: This is currently ignored by the
-     *     CraftBukkit server.)
-     * @param experience The experience given by this recipe
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public FurnaceRecipe(ItemStack result, Material source, int data, float experience) {
-        this.output = new ItemStack(result);
-        this.ingredient = new ItemStack(source, 1, (short) data);
-        this.experience = experience;
-    }
-
-    /**
-     * Sets the input of this furnace recipe.
-     *
-     * @param input The input material.
-     * @return The changed recipe, so you can chain calls.
-     */
-    public FurnaceRecipe setInput(MaterialData input) {
-        return setInput(input.getItemType(), input.getData());
-    }
-
-    /**
-     * Sets the input of this furnace recipe.
-     *
-     * @param input The input material.
-     * @return The changed recipe, so you can chain calls.
-     */
-    public FurnaceRecipe setInput(Material input) {
-        return setInput(input, 0);
-    }
-
-    /**
-     * Sets the input of this furnace recipe.
-     *
-     * @param input The input material.
-     * @param data The data value. (Note: This is currently ignored by the
-     *     CraftBukkit server.)
-     * @return The changed recipe, so you can chain calls.
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public FurnaceRecipe setInput(Material input, int data) {
-        this.ingredient = new ItemStack(input, 1, (short) data);
-        return this;
-    }
-
-    /**
-     * Get the input material.
-     *
-     * @return The input material.
-     */
-    public ItemStack getInput() {
-        return this.ingredient.clone();
-    }
-
-    /**
-     * Get the result of this recipe.
-     *
-     * @return The resulting stack.
-     */
-    public ItemStack getResult() {
-        return output.clone();
-    }
-
-    /**
-     * Sets the experience given by this recipe.
-     *
-     * @param experience the experience level
-     */
-    public void setExperience(float experience) {
-        this.experience = experience;
-    }
-
-    /**
-     * Get the experience given by this recipe.
-     *
-     * @return experience level
-     */
-    public float getExperience() {
-        return experience;
-    }
-}
diff --git a/src/main/java/org/bukkit/inventory/HorseInventory.java b/src/main/java/org/bukkit/inventory/HorseInventory.java
deleted file mode 100644
index a71efb8..0000000
--- a/src/main/java/org/bukkit/inventory/HorseInventory.java
+++ /dev/null
@@ -1,35 +0,0 @@
-package org.bukkit.inventory;
-
-/**
- * An interface to the inventory of a Horse.
- */
-public interface HorseInventory extends Inventory {
-
-    /**
-     * Gets the item in the horse's saddle slot.
-     *
-     * @return the saddle item
-     */
-    ItemStack getSaddle();
-
-    /**
-     * Gets the item in the horse's armor slot.
-     *
-     * @return the armor item
-     */
-    ItemStack getArmor();
-
-    /**
-     * Sets the item in the horse's saddle slot.
-     *
-     * @param stack the new item
-     */
-    void setSaddle(ItemStack stack);
-
-    /**
-     * Sets the item in the horse's armor slot.
-     *
-     * @param stack the new item
-     */
-    void setArmor(ItemStack stack);
-}
diff --git a/src/main/java/org/bukkit/inventory/Inventory.java b/src/main/java/org/bukkit/inventory/Inventory.java
deleted file mode 100644
index 3275e17..0000000
--- a/src/main/java/org/bukkit/inventory/Inventory.java
+++ /dev/null
@@ -1,420 +0,0 @@
-package org.bukkit.inventory;
-
-import java.util.HashMap;
-import java.util.List;
-import java.util.ListIterator;
-
-import org.bukkit.Location;
-import org.bukkit.Material;
-import org.bukkit.entity.HumanEntity;
-import org.bukkit.event.inventory.InventoryType;
-
-/**
- * Interface to the various inventories. Behavior relating to {@link
- * Material#AIR} is unspecified.
- */
-public interface Inventory extends Iterable<ItemStack> {
-
-    /**
-     * Returns the size of the inventory
-     *
-     * @return The size of the inventory
-     */
-    public int getSize();
-
-    /**
-     * Returns the maximum stack size for an ItemStack in this inventory.
-     *
-     * @return The maximum size for an ItemStack in this inventory.
-     */
-    public int getMaxStackSize();
-
-    /**
-     * This method allows you to change the maximum stack size for an
-     * inventory.
-     * <p>
-     * <b>Caveats:</b>
-     * <ul>
-     * <li>Not all inventories respect this value.
-     * <li>Stacks larger than 127 may be clipped when the world is saved.
-     * <li>This value is not guaranteed to be preserved; be sure to set it
-     *     before every time you want to set a slot over the max stack size.
-     * <li>Stacks larger than the default max size for this type of inventory
-     *     may not display correctly in the client.
-     * </ul>
-     *
-     * @param size The new maximum stack size for items in this inventory.
-     */
-    public void setMaxStackSize(int size);
-
-    /**
-     * Returns the name of the inventory
-     *
-     * @return The String with the name of the inventory
-     */
-    public String getName();
-
-    /**
-     * Returns the ItemStack found in the slot at the given index
-     *
-     * @param index The index of the Slot's ItemStack to return
-     * @return The ItemStack in the slot
-     */
-    public ItemStack getItem(int index);
-
-    /**
-     * Stores the ItemStack at the given index of the inventory.
-     *
-     * @param index The index where to put the ItemStack
-     * @param item The ItemStack to set
-     */
-    public void setItem(int index, ItemStack item);
-
-    /**
-     * Stores the given ItemStacks in the inventory. This will try to fill
-     * existing stacks and empty slots as well as it can.
-     * <p>
-     * The returned HashMap contains what it couldn't store, where the key is
-     * the index of the parameter, and the value is the ItemStack at that
-     * index of the varargs parameter. If all items are stored, it will return
-     * an empty HashMap.
-     * <p>
-     * If you pass in ItemStacks which exceed the maximum stack size for the
-     * Material, first they will be added to partial stacks where
-     * Material.getMaxStackSize() is not exceeded, up to
-     * Material.getMaxStackSize(). When there are no partial stacks left
-     * stacks will be split on Inventory.getMaxStackSize() allowing you to
-     * exceed the maximum stack size for that material.
-     * <p>
-     * It is known that in some implementations this method will also set
-     * the inputted argument amount to the number of that item not placed in
-     * slots.
-     *
-     * @param items The ItemStacks to add
-     * @return A HashMap containing items that didn't fit.
-     * @throws IllegalArgumentException if items or any element in it is null
-     */
-    public HashMap<Integer, ItemStack> addItem(ItemStack... items) throws IllegalArgumentException;
-
-    /**
-     * Removes the given ItemStacks from the inventory.
-     * <p>
-     * It will try to remove 'as much as possible' from the types and amounts
-     * you give as arguments.
-     * <p>
-     * The returned HashMap contains what it couldn't remove, where the key is
-     * the index of the parameter, and the value is the ItemStack at that
-     * index of the varargs parameter. If all the given ItemStacks are
-     * removed, it will return an empty HashMap.
-     * <p>
-     * It is known that in some implementations this method will also set the
-     * inputted argument amount to the number of that item not removed from
-     * slots.
-     *
-     * @param items The ItemStacks to remove
-     * @return A HashMap containing items that couldn't be removed.
-     * @throws IllegalArgumentException if items is null
-     */
-    public HashMap<Integer, ItemStack> removeItem(ItemStack... items) throws IllegalArgumentException;
-
-    /**
-     * Returns all ItemStacks from the inventory
-     *
-     * @return An array of ItemStacks from the inventory.
-     */
-    public ItemStack[] getContents();
-
-    /**
-     * Completely replaces the inventory's contents. Removes all existing
-     * contents and replaces it with the ItemStacks given in the array.
-     *
-     * @param items A complete replacement for the contents; the length must
-     *     be less than or equal to {@link #getSize()}.
-     * @throws IllegalArgumentException If the array has more items than the
-     *     inventory.
-     */
-    public void setContents(ItemStack[] items) throws IllegalArgumentException;
-
-    /**
-     * Return the contents from the section of the inventory where items can
-     * reasonably be expected to be stored. In most cases this will represent
-     * the entire inventory, but in some cases it may exclude armor or result
-     * slots.
-     * <br>
-     * It is these contents which will be used for add / contains / remove
-     * methods which look for a specific stack.
-     *
-     * @return inventory storage contents
-     */
-    public ItemStack[] getStorageContents();
-
-    /**
-     * Put the given ItemStacks into the storage slots
-     *
-     * @param items The ItemStacks to use as storage contents
-     * @throws IllegalArgumentException If the array has more items than the
-     * inventory.
-     */
-    public void setStorageContents(ItemStack[] items) throws IllegalArgumentException;
-
-    /**
-     * Checks if the inventory contains any ItemStacks with the given
-     * materialId
-     *
-     * @param materialId The materialId to check for
-     * @return true if an ItemStack in this inventory contains the materialId
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public boolean contains(int materialId);
-
-    /**
-     * Checks if the inventory contains any ItemStacks with the given
-     * material.
-     *
-     * @param material The material to check for
-     * @return true if an ItemStack is found with the given Material
-     * @throws IllegalArgumentException if material is null
-     */
-    public boolean contains(Material material) throws IllegalArgumentException;
-
-    /**
-     * Checks if the inventory contains any ItemStacks matching the given
-     * ItemStack.
-     * <p>
-     * This will only return true if both the type and the amount of the stack
-     * match.
-     *
-     * @param item The ItemStack to match against
-     * @return false if item is null, true if any exactly matching ItemStacks
-     *     were found
-     */
-    public boolean contains(ItemStack item);
-
-    /**
-     * Checks if the inventory contains any ItemStacks with the given
-     * materialId, adding to at least the minimum amount specified.
-     *
-     * @param materialId The materialId to check for
-     * @param amount The minimum amount to look for
-     * @return true if this contains any matching ItemStack with the given
-     *     materialId and amount
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public boolean contains(int materialId, int amount);
-
-    /**
-     * Checks if the inventory contains any ItemStacks with the given
-     * material, adding to at least the minimum amount specified.
-     *
-     * @param material The material to check for
-     * @param amount The minimum amount
-     * @return true if amount is less than 1, true if enough ItemStacks were
-     *     found to add to the given amount
-     * @throws IllegalArgumentException if material is null
-     */
-    public boolean contains(Material material, int amount) throws IllegalArgumentException;
-
-    /**
-     * Checks if the inventory contains at least the minimum amount specified
-     * of exactly matching ItemStacks.
-     * <p>
-     * An ItemStack only counts if both the type and the amount of the stack
-     * match.
-     *
-     * @param item the ItemStack to match against
-     * @param amount how many identical stacks to check for
-     * @return false if item is null, true if amount less than 1, true if
-     *     amount of exactly matching ItemStacks were found
-     * @see #containsAtLeast(ItemStack, int)
-     */
-    public boolean contains(ItemStack item, int amount);
-
-    /**
-     * Checks if the inventory contains ItemStacks matching the given
-     * ItemStack whose amounts sum to at least the minimum amount specified.
-     *
-     * @param item the ItemStack to match against
-     * @param amount the minimum amount
-     * @return false if item is null, true if amount less than 1, true if
-     *     enough ItemStacks were found to add to the given amount
-     */
-    public boolean containsAtLeast(ItemStack item, int amount);
-
-    /**
-     * Returns a HashMap with all slots and ItemStacks in the inventory with
-     * given materialId.
-     * <p>
-     * The HashMap contains entries where, the key is the slot index, and the
-     * value is the ItemStack in that slot. If no matching ItemStack with the
-     * given materialId is found, an empty map is returned.
-     *
-     * @param materialId The materialId to look for
-     * @return A HashMap containing the slot index, ItemStack pairs
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public HashMap<Integer, ? extends ItemStack> all(int materialId);
-
-    /**
-     * Returns a HashMap with all slots and ItemStacks in the inventory with
-     * the given Material.
-     * <p>
-     * The HashMap contains entries where, the key is the slot index, and the
-     * value is the ItemStack in that slot. If no matching ItemStack with the
-     * given Material is found, an empty map is returned.
-     *
-     * @param material The material to look for
-     * @return A HashMap containing the slot index, ItemStack pairs
-     * @throws IllegalArgumentException if material is null
-     */
-    public HashMap<Integer, ? extends ItemStack> all(Material material) throws IllegalArgumentException;
-
-    /**
-     * Finds all slots in the inventory containing any ItemStacks with the
-     * given ItemStack. This will only match slots if both the type and the
-     * amount of the stack match
-     * <p>
-     * The HashMap contains entries where, the key is the slot index, and the
-     * value is the ItemStack in that slot. If no matching ItemStack with the
-     * given Material is found, an empty map is returned.
-     *
-     * @param item The ItemStack to match against
-     * @return A map from slot indexes to item at index
-     */
-    public HashMap<Integer, ? extends ItemStack> all(ItemStack item);
-
-    /**
-     * Finds the first slot in the inventory containing an ItemStack with the
-     * given materialId.
-     *
-     * @param materialId The materialId to look for
-     * @return The slot index of the given materialId or -1 if not found
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public int first(int materialId);
-
-    /**
-     * Finds the first slot in the inventory containing an ItemStack with the
-     * given material
-     *
-     * @param material The material to look for
-     * @return The slot index of the given Material or -1 if not found
-     * @throws IllegalArgumentException if material is null
-     */
-    public int first(Material material) throws IllegalArgumentException;
-
-    /**
-     * Returns the first slot in the inventory containing an ItemStack with
-     * the given stack. This will only match a slot if both the type and the
-     * amount of the stack match
-     *
-     * @param item The ItemStack to match against
-     * @return The slot index of the given ItemStack or -1 if not found
-     */
-    public int first(ItemStack item);
-
-    /**
-     * Returns the first empty Slot.
-     *
-     * @return The first empty Slot found, or -1 if no empty slots.
-     */
-    public int firstEmpty();
-
-    /**
-     * Removes all stacks in the inventory matching the given materialId.
-     *
-     * @param materialId The material to remove
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public void remove(int materialId);
-
-    /**
-     * Removes all stacks in the inventory matching the given material.
-     *
-     * @param material The material to remove
-     * @throws IllegalArgumentException if material is null
-     */
-    public void remove(Material material) throws IllegalArgumentException;
-
-    /**
-     * Removes all stacks in the inventory matching the given stack.
-     * <p>
-     * This will only match a slot if both the type and the amount of the
-     * stack match
-     *
-     * @param item The ItemStack to match against
-     */
-    public void remove(ItemStack item);
-
-    /**
-     * Clears out a particular slot in the index.
-     *
-     * @param index The index to empty.
-     */
-    public void clear(int index);
-
-    /**
-     * Clears out the whole Inventory.
-     */
-    public void clear();
-
-    /**
-     * Gets a list of players viewing the inventory. Note that a player is
-     * considered to be viewing their own inventory and internal crafting
-     * screen even when said inventory is not open. They will normally be
-     * considered to be viewing their inventory even when they have a
-     * different inventory screen open, but it's possible for customized
-     * inventory screens to exclude the viewer's inventory, so this should
-     * never be assumed to be non-empty.
-     *
-     * @return A list of HumanEntities who are viewing this Inventory.
-     */
-    public List<HumanEntity> getViewers();
-
-    /**
-     * Returns the title of this inventory.
-     *
-     * @return A String with the title.
-     */
-    public String getTitle();
-
-    /**
-     * Returns what type of inventory this is.
-     *
-     * @return The InventoryType representing the type of inventory.
-     */
-    public InventoryType getType();
-
-    /**
-     * Gets the block or entity belonging to the open inventory
-     *
-     * @return The holder of the inventory; null if it has no holder.
-     */
-    public InventoryHolder getHolder();
-
-    @Override
-    public ListIterator<ItemStack> iterator();
-
-    /**
-     * Returns an iterator starting at the given index. If the index is
-     * positive, then the first call to next() will return the item at that
-     * index; if it is negative, the first call to previous will return the
-     * item at index (getSize() + index).
-     *
-     * @param index The index.
-     * @return An iterator.
-     */
-    public ListIterator<ItemStack> iterator(int index);
-
-    /**
-     * Get the location of the block or entity which corresponds to this inventory. May return null if this container
-     * was custom created or is a virtual / subcontainer.
-     *
-     * @return location or null if not applicable.
-     */
-    public Location getLocation();
-}
diff --git a/src/main/java/org/bukkit/inventory/InventoryHolder.java b/src/main/java/org/bukkit/inventory/InventoryHolder.java
deleted file mode 100644
index 9c06a3d..0000000
--- a/src/main/java/org/bukkit/inventory/InventoryHolder.java
+++ /dev/null
@@ -1,11 +0,0 @@
-package org.bukkit.inventory;
-
-public interface InventoryHolder {
-
-    /**
-     * Get the object's inventory.
-     *
-     * @return The inventory.
-     */
-    public Inventory getInventory();
-}
diff --git a/src/main/java/org/bukkit/inventory/InventoryView.java b/src/main/java/org/bukkit/inventory/InventoryView.java
deleted file mode 100644
index 27f9808..0000000
--- a/src/main/java/org/bukkit/inventory/InventoryView.java
+++ /dev/null
@@ -1,282 +0,0 @@
-package org.bukkit.inventory;
-
-import org.bukkit.GameMode;
-import org.bukkit.entity.HumanEntity;
-import org.bukkit.event.inventory.InventoryType;
-
-/**
- * Represents a view linking two inventories and a single player (whose
- * inventory may or may not be one of the two).
- * <p>
- * Note: If you implement this interface but fail to satisfy the expected
- * contracts of certain methods, there's no guarantee that the game will work
- * as it should.
- */
-public abstract class InventoryView {
-    public final static int OUTSIDE = -999;
-    /**
-     * Represents various extra properties of certain inventory windows.
-     */
-    public enum Property {
-        /**
-         * The progress of the down-pointing arrow in a brewing inventory.
-         */
-        BREW_TIME(0, InventoryType.BREWING),
-        /**
-         * The progress of the right-pointing arrow in a furnace inventory.
-         */
-        COOK_TIME(0, InventoryType.FURNACE),
-        /**
-         * The progress of the flame in a furnace inventory.
-         */
-        BURN_TIME(1, InventoryType.FURNACE),
-        /**
-         * How many total ticks the current fuel should last.
-         */
-        TICKS_FOR_CURRENT_FUEL(2, InventoryType.FURNACE),
-        /**
-         * In an enchanting inventory, the top button's experience level
-         * value.
-         */
-        ENCHANT_BUTTON1(0, InventoryType.ENCHANTING),
-        /**
-         * In an enchanting inventory, the middle button's experience level
-         * value.
-         */
-        ENCHANT_BUTTON2(1, InventoryType.ENCHANTING),
-        /**
-         * In an enchanting inventory, the bottom button's experience level
-         * value.
-         */
-        ENCHANT_BUTTON3(2, InventoryType.ENCHANTING);
-        int id;
-        InventoryType style;
-        private Property(int id, InventoryType appliesTo) {
-            this.id = id;
-            style = appliesTo;
-        }
-
-        public InventoryType getType() {
-            return style;
-        }
-
-        /**
-         *
-         * @return the id of this view
-         * @deprecated Magic value
-         */
-        @Deprecated
-        public int getId() {
-            return id;
-        }
-    }
-    /**
-     * Get the upper inventory involved in this transaction.
-     *
-     * @return the inventory
-     */
-    public abstract Inventory getTopInventory();
-
-    /**
-     * Get the lower inventory involved in this transaction.
-     *
-     * @return the inventory
-     */
-    public abstract Inventory getBottomInventory();
-
-    /**
-     * Get the player viewing.
-     *
-     * @return the player
-     */
-    public abstract HumanEntity getPlayer();
-
-    /**
-     * Determine the type of inventory involved in the transaction. This
-     * indicates the window style being shown. It will never return PLAYER,
-     * since that is common to all windows.
-     *
-     * @return the inventory type
-     */
-    public abstract InventoryType getType();
-
-    /**
-     * Sets one item in this inventory view by its raw slot ID.
-     * <p>
-     * Note: If slot ID -999 is chosen, it may be expected that the item is
-     * dropped on the ground. This is not required behaviour, however.
-     *
-     * @param slot The ID as returned by InventoryClickEvent.getRawSlot()
-     * @param item The new item to put in the slot, or null to clear it.
-     */
-    public void setItem(int slot, ItemStack item) {
-        if (slot != OUTSIDE) {
-            if (slot < getTopInventory().getSize()) {
-                getTopInventory().setItem(convertSlot(slot),item);
-            } else {
-                getBottomInventory().setItem(convertSlot(slot),item);
-            }
-        } else {
-            getPlayer().getWorld().dropItemNaturally(getPlayer().getLocation(), item);
-        }
-    }
-
-    /**
-     * Gets one item in this inventory view by its raw slot ID.
-     *
-     * @param slot The ID as returned by InventoryClickEvent.getRawSlot()
-     * @return The item currently in the slot.
-     */
-    public ItemStack getItem(int slot) {
-        if (slot == OUTSIDE) {
-            return null;
-        }
-        if (slot < getTopInventory().getSize()) {
-            return getTopInventory().getItem(convertSlot(slot));
-        } else {
-            return getBottomInventory().getItem(convertSlot(slot));
-        }
-    }
-
-    /**
-     * Sets the item on the cursor of one of the viewing players.
-     *
-     * @param item The item to put on the cursor, or null to remove the item
-     *     on their cursor.
-     */
-    public final void setCursor(ItemStack item) {
-        getPlayer().setItemOnCursor(item);
-    }
-
-    /**
-     * Get the item on the cursor of one of the viewing players.
-     *
-     * @return The item on the player's cursor, or null if they aren't holding
-     *     one.
-     */
-    public final ItemStack getCursor() {
-        return getPlayer().getItemOnCursor();
-    }
-
-    /**
-     * Converts a raw slot ID into its local slot ID into whichever of the two
-     * inventories the slot points to.
-     * <p>
-     * If the raw slot refers to the upper inventory, it will be returned
-     * unchanged and thus be suitable for getTopInventory().getItem(); if it
-     * refers to the lower inventory, the output will differ from the input
-     * and be suitable for getBottomInventory().getItem().
-     *
-     * @param rawSlot The raw slot ID.
-     * @return The converted slot ID.
-     */
-    public final int convertSlot(int rawSlot) {
-        int numInTop = getTopInventory().getSize();
-        // Index from the top inventory as having slots from [0,size]
-        if (rawSlot < numInTop) {
-            return rawSlot;
-        }
-
-        // Move down the slot index by the top size
-        int slot = rawSlot - numInTop;
-
-        // Creative mode players have one contiguous inventory dictated by the client
-        if (getPlayer().getGameMode() == GameMode.CREATIVE && getType() == InventoryType.PLAYER) {
-            return slot;
-        }
-
-        // Player crafting slots are indexed differently. The matrix is caught by the first return.
-        if (getType() == InventoryType.CRAFTING) {
-            /**
-             * Raw Slots:
-             *
-             * 5             1  2     0
-             * 6             3  4
-             * 7
-             * 8           45
-             * 9  10 11 12 13 14 15 16 17
-             * 18 19 20 21 22 23 24 25 26
-             * 27 28 29 30 31 32 33 34 35
-             * 36 37 38 39 40 41 42 43 44
-             */
-            
-            /**
-             * Converted Slots:
-             *
-             * 39             1  2     0
-             * 38             3  4
-             * 37
-             * 36          40
-             * 9  10 11 12 13 14 15 16 17
-             * 18 19 20 21 22 23 24 25 26
-             * 27 28 29 30 31 32 33 34 35
-             * 0  1  2  3  4  5  6  7  8
-             */
-
-            if (slot < 4) {
-                // Send [5,8] to [39,36]
-                return 39 - slot;
-            } else if (slot > 39) {
-                // Slot lives in the extra slot section
-                return slot;
-            } else {
-                // Reset index so 9 -> 0
-                slot -= 4;
-            }
-        }
-
-        // 27 = 36 - 9
-        if (slot >= 27) {
-            // Put into hotbar section
-            slot -= 27;
-        } else {
-            // Take out of hotbar section
-            // 9 = 36 - 27
-            slot += 9;
-        }
-
-        return slot;
-    }
-
-    /**
-     * Closes the inventory view.
-     */
-    public final void close() {
-        getPlayer().closeInventory();
-    }
-
-    /**
-     * Check the total number of slots in this view, combining the upper and
-     * lower inventories.
-     * <p>
-     * Note though that it's possible for this to be greater than the sum of
-     * the two inventories if for example some slots are not being used.
-     *
-     * @return The total size
-     */
-    public final int countSlots() {
-        return getTopInventory().getSize() + getBottomInventory().getSize();
-    }
-
-    /**
-     * Sets an extra property of this inventory if supported by that
-     * inventory, for example the state of a progress bar.
-     *
-     * @param prop the window property to update
-     * @param value the new value for the window property
-     * @return true if the property was updated successfully, false if the
-     *     property is not supported by that inventory
-     */
-    public final boolean setProperty(Property prop, int value) {
-        return getPlayer().setWindowProperty(prop, value);
-    }
-
-    /**
-     * Get the title of this inventory window.
-     *
-     * @return The title.
-     */
-    public final String getTitle() {
-        return getTopInventory().getTitle();
-    }
-}
diff --git a/src/main/java/org/bukkit/inventory/ItemFactory.java b/src/main/java/org/bukkit/inventory/ItemFactory.java
deleted file mode 100644
index 52a8d4d..0000000
--- a/src/main/java/org/bukkit/inventory/ItemFactory.java
+++ /dev/null
@@ -1,124 +0,0 @@
-package org.bukkit.inventory;
-
-import org.bukkit.Color;
-import org.bukkit.Material;
-import org.bukkit.Server;
-import org.bukkit.inventory.meta.BookMeta;
-import org.bukkit.inventory.meta.ItemMeta;
-import org.bukkit.inventory.meta.SkullMeta;
-
-/**
- * An instance of the ItemFactory can be obtained with {@link
- * Server#getItemFactory()}.
- * <p>
- * The ItemFactory is solely responsible for creating item meta containers to
- * apply on item stacks.
- */
-public interface ItemFactory {
-
-    /**
-     * This creates a new item meta for the material.
-     *
-     * @param material The material to consider as base for the meta
-     * @return a new ItemMeta that could be applied to an item stack of the
-     *     specified material
-     */
-    ItemMeta getItemMeta(final Material material);
-
-    /**
-     * This method checks the item meta to confirm that it is applicable (no
-     * data lost if applied) to the specified ItemStack.
-     * <p>
-     * A {@link SkullMeta} would not be valid for a sword, but a normal {@link
-     * ItemMeta} from an enchanted dirt block would.
-     *
-     * @param meta Meta to check
-     * @param stack Item that meta will be applied to
-     * @return true if the meta can be applied without losing data, false
-     *     otherwise
-     * @throws IllegalArgumentException if the meta was not created by this
-     *     factory
-     */
-    boolean isApplicable(final ItemMeta meta, final ItemStack stack) throws IllegalArgumentException;
-
-    /**
-     * This method checks the item meta to confirm that it is applicable (no
-     * data lost if applied) to the specified Material.
-     * <p>
-     * A {@link SkullMeta} would not be valid for a sword, but a normal {@link
-     * ItemMeta} from an enchanted dirt block would.
-     *
-     * @param meta Meta to check
-     * @param material Material that meta will be applied to
-     * @return true if the meta can be applied without losing data, false
-     *     otherwise
-     * @throws IllegalArgumentException if the meta was not created by this
-     *     factory
-     */
-    boolean isApplicable(final ItemMeta meta, final Material material) throws IllegalArgumentException;
-
-    /**
-     * This method is used to compare two item meta data objects.
-     *
-     * @param meta1 First meta to compare, and may be null to indicate no data
-     * @param meta2 Second meta to compare, and may be null to indicate no
-     *     data
-     * @return false if one of the meta has data the other does not, otherwise
-     *     true
-     * @throws IllegalArgumentException if either meta was not created by this
-     *     factory
-     */
-    boolean equals(final ItemMeta meta1, final ItemMeta meta2) throws IllegalArgumentException;
-
-    /**
-     * Returns an appropriate item meta for the specified stack.
-     * <p>
-     * The item meta returned will always be a valid meta for a given
-     * ItemStack of the specified material. It may be a more or less specific
-     * meta, and could also be the same meta or meta type as the parameter.
-     * The item meta returned will also always be the most appropriate meta.
-     * <p>
-     * Example, if a {@link SkullMeta} is being applied to a book, this method
-     * would return a {@link BookMeta} containing all information in the
-     * specified meta that is applicable to an {@link ItemMeta}, the highest
-     * common interface.
-     *
-     * @param meta the meta to convert
-     * @param stack the stack to convert the meta for
-     * @return An appropriate item meta for the specified item stack. No
-     *     guarantees are made as to if a copy is returned. This will be null
-     *     for a stack of air.
-     * @throws IllegalArgumentException if the specified meta was not created
-     *     by this factory
-     */
-    ItemMeta asMetaFor(final ItemMeta meta, final ItemStack stack) throws IllegalArgumentException;
-
-    /**
-     * Returns an appropriate item meta for the specified material.
-     * <p>
-     * The item meta returned will always be a valid meta for a given
-     * ItemStack of the specified material. It may be a more or less specific
-     * meta, and could also be the same meta or meta type as the parameter.
-     * The item meta returned will also always be the most appropriate meta.
-     * <p>
-     * Example, if a {@link SkullMeta} is being applied to a book, this method
-     * would return a {@link BookMeta} containing all information in the
-     * specified meta that is applicable to an {@link ItemMeta}, the highest
-     * common interface.
-     *
-     * @param meta the meta to convert
-     * @param material the material to convert the meta for
-     * @return An appropriate item meta for the specified item material. No
-     *     guarantees are made as to if a copy is returned. This will be null for air.
-     * @throws IllegalArgumentException if the specified meta was not created
-     *     by this factory
-     */
-    ItemMeta asMetaFor(final ItemMeta meta, final Material material) throws IllegalArgumentException;
-
-    /**
-     * Returns the default color for all leather armor.
-     *
-     * @return the default color for leather armor
-     */
-    Color getDefaultLeatherColor();
-}
diff --git a/src/main/java/org/bukkit/inventory/ItemFlag.java b/src/main/java/org/bukkit/inventory/ItemFlag.java
deleted file mode 100644
index 2a8af7b..0000000
--- a/src/main/java/org/bukkit/inventory/ItemFlag.java
+++ /dev/null
@@ -1,32 +0,0 @@
-package org.bukkit.inventory;
-
-/**
- * A ItemFlag can hide some Attributes from ItemStacks
- */
-public enum ItemFlag {
-
-    /**
-     * Setting to show/hide enchants
-     */
-    HIDE_ENCHANTS,
-    /**
-     * Setting to show/hide Attributes like Damage
-     */
-    HIDE_ATTRIBUTES,
-    /**
-     * Setting to show/hide the unbreakable State
-     */
-    HIDE_UNBREAKABLE,
-    /**
-     * Setting to show/hide what the ItemStack can break/destroy
-     */
-    HIDE_DESTROYS,
-    /**
-     * Setting to show/hide where this ItemStack can be build/placed on
-     */
-    HIDE_PLACED_ON,
-    /**
-     * Setting to show/hide potion effects on this ItemStack
-     */
-    HIDE_POTION_EFFECTS;
-}
diff --git a/src/main/java/org/bukkit/inventory/ItemStack.java b/src/main/java/org/bukkit/inventory/ItemStack.java
deleted file mode 100644
index d9cff5b..0000000
--- a/src/main/java/org/bukkit/inventory/ItemStack.java
+++ /dev/null
@@ -1,611 +0,0 @@
-package org.bukkit.inventory;
-
-import com.google.common.collect.ImmutableMap;
-import java.util.LinkedHashMap;
-import java.util.Map;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.Bukkit;
-import org.bukkit.Material;
-import org.bukkit.Utility;
-import org.bukkit.configuration.serialization.ConfigurationSerializable;
-import org.bukkit.enchantments.Enchantment;
-import org.bukkit.inventory.meta.ItemMeta;
-import org.bukkit.material.MaterialData;
-
-/**
- * Represents a stack of items
- */
-public class ItemStack implements Cloneable, ConfigurationSerializable {
-    private int type = 0;
-    private int amount = 0;
-    private MaterialData data = null;
-    private short durability = 0;
-    private ItemMeta meta;
-
-    @Utility
-    protected ItemStack() {}
-
-    /**
-     * Defaults stack size to 1, with no extra data
-     *
-     * @param type item material id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public ItemStack(final int type) {
-        this(type, 1);
-    }
-
-    /**
-     * Defaults stack size to 1, with no extra data
-     *
-     * @param type item material
-     */
-    public ItemStack(final Material type) {
-        this(type, 1);
-    }
-
-    /**
-     * An item stack with no extra data
-     *
-     * @param type item material id
-     * @param amount stack size
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public ItemStack(final int type, final int amount) {
-        this(type, amount, (short) 0);
-    }
-
-    /**
-     * An item stack with no extra data
-     *
-     * @param type item material
-     * @param amount stack size
-     */
-    public ItemStack(final Material type, final int amount) {
-        this(type.getId(), amount);
-    }
-
-    /**
-     * An item stack with the specified damage / durability
-     *
-     * @param type item material id
-     * @param amount stack size
-     * @param damage durability / damage
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public ItemStack(final int type, final int amount, final short damage) {
-        this.type = type;
-        this.amount = amount;
-        this.durability = damage;
-    }
-
-    /**
-     * An item stack with the specified damage / durabiltiy
-     *
-     * @param type item material
-     * @param amount stack size
-     * @param damage durability / damage
-     */
-    public ItemStack(final Material type, final int amount, final short damage) {
-        this(type.getId(), amount, damage);
-    }
-
-    /**
-     * @param type the raw type id
-     * @param amount the amount in the stack
-     * @param damage the damage value of the item
-     * @param data the data value or null
-     * @deprecated this method uses an ambiguous data byte object
-     */
-    @Deprecated
-    public ItemStack(final int type, final int amount, final short damage, final Byte data) {
-        this.type = type;
-        this.amount = amount;
-        this.durability = damage;
-        if (data != null) {
-            createData(data);
-            this.durability = data;
-        }
-    }
-
-    /**
-     * @param type the type
-     * @param amount the amount in the stack
-     * @param damage the damage value of the item
-     * @param data the data value or null
-     * @deprecated this method uses an ambiguous data byte object
-     */
-    @Deprecated
-    public ItemStack(final Material type, final int amount, final short damage, final Byte data) {
-        this(type.getId(), amount, damage, data);
-    }
-
-    /**
-     * Creates a new item stack derived from the specified stack
-     *
-     * @param stack the stack to copy
-     * @throws IllegalArgumentException if the specified stack is null or
-     *     returns an item meta not created by the item factory
-     */
-    public ItemStack(final ItemStack stack) throws IllegalArgumentException {
-        Validate.notNull(stack, "Cannot copy null stack");
-        this.type = stack.getTypeId();
-        this.amount = stack.getAmount();
-        this.durability = stack.getDurability();
-        this.data = stack.getData();
-        if (stack.hasItemMeta()) {
-            setItemMeta0(stack.getItemMeta(), getType0());
-        }
-    }
-
-    /**
-     * Gets the type of this item
-     *
-     * @return Type of the items in this stack
-     */
-    @Utility
-    public Material getType() {
-        return getType0(getTypeId());
-    }
-
-    private Material getType0() {
-        return getType0(this.type);
-    }
-
-    private static Material getType0(int id) {
-        Material material = Material.getMaterial(id);
-        return material == null ? Material.AIR : material;
-    }
-
-    /**
-     * Sets the type of this item
-     * <p>
-     * Note that in doing so you will reset the MaterialData for this stack
-     *
-     * @param type New type to set the items in this stack to
-     */
-    @Utility
-    public void setType(Material type) {
-        Validate.notNull(type, "Material cannot be null");
-        setTypeId(type.getId());
-    }
-
-    /**
-     * Gets the type id of this item
-     *
-     * @return Type Id of the items in this stack
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public int getTypeId() {
-        return type;
-    }
-
-    /**
-     * Sets the type id of this item
-     * <p>
-     * Note that in doing so you will reset the MaterialData for this stack
-     *
-     * @param type New type id to set the items in this stack to
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public void setTypeId(int type) {
-        this.type = type;
-        if (this.meta != null) {
-            this.meta = Bukkit.getItemFactory().asMetaFor(meta, getType0());
-        }
-        createData((byte) 0);
-    }
-
-    /**
-     * Gets the amount of items in this stack
-     *
-     * @return Amount of items in this stick
-     */
-    public int getAmount() {
-        return amount;
-    }
-
-    /**
-     * Sets the amount of items in this stack
-     *
-     * @param amount New amount of items in this stack
-     */
-    public void setAmount(int amount) {
-        this.amount = amount;
-    }
-
-    /**
-     * Gets the MaterialData for this stack of items
-     *
-     * @return MaterialData for this item
-     */
-    public MaterialData getData() {
-        Material mat = getType();
-        if (data == null && mat != null && mat.getData() != null) {
-            data = mat.getNewData((byte) this.getDurability());
-        }
-
-        return data;
-    }
-
-    /**
-     * Sets the MaterialData for this stack of items
-     *
-     * @param data New MaterialData for this item
-     */
-    public void setData(MaterialData data) {
-        Material mat = getType();
-
-        if (data == null || mat == null || mat.getData() == null) {
-            this.data = data;
-        } else {
-            if ((data.getClass() == mat.getData()) || (data.getClass() == MaterialData.class)) {
-                this.data = data;
-            } else {
-                throw new IllegalArgumentException("Provided data is not of type " + mat.getData().getName() + ", found " + data.getClass().getName());
-            }
-        }
-    }
-
-    /**
-     * Sets the durability of this item
-     *
-     * @param durability Durability of this item
-     */
-    public void setDurability(final short durability) {
-        this.durability = durability;
-    }
-
-    /**
-     * Gets the durability of this item
-     *
-     * @return Durability of this item
-     */
-    public short getDurability() {
-        return durability;
-    }
-
-    /**
-     * Get the maximum stacksize for the material hold in this ItemStack.
-     * (Returns -1 if it has no idea)
-     *
-     * @return The maximum you can stack this material to.
-     */
-    @Utility
-    public int getMaxStackSize() {
-        Material material = getType();
-        if (material != null) {
-            return material.getMaxStackSize();
-        }
-        return -1;
-    }
-
-    private void createData(final byte data) {
-        Material mat = Material.getMaterial(type);
-
-        if (mat == null) {
-            this.data = new MaterialData(type, data);
-        } else {
-            this.data = mat.getNewData(data);
-        }
-    }
-
-    @Override
-    @Utility
-    public String toString() {
-        StringBuilder toString = new StringBuilder("ItemStack{").append(getType().name()).append(" x ").append(getAmount());
-        if (hasItemMeta()) {
-            toString.append(", ").append(getItemMeta());
-        }
-        return toString.append('}').toString();
-    }
-
-    @Override
-    @Utility
-    public boolean equals(Object obj) {
-        if (this == obj) {
-            return true;
-        }
-        if (!(obj instanceof ItemStack)) {
-            return false;
-        }
-
-        ItemStack stack = (ItemStack) obj;
-        return getAmount() == stack.getAmount() && isSimilar(stack);
-    }
-
-    /**
-     * This method is the same as equals, but does not consider stack size
-     * (amount).
-     *
-     * @param stack the item stack to compare to
-     * @return true if the two stacks are equal, ignoring the amount
-     */
-    @Utility
-    public boolean isSimilar(ItemStack stack) {
-        if (stack == null) {
-            return false;
-        }
-        if (stack == this) {
-            return true;
-        }
-        return getTypeId() == stack.getTypeId() && getDurability() == stack.getDurability() && hasItemMeta() == stack.hasItemMeta() && (hasItemMeta() ? Bukkit.getItemFactory().equals(getItemMeta(), stack.getItemMeta()) : true);
-    }
-
-    @Override
-    public ItemStack clone() {
-        try {
-            ItemStack itemStack = (ItemStack) super.clone();
-
-            if (this.meta != null) {
-                itemStack.meta = this.meta.clone();
-            }
-
-            if (this.data != null) {
-                itemStack.data = this.data.clone();
-            }
-
-            return itemStack;
-        } catch (CloneNotSupportedException e) {
-            throw new Error(e);
-        }
-    }
-
-    @Override
-    @Utility
-    public final int hashCode() {
-        int hash = 1;
-
-        hash = hash * 31 + getTypeId();
-        hash = hash * 31 + getAmount();
-        hash = hash * 31 + (getDurability() & 0xffff);
-        hash = hash * 31 + (hasItemMeta() ? (meta == null ? getItemMeta().hashCode() : meta.hashCode()) : 0);
-
-        return hash;
-    }
-
-    /**
-     * Checks if this ItemStack contains the given {@link Enchantment}
-     *
-     * @param ench Enchantment to test
-     * @return True if this has the given enchantment
-     */
-    public boolean containsEnchantment(Enchantment ench) {
-        return meta == null ? false : meta.hasEnchant(ench);
-    }
-
-    /**
-     * Gets the level of the specified enchantment on this item stack
-     *
-     * @param ench Enchantment to check
-     * @return Level of the enchantment, or 0
-     */
-    public int getEnchantmentLevel(Enchantment ench) {
-        return meta == null ? 0 : meta.getEnchantLevel(ench);
-    }
-
-    /**
-     * Gets a map containing all enchantments and their levels on this item.
-     *
-     * @return Map of enchantments.
-     */
-    public Map<Enchantment, Integer> getEnchantments() {
-        return meta == null ? ImmutableMap.<Enchantment, Integer>of() : meta.getEnchants();
-    }
-
-    /**
-     * Adds the specified enchantments to this item stack.
-     * <p>
-     * This method is the same as calling {@link
-     * #addEnchantment(org.bukkit.enchantments.Enchantment, int)} for each
-     * element of the map.
-     *
-     * @param enchantments Enchantments to add
-     * @throws IllegalArgumentException if the specified enchantments is null
-     * @throws IllegalArgumentException if any specific enchantment or level
-     *     is null. <b>Warning</b>: Some enchantments may be added before this
-     *     exception is thrown.
-     */
-    @Utility
-    public void addEnchantments(Map<Enchantment, Integer> enchantments) {
-        Validate.notNull(enchantments, "Enchantments cannot be null");
-        for (Map.Entry<Enchantment, Integer> entry : enchantments.entrySet()) {
-            addEnchantment(entry.getKey(), entry.getValue());
-        }
-    }
-
-    /**
-     * Adds the specified {@link Enchantment} to this item stack.
-     * <p>
-     * If this item stack already contained the given enchantment (at any
-     * level), it will be replaced.
-     *
-     * @param ench Enchantment to add
-     * @param level Level of the enchantment
-     * @throws IllegalArgumentException if enchantment null, or enchantment is
-     *     not applicable
-     */
-    @Utility
-    public void addEnchantment(Enchantment ench, int level) {
-        Validate.notNull(ench, "Enchantment cannot be null");
-        if ((level < ench.getStartLevel()) || (level > ench.getMaxLevel())) {
-            throw new IllegalArgumentException("Enchantment level is either too low or too high (given " + level + ", bounds are " + ench.getStartLevel() + " to " + ench.getMaxLevel() + ")");
-        } else if (!ench.canEnchantItem(this)) {
-            throw new IllegalArgumentException("Specified enchantment cannot be applied to this itemstack");
-        }
-
-        addUnsafeEnchantment(ench, level);
-    }
-
-    /**
-     * Adds the specified enchantments to this item stack in an unsafe manner.
-     * <p>
-     * This method is the same as calling {@link
-     * #addUnsafeEnchantment(org.bukkit.enchantments.Enchantment, int)} for
-     * each element of the map.
-     *
-     * @param enchantments Enchantments to add
-     */
-    @Utility
-    public void addUnsafeEnchantments(Map<Enchantment, Integer> enchantments) {
-        for (Map.Entry<Enchantment, Integer> entry : enchantments.entrySet()) {
-            addUnsafeEnchantment(entry.getKey(), entry.getValue());
-        }
-    }
-
-    /**
-     * Adds the specified {@link Enchantment} to this item stack.
-     * <p>
-     * If this item stack already contained the given enchantment (at any
-     * level), it will be replaced.
-     * <p>
-     * This method is unsafe and will ignore level restrictions or item type.
-     * Use at your own discretion.
-     *
-     * @param ench Enchantment to add
-     * @param level Level of the enchantment
-     */
-    public void addUnsafeEnchantment(Enchantment ench, int level) {
-        (meta == null ? meta = Bukkit.getItemFactory().getItemMeta(getType0()) : meta).addEnchant(ench, level, true);
-    }
-
-    /**
-     * Removes the specified {@link Enchantment} if it exists on this
-     * ItemStack
-     *
-     * @param ench Enchantment to remove
-     * @return Previous level, or 0
-     */
-    public int removeEnchantment(Enchantment ench) {
-        int level = getEnchantmentLevel(ench);
-        if (level == 0 || meta == null) {
-            return level;
-        }
-        meta.removeEnchant(ench);
-        return level;
-    }
-
-    @Utility
-    public Map<String, Object> serialize() {
-        Map<String, Object> result = new LinkedHashMap<String, Object>();
-
-        result.put("type", getType().name());
-
-        if (getDurability() != 0) {
-            result.put("damage", getDurability());
-        }
-
-        if (getAmount() != 1) {
-            result.put("amount", getAmount());
-        }
-
-        ItemMeta meta = getItemMeta();
-        if (!Bukkit.getItemFactory().equals(meta, null)) {
-            result.put("meta", meta);
-        }
-
-        return result;
-    }
-
-    /**
-     * Required method for configuration serialization
-     *
-     * @param args map to deserialize
-     * @return deserialized item stack
-     * @see ConfigurationSerializable
-     */
-    public static ItemStack deserialize(Map<String, Object> args) {
-        Material type = Material.getMaterial((String) args.get("type"));
-        short damage = 0;
-        int amount = 1;
-
-        if (args.containsKey("damage")) {
-            damage = ((Number) args.get("damage")).shortValue();
-        }
-
-        if (args.containsKey("amount")) {
-            amount = ((Number) args.get("amount")).intValue();
-        }
-
-        ItemStack result = new ItemStack(type, amount, damage);
-
-        if (args.containsKey("enchantments")) { // Backward compatiblity, @deprecated
-            Object raw = args.get("enchantments");
-
-            if (raw instanceof Map) {
-                Map<?, ?> map = (Map<?, ?>) raw;
-
-                for (Map.Entry<?, ?> entry : map.entrySet()) {
-                    Enchantment enchantment = Enchantment.getByName(entry.getKey().toString());
-
-                    if ((enchantment != null) && (entry.getValue() instanceof Integer)) {
-                        result.addUnsafeEnchantment(enchantment, (Integer) entry.getValue());
-                    }
-                }
-            }
-        } else if (args.containsKey("meta")) { // We cannot and will not have meta when enchantments (pre-ItemMeta) exist
-            Object raw = args.get("meta");
-            if (raw instanceof ItemMeta) {
-                result.setItemMeta((ItemMeta) raw);
-            }
-        }
-
-        return result;
-    }
-
-    /**
-     * Get a copy of this ItemStack's {@link ItemMeta}.
-     *
-     * @return a copy of the current ItemStack's ItemData
-     */
-    public ItemMeta getItemMeta() {
-        return this.meta == null ? Bukkit.getItemFactory().getItemMeta(getType0()) : this.meta.clone();
-    }
-
-    /**
-     * Checks to see if any meta data has been defined.
-     *
-     * @return Returns true if some meta data has been set for this item
-     */
-    public boolean hasItemMeta() {
-        return !Bukkit.getItemFactory().equals(meta, null);
-    }
-
-    /**
-     * Set the ItemMeta of this ItemStack.
-     *
-     * @param itemMeta new ItemMeta, or null to indicate meta data be cleared.
-     * @return True if successfully applied ItemMeta, see {@link
-     *     ItemFactory#isApplicable(ItemMeta, ItemStack)}
-     * @throws IllegalArgumentException if the item meta was not created by
-     *     the {@link ItemFactory}
-     */
-    public boolean setItemMeta(ItemMeta itemMeta) {
-        return setItemMeta0(itemMeta, getType0());
-    }
-
-    /*
-     * Cannot be overridden, so it's safe for constructor call
-     */
-    private boolean setItemMeta0(ItemMeta itemMeta, Material material) {
-        if (itemMeta == null) {
-            this.meta = null;
-            return true;
-        }
-        if (!Bukkit.getItemFactory().isApplicable(itemMeta, material)) {
-            return false;
-        }
-        this.meta = Bukkit.getItemFactory().asMetaFor(itemMeta, material);
-        if (this.meta == itemMeta) {
-            this.meta = itemMeta.clone();
-        }
-
-        return true;
-    }
-}
diff --git a/src/main/java/org/bukkit/inventory/MainHand.java b/src/main/java/org/bukkit/inventory/MainHand.java
deleted file mode 100644
index 75f12f1..0000000
--- a/src/main/java/org/bukkit/inventory/MainHand.java
+++ /dev/null
@@ -1,9 +0,0 @@
-package org.bukkit.inventory;
-
-/**
- * Represents the chosen main hand of a player
- */
-public enum MainHand {
-    LEFT,
-    RIGHT
-}
diff --git a/src/main/java/org/bukkit/inventory/MerchantInventory.java b/src/main/java/org/bukkit/inventory/MerchantInventory.java
deleted file mode 100644
index d51fdbd..0000000
--- a/src/main/java/org/bukkit/inventory/MerchantInventory.java
+++ /dev/null
@@ -1,23 +0,0 @@
-package org.bukkit.inventory;
-
-/**
- * Represents a trading inventory between a player and a villager.
- * <br>
- * The holder of this Inventory is the owning Villager.
- */
-public interface MerchantInventory extends Inventory {
-
-    /**
-     * Get the index of the currently selected recipe.
-     *
-     * @return the index of the currently selected recipe
-     */
-    int getSelectedRecipeIndex();
-
-    /**
-     * Get the currently selected recipe.
-     *
-     * @return the currently selected recipe
-     */
-    MerchantRecipe getSelectedRecipe();
-}
diff --git a/src/main/java/org/bukkit/inventory/MerchantRecipe.java b/src/main/java/org/bukkit/inventory/MerchantRecipe.java
deleted file mode 100644
index 0a9fb63..0000000
--- a/src/main/java/org/bukkit/inventory/MerchantRecipe.java
+++ /dev/null
@@ -1,125 +0,0 @@
-package org.bukkit.inventory;
-
-import com.google.common.base.Preconditions;
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * Represents a Villager's trade.
- *
- * Trades can take one or two ingredients, and provide one result. The
- * ingredients' Itemstack amounts are respected in the trade.
- * <br>
- * A trade has a limited number of uses, after which the trade can no longer be
- * used, unless the player uses a different trade, which will cause its maximum
- * uses to increase.
- * <br>
- * A trade may or may not reward experience for being completed.
- *
- * @see org.bukkit.event.entity.VillagerReplenishTradeEvent
- */
-public class MerchantRecipe implements Recipe {
-
-    private ItemStack result;
-    private List<ItemStack> ingredients = new ArrayList<ItemStack>();
-    private int uses;
-    private int maxUses;
-    private boolean experienceReward;
-
-    public MerchantRecipe(ItemStack result, int maxUses) {
-        this(result, 0, maxUses, false);
-    }
-
-    public MerchantRecipe(ItemStack result, int uses, int maxUses, boolean experienceReward) {
-        this.result = result;
-        this.uses = uses;
-        this.maxUses = maxUses;
-        this.experienceReward = experienceReward;
-    }
-
-    @Override
-    public ItemStack getResult() {
-        return result;
-    }
-
-    public void addIngredient(ItemStack item) {
-        Preconditions.checkState(ingredients.size() < 2, "Merchant can only have 2 ingredients");
-        ingredients.add(item.clone());
-    }
-
-    public void removeIngredient(int index) {
-        ingredients.remove(index);
-    }
-
-    public void setIngredients(List<ItemStack> ingredients) {
-        this.ingredients = new ArrayList<ItemStack>();
-        for (ItemStack item : ingredients) {
-            this.ingredients.add(item.clone());
-        }
-    }
-
-    public List<ItemStack> getIngredients() {
-        List<ItemStack> copy = new ArrayList<ItemStack>();
-        for (ItemStack item : ingredients) {
-            copy.add(item.clone());
-        }
-        return copy;
-    }
-
-    /**
-     * Get the number of times this trade has been used.
-     *
-     * @return the number of uses
-     */
-    public int getUses() {
-        return uses;
-    }
-
-    /**
-     * Set the number of times this trade has been used.
-     *
-     * @param uses the number of uses
-     */
-    public void setUses(int uses) {
-        this.uses = uses;
-    }
-
-    /**
-     * Get the maximum number of uses this trade has.
-     * <br>
-     * The maximum uses of this trade may increase when a player trades with the
-     * owning villager.
-     *
-     * @return the maximum number of uses
-     */
-    public int getMaxUses() {
-        return maxUses;
-    }
-
-    /**
-     * Set the maximum number of uses this trade has.
-     *
-     * @param maxUses the maximum number of time this trade can be used
-     */
-    public void setMaxUses(int maxUses) {
-        this.maxUses = maxUses;
-    }
-
-    /**
-     * Whether to reward experience for the trade.
-     *
-     * @return whether to reward experience for completing this trade
-     */
-    public boolean hasExperienceReward() {
-        return experienceReward;
-    }
-
-    /**
-     * Set whether to reward experience for the trade.
-     *
-     * @param flag whether to reward experience for completing this trade
-     */
-    public void setExperienceReward(boolean flag) {
-        this.experienceReward = flag;
-    }
-}
diff --git a/src/main/java/org/bukkit/inventory/PlayerInventory.java b/src/main/java/org/bukkit/inventory/PlayerInventory.java
deleted file mode 100644
index 557cc04..0000000
--- a/src/main/java/org/bukkit/inventory/PlayerInventory.java
+++ /dev/null
@@ -1,214 +0,0 @@
-package org.bukkit.inventory;
-
-import org.bukkit.entity.HumanEntity;
-
-/**
- * Interface to the inventory of a Player, including the four armor slots and any extra slots.
- */
-public interface PlayerInventory extends Inventory {
-
-    /**
-     * Get all ItemStacks from the armor slots
-     *
-     * @return All the ItemStacks from the armor slots
-     */
-    public ItemStack[] getArmorContents();
-
-    /**
-     * Get all additional ItemStacks stored in this inventory.
-     * <br>
-     * NB: What defines an extra slot is up to the implementation, however it
-     * will not be contained within {@link #getStorageContents()} or
-     * {@link #getArmorContents()}
-     *
-     * @return All additional ItemStacks
-     */
-    public ItemStack[] getExtraContents();
-
-    /**
-     * Return the ItemStack from the helmet slot
-     *
-     * @return The ItemStack in the helmet slot
-     */
-    public ItemStack getHelmet();
-
-    /**
-     * Return the ItemStack from the chestplate slot
-     *
-     * @return The ItemStack in the chestplate slot
-     */
-    public ItemStack getChestplate();
-
-    /**
-     * Return the ItemStack from the leg slot
-     *
-     * @return The ItemStack in the leg slot
-     */
-    public ItemStack getLeggings();
-
-    /**
-     * Return the ItemStack from the boots slot
-     *
-     * @return The ItemStack in the boots slot
-     */
-    public ItemStack getBoots();
-
-    /**
-     * Stores the ItemStack at the given index of the inventory.
-     * <p>
-     * Indexes 0 through 8 refer to the hotbar. 9 through 35 refer to the main inventory, counting up from 9 at the top
-     * left corner of the inventory, moving to the right, and moving to the row below it back on the left side when it
-     * reaches the end of the row. It follows the same path in the inventory like you would read a book.
-     * <p>
-     * Indexes 36 through 39 refer to the armor slots. Though you can set armor with this method using these indexes,
-     * you are encouraged to use the provided methods for those slots.
-     * <p>
-     * If you attempt to use this method with an index less than 0 or greater than 39, an ArrayIndexOutOfBounds
-     * exception will be thrown.
-     *
-     * @param index The index where to put the ItemStack
-     * @param item The ItemStack to set
-     * @throws ArrayIndexOutOfBoundsException when index &lt; 0 || index &gt; 39
-     * @see #setBoots(ItemStack)
-     * @see #setChestplate(ItemStack)
-     * @see #setHelmet(ItemStack)
-     * @see #setLeggings(ItemStack)
-     */
-    @Override
-    public void setItem(int index, ItemStack item);
-
-    /**
-     * Put the given ItemStacks into the armor slots
-     *
-     * @param items The ItemStacks to use as armour
-     */
-    public void setArmorContents(ItemStack[] items);
-
-    /**
-     * Put the given ItemStacks into the extra slots
-     * <br>
-     * See {@link #getExtraContents()} for an explanation of extra slots.
-     *
-     * @param items The ItemStacks to use as extra
-     */
-    public void setExtraContents(ItemStack[] items);
-
-    /**
-     * Put the given ItemStack into the helmet slot. This does not check if
-     * the ItemStack is a helmet
-     *
-     * @param helmet The ItemStack to use as helmet
-     */
-    public void setHelmet(ItemStack helmet);
-
-    /**
-     * Put the given ItemStack into the chestplate slot. This does not check
-     * if the ItemStack is a chestplate
-     *
-     * @param chestplate The ItemStack to use as chestplate
-     */
-    public void setChestplate(ItemStack chestplate);
-
-    /**
-     * Put the given ItemStack into the leg slot. This does not check if the
-     * ItemStack is a pair of leggings
-     *
-     * @param leggings The ItemStack to use as leggings
-     */
-    public void setLeggings(ItemStack leggings);
-
-    /**
-     * Put the given ItemStack into the boots slot. This does not check if the
-     * ItemStack is a boots
-     *
-     * @param boots The ItemStack to use as boots
-     */
-    public void setBoots(ItemStack boots);
-
-    /**
-     * Gets a copy of the item the player is currently holding
-     * in their main hand.
-     *
-     * @return the currently held item
-     */
-    ItemStack getItemInMainHand();
-
-    /**
-     * Sets the item the player is holding in their main hand.
-     *
-     * @param item The item to put into the player's hand
-     */
-    void setItemInMainHand(ItemStack item);
-
-    /**
-     * Gets a copy of the item the player is currently holding
-     * in their off hand.
-     *
-     * @return the currently held item
-     */
-    ItemStack getItemInOffHand();
-
-    /**
-     * Sets the item the player is holding in their off hand.
-     *
-     * @param item The item to put into the player's hand
-     */
-    void setItemInOffHand(ItemStack item);
-
-    /**
-     * Gets a copy of the item the player is currently holding
-     *
-     * @deprecated players can duel wield now use the methods for the
-     *      specific hand instead
-     * @see #getItemInMainHand()
-     * @see #getItemInOffHand()
-     * @return the currently held item
-     */
-    @Deprecated
-    public ItemStack getItemInHand();
-
-    /**
-     * Sets the item the player is holding
-     *
-     * @deprecated players can duel wield now use the methods for the
-     *      specific hand instead
-     * @see #setItemInMainHand(ItemStack)
-     * @see #setItemInOffHand(ItemStack)
-     * @param stack The item to put into the player's hand
-     */
-    @Deprecated
-    public void setItemInHand(ItemStack stack);
-
-    /**
-     * Get the slot number of the currently held item
-     *
-     * @return Held item slot number
-     */
-    public int getHeldItemSlot();
-
-    /**
-     * Set the slot number of the currently held item.
-     * <p>
-     * This validates whether the slot is between 0 and 8 inclusive.
-     *
-     * @param slot The new slot number
-     * @throws IllegalArgumentException Thrown if slot is not between 0 and 8
-     *     inclusive
-     */
-    public void setHeldItemSlot(int slot);
-
-    /**
-     * Clears all matching items from the inventory. Setting either value to
-     * -1 will skip it's check, while setting both to -1 will clear all items
-     * in your inventory unconditionally.
-     *
-     * @param id the id of the item you want to clear from the inventory
-     * @param data the data of the item you want to clear from the inventory
-     * @return The number of items cleared
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public int clear(int id, int data);
-
-    public HumanEntity getHolder();
-}
diff --git a/src/main/java/org/bukkit/inventory/Recipe.java b/src/main/java/org/bukkit/inventory/Recipe.java
deleted file mode 100644
index 7977ce2..0000000
--- a/src/main/java/org/bukkit/inventory/Recipe.java
+++ /dev/null
@@ -1,14 +0,0 @@
-package org.bukkit.inventory;
-
-/**
- * Represents some type of crafting recipe.
- */
-public interface Recipe {
-
-    /**
-     * Get the result of this recipe.
-     *
-     * @return The result stack
-     */
-    ItemStack getResult();
-}
diff --git a/src/main/java/org/bukkit/inventory/ShapedRecipe.java b/src/main/java/org/bukkit/inventory/ShapedRecipe.java
deleted file mode 100644
index 2796473..0000000
--- a/src/main/java/org/bukkit/inventory/ShapedRecipe.java
+++ /dev/null
@@ -1,148 +0,0 @@
-package org.bukkit.inventory;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import org.apache.commons.lang.Validate;
-
-import org.bukkit.Material;
-import org.bukkit.material.MaterialData;
-
-/**
- * Represents a shaped (ie normal) crafting recipe.
- */
-public class ShapedRecipe implements Recipe {
-    private ItemStack output;
-    private String[] rows;
-    private Map<Character, ItemStack> ingredients = new HashMap<Character, ItemStack>();
-
-    /**
-     * Create a shaped recipe to craft the specified ItemStack. The
-     * constructor merely determines the result and type; to set the actual
-     * recipe, you'll need to call the appropriate methods.
-     *
-     * @param result The item you want the recipe to create.
-     * @see ShapedRecipe#shape(String...)
-     * @see ShapedRecipe#setIngredient(char, Material)
-     * @see ShapedRecipe#setIngredient(char, Material, int)
-     * @see ShapedRecipe#setIngredient(char, MaterialData)
-     */
-    public ShapedRecipe(ItemStack result) {
-        this.output = new ItemStack(result);
-    }
-
-    /**
-     * Set the shape of this recipe to the specified rows. Each character
-     * represents a different ingredient; exactly what each character
-     * represents is set separately. The first row supplied corresponds with
-     * the upper most part of the recipe on the workbench e.g. if all three
-     * rows are supplies the first string represents the top row on the
-     * workbench.
-     *
-     * @param shape The rows of the recipe (up to 3 rows).
-     * @return The changed recipe, so you can chain calls.
-     */
-    public ShapedRecipe shape(final String... shape) {
-        Validate.notNull(shape, "Must provide a shape");
-        Validate.isTrue(shape.length > 0 && shape.length < 4, "Crafting recipes should be 1, 2, 3 rows, not ", shape.length);
-
-        for (String row : shape) {
-            Validate.notNull(row, "Shape cannot have null rows");
-            Validate.isTrue(row.length() > 0 && row.length() < 4, "Crafting rows should be 1, 2, or 3 characters, not ", row.length());
-        }
-        this.rows = new String[shape.length];
-        for (int i = 0; i < shape.length; i++) {
-            this.rows[i] = shape[i];
-        }
-
-        // Remove character mappings for characters that no longer exist in the shape
-        HashMap<Character, ItemStack> newIngredients = new HashMap<Character, ItemStack>();
-        for (String row : shape) {
-            for (Character c : row.toCharArray()) {
-                newIngredients.put(c, ingredients.get(c));
-            }
-        }
-        this.ingredients = newIngredients;
-
-        return this;
-    }
-
-    /**
-     * Sets the material that a character in the recipe shape refers to.
-     *
-     * @param key The character that represents the ingredient in the shape.
-     * @param ingredient The ingredient.
-     * @return The changed recipe, so you can chain calls.
-     */
-    public ShapedRecipe setIngredient(char key, MaterialData ingredient) {
-        return setIngredient(key, ingredient.getItemType(), ingredient.getData());
-    }
-
-    /**
-     * Sets the material that a character in the recipe shape refers to.
-     *
-     * @param key The character that represents the ingredient in the shape.
-     * @param ingredient The ingredient.
-     * @return The changed recipe, so you can chain calls.
-     */
-    public ShapedRecipe setIngredient(char key, Material ingredient) {
-        return setIngredient(key, ingredient, 0);
-    }
-
-    /**
-     * Sets the material that a character in the recipe shape refers to.
-     *
-     * @param key The character that represents the ingredient in the shape.
-     * @param ingredient The ingredient.
-     * @param raw The raw material data as an integer.
-     * @return The changed recipe, so you can chain calls.
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public ShapedRecipe setIngredient(char key, Material ingredient, int raw) {
-        Validate.isTrue(ingredients.containsKey(key), "Symbol does not appear in the shape:", key);
-
-        // -1 is the old wildcard, map to Short.MAX_VALUE as the new one
-        if (raw == -1) {
-            raw = Short.MAX_VALUE;
-        }
-
-        ingredients.put(key, new ItemStack(ingredient, 1, (short) raw));
-        return this;
-    }
-
-    /**
-     * Get a copy of the ingredients map.
-     *
-     * @return The mapping of character to ingredients.
-     */
-    public Map<Character, ItemStack> getIngredientMap() {
-        HashMap<Character, ItemStack> result = new HashMap<Character, ItemStack>();
-        for (Map.Entry<Character, ItemStack> ingredient : ingredients.entrySet()) {
-            if (ingredient.getValue() == null) {
-                result.put(ingredient.getKey(), null);
-            } else {
-                result.put(ingredient.getKey(), ingredient.getValue().clone());
-            }
-        }
-        return result;
-    }
-
-    /**
-     * Get the shape.
-     *
-     * @return The recipe's shape.
-     */
-    public String[] getShape() {
-        return rows.clone();
-    }
-
-    /**
-     * Get the result.
-     *
-     * @return The result stack.
-     */
-    public ItemStack getResult() {
-        return output.clone();
-    }
-}
diff --git a/src/main/java/org/bukkit/inventory/ShapelessRecipe.java b/src/main/java/org/bukkit/inventory/ShapelessRecipe.java
deleted file mode 100644
index a718086..0000000
--- a/src/main/java/org/bukkit/inventory/ShapelessRecipe.java
+++ /dev/null
@@ -1,226 +0,0 @@
-package org.bukkit.inventory;
-
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-
-import org.apache.commons.lang.Validate;
-
-import org.bukkit.Material;
-import org.bukkit.material.MaterialData;
-
-/**
- * Represents a shapeless recipe, where the arrangement of the ingredients on
- * the crafting grid does not matter.
- */
-public class ShapelessRecipe implements Recipe {
-    private ItemStack output;
-    private List<ItemStack> ingredients = new ArrayList<ItemStack>();
-
-    /**
-     * Create a shapeless recipe to craft the specified ItemStack. The
-     * constructor merely determines the result and type; to set the actual
-     * recipe, you'll need to call the appropriate methods.
-     *
-     * @param result The item you want the recipe to create.
-     * @see ShapelessRecipe#addIngredient(Material)
-     * @see ShapelessRecipe#addIngredient(MaterialData)
-     * @see ShapelessRecipe#addIngredient(Material,int)
-     * @see ShapelessRecipe#addIngredient(int,Material)
-     * @see ShapelessRecipe#addIngredient(int,MaterialData)
-     * @see ShapelessRecipe#addIngredient(int,Material,int)
-     */
-    public ShapelessRecipe(ItemStack result) {
-        this.output = new ItemStack(result);
-    }
-
-    /**
-     * Adds the specified ingredient.
-     *
-     * @param ingredient The ingredient to add.
-     * @return The changed recipe, so you can chain calls.
-     */
-    public ShapelessRecipe addIngredient(MaterialData ingredient) {
-        return addIngredient(1, ingredient);
-    }
-
-    /**
-     * Adds the specified ingredient.
-     *
-     * @param ingredient The ingredient to add.
-     * @return The changed recipe, so you can chain calls.
-     */
-    public ShapelessRecipe addIngredient(Material ingredient) {
-        return addIngredient(1, ingredient, 0);
-    }
-
-    /**
-     * Adds the specified ingredient.
-     *
-     * @param ingredient The ingredient to add.
-     * @param rawdata The data value, or -1 to allow any data value.
-     * @return The changed recipe, so you can chain calls.
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public ShapelessRecipe addIngredient(Material ingredient, int rawdata) {
-        return addIngredient(1, ingredient, rawdata);
-    }
-
-    /**
-     * Adds multiples of the specified ingredient.
-     *
-     * @param count How many to add (can't be more than 9!)
-     * @param ingredient The ingredient to add.
-     * @return The changed recipe, so you can chain calls.
-     */
-    public ShapelessRecipe addIngredient(int count, MaterialData ingredient) {
-        return addIngredient(count, ingredient.getItemType(), ingredient.getData());
-    }
-
-    /**
-     * Adds multiples of the specified ingredient.
-     *
-     * @param count How many to add (can't be more than 9!)
-     * @param ingredient The ingredient to add.
-     * @return The changed recipe, so you can chain calls.
-     */
-    public ShapelessRecipe addIngredient(int count, Material ingredient) {
-        return addIngredient(count, ingredient, 0);
-    }
-
-    /**
-     * Adds multiples of the specified ingredient.
-     *
-     * @param count How many to add (can't be more than 9!)
-     * @param ingredient The ingredient to add.
-     * @param rawdata The data value, or -1 to allow any data value.
-     * @return The changed recipe, so you can chain calls.
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public ShapelessRecipe addIngredient(int count, Material ingredient, int rawdata) {
-        Validate.isTrue(ingredients.size() + count <= 9, "Shapeless recipes cannot have more than 9 ingredients");
-
-        // -1 is the old wildcard, map to Short.MAX_VALUE as the new one
-        if (rawdata == -1) {
-            rawdata = Short.MAX_VALUE;
-        }
-
-        while (count-- > 0) {
-            ingredients.add(new ItemStack(ingredient, 1, (short) rawdata));
-        }
-        return this;
-    }
-
-    /**
-     * Removes an ingredient from the list. If the ingredient occurs multiple
-     * times, only one instance of it is removed. Only removes exact matches,
-     * with a data value of 0.
-     *
-     * @param ingredient The ingredient to remove
-     * @return The changed recipe.
-     */
-    public ShapelessRecipe removeIngredient(Material ingredient) {
-        return removeIngredient(ingredient, 0);
-    }
-
-    /**
-     * Removes an ingredient from the list. If the ingredient occurs multiple
-     * times, only one instance of it is removed. If the data value is -1,
-     * only ingredients with a -1 data value will be removed.
-     *
-     * @param ingredient The ingredient to remove
-     * @return The changed recipe.
-     */
-    public ShapelessRecipe removeIngredient(MaterialData ingredient) {
-        return removeIngredient(ingredient.getItemType(), ingredient.getData());
-    }
-
-    /**
-     * Removes multiple instances of an ingredient from the list. If there are
-     * less instances then specified, all will be removed. Only removes exact
-     * matches, with a data value of 0.
-     *
-     * @param count The number of copies to remove.
-     * @param ingredient The ingredient to remove
-     * @return The changed recipe.
-     */
-    public ShapelessRecipe removeIngredient(int count, Material ingredient) {
-        return removeIngredient(count, ingredient, 0);
-    }
-
-    /**
-     * Removes multiple instances of an ingredient from the list. If there are
-     * less instances then specified, all will be removed. If the data value
-     * is -1, only ingredients with a -1 data value will be removed.
-     *
-     * @param count The number of copies to remove.
-     * @param ingredient The ingredient to remove.
-     * @return The changed recipe.
-     */
-    public ShapelessRecipe removeIngredient(int count, MaterialData ingredient) {
-        return removeIngredient(count, ingredient.getItemType(), ingredient.getData());
-    }
-
-    /**
-     * Removes an ingredient from the list. If the ingredient occurs multiple
-     * times, only one instance of it is removed. If the data value is -1,
-     * only ingredients with a -1 data value will be removed.
-     *
-     * @param ingredient The ingredient to remove
-     * @param rawdata The data value;
-     * @return The changed recipe.
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public ShapelessRecipe removeIngredient(Material ingredient, int rawdata) {
-        return removeIngredient(1, ingredient, rawdata);
-    }
-
-    /**
-     * Removes multiple instances of an ingredient from the list. If there are
-     * less instances then specified, all will be removed. If the data value
-     * is -1, only ingredients with a -1 data value will be removed.
-     *
-     * @param count The number of copies to remove.
-     * @param ingredient The ingredient to remove.
-     * @param rawdata The data value.
-     * @return The changed recipe.
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public ShapelessRecipe removeIngredient(int count, Material ingredient, int rawdata) {
-        Iterator<ItemStack> iterator = ingredients.iterator();
-        while (count > 0 && iterator.hasNext()) {
-            ItemStack stack = iterator.next();
-            if (stack.getType() == ingredient && stack.getDurability() == rawdata) {
-                iterator.remove();
-                count--;
-            }
-        }
-        return this;
-    }
-
-    /**
-     * Get the result of this recipe.
-     *
-     * @return The result stack.
-     */
-    public ItemStack getResult() {
-        return output.clone();
-    }
-
-    /**
-     * Get the list of ingredients used for this recipe.
-     *
-     * @return The input list
-     */
-    public List<ItemStack> getIngredientList() {
-        ArrayList<ItemStack> result = new ArrayList<ItemStack>(ingredients.size());
-        for (ItemStack ingredient : ingredients) {
-            result.add(ingredient.clone());
-        }
-        return result;
-    }
-}
diff --git a/src/main/java/org/bukkit/inventory/meta/BannerMeta.java b/src/main/java/org/bukkit/inventory/meta/BannerMeta.java
deleted file mode 100644
index 6bf33c5..0000000
--- a/src/main/java/org/bukkit/inventory/meta/BannerMeta.java
+++ /dev/null
@@ -1,76 +0,0 @@
-package org.bukkit.inventory.meta;
-
-import java.util.List;
-import org.bukkit.DyeColor;
-import org.bukkit.block.banner.Pattern;
-
-public interface BannerMeta extends ItemMeta {
-
-    /**
-     * Returns the base color for this banner
-     *
-     * @return the base color
-     */
-    DyeColor getBaseColor();
-
-    /**
-     * Sets the base color for this banner
-     *
-     * @param color the base color
-     */
-    void setBaseColor(DyeColor color);
-
-    /**
-     * Returns a list of patterns on this banner
-     *
-     * @return the patterns
-     */
-    List<Pattern> getPatterns();
-
-    /**
-     * Sets the patterns used on this banner
-     *
-     * @param patterns the new list of patterns
-     */
-    void setPatterns(List<Pattern> patterns);
-
-    /**
-     * Adds a new pattern on top of the existing
-     * patterns
-     *
-     * @param pattern the new pattern to add
-     */
-    void addPattern(Pattern pattern);
-
-    /**
-     * Returns the pattern at the specified index
-     *
-     * @param i the index
-     * @return the pattern
-     */
-    Pattern getPattern(int i);
-
-    /**
-     * Removes the pattern at the specified index
-     *
-     * @param i the index
-     * @return the removed pattern
-     */
-    Pattern removePattern(int i);
-
-    /**
-     * Sets the pattern at the specified index
-     *
-     * @param i       the index
-     * @param pattern the new pattern
-     */
-    void setPattern(int i, Pattern pattern);
-
-    /**
-     * Returns the number of patterns on this
-     * banner
-     *
-     * @return the number of patterns
-     */
-    int numberOfPatterns();
-}
diff --git a/src/main/java/org/bukkit/inventory/meta/BlockStateMeta.java b/src/main/java/org/bukkit/inventory/meta/BlockStateMeta.java
deleted file mode 100644
index 4c2a746..0000000
--- a/src/main/java/org/bukkit/inventory/meta/BlockStateMeta.java
+++ /dev/null
@@ -1,35 +0,0 @@
-
-package org.bukkit.inventory.meta;
-
-import org.bukkit.block.BlockState;
-
-public interface BlockStateMeta extends ItemMeta {
-
-    /**
-     * Returns whether the item has a block state currently
-     * attached to it.
-     * 
-     * @return whether a block state is already attached
-     */
-    boolean hasBlockState();
-
-    /**
-     * Returns the currently attached block state for this
-     * item or creates a new one if one doesn't exist.
-     *
-     * The state is a copy, it must be set back (or to another
-     * item) with {@link #setBlockState(org.bukkit.block.BlockState)}
-     *
-     * @return the attached state or a new state
-     */
-    BlockState getBlockState();
-
-    /**
-     * Attaches a copy of the passed block state to the item.
-     *
-     * @param blockState the block state to attach to the block.
-     * @throws IllegalArgumentException if the blockState is null
-     *         or invalid for this item.
-     */
-    void setBlockState(BlockState blockState);
-}
diff --git a/src/main/java/org/bukkit/inventory/meta/BookMeta.java b/src/main/java/org/bukkit/inventory/meta/BookMeta.java
deleted file mode 100644
index 845f71c..0000000
--- a/src/main/java/org/bukkit/inventory/meta/BookMeta.java
+++ /dev/null
@@ -1,168 +0,0 @@
-package org.bukkit.inventory.meta;
-
-import java.util.List;
-
-import org.bukkit.Material;
-
-/**
- * Represents a book ({@link Material#BOOK_AND_QUILL} or {@link
- * Material#WRITTEN_BOOK}) that can have a title, an author, and pages.
- */
-public interface BookMeta extends ItemMeta {
-
-    /**
-     * Represents the generation (or level of copying) of a written book
-     */
-    enum Generation {
-        /**
-         * Book written into a book-and-quill. Can be copied. (Default value)
-         */
-        ORIGINAL,
-        /**
-         * Book that was copied from an original. Can be copied.
-         */
-        COPY_OF_ORIGINAL,
-        /**
-         * Book that was copied from a copy of an original. Can't be copied.
-         */
-        COPY_OF_COPY,
-        /**
-         * Unused; unobtainable by players. Can't be copied.
-         */
-        TATTERED;
-    }
-
-    /**
-     * Checks for the existence of a title in the book.
-     *
-     * @return true if the book has a title
-     */
-    boolean hasTitle();
-
-    /**
-     * Gets the title of the book.
-     * <p>
-     * Plugins should check that hasTitle() returns true before calling this
-     * method.
-     *
-     * @return the title of the book
-     */
-    String getTitle();
-
-    /**
-     * Sets the title of the book.
-     * <p>
-     * Limited to 16 characters. Removes title when given null.
-     *
-     * @param title the title to set
-     * @return true if the title was successfully set
-     */
-    boolean setTitle(String title);
-
-    /**
-     * Checks for the existence of an author in the book.
-     *
-     * @return the author of the book
-     */
-    boolean hasAuthor();
-
-    /**
-     * Gets the author of the book.
-     * <p>
-     * Plugins should check that hasAuthor() returns true before calling this
-     * method.
-     *
-     * @return the author of the book
-     */
-    String getAuthor();
-
-    /**
-     * Sets the author of the book. Removes author when given null.
-     *
-     * @param author the author of the book
-     */
-    void setAuthor(String author);
-
-    /**
-     * Gets the generation of the book, or null if it's out of bounds.
-     *
-     * @return the generation of the book or null
-     */
-    Generation getGeneration();
-
-    /**
-     * Sets the generation of the book.
-     * <p>
-     * Assumes Generation.ORIGINAL if given null.
-     *
-     * @param generation the generation of the book
-     */
-    void setGeneration(Generation generation);
-
-    /**
-     * Checks for the existence of pages in the book.
-     *
-     * @return true if the book has pages
-     */
-    boolean hasPages();
-
-    /**
-     * Gets the specified page in the book. The given page must exist.
-     *
-     * @param page the page number to get
-     * @return the page from the book
-     */
-    String getPage(int page);
-
-    /**
-     * Sets the specified page in the book. Pages of the book must be
-     * contiguous.
-     * <p>
-     * The data can be up to 256 characters in length, additional characters
-     * are truncated.
-     *
-     * @param page the page number to set
-     * @param data the data to set for that page
-     */
-    void setPage(int page, String data);
-
-    /**
-     * Gets all the pages in the book.
-     *
-     * @return list of all the pages in the book
-     */
-    List<String> getPages();
-
-    /**
-     * Clears the existing book pages, and sets the book to use the provided
-     * pages. Maximum 50 pages with 256 characters per page.
-     *
-     * @param pages A list of pages to set the book to use
-     */
-    void setPages(List<String> pages);
-
-    /**
-     * Clears the existing book pages, and sets the book to use the provided
-     * pages. Maximum 50 pages with 256 characters per page.
-     *
-     * @param pages A list of strings, each being a page
-     */
-    void setPages(String... pages);
-
-    /**
-     * Adds new pages to the end of the book. Up to a maximum of 50 pages with
-     * 256 characters per page.
-     *
-     * @param pages A list of strings, each being a page
-     */
-    void addPage(String... pages);
-
-    /**
-     * Gets the number of pages in the book.
-     *
-     * @return the number of pages in the book
-     */
-    int getPageCount();
-
-    BookMeta clone();
-}
diff --git a/src/main/java/org/bukkit/inventory/meta/EnchantmentStorageMeta.java b/src/main/java/org/bukkit/inventory/meta/EnchantmentStorageMeta.java
deleted file mode 100644
index fb93d03..0000000
--- a/src/main/java/org/bukkit/inventory/meta/EnchantmentStorageMeta.java
+++ /dev/null
@@ -1,79 +0,0 @@
-package org.bukkit.inventory.meta;
-
-import java.util.Map;
-
-import org.bukkit.Material;
-import org.bukkit.enchantments.Enchantment;
-
-/**
- * EnchantmentMeta is specific to items that can <i>store</i> enchantments, as
- * opposed to being enchanted. {@link Material#ENCHANTED_BOOK} is an example
- * of an item with enchantment storage.
- */
-public interface EnchantmentStorageMeta extends ItemMeta {
-
-    /**
-     * Checks for the existence of any stored enchantments.
-     *
-     * @return true if an enchantment exists on this meta
-     */
-    boolean hasStoredEnchants();
-
-    /**
-     * Checks for storage of the specified enchantment.
-     *
-     * @param ench enchantment to check
-     * @return true if this enchantment is stored in this meta
-     */
-    boolean hasStoredEnchant(Enchantment ench);
-
-    /**
-     * Checks for the level of the stored enchantment.
-     *
-     * @param ench enchantment to check
-     * @return The level that the specified stored enchantment has, or 0 if
-     *     none
-     */
-    int getStoredEnchantLevel(Enchantment ench);
-
-    /**
-     * Gets a copy the stored enchantments in this ItemMeta.
-     *
-     * @return An immutable copy of the stored enchantments
-     */
-    Map<Enchantment, Integer> getStoredEnchants();
-
-    /**
-     * Stores the specified enchantment in this item meta.
-     *
-     * @param ench Enchantment to store
-     * @param level Level for the enchantment
-     * @param ignoreLevelRestriction this indicates the enchantment should be
-     *     applied, ignoring the level limit
-     * @return true if the item meta changed as a result of this call, false
-     *     otherwise
-     * @throws IllegalArgumentException if enchantment is null
-     */
-    boolean addStoredEnchant(Enchantment ench, int level, boolean ignoreLevelRestriction);
-
-    /**
-     * Remove the specified stored enchantment from this item meta.
-     *
-     * @param ench Enchantment to remove
-     * @return true if the item meta changed as a result of this call, false
-     *     otherwise
-     * @throws IllegalArgumentException if enchantment is null
-     */
-    boolean removeStoredEnchant(Enchantment ench) throws IllegalArgumentException;
-
-    /**
-     * Checks if the specified enchantment conflicts with any enchantments in
-     * this ItemMeta.
-     *
-     * @param ench enchantment to test
-     * @return true if the enchantment conflicts, false otherwise
-     */
-    boolean hasConflictingStoredEnchant(Enchantment ench);
-
-    EnchantmentStorageMeta clone();
-}
diff --git a/src/main/java/org/bukkit/inventory/meta/FireworkEffectMeta.java b/src/main/java/org/bukkit/inventory/meta/FireworkEffectMeta.java
deleted file mode 100644
index 47046f1..0000000
--- a/src/main/java/org/bukkit/inventory/meta/FireworkEffectMeta.java
+++ /dev/null
@@ -1,34 +0,0 @@
-package org.bukkit.inventory.meta;
-
-import org.bukkit.FireworkEffect;
-import org.bukkit.Material;
-
-/**
- * Represents a meta that can store a single FireworkEffect. An example
- * includes {@link Material#FIREWORK_CHARGE}.
- */
-public interface FireworkEffectMeta extends ItemMeta {
-
-    /**
-     * Sets the firework effect for this meta.
-     *
-     * @param effect the effect to set, or null to indicate none.
-     */
-    void setEffect(FireworkEffect effect);
-
-    /**
-     * Checks if this meta has an effect.
-     *
-     * @return true if this meta has an effect, false otherwise
-     */
-    boolean hasEffect();
-
-    /**
-     * Gets the firework effect for this meta.
-     *
-     * @return the current effect, or null if none
-     */
-    FireworkEffect getEffect();
-
-    FireworkEffectMeta clone();
-}
diff --git a/src/main/java/org/bukkit/inventory/meta/FireworkMeta.java b/src/main/java/org/bukkit/inventory/meta/FireworkMeta.java
deleted file mode 100644
index 1e3ee59..0000000
--- a/src/main/java/org/bukkit/inventory/meta/FireworkMeta.java
+++ /dev/null
@@ -1,94 +0,0 @@
-package org.bukkit.inventory.meta;
-
-import java.util.List;
-
-import org.bukkit.FireworkEffect;
-import org.bukkit.Material;
-
-/**
- * Represents a {@link Material#FIREWORK} and its effects.
- */
-public interface FireworkMeta extends ItemMeta {
-
-    /**
-     * Add another effect to this firework.
-     *
-     * @param effect The firework effect to add
-     * @throws IllegalArgumentException If effect is null
-     */
-    void addEffect(FireworkEffect effect) throws IllegalArgumentException;
-
-    /**
-     * Add several effects to this firework.
-     *
-     * @param effects The firework effects to add
-     * @throws IllegalArgumentException If effects is null
-     * @throws IllegalArgumentException If any effect is null (may be thrown
-     *     after changes have occurred)
-     */
-    void addEffects(FireworkEffect...effects) throws IllegalArgumentException;
-
-    /**
-     * Add several firework effects to this firework.
-     *
-     * @param effects An iterable object whose iterator yields the desired
-     *     firework effects
-     * @throws IllegalArgumentException If effects is null
-     * @throws IllegalArgumentException If any effect is null (may be thrown
-     *     after changes have occurred)
-     */
-    void addEffects(Iterable<FireworkEffect> effects) throws IllegalArgumentException;
-
-    /**
-     * Get the effects in this firework.
-     *
-     * @return An immutable list of the firework effects
-     */
-    List<FireworkEffect> getEffects();
-
-    /**
-     * Get the number of effects in this firework.
-     *
-     * @return The number of effects
-     */
-    int getEffectsSize();
-
-    /**
-     * Remove an effect from this firework.
-     *
-     * @param index The index of the effect to remove
-     * @throws IndexOutOfBoundsException If index {@literal < 0 or index >} {@link
-     *     #getEffectsSize()}
-     */
-    void removeEffect(int index) throws IndexOutOfBoundsException;
-
-    /**
-     * Remove all effects from this firework.
-     */
-    void clearEffects();
-
-    /**
-     * Get whether this firework has any effects.
-     *
-     * @return true if it has effects, false if there are no effects
-     */
-    boolean hasEffects();
-
-    /**
-     * Gets the approximate height the firework will fly.
-     *
-     * @return approximate flight height of the firework.
-     */
-    int getPower();
-
-    /**
-     * Sets the approximate power of the firework. Each level of power is half
-     * a second of flight time.
-     *
-     * @param power the power of the firework, from 0-128
-     * @throws IllegalArgumentException if {@literal height<0 or height>128}
-     */
-    void setPower(int power) throws IllegalArgumentException;
-
-    FireworkMeta clone();
-}
diff --git a/src/main/java/org/bukkit/inventory/meta/ItemMeta.java b/src/main/java/org/bukkit/inventory/meta/ItemMeta.java
deleted file mode 100644
index 459e09c..0000000
--- a/src/main/java/org/bukkit/inventory/meta/ItemMeta.java
+++ /dev/null
@@ -1,160 +0,0 @@
-package org.bukkit.inventory.meta;
-
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import org.bukkit.configuration.serialization.ConfigurationSerializable;
-import org.bukkit.enchantments.Enchantment;
-import org.bukkit.inventory.ItemFlag;
-
-/**
- * This type represents the storage mechanism for auxiliary item data.
- * <p>
- * An implementation will handle the creation and application for ItemMeta.
- * This class should not be implemented by a plugin in a live environment.
- */
-public interface ItemMeta extends Cloneable, ConfigurationSerializable {
-
-    /**
-     * Checks for existence of a display name.
-     *
-     * @return true if this has a display name
-     */
-    boolean hasDisplayName();
-
-    /**
-     * Gets the display name that is set.
-     * <p>
-     * Plugins should check that hasDisplayName() returns <code>true</code>
-     * before calling this method.
-     *
-     * @return the display name that is set
-     */
-    String getDisplayName();
-
-    /**
-     * Sets the display name.
-     *
-     * @param name the name to set
-     */
-    void setDisplayName(String name);
-
-    /**
-     * Checks for existence of lore.
-     *
-     * @return true if this has lore
-     */
-    boolean hasLore();
-
-    /**
-     * Gets the lore that is set.
-     * <p>
-     * Plugins should check if hasLore() returns <code>true</code> before
-     * calling this method.
-     * 
-     * @return a list of lore that is set
-     */
-    List<String> getLore();
-
-    /**
-     * Sets the lore for this item. 
-     * Removes lore when given null.
-     *
-     * @param lore the lore that will be set
-     */
-    void setLore(List<String> lore);
-
-    /**
-     * Checks for the existence of any enchantments.
-     *
-     * @return true if an enchantment exists on this meta
-     */
-    boolean hasEnchants();
-
-    /**
-     * Checks for existence of the specified enchantment.
-     *
-     * @param ench enchantment to check
-     * @return true if this enchantment exists for this meta
-     */
-    boolean hasEnchant(Enchantment ench);
-
-    /**
-     * Checks for the level of the specified enchantment.
-     *
-     * @param ench enchantment to check
-     * @return The level that the specified enchantment has, or 0 if none
-     */
-    int getEnchantLevel(Enchantment ench);
-
-    /**
-     * Returns a copy the enchantments in this ItemMeta. <br> 
-     * Returns an empty map if none.
-     *
-     * @return An immutable copy of the enchantments
-     */
-    Map<Enchantment, Integer> getEnchants();
-
-    /**
-     * Adds the specified enchantment to this item meta.
-     *
-     * @param ench Enchantment to add
-     * @param level Level for the enchantment
-     * @param ignoreLevelRestriction this indicates the enchantment should be
-     *     applied, ignoring the level limit
-     * @return true if the item meta changed as a result of this call, false
-     *     otherwise
-     */
-    boolean addEnchant(Enchantment ench, int level, boolean ignoreLevelRestriction);
-
-    /**
-     * Removes the specified enchantment from this item meta.
-     *
-     * @param ench Enchantment to remove
-     * @return true if the item meta changed as a result of this call, false
-     *     otherwise
-     */
-    boolean removeEnchant(Enchantment ench);
-
-   /**
-    * Checks if the specified enchantment conflicts with any enchantments in
-    * this ItemMeta.
-    *
-    * @param ench enchantment to test
-    * @return true if the enchantment conflicts, false otherwise
-    */
-    boolean hasConflictingEnchant(Enchantment ench);
-
-    /**
-     * Set itemflags which should be ignored when rendering a ItemStack in the Client. This Method does silently ignore double set itemFlags.
-     *
-     * @param itemFlags The hideflags which shouldn't be rendered
-     */
-    void addItemFlags(ItemFlag... itemFlags);
-
-    /**
-     * Remove specific set of itemFlags. This tells the Client it should render it again. This Method does silently ignore double removed itemFlags.
-     *
-     * @param itemFlags Hideflags which should be removed
-     */
-    void removeItemFlags(ItemFlag... itemFlags);
-
-    /**
-     * Get current set itemFlags. The collection returned is unmodifiable.
-     *
-     * @return A set of all itemFlags set
-     */
-    Set<ItemFlag> getItemFlags();
-
-    /**
-     * Check if the specified flag is present on this item.
-     *
-     * @param flag the flag to check
-     * @return if it is present
-     */
-    boolean hasItemFlag(ItemFlag flag);
-
-    @SuppressWarnings("javadoc")
-    ItemMeta clone();
-}
diff --git a/src/main/java/org/bukkit/inventory/meta/LeatherArmorMeta.java b/src/main/java/org/bukkit/inventory/meta/LeatherArmorMeta.java
deleted file mode 100644
index 2dc2420..0000000
--- a/src/main/java/org/bukkit/inventory/meta/LeatherArmorMeta.java
+++ /dev/null
@@ -1,31 +0,0 @@
-package org.bukkit.inventory.meta;
-
-import org.bukkit.Color;
-import org.bukkit.Material;
-import org.bukkit.inventory.ItemFactory;
-
-/**
- * Represents leather armor ({@link Material#LEATHER_BOOTS}, {@link
- * Material#LEATHER_CHESTPLATE}, {@link Material#LEATHER_HELMET}, or {@link
- * Material#LEATHER_LEGGINGS}) that can be colored.
- */
-public interface LeatherArmorMeta extends ItemMeta {
-
-    /**
-     * Gets the color of the armor. If it has not been set otherwise, it will
-     * be {@link ItemFactory#getDefaultLeatherColor()}.
-     *
-     * @return the color of the armor, never null
-     */
-    Color getColor();
-
-    /**
-     * Sets the color of the armor.
-     *
-     * @param color the color to set. Setting it to null is equivalent to
-     *     setting it to {@link ItemFactory#getDefaultLeatherColor()}.
-     */
-    void setColor(Color color);
-
-    LeatherArmorMeta clone();
-}
diff --git a/src/main/java/org/bukkit/inventory/meta/MapMeta.java b/src/main/java/org/bukkit/inventory/meta/MapMeta.java
deleted file mode 100644
index fb5c297..0000000
--- a/src/main/java/org/bukkit/inventory/meta/MapMeta.java
+++ /dev/null
@@ -1,23 +0,0 @@
-package org.bukkit.inventory.meta;
-
-/**
- * Represents a map that can be scalable.
- */
-public interface MapMeta extends ItemMeta {
-
-    /**
-     * Checks to see if this map is scaling.
-     *
-     * @return true if this map is scaling
-     */
-    boolean isScaling();
-
-    /**
-     * Sets if this map is scaling or not.
-     *
-     * @param value true to scale
-     */
-    void setScaling(boolean value);
-
-    MapMeta clone();
-}
diff --git a/src/main/java/org/bukkit/inventory/meta/PotionMeta.java b/src/main/java/org/bukkit/inventory/meta/PotionMeta.java
deleted file mode 100644
index 2be09e2..0000000
--- a/src/main/java/org/bukkit/inventory/meta/PotionMeta.java
+++ /dev/null
@@ -1,94 +0,0 @@
-package org.bukkit.inventory.meta;
-
-import org.bukkit.potion.PotionEffect;
-import org.bukkit.potion.PotionEffectType;
-import org.bukkit.potion.PotionData;
-import org.bukkit.potion.PotionType;
-
-import java.util.List;
-
-/**
- * Represents a potion or item that can have custom effects.
- */
-public interface PotionMeta extends ItemMeta {
-
-    /**
-     * Sets the underlying potion data
-     *
-     * @param data PotionData to set the base potion state to
-     */
-    void setBasePotionData(PotionData data);
-
-    /**
-     * Returns the potion data about the base potion
-     *
-     * @return a PotionData object
-     */
-    PotionData getBasePotionData();
-
-    /**
-     * Checks for the presence of custom potion effects.
-     *
-     * @return true if custom potion effects are applied
-     */
-    boolean hasCustomEffects();
-
-    /**
-     * Gets an immutable list containing all custom potion effects applied to
-     * this potion.
-     * <p>
-     * Plugins should check that hasCustomEffects() returns true before calling
-     * this method.
-     *
-     * @return the immutable list of custom potion effects
-     */
-    List<PotionEffect> getCustomEffects();
-
-    /**
-     * Adds a custom potion effect to this potion.
-     *
-     * @param effect the potion effect to add
-     * @param overwrite true if any existing effect of the same type should be
-     * overwritten
-     * @return true if the potion meta changed as a result of this call
-     */
-    boolean addCustomEffect(PotionEffect effect, boolean overwrite);
-
-    /**
-     * Removes a custom potion effect from this potion.
-     *
-     * @param type the potion effect type to remove
-     * @return true if the potion meta changed as a result of this call
-     */
-    boolean removeCustomEffect(PotionEffectType type);
-
-    /**
-     * Checks for a specific custom potion effect type on this potion.
-     *
-     * @param type the potion effect type to check for
-     * @return true if the potion has this effect
-     */
-    boolean hasCustomEffect(PotionEffectType type);
-
-    /**
-     * Moves a potion effect to the top of the potion effect list.
-     * <p>
-     * This causes the client to display the potion effect in the potion's name.
-     *
-     * @param type the potion effect type to move
-     * @return true if the potion meta changed as a result of this call
-     * @deprecated use {@link org.bukkit.potion.PotionType#PotionType}
-     */
-    @Deprecated
-    boolean setMainEffect(PotionEffectType type);
-
-    /**
-     * Removes all custom potion effects from this potion.
-     *
-     * @return true if the potion meta changed as a result of this call
-     */
-    boolean clearCustomEffects();
-
-    @Override
-    PotionMeta clone();
-}
diff --git a/src/main/java/org/bukkit/inventory/meta/Repairable.java b/src/main/java/org/bukkit/inventory/meta/Repairable.java
deleted file mode 100644
index c49844e..0000000
--- a/src/main/java/org/bukkit/inventory/meta/Repairable.java
+++ /dev/null
@@ -1,31 +0,0 @@
-package org.bukkit.inventory.meta;
-
-/**
- * Represents an item that can be repaired at an anvil.
- */
-public interface Repairable {
-
-    /**
-     * Checks to see if this has a repair penalty
-     *
-     * @return true if this has a repair penalty
-     */
-    boolean hasRepairCost();
-
-    /**
-     * Gets the repair penalty
-     *
-     * @return the repair penalty
-     */
-    int getRepairCost();
-
-    /**
-     * Sets the repair penalty
-     *
-     * @param cost repair penalty
-     */
-    void setRepairCost(int cost);
-
-    @SuppressWarnings("javadoc")
-    Repairable clone();
-}
diff --git a/src/main/java/org/bukkit/inventory/meta/SkullMeta.java b/src/main/java/org/bukkit/inventory/meta/SkullMeta.java
deleted file mode 100644
index fab3119..0000000
--- a/src/main/java/org/bukkit/inventory/meta/SkullMeta.java
+++ /dev/null
@@ -1,36 +0,0 @@
-package org.bukkit.inventory.meta;
-
-import org.bukkit.Material;
-
-/**
- * Represents a skull ({@link Material#SKULL_ITEM}) that can have an owner.
- */
-public interface SkullMeta extends ItemMeta {
-
-    /**
-     * Gets the owner of the skull.
-     *
-     * @return the owner if the skull
-     */
-    String getOwner();
-
-    /**
-     * Checks to see if the skull has an owner.
-     *
-     * @return true if the skull has an owner
-     */
-    boolean hasOwner();
-
-    /**
-     * Sets the owner of the skull.
-     * <p>
-     * Plugins should check that hasOwner() returns true before calling this
-     * plugin.
-     *
-     * @param owner the new owner of the skull
-     * @return true if the owner was successfully set
-     */
-    boolean setOwner(String owner);
-
-    SkullMeta clone();
-}
diff --git a/src/main/java/org/bukkit/map/MapCanvas.java b/src/main/java/org/bukkit/map/MapCanvas.java
deleted file mode 100644
index d68bb17..0000000
--- a/src/main/java/org/bukkit/map/MapCanvas.java
+++ /dev/null
@@ -1,84 +0,0 @@
-package org.bukkit.map;
-
-import java.awt.Image;
-
-/**
- * Represents a canvas for drawing to a map. Each canvas is associated with a
- * specific {@link MapRenderer} and represents that renderer's layer on the
- * map.
- */
-public interface MapCanvas {
-
-    /**
-     * Get the map this canvas is attached to.
-     *
-     * @return The MapView this canvas is attached to.
-     */
-    public MapView getMapView();
-
-    /**
-     * Get the cursor collection associated with this canvas.
-     *
-     * @return The MapCursorCollection associated with this canvas.
-     */
-    public MapCursorCollection getCursors();
-
-    /**
-     * Set the cursor collection associated with this canvas. This does not
-     * usually need to be called since a MapCursorCollection is already
-     * provided.
-     *
-     * @param cursors The MapCursorCollection to associate with this canvas.
-     */
-    public void setCursors(MapCursorCollection cursors);
-
-    /**
-     * Draw a pixel to the canvas.
-     *
-     * @param x The x coordinate, from 0 to 127.
-     * @param y The y coordinate, from 0 to 127.
-     * @param color The color. See {@link MapPalette}.
-     */
-    public void setPixel(int x, int y, byte color);
-
-    /**
-     * Get a pixel from the canvas.
-     *
-     * @param x The x coordinate, from 0 to 127.
-     * @param y The y coordinate, from 0 to 127.
-     * @return The color. See {@link MapPalette}.
-     */
-    public byte getPixel(int x, int y);
-
-    /**
-     * Get a pixel from the layers below this canvas.
-     *
-     * @param x The x coordinate, from 0 to 127.
-     * @param y The y coordinate, from 0 to 127.
-     * @return The color. See {@link MapPalette}.
-     */
-    public byte getBasePixel(int x, int y);
-
-    /**
-     * Draw an image to the map. The image will be clipped if necessary.
-     *
-     * @param x The x coordinate of the image.
-     * @param y The y coordinate of the image.
-     * @param image The Image to draw.
-     */
-    public void drawImage(int x, int y, Image image);
-
-    /**
-     * Render text to the map using fancy formatting. Newline (\n) characters
-     * will move down one line and return to the original column, and the text
-     * color can be changed using sequences such as "§12;", replacing 12 with
-     * the palette index of the color (see {@link MapPalette}).
-     *
-     * @param x The column to start rendering on.
-     * @param y The row to start rendering on.
-     * @param font The font to use.
-     * @param text The formatted text to render.
-     */
-    public void drawText(int x, int y, MapFont font, String text);
-
-}
diff --git a/src/main/java/org/bukkit/map/MapCursor.java b/src/main/java/org/bukkit/map/MapCursor.java
deleted file mode 100644
index 5231749..0000000
--- a/src/main/java/org/bukkit/map/MapCursor.java
+++ /dev/null
@@ -1,192 +0,0 @@
-package org.bukkit.map;
-
-/**
- * Represents a cursor on a map.
- */
-public final class MapCursor {
-    private byte x, y;
-    private byte direction, type;
-    private boolean visible;
-
-    /**
-     * Initialize the map cursor.
-     *
-     * @param x The x coordinate, from -128 to 127.
-     * @param y The y coordinate, from -128 to 127.
-     * @param direction The facing of the cursor, from 0 to 15.
-     * @param type The type (color/style) of the map cursor.
-     * @param visible Whether the cursor is visible by default.
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public MapCursor(byte x, byte y, byte direction, byte type, boolean visible) {
-        this.x = x;
-        this.y = y;
-        setDirection(direction);
-        setRawType(type);
-        this.visible = visible;
-    }
-
-    /**
-     * Get the X position of this cursor.
-     *
-     * @return The X coordinate.
-     */
-    public byte getX() {
-        return x;
-    }
-
-    /**
-     * Get the Y position of this cursor.
-     *
-     * @return The Y coordinate.
-     */
-    public byte getY() {
-        return y;
-    }
-
-    /**
-     * Get the direction of this cursor.
-     *
-     * @return The facing of the cursor, from 0 to 15.
-     */
-    public byte getDirection() {
-        return direction;
-    }
-
-    /**
-     * Get the type of this cursor.
-     *
-     * @return The type (color/style) of the map cursor.
-     */
-    public Type getType() {
-        return Type.byValue(type);
-    }
-
-    /**
-     * Get the type of this cursor.
-     *
-     * @return The type (color/style) of the map cursor.
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public byte getRawType() {
-        return type;
-    }
-
-    /**
-     * Get the visibility status of this cursor.
-     *
-     * @return True if visible, false otherwise.
-     */
-    public boolean isVisible() {
-        return visible;
-    }
-
-    /**
-     * Set the X position of this cursor.
-     *
-     * @param x The X coordinate.
-     */
-    public void setX(byte x) {
-        this.x = x;
-    }
-
-    /**
-     * Set the Y position of this cursor.
-     *
-     * @param y The Y coordinate.
-     */
-    public void setY(byte y) {
-        this.y = y;
-    }
-
-    /**
-     * Set the direction of this cursor.
-     *
-     * @param direction The facing of the cursor, from 0 to 15.
-     */
-    public void setDirection(byte direction) {
-        if (direction < 0 || direction > 15) {
-            throw new IllegalArgumentException("Direction must be in the range 0-15");
-        }
-        this.direction = direction;
-    }
-
-    /**
-     * Set the type of this cursor.
-     *
-     * @param type The type (color/style) of the map cursor.
-     */
-    public void setType(Type type) {
-        setRawType(type.value);
-    }
-
-    /**
-     * Set the type of this cursor.
-     *
-     * @param type The type (color/style) of the map cursor.
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public void setRawType(byte type) {
-        if (type < 0 || type > 15) {
-            throw new IllegalArgumentException("Type must be in the range 0-15");
-        }
-        this.type = type;
-    }
-
-    /**
-     * Set the visibility status of this cursor.
-     *
-     * @param visible True if visible.
-     */
-    public void setVisible(boolean visible) {
-        this.visible = visible;
-    }
-
-    /**
-     * Represents the standard types of map cursors. More may be made
-     * available by texture packs - the value is used by the client as an
-     * index in the file './misc/mapicons.png' from minecraft.jar or from a
-     * texture pack.
-     */
-    public enum Type {
-        WHITE_POINTER(0),
-        GREEN_POINTER(1),
-        RED_POINTER(2),
-        BLUE_POINTER(3),
-        WHITE_CROSS(4);
-
-        private byte value;
-
-        private Type(int value) {
-            this.value = (byte) value;
-        }
-
-        /**
-         *
-         * @return the value 
-         * @deprecated Magic value
-         */
-        @Deprecated
-        public byte getValue() {
-            return value;
-        }
-
-        /**
-         *
-         * @param value the value
-         * @return the matching type
-         * @deprecated Magic value
-         */
-        @Deprecated
-        public static Type byValue(byte value) {
-            for (Type t : values()) {
-                if (t.value == value) return t;
-            }
-            return null;
-        }
-    }
-
-}
diff --git a/src/main/java/org/bukkit/map/MapCursorCollection.java b/src/main/java/org/bukkit/map/MapCursorCollection.java
deleted file mode 100644
index 1dc9025..0000000
--- a/src/main/java/org/bukkit/map/MapCursorCollection.java
+++ /dev/null
@@ -1,96 +0,0 @@
-package org.bukkit.map;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * Represents all the map cursors on a {@link MapCanvas}. Like MapCanvas, a
- * MapCursorCollection is linked to a specific {@link MapRenderer}.
- */
-public final class MapCursorCollection {
-    private List<MapCursor> cursors = new ArrayList<MapCursor>();
-
-    /**
-     * Get the amount of cursors in this collection.
-     *
-     * @return The size of this collection.
-     */
-    public int size() {
-        return cursors.size();
-    }
-
-    /**
-     * Get a cursor from this collection.
-     *
-     * @param index The index of the cursor.
-     * @return The MapCursor.
-     */
-    public MapCursor getCursor(int index) {
-        return cursors.get(index);
-    }
-
-    /**
-     * Remove a cursor from the collection.
-     *
-     * @param cursor The MapCursor to remove.
-     * @return Whether the cursor was removed successfully.
-     */
-    public boolean removeCursor(MapCursor cursor) {
-        return cursors.remove(cursor);
-    }
-
-    /**
-     * Add a cursor to the collection.
-     *
-     * @param cursor The MapCursor to add.
-     * @return The MapCursor that was passed.
-     */
-    public MapCursor addCursor(MapCursor cursor) {
-        cursors.add(cursor);
-        return cursor;
-    }
-
-    /**
-     * Add a cursor to the collection.
-     *
-     * @param x The x coordinate, from -128 to 127.
-     * @param y The y coordinate, from -128 to 127.
-     * @param direction The facing of the cursor, from 0 to 15.
-     * @return The newly added MapCursor.
-     */
-    public MapCursor addCursor(int x, int y, byte direction) {
-        return addCursor(x, y, direction, (byte) 0, true);
-    }
-
-    /**
-     * Add a cursor to the collection.
-     *
-     * @param x The x coordinate, from -128 to 127.
-     * @param y The y coordinate, from -128 to 127.
-     * @param direction The facing of the cursor, from 0 to 15.
-     * @param type The type (color/style) of the map cursor.
-     * @return The newly added MapCursor.
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public MapCursor addCursor(int x, int y, byte direction, byte type) {
-        return addCursor(x, y, direction, type, true);
-    }
-
-    /**
-     * Add a cursor to the collection.
-     *
-     * @param x The x coordinate, from -128 to 127.
-     * @param y The y coordinate, from -128 to 127.
-     * @param direction The facing of the cursor, from 0 to 15.
-     * @param type The type (color/style) of the map cursor.
-     * @param visible Whether the cursor is visible.
-     * @return The newly added MapCursor.
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public MapCursor addCursor(int x, int y, byte direction, byte type, boolean visible) {
-        return addCursor(new MapCursor((byte) x, (byte) y, direction, type, visible));
-    }
-
-}
diff --git a/src/main/java/org/bukkit/map/MapFont.java b/src/main/java/org/bukkit/map/MapFont.java
deleted file mode 100644
index ea8f0ea..0000000
--- a/src/main/java/org/bukkit/map/MapFont.java
+++ /dev/null
@@ -1,144 +0,0 @@
-package org.bukkit.map;
-
-import java.util.HashMap;
-
-/**
- * Represents a bitmap font drawable to a map.
- */
-public class MapFont {
-
-    private final HashMap<Character, CharacterSprite> chars = new HashMap<Character, CharacterSprite>();
-    private int height = 0;
-    protected boolean malleable = true;
-
-    /**
-     * Set the sprite for a given character.
-     *
-     * @param ch The character to set the sprite for.
-     * @param sprite The CharacterSprite to set.
-     * @throws IllegalStateException if this font is static.
-     */
-    public void setChar(char ch, CharacterSprite sprite) {
-        if (!malleable) {
-            throw new IllegalStateException("this font is not malleable");
-        }
-
-        chars.put(ch, sprite);
-        if (sprite.getHeight() > height) {
-            height = sprite.getHeight();
-        }
-    }
-
-    /**
-     * Get the sprite for a given character.
-     *
-     * @param ch The character to get the sprite for.
-     * @return The CharacterSprite associated with the character, or null if
-     *     there is none.
-     */
-    public CharacterSprite getChar(char ch) {
-        return chars.get(ch);
-    }
-
-    /**
-     * Get the width of the given text as it would be rendered using this
-     * font.
-     *
-     * @param text The text.
-     * @return The width in pixels.
-     */
-    public int getWidth(String text) {
-        if (!isValid(text)) {
-            throw new IllegalArgumentException("text contains invalid characters");
-        }
-
-        if (text.length() == 0){
-            return 0;
-        }
-
-        int result = 0;
-        for (int i = 0; i < text.length(); ++i) {
-            result += chars.get(text.charAt(i)).getWidth();
-        }
-        result += text.length() - 1; // Account for 1px spacing between characters
-
-        return result;
-    }
-
-    /**
-     * Get the height of this font.
-     *
-     * @return The height of the font.
-     */
-    public int getHeight() {
-        return height;
-    }
-
-    /**
-     * Check whether the given text is valid.
-     *
-     * @param text The text.
-     * @return True if the string contains only defined characters, false
-     *     otherwise.
-     */
-    public boolean isValid(String text) {
-        for (int i = 0; i < text.length(); ++i) {
-            char ch = text.charAt(i);
-            if (ch == '\u00A7' || ch == '\n') continue;
-            if (chars.get(ch) == null) return false;
-        }
-        return true;
-    }
-
-    /**
-     * Represents the graphics for a single character in a MapFont.
-     */
-    public static class CharacterSprite {
-
-        private final int width;
-        private final int height;
-        private final boolean[] data;
-
-        public CharacterSprite(int width, int height, boolean[] data) {
-            this.width = width;
-            this.height = height;
-            this.data = data;
-
-            if (data.length != width * height) {
-                throw new IllegalArgumentException("size of data does not match dimensions");
-            }
-        }
-
-        /**
-         * Get the value of a pixel of the character.
-         *
-         * @param row The row, in the range [0,8).
-         * @param col The column, in the range [0,8).
-         * @return True if the pixel is solid, false if transparent.
-         */
-        public boolean get(int row, int col) {
-            if (row < 0 || col < 0 || row >= height || col >= width) return false;
-            return data[row * width + col];
-        }
-
-        /**
-         * Get the width of the character sprite.
-         *
-         * @return The width of the character.
-         */
-        public int getWidth() {
-            return width;
-        }
-
-        /**
-         * Get the height of the character sprite.
-         *
-         * @return The height of the character.
-         */
-        public int getHeight() {
-            return height;
-        }
-
-    }
-
-}
diff --git a/src/main/java/org/bukkit/map/MapPalette.java b/src/main/java/org/bukkit/map/MapPalette.java
deleted file mode 100644
index 3aca081..0000000
--- a/src/main/java/org/bukkit/map/MapPalette.java
+++ /dev/null
@@ -1,240 +0,0 @@
-package org.bukkit.map;
-
-import java.awt.Color;
-import java.awt.Graphics2D;
-import java.awt.Image;
-import java.awt.image.BufferedImage;
-
-/**
- * Represents the palette that map items use.
- * <p>
- * These fields are hee base color ranges. Each entry corresponds to four
- * colors of varying shades with values entry to entry + 3.
- */
-public final class MapPalette {
-    // Internal mechanisms
-    private MapPalette() {}
-
-    private static Color c(int r, int g, int b) {
-        return new Color(r, g, b);
-    }
-
-    private static double getDistance(Color c1, Color c2) {
-        double rmean = (c1.getRed() + c2.getRed()) / 2.0;
-        double r = c1.getRed() - c2.getRed();
-        double g = c1.getGreen() - c2.getGreen();
-        int b = c1.getBlue() - c2.getBlue();
-        double weightR = 2 + rmean / 256.0;
-        double weightG = 4.0;
-        double weightB = 2 + (255 - rmean) / 256.0;
-        return weightR * r * r + weightG * g * g + weightB * b * b;
-    }
-
-    static final Color[] colors = {
-        c(0, 0, 0), c(0, 0, 0), c(0, 0, 0), c(0, 0, 0),
-        c(89, 125, 39), c(109, 153, 48), c(127, 178, 56), c(67, 94, 29),
-        c(174, 164, 115), c(213, 201, 140), c(247, 233, 163), c(130, 123, 86),
-        c(140, 140, 140), c(171, 171, 171), c(199, 199, 199), c(105, 105, 105),
-        c(180, 0, 0), c(220, 0, 0), c(255, 0, 0), c(135, 0, 0),
-        c(112, 112, 180), c(138, 138, 220), c(160, 160, 255), c(84, 84, 135),
-        c(117, 117, 117), c(144, 144, 144), c(167, 167, 167), c(88, 88, 88),
-        c(0, 87, 0), c(0, 106, 0), c(0, 124, 0), c(0, 65, 0),
-        c(180, 180, 180), c(220, 220, 220), c(255, 255, 255), c(135, 135, 135),
-        c(115, 118, 129), c(141, 144, 158), c(164, 168, 184), c(86, 88, 97),
-        c(106, 76, 54), c(130, 94, 66), c(151, 109, 77), c(79, 57, 40),
-        c(79, 79, 79), c(96, 96, 96), c(112, 112, 112), c(59, 59, 59),
-        c(45, 45, 180), c(55, 55, 220), c(64, 64, 255), c(33, 33, 135),
-        c(100, 84, 50), c(123, 102, 62), c(143, 119, 72), c(75, 63, 38),
-        c(180, 177, 172), c(220, 217, 211), c(255, 252, 245), c(135, 133, 129),
-        c(152, 89, 36), c(186, 109, 44), c(216, 127, 51), c(114, 67, 27),
-        c(125, 53, 152), c(153, 65, 186), c(178, 76, 216), c(94, 40, 114),
-        c(72, 108, 152), c(88, 132, 186), c(102, 153, 216), c(54, 81, 114),
-        c(161, 161, 36), c(197, 197, 44), c(229, 229, 51), c(121, 121, 27),
-        c(89, 144, 17), c(109, 176, 21), c(127, 204, 25), c(67, 108, 13),
-        c(170, 89, 116), c(208, 109, 142), c(242, 127, 165), c(128, 67, 87),
-        c(53, 53, 53), c(65, 65, 65), c(76, 76, 76), c(40, 40, 40),
-        c(108, 108, 108), c(132, 132, 132), c(153, 153, 153), c(81, 81, 81),
-        c(53, 89, 108), c(65, 109, 132), c(76, 127, 153), c(40, 67, 81),
-        c(89, 44, 125), c(109, 54, 153), c(127, 63, 178), c(67, 33, 94),
-        c(36, 53, 125), c(44, 65, 153), c(51, 76, 178), c(27, 40, 94),
-        c(72, 53, 36), c(88, 65, 44), c(102, 76, 51), c(54, 40, 27),
-        c(72, 89, 36), c(88, 109, 44), c(102, 127, 51), c(54, 67, 27),
-        c(108, 36, 36), c(132, 44, 44), c(153, 51, 51), c(81, 27, 27),
-        c(17, 17, 17), c(21, 21, 21), c(25, 25, 25), c(13, 13, 13),
-        c(176, 168, 54), c(215, 205, 66), c(250, 238, 77), c(132, 126, 40),
-        c(64, 154, 150), c(79, 188, 183), c(92, 219, 213), c(48, 115, 112),
-        c(52, 90, 180), c(63, 110, 220), c(74, 128, 255), c(39, 67, 135),
-        c(0, 153, 40), c(0, 187, 50), c(0, 217, 58), c(0, 114, 30),
-        c(91, 60, 34), c(111, 74, 42), c(129, 86, 49), c(68, 45, 25),
-        c(79, 1, 0), c(96, 1, 0), c(112, 2, 0), c(59, 1, 0),
-    };
-
-    // Interface
-    /**
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public static final byte TRANSPARENT = 0;
-    /**
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public static final byte LIGHT_GREEN = 4;
-    /**
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public static final byte LIGHT_BROWN = 8;
-    /**
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public static final byte GRAY_1 = 12;
-    /**
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public static final byte RED = 16;
-    /**
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public static final byte PALE_BLUE = 20;
-    /**
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public static final byte GRAY_2 = 24;
-    /**
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public static final byte DARK_GREEN = 28;
-    /**
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public static final byte WHITE = 32;
-    /**
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public static final byte LIGHT_GRAY = 36;
-    /**
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public static final byte BROWN = 40;
-    /**
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public static final byte DARK_GRAY = 44;
-    /**
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public static final byte BLUE = 48;
-    /**
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public static final byte DARK_BROWN = 52;
-
-    /**
-     * Resize an image to 128x128.
-     *
-     * @param image The image to resize.
-     * @return The resized image.
-     */
-    public static BufferedImage resizeImage(Image image) {
-        BufferedImage result = new BufferedImage(128, 128, BufferedImage.TYPE_INT_ARGB);
-        Graphics2D graphics = result.createGraphics();
-        graphics.drawImage(image, 0, 0, 128, 128, null);
-        graphics.dispose();
-        return result;
-    }
-
-    /**
-     * Convert an Image to a byte[] using the palette.
-     *
-     * @param image The image to convert.
-     * @return A byte[] containing the pixels of the image.
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public static byte[] imageToBytes(Image image) {
-        BufferedImage temp = new BufferedImage(image.getWidth(null), image.getHeight(null), BufferedImage.TYPE_INT_ARGB);
-        Graphics2D graphics = temp.createGraphics();
-        graphics.drawImage(image, 0, 0, null);
-        graphics.dispose();
-
-        int[] pixels = new int[temp.getWidth() * temp.getHeight()];
-        temp.getRGB(0, 0, temp.getWidth(), temp.getHeight(), pixels, 0, temp.getWidth());
-
-        byte[] result = new byte[temp.getWidth() * temp.getHeight()];
-        for (int i = 0; i < pixels.length; i++) {
-            result[i] = matchColor(new Color(pixels[i], true));
-        }
-        return result;
-    }
-
-    /**
-     * Get the index of the closest matching color in the palette to the given
-     * color.
-     *
-     * @param r The red component of the color.
-     * @param b The blue component of the color.
-     * @param g The green component of the color.
-     * @return The index in the palette.
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public static byte matchColor(int r, int g, int b) {
-        return matchColor(new Color(r, g, b));
-    }
-
-    /**
-     * Get the index of the closest matching color in the palette to the given
-     * color.
-     *
-     * @param color The Color to match.
-     * @return The index in the palette.
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public static byte matchColor(Color color) {
-        if (color.getAlpha() < 128) return 0;
-
-        int index = 0;
-        double best = -1;
-
-        for (int i = 4; i < colors.length; i++) {
-            double distance = getDistance(color, colors[i]);
-            if (distance < best || best == -1) {
-                best = distance;
-                index = i;
-            }
-        }
-
-        // Minecraft has 143 colors, some of which have negative byte representations
-        return (byte) (index < 128 ? index : -129 + (index - 127));
-    }
-
-    /**
-     * Get the value of the given color in the palette.
-     *
-     * @param index The index in the palette.
-     * @return The Color of the palette entry.
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public static Color getColor(byte index) {
-        if ((index > -113 && index < 0) || index > 127) {
-            throw new IndexOutOfBoundsException();
-        } else {
-            // Minecraft has 143 colors, some of which have negative byte representations
-            return colors[index >= 0 ? index : index + 256];
-        }
-    }
-}
diff --git a/src/main/java/org/bukkit/map/MapRenderer.java b/src/main/java/org/bukkit/map/MapRenderer.java
deleted file mode 100644
index 322d0ce..0000000
--- a/src/main/java/org/bukkit/map/MapRenderer.java
+++ /dev/null
@@ -1,56 +0,0 @@
-package org.bukkit.map;
-
-import org.bukkit.entity.Player;
-
-/**
- * Represents a renderer for a map.
- */
-public abstract class MapRenderer {
-
-    private boolean contextual;
-
-    /**
-     * Initialize the map renderer base to be non-contextual. See {@link
-     * #isContextual()}.
-     */
-    public MapRenderer() {
-        this(false);
-    }
-
-    /**
-     * Initialize the map renderer base with the given contextual status.
-     *
-     * @param contextual Whether the renderer is contextual. See {@link
-     *     #isContextual()}.
-     */
-    public MapRenderer(boolean contextual) {
-        this.contextual = contextual;
-    }
-
-    /**
-     * Get whether the renderer is contextual, i.e. has different canvases for
-     * different players.
-     *
-     * @return True if contextual, false otherwise.
-     */
-    final public boolean isContextual() {
-        return contextual;
-    }
-
-    /**
-     * Initialize this MapRenderer for the given map.
-     *
-     * @param map The MapView being initialized.
-     */
-    public void initialize(MapView map) {}
-
-    /**
-     * Render to the given map.
-     *
-     * @param map The MapView being rendered to.
-     * @param canvas The canvas to use for rendering.
-     * @param player The player who triggered the rendering.
-     */
-    abstract public void render(MapView map, MapCanvas canvas, Player player);
-
-}
diff --git a/src/main/java/org/bukkit/map/MapView.java b/src/main/java/org/bukkit/map/MapView.java
deleted file mode 100644
index 65c4159..0000000
--- a/src/main/java/org/bukkit/map/MapView.java
+++ /dev/null
@@ -1,157 +0,0 @@
-package org.bukkit.map;
-
-import java.util.List;
-import org.bukkit.World;
-
-/**
- * Represents a map item.
- */
-public interface MapView {
-
-    /**
-     * An enum representing all possible scales a map can be set to.
-     */
-    public static enum Scale {
-        CLOSEST(0),
-        CLOSE(1),
-        NORMAL(2),
-        FAR(3),
-        FARTHEST(4);
-
-        private byte value;
-
-        private Scale(int value) {
-            this.value = (byte) value;
-        }
-
-        /**
-         * Get the scale given the raw value.
-         *
-         * @param value The raw scale
-         * @return The enum scale, or null for an invalid input
-         * @deprecated Magic value
-         */
-        @Deprecated
-        public static Scale valueOf(byte value) {
-            switch (value) {
-            case 0: return CLOSEST;
-            case 1: return CLOSE;
-            case 2: return NORMAL;
-            case 3: return FAR;
-            case 4: return FARTHEST;
-            default: return null;
-            }
-        }
-
-        /**
-         * Get the raw value of this scale level.
-         *
-         * @return The scale value
-         * @deprecated Magic value
-         */
-        @Deprecated
-        public byte getValue() {
-            return value;
-        }
-    }
-
-    /**
-     * Get the ID of this map item. Corresponds to the damage value of a map
-     * in an inventory.
-     *
-     * @return The ID of the map.
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public short getId();
-
-    /**
-     * Check whether this map is virtual. A map is virtual if its lowermost
-     * MapRenderer is plugin-provided.
-     *
-     * @return Whether the map is virtual.
-     */
-    public boolean isVirtual();
-
-    /**
-     * Get the scale of this map.
-     *
-     * @return The scale of the map.
-     */
-    public Scale getScale();
-
-    /**
-     * Set the scale of this map.
-     *
-     * @param scale The scale to set.
-     */
-    public void setScale(Scale scale);
-
-    /**
-     * Get the center X position of this map.
-     *
-     * @return The center X position.
-     */
-    public int getCenterX();
-
-    /**
-     * Get the center Z position of this map.
-     *
-     * @return The center Z position.
-     */
-    public int getCenterZ();
-
-    /**
-     * Set the center X position of this map.
-     *
-     * @param x The center X position.
-     */
-    public void setCenterX(int x);
-
-    /**
-     * Set the center Z position of this map.
-     *
-     * @param z The center Z position.
-     */
-    public void setCenterZ(int z);
-
-    /**
-     * Get the world that this map is associated with. Primarily used by the
-     * internal renderer, but may be used by external renderers. May return
-     * null if the world the map is associated with is not loaded.
-     *
-     * @return The World this map is associated with.
-     */
-    public World getWorld();
-
-    /**
-     * Set the world that this map is associated with. The world is used by
-     * the internal renderer, and may also be used by external renderers.
-     *
-     * @param world The World to associate this map with.
-     */
-    public void setWorld(World world);
-
-    /**
-     * Get a list of MapRenderers currently in effect.
-     *
-     * @return A {@code List<MapRenderer>} containing each map renderer.
-     */
-    public List<MapRenderer> getRenderers();
-
-    /**
-     * Add a renderer to this map.
-     *
-     * @param renderer The MapRenderer to add.
-     */
-    public void addRenderer(MapRenderer renderer);
-
-    /**
-     * Remove a renderer from this map.
-     *
-     * @param renderer The MapRenderer to remove.
-     * @return True if the renderer was successfully removed.
-     */
-    public boolean removeRenderer(MapRenderer renderer);
-
-}
diff --git a/src/main/java/org/bukkit/map/MinecraftFont.java b/src/main/java/org/bukkit/map/MinecraftFont.java
deleted file mode 100644
index 9ec8d10..0000000
--- a/src/main/java/org/bukkit/map/MinecraftFont.java
+++ /dev/null
@@ -1,328 +0,0 @@
-package org.bukkit.map;
-
-/**
- * Represents the built-in Minecraft font.
- */
-public class MinecraftFont extends MapFont {
-
-    private static final int spaceSize = 2;
-
-    private static final String fontChars =
-        " !\"#$%&'()*+,-./0123456789:;<=>?" +
-        "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_" +
-        "'abcdefghijklmnopqrstuvwxyz{|}~\u007F" +
-        "\u00C7\u00FC\u00E9\u00E2\u00E4\u00E0\u00E5\u00E7" + // Çüéâäàåç
-        "\u00EA\u00EB\u00E8\u00EF\u00EE\u00EC\u00C4\u00C5" + // êëèïîìÄÅ
-        "\u00C9\u00E6\u00C6\u00F4\u00F6\u00F2\u00FB\u00F9" + // ÉæÆôöòûù
-        "\u00FF\u00D6\u00DC\u00F8\u00A3\u00D8\u00D7\u0191" + // ÿÖÜø£Ø×ƒ
-        "\u00E1\u00ED\u00F3\u00FA\u00F1\u00D1\u00AA\u00BA" + // áíóúñÑªº
-        "\u00BF\u00AE\u00AC\u00BD\u00BC\u00A1\u00AB\u00BB";  // ¿®¬½¼¡«»
-
-    private static final int[][] fontData = new int[][] {
-        /* null */  {0,0,0,0,0,0,0,0},
-        /* 1 */  {126,129,165,129,189,153,129,126},
-        /* 2 */  {126,255,219,255,195,231,255,126},
-        /* 3 */  {54,127,127,127,62,28,8,0},
-        /* 4 */  {8,28,62,127,62,28,8,0},
-        /* 5 */  {28,62,28,127,127,62,28,62},
-        /* 6 */  {8,8,28,62,127,62,28,62},
-        /* 7 */  {0,0,24,60,60,24,0,0},
-        /* 8 */  {255,255,231,195,195,231,255,255},
-        /* 9 */  {0,60,102,66,66,102,60,0},
-        /* 10 */  {255,195,153,189,189,153,195,255},
-        /* 11 */  {240,224,240,190,51,51,51,30},
-        /* 12 */  {60,102,102,102,60,24,126,24},
-        /* 13 */  {252,204,252,12,12,14,15,7},
-        /* 14 */  {254,198,254,198,198,230,103,3},
-        /* 15 */  {153,90,60,231,231,60,90,153},
-        /* 16 */  {1,7,31,127,31,7,1,0},
-        /* 17 */  {64,112,124,127,124,112,64,0},
-        /* 18 */  {24,60,126,24,24,126,60,24},
-        /* 19 */  {102,102,102,102,102,0,102,0},
-        /* 20 */  {254,219,219,222,216,216,216,0},
-        /* 21 */  {124,198,28,54,54,28,51,30},
-        /* 22 */  {0,0,0,0,126,126,126,0},
-        /* 23 */  {24,60,126,24,126,60,24,255},
-        /* 24 */  {24,60,126,24,24,24,24,0},
-        /* 25 */  {24,24,24,24,126,60,24,0},
-        /* 26 */  {0,24,48,127,48,24,0,0},
-        /* 27 */  {0,12,6,127,6,12,0,0},
-        /* 28 */  {0,0,3,3,3,127,0,0},
-        /* 29 */  {0,36,102,255,102,36,0,0},
-        /* 30 */  {0,24,60,126,255,255,0,0},
-        /* 31 */  {0,255,255,126,60,24,0,0},
-        /*   */  {0,0,0,0,0,0,0,0},
-        /* ! */  {1,1,1,1,1,0,1,0},
-        /* " */  {10,10,5,0,0,0,0,0},
-        /* # */  {10,10,31,10,31,10,10,0},
-        /* $ */  {4,30,1,14,16,15,4,0},
-        /* % */  {17,9,8,4,2,18,17,0},
-        /* & */  {4,10,4,22,13,9,22,0},
-        /* ' */  {2,2,1,0,0,0,0,0},
-        /* ( */  {12,2,1,1,1,2,12,0},
-        /* ) */  {3,4,8,8,8,4,3,0},
-        /* * */  {0,0,9,6,9,0,0,0},
-        /* + */  {0,4,4,31,4,4,0,0},
-        /* , */  {0,0,0,0,0,1,1,1},
-        /* - */  {0,0,0,31,0,0,0,0},
-        /* . */  {0,0,0,0,0,1,1,0},
-        /* / */  {16,8,8,4,2,2,1,0},
-        /* 0 */  {14,17,25,21,19,17,14,0},
-        /* 1 */  {4,6,4,4,4,4,31,0},
-        /* 2 */  {14,17,16,12,2,17,31,0},
-        /* 3 */  {14,17,16,12,16,17,14,0},
-        /* 4 */  {24,20,18,17,31,16,16,0},
-        /* 5 */  {31,1,15,16,16,17,14,0},
-        /* 6 */  {12,2,1,15,17,17,14,0},
-        /* 7 */  {31,17,16,8,4,4,4,0},
-        /* 8 */  {14,17,17,14,17,17,14,0},
-        /* 9 */  {14,17,17,30,16,8,6,0},
-        /* : */  {0,1,1,0,0,1,1,0},
-        /* ; */  {0,1,1,0,0,1,1,1},
-        /* < */  {8,4,2,1,2,4,8,0},
-        /* = */  {0,0,31,0,0,31,0,0},
-        /* > */  {1,2,4,8,4,2,1,0},
-        /* ? */  {14,17,16,8,4,0,4,0},
-        /* @ */  {30,33,45,45,61,1,30,0},
-        /* A */  {14,17,31,17,17,17,17,0},
-        /* B */  {15,17,15,17,17,17,15,0},
-        /* C */  {14,17,1,1,1,17,14,0},
-        /* D */  {15,17,17,17,17,17,15,0},
-        /* E */  {31,1,7,1,1,1,31,0},
-        /* F */  {31,1,7,1,1,1,1,0},
-        /* G */  {30,1,25,17,17,17,14,0},
-        /* H */  {17,17,31,17,17,17,17,0},
-        /* I */  {7,2,2,2,2,2,7,0},
-        /* J */  {16,16,16,16,16,17,14,0},
-        /* K */  {17,9,7,9,17,17,17,0},
-        /* L */  {1,1,1,1,1,1,31,0},
-        /* M */  {17,27,21,17,17,17,17,0},
-        /* N */  {17,19,21,25,17,17,17,0},
-        /* O */  {14,17,17,17,17,17,14,0},
-        /* P */  {15,17,15,1,1,1,1,0},
-        /* Q */  {14,17,17,17,17,9,22,0},
-        /* R */  {15,17,15,17,17,17,17,0},
-        /* S */  {30,1,14,16,16,17,14,0},
-        /* T */  {31,4,4,4,4,4,4,0},
-        /* U */  {17,17,17,17,17,17,14,0},
-        /* V */  {17,17,17,17,10,10,4,0},
-        /* W */  {17,17,17,17,21,27,17,0},
-        /* X */  {17,10,4,10,17,17,17,0},
-        /* Y */  {17,10,4,4,4,4,4,0},
-        /* Z */  {31,16,8,4,2,1,31,0},
-        /* [ */  {7,1,1,1,1,1,7,0},
-        /* \ */  {1,2,2,4,8,8,16,0},
-        /* ] */  {7,4,4,4,4,4,7,0},
-        /* ^ */  {4,10,17,0,0,0,0,0},
-        /* _ */  {0,0,0,0,0,0,0,31},
-        /* ` */  {1,1,2,0,0,0,0,0},
-        /* a */  {0,0,14,16,30,17,30,0},
-        /* b */  {1,1,13,19,17,17,15,0},
-        /* c */  {0,0,14,17,1,17,14,0},
-        /* d */  {16,16,22,25,17,17,30,0},
-        /* e */  {0,0,14,17,31,1,30,0},
-        /* f */  {12,2,15,2,2,2,2,0},
-        /* g */  {0,0,30,17,17,30,16,15},
-        /* h */  {1,1,13,19,17,17,17,0},
-        /* i */  {1,0,1,1,1,1,1,0},
-        /* j */  {16,0,16,16,16,17,17,14},
-        /* k */  {1,1,9,5,3,5,9,0},
-        /* l */  {1,1,1,1,1,1,2,0},
-        /* m */  {0,0,11,21,21,17,17,0},
-        /* n */  {0,0,15,17,17,17,17,0},
-        /* o */  {0,0,14,17,17,17,14,0},
-        /* p */  {0,0,13,19,17,15,1,1},
-        /* q */  {0,0,22,25,17,30,16,16},
-        /* r */  {0,0,13,19,1,1,1,0},
-        /* s */  {0,0,30,1,14,16,15,0},
-        /* t */  {2,2,7,2,2,2,4,0},
-        /* u */  {0,0,17,17,17,17,30,0},
-        /* v */  {0,0,17,17,17,10,4,0},
-        /* w */  {0,0,17,17,21,21,30,0},
-        /* x */  {0,0,17,10,4,10,17,0},
-        /* y */  {0,0,17,17,17,30,16,15},
-        /* z */  {0,0,31,8,4,2,31,0},
-        /* { */  {12,2,2,1,2,2,12,0},
-        /* | */  {1,1,1,0,1,1,1,0},
-        /* } */  {3,4,4,8,4,4,3,0},
-        /* ~ */  {38,25,0,0,0,0,0,0},
-        /* ⌂ */  {0,0,4,10,17,17,31,0},
-        /* Ç */  {14,17,1,1,17,14,16,12},
-        /* ü */  {10,0,17,17,17,17,30,0},
-        /* é */  {24,0,14,17,31,1,30,0},
-        /* â */  {14,17,14,16,30,17,30,0},
-        /* ä */  {10,0,14,16,30,17,30,0},
-        /* à */  {3,0,14,16,30,17,30,0},
-        /* å */  {4,0,14,16,30,17,30,0},
-        /* ç */  {0,14,17,1,17,14,16,12},
-        /* ê */  {14,17,14,17,31,1,30,0},
-        /* ë */  {10,0,14,17,31,1,30,0},
-        /* è */  {3,0,14,17,31,1,30,0},
-        /* ï */  {5,0,2,2,2,2,2,0},
-        /* î */  {14,17,4,4,4,4,4,0},
-        /* ì */  {3,0,2,2,2,2,2,0},
-        /* Ä */  {17,14,17,31,17,17,17,0},
-        /* Å */  {4,0,14,17,31,17,17,0},
-        /* É */  {24,0,31,1,7,1,31,0},
-        /* æ */  {0,0,10,20,30,5,30,0},
-        /* Æ */  {30,5,15,5,5,5,29,0},
-        /* ô */  {14,17,14,17,17,17,14,0},
-        /* ö */  {10,0,14,17,17,17,14,0},
-        /* ò */  {3,0,14,17,17,17,14,0},
-        /* û */  {14,17,0,17,17,17,30,0},
-        /* ù */  {3,0,17,17,17,17,30,0},
-        /* ÿ */  {10,0,17,17,17,30,16,15},
-        /* Ö */  {17,14,17,17,17,17,14,0},
-        /* Ü */  {17,0,17,17,17,17,14,0},
-        /* ø */  {0,0,14,25,21,19,14,4},
-        /* £ */  {12,18,2,15,2,2,31,0},
-        /* Ø */  {14,17,25,21,19,17,14,0},
-        /* × */  {0,0,5,2,5,0,0,0},
-        /* ƒ */  {8,20,4,14,4,4,5,2},
-        /* á */  {24,0,14,16,30,17,30,0},
-        /* í */  {3,0,1,1,1,1,1,0},
-        /* ó */  {24,0,14,17,17,17,14,0},
-        /* ú */  {24,0,17,17,17,17,30,0},
-        /* ñ */  {31,0,15,17,17,17,17,0},
-        /* Ñ */  {31,0,17,19,21,25,17,0},
-        /* ª */  {14,16,31,30,0,31,0,0},
-        /* º */  {14,17,17,14,0,31,0,0},
-        /* ¿ */  {4,0,4,2,1,17,14,0},
-        /* ® */  {0,30,45,37,43,30,0,0},
-        /* ¬ */  {0,0,0,31,16,16,0,0},
-        /* ½ */  {17,9,8,4,18,10,25,0},
-        /* ¼ */  {17,9,8,4,26,26,17,0},
-        /* ¡ */  {0,1,0,1,1,1,1,0},
-        /* « */  {0,20,10,5,10,20,0,0},
-        /* » */  {0,5,10,20,10,5,0,0},
-        /* 176 */  {68,17,68,17,68,17,68,17},
-        /* 177 */  {170,85,170,85,170,85,170,85},
-        /* 178 */  {219,238,219,119,219,238,219,119},
-        /* 179 */  {24,24,24,24,24,24,24,24},
-        /* 180 */  {24,24,24,24,31,24,24,24},
-        /* 181 */  {24,24,31,24,31,24,24,24},
-        /* 182 */  {108,108,108,108,111,108,108,108},
-        /* 183 */  {0,0,0,0,127,108,108,108},
-        /* 184 */  {0,0,31,24,31,24,24,24},
-        /* 185 */  {108,108,111,96,111,108,108,108},
-        /* 186 */  {108,108,108,108,108,108,108,108},
-        /* 187 */  {0,0,127,96,111,108,108,108},
-        /* 188 */  {108,108,111,96,127,0,0,0},
-        /* 189 */  {108,108,108,108,127,0,0,0},
-        /* 190 */  {24,24,31,24,31,0,0,0},
-        /* 191 */  {0,0,0,0,31,24,24,24},
-        /* 192 */  {24,24,24,24,248,0,0,0},
-        /* 193 */  {24,24,24,24,255,0,0,0},
-        /* 194 */  {0,0,0,0,255,24,24,24},
-        /* 195 */  {24,24,24,24,248,24,24,24},
-        /* 196 */  {0,0,0,0,255,0,0,0},
-        /* 197 */  {24,24,24,24,255,24,24,24},
-        /* 198 */  {24,24,248,24,248,24,24,24},
-        /* 199 */  {108,108,108,108,236,108,108,108},
-        /* 200 */  {108,108,236,12,252,0,0,0},
-        /* 201 */  {0,0,252,12,236,108,108,108},
-        /* 202 */  {108,108,239,0,255,0,0,0},
-        /* 203 */  {0,0,255,0,239,108,108,108},
-        /* 204 */  {108,108,236,12,236,108,108,108},
-        /* 205 */  {0,0,255,0,255,0,0,0},
-        /* 206 */  {108,108,239,0,239,108,108,108},
-        /* 207 */  {24,24,255,0,255,0,0,0},
-        /* 208 */  {108,108,108,108,255,0,0,0},
-        /* 209 */  {0,0,255,0,255,24,24,24},
-        /* 210 */  {0,0,0,0,255,108,108,108},
-        /* 211 */  {108,108,108,108,252,0,0,0},
-        /* 212 */  {24,24,248,24,248,0,0,0},
-        /* 213 */  {0,0,248,24,248,24,24,24},
-        /* 214 */  {0,0,0,0,252,108,108,108},
-        /* 215 */  {108,108,108,108,255,108,108,108},
-        /* 216 */  {24,24,255,24,255,24,24,24},
-        /* 217 */  {24,24,24,24,31,0,0,0},
-        /* 218 */  {0,0,0,0,248,24,24,24},
-        /* 219 */  {255,255,255,255,255,255,255,255},
-        /* 220 */  {0,0,0,0,255,255,255,255},
-        /* 221 */  {15,15,15,15,15,15,15,15},
-        /* 222 */  {240,240,240,240,240,240,240,240},
-        /* 223 */  {255,255,255,255,0,0,0,0},
-        /* 224 */  {0,0,110,59,19,59,110,0},
-        /* 225 */  {0,30,51,31,51,31,3,3},
-        /* 226 */  {0,63,51,3,3,3,3,0},
-        /* 227 */  {0,127,54,54,54,54,54,0},
-        /* 228 */  {63,51,6,12,6,51,63,0},
-        /* 229 */  {0,0,126,27,27,27,14,0},
-        /* 230 */  {0,102,102,102,102,62,6,3},
-        /* 231 */  {0,110,59,24,24,24,24,0},
-        /* 232 */  {63,12,30,51,51,30,12,63},
-        /* 233 */  {28,54,99,127,99,54,28,0},
-        /* 234 */  {28,54,99,99,54,54,119,0},
-        /* 235 */  {56,12,24,62,51,51,30,0},
-        /* 236 */  {0,0,126,219,219,126,0,0},
-        /* 237 */  {96,48,126,219,219,126,6,3},
-        /* 238 */  {28,6,3,31,3,6,28,0},
-        /* 239 */  {30,51,51,51,51,51,51,0},
-        /* 240 */  {0,63,0,63,0,63,0,0},
-        /* 241 */  {12,12,63,12,12,0,63,0},
-        /* 242 */  {6,12,24,12,6,0,63,0},
-        /* 243 */  {24,12,6,12,24,0,63,0},
-        /* 244 */  {112,216,216,24,24,24,24,24},
-        /* 245 */  {24,24,24,24,24,27,27,14},
-        /* 246 */  {12,12,0,63,0,12,12,0},
-        /* 247 */  {0,110,59,0,110,59,0,0},
-        /* 248 */  {28,54,54,28,0,0,0,0},
-        /* 249 */  {0,0,0,24,24,0,0,0},
-        /* 250 */  {0,0,0,0,24,0,0,0},
-        /* 251 */  {240,48,48,48,55,54,60,56},
-        /* 252 */  {30,54,54,54,54,0,0,0},
-        /* 253 */  {14,24,12,6,30,0,0,0},
-        /* 254 */  {0,0,60,60,60,60,0,0},
-        /* 255 */  {0,0,0,0,0,0,0,0},
-    };
-
-    /**
-     * A static non-malleable MinecraftFont.
-     */
-    public static final MinecraftFont Font = new MinecraftFont(false);
-
-    /**
-     * Initialize a new MinecraftFont.
-     */
-    public MinecraftFont() {
-        this(true);
-    }
-
-    private MinecraftFont(boolean malleable) {
-        for (int i = 1; i < fontData.length; ++i) {
-            char ch = (char) i;
-            if (i >= 32 && i < 32 + fontChars.length()) {
-                ch = fontChars.charAt(i - 32);
-            }
-
-            if (ch == ' ') {
-                setChar(ch, new CharacterSprite(spaceSize, 8, new boolean[spaceSize * 8]));
-                continue;
-            }
-
-            int[] rows = fontData[i];
-            int width = 0;
-            for (int r = 0; r < 8; ++r) {
-                for (int c = 0; c < 8; ++c) {
-                    if ((rows[r] & (1 << c)) != 0 && c > width) {
-                        width = c;
-                    }
-                }
-            }
-            ++width;
-
-            boolean[] data = new boolean[width * 8];
-            for (int r = 0; r < 8; ++r) {
-                for (int c = 0; c < width; ++c) {
-                    data[r * width + c] = (rows[r] & (1 << c)) != 0;
-                }
-            }
-
-            setChar(ch, new CharacterSprite(width, 8, data));
-        }
-
-        this.malleable = malleable;
-    }
-
-}
diff --git a/src/main/java/org/bukkit/material/Attachable.java b/src/main/java/org/bukkit/material/Attachable.java
deleted file mode 100644
index 1d3f107..0000000
--- a/src/main/java/org/bukkit/material/Attachable.java
+++ /dev/null
@@ -1,16 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.block.BlockFace;
-
-/**
- * Indicates that a block can be attached to another block
- */
-public interface Attachable extends Directional {
-
-    /**
-     * Gets the face that this block is attached on
-     *
-     * @return BlockFace attached to
-     */
-    public BlockFace getAttachedFace();
-}
diff --git a/src/main/java/org/bukkit/material/Banner.java b/src/main/java/org/bukkit/material/Banner.java
deleted file mode 100644
index 80a7616..0000000
--- a/src/main/java/org/bukkit/material/Banner.java
+++ /dev/null
@@ -1,235 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.Material;
-import org.bukkit.block.BlockFace;
-
-public class Banner extends MaterialData implements Attachable {
-
-    public Banner() {
-        super(Material.BANNER);
-    }
-
-    public Banner(Material type) {
-        super(type);
-    }
-
-    /**
-     * @param type the raw type id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Banner(int type) {
-        super(type);
-    }
-
-    /**
-     *
-     * @param type the type
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Banner(Material type, byte data) {
-        super(type, data);
-    }
-
-    /**     *
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Banner(int type, byte data) {
-        super(type, data);
-    }
-
-    public boolean isWallBanner() {
-        return getItemType() == Material.WALL_BANNER;
-    }
-
-    public BlockFace getAttachedFace() {
-        if (isWallBanner()) {
-            byte data = getData();
-
-            switch (data) {
-                case 0x2:
-                    return BlockFace.SOUTH;
-
-                case 0x3:
-                    return BlockFace.NORTH;
-
-                case 0x4:
-                    return BlockFace.EAST;
-
-                case 0x5:
-                    return BlockFace.WEST;
-            }
-
-            return null;
-        } else {
-            return BlockFace.DOWN;
-        }
-    }
-
-    public BlockFace getFacing() {
-        byte data = getData();
-
-        if (!isWallBanner()) {
-            switch (data) {
-                case 0x0:
-                    return BlockFace.SOUTH;
-
-                case 0x1:
-                    return BlockFace.SOUTH_SOUTH_WEST;
-
-                case 0x2:
-                    return BlockFace.SOUTH_WEST;
-
-                case 0x3:
-                    return BlockFace.WEST_SOUTH_WEST;
-
-                case 0x4:
-                    return BlockFace.WEST;
-
-                case 0x5:
-                    return BlockFace.WEST_NORTH_WEST;
-
-                case 0x6:
-                    return BlockFace.NORTH_WEST;
-
-                case 0x7:
-                    return BlockFace.NORTH_NORTH_WEST;
-
-                case 0x8:
-                    return BlockFace.NORTH;
-
-                case 0x9:
-                    return BlockFace.NORTH_NORTH_EAST;
-
-                case 0xA:
-                    return BlockFace.NORTH_EAST;
-
-                case 0xB:
-                    return BlockFace.EAST_NORTH_EAST;
-
-                case 0xC:
-                    return BlockFace.EAST;
-
-                case 0xD:
-                    return BlockFace.EAST_SOUTH_EAST;
-
-                case 0xE:
-                    return BlockFace.SOUTH_EAST;
-
-                case 0xF:
-                    return BlockFace.SOUTH_SOUTH_EAST;
-            }
-
-            return null;
-        } else {
-            return getAttachedFace().getOppositeFace();
-        }
-    }
-
-    public void setFacingDirection(BlockFace face) {
-        byte data;
-
-        if (isWallBanner()) {
-            switch (face) {
-                case NORTH:
-                    data = 0x2;
-                    break;
-
-                case SOUTH:
-                    data = 0x3;
-                    break;
-
-                case WEST:
-                    data = 0x4;
-                    break;
-
-                case EAST:
-                default:
-                    data = 0x5;
-            }
-        } else {
-            switch (face) {
-                case SOUTH:
-                    data = 0x0;
-                    break;
-
-                case SOUTH_SOUTH_WEST:
-                    data = 0x1;
-                    break;
-
-                case SOUTH_WEST:
-                    data = 0x2;
-                    break;
-
-                case WEST_SOUTH_WEST:
-                    data = 0x3;
-                    break;
-
-                case WEST:
-                    data = 0x4;
-                    break;
-
-                case WEST_NORTH_WEST:
-                    data = 0x5;
-                    break;
-
-                case NORTH_WEST:
-                    data = 0x6;
-                    break;
-
-                case NORTH_NORTH_WEST:
-                    data = 0x7;
-                    break;
-
-                case NORTH:
-                    data = 0x8;
-                    break;
-
-                case NORTH_NORTH_EAST:
-                    data = 0x9;
-                    break;
-
-                case NORTH_EAST:
-                    data = 0xA;
-                    break;
-
-                case EAST_NORTH_EAST:
-                    data = 0xB;
-                    break;
-
-                case EAST:
-                    data = 0xC;
-                    break;
-
-                case EAST_SOUTH_EAST:
-                    data = 0xD;
-                    break;
-
-                case SOUTH_SOUTH_EAST:
-                    data = 0xF;
-                    break;
-
-                case SOUTH_EAST:
-                default:
-                    data = 0xE;
-            }
-        }
-
-        setData(data);
-    }
-
-    @Override
-    public String toString() {
-        return super.toString() + " facing " + getFacing();
-    }
-
-    @Override
-    public Banner clone() {
-        return (Banner) super.clone();
-    }
-}
diff --git a/src/main/java/org/bukkit/material/Bed.java b/src/main/java/org/bukkit/material/Bed.java
deleted file mode 100644
index ce94daf..0000000
--- a/src/main/java/org/bukkit/material/Bed.java
+++ /dev/null
@@ -1,145 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.Material;
-import org.bukkit.block.BlockFace;
-
-/**
- * Represents a bed.
- */
-public class Bed extends MaterialData implements Directional {
-
-    /**
-     * Default constructor for a bed.
-     */
-    public Bed() {
-        super(Material.BED_BLOCK);
-    }
-
-    /**
-     * Instantiate a bed facing in a particular direction.
-     *
-     * @param direction the direction the bed's head is facing
-     */
-    public Bed(BlockFace direction) {
-        this();
-        setFacingDirection(direction);
-    }
-
-    /**
-     *
-     * @param type the raw type id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Bed(final int type) {
-        super(type);
-    }
-
-    public Bed(final Material type) {
-        super(type);
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Bed(final int type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * @param type the type
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Bed(final Material type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * Determine if this block represents the head of the bed
-     *
-     * @return true if this is the head of the bed, false if it is the foot
-     */
-    public boolean isHeadOfBed() {
-        return (getData() & 0x8) == 0x8;
-    }
-
-    /**
-     * Configure this to be either the head or the foot of the bed
-     *
-     * @param isHeadOfBed True to make it the head.
-     */
-    public void setHeadOfBed(boolean isHeadOfBed) {
-        setData((byte) (isHeadOfBed ? (getData() | 0x8) : (getData() & ~0x8)));
-    }
-
-    /**
-     * Set which direction the head of the bed is facing. Note that this will
-     * only affect one of the two blocks the bed is made of.
-     */
-    public void setFacingDirection(BlockFace face) {
-        byte data;
-
-        switch (face) {
-        case SOUTH:
-            data = 0x0;
-            break;
-
-        case WEST:
-            data = 0x1;
-            break;
-
-        case NORTH:
-            data = 0x2;
-            break;
-
-        case EAST:
-        default:
-            data = 0x3;
-        }
-
-        if (isHeadOfBed()) {
-            data |= 0x8;
-        }
-
-        setData(data);
-    }
-
-    /**
-     * Get the direction that this bed's head is facing toward
-     *
-     * @return the direction the head of the bed is facing
-     */
-    public BlockFace getFacing() {
-        byte data = (byte) (getData() & 0x7);
-
-        switch (data) {
-        case 0x0:
-            return BlockFace.SOUTH;
-
-        case 0x1:
-            return BlockFace.WEST;
-
-        case 0x2:
-            return BlockFace.NORTH;
-
-        case 0x3:
-        default:
-            return BlockFace.EAST;
-        }
-    }
-
-    @Override
-    public String toString() {
-        return (isHeadOfBed() ? "HEAD" : "FOOT") + " of " + super.toString() + " facing " + getFacing();
-    }
-
-    @Override
-    public Bed clone() {
-        return (Bed) super.clone();
-    }
-}
diff --git a/src/main/java/org/bukkit/material/Button.java b/src/main/java/org/bukkit/material/Button.java
deleted file mode 100644
index fd6a7db..0000000
--- a/src/main/java/org/bukkit/material/Button.java
+++ /dev/null
@@ -1,142 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.block.BlockFace;
-import org.bukkit.Material;
-
-/**
- * Represents a button
- */
-public class Button extends SimpleAttachableMaterialData implements Redstone {
-    public Button() {
-        super(Material.STONE_BUTTON);
-    }
-
-    /**
-     * @param type the type
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Button(final int type) {
-        super(type);
-    }
-
-    public Button(final Material type) {
-        super(type);
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Button(final int type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * @param type the type
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Button(final Material type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * Gets the current state of this Material, indicating if it's powered or
-     * unpowered
-     *
-     * @return true if powered, otherwise false
-     */
-    public boolean isPowered() {
-        return (getData() & 0x8) == 0x8;
-    }
-
-    /**
-     * Sets the current state of this button
-     *
-     * @param bool
-     *            whether or not the button is powered
-     */
-    public void setPowered(boolean bool) {
-        setData((byte) (bool ? (getData() | 0x8) : (getData() & ~0x8)));
-    }
-
-    /**
-     * Gets the face that this block is attached on
-     *
-     * @return BlockFace attached to
-     */
-    public BlockFace getAttachedFace() {
-        byte data = (byte) (getData() & 0x7);
-
-        switch (data) {
-        case 0x0:
-            return BlockFace.UP;
-
-        case 0x1:
-            return BlockFace.WEST;
-
-        case 0x2:
-            return BlockFace.EAST;
-
-        case 0x3:
-            return BlockFace.NORTH;
-
-        case 0x4:
-            return BlockFace.SOUTH;
-
-        case 0x5:
-            return BlockFace.DOWN;
-        }
-
-        return null;
-    }
-
-    /**
-     * Sets the direction this button is pointing toward
-     */
-    public void setFacingDirection(BlockFace face) {
-        byte data = (byte) (getData() & 0x8);
-
-        switch (face) {
-        case DOWN:
-            data |= 0x0;
-            break;
-
-        case EAST:
-            data |= 0x1;
-            break;
-
-        case WEST:
-            data |= 0x2;
-            break;
-
-        case SOUTH:
-            data |= 0x3;
-            break;
-
-        case NORTH:
-            data |= 0x4;
-            break;
-
-        case UP:
-            data |= 0x5;
-            break;
-        }
-
-        setData(data);
-    }
-
-    @Override
-    public String toString() {
-        return super.toString() + " " + (isPowered() ? "" : "NOT ") + "POWERED";
-    }
-
-    @Override
-    public Button clone() {
-        return (Button) super.clone();
-    }
-}
diff --git a/src/main/java/org/bukkit/material/Cake.java b/src/main/java/org/bukkit/material/Cake.java
deleted file mode 100644
index e72cb91..0000000
--- a/src/main/java/org/bukkit/material/Cake.java
+++ /dev/null
@@ -1,93 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.Material;
-
-public class Cake extends MaterialData {
-    public Cake() {
-        super(Material.CAKE_BLOCK);
-    }
-
-    /**
-     * @param type the raw type id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Cake(int type) {
-        super(type);
-    }
-
-    public Cake(Material type) {
-        super(type);
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Cake(int type, byte data) {
-        super(type, data);
-    }
-
-    /**
-     * @param type the type
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Cake(Material type, byte data) {
-        super(type, data);
-    }
-
-    /**
-     * Gets the number of slices eaten from this cake
-     *
-     * @return The number of slices eaten
-     */
-    public int getSlicesEaten() {
-        return getData();
-    }
-
-    /**
-     * Gets the number of slices remaining on this cake
-     *
-     * @return The number of slices remaining
-     */
-    public int getSlicesRemaining() {
-        return 6 - getData();
-    }
-
-    /**
-     * Sets the number of slices eaten from this cake
-     *
-     * @param n The number of slices eaten
-     */
-    public void setSlicesEaten(int n) {
-        if (n < 6) {
-            setData((byte) n);
-        } // TODO: else destroy the block? Probably not possible though
-    }
-
-    /**
-     * Sets the number of slices remaining on this cake
-     *
-     * @param n The number of slices remaining
-     */
-    public void setSlicesRemaining(int n) {
-        if (n > 6) {
-            n = 6;
-        }
-        setData((byte) (6 - n));
-    }
-
-    @Override
-    public String toString() {
-        return super.toString() + " " + getSlicesEaten() + "/" + getSlicesRemaining() + " slices eaten/remaining";
-    }
-
-    @Override
-    public Cake clone() {
-        return (Cake) super.clone();
-    }
-}
diff --git a/src/main/java/org/bukkit/material/Cauldron.java b/src/main/java/org/bukkit/material/Cauldron.java
deleted file mode 100644
index 0ead402..0000000
--- a/src/main/java/org/bukkit/material/Cauldron.java
+++ /dev/null
@@ -1,64 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.Material;
-
-/**
- * Represents a cauldron
- */
-public class Cauldron extends MaterialData {
-    private static final int CAULDRON_FULL = 3;
-    private static final int CAULDRON_EMPTY = 0;
-
-    public Cauldron() {
-        super(Material.CAULDRON);
-    }
-
-    /**
-     *
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Cauldron(int type, byte data){
-        super(type, data);
-    }
-
-    /**
-     *
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Cauldron(byte data) {
-        super(Material.CAULDRON, data);
-    }
-
-    /**
-     * Check if the cauldron is full.
-     *
-     * @return True if it is full.
-     */
-    public boolean isFull() {
-        return getData() >= CAULDRON_FULL;
-    }
-
-    /**
-     * Check if the cauldron is empty.
-     *
-     * @return True if it is empty.
-     */
-    public boolean isEmpty() {
-        return getData() <= CAULDRON_EMPTY;
-    }
-
-    @Override
-    public String toString() {
-        return (isEmpty() ? "EMPTY" : (isFull() ? "FULL" : getData() + "/3 FULL")) + " CAULDRON";
-    }
-
-    @Override
-    public Cauldron clone() {
-        return (Cauldron) super.clone();
-    }
-}
diff --git a/src/main/java/org/bukkit/material/Chest.java b/src/main/java/org/bukkit/material/Chest.java
deleted file mode 100644
index 0db8aa5..0000000
--- a/src/main/java/org/bukkit/material/Chest.java
+++ /dev/null
@@ -1,62 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.Material;
-import org.bukkit.block.BlockFace;
-
-/**
- * Represents a chest
- */
-public class Chest extends DirectionalContainer {
-
-    public Chest() {
-        super(Material.CHEST);
-    }
-
-    /**
-     * Instantiate a chest facing in a particular direction.
-     *
-     * @param direction the direction the chest's lit opens towards
-     */
-    public Chest(BlockFace direction) {
-        this();
-        setFacingDirection(direction);
-    }
-
-    /**
-     * @param type the raw type id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Chest(final int type) {
-        super(type);
-    }
-
-    public Chest(final Material type) {
-        super(type);
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Chest(final int type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * @param type the type
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Chest(final Material type, final byte data) {
-        super(type, data);
-    }
-
-    @Override
-    public Chest clone() {
-        return (Chest) super.clone();
-    }
-}
diff --git a/src/main/java/org/bukkit/material/Coal.java b/src/main/java/org/bukkit/material/Coal.java
deleted file mode 100644
index dd940b6..0000000
--- a/src/main/java/org/bukkit/material/Coal.java
+++ /dev/null
@@ -1,79 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.CoalType;
-import org.bukkit.Material;
-
-/**
- * Represents the different types of coals.
- */
-public class Coal extends MaterialData {
-    public Coal() {
-        super(Material.COAL);
-    }
-
-    public Coal(CoalType type) {
-        this();
-        setType(type);
-    }
-
-    /**
-     * @param type the raw type id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Coal(final int type) {
-        super(type);
-    }
-
-    public Coal(final Material type) {
-        super(type);
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Coal(final int type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * @param type the type
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Coal(final Material type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * Gets the current type of this coal
-     *
-     * @return CoalType of this coal
-     */
-    public CoalType getType() {
-        return CoalType.getByData(getData());
-    }
-
-    /**
-     * Sets the type of this coal
-     *
-     * @param type New type of this coal
-     */
-    public void setType(CoalType type) {
-        setData(type.getData());
-    }
-
-    @Override
-    public String toString() {
-        return getType() + " " + super.toString();
-    }
-
-    @Override
-    public Coal clone() {
-        return (Coal) super.clone();
-    }
-}
diff --git a/src/main/java/org/bukkit/material/CocoaPlant.java b/src/main/java/org/bukkit/material/CocoaPlant.java
deleted file mode 100644
index 6dede93..0000000
--- a/src/main/java/org/bukkit/material/CocoaPlant.java
+++ /dev/null
@@ -1,133 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.Material;
-import org.bukkit.block.BlockFace;
-
-/**
- * Represents the cocoa plant
- */
-public class CocoaPlant extends MaterialData implements Directional, Attachable {
-
-    public enum CocoaPlantSize {
-        SMALL,
-        MEDIUM,
-        LARGE
-    }
-
-    public CocoaPlant() {
-        super(Material.COCOA);
-    }
-
-    /**
-     * @param type the raw type id     
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public CocoaPlant(final int type) {
-        super(type);
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public CocoaPlant(final int type, final byte data) {
-        super(type, data);
-    }
-
-    public CocoaPlant(CocoaPlantSize sz) {
-        this();
-        setSize(sz);
-    }
-
-    public CocoaPlant(CocoaPlantSize sz, BlockFace dir) {
-        this();
-        setSize(sz);
-        setFacingDirection(dir);
-    }
-
-    /**
-     * Get size of plant
-     *
-     * @return size
-     */
-    public CocoaPlantSize getSize() {
-        switch (getData() & 0xC) {
-            case 0:
-                return CocoaPlantSize.SMALL;
-            case 4:
-                return CocoaPlantSize.MEDIUM;
-            default:
-                return CocoaPlantSize.LARGE;
-        }
-    }
-
-    /**
-     * Set size of plant
-     *
-     * @param sz - size of plant
-     */
-    public void setSize(CocoaPlantSize sz) {
-        int dat = getData() & 0x3;
-        switch (sz) {
-            case SMALL:
-                break;
-            case MEDIUM:
-                dat |= 0x4;
-                break;
-            case LARGE:
-                dat |= 0x8;
-                break;
-        }
-        setData((byte) dat);
-    }
-
-    public BlockFace getAttachedFace() {
-        return getFacing().getOppositeFace();
-    }
-
-    public void setFacingDirection(BlockFace face) {
-        int dat = getData() & 0xC;
-        switch (face) {
-            default:
-            case SOUTH:
-                break;
-            case WEST:
-                dat |= 0x1;
-                break;
-            case NORTH:
-                dat |= 0x2;
-                break;
-            case EAST:
-                dat |= 0x3;
-                break;
-        }
-        setData((byte) dat);
-    }
-
-    public BlockFace getFacing() {
-        switch (getData() & 0x3) {
-            case 0:
-                return BlockFace.SOUTH;
-            case 1:
-                return BlockFace.WEST;
-            case 2:
-                return BlockFace.NORTH;
-            case 3:
-                return BlockFace.EAST;
-        }
-        return null;
-    }
-
-    @Override
-    public CocoaPlant clone() {
-        return (CocoaPlant) super.clone();
-    }
-
-    @Override
-    public String toString() {
-        return super.toString() + " facing " + getFacing() + " " + getSize();
-    }
-}
diff --git a/src/main/java/org/bukkit/material/Colorable.java b/src/main/java/org/bukkit/material/Colorable.java
deleted file mode 100644
index 3b91b24..0000000
--- a/src/main/java/org/bukkit/material/Colorable.java
+++ /dev/null
@@ -1,24 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.DyeColor;
-
-/**
- * An object that can be colored.
- */
-public interface Colorable {
-
-    /**
-     * Gets the color of this object.
-     *
-     * @return The DyeColor of this object.
-     */
-    public DyeColor getColor();
-
-    /**
-     * Sets the color of this object to the specified DyeColor.
-     *
-     * @param color The color of the object, as a DyeColor.
-     */
-    public void setColor(DyeColor color);
-
-}
diff --git a/src/main/java/org/bukkit/material/Command.java b/src/main/java/org/bukkit/material/Command.java
deleted file mode 100644
index b484229..0000000
--- a/src/main/java/org/bukkit/material/Command.java
+++ /dev/null
@@ -1,75 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.Material;
-
-/**
- * Represents a command block
- */
-public class Command extends MaterialData implements Redstone {
-    public Command() {
-        super(Material.COMMAND);
-    }
-
-    /**
-     * @param type the raw type id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Command(final int type) {
-        super(type);
-    }
-
-    public Command(final Material type) {
-        super(type);
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Command(final int type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * @param type the type
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Command(final Material type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * Gets the current state of this Material, indicating if it's powered or
-     * unpowered
-     *
-     * @return true if powered, otherwise false
-     */
-    public boolean isPowered() {
-        return (getData() & 1) != 0;
-    }
-
-    /**
-     * Sets the current state of this Material
-     *
-     * @param bool
-     *            whether or not the command block is powered
-     */
-    public void setPowered(boolean bool) {
-        setData((byte) (bool ? (getData() | 1) : (getData() & -2)));
-    }
-
-    @Override
-    public String toString() {
-        return super.toString() + " " + (isPowered() ? "" : "NOT ") + "POWERED";
-    }
-
-    @Override
-    public Command clone() {
-        return (Command) super.clone();
-    }
-}
diff --git a/src/main/java/org/bukkit/material/Comparator.java b/src/main/java/org/bukkit/material/Comparator.java
deleted file mode 100644
index b5602ee..0000000
--- a/src/main/java/org/bukkit/material/Comparator.java
+++ /dev/null
@@ -1,200 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.Material;
-import org.bukkit.block.BlockFace;
-
-/**
- * Represents a comparator in the on or off state, in normal or subtraction mode and facing in a specific direction.
- *
- * @see Material#REDSTONE_COMPARATOR_OFF
- * @see Material#REDSTONE_COMPARATOR_ON
- */
-public class Comparator extends MaterialData implements Directional, Redstone {
-    protected static final BlockFace DEFAULT_DIRECTION = BlockFace.NORTH;
-    protected static final boolean DEFAULT_SUBTRACTION_MODE = false;
-    protected static final boolean DEFAULT_STATE = false;
-
-    /**
-     * Constructs a comparator switched off, with the default mode (normal) and facing the default direction (north).
-     */
-    public Comparator() {
-        this(DEFAULT_DIRECTION, DEFAULT_SUBTRACTION_MODE, false);
-    }
-
-    /**
-     * Constructs a comparator switched off, with the default mode (normal) and facing the specified direction.
-     *
-     * @param facingDirection the direction the comparator is facing
-     *
-     * @see BlockFace
-     */
-    public Comparator(BlockFace facingDirection) {
-        this(facingDirection, DEFAULT_SUBTRACTION_MODE, DEFAULT_STATE);
-    }
-
-    /**
-     * Constructs a comparator switched off, with the specified mode and facing the specified direction.
-     *
-     * @param facingDirection the direction the comparator is facing
-     * @param isSubtraction True if the comparator is in subtraction mode, false for normal comparator operation
-     *
-     * @see BlockFace
-     */
-    public Comparator(BlockFace facingDirection, boolean isSubtraction) {
-    	this(facingDirection, isSubtraction, DEFAULT_STATE);
-    }
-
-    /**
-     * Constructs a comparator switched on or off, with the specified mode and facing the specified direction.
-     *
-     * @param facingDirection the direction the comparator is facing
-     * @param isSubtraction True if the comparator is in subtraction mode, false for normal comparator operation
-     * @param state True if the comparator is in the on state
-     *
-     * @see BlockFace
-     */
-    public Comparator(BlockFace facingDirection, boolean isSubtraction, boolean state) {
-        super(state ? Material.REDSTONE_COMPARATOR_ON : Material.REDSTONE_COMPARATOR_OFF);
-        setFacingDirection(facingDirection);
-        setSubtractionMode(isSubtraction);
-    }
-
-    /**
-     * @param type the raw type id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Comparator(int type) {
-        super(type);
-    }
-
-    public Comparator(Material type) {
-        super(type);
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Comparator(int type, byte data) {
-        super(type, data);
-    }
-
-    /**
-     * @param type the type
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Comparator(Material type, byte data) {
-        super(type, data);
-    }
-
-    /**
-     * Sets whether the comparator is in subtraction mode.
-     *
-     * @param isSubtraction True if the comparator is in subtraction mode, false for normal comparator operation
-     */
-    public void setSubtractionMode(boolean isSubtraction) {
-        setData((byte)(getData() & 0xB | (isSubtraction ? 0x4 : 0x0)));
-    }
-
-    /**
-     * Checks whether the comparator is in subtraction mode
-     *
-     * @return True if the comparator is in subtraction mode, false if normal comparator operation
-     */
-    public boolean isSubtractionMode() {
-        return (getData() & 0x4) != 0;
-    }
-
-    /**
-     * Sets the direction this comparator is facing
-     *
-     * @param face The direction to set this comparator to
-     *
-     * @see BlockFace
-     */
-    @Override
-    public void setFacingDirection(BlockFace face) {
-        int data = getData() & 0xC;
-
-        switch (face) {
-        case EAST:
-            data |= 0x1;
-            break;
-
-        case SOUTH:
-            data |= 0x2;
-            break;
-
-        case WEST:
-            data |= 0x3;
-            break;
-
-        case NORTH:
-        default:
-            data |= 0x0;
-        }
-
-        setData((byte)data);
-    }
-
-    /**
-     * Gets the direction this comparator is facing
-     *
-     * @return The direction this comparator is facing
-     *
-     * @see BlockFace
-     */
-    @Override
-    public BlockFace getFacing() {
-        byte data = (byte) (getData() & 0x3);
-
-        switch (data) {
-        case 0x0:
-        default:
-            return BlockFace.NORTH;
-
-        case 0x1:
-            return BlockFace.EAST;
-
-        case 0x2:
-            return BlockFace.SOUTH;
-
-        case 0x3:
-            return BlockFace.WEST;
-        }
-    }
-
-    @Override
-    public String toString() {
-        return super.toString() + " facing " + getFacing() + " in " + (isSubtractionMode() ? "subtraction" : "comparator") + " mode";
-    }
-
-    @Override
-    public Comparator clone() {
-        return (Comparator) super.clone();
-    }
-
-    /**
-     * Checks if the comparator is powered
-     *
-     * @return true if the comparator is powered
-     */
-    @Override
-    public boolean isPowered() {
-        return getItemType() == Material.REDSTONE_COMPARATOR_ON;
-    }
-
-    /**
-     * Checks if the comparator is being powered
-     *
-     * @return true if the comparator is being powered
-     */
-    public boolean isBeingPowered() {
-        return (getData() & 0x8) != 0;
-    }
-}
diff --git a/src/main/java/org/bukkit/material/Crops.java b/src/main/java/org/bukkit/material/Crops.java
deleted file mode 100644
index f48637d..0000000
--- a/src/main/java/org/bukkit/material/Crops.java
+++ /dev/null
@@ -1,151 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.CropState;
-import org.bukkit.Material;
-
-/**
- * Represents the different types of crops in different states of growth.
- *
- * @see Material#CROPS
- * @see Material#CARROT
- * @see Material#POTATO
- * @see Material#BEETROOT_BLOCK
- * @see Material#NETHER_WARTS
- */
-public class Crops extends MaterialData {
-    protected static final Material DEFAULT_TYPE = Material.CROPS;
-    protected static final CropState DEFAULT_STATE = CropState.SEEDED;
-
-    /**
-     * Constructs a wheat crop block in the seeded state.
-     */
-    public Crops() {
-        this(DEFAULT_TYPE, DEFAULT_STATE);
-    }
-
-    /**
-     * Constructs a wheat crop block in the given growth state
-     *
-     * @param state The growth state of the crops
-     */
-    public Crops(CropState state) {
-        this(DEFAULT_TYPE, state);
-        setState(state);
-    }
-
-    /**
-     * Constructs a crop block of the given type and in the given growth state
-     *
-     * @param type The type of crops
-     * @param state The growth state of the crops
-     */
-    public Crops(final Material type, final CropState state) {
-        super(type);
-        setState(state);
-    }
-
-    /**
-     * @param type the raw type id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Crops(final int type) {
-        super(type);
-    }
-
-    /**
-     * Constructs a crop block of the given type and in the seeded state
-     *
-     * @param type The type of crops
-     */
-    public Crops(final Material type) {
-        this(type, DEFAULT_STATE);
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Crops(final int type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * @param type the type
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Crops(final Material type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * Gets the current growth state of this crop
-     *
-     * For crops with only four growth states such as beetroot, only the values SEEDED, SMALL, TALL and RIPE will be
-     * returned.
-     *
-     * @return CropState of this crop
-     */
-    public CropState getState() {
-        switch (getItemType()) {
-            case CROPS:
-            case CARROT:
-            case POTATO:
-                // Mask the data just in case top bit set
-                return CropState.getByData((byte)(getData() & 0x7));
-            case BEETROOT_BLOCK:
-            case NETHER_WARTS:
-                // Mask the data just in case top bits are set
-                // Will return SEEDED, SMALL, TALL, RIPE for the three growth data values
-                return CropState.getByData((byte)(((getData() & 0x3)*7+2)/3)) ;
-            default:
-                throw new IllegalArgumentException("Block type is not a crop");
-        }
-    }
-
-    /**
-     * Sets the growth state of this crop
-     *
-     * For crops with only four growth states such as beetroot, the 8 CropStates are mapped into four states:
-     *
-     * SEEDED, SMALL, TALL and RIPE
-     *
-     * GERMINATED will change to SEEDED
-     * VERY_SMALL will change to SMALL
-     * MEDIUM will change to TALL
-     * VERY_TALL will change to RIPE
-     *
-     * @param state New growth state of this crop
-     */
-    public void setState(CropState state) {
-        switch (getItemType()) {
-            case CROPS:
-            case CARROT:
-            case POTATO:
-                // Preserve the top bit in case it is set
-                setData((byte)((getData() & 0x8)|state.getData()));
-                break;
-            case NETHER_WARTS:
-            case BEETROOT_BLOCK:
-                // Preserve the top bits in case they are set
-                setData((byte)((getData() & 0xC)|(state.getData() >> 1)));
-                break;
-            default:
-                throw new IllegalArgumentException("Block type is not a crop");
-        }
-    }
-
-    @Override
-    public String toString() {
-        return getState() + " " + super.toString();
-    }
-
-    @Override
-    public Crops clone() {
-        return (Crops) super.clone();
-    }
-}
diff --git a/src/main/java/org/bukkit/material/DetectorRail.java b/src/main/java/org/bukkit/material/DetectorRail.java
deleted file mode 100644
index 652a4b5..0000000
--- a/src/main/java/org/bukkit/material/DetectorRail.java
+++ /dev/null
@@ -1,58 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.Material;
-
-/**
- * Represents a detector rail
- */
-public class DetectorRail extends ExtendedRails implements PressureSensor {
-    public DetectorRail() {
-        super(Material.DETECTOR_RAIL);
-    }
-
-    /**
-     * @param type the raw type id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public DetectorRail(final int type) {
-        super(type);
-    }
-
-    public DetectorRail(final Material type) {
-        super(type);
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public DetectorRail(final int type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * @param type the type
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public DetectorRail(final Material type, final byte data) {
-        super(type, data);
-    }
-
-    public boolean isPressed() {
-        return (getData() & 0x8) == 0x8;
-    }
-
-    public void setPressed(boolean isPressed) {
-        setData((byte) (isPressed ? (getData() | 0x8) : (getData() & ~0x8)));
-    }
-
-    @Override
-    public DetectorRail clone() {
-        return (DetectorRail) super.clone();
-    }
-}
diff --git a/src/main/java/org/bukkit/material/Diode.java b/src/main/java/org/bukkit/material/Diode.java
deleted file mode 100644
index 84014c4..0000000
--- a/src/main/java/org/bukkit/material/Diode.java
+++ /dev/null
@@ -1,209 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.Material;
-import org.bukkit.block.BlockFace;
-
-/**
- * Represents a diode/repeater in the on or off state, with a delay and facing
- * in a specific direction.
- *
- * @see Material#DIODE_BLOCK_OFF
- * @see Material#DIODE_BLOCK_ON
- */
-public class Diode extends MaterialData implements Directional, Redstone {
-
-    protected static final BlockFace DEFAULT_DIRECTION = BlockFace.NORTH;
-    protected static final int DEFAULT_DELAY = 1;
-    protected static final boolean DEFAULT_STATE = false;
-
-    /**
-     * Constructs a diode switched on, with a delay of 1 and facing the default
-     * direction (north).
-     *
-     * By default this constructor creates a diode that is switched on for
-     * backwards compatibility with past implementations.
-     */
-    public Diode() {
-        this(DEFAULT_DIRECTION, DEFAULT_DELAY, true);
-    }
-
-    /**
-     * Constructs a diode switched off, with a delay of 1 and facing the
-     * specified direction.
-     *
-     * @param facingDirection the direction the diode is facing
-     *
-     * @see BlockFace
-     */
-    public Diode(BlockFace facingDirection) {
-        this(facingDirection, DEFAULT_DELAY, DEFAULT_STATE);
-    }
-
-    /**
-     * Constructs a diode switched off, with the specified delay and facing the
-     * specified direction.
-     *
-     * @param facingDirection the direction the diode is facing
-     * @param delay The number of ticks (1-4) before the diode turns on after
-     * being powered
-     *
-     * @see BlockFace
-     */
-    public Diode(BlockFace facingDirection, int delay) {
-        this(facingDirection, delay, DEFAULT_STATE);
-    }
-
-    /**
-     * Constructs a diode switched on or off, with the specified delay and
-     * facing the specified direction.
-     *
-     * @param facingDirection the direction the diode is facing
-     * @param delay The number of ticks (1-4) before the diode turns on after
-     * being powered
-     * @param state True if the diode is in the on state
-     *
-     * @see BlockFace
-     */
-    public Diode(BlockFace facingDirection, int delay, boolean state) {
-        super(state ? Material.DIODE_BLOCK_ON : Material.DIODE_BLOCK_OFF);
-        setFacingDirection(facingDirection);
-        setDelay(delay);
-    }
-
-    /**
-     * @param type the raw type id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Diode(int type) {
-        super(type);
-    }
-
-    public Diode(Material type) {
-        super(type);
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Diode(int type, byte data) {
-        super(type, data);
-    }
-
-    /**
-     * @param type the type
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Diode(Material type, byte data) {
-        super(type, data);
-    }
-
-    /**
-     * Sets the delay of the repeater.
-     *
-     * @param delay The new delay (1-4)
-     */
-    public void setDelay(int delay) {
-        if (delay > 4) {
-            delay = 4;
-        }
-        if (delay < 1) {
-            delay = 1;
-        }
-        byte newData = (byte) (getData() & 0x3);
-
-        setData((byte) (newData | ((delay - 1) << 2)));
-    }
-
-    /**
-     * Gets the delay of the repeater in ticks.
-     *
-     * @return The delay (1-4)
-     */
-    public int getDelay() {
-        return (getData() >> 2) + 1;
-    }
-
-    /**
-     * Sets the direction this diode is facing.
-     *
-     * @param face The direction to set this diode to
-     *
-     * @see BlockFace
-     */
-    @Override
-    public void setFacingDirection(BlockFace face) {
-        int delay = getDelay();
-        byte data;
-
-        switch (face) {
-            case EAST:
-                data = 0x1;
-                break;
-            case SOUTH:
-                data = 0x2;
-                break;
-            case WEST:
-                data = 0x3;
-                break;
-            case NORTH:
-            default:
-                data = 0x0;
-        }
-
-        setData(data);
-        setDelay(delay);
-    }
-
-    /**
-     * Gets the direction this diode is facing
-     *
-     * @return The direction this diode is facing
-     *
-     * @see BlockFace
-     */
-    @Override
-    public BlockFace getFacing() {
-        byte data = (byte) (getData() & 0x3);
-
-        switch (data) {
-            case 0x0:
-            default:
-                return BlockFace.NORTH;
-
-            case 0x1:
-                return BlockFace.EAST;
-
-            case 0x2:
-                return BlockFace.SOUTH;
-
-            case 0x3:
-                return BlockFace.WEST;
-        }
-    }
-
-    @Override
-    public String toString() {
-        return super.toString() + " facing " + getFacing() + " with " + getDelay() + " ticks delay";
-    }
-
-    @Override
-    public Diode clone() {
-        return (Diode) super.clone();
-    }
-
-    /**
-     * Checks if the diode is powered.
-     *
-     * @return true if the diode is powered
-     */
-    @Override
-    public boolean isPowered() {
-        return getItemType() == Material.DIODE_BLOCK_ON;
-    }
-}
diff --git a/src/main/java/org/bukkit/material/Directional.java b/src/main/java/org/bukkit/material/Directional.java
deleted file mode 100644
index 25624d2..0000000
--- a/src/main/java/org/bukkit/material/Directional.java
+++ /dev/null
@@ -1,20 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.block.BlockFace;
-
-public interface Directional {
-
-    /**
-     * Sets the direction that this block is facing in
-     *
-     * @param face The facing direction
-     */
-    public void setFacingDirection(BlockFace face);
-
-    /**
-     * Gets the direction this block is facing
-     *
-     * @return the direction this block is facing
-     */
-    public BlockFace getFacing();
-}
diff --git a/src/main/java/org/bukkit/material/DirectionalContainer.java b/src/main/java/org/bukkit/material/DirectionalContainer.java
deleted file mode 100644
index b56f098..0000000
--- a/src/main/java/org/bukkit/material/DirectionalContainer.java
+++ /dev/null
@@ -1,95 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.Material;
-import org.bukkit.block.BlockFace;
-
-/**
- * Represents a furnace or a dispenser.
- */
-public class DirectionalContainer extends MaterialData implements Directional {
-    /**
-     * @param type the raw type id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public DirectionalContainer(final int type) {
-        super(type);
-    }
-
-    public DirectionalContainer(final Material type) {
-        super(type);
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public DirectionalContainer(final int type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * @param type the type
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public DirectionalContainer(final Material type, final byte data) {
-        super(type, data);
-    }
-
-    public void setFacingDirection(BlockFace face) {
-        byte data;
-
-        switch (face) {
-        case NORTH:
-            data = 0x2;
-            break;
-
-        case SOUTH:
-            data = 0x3;
-            break;
-
-        case WEST:
-            data = 0x4;
-            break;
-
-        case EAST:
-        default:
-            data = 0x5;
-        }
-
-        setData(data);
-    }
-
-    public BlockFace getFacing() {
-        byte data = getData();
-
-        switch (data) {
-        case 0x2:
-            return BlockFace.NORTH;
-
-        case 0x3:
-            return BlockFace.SOUTH;
-
-        case 0x4:
-            return BlockFace.WEST;
-
-        case 0x5:
-        default:
-            return BlockFace.EAST;
-        }
-    }
-
-    @Override
-    public String toString() {
-        return super.toString() + " facing " + getFacing();
-    }
-
-    @Override
-    public DirectionalContainer clone() {
-        return (DirectionalContainer) super.clone();
-    }
-}
diff --git a/src/main/java/org/bukkit/material/Dispenser.java b/src/main/java/org/bukkit/material/Dispenser.java
deleted file mode 100644
index 988407c..0000000
--- a/src/main/java/org/bukkit/material/Dispenser.java
+++ /dev/null
@@ -1,114 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.Material;
-import org.bukkit.block.BlockFace;
-
-/**
- * Represents a dispenser.
- */
-public class Dispenser extends FurnaceAndDispenser {
-
-    public Dispenser() {
-        super(Material.DISPENSER);
-    }
-
-    public Dispenser(BlockFace direction) {
-        this();
-        setFacingDirection(direction);
-    }
-
-    /**
-     * @param type the raw type id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Dispenser(final int type) {
-        super(type);
-    }
-
-    public Dispenser(final Material type) {
-        super(type);
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Dispenser(final int type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * @param type the type
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Dispenser(final Material type, final byte data) {
-        super(type, data);
-    }
-
-    public void setFacingDirection(BlockFace face) {
-        byte data;
-
-        switch (face) {
-            case DOWN:
-                data = 0x0;
-                break;
-
-            case UP:
-                data = 0x1;
-                break;
-
-            case NORTH:
-                data = 0x2;
-                break;
-
-            case SOUTH:
-                data = 0x3;
-                break;
-
-            case WEST:
-                data = 0x4;
-                break;
-
-            case EAST:
-            default:
-                data = 0x5;
-        }
-
-        setData(data);
-    }
-
-    public BlockFace getFacing() {
-        int data = getData() & 0x7;
-
-        switch (data) {
-            case 0x0:
-                return BlockFace.DOWN;
-
-            case 0x1:
-                return BlockFace.UP;
-
-            case 0x2:
-                return BlockFace.NORTH;
-
-            case 0x3:
-                return BlockFace.SOUTH;
-
-            case 0x4:
-                return BlockFace.WEST;
-
-            case 0x5:
-            default:
-                return BlockFace.EAST;
-        }
-    }
-
-    @Override
-    public Dispenser clone() {
-        return (Dispenser) super.clone();
-    }
-}
diff --git a/src/main/java/org/bukkit/material/Door.java b/src/main/java/org/bukkit/material/Door.java
deleted file mode 100644
index 07a40a0..0000000
--- a/src/main/java/org/bukkit/material/Door.java
+++ /dev/null
@@ -1,338 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.Material;
-import org.bukkit.TreeSpecies;
-import org.bukkit.block.BlockFace;
-
-/**
- * Represents a door.
- *
- * This class was previously deprecated, but has been retrofitted to
- * work with modern doors. Some methods are undefined dependant on <code>isTopHalf()</code>
- * due to Minecraft's internal representation of doors.
- *
- * @see Material#WOODEN_DOOR
- * @see Material#IRON_DOOR_BLOCK
- * @see Material#SPRUCE_DOOR
- * @see Material#BIRCH_DOOR
- * @see Material#JUNGLE_DOOR
- * @see Material#ACACIA_DOOR
- * @see Material#DARK_OAK_DOOR
- */
-public class Door extends MaterialData implements Directional, Openable {
-
-    // This class breaks API contracts on Directional and Openable because
-    // of the way doors are currently implemented. Beware!
-
-    /**
-     * @deprecated Artifact of old API, equivalent to new <code>Door(Material.WOODEN_DOOR);</code>
-     */
-    @Deprecated
-    public Door() {
-        super(Material.WOODEN_DOOR);
-    }
-
-    /**
-     * @param type the raw type id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Door(final int type) {
-        super(type);
-    }
-
-    public Door(final Material type) {
-        super(type);
-    }
-
-    /**
-     * Constructs the bottom half of a door of the given material type, facing the specified direction and set to closed
-     *
-     * @param type The type of material this door is made of. This must match the type of the block above.
-     * @param face The direction the door is facing.
-     *
-     * @see Material#WOODEN_DOOR
-     * @see Material#IRON_DOOR_BLOCK
-     * @see Material#SPRUCE_DOOR
-     * @see Material#BIRCH_DOOR
-     * @see Material#JUNGLE_DOOR
-     * @see Material#ACACIA_DOOR
-     * @see Material#DARK_OAK_DOOR
-     *
-     * @see BlockFace#WEST
-     * @see BlockFace#NORTH
-     * @see BlockFace#EAST
-     * @see BlockFace#SOUTH
-     */
-    public Door(final Material type, BlockFace face) {
-        this(type, face, false);
-    }
-
-    /**
-     * Constructs the bottom half of a door of the given material type, facing the specified direction and set to open
-     * or closed
-     *
-     * @param type The type of material this door is made of. This must match the type of the block above.
-     * @param face The direction the door is facing.
-     * @param isOpen Whether the door is currently opened.
-     *
-     * @see Material#WOODEN_DOOR
-     * @see Material#IRON_DOOR_BLOCK
-     * @see Material#SPRUCE_DOOR
-     * @see Material#BIRCH_DOOR
-     * @see Material#JUNGLE_DOOR
-     * @see Material#ACACIA_DOOR
-     * @see Material#DARK_OAK_DOOR
-     *
-     * @see BlockFace#WEST
-     * @see BlockFace#NORTH
-     * @see BlockFace#EAST
-     * @see BlockFace#SOUTH
-     */
-    public Door(final Material type, BlockFace face, boolean isOpen) {
-        super(type);
-        setTopHalf(false);
-        setFacingDirection(face);
-        setOpen(isOpen);
-    }
-
-    /**
-     * Constructs the top half of door of the given material type and with the hinge on the left or right
-     *
-     * @param type The type of material this door is made of. This must match the type of the block below.
-     * @param isHingeRight True if the hinge is on the right hand side, false if the hinge is on the left hand side.
-     *
-     * @see Material#WOODEN_DOOR
-     * @see Material#IRON_DOOR_BLOCK
-     * @see Material#SPRUCE_DOOR
-     * @see Material#BIRCH_DOOR
-     * @see Material#JUNGLE_DOOR
-     * @see Material#ACACIA_DOOR
-     * @see Material#DARK_OAK_DOOR
-     */
-    public Door(final Material type, boolean isHingeRight) {
-        super(type);
-        setTopHalf(true);
-        setHinge(isHingeRight);
-    }
-
-    /**
-     * Constructs the bottom half of a wooden door of the given species, facing the specified direction and set to
-     * closed
-     *
-     * @param species The species this wooden door is made of. This must match the species of the block above.
-     * @param face The direction the door is facing.
-     *
-     * @see TreeSpecies
-     *
-     * @see BlockFace#WEST
-     * @see BlockFace#NORTH
-     * @see BlockFace#EAST
-     * @see BlockFace#SOUTH
-     */
-    public Door(final TreeSpecies species, BlockFace face) {
-        this(getWoodDoorOfSpecies(species), face, false);
-    }
-
-    /**
-     * Constructs the bottom half of a wooden door of the given species, facing the specified direction and set to open
-     * or closed
-     *
-     * @param species The species this wooden door is made of. This must match the species of the block above.
-     * @param face The direction the door is facing.
-     * @param isOpen Whether the door is currently opened.
-     *
-     * @see TreeSpecies
-     *
-     * @see BlockFace#WEST
-     * @see BlockFace#NORTH
-     * @see BlockFace#EAST
-     * @see BlockFace#SOUTH
-     */
-    public Door(final TreeSpecies species, BlockFace face, boolean isOpen) {
-        this(getWoodDoorOfSpecies(species), face, isOpen);
-    }
-
-    /**
-     * Constructs the top half of a wooden door of the given species and with the hinge on the left or right
-     *
-     * @param species The species this wooden door is made of. This must match the species of the block below.
-     * @param isHingeRight True if the hinge is on the right hand side, false if the hinge is on the left hand side.
-     *
-     * @see TreeSpecies
-     */
-    public Door(final TreeSpecies species, boolean isHingeRight) {
-        this(getWoodDoorOfSpecies(species), isHingeRight);
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Door(final int type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * @param type the type
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Door(final Material type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * Returns the item type of a wooden door for the given tree species.
-     *
-     * @param species The species of wood door required.
-     * @return The item type for the given species.
-     *
-     * @see Material#WOODEN_DOOR
-     * @see Material#SPRUCE_DOOR
-     * @see Material#BIRCH_DOOR
-     * @see Material#JUNGLE_DOOR
-     * @see Material#ACACIA_DOOR
-     * @see Material#DARK_OAK_DOOR
-     */
-    public static Material getWoodDoorOfSpecies(TreeSpecies species) {
-        switch (species) {
-            default:
-            case GENERIC:
-                return Material.WOODEN_DOOR;
-            case BIRCH:
-                return Material.BIRCH_DOOR;
-            case REDWOOD:
-                return Material.SPRUCE_DOOR;
-            case JUNGLE:
-                return Material.JUNGLE_DOOR;
-            case ACACIA:
-                return Material.ACACIA_DOOR;
-            case DARK_OAK:
-                return Material.DARK_OAK_DOOR;
-        }
-    }
-
-    /**
-     * Result is undefined if <code>isTopHalf()</code> is true.
-     */
-    public boolean isOpen() {
-        return ((getData() & 0x4) == 0x4);
-    }
-
-    /**
-     * Set whether the door is open. Undefined if <code>isTopHalf()</code> is true.
-     */
-    public void setOpen(boolean isOpen) {
-        setData((byte) (isOpen ? (getData() | 0x4) : (getData() & ~0x4)));
-    }
-
-    /**
-     * @return whether this is the top half of the door
-     */
-    public boolean isTopHalf() {
-        return ((getData() & 0x8) == 0x8);
-    }
-
-    /**
-     * Configure this part of the door to be either the top or the bottom half
-     *
-     * @param isTopHalf True to make it the top half.
-     */
-    public void setTopHalf(boolean isTopHalf) {
-        setData((byte) (isTopHalf ? (getData() | 0x8) : (getData() & ~0x8)));
-    }
-
-    /**
-     * @return BlockFace.SELF
-     * @deprecated This method should not be used; use hinge and facing accessors instead.
-     */
-    @Deprecated
-    public BlockFace getHingeCorner() {
-        return BlockFace.SELF;
-    }
-
-    @Override
-    public String toString() {
-        return (isTopHalf() ? "TOP" : "BOTTOM") + " half of " + super.toString();
-    }
-
-    /**
-     * Set the direction that this door should is facing.
-     *
-     * Undefined if <code>isTopHalf()</code> is true.
-     *
-     * @param face the direction
-     */
-    public void setFacingDirection(BlockFace face) {
-        byte data = (byte) (getData() & 0xC);
-        switch (face) {
-            case WEST:
-                data |= 0x0;
-                break;
-            case NORTH:
-                data |= 0x1;
-                break;
-            case EAST:
-                data |= 0x2;
-                break;
-            case SOUTH:
-                data |= 0x3;
-                break;
-        }
-        setData(data);
-    }
-
-    /**
-     * Get the direction that this door is facing.
-     *
-     * Undefined if <code>isTopHalf()</code> is true.
-     *
-     * @return the direction
-     */
-    public BlockFace getFacing() {
-        byte data = (byte) (getData() & 0x3);
-        switch (data) {
-            case 0:
-                return BlockFace.WEST;
-            case 1:
-                return BlockFace.NORTH;
-            case 2:
-                return BlockFace.EAST;
-            case 3:
-                return BlockFace.SOUTH;
-            default:
-                throw new IllegalStateException("Unknown door facing (data: " + data + ")");
-        }
-    }
-
-    /**
-     * Returns the side of the door the hinge is on.
-     *
-     * Undefined if <code>isTopHalf()</code> is false.
-     *
-     * @return false for left hinge, true for right hinge
-     */
-    public boolean getHinge() {
-        return (getData() & 0x1) == 1;
-    }
-
-    /**
-     * Set whether the hinge is on the left or right side. Left is false, right is true.
-     *
-     * Undefined if <code>isTopHalf()</code> is false.
-     *
-     * @param isHingeRight True if the hinge is on the right hand side, false if the hinge is on the left hand side.
-     */
-    public void setHinge(boolean isHingeRight) {
-        setData((byte) (isHingeRight ? (getData() | 0x1) : (getData() & ~0x1)));
-    }
-
-    @Override
-    public Door clone() {
-        return (Door) super.clone();
-    }
-}
diff --git a/src/main/java/org/bukkit/material/Dye.java b/src/main/java/org/bukkit/material/Dye.java
deleted file mode 100644
index 7174fdb..0000000
--- a/src/main/java/org/bukkit/material/Dye.java
+++ /dev/null
@@ -1,81 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.DyeColor;
-import org.bukkit.Material;
-
-/**
- * Represents dye
- */
-public class Dye extends MaterialData implements Colorable {
-    public Dye() {
-        super(Material.INK_SACK);
-    }
-
-    /**
-     * @param type the raw type id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Dye(final int type) {
-        super(type);
-    }
-
-    public Dye(final Material type) {
-        super(type);
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Dye(final int type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * @param type the type
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Dye(final Material type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * @param color color of the dye
-     */
-    public Dye(final DyeColor color) {
-        super(Material.INK_SACK, color.getDyeData());
-    }
-
-    /**
-     * Gets the current color of this dye
-     *
-     * @return DyeColor of this dye
-     */
-    public DyeColor getColor() {
-        return DyeColor.getByDyeData(getData());
-    }
-
-    /**
-     * Sets the color of this dye
-     *
-     * @param color New color of this dye
-     */
-    public void setColor(DyeColor color) {
-        setData(color.getDyeData());
-    }
-
-    @Override
-    public String toString() {
-        return getColor() + " DYE(" + getData() + ")";
-    }
-
-    @Override
-    public Dye clone() {
-        return (Dye) super.clone();
-    }
-}
diff --git a/src/main/java/org/bukkit/material/EnderChest.java b/src/main/java/org/bukkit/material/EnderChest.java
deleted file mode 100644
index d3a6019..0000000
--- a/src/main/java/org/bukkit/material/EnderChest.java
+++ /dev/null
@@ -1,62 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.Material;
-import org.bukkit.block.BlockFace;
-
-/**
- * Represents an ender chest
- */
-public class EnderChest extends DirectionalContainer {
-
-    public EnderChest() {
-        super(Material.ENDER_CHEST);
-    }
-
-    /**
-     * Instantiate an ender chest facing in a particular direction.
-     *
-     * @param direction the direction the ender chest's lid opens towards
-     */
-    public EnderChest(BlockFace direction) {
-        this();
-        setFacingDirection(direction);
-    }
-
-    /**
-     * @param type the raw type id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public EnderChest(final int type) {
-        super(type);
-    }
-
-    public EnderChest(final Material type) {
-        super(type);
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public EnderChest(final int type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * @param type the type
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public EnderChest(final Material type, final byte data) {
-        super(type, data);
-    }
-
-    @Override
-    public EnderChest clone() {
-        return (EnderChest) super.clone();
-    }
-}
diff --git a/src/main/java/org/bukkit/material/ExtendedRails.java b/src/main/java/org/bukkit/material/ExtendedRails.java
deleted file mode 100644
index 34fb55e..0000000
--- a/src/main/java/org/bukkit/material/ExtendedRails.java
+++ /dev/null
@@ -1,75 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.Material;
-import org.bukkit.block.BlockFace;
-
-/**
- * This is the superclass for the {@link DetectorRail} and {@link PoweredRail}
- * classes
- */
-public class ExtendedRails extends Rails {
-    /**
-     * @param type the raw type id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public ExtendedRails(final int type) {
-        super(type);
-    }
-
-    public ExtendedRails(final Material type) {
-        super(type);
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public ExtendedRails(final int type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * @param type the type
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public ExtendedRails(final Material type, final byte data) {
-        super(type, data);
-    }
-
-    @Override
-    public boolean isCurve() {
-        return false;
-    }
-
-    /**
-     *
-     * @deprecated Magic value
-     */
-    @Deprecated
-    @Override
-    protected byte getConvertedData() {
-        return (byte) (getData() & 0x7);
-    }
-
-    @Override
-    public void setDirection(BlockFace face, boolean isOnSlope) {
-        boolean extraBitSet = (getData() & 0x8) == 0x8;
-
-        if (face != BlockFace.WEST && face != BlockFace.EAST && face != BlockFace.NORTH && face != BlockFace.SOUTH) {
-            throw new IllegalArgumentException("Detector rails and powered rails cannot be set on a curve!");
-        }
-
-        super.setDirection(face, isOnSlope);
-        setData((byte) (extraBitSet ? (getData() | 0x8) : (getData() & ~0x8)));
-    }
-
-    @Override
-    public ExtendedRails clone() {
-        return (ExtendedRails) super.clone();
-    }
-}
diff --git a/src/main/java/org/bukkit/material/FlowerPot.java b/src/main/java/org/bukkit/material/FlowerPot.java
deleted file mode 100644
index a3951e7..0000000
--- a/src/main/java/org/bukkit/material/FlowerPot.java
+++ /dev/null
@@ -1,141 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.GrassSpecies;
-import org.bukkit.Material;
-import org.bukkit.TreeSpecies;
-
-/**
- * Represents a flower pot.
- *
- * @deprecated Flower pots are now tile entities, use
- * {@link org.bukkit.block.FlowerPot}.
- */
-@Deprecated
-public class FlowerPot extends MaterialData {
-
-    /**
-     * Default constructor for a flower pot.
-     */
-    public FlowerPot() {
-        super(Material.FLOWER_POT);
-    }
-
-    /**
-     * @param type the raw type id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public FlowerPot(final int type) {
-        super(type);
-    }
-
-    public FlowerPot(final Material type) {
-        super(type);
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public FlowerPot(final int type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * @param type the type
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public FlowerPot(final Material type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * Get the material in the flower pot
-     *
-     * @return material MaterialData for the block currently in the flower pot
-     *     or null if empty
-     */
-    public MaterialData getContents() {
-        switch (getData()) {
-            case 1:
-                return new MaterialData(Material.RED_ROSE);
-            case 2:
-                return new MaterialData(Material.YELLOW_FLOWER);
-            case 3:
-                return new Tree(TreeSpecies.GENERIC);
-            case 4:
-                return new Tree(TreeSpecies.REDWOOD);
-            case 5:
-                return new Tree(TreeSpecies.BIRCH);
-            case 6:
-                return new Tree(TreeSpecies.JUNGLE);
-            case 7:
-                return new MaterialData(Material.RED_MUSHROOM);
-            case 8:
-                return new MaterialData(Material.BROWN_MUSHROOM);
-            case 9:
-                return new MaterialData(Material.CACTUS);
-            case 10:
-                return new MaterialData(Material.DEAD_BUSH);
-            case 11:
-                return new LongGrass(GrassSpecies.FERN_LIKE);
-            default:
-                return null;
-        }
-    }
-
-    /**
-     * Set the contents of the flower pot
-     *
-     * @param materialData MaterialData of the block to put in the flower pot.
-     */
-    public void setContents(MaterialData materialData) {
-        Material mat = materialData.getItemType();
-
-        if (mat == Material.RED_ROSE) {
-            setData((byte) 1);
-        } else if (mat == Material.YELLOW_FLOWER) {
-            setData((byte) 2);
-        } else if (mat == Material.RED_MUSHROOM) {
-            setData((byte) 7);
-        } else if (mat == Material.BROWN_MUSHROOM) {
-            setData((byte) 8);
-        } else if (mat == Material.CACTUS) {
-            setData((byte) 9);
-        } else if (mat == Material.DEAD_BUSH) {
-            setData((byte) 10);
-        } else if (mat == Material.SAPLING) {
-            TreeSpecies species = ((Tree) materialData).getSpecies();
-
-            if (species == TreeSpecies.GENERIC) {
-                setData((byte) 3);
-            } else if (species == TreeSpecies.REDWOOD) {
-                setData((byte) 4);
-            } else if (species == TreeSpecies.BIRCH) {
-                setData((byte) 5);
-            } else {
-                setData((byte) 6);
-            }
-        } else if (mat == Material.LONG_GRASS) {
-            GrassSpecies species = ((LongGrass) materialData).getSpecies();
-
-            if (species == GrassSpecies.FERN_LIKE) {
-                setData((byte) 11);
-            }
-        }
-    }
-
-    @Override
-    public String toString() {
-        return super.toString() + " containing " + getContents();
-    }
-
-    @Override
-    public FlowerPot clone() {
-        return (FlowerPot) super.clone();
-    }
-}
diff --git a/src/main/java/org/bukkit/material/Furnace.java b/src/main/java/org/bukkit/material/Furnace.java
deleted file mode 100644
index c607226..0000000
--- a/src/main/java/org/bukkit/material/Furnace.java
+++ /dev/null
@@ -1,62 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.Material;
-import org.bukkit.block.BlockFace;
-
-/**
- * Represents a furnace.
- */
-public class Furnace extends FurnaceAndDispenser {
-
-    public Furnace() {
-        super(Material.FURNACE);
-    }
-
-    /**
-     * Instantiate a furnace facing in a particular direction.
-     *
-     * @param direction the direction the furnace's "opening" is facing
-     */
-    public Furnace(BlockFace direction) {
-        this();
-        setFacingDirection(direction);
-    }
-
-    /**
-     * @param type the raw type id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Furnace(final int type) {
-        super(type);
-    }
-
-    public Furnace(final Material type) {
-        super(type);
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Furnace(final int type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * @param type the type
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Furnace(final Material type, final byte data) {
-        super(type, data);
-    }
-
-    @Override
-    public Furnace clone() {
-        return (Furnace) super.clone();
-    }
-}
diff --git a/src/main/java/org/bukkit/material/FurnaceAndDispenser.java b/src/main/java/org/bukkit/material/FurnaceAndDispenser.java
deleted file mode 100644
index 184fda2..0000000
--- a/src/main/java/org/bukkit/material/FurnaceAndDispenser.java
+++ /dev/null
@@ -1,47 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.Material;
-
-/**
- * Represents a furnace or dispenser, two types of directional containers
- */
-public class FurnaceAndDispenser extends DirectionalContainer {
-
-    /**
-     * @param type the raw type id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public FurnaceAndDispenser(final int type) {
-        super(type);
-    }
-
-    public FurnaceAndDispenser(final Material type) {
-        super(type);
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public FurnaceAndDispenser(final int type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * @param type the type
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public FurnaceAndDispenser(final Material type, final byte data) {
-        super(type, data);
-    }
-
-    @Override
-    public FurnaceAndDispenser clone() {
-        return (FurnaceAndDispenser) super.clone();
-    }
-}
diff --git a/src/main/java/org/bukkit/material/Gate.java b/src/main/java/org/bukkit/material/Gate.java
deleted file mode 100644
index 8adc1cf..0000000
--- a/src/main/java/org/bukkit/material/Gate.java
+++ /dev/null
@@ -1,91 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.Material;
-import org.bukkit.block.BlockFace;
-
-/**
- * Represents a fence gate
- */
-public class Gate extends MaterialData implements Directional, Openable {
-    private static final byte OPEN_BIT = 0x4;
-    private static final byte DIR_BIT = 0x3;
-    private static final byte GATE_SOUTH = 0x0;
-    private static final byte GATE_WEST = 0x1;
-    private static final byte GATE_NORTH = 0x2;
-    private static final byte GATE_EAST = 0x3;
-
-    public Gate() {
-        super(Material.FENCE_GATE);
-    }
-
-    public Gate(int type, byte data){
-        super(type, data);
-    }
-
-    public Gate(byte data) {
-        super(Material.FENCE_GATE, data);
-    }
-
-    public void setFacingDirection(BlockFace face) {
-        byte data = (byte) (getData() &~ DIR_BIT);
-
-        switch (face) {
-            default:
-            case EAST:
-                data |= GATE_SOUTH;
-                break;
-            case SOUTH:
-                data |= GATE_WEST;
-                break;
-            case WEST:
-                data |= GATE_NORTH;
-                break;
-            case NORTH:
-                data |= GATE_EAST;
-                break;
-        }
-
-        setData(data);
-    }
-
-    public BlockFace getFacing() {
-        switch (getData() & DIR_BIT) {
-            case GATE_SOUTH:
-                return BlockFace.EAST;
-            case GATE_WEST:
-                return BlockFace.SOUTH;
-            case GATE_NORTH:
-                return BlockFace.WEST;
-            case GATE_EAST:
-                return BlockFace.NORTH;
-        }
-
-        return BlockFace.EAST;
-    }
-
-    public boolean isOpen() {
-        return (getData() & OPEN_BIT) > 0;
-    }
-
-    public void setOpen(boolean isOpen) {
-        byte data = getData();
-
-        if (isOpen) {
-            data |= OPEN_BIT;
-        } else {
-            data &= ~OPEN_BIT;
-        }
-
-        setData(data);
-    }
-
-    @Override
-    public String toString() {
-        return (isOpen() ? "OPEN " : "CLOSED ") + " facing and opening " + getFacing();
-    }
-
-    @Override
-    public Gate clone() {
-        return (Gate) super.clone();
-    }
-}
\ No newline at end of file
diff --git a/src/main/java/org/bukkit/material/Hopper.java b/src/main/java/org/bukkit/material/Hopper.java
deleted file mode 100644
index d1516f2..0000000
--- a/src/main/java/org/bukkit/material/Hopper.java
+++ /dev/null
@@ -1,181 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.Material;
-import org.bukkit.block.BlockFace;
-
-/**
- * Represents a hopper in an active or deactivated state and facing in a
- * specific direction.
- *
- * @see Material#HOPPER
- */
-public class Hopper extends MaterialData implements Directional, Redstone {
-
-    protected static final BlockFace DEFAULT_DIRECTION = BlockFace.DOWN;
-    protected static final boolean DEFAULT_ACTIVE = true;
-
-    /**
-     * Constructs a hopper facing the default direction (down) and initially
-     * active.
-     */
-    public Hopper() {
-        this(DEFAULT_DIRECTION, DEFAULT_ACTIVE);
-    }
-
-    /**
-     * Constructs a hopper facing the specified direction and initially active.
-     *
-     * @param facingDirection the direction the hopper is facing
-     *
-     * @see BlockFace
-     */
-    public Hopper(BlockFace facingDirection) {
-        this(facingDirection, DEFAULT_ACTIVE);
-    }
-
-    /**
-     * Constructs a hopper facing the specified direction and either active or
-     * not.
-     *
-     * @param facingDirection the direction the hopper is facing
-     * @param isActive True if the hopper is initially active, false if
-     * deactivated
-     *
-     * @see BlockFace
-     */
-    public Hopper(BlockFace facingDirection, boolean isActive) {
-        super(Material.HOPPER);
-        setFacingDirection(facingDirection);
-        setActive(isActive);
-    }
-
-    /**
-     * @param type the raw type id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Hopper(int type) {
-        super(type);
-    }
-
-    public Hopper(Material type) {
-        super(type);
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Hopper(int type, byte data) {
-        super(type, data);
-    }
-
-    /**
-     * @param type the type
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Hopper(Material type, byte data) {
-        super(type, data);
-    }
-
-    /**
-     * Sets whether the hopper is active or not.
-     *
-     * @param isActive True if the hopper is active, false if deactivated as if
-     * powered by redstone
-     */
-    public void setActive(boolean isActive) {
-        setData((byte) (getData() & 0x7 | (isActive ? 0x0 : 0x8)));
-    }
-
-    /**
-     * Checks whether the hopper is active or not.
-     *
-     * @return True if the hopper is active, false if deactivated
-     */
-    public boolean isActive() {
-        return (getData() & 0x8) == 0;
-    }
-
-    /**
-     * Sets the direction this hopper is facing
-     *
-     * @param face The direction to set this hopper to
-     *
-     * @see BlockFace
-     */
-    @Override
-    public void setFacingDirection(BlockFace face) {
-        int data = getData() & 0x8;
-
-        switch (face) {
-            case DOWN:
-                data |= 0x0;
-                break;
-            case NORTH:
-                data |= 0x2;
-                break;
-            case SOUTH:
-                data |= 0x3;
-                break;
-            case WEST:
-                data |= 0x4;
-                break;
-            case EAST:
-                data |= 0x5;
-                break;
-        }
-
-        setData((byte) data);
-    }
-
-    /**
-     * Gets the direction this hopper is facing
-     *
-     * @return The direction this hopper is facing
-     *
-     * @see BlockFace
-     */
-    @Override
-    public BlockFace getFacing() {
-        byte data = (byte) (getData() & 0x7);
-
-        switch (data) {
-            default:
-            case 0x0:
-                return BlockFace.DOWN;
-            case 0x2:
-                return BlockFace.NORTH;
-            case 0x3:
-                return BlockFace.SOUTH;
-            case 0x4:
-                return BlockFace.WEST;
-            case 0x5:
-                return BlockFace.EAST;
-        }
-    }
-
-    @Override
-    public String toString() {
-        return super.toString() + " facing " + getFacing();
-    }
-
-    @Override
-    public Hopper clone() {
-        return (Hopper) super.clone();
-    }
-
-    /**
-     * Checks if the hopper is powered.
-     *
-     * @return true if the hopper is powered
-     */
-    @Override
-    public boolean isPowered() {
-        return (getData() & 0x8) != 0;
-    }
-}
diff --git a/src/main/java/org/bukkit/material/Ladder.java b/src/main/java/org/bukkit/material/Ladder.java
deleted file mode 100644
index cd4d691..0000000
--- a/src/main/java/org/bukkit/material/Ladder.java
+++ /dev/null
@@ -1,104 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.block.BlockFace;
-import org.bukkit.Material;
-
-/**
- * Represents Ladder data
- */
-public class Ladder extends SimpleAttachableMaterialData {
-    public Ladder() {
-        super(Material.LADDER);
-    }
-
-    /**
-     * @param type the raw type id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Ladder(final int type) {
-        super(type);
-    }
-
-    public Ladder(final Material type) {
-        super(type);
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Ladder(final int type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * @param type the type
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Ladder(final Material type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * Gets the face that this block is attached on
-     *
-     * @return BlockFace attached to
-     */
-    public BlockFace getAttachedFace() {
-        byte data = getData();
-
-        switch (data) {
-        case 0x2:
-            return BlockFace.SOUTH;
-
-        case 0x3:
-            return BlockFace.NORTH;
-
-        case 0x4:
-            return BlockFace.EAST;
-
-        case 0x5:
-            return BlockFace.WEST;
-        }
-
-        return null;
-    }
-
-    /**
-     * Sets the direction this ladder is facing
-     */
-    public void setFacingDirection(BlockFace face) {
-        byte data = (byte) 0x0;
-
-        switch (face) {
-        case SOUTH:
-            data = 0x2;
-            break;
-
-        case NORTH:
-            data = 0x3;
-            break;
-
-        case EAST:
-            data = 0x4;
-            break;
-
-        case WEST:
-            data = 0x5;
-            break;
-        }
-
-        setData(data);
-
-    }
-
-    @Override
-    public Ladder clone() {
-        return (Ladder) super.clone();
-    }
-}
diff --git a/src/main/java/org/bukkit/material/Leaves.java b/src/main/java/org/bukkit/material/Leaves.java
deleted file mode 100644
index 904659b..0000000
--- a/src/main/java/org/bukkit/material/Leaves.java
+++ /dev/null
@@ -1,156 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.Material;
-import org.bukkit.TreeSpecies;
-
-/**
- * Represents the different types of leaf block that may be permanent or can
- * decay when too far from a log.
- *
- * @see Material#LEAVES
- * @see Material#LEAVES_2
- */
-public class Leaves extends Wood {
-    protected static final Material DEFAULT_TYPE = Material.LEAVES;
-    protected static final boolean DEFAULT_DECAYABLE = true;
-
-    /**
-     * Constructs a leaf block.
-     */
-    public Leaves() {
-        this(DEFAULT_TYPE, DEFAULT_SPECIES, DEFAULT_DECAYABLE);
-    }
-
-    /**
-     * Constructs a leaf block of the given tree species.
-     *
-     * @param species the species of the wood block
-     */
-    public Leaves(TreeSpecies species) {
-        this(DEFAULT_TYPE, species, DEFAULT_DECAYABLE);
-    }
-
-    /**
-     * Constructs a leaf block of the given tree species and flag for whether
-     * this leaf block will disappear when too far from a log.
-     *
-     * @param species the species of the wood block
-     * @param isDecayable whether the block is permanent or can disappear
-     */
-    public Leaves(TreeSpecies species, boolean isDecayable) {
-        this(DEFAULT_TYPE, species, isDecayable);
-    }
-
-    /**
-     * @param type the raw type id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Leaves(final int type) {
-        super(type);
-    }
-
-    /**
-     * Constructs a leaf block of the given type.
-     *
-     * @param type the type of leaf block
-     */
-    public Leaves(final Material type) {
-        this(type, DEFAULT_SPECIES, DEFAULT_DECAYABLE);
-    }
-
-    /**
-     * Constructs a leaf block of the given type and tree species.
-     *
-     * @param type the type of leaf block
-     * @param species the species of the wood block
-     */
-    public Leaves(final Material type, TreeSpecies species) {
-        this(type, species, DEFAULT_DECAYABLE);
-    }
-
-    /**
-     * Constructs a leaf block of the given type and tree species and flag for
-     * whether this leaf block will disappear when too far from a log.
-     *
-     * @param type the type of leaf block
-     * @param species the species of the wood block
-     * @param isDecayable whether the block is permanent or can disappear
-     */
-    public Leaves(final Material type, TreeSpecies species, boolean isDecayable) {
-        super(type, species);
-        setDecayable(isDecayable);
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Leaves(final int type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * @param type the type
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Leaves(final Material type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * Checks if this leaf block is in the process of decaying
-     *
-     * @return true if the leaf block is in the process of decaying
-     */
-    public boolean isDecaying() {
-        return (getData() & 0x8) != 0;
-    }
-
-    /**
-     * Set whether this leaf block is in the process of decaying
-     *
-     * @param isDecaying whether the block is decaying or not
-     */
-    public void setDecaying(boolean isDecaying) {
-        setData((byte) ((getData() & 0x3) | (isDecaying
-                ? 0x8 // Clear the permanent flag to make this a decayable flag and set the decaying flag
-                : (getData() & 0x4)))); // Only persist the decayable flag if this is not a decaying block
-    }
-
-    /**
-     * Checks if this leaf block is permanent or can decay when too far from a
-     * log
-     *
-     * @return true if the leaf block is permanent or can decay when too far
-     * from a log
-     */
-    public boolean isDecayable() {
-        return (getData() & 0x4) == 0;
-    }
-
-    /**
-     * Set whether this leaf block will disappear when too far from a log
-     *
-     * @param isDecayable whether the block is permanent or can disappear
-     */
-    public void setDecayable(boolean isDecayable) {
-        setData((byte) ((getData() & 0x3) | (isDecayable
-                ? (getData() & 0x8) // Only persist the decaying flag if this is a decayable block
-                : 0x4)));
-    }
-
-    @Override
-    public String toString() {
-        return getSpecies() + (isDecayable() ? " DECAYABLE " : " PERMANENT ") + (isDecaying() ? " DECAYING " : " ") + super.toString();
-    }
-
-    @Override
-    public Leaves clone() {
-        return (Leaves) super.clone();
-    }
-}
diff --git a/src/main/java/org/bukkit/material/Lever.java b/src/main/java/org/bukkit/material/Lever.java
deleted file mode 100644
index c6d3882..0000000
--- a/src/main/java/org/bukkit/material/Lever.java
+++ /dev/null
@@ -1,162 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.block.BlockFace;
-import org.bukkit.Material;
-
-/**
- * Represents a lever
- */
-public class Lever extends SimpleAttachableMaterialData implements Redstone {
-    public Lever() {
-        super(Material.LEVER);
-    }
-
-    /**
-     * @param type the raw type id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Lever(final int type) {
-        super(type);
-    }
-
-    public Lever(final Material type) {
-        super(type);
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Lever(final int type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * @param type the type
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Lever(final Material type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * Gets the current state of this Material, indicating if it's powered or
-     * unpowered
-     *
-     * @return true if powered, otherwise false
-     */
-    public boolean isPowered() {
-        return (getData() & 0x8) == 0x8;
-    }
-
-    /**
-     * Set this lever to be powered or not.
-     *
-     * @param isPowered whether the lever should be powered or not
-     */
-    public void setPowered(boolean isPowered) {
-        setData((byte) (isPowered ? (getData() | 0x8) : (getData() & ~0x8)));
-    }
-
-    /**
-     * Gets the face that this block is attached on
-     *
-     * @return BlockFace attached to
-     */
-    public BlockFace getAttachedFace() {
-        byte data = (byte) (getData() & 0x7);
-
-        switch (data) {
-        case 0x1:
-            return BlockFace.WEST;
-
-        case 0x2:
-            return BlockFace.EAST;
-
-        case 0x3:
-            return BlockFace.NORTH;
-
-        case 0x4:
-            return BlockFace.SOUTH;
-
-        case 0x5:
-        case 0x6:
-            return BlockFace.DOWN;
-
-        case 0x0:
-        case 0x7:
-            return BlockFace.UP;
-
-        }
-
-        return null;
-    }
-
-    /**
-     * Sets the direction this lever is pointing in
-     */
-    public void setFacingDirection(BlockFace face) {
-        byte data = (byte) (getData() & 0x8);
-        BlockFace attach = getAttachedFace();
-
-        if (attach == BlockFace.DOWN) {
-            switch (face) {
-            case SOUTH:
-            case NORTH:
-                data |= 0x5;
-                break;
-
-            case EAST:
-            case WEST:
-                data |= 0x6;
-                break;
-            }
-        } else if (attach == BlockFace.UP) {
-            switch (face) {
-            case SOUTH:
-            case NORTH:
-                data |= 0x7;
-                break;
-
-            case EAST:
-            case WEST:
-                data |= 0x0;
-                break;
-            }
-        } else {
-            switch (face) {
-            case EAST:
-                data |= 0x1;
-                break;
-
-            case WEST:
-                data |= 0x2;
-                break;
-
-            case SOUTH:
-                data |= 0x3;
-                break;
-
-            case NORTH:
-                data |= 0x4;
-                break;
-            }
-        }
-        setData(data);
-    }
-
-    @Override
-    public String toString() {
-        return super.toString() + " facing " + getFacing() + " " + (isPowered() ? "" : "NOT ") + "POWERED";
-    }
-
-    @Override
-    public Lever clone() {
-        return (Lever) super.clone();
-    }
-}
diff --git a/src/main/java/org/bukkit/material/LongGrass.java b/src/main/java/org/bukkit/material/LongGrass.java
deleted file mode 100644
index 5cd8d20..0000000
--- a/src/main/java/org/bukkit/material/LongGrass.java
+++ /dev/null
@@ -1,79 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.GrassSpecies;
-import org.bukkit.Material;
-
-/**
- * Represents the different types of long grasses.
- */
-public class LongGrass extends MaterialData {
-    public LongGrass() {
-        super(Material.LONG_GRASS);
-    }
-
-    public LongGrass(GrassSpecies species) {
-        this();
-        setSpecies(species);
-    }
-
-    /**
-     * @param type the raw type id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public LongGrass(final int type) {
-        super(type);
-    }
-
-    public LongGrass(final Material type) {
-        super(type);
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public LongGrass(final int type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * @param type the type
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public LongGrass(final Material type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * Gets the current species of this grass
-     *
-     * @return GrassSpecies of this grass
-     */
-    public GrassSpecies getSpecies() {
-        return GrassSpecies.getByData(getData());
-    }
-
-    /**
-     * Sets the species of this grass
-     *
-     * @param species New species of this grass
-     */
-    public void setSpecies(GrassSpecies species) {
-        setData(species.getData());
-    }
-
-    @Override
-    public String toString() {
-        return getSpecies() + " " + super.toString();
-    }
-
-    @Override
-    public LongGrass clone() {
-        return (LongGrass) super.clone();
-    }
-}
diff --git a/src/main/java/org/bukkit/material/MaterialData.java b/src/main/java/org/bukkit/material/MaterialData.java
deleted file mode 100644
index 9caf085..0000000
--- a/src/main/java/org/bukkit/material/MaterialData.java
+++ /dev/null
@@ -1,137 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.inventory.ItemStack;
-import org.bukkit.Material;
-
-/**
- * Handles specific metadata for certain items or blocks
- */
-public class MaterialData implements Cloneable {
-    private final int type;
-    private byte data = 0;
-
-    /**
-     * @param type the raw type id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public MaterialData(final int type) {
-        this(type, (byte) 0);
-    }
-
-    public MaterialData(final Material type) {
-        this(type, (byte) 0);
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public MaterialData(final int type, final byte data) {
-        this.type = type;
-        this.data = data;
-    }
-
-    /**
-     * @param type the type
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public MaterialData(final Material type, final byte data) {
-        this(type.getId(), data);
-    }
-
-    /**
-     * Gets the raw data in this material
-     *
-     * @return Raw data
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public byte getData() {
-        return data;
-    }
-
-    /**
-     * Sets the raw data of this material
-     *
-     * @param data New raw data
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public void setData(byte data) {
-        this.data = data;
-    }
-
-    /**
-     * Gets the Material that this MaterialData represents
-     *
-     * @return Material represented by this MaterialData
-     */
-    public Material getItemType() {
-        return Material.getMaterial(type);
-    }
-
-    /**
-     * Gets the Material Id that this MaterialData represents
-     *
-     * @return Material Id represented by this MaterialData
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public int getItemTypeId() {
-        return type;
-    }
-
-    /**
-     * Creates a new ItemStack based on this MaterialData
-     *
-     * @return New ItemStack containing a copy of this MaterialData
-     */
-    public ItemStack toItemStack() {
-        return new ItemStack(type, 0, data);
-    }
-
-    /**
-     * Creates a new ItemStack based on this MaterialData
-     *
-     * @param amount The stack size of the new stack
-     * @return New ItemStack containing a copy of this MaterialData
-     */
-    public ItemStack toItemStack(int amount) {
-        return new ItemStack(type, amount, data);
-    }
-
-    @Override
-    public String toString() {
-        return getItemType() + "(" + getData() + ")";
-    }
-
-    @Override
-    public int hashCode() {
-        return ((getItemTypeId() << 8) ^ getData());
-    }
-
-    @Override
-    public boolean equals(Object obj) {
-        if (obj != null && obj instanceof MaterialData) {
-            MaterialData md = (MaterialData) obj;
-
-            return (md.getItemTypeId() == getItemTypeId() && md.getData() == getData());
-        } else {
-            return false;
-        }
-    }
-
-    @Override
-    public MaterialData clone() {
-        try {
-            return (MaterialData) super.clone();
-        } catch (CloneNotSupportedException e) {
-            throw new Error(e);
-        }
-    }
-}
diff --git a/src/main/java/org/bukkit/material/MonsterEggs.java b/src/main/java/org/bukkit/material/MonsterEggs.java
deleted file mode 100644
index a6897b7..0000000
--- a/src/main/java/org/bukkit/material/MonsterEggs.java
+++ /dev/null
@@ -1,69 +0,0 @@
-package org.bukkit.material;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import org.bukkit.Material;
-
-/**
- * Represents the different types of monster eggs
- */
-public class MonsterEggs extends TexturedMaterial {
-
-    private static final List<Material> textures = new ArrayList<Material>();
-    static {
-        textures.add(Material.STONE);
-        textures.add(Material.COBBLESTONE);
-        textures.add(Material.SMOOTH_BRICK);
-    }
-
-    public MonsterEggs() {
-        super(Material.MONSTER_EGGS);
-    }
-
-    /**
-     * @param type the raw type id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public MonsterEggs(final int type) {
-        super(type);
-    }
-
-    public MonsterEggs(final Material type) {
-        super((textures.contains(type)) ? Material.MONSTER_EGGS : type);
-        if (textures.contains(type)) {
-            setMaterial(type);
-        }
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public MonsterEggs(final int type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * @param type the type
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public MonsterEggs(final Material type, final byte data) {
-        super(type, data);
-    }
-
-    @Override
-    public List<Material> getTextures() {
-        return textures;
-    }
-
-    @Override
-    public MonsterEggs clone() {
-        return (MonsterEggs) super.clone();
-    }
-}
diff --git a/src/main/java/org/bukkit/material/Mushroom.java b/src/main/java/org/bukkit/material/Mushroom.java
deleted file mode 100644
index 3b372ec..0000000
--- a/src/main/java/org/bukkit/material/Mushroom.java
+++ /dev/null
@@ -1,295 +0,0 @@
-package org.bukkit.material;
-
-import java.util.EnumSet;
-import java.util.Set;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.Material;
-import org.bukkit.block.BlockFace;
-import org.bukkit.material.types.MushroomBlockTexture;
-
-/**
- * Represents a huge mushroom block with certain combinations of faces set to
- * cap, pores or stem.
- *
- * @see Material#HUGE_MUSHROOM_1
- * @see Material#HUGE_MUSHROOM_2
- */
-public class Mushroom extends MaterialData {
-    private static final byte NORTH_LIMIT = 4;
-    private static final byte SOUTH_LIMIT = 6;
-    private static final byte EAST_WEST_LIMIT = 3;
-    private static final byte EAST_REMAINDER = 0;
-    private static final byte WEST_REMAINDER = 1;
-    private static final byte NORTH_SOUTH_MOD = 3;
-    private static final byte EAST_WEST_MOD = 1;
-
-    /**
-     * Constructs a brown/red mushroom block with all sides set to pores.
-     *
-     * @param shroom A brown or red mushroom material type.
-     *
-     * @see Material#HUGE_MUSHROOM_1
-     * @see Material#HUGE_MUSHROOM_2
-     */
-    public Mushroom(Material shroom) {
-        super(shroom);
-        Validate.isTrue(shroom == Material.HUGE_MUSHROOM_1 || shroom == Material.HUGE_MUSHROOM_2, "Not a mushroom!");
-    }
-
-    /**
-     * Constructs a brown/red mushroom cap block with the specified face or
-     * faces set to cap texture.
-     *
-     * Setting any of the four sides will also set the top to cap.
-     *
-     * To set two side faces at once use e.g. north-west.
-     *
-     * Specify self to set all six faces at once.
-     *
-     * @param shroom A brown or red mushroom material type.
-     * @param capFace The face or faces to set to mushroom cap texture.
-     *
-     * @see Material#HUGE_MUSHROOM_1
-     * @see Material#HUGE_MUSHROOM_2
-     * @see BlockFace
-     */
-    public Mushroom(Material shroom, BlockFace capFace) {
-        this(shroom, MushroomBlockTexture.getCapByFace(capFace));
-    }
-
-    /**
-     * Constructs a brown/red mushroom block with the specified textures.
-     *
-     * @param shroom A brown or red mushroom material type.
-     * @param texture The textured mushroom faces.
-     *
-     * @see Material#HUGE_MUSHROOM_1
-     * @see Material#HUGE_MUSHROOM_2
-     */
-    public Mushroom(Material shroom, MushroomBlockTexture texture) {
-        this(shroom, texture.getData());
-    }
-
-    /**
-     * @param shroom the type
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Mushroom(Material shroom, byte data) {
-        super(shroom, data);
-        Validate.isTrue(shroom == Material.HUGE_MUSHROOM_1 || shroom == Material.HUGE_MUSHROOM_2, "Not a mushroom!");
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Mushroom(int type, byte data){
-        super(type, data);
-        Validate.isTrue(type == Material.HUGE_MUSHROOM_1.getId() || type == Material.HUGE_MUSHROOM_2.getId(), "Not a mushroom!");
-    }
-
-    /**
-     * @return Whether this is a mushroom stem.
-     */
-    public boolean isStem() {
-        return getData() == MushroomBlockTexture.STEM_SIDES.getData() || getData() == MushroomBlockTexture.ALL_STEM.getData();
-    }
-
-    /**
-     * Sets this to be a mushroom stem.
-     *
-     * @see MushroomBlockTexture#STEM_SIDES
-     * @see MushroomBlockTexture#ALL_STEM
-     *
-     * @deprecated Use
-     * {@link #setBlockTexture(org.bukkit.material.types.MushroomBlockTexture)}
-     * with {@link MushroomBlockTexture#STEM_SIDES } or
-     * {@link MushroomBlockTexture#ALL_STEM}
-     */
-    @Deprecated
-    public void setStem() {
-        setData((byte) MushroomBlockTexture.STEM_SIDES.getData());
-    }
-
-    /**
-     * Gets the mushroom texture of this block.
-     *
-     * @return The mushroom texture of this block
-     */
-    public MushroomBlockTexture getBlockTexture() {
-        return MushroomBlockTexture.getByData(getData());
-    }
-
-    /**
-     * Sets the mushroom texture of this block.
-     *
-     * @param texture The mushroom texture to set
-     */
-    public void setBlockTexture(MushroomBlockTexture texture) {
-        setData(texture.getData());
-    }
-
-    /**
-     * Checks whether a face of the block is painted with cap texture.
-     *
-     * @param face The face to check.
-     * @return True if it is painted.
-     */
-    public boolean isFacePainted(BlockFace face) {
-        byte data = getData();
-
-        if (data == MushroomBlockTexture.ALL_PORES.getData() || data == MushroomBlockTexture.STEM_SIDES.getData()
-                || data == MushroomBlockTexture.ALL_STEM.getData()) {
-            return false;
-        }
-
-        switch (face) {
-            case WEST:
-                return data < NORTH_LIMIT;
-            case EAST:
-                return data > SOUTH_LIMIT;
-            case NORTH:
-                return data % EAST_WEST_LIMIT == EAST_REMAINDER;
-            case SOUTH:
-                return data % EAST_WEST_LIMIT == WEST_REMAINDER;
-            case UP:
-                return true;
-            case DOWN:
-            case SELF:
-                return data == MushroomBlockTexture.ALL_CAP.getData();
-            default:
-                return false;
-        }
-    }
-
-    /**
-     * Set a face of the block to be painted or not. Note that due to the
-     * nature of how the data is stored, setting a face painted or not is not
-     * guaranteed to leave the other faces unchanged.
-     *
-     * @param face The face to paint or unpaint.
-     * @param painted True if you want to paint it, false if you want the
-     *     pores to show.
-     *
-     * @deprecated Use MushroomBlockType cap options
-     */
-    @Deprecated
-    public void setFacePainted(BlockFace face, boolean painted) {
-        if (painted == isFacePainted(face)) {
-            return;
-        }
-
-        byte data = getData();
-
-        if (data == MushroomBlockTexture.ALL_PORES.getData() || isStem()) {
-            data = MushroomBlockTexture.CAP_TOP.getData();
-        }
-        if (data == MushroomBlockTexture.ALL_CAP.getData() && !painted) {
-            data = MushroomBlockTexture.CAP_TOP.getData();
-            face = face.getOppositeFace();
-            painted = true;
-        }
-
-        switch (face) {
-            case WEST:
-                if (painted) {
-                    data -= NORTH_SOUTH_MOD;
-                } else {
-                    data += NORTH_SOUTH_MOD;
-                }
-
-                break;
-            case EAST:
-                if (painted) {
-                    data += NORTH_SOUTH_MOD;
-                } else {
-                    data -= NORTH_SOUTH_MOD;
-                }
-
-                break;
-            case NORTH:
-                if (painted) {
-                    data += EAST_WEST_MOD;
-                } else {
-                    data -= EAST_WEST_MOD;
-                }
-
-                break;
-            case SOUTH:
-                if (painted) {
-                    data -= EAST_WEST_MOD;
-                } else {
-                    data += EAST_WEST_MOD;
-                }
-
-                break;
-            case UP:
-                if (!painted) {
-                    data = MushroomBlockTexture.ALL_PORES.getData();
-                }
-                break;
-            case SELF:
-            case DOWN:
-                if (painted) {
-                    data = MushroomBlockTexture.ALL_CAP.getData();
-                }
-                else {
-                    data = MushroomBlockTexture.ALL_PORES.getData();
-                }
-                break;
-            default:
-                throw new IllegalArgumentException("Can't paint that face of a mushroom!");
-        }
-
-        setData(data);
-    }
-
-    /**
-     * @return A set of all faces that are currently painted (an empty set if
-     *     it is a stem)
-     */
-    public Set<BlockFace> getPaintedFaces() {
-        EnumSet<BlockFace> faces = EnumSet.noneOf(BlockFace.class);
-
-        if (isFacePainted(BlockFace.WEST)) {
-            faces.add(BlockFace.WEST);
-        }
-
-        if (isFacePainted(BlockFace.NORTH)) {
-            faces.add(BlockFace.NORTH);
-        }
-
-        if (isFacePainted(BlockFace.SOUTH)) {
-            faces.add(BlockFace.SOUTH);
-        }
-
-        if (isFacePainted(BlockFace.EAST)) {
-            faces.add(BlockFace.EAST);
-        }
-
-        if (isFacePainted(BlockFace.UP)) {
-            faces.add(BlockFace.UP);
-        }
-
-        if (isFacePainted(BlockFace.DOWN)) {
-            faces.add(BlockFace.DOWN);
-        }
-
-        return faces;
-    }
-
-    @Override
-    public String toString() {
-        return Material.getMaterial(getItemTypeId()).toString() + (isStem() ? " STEM " : " CAP ") + getPaintedFaces();
-    }
-
-    @Override
-    public Mushroom clone() {
-        return (Mushroom) super.clone();
-    }
-}
diff --git a/src/main/java/org/bukkit/material/NetherWarts.java b/src/main/java/org/bukkit/material/NetherWarts.java
deleted file mode 100644
index 55eb864..0000000
--- a/src/main/java/org/bukkit/material/NetherWarts.java
+++ /dev/null
@@ -1,101 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.Material;
-import org.bukkit.NetherWartsState;
-
-/**
- * Represents nether wart
- */
-public class NetherWarts extends MaterialData {
-    public NetherWarts() {
-        super(Material.NETHER_WARTS);
-    }
-
-    public NetherWarts(NetherWartsState state) {
-        this();
-        setState(state);
-    }
-
-    /**
-     * @param type the raw type id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public NetherWarts(final int type) {
-        super(type);
-    }
-
-    public NetherWarts(final Material type) {
-        super (type);
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public NetherWarts(final int type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * @param type the type
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public NetherWarts(final Material type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * Gets the current growth state of this nether wart
-     *
-     * @return NetherWartsState of this nether wart
-     */
-    public NetherWartsState getState() {
-        switch (getData()) {
-            case 0:
-                return NetherWartsState.SEEDED;
-            case 1:
-                return NetherWartsState.STAGE_ONE;
-            case 2:
-                return NetherWartsState.STAGE_TWO;
-            default:
-                return NetherWartsState.RIPE;
-        }
-    }
-
-    /**
-     * Sets the growth state of this nether wart
-     *
-     * @param state New growth state of this nether wart
-     */
-    public void setState(NetherWartsState state) {
-        switch (state) {
-            case SEEDED:
-                setData((byte) 0x0);
-                return;
-            case STAGE_ONE:
-                setData((byte) 0x1);
-                return;
-            case STAGE_TWO:
-                setData((byte) 0x2);
-                return;
-            case RIPE:
-                setData((byte) 0x3);
-                return;
-        }
-    }
-
-    @Override
-    public String toString() {
-        return getState() + " " + super.toString();
-    }
-
-    @Override
-    public NetherWarts clone() {
-        return (NetherWarts) super.clone();
-    }
-}
diff --git a/src/main/java/org/bukkit/material/Openable.java b/src/main/java/org/bukkit/material/Openable.java
deleted file mode 100644
index 0ae54f9..0000000
--- a/src/main/java/org/bukkit/material/Openable.java
+++ /dev/null
@@ -1,18 +0,0 @@
-package org.bukkit.material;
-
-public interface Openable {
-
-    /**
-     * Check to see if the door is open.
-     *
-     * @return true if the door has swung counterclockwise around its hinge.
-     */
-    boolean isOpen();
-
-    /**
-     * Configure this door to be either open or closed;
-     *
-     * @param isOpen True to open the door.
-     */
-    void setOpen(boolean isOpen);
-}
diff --git a/src/main/java/org/bukkit/material/PistonBaseMaterial.java b/src/main/java/org/bukkit/material/PistonBaseMaterial.java
deleted file mode 100644
index bbf1565..0000000
--- a/src/main/java/org/bukkit/material/PistonBaseMaterial.java
+++ /dev/null
@@ -1,123 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.Material;
-import org.bukkit.block.BlockFace;
-
-/**
- * Material data for the piston base block
- */
-public class PistonBaseMaterial extends MaterialData implements Directional, Redstone {
-    
-    /**
-     * Constructs a PistonBaseMaterial
-     * 
-     * @param type the raw type id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public PistonBaseMaterial(final int type) {
-        super(type);
-    }
-
-    public PistonBaseMaterial(final Material type) {
-        super(type);
-    }
-
-    /**
-     * Constructs a PistonBaseMaterial.
-     * 
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public PistonBaseMaterial(final int type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * Constructs a PistonBaseMaterial.
-     * 
-     * @param type the material type to use
-     * @param data the raw data value 
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public PistonBaseMaterial(final Material type, final byte data) {
-        super(type, data);
-    }
-
-    @Override
-    public void setFacingDirection(BlockFace face) {
-        byte data = (byte) (getData() & 0x8);
-
-        switch (face) {
-        case UP:
-            data |= 1;
-            break;
-        case NORTH:
-            data |= 2;
-            break;
-        case SOUTH:
-            data |= 3;
-            break;
-        case WEST:
-            data |= 4;
-            break;
-        case EAST:
-            data |= 5;
-            break;
-        }
-        setData(data);
-    }
-
-    @Override
-    public BlockFace getFacing() {
-        byte dir = (byte) (getData() & 7);
-
-        switch (dir) {
-        case 0:
-            return BlockFace.DOWN;
-        case 1:
-            return BlockFace.UP;
-        case 2:
-            return BlockFace.NORTH;
-        case 3:
-            return BlockFace.SOUTH;
-        case 4:
-            return BlockFace.WEST;
-        case 5:
-            return BlockFace.EAST;
-        default:
-            return BlockFace.SELF;
-        }
-    }
-
-    @Override
-    public boolean isPowered() {
-        return (getData() & 0x8) == 0x8;
-    }
-
-    /**
-     * Sets the current state of this piston
-     *
-     * @param powered true if the piston is extended {@literal &} powered, or false
-     */
-    public void setPowered(boolean powered) {
-        setData((byte) (powered ? (getData() | 0x8) : (getData() & ~0x8)));
-    }
-
-    /**
-     * Checks if this piston base is sticky, and returns true if so
-     *
-     * @return true if this piston is "sticky", or false
-     */
-    public boolean isSticky() {
-        return this.getItemType() == Material.PISTON_STICKY_BASE;
-    }
-
-    @Override
-    public PistonBaseMaterial clone() {
-        return (PistonBaseMaterial) super.clone();
-    }
-}
diff --git a/src/main/java/org/bukkit/material/PistonExtensionMaterial.java b/src/main/java/org/bukkit/material/PistonExtensionMaterial.java
deleted file mode 100644
index 8076ec9..0000000
--- a/src/main/java/org/bukkit/material/PistonExtensionMaterial.java
+++ /dev/null
@@ -1,113 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.Material;
-import org.bukkit.block.BlockFace;
-
-/**
- * Material data for the piston extension block
- */
-public class PistonExtensionMaterial extends MaterialData implements Attachable {
-    /**
-     * @param type the raw type id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public PistonExtensionMaterial(final int type) {
-        super(type);
-    }
-
-    public PistonExtensionMaterial(final Material type) {
-        super(type);
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public PistonExtensionMaterial(final int type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * @param type the type
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public PistonExtensionMaterial(final Material type, final byte data) {
-        super(type, data);
-    }
-
-    public void setFacingDirection(BlockFace face) {
-        byte data = (byte) (getData() & 0x8);
-
-        switch (face) {
-        case UP:
-            data |= 1;
-            break;
-        case NORTH:
-            data |= 2;
-            break;
-        case SOUTH:
-            data |= 3;
-            break;
-        case WEST:
-            data |= 4;
-            break;
-        case EAST:
-            data |= 5;
-            break;
-        }
-        setData(data);
-    }
-
-    public BlockFace getFacing() {
-        byte dir = (byte) (getData() & 7);
-
-        switch (dir) {
-        case 0:
-            return BlockFace.DOWN;
-        case 1:
-            return BlockFace.UP;
-        case 2:
-            return BlockFace.NORTH;
-        case 3:
-            return BlockFace.SOUTH;
-        case 4:
-            return BlockFace.WEST;
-        case 5:
-            return BlockFace.EAST;
-        default:
-            return BlockFace.SELF;
-        }
-    }
-
-    /**
-     * Checks if this piston extension is sticky, and returns true if so
-     *
-     * @return true if this piston is "sticky", or false
-     */
-    public boolean isSticky() {
-        return (getData() & 8) == 8;
-    }
-
-    /**
-     * Sets whether or not this extension is sticky
-     *
-     * @param sticky true if sticky, otherwise false
-     */
-    public void setSticky(boolean sticky) {
-        setData((byte) (sticky ? (getData() | 0x8) : (getData() & ~0x8)));
-    }
-
-    public BlockFace getAttachedFace() {
-        return getFacing().getOppositeFace();
-    }
-
-    @Override
-    public PistonExtensionMaterial clone() {
-        return (PistonExtensionMaterial) super.clone();
-    }
-}
diff --git a/src/main/java/org/bukkit/material/PoweredRail.java b/src/main/java/org/bukkit/material/PoweredRail.java
deleted file mode 100644
index 4a9d6a9..0000000
--- a/src/main/java/org/bukkit/material/PoweredRail.java
+++ /dev/null
@@ -1,63 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.Material;
-
-/**
- * Represents a powered rail
- */
-public class PoweredRail extends ExtendedRails implements Redstone {
-    public PoweredRail() {
-        super(Material.POWERED_RAIL);
-    }
-
-    /**
-     * @param type the raw type id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public PoweredRail(final int type) {
-        super(type);
-    }
-
-    public PoweredRail(final Material type) {
-        super(type);
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public PoweredRail(final int type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * @param type the type
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public PoweredRail(final Material type, final byte data) {
-        super(type, data);
-    }
-
-    public boolean isPowered() {
-        return (getData() & 0x8) == 0x8;
-    }
-
-    /**
-     * Set whether this PoweredRail should be powered or not.
-     *
-     * @param isPowered whether or not the rail is powered
-     */
-    public void setPowered(boolean isPowered) {
-        setData((byte) (isPowered ? (getData() | 0x8) : (getData() & ~0x8)));
-    }
-
-    @Override
-    public PoweredRail clone() {
-        return (PoweredRail) super.clone();
-    }
-}
diff --git a/src/main/java/org/bukkit/material/PressurePlate.java b/src/main/java/org/bukkit/material/PressurePlate.java
deleted file mode 100644
index d7747b5..0000000
--- a/src/main/java/org/bukkit/material/PressurePlate.java
+++ /dev/null
@@ -1,59 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.Material;
-
-/**
- * Represents a pressure plate
- */
-public class PressurePlate extends MaterialData implements PressureSensor {
-    public PressurePlate() {
-        super(Material.WOOD_PLATE);
-    }
-
-    /**
-     * @param type the raw type id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public PressurePlate(int type) {
-        super(type);
-    }
-
-    public PressurePlate(Material type) {
-        super(type);
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public PressurePlate(int type, byte data) {
-        super(type, data);
-    }
-
-    /**
-     * @param type the type
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public PressurePlate(Material type, byte data) {
-        super(type, data);
-    }
-
-    public boolean isPressed() {
-        return getData() == 0x1;
-    }
-
-    @Override
-    public String toString() {
-        return super.toString() + (isPressed() ? " PRESSED" : "");
-    }
-
-    @Override
-    public PressurePlate clone() {
-        return (PressurePlate) super.clone();
-    }
-}
diff --git a/src/main/java/org/bukkit/material/PressureSensor.java b/src/main/java/org/bukkit/material/PressureSensor.java
deleted file mode 100644
index de20bd3..0000000
--- a/src/main/java/org/bukkit/material/PressureSensor.java
+++ /dev/null
@@ -1,5 +0,0 @@
-package org.bukkit.material;
-
-public interface PressureSensor {
-    public boolean isPressed();
-}
diff --git a/src/main/java/org/bukkit/material/Pumpkin.java b/src/main/java/org/bukkit/material/Pumpkin.java
deleted file mode 100644
index afd200a..0000000
--- a/src/main/java/org/bukkit/material/Pumpkin.java
+++ /dev/null
@@ -1,114 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.Material;
-import org.bukkit.block.BlockFace;
-
-/**
- * Represents a pumpkin.
- */
-public class Pumpkin extends MaterialData implements Directional {
-
-    public Pumpkin() {
-        super(Material.PUMPKIN);
-    }
-
-    /**
-     * Instantiate a pumpkin facing in a particular direction.
-     *
-     * @param direction the direction the pumkin's face is facing
-     */
-    public Pumpkin(BlockFace direction) {
-        this();
-        setFacingDirection(direction);
-    }
-
-    /**
-     * @param type the raw type id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Pumpkin(final int type) {
-        super(type);
-    }
-
-    public Pumpkin(final Material type) {
-        super(type);
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Pumpkin(final int type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * @param type the type
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Pumpkin(final Material type, final byte data) {
-        super(type, data);
-    }
-
-    public boolean isLit() {
-        return getItemType() == Material.JACK_O_LANTERN;
-    }
-
-    public void setFacingDirection(BlockFace face) {
-        byte data;
-
-        switch (face) {
-        case NORTH:
-            data = 0x0;
-            break;
-
-        case EAST:
-            data = 0x1;
-            break;
-
-        case SOUTH:
-            data = 0x2;
-            break;
-
-        case WEST:
-        default:
-            data = 0x3;
-        }
-
-        setData(data);
-    }
-
-    public BlockFace getFacing() {
-        byte data = getData();
-
-        switch (data) {
-        case 0x0:
-            return BlockFace.NORTH;
-
-        case 0x1:
-            return BlockFace.EAST;
-
-        case 0x2:
-            return BlockFace.SOUTH;
-
-        case 0x3:
-        default:
-            return BlockFace.EAST;
-        }
-    }
-
-    @Override
-    public String toString() {
-        return super.toString() + " facing " + getFacing() + " " + (isLit() ? "" : "NOT ") + "LIT";
-    }
-
-    @Override
-    public Pumpkin clone() {
-        return (Pumpkin) super.clone();
-    }
-}
diff --git a/src/main/java/org/bukkit/material/Rails.java b/src/main/java/org/bukkit/material/Rails.java
deleted file mode 100644
index 10044ee..0000000
--- a/src/main/java/org/bukkit/material/Rails.java
+++ /dev/null
@@ -1,178 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.Material;
-import org.bukkit.block.BlockFace;
-
-/**
- * Represents minecart rails.
- */
-public class Rails extends MaterialData {
-
-    public Rails() {
-        super(Material.RAILS);
-    }
-
-    /**
-     * @param type the raw type id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Rails(final int type) {
-        super(type);
-    }
-
-    public Rails(final Material type) {
-        super(type);
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Rails(final int type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * @param type the type
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Rails(final Material type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * @return the whether this track is set on a slope
-     */
-    public boolean isOnSlope() {
-        byte d = getConvertedData();
-
-        return (d == 0x2 || d == 0x3 || d == 0x4 || d == 0x5);
-    }
-
-    /**
-     * @return the whether this track is set as a curve
-     */
-    public boolean isCurve() {
-        byte d = getConvertedData();
-
-        return (d == 0x6 || d == 0x7 || d == 0x8 || d == 0x9);
-    }
-
-    /**
-     * @return the direction these tracks are set
-     *     <p>
-     *     Note that tracks are bidirectional and that the direction returned
-     *     is the ascending direction if the track is set on a slope. If it is
-     *     set as a curve, the corner of the track is returned.
-     */
-    public BlockFace getDirection() {
-        byte d = getConvertedData();
-
-        switch (d) {
-        case 0x0:
-        default:
-            return BlockFace.SOUTH;
-
-        case 0x1:
-            return BlockFace.EAST;
-
-        case 0x2:
-            return BlockFace.EAST;
-
-        case 0x3:
-            return BlockFace.WEST;
-
-        case 0x4:
-            return BlockFace.NORTH;
-
-        case 0x5:
-            return BlockFace.SOUTH;
-
-        case 0x6:
-            return BlockFace.NORTH_WEST;
-
-        case 0x7:
-            return BlockFace.NORTH_EAST;
-
-        case 0x8:
-            return BlockFace.SOUTH_EAST;
-
-        case 0x9:
-            return BlockFace.SOUTH_WEST;
-        }
-    }
-
-    @Override
-    public String toString() {
-        return super.toString() + " facing " + getDirection() + (isCurve() ? " on a curve" : (isOnSlope() ? " on a slope" : ""));
-    }
-
-    /**
-     * Return the data without the extended properties used by {@link
-     * PoweredRail} and {@link DetectorRail}. Overridden in {@link
-     * ExtendedRails}
-     *
-     * @return the data without the extended part
-     * @deprecated Magic value
-     */
-    @Deprecated
-    protected byte getConvertedData() {
-        return getData();
-    }
-
-    /**
-     * Set the direction of these tracks
-     * <p>
-     * Note that tracks are bidirectional and that the direction returned is
-     * the ascending direction if the track is set on a slope. If it is set as
-     * a curve, the corner of the track should be supplied.
-     *
-     * @param face the direction the track should be facing
-     * @param isOnSlope whether or not the track should be on a slope
-     */
-    public void setDirection(BlockFace face, boolean isOnSlope) {
-        switch (face) {
-        case EAST:
-            setData((byte) (isOnSlope ? 0x2 : 0x1));
-            break;
-
-        case WEST:
-            setData((byte) (isOnSlope ? 0x3 : 0x1));
-            break;
-
-        case NORTH:
-            setData((byte) (isOnSlope ? 0x4 : 0x0));
-            break;
-
-        case SOUTH:
-            setData((byte) (isOnSlope ? 0x5 : 0x0));
-            break;
-
-        case NORTH_WEST:
-            setData((byte) 0x6);
-            break;
-
-        case NORTH_EAST:
-            setData((byte) 0x7);
-            break;
-
-        case SOUTH_EAST:
-            setData((byte) 0x8);
-            break;
-
-        case SOUTH_WEST:
-            setData((byte) 0x9);
-            break;
-        }
-    }
-
-    @Override
-    public Rails clone() {
-        return (Rails) super.clone();
-    }
-}
diff --git a/src/main/java/org/bukkit/material/Redstone.java b/src/main/java/org/bukkit/material/Redstone.java
deleted file mode 100644
index 3e46603..0000000
--- a/src/main/java/org/bukkit/material/Redstone.java
+++ /dev/null
@@ -1,15 +0,0 @@
-package org.bukkit.material;
-
-/**
- * Indicated a Material that may carry or create a Redstone current
- */
-public interface Redstone {
-
-    /**
-     * Gets the current state of this Material, indicating if it's powered or
-     * unpowered
-     *
-     * @return true if powered, otherwise false
-     */
-    public boolean isPowered();
-}
diff --git a/src/main/java/org/bukkit/material/RedstoneTorch.java b/src/main/java/org/bukkit/material/RedstoneTorch.java
deleted file mode 100644
index 45c3e47..0000000
--- a/src/main/java/org/bukkit/material/RedstoneTorch.java
+++ /dev/null
@@ -1,65 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.Material;
-
-/**
- * Represents a redstone torch
- */
-public class RedstoneTorch extends Torch implements Redstone {
-    public RedstoneTorch() {
-        super(Material.REDSTONE_TORCH_ON);
-    }
-
-    /**
-     * @param type the raw type id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public RedstoneTorch(final int type) {
-        super(type);
-    }
-
-    public RedstoneTorch(final Material type) {
-        super(type);
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public RedstoneTorch(final int type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * @param type the type
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public RedstoneTorch(final Material type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * Gets the current state of this Material, indicating if it's powered or
-     * unpowered
-     *
-     * @return true if powered, otherwise false
-     */
-    public boolean isPowered() {
-        return getItemType() == Material.REDSTONE_TORCH_ON;
-    }
-
-    @Override
-    public String toString() {
-        return super.toString() + " " + (isPowered() ? "" : "NOT ") + "POWERED";
-    }
-
-    @Override
-    public RedstoneTorch clone() {
-        return (RedstoneTorch) super.clone();
-    }
-}
diff --git a/src/main/java/org/bukkit/material/RedstoneWire.java b/src/main/java/org/bukkit/material/RedstoneWire.java
deleted file mode 100644
index d13ae4b..0000000
--- a/src/main/java/org/bukkit/material/RedstoneWire.java
+++ /dev/null
@@ -1,65 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.Material;
-
-/**
- * Represents redstone wire
- */
-public class RedstoneWire extends MaterialData implements Redstone {
-    public RedstoneWire() {
-        super(Material.REDSTONE_WIRE);
-    }
-
-    /**
-     * @param type the raw type id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public RedstoneWire(final int type) {
-        super(type);
-    }
-
-    public RedstoneWire(final Material type) {
-        super(type);
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public RedstoneWire(final int type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * @param type the type
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public RedstoneWire(final Material type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * Gets the current state of this Material, indicating if it's powered or
-     * unpowered
-     *
-     * @return true if powered, otherwise false
-     */
-    public boolean isPowered() {
-        return getData() > 0;
-    }
-
-    @Override
-    public String toString() {
-        return super.toString() + " " + (isPowered() ? "" : "NOT ") + "POWERED";
-    }
-
-    @Override
-    public RedstoneWire clone() {
-        return (RedstoneWire) super.clone();
-    }
-}
diff --git a/src/main/java/org/bukkit/material/Sandstone.java b/src/main/java/org/bukkit/material/Sandstone.java
deleted file mode 100644
index be88d43..0000000
--- a/src/main/java/org/bukkit/material/Sandstone.java
+++ /dev/null
@@ -1,79 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.Material;
-import org.bukkit.SandstoneType;
-
-/**
- * Represents the different types of sandstone.
- */
-public class Sandstone extends MaterialData {
-    public Sandstone() {
-        super(Material.SANDSTONE);
-    }
-
-    public Sandstone(SandstoneType type) {
-        this();
-        setType(type);
-    }
-
-    /**
-     * @param type the raw type id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Sandstone(final int type) {
-        super(type);
-    }
-
-    public Sandstone(final Material type) {
-        super(type);
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Sandstone(final int type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * @param type the type
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Sandstone(final Material type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * Gets the current type of this sandstone
-     *
-     * @return SandstoneType of this sandstone
-     */
-    public SandstoneType getType() {
-        return SandstoneType.getByData(getData());
-    }
-
-    /**
-     * Sets the type of this sandstone
-     *
-     * @param type New type of this sandstone
-     */
-    public void setType(SandstoneType type) {
-        setData(type.getData());
-    }
-
-    @Override
-    public String toString() {
-        return getType() + " " + super.toString();
-    }
-
-    @Override
-    public Sandstone clone() {
-        return (Sandstone) super.clone();
-    }
-}
diff --git a/src/main/java/org/bukkit/material/Sapling.java b/src/main/java/org/bukkit/material/Sapling.java
deleted file mode 100644
index 08ef2de..0000000
--- a/src/main/java/org/bukkit/material/Sapling.java
+++ /dev/null
@@ -1,121 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.Material;
-import org.bukkit.TreeSpecies;
-
-/**
- * Represents the different types of Tree block that face a direction.
- *
- * @see Material#SAPLING
- */
-public class Sapling extends Wood {
-
-    /**
-     * Constructs a sapling.
-     */
-    public Sapling() {
-        this(DEFAULT_SPECIES);
-    }
-
-    /**
-     * Constructs a sapling of the given tree species.
-     *
-     * @param species the species of the sapling
-     */
-    public Sapling(TreeSpecies species) {
-        this(species, false);
-    }
-
-    /**
-     * Constructs a sapling of the given tree species and if is it instant
-     * growable
-     *
-     * @param species the species of the tree block
-     * @param isInstantGrowable true if the Sapling should grow when next ticked with bonemeal
-     */
-    public Sapling(TreeSpecies species, boolean isInstantGrowable) {
-        this(Material.SAPLING, species, isInstantGrowable);
-    }
-
-    /**
-     * Constructs a sapling of the given type.
-     *
-     * @param type the type of tree block
-     */
-    public Sapling(final Material type) {
-        this(type, DEFAULT_SPECIES, false);
-    }
-
-    /**
-     * Constructs a sapling of the given type and tree species.
-     *
-     * @param type the type of sapling
-     * @param species the species of the sapling
-     */
-    public Sapling(final Material type, TreeSpecies species) {
-        this(type, species, false);
-    }
-
-    /**
-     * Constructs a sapling of the given type and tree species and if is it
-     * instant growable
-     *
-     * @param type the type of sapling
-     * @param species the species of the sapling
-     * @param isInstantGrowable true if the Sapling should grow when next ticked
-     * with bonemeal
-     */
-    public Sapling(final Material type, TreeSpecies species, boolean isInstantGrowable) {
-        super(type, species);
-        setIsInstantGrowable(isInstantGrowable);
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Sapling(final int type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * @param type the type
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Sapling(final Material type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * Checks if the Sapling would grow when next ticked with bonemeal
-     *
-     * @return true if the Sapling would grow when next ticked with bonemeal
-     */
-    public boolean isInstantGrowable() {
-        return (getData() & 0x8) == 0x8;
-    }
-
-    /**
-     * Set whether this sapling will grow when next ticked with bonemeal
-     *
-     * @param isInstantGrowable true if the Sapling should grow when next ticked
-     * with bonemeal
-     */
-    public void setIsInstantGrowable(boolean isInstantGrowable) {
-        setData(isInstantGrowable ? (byte) ((getData() & 0x7) | 0x8) : (byte) (getData() & 0x7));
-    }
-
-    @Override
-    public String toString() {
-        return getSpecies() + " " + (isInstantGrowable() ? " IS_INSTANT_GROWABLE " : "") + " " + super.toString();
-    }
-
-    @Override
-    public Sapling clone() {
-        return (Sapling) super.clone();
-    }
-}
diff --git a/src/main/java/org/bukkit/material/Sign.java b/src/main/java/org/bukkit/material/Sign.java
deleted file mode 100644
index 0accdbc..0000000
--- a/src/main/java/org/bukkit/material/Sign.java
+++ /dev/null
@@ -1,252 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.block.BlockFace;
-import org.bukkit.Material;
-
-/**
- * MaterialData for signs
- */
-public class Sign extends MaterialData implements Attachable {
-    public Sign() {
-        super(Material.SIGN_POST);
-    }
-
-    /**
-     * @param type the raw type id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Sign(final int type) {
-        super(type);
-    }
-
-    public Sign(final Material type) {
-        super(type);
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Sign(final int type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Sign(final Material type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * Check if this sign is attached to a wall
-     *
-     * @return true if this sign is attached to a wall, false if set on top of
-     *     a block
-     */
-    public boolean isWallSign() {
-        return getItemType() == Material.WALL_SIGN;
-    }
-
-    /**
-     * Gets the face that this block is attached on
-     *
-     * @return BlockFace attached to
-     */
-    public BlockFace getAttachedFace() {
-        if (isWallSign()) {
-            byte data = getData();
-
-            switch (data) {
-            case 0x2:
-                return BlockFace.SOUTH;
-
-            case 0x3:
-                return BlockFace.NORTH;
-
-            case 0x4:
-                return BlockFace.EAST;
-
-            case 0x5:
-                return BlockFace.WEST;
-            }
-
-            return null;
-        } else {
-            return BlockFace.DOWN;
-        }
-    }
-
-    /**
-     * Gets the direction that this sign is currently facing
-     *
-     * @return BlockFace indicating where this sign is facing
-     */
-    public BlockFace getFacing() {
-        byte data = getData();
-
-        if (!isWallSign()) {
-            switch (data) {
-            case 0x0:
-                return BlockFace.SOUTH;
-
-            case 0x1:
-                return BlockFace.SOUTH_SOUTH_WEST;
-
-            case 0x2:
-                return BlockFace.SOUTH_WEST;
-
-            case 0x3:
-                return BlockFace.WEST_SOUTH_WEST;
-
-            case 0x4:
-                return BlockFace.WEST;
-
-            case 0x5:
-                return BlockFace.WEST_NORTH_WEST;
-
-            case 0x6:
-                return BlockFace.NORTH_WEST;
-
-            case 0x7:
-                return BlockFace.NORTH_NORTH_WEST;
-
-            case 0x8:
-                return BlockFace.NORTH;
-
-            case 0x9:
-                return BlockFace.NORTH_NORTH_EAST;
-
-            case 0xA:
-                return BlockFace.NORTH_EAST;
-
-            case 0xB:
-                return BlockFace.EAST_NORTH_EAST;
-
-            case 0xC:
-                return BlockFace.EAST;
-
-            case 0xD:
-                return BlockFace.EAST_SOUTH_EAST;
-
-            case 0xE:
-                return BlockFace.SOUTH_EAST;
-
-            case 0xF:
-                return BlockFace.SOUTH_SOUTH_EAST;
-            }
-
-            return null;
-        } else {
-            return getAttachedFace().getOppositeFace();
-        }
-    }
-
-    public void setFacingDirection(BlockFace face) {
-        byte data;
-
-        if (isWallSign()) {
-            switch (face) {
-            case NORTH:
-                data = 0x2;
-                break;
-
-            case SOUTH:
-                data = 0x3;
-                break;
-
-            case WEST:
-                data = 0x4;
-                break;
-
-            case EAST:
-            default:
-                data = 0x5;
-            }
-        } else {
-            switch (face) {
-            case SOUTH:
-                data = 0x0;
-                break;
-
-            case SOUTH_SOUTH_WEST:
-                data = 0x1;
-                break;
-
-            case SOUTH_WEST:
-                data = 0x2;
-                break;
-
-            case WEST_SOUTH_WEST:
-                data = 0x3;
-                break;
-
-            case WEST:
-                data = 0x4;
-                break;
-
-            case WEST_NORTH_WEST:
-                data = 0x5;
-                break;
-
-            case NORTH_WEST:
-                data = 0x6;
-                break;
-
-            case NORTH_NORTH_WEST:
-                data = 0x7;
-                break;
-
-            case NORTH:
-                data = 0x8;
-                break;
-
-            case NORTH_NORTH_EAST:
-                data = 0x9;
-                break;
-
-            case NORTH_EAST:
-                data = 0xA;
-                break;
-
-            case EAST_NORTH_EAST:
-                data = 0xB;
-                break;
-
-            case EAST:
-                data = 0xC;
-                break;
-
-            case EAST_SOUTH_EAST:
-                data = 0xD;
-                break;
-
-            case SOUTH_SOUTH_EAST:
-                data = 0xF;
-                break;
-
-            case SOUTH_EAST:
-            default:
-                data = 0xE;
-            }
-        }
-
-        setData(data);
-    }
-
-    @Override
-    public String toString() {
-        return super.toString() + " facing " + getFacing();
-    }
-
-    @Override
-    public Sign clone() {
-        return (Sign) super.clone();
-    }
-}
diff --git a/src/main/java/org/bukkit/material/SimpleAttachableMaterialData.java b/src/main/java/org/bukkit/material/SimpleAttachableMaterialData.java
deleted file mode 100644
index b1897b7..0000000
--- a/src/main/java/org/bukkit/material/SimpleAttachableMaterialData.java
+++ /dev/null
@@ -1,68 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.Material;
-import org.bukkit.block.BlockFace;
-
-/**
- * Simple utility class for attachable MaterialData subclasses
- */
-public abstract class SimpleAttachableMaterialData extends MaterialData implements Attachable {
-
-    /**
-     * @param type the raw type id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public SimpleAttachableMaterialData(int type) {
-        super(type);
-    }
-
-    public SimpleAttachableMaterialData(int type, BlockFace direction) {
-        this(type);
-        setFacingDirection(direction);
-    }
-
-    public SimpleAttachableMaterialData(Material type, BlockFace direction) {
-        this(type);
-        setFacingDirection(direction);
-    }
-
-    public SimpleAttachableMaterialData(Material type) {
-        super(type);
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public SimpleAttachableMaterialData(int type, byte data) {
-        super(type, data);
-    }
-
-    /**
-     * @param type the type
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public SimpleAttachableMaterialData(Material type, byte data) {
-        super(type, data);
-    }
-
-    public BlockFace getFacing() {
-        BlockFace attachedFace = getAttachedFace();
-        return attachedFace == null ? null : attachedFace.getOppositeFace();
-    }
-
-    @Override
-    public String toString() {
-        return super.toString() + " facing " + getFacing();
-    }
-
-    @Override
-    public SimpleAttachableMaterialData clone() {
-        return (SimpleAttachableMaterialData) super.clone();
-    }
-}
diff --git a/src/main/java/org/bukkit/material/Skull.java b/src/main/java/org/bukkit/material/Skull.java
deleted file mode 100644
index 659d9e9..0000000
--- a/src/main/java/org/bukkit/material/Skull.java
+++ /dev/null
@@ -1,116 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.Material;
-import org.bukkit.block.BlockFace;
-
-/**
- * Represents a skull.
- */
-public class Skull extends MaterialData implements Directional {
-    public Skull() {
-        super(Material.SKULL);
-    }
-
-    /**
-     * Instantiate a skull facing in a particular direction.
-     *
-     * @param direction the direction the skull's face is facing
-     */
-    public Skull(BlockFace direction) {
-        this();
-        setFacingDirection(direction);
-    }
-
-    /**
-     * @param type the raw type id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Skull(final int type) {
-        super(type);
-    }
-
-    public Skull(final Material type) {
-        super(type);
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Skull(final int type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * @param type the type
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Skull(final Material type, final byte data) {
-        super(type, data);
-    }
-
-    public void setFacingDirection(BlockFace face) {
-        int data;
-
-        switch (face) {
-            case SELF:
-            default:
-                data = 0x1;
-                break;
-
-            case NORTH:
-                data = 0x2;
-                break;
-
-            case EAST:
-                data = 0x4;
-                break;
-
-            case SOUTH:
-                data = 0x3;
-                break;
-
-            case WEST:
-                data = 0x5;
-        }
-
-        setData((byte) data);
-    }
-
-    public BlockFace getFacing() {
-        int data = getData();
-
-        switch (data) {
-            case 0x1:
-            default:
-                return BlockFace.SELF;
-
-            case 0x2:
-                return BlockFace.NORTH;
-
-            case 0x3:
-                return BlockFace.SOUTH;
-
-            case 0x4:
-                return BlockFace.EAST;
-
-            case 0x5:
-                return BlockFace.WEST;
-        }
-    }
-
-    @Override
-    public String toString() {
-        return super.toString() + " facing " + getFacing();
-    }
-
-    @Override
-    public Skull clone() {
-        return (Skull) super.clone();
-    }
-}
diff --git a/src/main/java/org/bukkit/material/SmoothBrick.java b/src/main/java/org/bukkit/material/SmoothBrick.java
deleted file mode 100644
index a6d8931..0000000
--- a/src/main/java/org/bukkit/material/SmoothBrick.java
+++ /dev/null
@@ -1,70 +0,0 @@
-package org.bukkit.material;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import org.bukkit.Material;
-
-/**
- * Represents the different types of smooth bricks.
- */
-public class SmoothBrick extends TexturedMaterial {
-
-    private static final List<Material> textures = new ArrayList<Material>();
-    static {
-        textures.add(Material.STONE);
-        textures.add(Material.MOSSY_COBBLESTONE);
-        textures.add(Material.COBBLESTONE);
-        textures.add(Material.SMOOTH_BRICK);
-    }
-
-    public SmoothBrick() {
-        super(Material.SMOOTH_BRICK);
-    }
-
-    /**
-     * @param type the raw type id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public SmoothBrick(final int type) {
-        super(type);
-    }
-
-    public SmoothBrick(final Material type) {
-        super((textures.contains(type)) ? Material.SMOOTH_BRICK : type);
-        if (textures.contains(type)) {
-            setMaterial(type);
-        }
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public SmoothBrick(final int type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * @param type the type
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public SmoothBrick(final Material type, final byte data) {
-        super(type, data);
-    }
-
-    @Override
-    public List<Material> getTextures() {
-        return textures;
-    }
-
-    @Override
-    public SmoothBrick clone() {
-        return (SmoothBrick) super.clone();
-    }
-}
diff --git a/src/main/java/org/bukkit/material/SpawnEgg.java b/src/main/java/org/bukkit/material/SpawnEgg.java
deleted file mode 100644
index 596d08a..0000000
--- a/src/main/java/org/bukkit/material/SpawnEgg.java
+++ /dev/null
@@ -1,71 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.Material;
-import org.bukkit.entity.EntityType;
-import org.bukkit.inventory.meta.ItemMeta;
-
-/**
- * Represents a spawn egg that can be used to spawn mobs
- */
-public class SpawnEgg extends MaterialData {
-
-    public SpawnEgg() {
-        super(Material.MONSTER_EGG);
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public SpawnEgg(int type, byte data){
-        super(type, data);
-    }
-
-    /**
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public SpawnEgg(byte data) {
-        super(Material.MONSTER_EGG, data);
-    }
-
-    public SpawnEgg(EntityType type) {
-        this();
-        setSpawnedType(type);
-    }
-
-    /**
-     * Get the type of entity this egg will spawn.
-     *
-     * @return The entity type.
-     * @deprecated This is now stored in {@link ItemMeta}. See SPIGOT-1592.
-     */
-    @Deprecated
-    public EntityType getSpawnedType() {
-        return EntityType.fromId(getData());
-    }
-
-    /**
-     * Set the type of entity this egg will spawn.
-     *
-     * @param type The entity type.
-     * @deprecated This is now stored in {@link ItemMeta}. See SPIGOT-1592.
-     */
-    @Deprecated
-    public void setSpawnedType(EntityType type) {
-        setData((byte) type.getTypeId());
-    }
-
-    @Override
-    public String toString() {
-        return "SPAWN EGG{" + getSpawnedType() + "}";
-    }
-
-    @Override
-    public SpawnEgg clone() {
-        return (SpawnEgg) super.clone();
-    }
-}
diff --git a/src/main/java/org/bukkit/material/Stairs.java b/src/main/java/org/bukkit/material/Stairs.java
deleted file mode 100644
index 7dde021..0000000
--- a/src/main/java/org/bukkit/material/Stairs.java
+++ /dev/null
@@ -1,140 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.Material;
-import org.bukkit.block.BlockFace;
-
-/**
- * Represents stairs.
- */
-public class Stairs extends MaterialData implements Directional {
-
-    /**
-     * @param type the raw type id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Stairs(final int type) {
-        super(type);
-    }
-
-    public Stairs(final Material type) {
-        super(type);
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Stairs(final int type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * @param type the type
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Stairs(final Material type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * @return the direction the stairs ascend towards
-     */
-    public BlockFace getAscendingDirection() {
-        byte data = getData();
-
-        switch (data & 0x3) {
-        case 0x0:
-        default:
-            return BlockFace.EAST;
-
-        case 0x1:
-            return BlockFace.WEST;
-
-        case 0x2:
-            return BlockFace.SOUTH;
-
-        case 0x3:
-            return BlockFace.NORTH;
-        }
-    }
-
-    /**
-     * @return the direction the stairs descend towards
-     */
-    public BlockFace getDescendingDirection() {
-        return getAscendingDirection().getOppositeFace();
-    }
-
-    /**
-     * Set the direction the stair part of the block is facing
-     */
-    public void setFacingDirection(BlockFace face) {
-        byte data;
-
-        switch (face) {
-        case NORTH:
-            data = 0x3;
-            break;
-
-        case SOUTH:
-            data = 0x2;
-            break;
-
-        case EAST:
-        default:
-            data = 0x0;
-            break;
-
-        case WEST:
-            data = 0x1;
-            break;
-        }
-
-        setData((byte) ((getData() & 0xC) | data));
-    }
-
-    /**
-     * @return the direction the stair part of the block is facing
-     */
-    public BlockFace getFacing() {
-        return getDescendingDirection();
-    }
-
-    /**
-     * Test if step is inverted
-     *
-     * @return true if inverted (top half), false if normal (bottom half)
-     */
-    public boolean isInverted() {
-        return ((getData() & 0x4) != 0);
-    }
-
-    /**
-     * Set step inverted state
-     *
-     * @param inv - true if step is inverted (top half), false if step is
-     *     normal (bottom half)
-     */
-    public void setInverted(boolean inv) {
-        int dat = getData() & 0x3;
-        if (inv) {
-            dat |= 0x4;
-        }
-        setData((byte) dat);
-    }
-
-    @Override
-    public String toString() {
-        return super.toString() + " facing " + getFacing() + (isInverted()?" inverted":"");
-    }
-
-    @Override
-    public Stairs clone() {
-        return (Stairs) super.clone();
-    }
-}
diff --git a/src/main/java/org/bukkit/material/Step.java b/src/main/java/org/bukkit/material/Step.java
deleted file mode 100644
index c2ccfce..0000000
--- a/src/main/java/org/bukkit/material/Step.java
+++ /dev/null
@@ -1,121 +0,0 @@
-package org.bukkit.material;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import org.bukkit.Material;
-
-/**
- * Represents the different types of steps.
- */
-public class Step extends TexturedMaterial {
-    private static final List<Material> textures = new ArrayList<Material>();
-    static {
-        textures.add(Material.STONE);
-        textures.add(Material.SANDSTONE);
-        textures.add(Material.WOOD);
-        textures.add(Material.COBBLESTONE);
-        textures.add(Material.BRICK);
-        textures.add(Material.SMOOTH_BRICK);
-        textures.add(Material.NETHER_BRICK);
-        textures.add(Material.QUARTZ_BLOCK);
-    }
-
-    public Step() {
-        super(Material.STEP);
-    }
-
-    /**
-     * @param type the raw type id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Step(final int type) {
-        super(type);
-    }
-
-    public Step(final Material type) {
-        super((textures.contains(type)) ? Material.STEP : type);
-        if (textures.contains(type)) {
-            setMaterial(type);
-        }
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Step(final int type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * @param type the type
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Step(final Material type, final byte data) {
-        super(type, data);
-    }
-
-    @Override
-    public List<Material> getTextures() {
-        return textures;
-    }
-
-    /**
-     * Test if step is inverted
-     *
-     * @return true if inverted (top half), false if normal (bottom half)
-     */
-    public boolean isInverted() {
-        return ((getData() & 0x8) != 0);
-    }
-
-    /**
-     * Set step inverted state
-     *
-     * @param inv - true if step is inverted (top half), false if step is
-     *     normal (bottom half)
-     */
-    public void setInverted(boolean inv) {
-        int dat = getData() & 0x7;
-        if (inv) {
-            dat |= 0x8;
-        }
-        setData((byte) dat);
-    }
-
-    /**
-     *
-     * @deprecated Magic value
-     */
-    @Deprecated
-    @Override
-    protected int getTextureIndex() {
-        return getData() & 0x7;
-    }
-
-    /**
-     *
-     * @deprecated Magic value
-     */
-    @Deprecated
-    @Override
-    protected void setTextureIndex(int idx) {
-        setData((byte) ((getData() & 0x8) | idx));
-    }
-
-    @Override
-    public Step clone() {
-        return (Step) super.clone();
-    }
-
-    @Override
-    public String toString() {
-        return super.toString() + (isInverted()?"inverted":"");
-    }
-}
diff --git a/src/main/java/org/bukkit/material/TexturedMaterial.java b/src/main/java/org/bukkit/material/TexturedMaterial.java
deleted file mode 100644
index d1b85e2..0000000
--- a/src/main/java/org/bukkit/material/TexturedMaterial.java
+++ /dev/null
@@ -1,112 +0,0 @@
-package org.bukkit.material;
-
-import java.util.List;
-
-import org.bukkit.Material;
-
-/**
- * Represents textured materials like steps and smooth bricks
- */
-public abstract class TexturedMaterial extends MaterialData {
-
-    public TexturedMaterial(Material m) {
-        super(m);
-    }
-
-    /**
-     * @param type the raw type id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public TexturedMaterial(int type) {
-        super(type);
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public TexturedMaterial(final int type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * @param type the type
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public TexturedMaterial(final Material type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * Retrieve a list of possible textures. The first element of the list
-     * will be used as a default.
-     *
-     * @return a list of possible textures for this block
-     */
-    public abstract List<Material> getTextures();
-
-    /**
-     * Gets the current Material this block is made of
-     *
-     * @return Material of this block
-     */
-    public Material getMaterial() {
-        int n = getTextureIndex();
-        if (n > getTextures().size() - 1) {
-            n = 0;
-        }
-
-        return getTextures().get(n);
-    }
-
-    /**
-     * Sets the material this block is made of
-     *
-     * @param material
-     *            New material of this block
-     */
-    public void setMaterial(Material material) {
-        if (getTextures().contains(material)) {
-            setTextureIndex(getTextures().indexOf(material));
-        } else {
-            setTextureIndex(0x0);
-        }
-    }
-
-    /**
-     * Get material index from data
-     *
-     * @return index of data in textures list
-     * @deprecated Magic value
-     */
-    @Deprecated
-    protected int getTextureIndex() {
-        return getData(); // Default to using all bits - override for other mappings
-    }
-
-    /**
-     * Set material index
-     *
-     * @param idx - index of data in textures list
-     * @deprecated Magic value
-     */
-    @Deprecated
-    protected void setTextureIndex(int idx) {
-        setData((byte) idx); // Defult to using all bits - override for other mappings
-    }
-
-    @Override
-    public String toString() {
-        return getMaterial() + " " + super.toString();
-    }
-
-    @Override
-    public TexturedMaterial clone() {
-        return (TexturedMaterial) super.clone();
-    }
-}
diff --git a/src/main/java/org/bukkit/material/Torch.java b/src/main/java/org/bukkit/material/Torch.java
deleted file mode 100644
index 60be6bd..0000000
--- a/src/main/java/org/bukkit/material/Torch.java
+++ /dev/null
@@ -1,106 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.block.BlockFace;
-import org.bukkit.Material;
-
-/**
- * MaterialData for torches
- */
-public class Torch extends SimpleAttachableMaterialData {
-    public Torch() {
-        super(Material.TORCH);
-    }
-
-    /**
-     * @param type the raw type id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Torch(final int type) {
-        super(type);
-    }
-
-    public Torch(final Material type) {
-        super(type);
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Torch(final int type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * @param type the type
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Torch(final Material type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * Gets the face that this block is attached on
-     *
-     * @return BlockFace attached to
-     */
-    public BlockFace getAttachedFace() {
-        byte data = getData();
-
-        switch (data) {
-        case 0x1:
-            return BlockFace.WEST;
-
-        case 0x2:
-            return BlockFace.EAST;
-
-        case 0x3:
-            return BlockFace.NORTH;
-
-        case 0x4:
-            return BlockFace.SOUTH;
-
-        case 0x5:
-        default:
-            return BlockFace.DOWN;
-        }
-    }
-
-    public void setFacingDirection(BlockFace face) {
-        byte data;
-
-        switch (face) {
-        case EAST:
-            data = 0x1;
-            break;
-
-        case WEST:
-            data = 0x2;
-            break;
-
-        case SOUTH:
-            data = 0x3;
-            break;
-
-        case NORTH:
-            data = 0x4;
-            break;
-
-        case UP:
-        default:
-            data = 0x5;
-        }
-
-        setData(data);
-    }
-
-    @Override
-    public Torch clone() {
-        return (Torch) super.clone();
-    }
-}
diff --git a/src/main/java/org/bukkit/material/TrapDoor.java b/src/main/java/org/bukkit/material/TrapDoor.java
deleted file mode 100644
index 2ae3362..0000000
--- a/src/main/java/org/bukkit/material/TrapDoor.java
+++ /dev/null
@@ -1,133 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.Material;
-import org.bukkit.block.BlockFace;
-
-/**
- * Represents a trap door
- */
-public class TrapDoor extends SimpleAttachableMaterialData implements Openable {
-    public TrapDoor() {
-        super(Material.TRAP_DOOR);
-    }
-
-    /**
-     * @param type the raw type id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public TrapDoor(final int type) {
-        super(type);
-    }
-
-    public TrapDoor(final Material type) {
-        super(type);
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public TrapDoor(final int type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * @param type the type
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public TrapDoor(final Material type, final byte data) {
-        super(type, data);
-    }
-
-    public boolean isOpen() {
-        return ((getData() & 0x4) == 0x4);
-    }
-
-    public void setOpen(boolean isOpen) {
-        byte data = getData();
-
-        if (isOpen) {
-            data |= 0x4;
-        } else {
-            data &= ~0x4;
-        }
-
-        setData(data);
-    }
-
-    /**
-     * Test if trapdoor is inverted
-     *
-     * @return true if inverted (top half), false if normal (bottom half)
-     */
-    public boolean isInverted() {
-        return ((getData() & 0x8) != 0);
-    }
-
-    /**
-     * Set trapdoor inverted state
-     *
-     * @param inv - true if inverted (top half), false if normal (bottom half)
-     */
-    public void setInverted(boolean inv) {
-        int dat = getData() & 0x7;
-        if (inv) {
-            dat |= 0x8;
-        }
-        setData((byte) dat);
-    }
-
-    public BlockFace getAttachedFace() {
-        byte data = (byte) (getData() & 0x3);
-
-        switch (data) {
-            case 0x0:
-                return BlockFace.SOUTH;
-
-            case 0x1:
-                return BlockFace.NORTH;
-
-            case 0x2:
-                return BlockFace.EAST;
-
-            case 0x3:
-                return BlockFace.WEST;
-        }
-
-        return null;
-
-    }
-
-    public void setFacingDirection(BlockFace face) {
-        byte data = (byte) (getData() & 0xC);
-
-        switch (face) {
-            case SOUTH:
-                data |= 0x1;
-                break;
-            case WEST:
-                data |= 0x2;
-                break;
-            case EAST:
-                data |= 0x3;
-                break;
-        }
-
-        setData(data);
-    }
-
-    @Override
-    public String toString() {
-        return (isOpen() ? "OPEN " : "CLOSED ") + super.toString() + " with hinges set " + getAttachedFace() + (isInverted() ? " inverted" : "");
-    }
-
-    @Override
-    public TrapDoor clone() {
-        return (TrapDoor) super.clone();
-    }
-}
diff --git a/src/main/java/org/bukkit/material/Tree.java b/src/main/java/org/bukkit/material/Tree.java
deleted file mode 100644
index e28499d..0000000
--- a/src/main/java/org/bukkit/material/Tree.java
+++ /dev/null
@@ -1,169 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.Material;
-import org.bukkit.TreeSpecies;
-import org.bukkit.block.BlockFace;
-
-/**
- * Represents the different types of Tree block that face a direction.
- *
- * @see Material#LOG
- * @see Material#LOG_2
- */
-public class Tree extends Wood {
-    protected static final Material DEFAULT_TYPE = Material.LOG;
-    protected static final BlockFace DEFAULT_DIRECTION = BlockFace.UP;
-
-    /**
-     * Constructs a tree block.
-     */
-    public Tree() {
-        this(DEFAULT_TYPE, DEFAULT_SPECIES, DEFAULT_DIRECTION);
-    }
-
-    /**
-     * Constructs a tree block of the given tree species.
-     *
-     * @param species the species of the tree block
-     */
-    public Tree(TreeSpecies species) {
-        this(DEFAULT_TYPE, species, DEFAULT_DIRECTION);
-    }
-
-    /**
-     * Constructs a tree block of the given tree species, and facing the given
-     * direction.
-     *
-     * @param species the species of the tree block
-     * @param dir the direction the tree block is facing
-     */
-    public Tree(TreeSpecies species, BlockFace dir) {
-        this(DEFAULT_TYPE, species, dir);
-    }
-
-    /**
-     * @param type the raw type id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Tree(final int type) {
-        super(type);
-    }
-
-    /**
-     * Constructs a tree block of the given type.
-     *
-     * @param type the type of tree block
-     */
-    public Tree(final Material type) {
-        this(type, DEFAULT_SPECIES, DEFAULT_DIRECTION);
-    }
-
-    /**
-     * Constructs a tree block of the given type and tree species.
-     *
-     * @param type the type of tree block
-     * @param species the species of the tree block
-     */
-    public Tree(final Material type, TreeSpecies species) {
-        this(type, species, DEFAULT_DIRECTION);
-    }
-
-    /**
-     * Constructs a tree block of the given type and tree species, and facing
-     * the given direction.
-     *
-     * @param type the type of tree block
-     * @param species the species of the tree block
-     * @param dir the direction the tree block is facing
-     */
-    public Tree(final Material type, TreeSpecies species, BlockFace dir) {
-        super(type, species);
-        setDirection(dir);
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Tree(final int type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * @param type the type
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Tree(final Material type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * Get direction of the log
-     *
-     * @return one of:
-     * <ul>
-     * <li>BlockFace.TOP for upright (default)
-     * <li>BlockFace.NORTH (east-west)
-     * <li>BlockFace.WEST (north-south)
-     * <li>BlockFace.SELF (directionless)
-     * </ul>
-     */
-    @SuppressWarnings("deprecation")
-    public BlockFace getDirection() {
-        switch ((getData() >> 2) & 0x3) {
-            case 0: // Up-down
-            default:
-                return BlockFace.UP;
-            case 1: // North-south
-                return BlockFace.WEST;
-            case 2: // East-west
-                return BlockFace.NORTH;
-            case 3: // Directionless (bark on all sides)
-                return BlockFace.SELF;
-        }
-    }
-
-    /**
-     * Set direction of the log
-     *
-     * @param dir - direction of end of log (BlockFace.SELF for no direction)
-     */
-    @SuppressWarnings("deprecation")
-    public void setDirection(BlockFace dir) {
-        int dat;
-        switch (dir) {
-            case UP:
-            case DOWN:
-            default:
-                dat = 0;
-                break;
-            case WEST:
-            case EAST:
-                dat = 4; // 1<<2
-                break;
-            case NORTH:
-            case SOUTH:
-                dat = 8; // 2<<2
-                break;
-            case SELF:
-                dat = 12; // 3<<2
-                break;
-        }
-        setData((byte) ((getData() & 0x3) | dat));
-    }
-
-    @Override
-    public String toString() {
-        return getSpecies() + " " + getDirection() + " " + super.toString();
-    }
-
-    @Override
-    public Tree clone() {
-        return (Tree) super.clone();
-    }
-}
diff --git a/src/main/java/org/bukkit/material/Tripwire.java b/src/main/java/org/bukkit/material/Tripwire.java
deleted file mode 100644
index 570635d..0000000
--- a/src/main/java/org/bukkit/material/Tripwire.java
+++ /dev/null
@@ -1,86 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.Material;
-
-/**
- * Represents the tripwire
- */
-public class Tripwire extends MaterialData {
-    
-    public Tripwire() {
-        super(Material.TRIPWIRE);
-    }
-
-    /**
-     * @param type the raw type id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Tripwire(final int type) {
-        super(type);
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Tripwire(final int type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * Test if tripwire is currently activated
-     *
-     * @return true if activated, false if not
-     */
-    public boolean isActivated() {
-        return (getData() & 0x4) != 0;
-    }
-    
-    /**
-     * Set tripwire activated state
-     *
-     * @param act - true if activated, false if not
-     */
-    public void setActivated(boolean act) {
-        int dat = getData() & (0x8 | 0x3);
-        if (act) {
-            dat |= 0x4;
-        }
-        setData((byte) dat);
-    }    
-    
-    /**
-     * Test if object triggering this tripwire directly
-     *
-     * @return true if object activating tripwire, false if not
-     */
-    public boolean isObjectTriggering() {
-        return (getData() & 0x1) != 0;
-    }
-
-    /**
-     * Set object triggering state for this tripwire
-     *
-     * @param trig - true if object activating tripwire, false if not
-     */
-    public void setObjectTriggering(boolean trig) {
-        int dat = getData() & 0xE;
-        if (trig) {
-            dat |= 0x1;
-        }
-        setData((byte) dat);
-    }
-
-    @Override
-    public Tripwire clone() {
-        return (Tripwire) super.clone();
-    }
-
-    @Override
-    public String toString() {
-        return super.toString() + (isActivated()?" Activated":"") + (isObjectTriggering()?" Triggered":"");
-    }
-}
diff --git a/src/main/java/org/bukkit/material/TripwireHook.java b/src/main/java/org/bukkit/material/TripwireHook.java
deleted file mode 100644
index 8ff23e9..0000000
--- a/src/main/java/org/bukkit/material/TripwireHook.java
+++ /dev/null
@@ -1,129 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.Material;
-import org.bukkit.block.BlockFace;
-
-/**
- * Represents the tripwire hook
- */
-public class TripwireHook extends SimpleAttachableMaterialData implements Redstone {
-
-    public TripwireHook() {
-        super(Material.TRIPWIRE_HOOK);
-    }
-
-    /**
-     * @param type the raw type id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public TripwireHook(final int type) {
-        super(type);
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public TripwireHook(final int type, final byte data) {
-        super(type, data);
-    }
-
-    public TripwireHook(BlockFace dir) {
-        this();
-        setFacingDirection(dir);
-    }
-
-    /**
-     * Test if tripwire is connected
-     *
-     * @return true if connected, false if not
-     */
-    public boolean isConnected() {
-        return (getData() & 0x4) != 0;
-    }
-
-    /**
-     * Set tripwire connection state
-     *
-     * @param connected - true if connected, false if not
-     */
-    public void setConnected(boolean connected) {
-        int dat = getData() & (0x8 | 0x3);
-        if (connected) {
-            dat |= 0x4;
-        }
-        setData((byte) dat);
-    }
-
-    /**
-     * Test if hook is currently activated
-     *
-     * @return true if activated, false if not
-     */
-    public boolean isActivated() {
-        return (getData() & 0x8) != 0;
-    }
-
-    /**
-     * Set hook activated state
-     *
-     * @param act - true if activated, false if not
-     */
-    public void setActivated(boolean act) {
-        int dat = getData() & (0x4 | 0x3);
-        if (act) {
-            dat |= 0x8;
-        }
-        setData((byte) dat);
-    }
-
-    public void setFacingDirection(BlockFace face) {
-        int dat = getData() & 0xC;
-        switch (face) {
-        case WEST:
-            dat |= 0x1;
-            break;
-        case NORTH:
-            dat |= 0x2;
-            break;
-        case EAST:
-            dat |= 0x3;
-            break;
-        case SOUTH:
-        default:
-            break;
-        }
-        setData((byte) dat);
-    }
-
-    public BlockFace getAttachedFace() {
-        switch (getData() & 0x3) {
-        case 0:
-            return BlockFace.NORTH;
-        case 1:
-            return BlockFace.EAST;
-        case 2:
-            return BlockFace.SOUTH;
-        case 3:
-            return BlockFace.WEST;
-        }
-        return null;
-    }
-
-    public boolean isPowered() {
-        return isActivated();
-    }
-
-    @Override
-    public TripwireHook clone() {
-        return (TripwireHook) super.clone();
-    }
-
-    @Override
-    public String toString() {
-        return super.toString() + " facing " + getFacing() + (isActivated()?" Activated":"") + (isConnected()?" Connected":"");
-    }
-}
diff --git a/src/main/java/org/bukkit/material/Vine.java b/src/main/java/org/bukkit/material/Vine.java
deleted file mode 100644
index 5a09667..0000000
--- a/src/main/java/org/bukkit/material/Vine.java
+++ /dev/null
@@ -1,197 +0,0 @@
-package org.bukkit.material;
-
-import java.util.Arrays;
-import java.util.EnumSet;
-
-import org.bukkit.Material;
-import org.bukkit.block.BlockFace;
-
-/**
- * Represents a vine
- */
-public class Vine extends MaterialData {
-    private static final int VINE_NORTH = 0x4;
-    private static final int VINE_EAST = 0x8;
-    private static final int VINE_WEST = 0x2;
-    private static final int VINE_SOUTH = 0x1;
-    EnumSet<BlockFace> possibleFaces = EnumSet.of(BlockFace.WEST, BlockFace.NORTH, BlockFace.SOUTH, BlockFace.EAST);
-
-    public Vine() {
-        super(Material.VINE);
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Vine(int type, byte data){
-        super(type, data);
-    }
-
-    /**
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Vine(byte data) {
-        super(Material.VINE, data);
-    }
-
-    public Vine(BlockFace... faces) {
-        this(EnumSet.copyOf(Arrays.asList(faces)));
-    }
-
-    public Vine(EnumSet<BlockFace> faces) {
-        this((byte) 0);
-        faces.retainAll(possibleFaces);
-
-        byte data = 0;
-
-        if (faces.contains(BlockFace.WEST)) {
-            data |= VINE_WEST;
-        }
-
-        if (faces.contains(BlockFace.NORTH)) {
-            data |= VINE_NORTH;
-        }
-
-        if (faces.contains(BlockFace.SOUTH)) {
-            data |= VINE_SOUTH;
-        }
-
-        if (faces.contains(BlockFace.EAST)) {
-            data |= VINE_EAST;
-        }
-
-        setData(data);
-    }
-
-    /**
-     * Check if the vine is attached to the specified face of an adjacent
-     * block. You can check two faces at once by passing e.g. {@link
-     * BlockFace#NORTH_EAST}.
-     *
-     * @param face The face to check.
-     * @return Whether it is attached to that face.
-     */
-    public boolean isOnFace(BlockFace face) {
-        switch (face) {
-            case WEST:
-                return (getData() & VINE_WEST) == VINE_WEST;
-            case NORTH:
-                return (getData() & VINE_NORTH) == VINE_NORTH;
-            case SOUTH:
-                return (getData() & VINE_SOUTH) == VINE_SOUTH;
-            case EAST:
-                return (getData() & VINE_EAST) == VINE_EAST;
-            case NORTH_EAST:
-                return isOnFace(BlockFace.EAST) && isOnFace(BlockFace.NORTH);
-            case NORTH_WEST:
-                return isOnFace(BlockFace.WEST) && isOnFace(BlockFace.NORTH);
-            case SOUTH_EAST:
-                return isOnFace(BlockFace.EAST) && isOnFace(BlockFace.SOUTH);
-            case SOUTH_WEST:
-                return isOnFace(BlockFace.WEST) && isOnFace(BlockFace.SOUTH);
-            case UP: // It's impossible to be accurate with this since it's contextual
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    /**
-     * Attach the vine to the specified face of an adjacent block.
-     *
-     * @param face The face to attach.
-     */
-    public void putOnFace(BlockFace face) {
-        switch(face) {
-            case WEST:
-                setData((byte) (getData() | VINE_WEST));
-                break;
-            case NORTH:
-                setData((byte) (getData() | VINE_NORTH));
-                break;
-            case SOUTH:
-                setData((byte) (getData() | VINE_SOUTH));
-                break;
-            case EAST:
-                setData((byte) (getData() | VINE_EAST));
-                break;
-            case NORTH_WEST:
-                putOnFace(BlockFace.WEST);
-                putOnFace(BlockFace.NORTH);
-                break;
-            case SOUTH_WEST:
-                putOnFace(BlockFace.WEST);
-                putOnFace(BlockFace.SOUTH);
-                break;
-            case NORTH_EAST:
-                putOnFace(BlockFace.EAST);
-                putOnFace(BlockFace.NORTH);
-                break;
-            case SOUTH_EAST:
-                putOnFace(BlockFace.EAST);
-                putOnFace(BlockFace.SOUTH);
-                break;
-            case UP:
-                break;
-            default:
-                throw new IllegalArgumentException("Vines can't go on face " + face.toString());
-        }
-    }
-
-    /**
-     * Detach the vine from the specified face of an adjacent block.
-     *
-     * @param face The face to detach.
-     */
-    public void removeFromFace(BlockFace face) {
-        switch(face) {
-            case WEST:
-                setData((byte) (getData() & ~VINE_WEST));
-                break;
-            case NORTH:
-                setData((byte) (getData() & ~VINE_NORTH));
-                break;
-            case SOUTH:
-                setData((byte) (getData() & ~VINE_SOUTH));
-                break;
-            case EAST:
-                setData((byte) (getData() & ~VINE_EAST));
-                break;
-            case NORTH_WEST:
-                removeFromFace(BlockFace.WEST);
-                removeFromFace(BlockFace.NORTH);
-                break;
-            case SOUTH_WEST:
-                removeFromFace(BlockFace.WEST);
-                removeFromFace(BlockFace.SOUTH);
-                break;
-            case NORTH_EAST:
-                removeFromFace(BlockFace.EAST);
-                removeFromFace(BlockFace.NORTH);
-                break;
-            case SOUTH_EAST:
-                removeFromFace(BlockFace.EAST);
-                removeFromFace(BlockFace.SOUTH);
-                break;
-            case UP:
-                break;
-            default:
-                throw new IllegalArgumentException("Vines can't go on face " + face.toString());
-        }
-    }
-
-    @Override
-    public String toString() {
-        return "VINE";
-    }
-
-    @Override
-    public Vine clone() {
-        return (Vine) super.clone();
-    }
-}
diff --git a/src/main/java/org/bukkit/material/Wood.java b/src/main/java/org/bukkit/material/Wood.java
deleted file mode 100644
index 794cfd4..0000000
--- a/src/main/java/org/bukkit/material/Wood.java
+++ /dev/null
@@ -1,196 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.Material;
-import org.bukkit.TreeSpecies;
-
-/**
- * Represents wood blocks of different species.
- *
- * @see Material#WOOD
- * @see Material#SAPLING
- * @see Material#WOOD_DOUBLE_STEP
- */
-public class Wood extends MaterialData {
-    protected static final Material DEFAULT_TYPE = Material.WOOD;
-    protected static final TreeSpecies DEFAULT_SPECIES = TreeSpecies.GENERIC;
-
-    /**
-     * Constructs a wood block.
-     */
-    public Wood() {
-        this(DEFAULT_TYPE, DEFAULT_SPECIES);
-    }
-
-    /**
-     * Constructs a wood block of the given tree species.
-     * 
-     * @param species the species of the wood block
-     */
-    public Wood(TreeSpecies species) {
-        this(DEFAULT_TYPE, species);
-    }
-
-    /**
-     * @param type the raw type id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Wood(final int type) {
-        super(type);
-    }
-
-    /**
-     * Constructs a wood block of the given type.
-     *
-     * @param type the type of wood block
-     */
-    public Wood(final Material type) {
-        this(type, DEFAULT_SPECIES);
-    }
-
-    /**
-     * Constructs a wood block of the given type and tree species.
-     *
-     * @param type the type of wood block
-     * @param species the species of the wood block
-     */
-    public Wood(final Material type, final TreeSpecies species) {
-        // Ensure only valid species-type combinations
-        super(getSpeciesType(type, species));
-        setSpecies(species);
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Wood(final int type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * @param type the type
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Wood(final Material type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * Gets the current species of this wood block
-     *
-     * @return TreeSpecies of this wood block
-     */
-    public TreeSpecies getSpecies() {
-        switch (getItemType()) {
-            case WOOD:
-            case WOOD_DOUBLE_STEP:
-                return TreeSpecies.getByData((byte) getData());
-            case LOG:
-            case LEAVES:
-                return TreeSpecies.getByData((byte) (getData() & 0x3));
-            case LOG_2:
-            case LEAVES_2:
-                return TreeSpecies.getByData((byte) ((getData() & 0x3) | 0x4));
-            case SAPLING:
-            case WOOD_STEP:
-                return TreeSpecies.getByData((byte) (getData() & 0x7));
-            default:
-                throw new IllegalArgumentException("Invalid block type for tree species");
-        }
-    }
-
-    /**
-     * Correct the block type for certain species-type combinations.
-     *
-     * @param type The desired type
-     * @param species The required species
-     * @return The actual type for this species given the desired type
-     */
-    private static Material getSpeciesType(Material type, TreeSpecies species) {
-        switch (species) {
-            case GENERIC:
-            case REDWOOD:
-            case BIRCH:
-            case JUNGLE:
-                switch (type) {
-                    case LOG_2:
-                        return Material.LOG;
-                    case LEAVES_2:
-                        return Material.LEAVES;
-                    default:
-                }
-                break;
-            case ACACIA:
-            case DARK_OAK:
-                switch (type) {
-                    case LOG:
-                        return Material.LOG_2;
-                    case LEAVES:
-                        return Material.LEAVES_2;
-                    default:
-                }
-                break;
-        }
-        return type;
-    }
-
-    /**
-     * Sets the species of this wood block
-     *
-     * @param species New species of this wood block
-     */
-    public void setSpecies(final TreeSpecies species) {
-        boolean firstType = false;
-        switch (getItemType()) {
-            case WOOD:
-            case WOOD_DOUBLE_STEP:
-                setData(species.getData());
-                break;
-            case LOG:
-            case LEAVES:
-                firstType = true;
-            // fall through to next switch statement below
-            case LOG_2:
-            case LEAVES_2:
-                switch (species) {
-                    case GENERIC:
-                    case REDWOOD:
-                    case BIRCH:
-                    case JUNGLE:
-                        if (!firstType) {
-                            throw new IllegalArgumentException("Invalid tree species for block type, use block type 2 instead");
-                        }
-                        break;
-                    case ACACIA:
-                    case DARK_OAK:
-                        if (firstType) {
-                            throw new IllegalArgumentException("Invalid tree species for block type 2, use block type instead");
-                        }
-                        break;
-                }
-                setData((byte) ((getData() & 0xC) | (species.getData() & 0x3)));
-                break;
-            case SAPLING:
-            case WOOD_STEP:
-                setData((byte) ((getData() & 0x8) | species.getData()));
-                break;
-            default:
-                throw new IllegalArgumentException("Invalid block type for tree species");
-        }
-    }
-
-    @Override
-    public String toString() {
-        return getSpecies() + " " + super.toString();
-    }
-
-    @Override
-    public Wood clone() {
-        return (Wood) super.clone();
-    }
-}
diff --git a/src/main/java/org/bukkit/material/WoodenStep.java b/src/main/java/org/bukkit/material/WoodenStep.java
deleted file mode 100644
index 17b7050..0000000
--- a/src/main/java/org/bukkit/material/WoodenStep.java
+++ /dev/null
@@ -1,106 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.Material;
-import org.bukkit.TreeSpecies;
-
-/**
- * Represents the different types of wooden steps.
- *
- * @see Material#WOOD_STEP
- */
-public class WoodenStep extends Wood {
-    protected static final Material DEFAULT_TYPE = Material.WOOD_STEP;
-    protected static final boolean DEFAULT_INVERTED = false;
-
-    /**
-     * Constructs a wooden step.
-     */
-    public WoodenStep() {
-        this(DEFAULT_SPECIES, DEFAULT_INVERTED);
-    }
-
-    /**
-     * Constructs a wooden step of the given tree species.
-     *
-     * @param species the species of the wooden step
-     */
-    public WoodenStep(TreeSpecies species) {
-        this(species, DEFAULT_INVERTED);
-    }
-
-    /**
-     * Constructs a wooden step of the given type and tree species, either
-     * inverted or not.
-     *
-     * @param species the species of the wooden step
-     * @param inv true the step is at the top of the block
-     */
-    public WoodenStep(final TreeSpecies species, boolean inv) {
-        super(DEFAULT_TYPE, species);
-        setInverted(inv);
-    }
-
-    /**
-     * @param type the raw type id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public WoodenStep(final int type) {
-        super(type);
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public WoodenStep(final int type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * @param type the type
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public WoodenStep(final Material type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * Test if step is inverted
-     *
-     * @return true if inverted (top half), false if normal (bottom half)
-     */
-    @SuppressWarnings("deprecation")
-    public boolean isInverted() {
-        return ((getData() & 0x8) != 0);
-    }
-
-    /**
-     * Set step inverted state
-     *
-     * @param inv - true if step is inverted (top half), false if step is normal
-     * (bottom half)
-     */
-    @SuppressWarnings("deprecation")
-    public void setInverted(boolean inv) {
-        int dat = getData() & 0x7;
-        if (inv) {
-            dat |= 0x8;
-        }
-        setData((byte) dat);
-    }
-
-    @Override
-    public WoodenStep clone() {
-        return (WoodenStep) super.clone();
-    }
-
-    @Override
-    public String toString() {
-        return super.toString() + " " + getSpecies() + (isInverted() ? " inverted" : "");
-    }
-}
diff --git a/src/main/java/org/bukkit/material/Wool.java b/src/main/java/org/bukkit/material/Wool.java
deleted file mode 100644
index c4e4bfa..0000000
--- a/src/main/java/org/bukkit/material/Wool.java
+++ /dev/null
@@ -1,79 +0,0 @@
-package org.bukkit.material;
-
-import org.bukkit.DyeColor;
-import org.bukkit.Material;
-
-/**
- * Represents a Wool/Cloth block
- */
-public class Wool extends MaterialData implements Colorable {
-    public Wool() {
-        super(Material.WOOL);
-    }
-
-    public Wool(DyeColor color) {
-        this();
-        setColor(color);
-    }
-
-    /**
-     * @param type the raw type id
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Wool(final int type) {
-        super(type);
-    }
-
-    public Wool(final Material type) {
-        super(type);
-    }
-
-    /**
-     * @param type the raw type id
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Wool(final int type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * @param type the type
-     * @param data the raw data value
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public Wool(final Material type, final byte data) {
-        super(type, data);
-    }
-
-    /**
-     * Gets the current color of this dye
-     *
-     * @return DyeColor of this dye
-     */
-    public DyeColor getColor() {
-        return DyeColor.getByWoolData(getData());
-    }
-
-    /**
-     * Sets the color of this dye
-     *
-     * @param color New color of this dye
-     */
-    public void setColor(DyeColor color) {
-        setData(color.getWoolData());
-    }
-
-    @Override
-    public String toString() {
-        return getColor() + " " + super.toString();
-    }
-
-    @Override
-    public Wool clone() {
-        return (Wool) super.clone();
-    }
-}
diff --git a/src/main/java/org/bukkit/material/types/MushroomBlockTexture.java b/src/main/java/org/bukkit/material/types/MushroomBlockTexture.java
deleted file mode 100644
index 6525ab4..0000000
--- a/src/main/java/org/bukkit/material/types/MushroomBlockTexture.java
+++ /dev/null
@@ -1,130 +0,0 @@
-package org.bukkit.material.types;
-
-import java.util.Map;
-
-import org.bukkit.block.BlockFace;
-
-import com.google.common.collect.Maps;
-
-/**
- * Represents the different textured blocks of mushroom.
- */
-public enum MushroomBlockTexture {
-
-    /**
-     * Pores on all faces.
-     */
-    ALL_PORES(0, null),
-    /**
-     * Cap texture on the top, north and west faces, pores on remaining sides.
-     */
-    CAP_NORTH_WEST(1, BlockFace.NORTH_WEST),
-    /**
-     * Cap texture on the top and north faces, pores on remaining sides.
-     */
-    CAP_NORTH(2, BlockFace.NORTH),
-    /**
-     * Cap texture on the top, north and east faces, pores on remaining sides.
-     */
-    CAP_NORTH_EAST(3, BlockFace.NORTH_EAST),
-    /**
-     * Cap texture on the top and west faces, pores on remaining sides.
-     */
-    CAP_WEST(4, BlockFace.WEST),
-    /**
-     * Cap texture on the top face, pores on remaining sides.
-     */
-    CAP_TOP(5, BlockFace.UP),
-    /**
-     * Cap texture on the top and east faces, pores on remaining sides.
-     */
-    CAP_EAST(6, BlockFace.EAST),
-    /**
-     * Cap texture on the top, south and west faces, pores on remaining sides.
-     */
-    CAP_SOUTH_WEST(7, BlockFace.SOUTH_WEST),
-    /**
-     * Cap texture on the top and south faces, pores on remaining sides.
-     */
-    CAP_SOUTH(8, BlockFace.SOUTH),
-    /**
-     * Cap texture on the top, south and east faces, pores on remaining sides.
-     */
-    CAP_SOUTH_EAST(9, BlockFace.SOUTH_EAST),
-    /**
-     * Stem texture on the north, east, south and west faces, pores on top and
-     * bottom.
-     */
-    STEM_SIDES(10, null),
-    /**
-     * Cap texture on all faces.
-     */
-    ALL_CAP(14, BlockFace.SELF),
-    /**
-     * Stem texture on all faces.
-     */
-    ALL_STEM(15, null);
-    private final static Map<Byte, MushroomBlockTexture> BY_DATA = Maps.newHashMap();
-    private final static Map<BlockFace, MushroomBlockTexture> BY_BLOCKFACE = Maps.newHashMap();
-
-    private final Byte data;
-    private final BlockFace capFace;
-
-    private MushroomBlockTexture(final int data, final BlockFace capFace) {
-        this.data = (byte) data;
-        this.capFace = capFace;
-    }
-
-    /**
-     * Gets the associated data value representing this mushroom block face.
-     *
-     * @return A byte containing the data value of this mushroom block face
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public byte getData() {
-        return data;
-    }
-
-    /**
-     * Gets the face that has cap texture.
-     *
-     * @return The cap face
-     */
-    public BlockFace getCapFace() {
-        return capFace;
-    }
-
-    /**
-     * Gets the MushroomBlockType with the given data value.
-     *
-     * @param data Data value to fetch
-     * @return The {@link MushroomBlockTexture} representing the given value, or
-     * null if it doesn't exist
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public static MushroomBlockTexture getByData(final byte data) {
-        return BY_DATA.get(data);
-    }
-
-    /**
-     * Gets the MushroomBlockType with cap texture on the given block face.
-     *
-     * @param face the required block face with cap texture
-     * @return The {@link MushroomBlockTexture} representing the given block
-     * face, or null if it doesn't exist
-     *
-     * @see BlockFace
-     */
-    public static MushroomBlockTexture getCapByFace(final BlockFace face) {
-        return BY_BLOCKFACE.get(face);
-    }
-
-    static {
-        for (MushroomBlockTexture type : values()) {
-            BY_DATA.put(type.data, type);
-            BY_BLOCKFACE.put(type.capFace, type);
-        }
-    }
-}
diff --git a/src/main/java/org/bukkit/metadata/FixedMetadataValue.java b/src/main/java/org/bukkit/metadata/FixedMetadataValue.java
deleted file mode 100644
index bce6f00..0000000
--- a/src/main/java/org/bukkit/metadata/FixedMetadataValue.java
+++ /dev/null
@@ -1,43 +0,0 @@
-package org.bukkit.metadata;
-
-import org.bukkit.plugin.Plugin;
-
-import java.util.concurrent.Callable;
-
-/**
- * A FixedMetadataValue is a special case metadata item that contains the same
- * value forever after initialization. Invalidating a FixedMetadataValue has
- * no effect.
- * <p>
- * This class extends LazyMetadataValue for historical reasons, even though it
- * overrides all the implementation methods. it is possible that in the future
- * that the inheritance hierarchy may change.
- */
-public class FixedMetadataValue extends LazyMetadataValue {
-
-    /**
-     * Store the internal value that is represented by this fixed value.
-     */
-    private final Object internalValue;
-
-    /**
-     * Initializes a FixedMetadataValue with an Object
-     *
-     * @param owningPlugin the {@link Plugin} that created this metadata value
-     * @param value the value assigned to this metadata value
-     */
-    public FixedMetadataValue(Plugin owningPlugin, final Object value) {
-        super(owningPlugin);
-        this.internalValue = value;
-    }
-
-    @Override
-    public void invalidate() {
-
-    }
-
-    @Override
-    public Object value() {
-        return internalValue;
-    }
-}
diff --git a/src/main/java/org/bukkit/metadata/LazyMetadataValue.java b/src/main/java/org/bukkit/metadata/LazyMetadataValue.java
deleted file mode 100644
index 564d0fa..0000000
--- a/src/main/java/org/bukkit/metadata/LazyMetadataValue.java
+++ /dev/null
@@ -1,122 +0,0 @@
-package org.bukkit.metadata;
-
-import java.lang.ref.SoftReference;
-import java.util.concurrent.Callable;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.plugin.Plugin;
-
-/**
- * The LazyMetadataValue class implements a type of metadata that is not
- * computed until another plugin asks for it.
- * <p>
- * By making metadata values lazy, no computation is done by the providing
- * plugin until absolutely necessary (if ever). Additionally,
- * LazyMetadataValue objects cache their values internally unless overridden
- * by a {@link CacheStrategy} or invalidated at the individual or plugin
- * level. Once invalidated, the LazyMetadataValue will recompute its value
- * when asked.
- */
-public class LazyMetadataValue extends MetadataValueAdapter implements MetadataValue {
-    private Callable<Object> lazyValue;
-    private CacheStrategy cacheStrategy;
-    private SoftReference<Object> internalValue;
-    private static final Object ACTUALLY_NULL = new Object();
-
-    /**
-     * Initialized a LazyMetadataValue object with the default
-     * CACHE_AFTER_FIRST_EVAL cache strategy.
-     *
-     * @param owningPlugin the {@link Plugin} that created this metadata
-     *     value.
-     * @param lazyValue the lazy value assigned to this metadata value.
-     */
-    public LazyMetadataValue(Plugin owningPlugin, Callable<Object> lazyValue) {
-        this(owningPlugin, CacheStrategy.CACHE_AFTER_FIRST_EVAL, lazyValue);
-    }
-
-    /**
-     * Initializes a LazyMetadataValue object with a specific cache strategy.
-     *
-     * @param owningPlugin the {@link Plugin} that created this metadata
-     *     value.
-     * @param cacheStrategy determines the rules for caching this metadata
-     *     value.
-     * @param lazyValue the lazy value assigned to this metadata value.
-     */
-    public LazyMetadataValue(Plugin owningPlugin, CacheStrategy cacheStrategy, Callable<Object> lazyValue) {
-        super(owningPlugin);
-        Validate.notNull(cacheStrategy, "cacheStrategy cannot be null");
-        Validate.notNull(lazyValue, "lazyValue cannot be null");
-        this.internalValue = new SoftReference<Object>(null);
-        this.lazyValue = lazyValue;
-        this.cacheStrategy = cacheStrategy;
-    }
-
-    /**
-     * Protected special constructor used by FixedMetadataValue to bypass
-     * standard setup.
-     * 
-     * @param owningPlugin the owning plugin
-     */
-    protected LazyMetadataValue(Plugin owningPlugin) {
-        super(owningPlugin);
-    }
-
-    public Object value() {
-        eval();
-        Object value = internalValue.get();
-        if (value == ACTUALLY_NULL) {
-            return null;
-        }
-        return value;
-    }
-
-    /**
-     * Lazily evaluates the value of this metadata item.
-     *
-     * @throws MetadataEvaluationException if computing the metadata value
-     *     fails.
-     */
-    private synchronized void eval() throws MetadataEvaluationException {
-        if (cacheStrategy == CacheStrategy.NEVER_CACHE || internalValue.get() == null) {
-            try {
-                Object value = lazyValue.call();
-                if (value == null) {
-                    value = ACTUALLY_NULL;
-                }
-                internalValue = new SoftReference<Object>(value);
-            } catch (Exception e) {
-                throw new MetadataEvaluationException(e);
-            }
-        }
-    }
-
-    public synchronized void invalidate() {
-        if (cacheStrategy != CacheStrategy.CACHE_ETERNALLY) {
-            internalValue.clear();
-        }
-    }
-
-    /**
-     * Describes possible caching strategies for metadata.
-     */
-    public enum CacheStrategy {
-        /**
-         * Once the metadata value has been evaluated, do not re-evaluate the
-         * value until it is manually invalidated.
-         */
-        CACHE_AFTER_FIRST_EVAL,
-
-        /**
-         * Re-evaluate the metadata item every time it is requested
-         */
-        NEVER_CACHE,
-
-        /**
-         * Once the metadata value has been evaluated, do not re-evaluate the
-         * value in spite of manual invalidation.
-         */
-        CACHE_ETERNALLY
-    }
-}
diff --git a/src/main/java/org/bukkit/metadata/MetadataConversionException.java b/src/main/java/org/bukkit/metadata/MetadataConversionException.java
deleted file mode 100644
index a3def46..0000000
--- a/src/main/java/org/bukkit/metadata/MetadataConversionException.java
+++ /dev/null
@@ -1,13 +0,0 @@
-package org.bukkit.metadata;
-
-/**
- * A MetadataConversionException is thrown any time a {@link
- * LazyMetadataValue} attempts to convert a metadata value to an inappropriate
- * data type.
- */
-@SuppressWarnings("serial")
-public class MetadataConversionException extends RuntimeException {
-    MetadataConversionException(String message) {
-        super(message);
-    }
-}
diff --git a/src/main/java/org/bukkit/metadata/MetadataEvaluationException.java b/src/main/java/org/bukkit/metadata/MetadataEvaluationException.java
deleted file mode 100644
index 918e7c8..0000000
--- a/src/main/java/org/bukkit/metadata/MetadataEvaluationException.java
+++ /dev/null
@@ -1,13 +0,0 @@
-package org.bukkit.metadata;
-
-/**
- * A MetadataEvaluationException is thrown any time a {@link
- * LazyMetadataValue} fails to evaluate its value due to an exception. The
- * originating exception will be included as this exception's cause.
- */
-@SuppressWarnings("serial")
-public class MetadataEvaluationException extends RuntimeException {
-    MetadataEvaluationException(Throwable cause) {
-        super(cause);
-    }
-}
diff --git a/src/main/java/org/bukkit/metadata/MetadataStore.java b/src/main/java/org/bukkit/metadata/MetadataStore.java
deleted file mode 100644
index 700d0bf..0000000
--- a/src/main/java/org/bukkit/metadata/MetadataStore.java
+++ /dev/null
@@ -1,60 +0,0 @@
-package org.bukkit.metadata;
-
-import org.bukkit.plugin.Plugin;
-
-import java.util.List;
-
-public interface MetadataStore<T> {
-    /**
-     * Adds a metadata value to an object.
-     *
-     * @param subject The object receiving the metadata.
-     * @param metadataKey A unique key to identify this metadata.
-     * @param newMetadataValue The metadata value to apply.
-     * @throws IllegalArgumentException If value is null, or the owning plugin
-     *     is null
-     */
-    public void setMetadata(T subject, String metadataKey, MetadataValue newMetadataValue);
-
-    /**
-     * Returns all metadata values attached to an object. If multiple plugins
-     * have attached metadata, each will value will be included.
-     *
-     * @param subject the object being interrogated.
-     * @param metadataKey the unique metadata key being sought.
-     * @return A list of values, one for each plugin that has set the
-     *     requested value.
-     */
-    public List<MetadataValue> getMetadata(T subject, String metadataKey);
-
-    /**
-     * Tests to see if a metadata attribute has been set on an object.
-     *
-     * @param subject the object upon which the has-metadata test is
-     *     performed.
-     * @param metadataKey the unique metadata key being queried.
-     * @return the existence of the metadataKey within subject.
-     */
-    public boolean hasMetadata(T subject, String metadataKey);
-
-    /**
-     * Removes a metadata item owned by a plugin from a subject.
-     *
-     * @param subject the object to remove the metadata from.
-     * @param metadataKey the unique metadata key identifying the metadata to
-     *     remove.
-     * @param owningPlugin the plugin attempting to remove a metadata item.
-     * @throws IllegalArgumentException If plugin is null
-     */
-    public void removeMetadata(T subject, String metadataKey, Plugin owningPlugin);
-
-    /**
-     * Invalidates all metadata in the metadata store that originates from the
-     * given plugin. Doing this will force each invalidated metadata item to
-     * be recalculated the next time it is accessed.
-     *
-     * @param owningPlugin the plugin requesting the invalidation.
-     * @throws IllegalArgumentException If plugin is null
-     */
-    public void invalidateAll(Plugin owningPlugin);
-}
diff --git a/src/main/java/org/bukkit/metadata/MetadataStoreBase.java b/src/main/java/org/bukkit/metadata/MetadataStoreBase.java
deleted file mode 100644
index 093c144..0000000
--- a/src/main/java/org/bukkit/metadata/MetadataStoreBase.java
+++ /dev/null
@@ -1,136 +0,0 @@
-package org.bukkit.metadata;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.plugin.Plugin;
-
-import java.util.*;
-
-public abstract class MetadataStoreBase<T> {
-    private Map<String, Map<Plugin, MetadataValue>> metadataMap = new HashMap<String, Map<Plugin, MetadataValue>>();
-
-    /**
-     * Adds a metadata value to an object. Each metadata value is owned by a
-     * specific {@link Plugin}. If a plugin has already added a metadata value
-     * to an object, that value will be replaced with the value of {@code
-     * newMetadataValue}. Multiple plugins can set independent values for the
-     * same {@code metadataKey} without conflict.
-     * <p>
-     * Implementation note: I considered using a {@link
-     * java.util.concurrent.locks.ReadWriteLock} for controlling access to
-     * {@code metadataMap}, but decided that the added overhead wasn't worth
-     * the finer grained access control.
-     * <p>
-     * Bukkit is almost entirely single threaded so locking overhead shouldn't
-     * pose a problem.
-     *
-     * @param subject The object receiving the metadata.
-     * @param metadataKey A unique key to identify this metadata.
-     * @param newMetadataValue The metadata value to apply.
-     * @see MetadataStore#setMetadata(Object, String, MetadataValue)
-     * @throws IllegalArgumentException If value is null, or the owning plugin
-     *     is null
-     */
-    public synchronized void setMetadata(T subject, String metadataKey, MetadataValue newMetadataValue) {
-        Validate.notNull(newMetadataValue, "Value cannot be null");
-        Plugin owningPlugin = newMetadataValue.getOwningPlugin();
-        Validate.notNull(owningPlugin, "Plugin cannot be null");
-        String key = disambiguate(subject, metadataKey);
-        Map<Plugin, MetadataValue> entry = metadataMap.get(key);
-        if (entry == null) {
-            entry = new WeakHashMap<Plugin, MetadataValue>(1);
-            metadataMap.put(key, entry);
-        }
-        entry.put(owningPlugin, newMetadataValue);
-    }
-
-    /**
-     * Returns all metadata values attached to an object. If multiple
-     * have attached metadata, each will value will be included.
-     *
-     * @param subject the object being interrogated.
-     * @param metadataKey the unique metadata key being sought.
-     * @return A list of values, one for each plugin that has set the
-     *     requested value.
-     * @see MetadataStore#getMetadata(Object, String)
-     */
-    public synchronized List<MetadataValue> getMetadata(T subject, String metadataKey) {
-        String key = disambiguate(subject, metadataKey);
-        if (metadataMap.containsKey(key)) {
-            Collection<MetadataValue> values = metadataMap.get(key).values();
-            return Collections.unmodifiableList(new ArrayList<MetadataValue>(values));
-        } else {
-            return Collections.emptyList();
-        }
-    }
-
-    /**
-     * Tests to see if a metadata attribute has been set on an object.
-     *
-     * @param subject the object upon which the has-metadata test is
-     *     performed.
-     * @param metadataKey the unique metadata key being queried.
-     * @return the existence of the metadataKey within subject.
-     */
-    public synchronized boolean hasMetadata(T subject, String metadataKey) {
-        String key = disambiguate(subject, metadataKey);
-        return metadataMap.containsKey(key);
-    }
-
-    /**
-     * Removes a metadata item owned by a plugin from a subject.
-     *
-     * @param subject the object to remove the metadata from.
-     * @param metadataKey the unique metadata key identifying the metadata to
-     *     remove.
-     * @param owningPlugin the plugin attempting to remove a metadata item.
-     * @see MetadataStore#removeMetadata(Object, String,
-     *     org.bukkit.plugin.Plugin)
-     * @throws IllegalArgumentException If plugin is null
-     */
-    public synchronized void removeMetadata(T subject, String metadataKey, Plugin owningPlugin) {
-        Validate.notNull(owningPlugin, "Plugin cannot be null");
-        String key = disambiguate(subject, metadataKey);
-        Map<Plugin, MetadataValue> entry = metadataMap.get(key);
-        if (entry == null) {
-            return;
-        }
-
-        entry.remove(owningPlugin);
-        if (entry.isEmpty()) {
-            metadataMap.remove(key);
-        }
-    }
-
-    /**
-     * Invalidates all metadata in the metadata store that originates from the
-     * given plugin. Doing this will force each invalidated metadata item to
-     * be recalculated the next time it is accessed.
-     *
-     * @param owningPlugin the plugin requesting the invalidation.
-     * @see MetadataStore#invalidateAll(org.bukkit.plugin.Plugin)
-     * @throws IllegalArgumentException If plugin is null
-     */
-    public synchronized void invalidateAll(Plugin owningPlugin) {
-        Validate.notNull(owningPlugin, "Plugin cannot be null");
-        for (Map<Plugin, MetadataValue> values : metadataMap.values()) {
-            if (values.containsKey(owningPlugin)) {
-                values.get(owningPlugin).invalidate();
-            }
-        }
-    }
-
-    /**
-     * Creates a unique name for the object receiving metadata by combining
-     * unique data from the subject with a metadataKey.
-     * <p>
-     * The name created must be globally unique for the given object and any
-     * two equivalent objects must generate the same unique name. For example,
-     * two Player objects must generate the same string if they represent the
-     * same player, even if the objects would fail a reference equality test.
-     *
-     * @param subject The object for which this key is being generated.
-     * @param metadataKey The name identifying the metadata value.
-     * @return a unique metadata key for the given subject.
-     */
-    protected abstract String disambiguate(T subject, String metadataKey);
-}
diff --git a/src/main/java/org/bukkit/metadata/MetadataValue.java b/src/main/java/org/bukkit/metadata/MetadataValue.java
deleted file mode 100644
index eded8c0..0000000
--- a/src/main/java/org/bukkit/metadata/MetadataValue.java
+++ /dev/null
@@ -1,83 +0,0 @@
-package org.bukkit.metadata;
-
-import org.bukkit.plugin.Plugin;
-
-public interface MetadataValue {
-
-    /**
-     * Fetches the value of this metadata item.
-     *
-     * @return the metadata value.
-     */
-    public Object value();
-
-    /**
-     * Attempts to convert the value of this metadata item into an int.
-     *
-     * @return the value as an int.
-     */
-    public int asInt();
-
-    /**
-     * Attempts to convert the value of this metadata item into a float.
-     *
-     * @return the value as a float.
-     */
-    public float asFloat();
-
-    /**
-     * Attempts to convert the value of this metadata item into a double.
-     *
-     * @return the value as a double.
-     */
-    public double asDouble();
-
-    /**
-     * Attempts to convert the value of this metadata item into a long.
-     *
-     * @return the value as a long.
-     */
-    public long asLong();
-
-    /**
-     * Attempts to convert the value of this metadata item into a short.
-     *
-     * @return the value as a short.
-     */
-    public short asShort();
-
-    /**
-     * Attempts to convert the value of this metadata item into a byte.
-     *
-     * @return the value as a byte.
-     */
-    public byte asByte();
-
-    /**
-     * Attempts to convert the value of this metadata item into a boolean.
-     *
-     * @return the value as a boolean.
-     */
-    public boolean asBoolean();
-
-    /**
-     * Attempts to convert the value of this metadata item into a string.
-     *
-     * @return the value as a string.
-     */
-    public String asString();
-
-    /**
-     * Returns the {@link Plugin} that created this metadata item.
-     *
-     * @return the plugin that owns this metadata value. This should never be
-     *     null.
-     */
-    public Plugin getOwningPlugin();
-
-    /**
-     * Invalidates this metadata item, forcing it to recompute when next
-     * accessed.
-     */
-    public void invalidate();
-}
diff --git a/src/main/java/org/bukkit/metadata/MetadataValueAdapter.java b/src/main/java/org/bukkit/metadata/MetadataValueAdapter.java
deleted file mode 100644
index bbc3da8..0000000
--- a/src/main/java/org/bukkit/metadata/MetadataValueAdapter.java
+++ /dev/null
@@ -1,78 +0,0 @@
-package org.bukkit.metadata;
-
-import java.lang.ref.WeakReference;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.plugin.Plugin;
-import org.bukkit.util.NumberConversions;
-
-/**
- * Optional base class for facilitating MetadataValue implementations.
- * <p>
- * This provides all the conversion functions for MetadataValue so that
- * writing an implementation of MetadataValue is as simple as implementing
- * value() and invalidate().
- */
-public abstract class MetadataValueAdapter implements MetadataValue {
-    protected final WeakReference<Plugin> owningPlugin;
-
-    protected MetadataValueAdapter(Plugin owningPlugin) {
-        Validate.notNull(owningPlugin, "owningPlugin cannot be null");
-        this.owningPlugin = new WeakReference<Plugin>(owningPlugin);
-    }
-
-    public Plugin getOwningPlugin() {
-        return owningPlugin.get();
-    }
-
-    public int asInt() {
-        return NumberConversions.toInt(value());
-    }
-
-    public float asFloat() {
-        return NumberConversions.toFloat(value());
-    }
-
-    public double asDouble() {
-        return NumberConversions.toDouble(value());
-    }
-
-    public long asLong() {
-        return NumberConversions.toLong(value());
-    }
-
-    public short asShort() {
-        return NumberConversions.toShort(value());
-    }
-
-    public byte asByte() {
-        return NumberConversions.toByte(value());
-    }
-
-    public boolean asBoolean() {
-        Object value = value();
-        if (value instanceof Boolean) {
-            return (Boolean) value;
-        }
-
-        if (value instanceof Number) {
-            return ((Number) value).intValue() != 0;
-        }
-
-        if (value instanceof String) {
-            return Boolean.parseBoolean((String) value);
-        }
-
-        return value != null;
-    }
-
-    public String asString() {
-        Object value = value();
-
-        if (value == null) {
-            return "";
-        }
-        return value.toString();
-    }
-
-}
diff --git a/src/main/java/org/bukkit/metadata/Metadatable.java b/src/main/java/org/bukkit/metadata/Metadatable.java
deleted file mode 100644
index b47cf2b..0000000
--- a/src/main/java/org/bukkit/metadata/Metadatable.java
+++ /dev/null
@@ -1,52 +0,0 @@
-package org.bukkit.metadata;
-
-import org.bukkit.plugin.Plugin;
-
-import java.util.List;
-
-/**
- * This interface is implemented by all objects that can provide metadata
- * about themselves.
- */
-public interface Metadatable {
-    /**
-     * Sets a metadata value in the implementing object's metadata store.
-     *
-     * @param metadataKey A unique key to identify this metadata.
-     * @param newMetadataValue The metadata value to apply.
-     * @throws IllegalArgumentException If value is null, or the owning plugin
-     *     is null
-     */
-    public void setMetadata(String metadataKey, MetadataValue newMetadataValue);
-
-    /**
-     * Returns a list of previously set metadata values from the implementing
-     * object's metadata store.
-     *
-     * @param metadataKey the unique metadata key being sought.
-     * @return A list of values, one for each plugin that has set the
-     *     requested value.
-     */
-    public List<MetadataValue> getMetadata(String metadataKey);
-
-    /**
-     * Tests to see whether the implementing object contains the given
-     * metadata value in its metadata store.
-     *
-     * @param metadataKey the unique metadata key being queried.
-     * @return the existence of the metadataKey within subject.
-     */
-    public boolean hasMetadata(String metadataKey);
-
-    /**
-     * Removes the given metadata value from the implementing object's
-     * metadata store.
-     *
-     * @param metadataKey the unique metadata key identifying the metadata to
-     *     remove.
-     * @param owningPlugin This plugin's metadata value will be removed. All
-     *     other values will be left untouched.
-     * @throws IllegalArgumentException If plugin is null
-     */
-    public void removeMetadata(String metadataKey, Plugin owningPlugin);
-}
diff --git a/src/main/java/org/bukkit/permissions/Permissible.java b/src/main/java/org/bukkit/permissions/Permissible.java
deleted file mode 100644
index 5cd3cff..0000000
--- a/src/main/java/org/bukkit/permissions/Permissible.java
+++ /dev/null
@@ -1,122 +0,0 @@
-package org.bukkit.permissions;
-
-import java.util.Set;
-import org.bukkit.plugin.Plugin;
-
-/**
- * Represents an object that may be assigned permissions
- */
-public interface Permissible extends ServerOperator {
-
-    /**
-     * Checks if this object contains an override for the specified
-     * permission, by fully qualified name
-     *
-     * @param name Name of the permission
-     * @return true if the permission is set, otherwise false
-     */
-    public boolean isPermissionSet(String name);
-
-    /**
-     * Checks if this object contains an override for the specified {@link
-     * Permission}
-     *
-     * @param perm Permission to check
-     * @return true if the permission is set, otherwise false
-     */
-    public boolean isPermissionSet(Permission perm);
-
-    /**
-     * Gets the value of the specified permission, if set.
-     * <p>
-     * If a permission override is not set on this object, the default value
-     * of the permission will be returned.
-     *
-     * @param name Name of the permission
-     * @return Value of the permission
-     */
-    public boolean hasPermission(String name);
-
-    /**
-     * Gets the value of the specified permission, if set.
-     * <p>
-     * If a permission override is not set on this object, the default value
-     * of the permission will be returned
-     *
-     * @param perm Permission to get
-     * @return Value of the permission
-     */
-    public boolean hasPermission(Permission perm);
-
-    /**
-     * Adds a new {@link PermissionAttachment} with a single permission by
-     * name and value
-     *
-     * @param plugin Plugin responsible for this attachment, may not be null
-     *     or disabled
-     * @param name Name of the permission to attach
-     * @param value Value of the permission
-     * @return The PermissionAttachment that was just created
-     */
-    public PermissionAttachment addAttachment(Plugin plugin, String name, boolean value);
-
-    /**
-     * Adds a new empty {@link PermissionAttachment} to this object
-     *
-     * @param plugin Plugin responsible for this attachment, may not be null
-     *     or disabled
-     * @return The PermissionAttachment that was just created
-     */
-    public PermissionAttachment addAttachment(Plugin plugin);
-
-    /**
-     * Temporarily adds a new {@link PermissionAttachment} with a single
-     * permission by name and value
-     *
-     * @param plugin Plugin responsible for this attachment, may not be null
-     *     or disabled
-     * @param name Name of the permission to attach
-     * @param value Value of the permission
-     * @param ticks Amount of ticks to automatically remove this attachment
-     *     after
-     * @return The PermissionAttachment that was just created
-     */
-    public PermissionAttachment addAttachment(Plugin plugin, String name, boolean value, int ticks);
-
-    /**
-     * Temporarily adds a new empty {@link PermissionAttachment} to this
-     * object
-     *
-     * @param plugin Plugin responsible for this attachment, may not be null
-     *     or disabled
-     * @param ticks Amount of ticks to automatically remove this attachment
-     *     after
-     * @return The PermissionAttachment that was just created
-     */
-    public PermissionAttachment addAttachment(Plugin plugin, int ticks);
-
-    /**
-     * Removes the given {@link PermissionAttachment} from this object
-     *
-     * @param attachment Attachment to remove
-     * @throws IllegalArgumentException Thrown when the specified attachment
-     *     isn't part of this object
-     */
-    public void removeAttachment(PermissionAttachment attachment);
-
-    /**
-     * Recalculates the permissions for this object, if the attachments have
-     * changed values.
-     * <p>
-     * This should very rarely need to be called from a plugin.
-     */
-    public void recalculatePermissions();
-
-    /**
-     * Gets a set containing all of the permissions currently in effect by
-     * this object
-     *
-     * @return Set of currently effective permissions
-     */
-    public Set<PermissionAttachmentInfo> getEffectivePermissions();
-}
diff --git a/src/main/java/org/bukkit/permissions/PermissibleBase.java b/src/main/java/org/bukkit/permissions/PermissibleBase.java
deleted file mode 100644
index 3b95061..0000000
--- a/src/main/java/org/bukkit/permissions/PermissibleBase.java
+++ /dev/null
@@ -1,246 +0,0 @@
-package org.bukkit.permissions;
-
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.logging.Level;
-import org.bukkit.Bukkit;
-import org.bukkit.plugin.Plugin;
-
-/**
- * Base Permissible for use in any Permissible object via proxy or extension
- */
-public class PermissibleBase implements Permissible {
-    private ServerOperator opable = null;
-    private Permissible parent = this;
-    private final List<PermissionAttachment> attachments = new LinkedList<PermissionAttachment>();
-    private final Map<String, PermissionAttachmentInfo> permissions = new HashMap<String, PermissionAttachmentInfo>();
-
-    public PermissibleBase(ServerOperator opable) {
-        this.opable = opable;
-
-        if (opable instanceof Permissible) {
-            this.parent = (Permissible) opable;
-        }
-
-        recalculatePermissions();
-    }
-
-    public boolean isOp() {
-        if (opable == null) {
-            return false;
-        } else {
-            return opable.isOp();
-        }
-    }
-
-    public void setOp(boolean value) {
-        if (opable == null) {
-            throw new UnsupportedOperationException("Cannot change op value as no ServerOperator is set");
-        } else {
-            opable.setOp(value);
-        }
-    }
-
-    public boolean isPermissionSet(String name) {
-        if (name == null) {
-            throw new IllegalArgumentException("Permission name cannot be null");
-        }
-
-        return permissions.containsKey(name.toLowerCase());
-    }
-
-    public boolean isPermissionSet(Permission perm) {
-        if (perm == null) {
-            throw new IllegalArgumentException("Permission cannot be null");
-        }
-
-        return isPermissionSet(perm.getName());
-    }
-
-    public boolean hasPermission(String inName) {
-        if (inName == null) {
-            throw new IllegalArgumentException("Permission name cannot be null");
-        }
-
-        String name = inName.toLowerCase();
-
-        if (isPermissionSet(name)) {
-            return permissions.get(name).getValue();
-        } else {
-            Permission perm = Bukkit.getServer().getPluginManager().getPermission(name);
-
-            if (perm != null) {
-                return perm.getDefault().getValue(isOp());
-            } else {
-                return Permission.DEFAULT_PERMISSION.getValue(isOp());
-            }
-        }
-    }
-
-    public boolean hasPermission(Permission perm) {
-        if (perm == null) {
-            throw new IllegalArgumentException("Permission cannot be null");
-        }
-
-        String name = perm.getName().toLowerCase();
-
-        if (isPermissionSet(name)) {
-            return permissions.get(name).getValue();
-        }
-        return perm.getDefault().getValue(isOp());
-    }
-
-    public PermissionAttachment addAttachment(Plugin plugin, String name, boolean value) {
-        if (name == null) {
-            throw new IllegalArgumentException("Permission name cannot be null");
-        } else if (plugin == null) {
-            throw new IllegalArgumentException("Plugin cannot be null");
-        } else if (!plugin.isEnabled()) {
-            throw new IllegalArgumentException("Plugin " + plugin.getDescription().getFullName() + " is disabled");
-        }
-
-        PermissionAttachment result = addAttachment(plugin);
-        result.setPermission(name, value);
-
-        recalculatePermissions();
-
-        return result;
-    }
-
-    public PermissionAttachment addAttachment(Plugin plugin) {
-        if (plugin == null) {
-            throw new IllegalArgumentException("Plugin cannot be null");
-        } else if (!plugin.isEnabled()) {
-            throw new IllegalArgumentException("Plugin " + plugin.getDescription().getFullName() + " is disabled");
-        }
-
-        PermissionAttachment result = new PermissionAttachment(plugin, parent);
-
-        attachments.add(result);
-        recalculatePermissions();
-
-        return result;
-    }
-
-    public void removeAttachment(PermissionAttachment attachment) {
-        if (attachment == null) {
-            throw new IllegalArgumentException("Attachment cannot be null");
-        }
-
-        if (attachments.contains(attachment)) {
-            attachments.remove(attachment);
-            PermissionRemovedExecutor ex = attachment.getRemovalCallback();
-
-            if (ex != null) {
-                ex.attachmentRemoved(attachment);
-            }
-
-            recalculatePermissions();
-        } else {
-            throw new IllegalArgumentException("Given attachment is not part of Permissible object " + parent);
-        }
-    }
-
-    public void recalculatePermissions() {
-        clearPermissions();
-        Set<Permission> defaults = Bukkit.getServer().getPluginManager().getDefaultPermissions(isOp());
-        Bukkit.getServer().getPluginManager().subscribeToDefaultPerms(isOp(), parent);
-
-        for (Permission perm : defaults) {
-            String name = perm.getName().toLowerCase();
-            permissions.put(name, new PermissionAttachmentInfo(parent, name, null, true));
-            Bukkit.getServer().getPluginManager().subscribeToPermission(name, parent);
-            calculateChildPermissions(perm.getChildren(), false, null);
-        }
-
-        for (PermissionAttachment attachment : attachments) {
-            calculateChildPermissions(attachment.getPermissions(), false, attachment);
-        }
-    }
-
-    public synchronized void clearPermissions() {
-        Set<String> perms = permissions.keySet();
-
-        for (String name : perms) {
-            Bukkit.getServer().getPluginManager().unsubscribeFromPermission(name, parent);
-        }
-
-        Bukkit.getServer().getPluginManager().unsubscribeFromDefaultPerms(false, parent);
-        Bukkit.getServer().getPluginManager().unsubscribeFromDefaultPerms(true, parent);
-
-        permissions.clear();
-    }
-
-    private void calculateChildPermissions(Map<String, Boolean> children, boolean invert, PermissionAttachment attachment) {
-        Set<String> keys = children.keySet();
-
-        for (String name : keys) {
-            Permission perm = Bukkit.getServer().getPluginManager().getPermission(name);
-            boolean value = children.get(name) ^ invert;
-            String lname = name.toLowerCase();
-
-            permissions.put(lname, new PermissionAttachmentInfo(parent, lname, attachment, value));
-            Bukkit.getServer().getPluginManager().subscribeToPermission(name, parent);
-
-            if (perm != null) {
-                calculateChildPermissions(perm.getChildren(), !value, attachment);
-            }
-        }
-    }
-
-    public PermissionAttachment addAttachment(Plugin plugin, String name, boolean value, int ticks) {
-        if (name == null) {
-            throw new IllegalArgumentException("Permission name cannot be null");
-        } else if (plugin == null) {
-            throw new IllegalArgumentException("Plugin cannot be null");
-        } else if (!plugin.isEnabled()) {
-            throw new IllegalArgumentException("Plugin " + plugin.getDescription().getFullName() + " is disabled");
-        }
-
-        PermissionAttachment result = addAttachment(plugin, ticks);
-
-        if (result != null) {
-            result.setPermission(name, value);
-        }
-
-        return result;
-    }
-
-    public PermissionAttachment addAttachment(Plugin plugin, int ticks) {
-        if (plugin == null) {
-            throw new IllegalArgumentException("Plugin cannot be null");
-        } else if (!plugin.isEnabled()) {
-            throw new IllegalArgumentException("Plugin " + plugin.getDescription().getFullName() + " is disabled");
-        }
-
-        PermissionAttachment result = addAttachment(plugin);
-
-        if (Bukkit.getServer().getScheduler().scheduleSyncDelayedTask(plugin, new RemoveAttachmentRunnable(result), ticks) == -1) {
-            Bukkit.getServer().getLogger().log(Level.WARNING, "Could not add PermissionAttachment to " + parent + " for plugin " + plugin.getDescription().getFullName() + ": Scheduler returned -1");
-            result.remove();
-            return null;
-        } else {
-            return result;
-        }
-    }
-
-    public Set<PermissionAttachmentInfo> getEffectivePermissions() {
-        return new HashSet<PermissionAttachmentInfo>(permissions.values());
-    }
-
-    private class RemoveAttachmentRunnable implements Runnable {
-        private PermissionAttachment attachment;
-
-        public RemoveAttachmentRunnable(PermissionAttachment attachment) {
-            this.attachment = attachment;
-        }
-
-        public void run() {
-            attachment.remove();
-        }
-    }
-}
diff --git a/src/main/java/org/bukkit/permissions/Permission.java b/src/main/java/org/bukkit/permissions/Permission.java
deleted file mode 100644
index 0184f47..0000000
--- a/src/main/java/org/bukkit/permissions/Permission.java
+++ /dev/null
@@ -1,345 +0,0 @@
-package org.bukkit.permissions;
-
-import java.util.ArrayList;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.logging.Level;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.Bukkit;
-import org.bukkit.plugin.PluginManager;
-
-/**
- * Represents a unique permission that may be attached to a {@link
- * Permissible}
- */
-public class Permission {
-    public static final PermissionDefault DEFAULT_PERMISSION = PermissionDefault.OP;
-
-    private final String name;
-    private final Map<String, Boolean> children = new LinkedHashMap<String, Boolean>();
-    private PermissionDefault defaultValue = DEFAULT_PERMISSION;
-    private String description;
-
-    public Permission(String name) {
-        this(name, null, null, null);
-    }
-
-    public Permission(String name, String description) {
-        this(name, description, null, null);
-    }
-
-    public Permission(String name, PermissionDefault defaultValue) {
-        this(name, null, defaultValue, null);
-    }
-
-    public Permission(String name, String description, PermissionDefault defaultValue) {
-        this(name, description, defaultValue, null);
-    }
-
-    public Permission(String name, Map<String, Boolean> children) {
-        this(name, null, null, children);
-    }
-
-    public Permission(String name, String description, Map<String, Boolean> children) {
-        this(name, description, null, children);
-    }
-
-    public Permission(String name, PermissionDefault defaultValue, Map<String, Boolean> children) {
-        this(name, null, defaultValue, children);
-    }
-
-    public Permission(String name, String description, PermissionDefault defaultValue, Map<String, Boolean> children) {
-        Validate.notNull(name, "Name cannot be null");
-        this.name = name;
-        this.description = (description == null) ? "" : description;
-
-        if (defaultValue != null) {
-            this.defaultValue = defaultValue;
-        }
-
-        if (children != null) {
-            this.children.putAll(children);
-        }
-
-        recalculatePermissibles();
-    }
-
-    /**
-     * Returns the unique fully qualified name of this Permission
-     *
-     * @return Fully qualified name
-     */
-    public String getName() {
-        return name;
-    }
-
-    /**
-     * Gets the children of this permission.
-     * <p>
-     * If you change this map in any form, you must call {@link
-     * #recalculatePermissibles()} to recalculate all {@link Permissible}s
-     *
-     * @return Permission children
-     */
-    public Map<String, Boolean> getChildren() {
-        return children;
-    }
-
-    /**
-     * Gets the default value of this permission.
-     *
-     * @return Default value of this permission.
-     */
-    public PermissionDefault getDefault() {
-        return defaultValue;
-    }
-
-    /**
-     * Sets the default value of this permission.
-     * <p>
-     * This will not be saved to disk, and is a temporary operation until the
-     * server reloads permissions. Changing this default will cause all {@link
-     * Permissible}s that contain this permission to recalculate their
-     * permissions
-     *
-     * @param value The new default to set
-     */
-    public void setDefault(PermissionDefault value) {
-        if (defaultValue == null) {
-            throw new IllegalArgumentException("Default value cannot be null");
-        }
-
-        defaultValue = value;
-        recalculatePermissibles();
-    }
-
-    /**
-     * Gets a brief description of this permission, if set
-     *
-     * @return Brief description of this permission
-     */
-    public String getDescription() {
-        return description;
-    }
-
-    /**
-     * Sets the description of this permission.
-     * <p>
-     * This will not be saved to disk, and is a temporary operation until the
-     * server reloads permissions.
-     *
-     * @param value The new description to set
-     */
-    public void setDescription(String value) {
-        if (value == null) {
-            description = "";
-        } else {
-            description = value;
-        }
-    }
-
-    /**
-     * Gets a set containing every {@link Permissible} that has this
-     * permission.
-     * <p>
-     * This set cannot be modified.
-     *
-     * @return Set containing permissibles with this permission
-     */
-    public Set<Permissible> getPermissibles() {
-        return Bukkit.getServer().getPluginManager().getPermissionSubscriptions(name);
-    }
-
-    /**
-     * Recalculates all {@link Permissible}s that contain this permission.
-     * <p>
-     * This should be called after modifying the children, and is
-     * automatically called after modifying the default value
-     */
-    public void recalculatePermissibles() {
-        Set<Permissible> perms = getPermissibles();
-
-        Bukkit.getServer().getPluginManager().recalculatePermissionDefaults(this);
-
-        for (Permissible p : perms) {
-            p.recalculatePermissions();
-        }
-    }
-
-    /**
-     * Adds this permission to the specified parent permission.
-     * <p>
-     * If the parent permission does not exist, it will be created and
-     * registered.
-     *
-     * @param name Name of the parent permission
-     * @param value The value to set this permission to
-     * @return Parent permission it created or loaded
-     */
-    public Permission addParent(String name, boolean value) {
-        PluginManager pm = Bukkit.getServer().getPluginManager();
-        String lname = name.toLowerCase();
-
-        Permission perm = pm.getPermission(lname);
-
-        if (perm == null) {
-            perm = new Permission(lname);
-            pm.addPermission(perm);
-        }
-
-        addParent(perm, value);
-
-        return perm;
-    }
-
-    /**
-     * Adds this permission to the specified parent permission.
-     *
-     * @param perm Parent permission to register with
-     * @param value The value to set this permission to
-     */
-    public void addParent(Permission perm, boolean value) {
-        perm.getChildren().put(getName(), value);
-        perm.recalculatePermissibles();
-    }
-
-    /**
-     * Loads a list of Permissions from a map of data, usually used from
-     * retrieval from a yaml file.
-     * <p>
-     * The data may contain a list of name:data, where the data contains the
-     * following keys:
-     * <ul>
-     * <li>default: Boolean true or false. If not specified, false.
-     * <li>children: {@code Map<String, Boolean>} of child permissions. If not
-     *     specified, empty list.
-     * <li>description: Short string containing a very small description of
-     *     this description. If not specified, empty string.
-     * </ul>
-     *
-     * @param data Map of permissions
-     * @param error An error message to show if a permission is invalid.
-     * @param def Default permission value to use if missing
-     * @return Permission object
-     */
-    public static List<Permission> loadPermissions(Map<?, ?> data, String error, PermissionDefault def) {
-        List<Permission> result = new ArrayList<Permission>();
-
-        for (Map.Entry<?, ?> entry : data.entrySet()) {
-            try {
-                result.add(Permission.loadPermission(entry.getKey().toString(), (Map<?, ?>) entry.getValue(), def, result));
-            } catch (Throwable ex) {
-                Bukkit.getServer().getLogger().log(Level.SEVERE, String.format(error, entry.getKey()), ex);
-            }
-        }
-
-        return result;
-    }
-
-    /**
-     * Loads a Permission from a map of data, usually used from retrieval from
-     * a yaml file.
-     * <p>
-     * The data may contain the following keys:
-     * <ul>
-     * <li>default: Boolean true or false. If not specified, false.
-     * <li>children: {@code Map<String, Boolean>} of child permissions. If not
-     *     specified, empty list.
-     * <li>description: Short string containing a very small description of
-     *     this description. If not specified, empty string.
-     * </ul>
-     *
-     * @param name Name of the permission
-     * @param data Map of keys
-     * @return Permission object
-     */
-    public static Permission loadPermission(String name, Map<String, Object> data) {
-        return loadPermission(name, data, DEFAULT_PERMISSION, null);
-    }
-
-    /**
-     * Loads a Permission from a map of data, usually used from retrieval from
-     * a yaml file.
-     * <p>
-     * The data may contain the following keys:
-     * <ul>
-     * <li>default: Boolean true or false. If not specified, false.
-     * <li>children: {@code Map<String, Boolean>} of child permissions. If not
-     *     specified, empty list.
-     * <li>description: Short string containing a very small description of
-     *     this description. If not specified, empty string.
-     * </ul>
-     *
-     * @param name Name of the permission
-     * @param data Map of keys
-     * @param def Default permission value to use if not set
-     * @param output A list to append any created child-Permissions to, may be null
-     * @return Permission object
-     */
-    public static Permission loadPermission(String name, Map<?, ?> data, PermissionDefault def, List<Permission> output) {
-        Validate.notNull(name, "Name cannot be null");
-        Validate.notNull(data, "Data cannot be null");
-
-        String desc = null;
-        Map<String, Boolean> children = null;
-
-        if (data.get("default") != null) {
-            PermissionDefault value = PermissionDefault.getByName(data.get("default").toString());
-            if (value != null) {
-                def = value;
-            } else {
-                throw new IllegalArgumentException("'default' key contained unknown value");
-            }
-        }
-
-        if (data.get("children") != null) {
-            Object childrenNode = data.get("children");
-            if (childrenNode instanceof Iterable) {
-                children = new LinkedHashMap<String, Boolean>();
-                for (Object child : (Iterable<?>) childrenNode) {
-                    if (child != null) {
-                        children.put(child.toString(), Boolean.TRUE);
-                    }
-                }
-            } else if (childrenNode instanceof Map) {
-                children = extractChildren((Map<?,?>) childrenNode, name, def, output);
-            } else {
-                throw new IllegalArgumentException("'children' key is of wrong type");
-            }
-        }
-
-        if (data.get("description") != null) {
-            desc = data.get("description").toString();
-        }
-
-        return new Permission(name, desc, def, children);
-    }
-
-    private static Map<String, Boolean> extractChildren(Map<?, ?> input, String name, PermissionDefault def, List<Permission> output) {
-        Map<String, Boolean> children = new LinkedHashMap<String, Boolean>();
-
-        for (Map.Entry<?, ?> entry : input.entrySet()) {
-            if ((entry.getValue() instanceof Boolean)) {
-                children.put(entry.getKey().toString(), (Boolean) entry.getValue());
-            } else if ((entry.getValue() instanceof Map)) {
-                try {
-                    Permission perm = loadPermission(entry.getKey().toString(), (Map<?, ?>) entry.getValue(), def, output);
-                    children.put(perm.getName(), Boolean.TRUE);
-
-                    if (output != null) {
-                        output.add(perm);
-                    }
-                } catch (Throwable ex) {
-                    throw new IllegalArgumentException("Permission node '" + entry.getKey().toString() + "' in child of " + name + " is invalid", ex);
-                }
-            } else {
-                throw new IllegalArgumentException("Child '" + entry.getKey().toString() + "' contains invalid value");
-            }
-        }
-
-        return children;
-    }
-}
diff --git a/src/main/java/org/bukkit/permissions/PermissionAttachment.java b/src/main/java/org/bukkit/permissions/PermissionAttachment.java
deleted file mode 100644
index b2a44d5..0000000
--- a/src/main/java/org/bukkit/permissions/PermissionAttachment.java
+++ /dev/null
@@ -1,139 +0,0 @@
-package org.bukkit.permissions;
-
-import java.util.LinkedHashMap;
-import java.util.Map;
-import org.bukkit.plugin.Plugin;
-
-/**
- * Holds information about a permission attachment on a {@link Permissible}
- * object
- */
-public class PermissionAttachment {
-    private PermissionRemovedExecutor removed;
-    private final Map<String, Boolean> permissions = new LinkedHashMap<String, Boolean>();
-    private final Permissible permissible;
-    private final Plugin plugin;
-
-    public PermissionAttachment(Plugin plugin, Permissible Permissible) {
-        if (plugin == null) {
-            throw new IllegalArgumentException("Plugin cannot be null");
-        } else if (!plugin.isEnabled()) {
-            throw new IllegalArgumentException("Plugin " + plugin.getDescription().getFullName() + " is disabled");
-        }
-
-        this.permissible = Permissible;
-        this.plugin = plugin;
-    }
-
-    /**
-     * Gets the plugin responsible for this attachment
-     *
-     * @return Plugin responsible for this permission attachment
-     */
-    public Plugin getPlugin() {
-        return plugin;
-    }
-
-    /**
-     * Sets an object to be called for when this attachment is removed from a
-     * {@link Permissible}. May be null.
-     *
-     * @param ex Object to be called when this is removed
-     */
-    public void setRemovalCallback(PermissionRemovedExecutor ex) {
-        removed = ex;
-    }
-
-    /**
-     * Gets the class that was previously set to be called when this
-     * attachment was removed from a {@link Permissible}. May be null.
-     *
-     * @return Object to be called when this is removed
-     */
-    public PermissionRemovedExecutor getRemovalCallback() {
-        return removed;
-    }
-
-    /**
-     * Gets the Permissible that this is attached to
-     *
-     * @return Permissible containing this attachment
-     */
-    public Permissible getPermissible() {
-        return permissible;
-    }
-
-    /**
-     * Gets a copy of all set permissions and values contained within this
-     * attachment.
-     * <p>
-     * This map may be modified but will not affect the attachment, as it is a
-     * copy.
-     *
-     * @return Copy of all permissions and values expressed by this attachment
-     */
-    public Map<String, Boolean> getPermissions() {
-        return new LinkedHashMap<String, Boolean>(permissions);
-    }
-
-    /**
-     * Sets a permission to the given value, by its fully qualified name
-     *
-     * @param name Name of the permission
-     * @param value New value of the permission
-     */
-    public void setPermission(String name, boolean value) {
-        permissions.put(name.toLowerCase(), value);
-        permissible.recalculatePermissions();
-    }
-
-    /**
-     * Sets a permission to the given value
-     *
-     * @param perm Permission to set
-     * @param value New value of the permission
-     */
-    public void setPermission(Permission perm, boolean value) {
-        setPermission(perm.getName(), value);
-    }
-
-    /**
-     * Removes the specified permission from this attachment.
-     * <p>
-     * If the permission does not exist in this attachment, nothing will
-     * happen.
-     *
-     * @param name Name of the permission to remove
-     */
-    public void unsetPermission(String name) {
-        permissions.remove(name.toLowerCase());
-        permissible.recalculatePermissions();
-    }
-
-    /**
-     * Removes the specified permission from this attachment.
-     * <p>
-     * If the permission does not exist in this attachment, nothing will
-     * happen.
-     *
-     * @param perm Permission to remove
-     */
-    public void unsetPermission(Permission perm) {
-        unsetPermission(perm.getName());
-    }
-
-    /**
-     * Removes this attachment from its registered {@link Permissible}
-     *
-     * @return true if the permissible was removed successfully, false if it
-     *     did not exist
-     */
-    public boolean remove() {
-        try {
-            permissible.removeAttachment(this);
-            return true;
-        } catch (IllegalArgumentException ex) {
-            return false;
-        }
-    }
-}
diff --git a/src/main/java/org/bukkit/permissions/PermissionAttachmentInfo.java b/src/main/java/org/bukkit/permissions/PermissionAttachmentInfo.java
deleted file mode 100644
index 8e8e335..0000000
--- a/src/main/java/org/bukkit/permissions/PermissionAttachmentInfo.java
+++ /dev/null
@@ -1,62 +0,0 @@
-package org.bukkit.permissions;
-
-/**
- * Holds information on a permission and which {@link PermissionAttachment}
- * provides it
- */
-public class PermissionAttachmentInfo {
-    private final Permissible permissible;
-    private final String permission;
-    private final PermissionAttachment attachment;
-    private final boolean value;
-
-    public PermissionAttachmentInfo(Permissible permissible, String permission, PermissionAttachment attachment, boolean value) {
-        if (permissible == null) {
-            throw new IllegalArgumentException("Permissible may not be null");
-        } else if (permission == null) {
-            throw new IllegalArgumentException("Permissions may not be null");
-        }
-
-        this.permissible = permissible;
-        this.permission = permission;
-        this.attachment = attachment;
-        this.value = value;
-    }
-
-    /**
-     * Gets the permissible this is attached to
-     *
-     * @return Permissible this permission is for
-     */
-    public Permissible getPermissible() {
-        return permissible;
-    }
-
-    /**
-     * Gets the permission being set
-     *
-     * @return Name of the permission
-     */
-    public String getPermission() {
-        return permission;
-    }
-
-    /**
-     * Gets the attachment providing this permission. This may be null for
-     * default permissions (usually parent permissions).
-     *
-     * @return Attachment
-     */
-    public PermissionAttachment getAttachment() {
-        return attachment;
-    }
-
-    /**
-     * Gets the value of this permission
-     *
-     * @return Value of the permission
-     */
-    public boolean getValue() {
-        return value;
-    }
-}
diff --git a/src/main/java/org/bukkit/permissions/PermissionDefault.java b/src/main/java/org/bukkit/permissions/PermissionDefault.java
deleted file mode 100644
index 045e733..0000000
--- a/src/main/java/org/bukkit/permissions/PermissionDefault.java
+++ /dev/null
@@ -1,66 +0,0 @@
-package org.bukkit.permissions;
-
-import java.util.HashMap;
-import java.util.Map;
-
-/**
- * Represents the possible default values for permissions
- */
-public enum PermissionDefault {
-    TRUE("true"),
-    FALSE("false"),
-    OP("op", "isop", "operator", "isoperator", "admin", "isadmin"),
-    NOT_OP("!op", "notop", "!operator", "notoperator", "!admin", "notadmin");
-
-    private final String[] names;
-    private final static Map<String, PermissionDefault> lookup = new HashMap<String, PermissionDefault>();
-
-    private PermissionDefault(String... names) {
-        this.names = names;
-    }
-
-    /**
-     * Calculates the value of this PermissionDefault for the given operator
-     * value
-     *
-     * @param op If the target is op
-     * @return True if the default should be true, or false
-     */
-    public boolean getValue(boolean op) {
-        switch (this) {
-        case TRUE:
-            return true;
-        case FALSE:
-            return false;
-        case OP:
-            return op;
-        case NOT_OP:
-            return !op;
-        default:
-            return false;
-        }
-    }
-
-    /**
-     * Looks up a PermissionDefault by name
-     *
-     * @param name Name of the default
-     * @return Specified value, or null if not found
-     */
-    public static PermissionDefault getByName(String name) {
-        return lookup.get(name.toLowerCase().replaceAll("[^a-z!]", ""));
-    }
-
-    @Override
-    public String toString() {
-        return names[0];
-    }
-
-    static {
-        for (PermissionDefault value : values()) {
-            for (String name : value.names) {
-                lookup.put(name, value);
-            }
-        }
-    }
-}
diff --git a/src/main/java/org/bukkit/permissions/PermissionRemovedExecutor.java b/src/main/java/org/bukkit/permissions/PermissionRemovedExecutor.java
deleted file mode 100644
index b13d008..0000000
--- a/src/main/java/org/bukkit/permissions/PermissionRemovedExecutor.java
+++ /dev/null
@@ -1,16 +0,0 @@
-package org.bukkit.permissions;
-
-/**
- * Represents a class which is to be notified when a {@link
- * PermissionAttachment} is removed from a {@link Permissible}
- */
-public interface PermissionRemovedExecutor {
-
-    /**
-     * Called when a {@link PermissionAttachment} is removed from a {@link
-     * Permissible}
-     *
-     * @param attachment Attachment which was removed
-     */
-    public void attachmentRemoved(PermissionAttachment attachment);
-}
diff --git a/src/main/java/org/bukkit/permissions/ServerOperator.java b/src/main/java/org/bukkit/permissions/ServerOperator.java
deleted file mode 100644
index 26ed243..0000000
--- a/src/main/java/org/bukkit/permissions/ServerOperator.java
+++ /dev/null
@@ -1,24 +0,0 @@
-package org.bukkit.permissions;
-
-import org.bukkit.entity.Player;
-
-/**
- * Represents an object that may become a server operator, such as a {@link
- * Player}
- */
-public interface ServerOperator {
-
-    /**
-     * Checks if this object is a server operator
-     *
-     * @return true if this is an operator, otherwise false
-     */
-    public boolean isOp();
-
-    /**
-     * Sets the operator status of this object
-     *
-     * @param value New operator value
-     */
-    public void setOp(boolean value);
-}
diff --git a/src/main/java/org/bukkit/plugin/AuthorNagException.java b/src/main/java/org/bukkit/plugin/AuthorNagException.java
deleted file mode 100644
index 6565a44..0000000
--- a/src/main/java/org/bukkit/plugin/AuthorNagException.java
+++ /dev/null
@@ -1,20 +0,0 @@
-package org.bukkit.plugin;
-
-@SuppressWarnings("serial")
-public class AuthorNagException extends RuntimeException {
-    private final String message;
-
-    /**
-     * Constructs a new AuthorNagException based on the given Exception
-     *
-     * @param message Brief message explaining the cause of the exception
-     */
-    public AuthorNagException(final String message) {
-        this.message = message;
-    }
-
-    @Override
-    public String getMessage() {
-        return message;
-    }
-}
diff --git a/src/main/java/org/bukkit/plugin/EventExecutor.java b/src/main/java/org/bukkit/plugin/EventExecutor.java
deleted file mode 100644
index 3b2c99e..0000000
--- a/src/main/java/org/bukkit/plugin/EventExecutor.java
+++ /dev/null
@@ -1,12 +0,0 @@
-package org.bukkit.plugin;
-
-import org.bukkit.event.Event;
-import org.bukkit.event.EventException;
-import org.bukkit.event.Listener;
-
-/**
- * Interface which defines the class for event call backs to plugins
- */
-public interface EventExecutor {
-    public void execute(Listener listener, Event event) throws EventException;
-}
diff --git a/src/main/java/org/bukkit/plugin/IllegalPluginAccessException.java b/src/main/java/org/bukkit/plugin/IllegalPluginAccessException.java
deleted file mode 100644
index b25447d..0000000
--- a/src/main/java/org/bukkit/plugin/IllegalPluginAccessException.java
+++ /dev/null
@@ -1,25 +0,0 @@
-package org.bukkit.plugin;
-
-/**
- * Thrown when a plugin attempts to interact with the server when it is not
- * enabled
- */
-@SuppressWarnings("serial")
-public class IllegalPluginAccessException extends RuntimeException {
-
-    /**
-     * Creates a new instance of <code>IllegalPluginAccessException</code>
-     * without detail message.
-     */
-    public IllegalPluginAccessException() {}
-
-    /**
-     * Constructs an instance of <code>IllegalPluginAccessException</code>
-     * with the specified detail message.
-     *
-     * @param msg the detail message.
-     */
-    public IllegalPluginAccessException(String msg) {
-        super(msg);
-    }
-}
diff --git a/src/main/java/org/bukkit/plugin/InvalidDescriptionException.java b/src/main/java/org/bukkit/plugin/InvalidDescriptionException.java
deleted file mode 100644
index 0a77c2e..0000000
--- a/src/main/java/org/bukkit/plugin/InvalidDescriptionException.java
+++ /dev/null
@@ -1,45 +0,0 @@
-package org.bukkit.plugin;
-
-/**
- * Thrown when attempting to load an invalid PluginDescriptionFile
- */
-public class InvalidDescriptionException extends Exception {
-    private static final long serialVersionUID = 5721389122281775896L;
-
-    /**
-     * Constructs a new InvalidDescriptionException based on the given
-     * Exception
-     *
-     * @param message Brief message explaining the cause of the exception
-     * @param cause Exception that triggered this Exception
-     */
-    public InvalidDescriptionException(final Throwable cause, final String message) {
-        super(message, cause);
-    }
-
-    /**
-     * Constructs a new InvalidDescriptionException based on the given
-     * Exception
-     *
-     * @param cause Exception that triggered this Exception
-     */
-    public InvalidDescriptionException(final Throwable cause) {
-        super("Invalid plugin.yml", cause);
-    }
-
-    /**
-     * Constructs a new InvalidDescriptionException with the given message
-     *
-     * @param message Brief message explaining the cause of the exception
-     */
-    public InvalidDescriptionException(final String message) {
-        super(message);
-    }
-
-    /**
-     * Constructs a new InvalidDescriptionException
-     */
-    public InvalidDescriptionException() {
-        super("Invalid plugin.yml");
-    }
-}
diff --git a/src/main/java/org/bukkit/plugin/InvalidPluginException.java b/src/main/java/org/bukkit/plugin/InvalidPluginException.java
deleted file mode 100644
index 7ddf7b6..0000000
--- a/src/main/java/org/bukkit/plugin/InvalidPluginException.java
+++ /dev/null
@@ -1,49 +0,0 @@
-package org.bukkit.plugin;
-
-/**
- * Thrown when attempting to load an invalid Plugin file
- */
-public class InvalidPluginException extends Exception {
-    private static final long serialVersionUID = -8242141640709409544L;
-
-    /**
-     * Constructs a new InvalidPluginException based on the given Exception
-     *
-     * @param cause Exception that triggered this Exception
-     */
-    public InvalidPluginException(final Throwable cause) {
-        super(cause);
-    }
-
-    /**
-     * Constructs a new InvalidPluginException
-     */
-    public InvalidPluginException() {
-
-    }
-
-    /**
-     * Constructs a new InvalidPluginException with the specified detail
-     * message and cause.
-     *
-     * @param message the detail message (which is saved for later retrieval
-     *     by the getMessage() method).
-     * @param cause the cause (which is saved for later retrieval by the
-     *     getCause() method). (A null value is permitted, and indicates that
-     *     the cause is nonexistent or unknown.)
-     */
-    public InvalidPluginException(final String message, final Throwable cause) {
-        super(message, cause);
-    }
-
-    /**
-     * Constructs a new InvalidPluginException with the specified detail
-     * message
-     *
-     * @param message TThe detail message is saved for later retrieval by the
-     *     getMessage() method.
-     */
-    public InvalidPluginException(final String message) {
-        super(message);
-    }
-}
diff --git a/src/main/java/org/bukkit/plugin/Plugin.java b/src/main/java/org/bukkit/plugin/Plugin.java
deleted file mode 100644
index 7bdc809..0000000
--- a/src/main/java/org/bukkit/plugin/Plugin.java
+++ /dev/null
@@ -1,189 +0,0 @@
-package org.bukkit.plugin;
-
-import java.io.File;
-import java.io.InputStream;
-import java.util.logging.Logger;
-
-import org.bukkit.Server;
-import org.bukkit.command.TabExecutor;
-import org.bukkit.configuration.file.FileConfiguration;
-import org.bukkit.generator.ChunkGenerator;
-
-import com.avaje.ebean.EbeanServer;
-
-/**
- * Represents a Plugin
- * <p>
- * The use of {@link PluginBase} is recommended for actual Implementation
- */
-public interface Plugin extends TabExecutor {
-    /**
-     * Returns the folder that the plugin data's files are located in. The
-     * folder may not yet exist.
-     *
-     * @return The folder
-     */
-    public File getDataFolder();
-
-    /**
-     * Returns the plugin.yaml file containing the details for this plugin
-     *
-     * @return Contents of the plugin.yaml file
-     */
-    public PluginDescriptionFile getDescription();
-
-    /**
-     * Gets a {@link FileConfiguration} for this plugin, read through
-     * "config.yml"
-     * <p>
-     * If there is a default config.yml embedded in this plugin, it will be
-     * provided as a default for this Configuration.
-     *
-     * @return Plugin configuration
-     */
-    public FileConfiguration getConfig();
-
-    /**
-     * Gets an embedded resource in this plugin
-     *
-     * @param filename Filename of the resource
-     * @return File if found, otherwise null
-     */
-    public InputStream getResource(String filename);
-
-    /**
-     * Saves the {@link FileConfiguration} retrievable by {@link #getConfig()}.
-     */
-    public void saveConfig();
-
-    /**
-     * Saves the raw contents of the default config.yml file to the location
-     * retrievable by {@link #getConfig()}. If there is no default config.yml
-     * embedded in the plugin, an empty config.yml file is saved. This should
-     * fail silently if the config.yml already exists.
-     */
-    public void saveDefaultConfig();
-
-    /**
-     * Saves the raw contents of any resource embedded with a plugin's .jar
-     * file assuming it can be found using {@link #getResource(String)}.
-     * <p>
-     * The resource is saved into the plugin's data folder using the same
-     * hierarchy as the .jar file (subdirectories are preserved).
-     *
-     * @param resourcePath the embedded resource path to look for within the
-     *     plugin's .jar file. (No preceding slash).
-     * @param replace if true, the embedded resource will overwrite the
-     *     contents of an existing file.
-     * @throws IllegalArgumentException if the resource path is null, empty,
-     *     or points to a nonexistent resource.
-     */
-    public void saveResource(String resourcePath, boolean replace);
-
-    /**
-     * Discards any data in {@link #getConfig()} and reloads from disk.
-     */
-    public void reloadConfig();
-
-    /**
-     * Gets the associated PluginLoader responsible for this plugin
-     *
-     * @return PluginLoader that controls this plugin
-     */
-    public PluginLoader getPluginLoader();
-
-    /**
-     * Returns the Server instance currently running this plugin
-     *
-     * @return Server running this plugin
-     */
-    public Server getServer();
-
-    /**
-     * Returns a value indicating whether or not this plugin is currently
-     * enabled
-     *
-     * @return true if this plugin is enabled, otherwise false
-     */
-    public boolean isEnabled();
-
-    /**
-     * Called when this plugin is disabled
-     */
-    public void onDisable();
-
-    /**
-     * Called after a plugin is loaded but before it has been enabled.
-     * <p>
-     * When mulitple plugins are loaded, the onLoad() for all plugins is
-     * called before any onEnable() is called.
-     */
-    public void onLoad();
-
-    /**
-     * Called when this plugin is enabled
-     */
-    public void onEnable();
-
-    /**
-     * Simple boolean if we can still nag to the logs about things
-     *
-     * @return boolean whether we can nag
-     */
-    public boolean isNaggable();
-
-    /**
-     * Set naggable state
-     *
-     * @param canNag is this plugin still naggable?
-     */
-    public void setNaggable(boolean canNag);
-
-    /**
-     * Gets the {@link EbeanServer} tied to this plugin. This will only be
-     * available if enabled in the {@link
-     * PluginDescriptionFile#isDatabaseEnabled()}
-     * <p>
-     * <i>For more information on the use of <a href="http://www.avaje.org/">
-     * Avaje Ebeans ORM</a>, see <a
-     * href="http://www.avaje.org/ebean/documentation.html">Avaje Ebeans
-     * Documentation</a></i>
-     * <p>
-     * <i>For an example using Ebeans ORM, see <a
-     * href="https://github.com/Bukkit/HomeBukkit">Bukkit's Homebukkit Plugin
-     * </a></i>
-     *
-     * @return ebean server instance or null if not enabled
-     */
-    public EbeanServer getDatabase();
-
-    /**
-     * Gets a {@link ChunkGenerator} for use in a default world, as specified
-     * in the server configuration
-     *
-     * @param worldName Name of the world that this will be applied to
-     * @param id Unique ID, if any, that was specified to indicate which
-     *     generator was requested
-     * @return ChunkGenerator for use in the default world generation
-     */
-    public ChunkGenerator getDefaultWorldGenerator(String worldName, String id);
-
-    /**
-     * Returns the plugin logger associated with this server's logger. The
-     * returned logger automatically tags all log messages with the plugin's
-     * name.
-     *
-     * @return Logger associated with this plugin
-     */
-    public Logger getLogger();
-
-    /**
-     * Returns the name of the plugin.
-     * <p>
-     * This should return the bare name of the plugin and should be used for
-     * comparison.
-     *
-     * @return name of the plugin
-     */
-    public String getName();
-}
diff --git a/src/main/java/org/bukkit/plugin/PluginAwareness.java b/src/main/java/org/bukkit/plugin/PluginAwareness.java
deleted file mode 100644
index 3f535ed..0000000
--- a/src/main/java/org/bukkit/plugin/PluginAwareness.java
+++ /dev/null
@@ -1,28 +0,0 @@
-package org.bukkit.plugin;
-
-import java.util.Set;
-
-/**
- * Represents a concept that a plugin is aware of.
- * <p>
- * The internal representation may be singleton, or be a parameterized
- * instance, but must be immutable.
- */
-public interface PluginAwareness {
-    /**
-     * Each entry here represents a particular plugin's awareness. These can
-     * be checked by using {@link PluginDescriptionFile#getAwareness()}.{@link
-     * Set#contains(Object) contains(flag)}.
-     */
-    public enum Flags implements PluginAwareness {
-        /**
-         * This specifies that all (text) resources stored in a plugin's jar
-         * use UTF-8 encoding.
-         *
-         * @deprecated all plugins are now assumed to be UTF-8 aware.
-         */
-        @Deprecated
-        UTF8,
-        ;
-    }
-}
diff --git a/src/main/java/org/bukkit/plugin/PluginBase.java b/src/main/java/org/bukkit/plugin/PluginBase.java
deleted file mode 100644
index 6031af1..0000000
--- a/src/main/java/org/bukkit/plugin/PluginBase.java
+++ /dev/null
@@ -1,32 +0,0 @@
-package org.bukkit.plugin;
-
-/**
- * Represents a base {@link Plugin}
- * <p>
- * Extend this class if your plugin is not a {@link
- * org.bukkit.plugin.java.JavaPlugin}
- */
-public abstract class PluginBase implements Plugin {
-    @Override
-    public final int hashCode() {
-        return getName().hashCode();
-    }
-
-    @Override
-    public final boolean equals(Object obj) {
-        if (this == obj) {
-            return true;
-        }
-        if (obj == null) {
-            return false;
-        }
-        if (!(obj instanceof Plugin)) {
-            return false;
-        }
-        return getName().equals(((Plugin) obj).getName());
-    }
-
-    public final String getName() {
-        return getDescription().getName();
-    }
-}
diff --git a/src/main/java/org/bukkit/plugin/PluginDescriptionFile.java b/src/main/java/org/bukkit/plugin/PluginDescriptionFile.java
deleted file mode 100644
index c82928e..0000000
--- a/src/main/java/org/bukkit/plugin/PluginDescriptionFile.java
+++ /dev/null
@@ -1,1116 +0,0 @@
-package org.bukkit.plugin;
-
-import java.io.InputStream;
-import java.io.Reader;
-import java.io.Writer;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import org.bukkit.command.CommandExecutor;
-import org.bukkit.command.PluginCommand;
-import org.bukkit.plugin.java.JavaPlugin;
-import org.bukkit.permissions.Permissible;
-import org.bukkit.permissions.Permission;
-import org.bukkit.permissions.PermissionDefault;
-import org.yaml.snakeyaml.Yaml;
-import org.yaml.snakeyaml.constructor.AbstractConstruct;
-import org.yaml.snakeyaml.constructor.SafeConstructor;
-import org.yaml.snakeyaml.nodes.Node;
-import org.yaml.snakeyaml.nodes.Tag;
-
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.ImmutableSet;
-
-/**
- * This type is the runtime-container for the information in the plugin.yml.
- * All plugins must have a respective plugin.yml. For plugins written in java
- * using the standard plugin loader, this file must be in the root of the jar
- * file.
- * <p>
- * When Bukkit loads a plugin, it needs to know some basic information about
- * it. It reads this information from a YAML file, 'plugin.yml'. This file
- * consists of a set of attributes, each defined on a new line and with no
- * indentation.
- * <p>
- * Every (almost* every) method corresponds with a specific entry in the
- * plugin.yml. These are the <b>required</b> entries for every plugin.yml:
- * <ul>
- * <li>{@link #getName()} - <code>name</code>
- * <li>{@link #getVersion()} - <code>version</code>
- * <li>{@link #getMain()} - <code>main</code>
- * </ul>
- * <p>
- * Failing to include any of these items will throw an exception and cause the
- * server to ignore your plugin.
- * <p>
- * This is a list of the possible yaml keys, with specific details included in
- * the respective method documentations:
- * <table border=1>
- * <caption>The description of the plugin.yml layout</caption>
- * <tr>
- *     <th>Node</th>
- *     <th>Method</th>
- *     <th>Summary</th>
- * </tr><tr>
- *     <td><code>name</code></td>
- *     <td>{@link #getName()}</td>
- *     <td>The unique name of plugin</td>
- * </tr><tr>
- *     <td><code>version</code></td>
- *     <td>{@link #getVersion()}</td>
- *     <td>A plugin revision identifier</td>
- * </tr><tr>
- *     <td><code>main</code></td>
- *     <td>{@link #getMain()}</td>
- *     <td>The plugin's initial class file</td>
- * </tr><tr>
- *     <td><code>author</code><br><code>authors</code></td>
- *     <td>{@link #getAuthors()}</td>
- *     <td>The plugin contributors</td>
- * </tr><tr>
- *     <td><code>description</code></td>
- *     <td>{@link #getDescription()}</td>
- *     <td>Human readable plugin summary</td>
- * </tr><tr>
- *     <td><code>website</code></td>
- *     <td>{@link #getWebsite()}</td>
- *     <td>The URL to the plugin's site</td>
- * </tr><tr>
- *     <td><code>prefix</code></td>
- *     <td>{@link #getPrefix()}</td>
- *     <td>The token to prefix plugin log entries</td>
- * </tr><tr>
- *     <td><code>database</code></td>
- *     <td>{@link #isDatabaseEnabled()}</td>
- *     <td>Indicator to enable database support</td>
- * </tr><tr>
- *     <td><code>load</code></td>
- *     <td>{@link #getLoad()}</td>
- *     <td>The phase of server-startup this plugin will load during</td>
- * </tr><tr>
- *     <td><code>depend</code></td>
- *     <td>{@link #getDepend()}</td>
- *     <td>Other required plugins</td>
- * </tr><tr>
- *     <td><code>softdepend</code></td>
- *     <td>{@link #getSoftDepend()}</td>
- *     <td>Other plugins that add functionality</td>
- * </tr><tr>
- *     <td><code>loadbefore</code></td>
- *     <td>{@link #getLoadBefore()}</td>
- *     <td>The inverse softdepend</td>
- * </tr><tr>
- *     <td><code>commands</code></td>
- *     <td>{@link #getCommands()}</td>
- *     <td>The commands the plugin will register</td>
- * </tr><tr>
- *     <td><code>permissions</code></td>
- *     <td>{@link #getPermissions()}</td>
- *     <td>The permissions the plugin will register</td>
- * </tr><tr>
- *     <td><code>default-permission</code></td>
- *     <td>{@link #getPermissionDefault()}</td>
- *     <td>The default {@link Permission#getDefault() default} permission
- *         state for defined {@link #getPermissions() permissions} the plugin
- *         will register</td>
- * </tr><tr>
- *     <td><code>awareness</code></td>
- *     <td>{@link #getAwareness()}</td>
- *     <td>The concepts that the plugin acknowledges</td>
- * </tr>
- * </table>
- * <p>
- * A plugin.yml example:<blockquote><pre>
- *name: Inferno
- *version: 1.4.1
- *description: This plugin is so 31337. You can set yourself on fire.
- *# We could place every author in the authors list, but chose not to for illustrative purposes
- *# Also, having an author distinguishes that person as the project lead, and ensures their
- *# name is displayed first
- *author: CaptainInflamo
- *authors: [Cogito, verrier, EvilSeph]
- *website: http://www.curse.com/server-mods/minecraft/myplugin
- *
- *main: com.captaininflamo.bukkit.inferno.Inferno
- *database: false
- *depend: [NewFire, FlameWire]
- *
- *commands:
- *  flagrate:
- *    description: Set yourself on fire.
- *    aliases: [combust_me, combustMe]
- *    permission: inferno.flagrate
- *    usage: Syntax error! Simply type /&lt;command&gt; to ignite yourself.
- *  burningdeaths:
- *    description: List how many times you have died by fire.
- *    aliases: [burning_deaths, burningDeaths]
- *    permission: inferno.burningdeaths
- *    usage: |
- *      /&lt;command&gt; [player]
- *      Example: /&lt;command&gt; - see how many times you have burned to death
- *      Example: /&lt;command&gt; CaptainIce - see how many times CaptainIce has burned to death
- *
- *permissions:
- *  inferno.*:
- *    description: Gives access to all Inferno commands
- *    children:
- *      inferno.flagrate: true
- *      inferno.burningdeaths: true
- *      inferno.burningdeaths.others: true
- *  inferno.flagrate:
- *    description: Allows you to ignite yourself
- *    default: true
- *  inferno.burningdeaths:
- *    description: Allows you to see how many times you have burned to death
- *    default: true
- *  inferno.burningdeaths.others:
- *    description: Allows you to see how many times others have burned to death
- *    default: op
- *    children:
- *      inferno.burningdeaths: true
- *</pre></blockquote>
- */
-public final class PluginDescriptionFile {
-    private static final ThreadLocal<Yaml> YAML = new ThreadLocal<Yaml>() {
-        @Override
-        protected Yaml initialValue() {
-            return new Yaml(new SafeConstructor() {
-                {
-                    yamlConstructors.put(null, new AbstractConstruct() {
-                        @Override
-                        public Object construct(final Node node) {
-                            if (!node.getTag().startsWith("!@")) {
-                                // Unknown tag - will fail
-                                return SafeConstructor.undefinedConstructor.construct(node);
-                            }
-                            // Unknown awareness - provide a graceful substitution
-                            return new PluginAwareness() {
-                                @Override
-                                public String toString() {
-                                    return node.toString();
-                                }
-                            };
-                        }
-                    });
-                    for (final PluginAwareness.Flags flag : PluginAwareness.Flags.values()) {
-                        yamlConstructors.put(new Tag("!@" + flag.name()), new AbstractConstruct() {
-                            @Override
-                            public PluginAwareness.Flags construct(final Node node) {
-                                return flag;
-                            }
-                        });
-                    }
-                }
-            });
-        }
-    };
-    String rawName = null;
-    private String name = null;
-    private String main = null;
-    private String classLoaderOf = null;
-    private List<String> depend = ImmutableList.of();
-    private List<String> softDepend = ImmutableList.of();
-    private List<String> loadBefore = ImmutableList.of();
-    private String version = null;
-    private Map<String, Map<String, Object>> commands = null;
-    private String description = null;
-    private List<String> authors = null;
-    private String website = null;
-    private String prefix = null;
-    private boolean database = false;
-    private PluginLoadOrder order = PluginLoadOrder.POSTWORLD;
-    private List<Permission> permissions = null;
-    private Map<?, ?> lazyPermissions = null;
-    private PermissionDefault defaultPerm = PermissionDefault.OP;
-    private Set<PluginAwareness> awareness = ImmutableSet.of();
-
-    public PluginDescriptionFile(final InputStream stream) throws InvalidDescriptionException {
-        loadMap(asMap(YAML.get().load(stream)));
-    }
-
-    /**
-     * Loads a PluginDescriptionFile from the specified reader
-     *
-     * @param reader The reader
-     * @throws InvalidDescriptionException If the PluginDescriptionFile is
-     *     invalid
-     */
-    public PluginDescriptionFile(final Reader reader) throws InvalidDescriptionException {
-        loadMap(asMap(YAML.get().load(reader)));
-    }
-
-    /**
-     * Creates a new PluginDescriptionFile with the given detailed
-     *
-     * @param pluginName Name of this plugin
-     * @param pluginVersion Version of this plugin
-     * @param mainClass Full location of the main class of this plugin
-     */
-    public PluginDescriptionFile(final String pluginName, final String pluginVersion, final String mainClass) {
-        name = pluginName.replace(' ', '_');
-        version = pluginVersion;
-        main = mainClass;
-    }
-
-    /**
-     * Gives the name of the plugin. This name is a unique identifier for
-     * plugins.
-     * <ul>
-     * <li>Must consist of all alphanumeric characters, underscores, hyphon,
-     *     and period (a-z,A-Z,0-9, _.-). Any other character will cause the
-     *     plugin.yml to fail loading.
-     * <li>Used to determine the name of the plugin's data folder. Data
-     *     folders are placed in the ./plugins/ directory by default, but this
-     *     behavior should not be relied on. {@link Plugin#getDataFolder()}
-     *     should be used to reference the data folder.
-     * <li>It is good practice to name your jar the same as this, for example
-     *     'MyPlugin.jar'.
-     * <li>Case sensitive.
-     * <li>The is the token referenced in {@link #getDepend()}, {@link
-     *     #getSoftDepend()}, and {@link #getLoadBefore()}.
-     * <li>Using spaces in the plugin's name is deprecated.
-     * </ul>
-     * <p>
-     * In the plugin.yml, this entry is named <code>name</code>.
-     * <p>
-     * Example:<blockquote><pre>name: MyPlugin</pre></blockquote>
-     *
-     * @return the name of the plugin
-     */
-    public String getName() {
-        return name;
-    }
-
-    /**
-     * Gives the version of the plugin.
-     * <ul>
-     * <li>Version is an arbitrary string, however the most common format is
-     *     MajorRelease.MinorRelease.Build (eg: 1.4.1).
-     * <li>Typically you will increment this every time you release a new
-     *     feature or bug fix.
-     * <li>Displayed when a user types <code>/version PluginName</code>
-     * </ul>
-     * <p>
-     * In the plugin.yml, this entry is named <code>version</code>.
-     * <p>
-     * Example:<blockquote><pre>version: 1.4.1</pre></blockquote>
-     *
-     * @return the version of the plugin
-     */
-    public String getVersion() {
-        return version;
-    }
-
-    /**
-     * Gives the fully qualified name of the main class for a plugin. The
-     * format should follow the {@link ClassLoader#loadClass(String)} syntax
-     * to successfully be resolved at runtime. For most plugins, this is the
-     * class that extends {@link JavaPlugin}.
-     * <ul>
-     * <li>This must contain the full namespace including the class file
-     *     itself.
-     * <li>If your namespace is <code>org.bukkit.plugin</code>, and your class
-     *     file is called <code>MyPlugin</code> then this must be
-     *     <code>org.bukkit.plugin.MyPlugin</code>
-     * <li>No plugin can use <code>org.bukkit.</code> as a base package for
-     *     <b>any class</b>, including the main class.
-     * </ul>
-     * <p>
-     * In the plugin.yml, this entry is named <code>main</code>.
-     * <p>
-     * Example:
-     * <blockquote><pre>main: org.bukkit.plugin.MyPlugin</pre></blockquote>
-     *
-     * @return the fully qualified main class for the plugin
-     */
-    public String getMain() {
-        return main;
-    }
-
-    /**
-     * Gives a human-friendly description of the functionality the plugin
-     * provides.
-     * <ul>
-     * <li>The description can have multiple lines.
-     * <li>Displayed when a user types <code>/version PluginName</code>
-     * </ul>
-     * <p>
-     * In the plugin.yml, this entry is named <code>description</code>.
-     * <p>
-     * Example:
-     * <blockquote><pre>description: This plugin is so 31337. You can set yourself on fire.</pre></blockquote>
-     *
-     * @return description of this plugin, or null if not specified
-     */
-    public String getDescription() {
-        return description;
-    }
-
-    /**
-     * Gives the phase of server startup that the plugin should be loaded.
-     * <ul>
-     * <li>Possible values are in {@link PluginLoadOrder}.
-     * <li>Defaults to {@link PluginLoadOrder#POSTWORLD}.
-     * <li>Certain caveats apply to each phase.
-     * <li>When different, {@link #getDepend()}, {@link #getSoftDepend()}, and
-     *     {@link #getLoadBefore()} become relative in order loaded per-phase.
-     *     If a plugin loads at <code>STARTUP</code>, but a dependency loads
-     *     at <code>POSTWORLD</code>, the dependency will not be loaded before
-     *     the plugin is loaded.
-     * </ul>
-     * <p>
-     * In the plugin.yml, this entry is named <code>load</code>.
-     * <p>
-     * Example:<blockquote><pre>load: STARTUP</pre></blockquote>
-     *
-     * @return the phase when the plugin should be loaded
-     */
-    public PluginLoadOrder getLoad() {
-        return order;
-    }
-
-    /**
-     * Gives the list of authors for the plugin.
-     * <ul>
-     * <li>Gives credit to the developer.
-     * <li>Used in some server error messages to provide helpful feedback on
-     *     who to contact when an error occurs.
-     * <li>A bukkit.org forum handle or email address is recommended.
-     * <li>Is displayed when a user types <code>/version PluginName</code>
-     * <li><code>authors</code> must be in <a
-     *     href="http://en.wikipedia.org/wiki/YAML#Lists">YAML list
-     *     format</a>.
-     * </ul>
-     * <p>
-     * In the plugin.yml, this has two entries, <code>author</code> and
-     * <code>authors</code>.
-     * <p>
-     * Single author example:
-     * <blockquote><pre>author: CaptainInflamo</pre></blockquote>
-     * Multiple author example:
-     * <blockquote><pre>authors: [Cogito, verrier, EvilSeph]</pre></blockquote>
-     * When both are specified, author will be the first entry in the list, so
-     * this example:
-     * <blockquote><pre>author: Grum
-     *authors:
-     *- feildmaster
-     *- amaranth</pre></blockquote>
-     * Is equivilant to this example:
-     * <pre>authors: [Grum, feildmaster, aramanth]</pre>
-     *
-     * @return an immutable list of the plugin's authors
-     */
-    public List<String> getAuthors() {
-        return authors;
-    }
-
-    /**
-     * Gives the plugin's or plugin's author's website.
-     * <ul>
-     * <li>A link to the Curse page that includes documentation and downloads
-     *     is highly recommended.
-     * <li>Displayed when a user types <code>/version PluginName</code>
-     * </ul>
-     * <p>
-     * In the plugin.yml, this entry is named <code>website</code>.
-     * <p>
-     * Example:
-     * <blockquote><pre>website: http://www.curse.com/server-mods/minecraft/myplugin</pre></blockquote>
-     *
-     * @return description of this plugin, or null if not specified
-     */
-    public String getWebsite() {
-        return website;
-    }
-
-    /**
-     * Gives if the plugin uses a database.
-     * <ul>
-     * <li>Using a database is non-trivial.
-     * <li>Valid values include <code>true</code> and <code>false</code>
-     * </ul>
-     * <p>
-     * In the plugin.yml, this entry is named <code>database</code>.
-     * <p>
-     * Example:
-     * <blockquote><pre>database: false</pre></blockquote>
-     *
-     * @return if this plugin requires a database
-     * @see Plugin#getDatabase()
-     */
-    public boolean isDatabaseEnabled() {
-        return database;
-    }
-
-    /**
-     * Gives a list of other plugins that the plugin requires.
-     * <ul>
-     * <li>Use the value in the {@link #getName()} of the target plugin to
-     *     specify the dependency.
-     * <li>If any plugin listed here is not found, your plugin will fail to
-     *     load at startup.
-     * <li>If multiple plugins list each other in <code>depend</code>,
-     *     creating a network with no individual plugin does not list another
-     *     plugin in the <a
-     *     href=https://en.wikipedia.org/wiki/Circular_dependency>network</a>,
-     *     all plugins in that network will fail.
-     * <li><code>depend</code> must be in must be in <a
-     *     href="http://en.wikipedia.org/wiki/YAML#Lists">YAML list
-     *     format</a>.
-     * </ul>
-     * <p>
-     * In the plugin.yml, this entry is named <code>depend</code>.
-     * <p>
-     * Example:
-     * <blockquote><pre>depend:
-     *- OnePlugin
-     *- AnotherPlugin</pre></blockquote>
-     *
-     * @return immutable list of the plugin's dependencies
-     */
-    public List<String> getDepend() {
-        return depend;
-    }
-
-    /**
-     * Gives a list of other plugins that the plugin requires for full
-     * functionality. The {@link PluginManager} will make best effort to treat
-     * all entries here as if they were a {@link #getDepend() dependency}, but
-     * will never fail because of one of these entries.
-     * <ul>
-     * <li>Use the value in the {@link #getName()} of the target plugin to
-     *     specify the dependency.
-     * <li>When an unresolvable plugin is listed, it will be ignored and does
-     *     not affect load order.
-     * <li>When a circular dependency occurs (a network of plugins depending
-     *     or soft-dependending each other), it will arbitrarily choose a
-     *     plugin that can be resolved when ignoring soft-dependencies.
-     * <li><code>softdepend</code> must be in <a
-     *     href="http://en.wikipedia.org/wiki/YAML#Lists">YAML list
-     *     format</a>.
-     * </ul>
-     * <p>
-     * In the plugin.yml, this entry is named <code>softdepend</code>.
-     * <p>
-     * Example:
-     * <blockquote><pre>softdepend: [OnePlugin, AnotherPlugin]</pre></blockquote>
-     *
-     * @return immutable list of the plugin's preferred dependencies
-     */
-    public List<String> getSoftDepend() {
-        return softDepend;
-    }
-
-    /**
-     * Gets the list of plugins that should consider this plugin a
-     * soft-dependency.
-     * <ul>
-     * <li>Use the value in the {@link #getName()} of the target plugin to
-     *     specify the dependency.
-     * <li>The plugin should load before any other plugins listed here.
-     * <li>Specifying another plugin here is strictly equivalent to having the
-     *     specified plugin's {@link #getSoftDepend()} include {@link
-     *     #getName() this plugin}.
-     * <li><code>loadbefore</code> must be in <a
-     *     href="http://en.wikipedia.org/wiki/YAML#Lists">YAML list
-     *     format</a>.
-     * </ul>
-     * <p>
-     * In the plugin.yml, this entry is named <code>loadbefore</code>.
-     * <p>
-     * Example:
-     * <blockquote><pre>loadbefore:
-     *- OnePlugin
-     *- AnotherPlugin</pre></blockquote>
-     *
-     * @return immutable list of plugins that should consider this plugin a
-     *     soft-dependency
-     */
-    public List<String> getLoadBefore() {
-        return loadBefore;
-    }
-
-    /**
-     * Gives the token to prefix plugin-specific logging messages with.
-     * <ul>
-     * <li>This includes all messages using {@link Plugin#getLogger()}.
-     * <li>If not specified, the server uses the plugin's {@link #getName()
-     *     name}.
-     * <li>This should clearly indicate what plugin is being logged.
-     * </ul>
-     * <p>
-     * In the plugin.yml, this entry is named <code>prefix</code>.
-     * <p>
-     * Example:<blockquote><pre>prefix: ex-why-zee</pre></blockquote>
-     *
-     * @return the prefixed logging token, or null if not specified
-     */
-    public String getPrefix() {
-        return prefix;
-    }
-
-    /**
-     * Gives the map of command-name to command-properties. Each entry in this
-     * map corresponds to a single command and the respective values are the
-     * properties of the command. Each property, <i>with the exception of
-     * aliases</i>, can be defined at runtime using methods in {@link
-     * PluginCommand} and are defined here only as a convenience.
-     * <table border=1>
-     * <caption>The command section's description</caption>
-     * <tr>
-     *     <th>Node</th>
-     *     <th>Method</th>
-     *     <th>Type</th>
-     *     <th>Description</th>
-     *     <th>Example</th>
-     * </tr><tr>
-     *     <td><code>description</code></td>
-     *     <td>{@link PluginCommand#setDescription(String)}</td>
-     *     <td>String</td>
-     *     <td>A user-friendly description for a command. It is useful for
-     *         documentation purposes as well as in-game help.</td>
-     *     <td><blockquote><pre>description: Set yourself on fire</pre></blockquote></td>
-     * </tr><tr>
-     *     <td><code>aliases</code></td>
-     *     <td>{@link PluginCommand#setAliases(List)}</td>
-     *     <td>String or <a
-     *         href="http://en.wikipedia.org/wiki/YAML#Lists">List</a> of
-     *         strings</td>
-     *     <td>Alternative command names, with special usefulness for commands
-     *         that are already registered. <i>Aliases are not effective when
-     *         defined at runtime,</i> so the plugin description file is the
-     *         only way to have them properly defined.
-     *         <p>
-     *         Note: Command aliases may not have a colon in them.</td>
-     *     <td>Single alias format:
-     *         <blockquote><pre>aliases: combust_me</pre></blockquote> or
-     *         multiple alias format:
-     *         <blockquote><pre>aliases: [combust_me, combustMe]</pre></blockquote></td>
-     * </tr><tr>
-     *     <td><code>permission</code></td>
-     *     <td>{@link PluginCommand#setPermission(String)}</td>
-     *     <td>String</td>
-     *     <td>The name of the {@link Permission} required to use the command.
-     *         A user without the permission will receive the specified
-     *         message (see {@linkplain
-     *         PluginCommand#setPermissionMessage(String) below}), or a
-     *         standard one if no specific message is defined. Without the
-     *         permission node, no {@link
-     *         PluginCommand#setExecutor(CommandExecutor) CommandExecutor} or
-     *         {@link PluginCommand#setTabCompleter(TabCompleter)
-     *         TabCompleter} will be called.</td>
-     *     <td><blockquote><pre>permission: inferno.flagrate</pre></blockquote></td>
-     * </tr><tr>
-     *     <td><code>permission-message</code></td>
-     *     <td>{@link PluginCommand#setPermissionMessage(String)}</td>
-     *     <td>String</td>
-     *     <td><ul>
-     *         <li>Displayed to a player that attempts to use a command, but
-     *             does not have the required permission. See {@link
-     *             PluginCommand#getPermission() above}.
-     *         <li>&lt;permission&gt; is a macro that is replaced with the
-     *             permission node required to use the command.
-     *         <li>Using empty quotes is a valid way to indicate nothing
-     *             should be displayed to a player.
-     *         </ul></td>
-     *     <td><blockquote><pre>permission-message: You do not have /&lt;permission&gt;</pre></blockquote></td>
-     * </tr><tr>
-     *     <td><code>usage</code></td>
-     *     <td>{@link PluginCommand#setUsage(String)}</td>
-     *     <td>String</td>
-     *     <td>This message is displayed to a player when the {@link
-     *         PluginCommand#setExecutor(CommandExecutor)} {@linkplain
-     *         CommandExecutor#onCommand(CommandSender,Command,String,String[])
-     *         returns false}. &lt;command&gt; is a macro that is replaced
-     *         the command issued.</td>
-     *     <td><blockquote><pre>usage: Syntax error! Perhaps you meant /&lt;command&gt; PlayerName?</pre></blockquote>
-     *         It is worth noting that to use a colon in a yaml, like
-     *         <code>`usage: Usage: /god [player]'</code>, you need to
-     *         <a href="http://yaml.org/spec/current.html#id2503232">surround
-     *         the message with double-quote</a>:
-     *         <blockquote><pre>usage: "Usage: /god [player]"</pre></blockquote></td>
-     * </tr>
-     * </table>
-     * The commands are structured as a hiearchy of <a
-     * href="http://yaml.org/spec/current.html#id2502325">nested mappings</a>.
-     * The primary (top-level, no intendentation) node is
-     * `<code>commands</code>', while each individual command name is
-     * indented, indicating it maps to some value (in our case, the
-     * properties of the table above).
-     * <p>
-     * Here is an example bringing together the piecemeal examples above, as
-     * well as few more definitions:<blockquote><pre>
-     *commands:
-     *  flagrate:
-     *    description: Set yourself on fire.
-     *    aliases: [combust_me, combustMe]
-     *    permission: inferno.flagrate
-     *    permission-message: You do not have /&lt;permission&gt;
-     *    usage: Syntax error! Perhaps you meant /&lt;command&gt; PlayerName?
-     *  burningdeaths:
-     *    description: List how many times you have died by fire.
-     *    aliases:
-     *    - burning_deaths
-     *    - burningDeaths
-     *    permission: inferno.burningdeaths
-     *    usage: |
-     *      /&lt;command&gt; [player]
-     *      Example: /&lt;command&gt; - see how many times you have burned to death
-     *      Example: /&lt;command&gt; CaptainIce - see how many times CaptainIce has burned to death
-     *  # The next command has no description, aliases, etc. defined, but is still valid
-     *  # Having an empty declaration is useful for defining the description, permission, and messages from a configuration dynamically
-     *  apocalypse:
-     *</pre></blockquote>
-     * Note: Command names may not have a colon in their name.
-     *
-     * @return the commands this plugin will register
-     */
-    public Map<String, Map<String, Object>> getCommands() {
-        return commands;
-    }
-
-    /**
-     * Gives the list of permissions the plugin will register at runtime,
-     * immediately proceding enabling. The format for defining permissions is
-     * a map from permission name to properties. To represent a map without
-     * any specific property, empty <a
-     * href="http://yaml.org/spec/current.html#id2502702">curly-braces</a> (
-     * <code>&#123;&#125;</code> ) may be used (as a null value is not
-     * accepted, unlike the {@link #getCommands() commands} above).
-     * <p>
-     * A list of optional properties for permissions:
-     * <table border=1>
-     * <caption>The permission section's description</caption>
-     * <tr>
-     *     <th>Node</th>
-     *     <th>Description</th>
-     *     <th>Example</th>
-     * </tr><tr>
-     *     <td><code>description</code></td>
-     *     <td>Plaintext (user-friendly) description of what the permission
-     *         is for.</td>
-     *     <td><blockquote><pre>description: Allows you to set yourself on fire</pre></blockquote></td>
-     * </tr><tr>
-     *     <td><code>default</code></td>
-     *     <td>The default state for the permission, as defined by {@link
-     *         Permission#getDefault()}. If not defined, it will be set to
-     *         the value of {@link PluginDescriptionFile#getPermissionDefault()}.
-     *         <p>
-     *         For reference:<ul>
-     *         <li><code>true</code> - Represents a positive assignment to
-     *             {@link Permissible permissibles}.
-     *         <li><code>false</code> - Represents no assignment to {@link
-     *             Permissible permissibles}.
-     *         <li><code>op</code> - Represents a positive assignment to
-     *             {@link Permissible#isOp() operator permissibles}.
-     *         <li><code>notop</code> - Represents a positive assignment to
-     *             {@link Permissible#isOp() non-operator permissibiles}.
-     *         </ul></td>
-     *     <td><blockquote><pre>default: true</pre></blockquote></td>
-     * </tr><tr>
-     *     <td><code>children</code></td>
-     *     <td>Allows other permissions to be set as a {@linkplain
-     *         Permission#getChildren() relation} to the parent permission.
-     *         When a parent permissions is assigned, child permissions are
-     *         respectively assigned as well.
-     *         <ul>
-     *         <li>When a parent permission is assigned negatively, child
-     *             permissions are assigned based on an inversion of their
-     *             association.
-     *         <li>When a parent permission is assigned positively, child
-     *             permissions are assigned based on their association.
-     *         </ul>
-     *         <p>
-     *         Child permissions may be defined in a number of ways:<ul>
-     *         <li>Children may be defined as a <a
-     *             href="http://en.wikipedia.org/wiki/YAML#Lists">list</a> of
-     *             names. Using a list will treat all children associated
-     *             positively to their parent.
-     *         <li>Children may be defined as a map. Each permission name maps
-     *             to either a boolean (representing the association), or a
-     *             nested permission definition (just as another permission).
-     *             Using a nested definition treats the child as a positive
-     *             association.
-     *         <li>A nested permission definition must be a map of these same
-     *             properties. To define a valid nested permission without
-     *             defining any specific property, empty curly-braces (
-     *             <code>&#123;&#125;</code> ) must be used.
-     *          <li>A nested permission may carry it's own nested permissions
-     *              as children, as they may also have nested permissions, and
-     *              so forth. There is no direct limit to how deep the
-     *              permission tree is defined.
-     *         </ul></td>
-     *     <td>As a list:
-     *         <blockquote><pre>children: [inferno.flagrate, inferno.burningdeaths]</pre></blockquote>
-     *         Or as a mapping:
-     *         <blockquote><pre>children:
-     *  inferno.flagrate: true
-     *  inferno.burningdeaths: true</pre></blockquote>
-     *         An additional example showing basic nested values can be seen
-     *         <a href="doc-files/permissions-example_plugin.yml">here</a>.
-     *         </td>
-     * </tr>
-     * </table>
-     * The permissions are structured as a hiearchy of <a
-     * href="http://yaml.org/spec/current.html#id2502325">nested mappings</a>.
-     * The primary (top-level, no intendentation) node is
-     * `<code>permissions</code>', while each individual permission name is
-     * indented, indicating it maps to some value (in our case, the
-     * properties of the table above).
-     * <p>
-     * Here is an example using some of the properties:<blockquote><pre>
-     *permissions:
-     *  inferno.*:
-     *    description: Gives access to all Inferno commands
-     *    children:
-     *      inferno.flagrate: true
-     *      inferno.burningdeaths: true
-     *  inferno.flagate:
-     *    description: Allows you to ignite yourself
-     *    default: true
-     *  inferno.burningdeaths:
-     *    description: Allows you to see how many times you have burned to death
-     *    default: true
-     *</pre></blockquote>
-     * Another example, with nested definitions, can be found <a
-     * href="doc-files/permissions-example_plugin.yml">here</a>.
-     * 
-     * @return the permissions this plugin will register
-     */
-    public List<Permission> getPermissions() {
-        if (permissions == null) {
-            if (lazyPermissions == null) {
-                permissions = ImmutableList.<Permission>of();
-            } else {
-                permissions = ImmutableList.copyOf(Permission.loadPermissions(lazyPermissions, "Permission node '%s' in plugin description file for " + getFullName() + " is invalid", defaultPerm));
-                lazyPermissions = null;
-            }
-        }
-        return permissions;
-    }
-
-    /**
-     * Gives the default {@link Permission#getDefault() default} state of
-     * {@link #getPermissions() permissions} registered for the plugin.
-     * <ul>
-     * <li>If not specified, it will be {@link PermissionDefault#OP}.
-     * <li>It is matched using {@link PermissionDefault#getByName(String)}
-     * <li>It only affects permissions that do not define the
-     *     <code>default</code> node.
-     * <li>It may be any value in {@link PermissionDefault}.
-     * </ul>
-     * <p>
-     * In the plugin.yml, this entry is named <code>default-permission</code>.
-     * <p>
-     * Example:<blockquote><pre>default-permission: NOT_OP</pre></blockquote>
-     *
-     * @return the default value for the plugin's permissions
-     */
-    public PermissionDefault getPermissionDefault() {
-        return defaultPerm;
-    }
-
-    /**
-     * Gives a set of every {@link PluginAwareness} for a plugin. An awareness
-     * dictates something that a plugin developer acknowledges when the plugin
-     * is compiled. Some implementions may define extra awarenesses that are
-     * not included in the API. Any unrecognized
-     * awareness (one unsupported or in a future version) will cause a dummy
-     * object to be created instead of failing.
-     * 
-     * <ul>
-     * <li>Currently only supports the enumerated values in {@link
-     *     PluginAwareness.Flags}.
-     * <li>Each awareness starts the identifier with bang-at
-     *     (<code>!@</code>).
-     * <li>Unrecognized (future / unimplemented) entries are quietly replaced
-     *     by a generic object that implements PluginAwareness.
-     * <li>A type of awareness must be defined by the runtime and acknowledged
-     *     by the API, effectively discluding any derived type from any
-     *     plugin's classpath.
-     * <li><code>awareness</code> must be in <a
-     *     href="http://en.wikipedia.org/wiki/YAML#Lists">YAML list
-     *     format</a>.
-     * </ul>
-     * <p>
-     * In the plugin.yml, this entry is named <code>awareness</code>.
-     * <p>
-     * Example:<blockquote><pre>awareness:
-     *- !@UTF8</pre></blockquote>
-     * <p>
-     * <b>Note:</b> Although unknown versions of some future awareness are
-     * gracefully substituted, previous versions of Bukkit (ones prior to the
-     * first implementation of awareness) will fail to load a plugin that
-     * defines any awareness.
-     *
-     * @return a set containing every awareness for the plugin
-     */
-    public Set<PluginAwareness> getAwareness() {
-        return awareness;
-    }
-
-    /**
-     * Returns the name of a plugin, including the version. This method is
-     * provided for convenience; it uses the {@link #getName()} and {@link
-     * #getVersion()} entries.
-     *
-     * @return a descriptive name of the plugin and respective version
-     */
-    public String getFullName() {
-        return name + " v" + version;
-    }
-
-    /**
-     * @return unused
-     * @deprecated unused
-     */
-    @Deprecated
-    public String getClassLoaderOf() {
-        return classLoaderOf;
-    }
-
-    public void setDatabaseEnabled(boolean database) {
-        this.database = database;
-    }
-
-    /**
-     * Saves this PluginDescriptionFile to the given writer
-     *
-     * @param writer Writer to output this file to
-     */
-    public void save(Writer writer) {
-        YAML.get().dump(saveMap(), writer);
-    }
-
-    private void loadMap(Map<?, ?> map) throws InvalidDescriptionException {
-        try {
-            name = rawName = map.get("name").toString();
-
-            if (!name.matches("^[A-Za-z0-9 _.-]+$")) {
-                throw new InvalidDescriptionException("name '" + name + "' contains invalid characters.");
-            }
-            name = name.replace(' ', '_');
-        } catch (NullPointerException ex) {
-            throw new InvalidDescriptionException(ex, "name is not defined");
-        } catch (ClassCastException ex) {
-            throw new InvalidDescriptionException(ex, "name is of wrong type");
-        }
-
-        try {
-            version = map.get("version").toString();
-        } catch (NullPointerException ex) {
-            throw new InvalidDescriptionException(ex, "version is not defined");
-        } catch (ClassCastException ex) {
-            throw new InvalidDescriptionException(ex, "version is of wrong type");
-        }
-
-        try {
-            main = map.get("main").toString();
-            if (main.startsWith("org.bukkit.")) {
-                throw new InvalidDescriptionException("main may not be within the org.bukkit namespace");
-            }
-        } catch (NullPointerException ex) {
-            throw new InvalidDescriptionException(ex, "main is not defined");
-        } catch (ClassCastException ex) {
-            throw new InvalidDescriptionException(ex, "main is of wrong type");
-        }
-
-        if (map.get("commands") != null) {
-            ImmutableMap.Builder<String, Map<String, Object>> commandsBuilder = ImmutableMap.<String, Map<String, Object>>builder();
-            try {
-                for (Map.Entry<?, ?> command : ((Map<?, ?>) map.get("commands")).entrySet()) {
-                    ImmutableMap.Builder<String, Object> commandBuilder = ImmutableMap.<String, Object>builder();
-                    if (command.getValue() != null) {
-                        for (Map.Entry<?, ?> commandEntry : ((Map<?, ?>) command.getValue()).entrySet()) {
-                            if (commandEntry.getValue() instanceof Iterable) {
-                                // This prevents internal alias list changes
-                                ImmutableList.Builder<Object> commandSubList = ImmutableList.<Object>builder();
-                                for (Object commandSubListItem : (Iterable<?>) commandEntry.getValue()) {
-                                    if (commandSubListItem != null) {
-                                        commandSubList.add(commandSubListItem);
-                                    }
-                                }
-                                commandBuilder.put(commandEntry.getKey().toString(), commandSubList.build());
-                            } else if (commandEntry.getValue() != null) {
-                                commandBuilder.put(commandEntry.getKey().toString(), commandEntry.getValue());
-                            }
-                        }
-                    }
-                    commandsBuilder.put(command.getKey().toString(), commandBuilder.build());
-                }
-            } catch (ClassCastException ex) {
-                throw new InvalidDescriptionException(ex, "commands are of wrong type");
-            }
-            commands = commandsBuilder.build();
-        }
-
-        if (map.get("class-loader-of") != null) {
-            classLoaderOf = map.get("class-loader-of").toString();
-        }
-
-        depend = makePluginNameList(map, "depend");
-        softDepend = makePluginNameList(map, "softdepend");
-        loadBefore = makePluginNameList(map, "loadbefore");
-
-        if (map.get("database") != null) {
-            try {
-                database = (Boolean) map.get("database");
-            } catch (ClassCastException ex) {
-                throw new InvalidDescriptionException(ex, "database is of wrong type");
-            }
-        }
-
-        if (map.get("website") != null) {
-            website = map.get("website").toString();
-        }
-
-        if (map.get("description") != null) {
-            description = map.get("description").toString();
-        }
-
-        if (map.get("load") != null) {
-            try {
-                order = PluginLoadOrder.valueOf(((String) map.get("load")).toUpperCase().replaceAll("\\W", ""));
-            } catch (ClassCastException ex) {
-                throw new InvalidDescriptionException(ex, "load is of wrong type");
-            } catch (IllegalArgumentException ex) {
-                throw new InvalidDescriptionException(ex, "load is not a valid choice");
-            }
-        }
-
-        if (map.get("authors") != null) {
-            ImmutableList.Builder<String> authorsBuilder = ImmutableList.<String>builder();
-            if (map.get("author") != null) {
-                authorsBuilder.add(map.get("author").toString());
-            }
-            try {
-                for (Object o : (Iterable<?>) map.get("authors")) {
-                    authorsBuilder.add(o.toString());
-                }
-            } catch (ClassCastException ex) {
-                throw new InvalidDescriptionException(ex, "authors are of wrong type");
-            } catch (NullPointerException ex) {
-                throw new InvalidDescriptionException(ex, "authors are improperly defined");
-            }
-            authors = authorsBuilder.build();
-        } else if (map.get("author") != null) {
-            authors = ImmutableList.of(map.get("author").toString());
-        } else {
-            authors = ImmutableList.<String>of();
-        }
-
-        if (map.get("default-permission") != null) {
-            try {
-                defaultPerm = PermissionDefault.getByName(map.get("default-permission").toString());
-            } catch (ClassCastException ex) {
-                throw new InvalidDescriptionException(ex, "default-permission is of wrong type");
-            } catch (IllegalArgumentException ex) {
-                throw new InvalidDescriptionException(ex, "default-permission is not a valid choice");
-            }
-        }
-
-        if (map.get("awareness") instanceof Iterable) {
-            Set<PluginAwareness> awareness = new HashSet<PluginAwareness>();
-            try {
-                for (Object o : (Iterable<?>) map.get("awareness")) {
-                    awareness.add((PluginAwareness) o);
-                }
-            } catch (ClassCastException ex) {
-                throw new InvalidDescriptionException(ex, "awareness has wrong type");
-            }
-            this.awareness = ImmutableSet.copyOf(awareness);
-        }
-
-        try {
-            lazyPermissions = (Map<?, ?>) map.get("permissions");
-        } catch (ClassCastException ex) {
-            throw new InvalidDescriptionException(ex, "permissions are of the wrong type");
-        }
-
-        if (map.get("prefix") != null) {
-            prefix = map.get("prefix").toString();
-        }
-    }
-
-    private static List<String> makePluginNameList(final Map<?, ?> map, final String key) throws InvalidDescriptionException {
-        final Object value = map.get(key);
-        if (value == null) {
-            return ImmutableList.of();
-        }
-
-        final ImmutableList.Builder<String> builder = ImmutableList.<String>builder();
-        try {
-            for (final Object entry : (Iterable<?>) value) {
-                builder.add(entry.toString().replace(' ', '_'));
-            }
-        } catch (ClassCastException ex) {
-            throw new InvalidDescriptionException(ex, key + " is of wrong type");
-        } catch (NullPointerException ex) {
-            throw new InvalidDescriptionException(ex, "invalid " + key + " format");
-        }
-        return builder.build();
-    }
-
-    private Map<String, Object> saveMap() {
-        Map<String, Object> map = new HashMap<String, Object>();
-
-        map.put("name", name);
-        map.put("main", main);
-        map.put("version", version);
-        map.put("database", database);
-        map.put("order", order.toString());
-        map.put("default-permission", defaultPerm.toString());
-
-        if (commands != null) {
-            map.put("command", commands);
-        }
-        if (depend != null) {
-            map.put("depend", depend);
-        }
-        if (softDepend != null) {
-            map.put("softdepend", softDepend);
-        }
-        if (website != null) {
-            map.put("website", website);
-        }
-        if (description != null) {
-            map.put("description", description);
-        }
-
-        if (authors.size() == 1) {
-            map.put("author", authors.get(0));
-        } else if (authors.size() > 1) {
-            map.put("authors", authors);
-        }
-
-        if (classLoaderOf != null) {
-            map.put("class-loader-of", classLoaderOf);
-        }
-
-        if (prefix != null) {
-            map.put("prefix", prefix);
-        }
-
-        return map;
-    }
-
-    private Map<?,?> asMap(Object object) throws InvalidDescriptionException {
-        if (object instanceof Map) {
-            return (Map<?,?>) object;
-        }
-        throw new InvalidDescriptionException(object + " is not properly structured.");
-    }
-
-    /**
-     * @return internal use
-     * @deprecated Internal use
-     */
-    @Deprecated
-    public String getRawName() {
-        return rawName;
-    }
-}
diff --git a/src/main/java/org/bukkit/plugin/PluginLoadOrder.java b/src/main/java/org/bukkit/plugin/PluginLoadOrder.java
deleted file mode 100644
index b77436f..0000000
--- a/src/main/java/org/bukkit/plugin/PluginLoadOrder.java
+++ /dev/null
@@ -1,17 +0,0 @@
-package org.bukkit.plugin;
-
-/**
- * Represents the order in which a plugin should be initialized and enabled
- */
-public enum PluginLoadOrder {
-
-    /**
-     * Indicates that the plugin will be loaded at startup
-     */
-    STARTUP,
-    /**
-     * Indicates that the plugin will be loaded after the first/default world
-     * was created
-     */
-    POSTWORLD
-}
diff --git a/src/main/java/org/bukkit/plugin/PluginLoader.java b/src/main/java/org/bukkit/plugin/PluginLoader.java
deleted file mode 100644
index e7981a1..0000000
--- a/src/main/java/org/bukkit/plugin/PluginLoader.java
+++ /dev/null
@@ -1,76 +0,0 @@
-package org.bukkit.plugin;
-
-import java.io.File;
-import java.util.Map;
-import java.util.Set;
-import java.util.regex.Pattern;
-
-import org.bukkit.event.Event;
-import org.bukkit.event.Listener;
-
-/**
- * Represents a plugin loader, which handles direct access to specific types
- * of plugins
- */
-public interface PluginLoader {
-
-    /**
-     * Loads the plugin contained in the specified file
-     *
-     * @param file File to attempt to load
-     * @return Plugin that was contained in the specified file, or null if
-     *     unsuccessful
-     * @throws InvalidPluginException Thrown when the specified file is not a
-     *     plugin
-     * @throws UnknownDependencyException If a required dependency could not
-     *     be found
-     */
-    public Plugin loadPlugin(File file) throws InvalidPluginException, UnknownDependencyException;
-
-    /**
-     * Loads a PluginDescriptionFile from the specified file
-     *
-     * @param file File to attempt to load from
-     * @return A new PluginDescriptionFile loaded from the plugin.yml in the
-     *     specified file
-     * @throws InvalidDescriptionException If the plugin description file
-     *     could not be created
-     */
-    public PluginDescriptionFile getPluginDescription(File file) throws InvalidDescriptionException;
-
-    /**
-     * Returns a list of all filename filters expected by this PluginLoader
-     *
-     * @return The filters
-     */
-    public Pattern[] getPluginFileFilters();
-
-    /**
-     * Creates and returns registered listeners for the event classes used in
-     * this listener
-     *
-     * @param listener The object that will handle the eventual call back
-     * @param plugin The plugin to use when creating registered listeners
-     * @return The registered listeners.
-     */
-    public Map<Class<? extends Event>, Set<RegisteredListener>> createRegisteredListeners(Listener listener, Plugin plugin);
-
-    /**
-     * Enables the specified plugin
-     * <p>
-     * Attempting to enable a plugin that is already enabled will have no
-     * effect
-     *
-     * @param plugin Plugin to enable
-     */
-    public void enablePlugin(Plugin plugin);
-
-    /**
-     * Disables the specified plugin
-     * <p>
-     * Attempting to disable a plugin that is not enabled will have no effect
-     *
-     * @param plugin Plugin to disable
-     */
-    public void disablePlugin(Plugin plugin);
-}
diff --git a/src/main/java/org/bukkit/plugin/PluginLogger.java b/src/main/java/org/bukkit/plugin/PluginLogger.java
deleted file mode 100644
index f43c10b..0000000
--- a/src/main/java/org/bukkit/plugin/PluginLogger.java
+++ /dev/null
@@ -1,36 +0,0 @@
-package org.bukkit.plugin;
-
-import java.util.logging.Level;
-import java.util.logging.LogRecord;
-import java.util.logging.Logger;
-
-/**
- * The PluginLogger class is a modified {@link Logger} that prepends all
- * logging calls with the name of the plugin doing the logging. The API for
- * PluginLogger is exactly the same as {@link Logger}.
- *
- * @see Logger
- */
-public class PluginLogger extends Logger {
-    private String pluginName;
-
-    /**
-     * Creates a new PluginLogger that extracts the name from a plugin.
-     *
-     * @param context A reference to the plugin
-     */
-    public PluginLogger(Plugin context) {
-        super(context.getClass().getCanonicalName(), null);
-        String prefix = context.getDescription().getPrefix();
-        pluginName = prefix != null ? new StringBuilder().append("[").append(prefix).append("] ").toString() : "[" + context.getDescription().getName() + "] ";
-        setParent(context.getServer().getLogger());
-        setLevel(Level.ALL);
-    }
-
-    @Override
-    public void log(LogRecord logRecord) {
-        logRecord.setMessage(pluginName + logRecord.getMessage());
-        super.log(logRecord);
-    }
-
-}
diff --git a/src/main/java/org/bukkit/plugin/PluginManager.java b/src/main/java/org/bukkit/plugin/PluginManager.java
deleted file mode 100644
index e5638d5..0000000
--- a/src/main/java/org/bukkit/plugin/PluginManager.java
+++ /dev/null
@@ -1,294 +0,0 @@
-package org.bukkit.plugin;
-
-import java.io.File;
-import java.util.Set;
-
-import org.bukkit.event.Event;
-import org.bukkit.event.EventPriority;
-import org.bukkit.event.Listener;
-import org.bukkit.permissions.Permissible;
-import org.bukkit.permissions.Permission;
-
-/**
- * Handles all plugin management from the Server
- */
-public interface PluginManager {
-
-    /**
-     * Registers the specified plugin loader
-     *
-     * @param loader Class name of the PluginLoader to register
-     * @throws IllegalArgumentException Thrown when the given Class is not a
-     *     valid PluginLoader
-     */
-    public void registerInterface(Class<? extends PluginLoader> loader) throws IllegalArgumentException;
-
-    /**
-     * Checks if the given plugin is loaded and returns it when applicable
-     * <p>
-     * Please note that the name of the plugin is case-sensitive
-     *
-     * @param name Name of the plugin to check
-     * @return Plugin if it exists, otherwise null
-     */
-    public Plugin getPlugin(String name);
-
-    /**
-     * Gets a list of all currently loaded plugins
-     *
-     * @return Array of Plugins
-     */
-    public Plugin[] getPlugins();
-
-    /**
-     * Checks if the given plugin is enabled or not
-     * <p>
-     * Please note that the name of the plugin is case-sensitive.
-     *
-     * @param name Name of the plugin to check
-     * @return true if the plugin is enabled, otherwise false
-     */
-    public boolean isPluginEnabled(String name);
-
-    /**
-     * Checks if the given plugin is enabled or not
-     *
-     * @param plugin Plugin to check
-     * @return true if the plugin is enabled, otherwise false
-     */
-    public boolean isPluginEnabled(Plugin plugin);
-
-    /**
-     * Loads the plugin in the specified file
-     * <p>
-     * File must be valid according to the current enabled Plugin interfaces
-     *
-     * @param file File containing the plugin to load
-     * @return The Plugin loaded, or null if it was invalid
-     * @throws InvalidPluginException Thrown when the specified file is not a
-     *     valid plugin
-     * @throws InvalidDescriptionException Thrown when the specified file
-     *     contains an invalid description
-     * @throws UnknownDependencyException If a required dependency could not
-     *     be resolved
-     */
-    public Plugin loadPlugin(File file) throws InvalidPluginException, InvalidDescriptionException, UnknownDependencyException;
-
-    /**
-     * Loads the plugins contained within the specified directory
-     *
-     * @param directory Directory to check for plugins
-     * @return A list of all plugins loaded
-     */
-    public Plugin[] loadPlugins(File directory);
-
-    /**
-     * Disables all the loaded plugins
-     */
-    public void disablePlugins();
-
-    /**
-     * Disables and removes all plugins
-     */
-    public void clearPlugins();
-
-    /**
-     * Calls an event with the given details
-     *
-     * @param event Event details
-     * @throws IllegalStateException Thrown when an asynchronous event is
-     *     fired from synchronous code.
-     *     <p>
-     *     <i>Note: This is best-effort basis, and should not be used to test
-     *     synchronized state. This is an indicator for flawed flow logic.</i>
-     */
-    public void callEvent(Event event) throws IllegalStateException;
-
-    /**
-     * Registers all the events in the given listener class
-     *
-     * @param listener Listener to register
-     * @param plugin Plugin to register
-     */
-    public void registerEvents(Listener listener, Plugin plugin);
-
-    /**
-     * Registers the specified executor to the given event class
-     *
-     * @param event Event type to register
-     * @param listener Listener to register
-     * @param priority Priority to register this event at
-     * @param executor EventExecutor to register
-     * @param plugin Plugin to register
-     */
-    public void registerEvent(Class<? extends Event> event, Listener listener, EventPriority priority, EventExecutor executor, Plugin plugin);
-
-    /**
-     * Registers the specified executor to the given event class
-     *
-     * @param event Event type to register
-     * @param listener Listener to register
-     * @param priority Priority to register this event at
-     * @param executor EventExecutor to register
-     * @param plugin Plugin to register
-     * @param ignoreCancelled Whether to pass cancelled events or not
-     */
-    public void registerEvent(Class<? extends Event> event, Listener listener, EventPriority priority, EventExecutor executor, Plugin plugin, boolean ignoreCancelled);
-
-    /**
-     * Enables the specified plugin
-     * <p>
-     * Attempting to enable a plugin that is already enabled will have no
-     * effect
-     *
-     * @param plugin Plugin to enable
-     */
-    public void enablePlugin(Plugin plugin);
-
-    /**
-     * Disables the specified plugin
-     * <p>
-     * Attempting to disable a plugin that is not enabled will have no effect
-     *
-     * @param plugin Plugin to disable
-     */
-    public void disablePlugin(Plugin plugin);
-
-    /**
-     * Gets a {@link Permission} from its fully qualified name
-     *
-     * @param name Name of the permission
-     * @return Permission, or null if none
-     */
-    public Permission getPermission(String name);
-
-    /**
-     * Adds a {@link Permission} to this plugin manager.
-     * <p>
-     * If a permission is already defined with the given name of the new
-     * permission, an exception will be thrown.
-     *
-     * @param perm Permission to add
-     * @throws IllegalArgumentException Thrown when a permission with the same
-     *     name already exists
-     */
-    public void addPermission(Permission perm);
-
-    /**
-     * Removes a {@link Permission} registration from this plugin manager.
-     * <p>
-     * If the specified permission does not exist in this plugin manager,
-     * nothing will happen.
-     * <p>
-     * Removing a permission registration will <b>not</b> remove the
-     * permission from any {@link Permissible}s that have it.
-     *
-     * @param perm Permission to remove
-     */
-    public void removePermission(Permission perm);
-
-    /**
-     * Removes a {@link Permission} registration from this plugin manager.
-     * <p>
-     * If the specified permission does not exist in this plugin manager,
-     * nothing will happen.
-     * <p>
-     * Removing a permission registration will <b>not</b> remove the
-     * permission from any {@link Permissible}s that have it.
-     *
-     * @param name Permission to remove
-     */
-    public void removePermission(String name);
-
-    /**
-     * Gets the default permissions for the given op status
-     *
-     * @param op Which set of default permissions to get
-     * @return The default permissions
-     */
-    public Set<Permission> getDefaultPermissions(boolean op);
-
-    /**
-     * Recalculates the defaults for the given {@link Permission}.
-     * <p>
-     * This will have no effect if the specified permission is not registered
-     * here.
-     *
-     * @param perm Permission to recalculate
-     */
-    public void recalculatePermissionDefaults(Permission perm);
-
-    /**
-     * Subscribes the given Permissible for information about the requested
-     * Permission, by name.
-     * <p>
-     * If the specified Permission changes in any form, the Permissible will
-     * be asked to recalculate.
-     *
-     * @param permission Permission to subscribe to
-     * @param permissible Permissible subscribing
-     */
-    public void subscribeToPermission(String permission, Permissible permissible);
-
-    /**
-     * Unsubscribes the given Permissible for information about the requested
-     * Permission, by name.
-     *
-     * @param permission Permission to unsubscribe from
-     * @param permissible Permissible subscribing
-     */
-    public void unsubscribeFromPermission(String permission, Permissible permissible);
-
-    /**
-     * Gets a set containing all subscribed {@link Permissible}s to the given
-     * permission, by name
-     *
-     * @param permission Permission to query for
-     * @return Set containing all subscribed permissions
-     */
-    public Set<Permissible> getPermissionSubscriptions(String permission);
-
-    /**
-     * Subscribes to the given Default permissions by operator status
-     * <p>
-     * If the specified defaults change in any form, the Permissible will be
-     * asked to recalculate.
-     *
-     * @param op Default list to subscribe to
-     * @param permissible Permissible subscribing
-     */
-    public void subscribeToDefaultPerms(boolean op, Permissible permissible);
-
-    /**
-     * Unsubscribes from the given Default permissions by operator status
-     *
-     * @param op Default list to unsubscribe from
-     * @param permissible Permissible subscribing
-     */
-    public void unsubscribeFromDefaultPerms(boolean op, Permissible permissible);
-
-    /**
-     * Gets a set containing all subscribed {@link Permissible}s to the given
-     * default list, by op status
-     *
-     * @param op Default list to query for
-     * @return Set containing all subscribed permissions
-     */
-    public Set<Permissible> getDefaultPermSubscriptions(boolean op);
-
-    /**
-     * Gets a set of all registered permissions.
-     * <p>
-     * This set is a copy and will not be modified live.
-     *
-     * @return Set containing all current registered permissions
-     */
-    public Set<Permission> getPermissions();
-
-    /**
-     * Returns whether or not timing code should be used for event calls
-     *
-     * @return True if event timings are to be used
-     */
-    public boolean useTimings();
-}
diff --git a/src/main/java/org/bukkit/plugin/RegisteredListener.java b/src/main/java/org/bukkit/plugin/RegisteredListener.java
deleted file mode 100644
index 9dd0b7a..0000000
--- a/src/main/java/org/bukkit/plugin/RegisteredListener.java
+++ /dev/null
@@ -1,73 +0,0 @@
-package org.bukkit.plugin;
-
-import org.bukkit.event.*;
-
-/**
- * Stores relevant information for plugin listeners
- */
-public class RegisteredListener {
-    private final Listener listener;
-    private final EventPriority priority;
-    private final Plugin plugin;
-    private final EventExecutor executor;
-    private final boolean ignoreCancelled;
-
-    public RegisteredListener(final Listener listener, final EventExecutor executor, final EventPriority priority, final Plugin plugin, final boolean ignoreCancelled) {
-        this.listener = listener;
-        this.priority = priority;
-        this.plugin = plugin;
-        this.executor = executor;
-        this.ignoreCancelled = ignoreCancelled;
-    }
-
-    /**
-     * Gets the listener for this registration
-     *
-     * @return Registered Listener
-     */
-    public Listener getListener() {
-        return listener;
-    }
-
-    /**
-     * Gets the plugin for this registration
-     *
-     * @return Registered Plugin
-     */
-    public Plugin getPlugin() {
-        return plugin;
-    }
-
-    /**
-     * Gets the priority for this registration
-     *
-     * @return Registered Priority
-     */
-    public EventPriority getPriority() {
-        return priority;
-    }
-
-    /**
-     * Calls the event executor
-     *
-     * @param event The event
-     * @throws EventException If an event handler throws an exception.
-     */
-    public void callEvent(final Event event) throws EventException {
-        if (event instanceof Cancellable){
-            if (((Cancellable) event).isCancelled() && isIgnoringCancelled()){
-                return;
-            }
-        }
-        executor.execute(listener, event);
-    }
-
-     /**
-     * Whether this listener accepts cancelled events
-     *
-     * @return True when ignoring cancelled events
-     */
-    public boolean isIgnoringCancelled() {
-        return ignoreCancelled;
-    }
-}
diff --git a/src/main/java/org/bukkit/plugin/RegisteredServiceProvider.java b/src/main/java/org/bukkit/plugin/RegisteredServiceProvider.java
deleted file mode 100644
index ba3ff15..0000000
--- a/src/main/java/org/bukkit/plugin/RegisteredServiceProvider.java
+++ /dev/null
@@ -1,46 +0,0 @@
-package org.bukkit.plugin;
-
-/**
- * A registered service provider.
- *
- * @param <T> Service
- */
-public class RegisteredServiceProvider<T> implements Comparable<RegisteredServiceProvider<?>> {
-
-    private Class<T> service;
-    private Plugin plugin;
-    private T provider;
-    private ServicePriority priority;
-
-    public RegisteredServiceProvider(Class<T> service, T provider, ServicePriority priority, Plugin plugin) {
-
-        this.service = service;
-        this.plugin = plugin;
-        this.provider = provider;
-        this.priority = priority;
-    }
-
-    public Class<T> getService() {
-        return service;
-    }
-
-    public Plugin getPlugin() {
-        return plugin;
-    }
-
-    public T getProvider() {
-        return provider;
-    }
-
-    public ServicePriority getPriority() {
-        return priority;
-    }
-
-    public int compareTo(RegisteredServiceProvider<?> other) {
-        if (priority.ordinal() == other.getPriority().ordinal()) {
-            return 0;
-        } else {
-            return priority.ordinal() < other.getPriority().ordinal() ? 1 : -1;
-        }
-    }
-}
diff --git a/src/main/java/org/bukkit/plugin/ServicePriority.java b/src/main/java/org/bukkit/plugin/ServicePriority.java
deleted file mode 100644
index 4afe0fb..0000000
--- a/src/main/java/org/bukkit/plugin/ServicePriority.java
+++ /dev/null
@@ -1,12 +0,0 @@
-package org.bukkit.plugin;
-
-/**
- * Represents various priorities of a provider.
- */
-public enum ServicePriority {
-    Lowest,
-    Low,
-    Normal,
-    High,
-    Highest
-}
diff --git a/src/main/java/org/bukkit/plugin/ServicesManager.java b/src/main/java/org/bukkit/plugin/ServicesManager.java
deleted file mode 100644
index 5d45ffb..0000000
--- a/src/main/java/org/bukkit/plugin/ServicesManager.java
+++ /dev/null
@@ -1,106 +0,0 @@
-package org.bukkit.plugin;
-
-import java.util.Collection;
-import java.util.List;
-
-/**
- * Manages services and service providers. Services are an interface
- * specifying a list of methods that a provider must implement. Providers are
- * implementations of these services. A provider can be queried from the
- * services manager in order to use a service (if one is available). If
- * multiple plugins register a service, then the service with the highest
- * priority takes precedence.
- */
-public interface ServicesManager {
-
-    /**
-     * Register a provider of a service.
-     *
-     * @param <T> Provider
-     * @param service service class
-     * @param provider provider to register
-     * @param plugin plugin with the provider
-     * @param priority priority of the provider
-     */
-    public <T> void register(Class<T> service, T provider, Plugin plugin, ServicePriority priority);
-
-    /**
-     * Unregister all the providers registered by a particular plugin.
-     *
-     * @param plugin The plugin
-     */
-    public void unregisterAll(Plugin plugin);
-
-    /**
-     * Unregister a particular provider for a particular service.
-     *
-     * @param service The service interface
-     * @param provider The service provider implementation
-     */
-    public void unregister(Class<?> service, Object provider);
-
-    /**
-     * Unregister a particular provider.
-     *
-     * @param provider The service provider implementation
-     */
-    public void unregister(Object provider);
-
-    /**
-     * Queries for a provider. This may return if no provider has been
-     * registered for a service. The highest priority provider is returned.
-     *
-     * @param <T> The service interface
-     * @param service The service interface
-     * @return provider or null
-     */
-    public <T> T load(Class<T> service);
-
-    /**
-     * Queries for a provider registration. This may return if no provider
-     * has been registered for a service.
-     *
-     * @param <T> The service interface
-     * @param service The service interface
-     * @return provider registration or null
-     */
-    public <T> RegisteredServiceProvider<T> getRegistration(Class<T> service);
-
-    /**
-     * Get registrations of providers for a plugin.
-     *
-     * @param plugin The plugin
-     * @return provider registration or null
-     */
-    public List<RegisteredServiceProvider<?>> getRegistrations(Plugin plugin);
-
-    /**
-     * Get registrations of providers for a service. The returned list is
-     * unmodifiable.
-     *
-     * @param <T> The service interface
-     * @param service The service interface
-     * @return list of registrations
-     */
-    public <T> Collection<RegisteredServiceProvider<T>> getRegistrations(Class<T> service);
-
-    /**
-     * Get a list of known services. A service is known if it has registered
-     * providers for it.
-     *
-     * @return list of known services
-     */
-    public Collection<Class<?>> getKnownServices();
-
-    /**
-     * Returns whether a provider has been registered for a service. Do not
-     * check this first only to call <code>load(service)</code> later, as that
-     * would be a non-thread safe situation.
-     *
-     * @param <T> service
-     * @param service service to check
-     * @return whether there has been a registered provider
-     */
-    public <T> boolean isProvidedFor(Class<T> service);
-
-}
diff --git a/src/main/java/org/bukkit/plugin/SimplePluginManager.java b/src/main/java/org/bukkit/plugin/SimplePluginManager.java
deleted file mode 100644
index 5a9e50d..0000000
--- a/src/main/java/org/bukkit/plugin/SimplePluginManager.java
+++ /dev/null
@@ -1,730 +0,0 @@
-package org.bukkit.plugin;
-
-import java.io.File;
-import java.lang.reflect.Constructor;
-import java.lang.reflect.Method;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.LinkedHashMap;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.WeakHashMap;
-import java.util.logging.Level;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.Server;
-import org.bukkit.command.Command;
-import org.bukkit.command.PluginCommandYamlParser;
-import org.bukkit.command.SimpleCommandMap;
-import org.bukkit.event.Event;
-import org.bukkit.event.EventPriority;
-import org.bukkit.event.HandlerList;
-import org.bukkit.event.Listener;
-import org.bukkit.permissions.Permissible;
-import org.bukkit.permissions.Permission;
-import org.bukkit.permissions.PermissionDefault;
-import org.bukkit.util.FileUtil;
-
-import com.google.common.collect.ImmutableSet;
-
-/**
- * Handles all plugin management from the Server
- */
-public final class SimplePluginManager implements PluginManager {
-    private final Server server;
-    private final Map<Pattern, PluginLoader> fileAssociations = new HashMap<Pattern, PluginLoader>();
-    private final List<Plugin> plugins = new ArrayList<Plugin>();
-    private final Map<String, Plugin> lookupNames = new HashMap<String, Plugin>();
-    private static File updateDirectory = null;
-    private final SimpleCommandMap commandMap;
-    private final Map<String, Permission> permissions = new HashMap<String, Permission>();
-    private final Map<Boolean, Set<Permission>> defaultPerms = new LinkedHashMap<Boolean, Set<Permission>>();
-    private final Map<String, Map<Permissible, Boolean>> permSubs = new HashMap<String, Map<Permissible, Boolean>>();
-    private final Map<Boolean, Map<Permissible, Boolean>> defSubs = new HashMap<Boolean, Map<Permissible, Boolean>>();
-    private boolean useTimings = false;
-
-    public SimplePluginManager(Server instance, SimpleCommandMap commandMap) {
-        server = instance;
-        this.commandMap = commandMap;
-
-        defaultPerms.put(true, new HashSet<Permission>());
-        defaultPerms.put(false, new HashSet<Permission>());
-    }
-
-    /**
-     * Registers the specified plugin loader
-     *
-     * @param loader Class name of the PluginLoader to register
-     * @throws IllegalArgumentException Thrown when the given Class is not a
-     *     valid PluginLoader
-     */
-    public void registerInterface(Class<? extends PluginLoader> loader) throws IllegalArgumentException {
-        PluginLoader instance;
-
-        if (PluginLoader.class.isAssignableFrom(loader)) {
-            Constructor<? extends PluginLoader> constructor;
-
-            try {
-                constructor = loader.getConstructor(Server.class);
-                instance = constructor.newInstance(server);
-            } catch (NoSuchMethodException ex) {
-                String className = loader.getName();
-
-                throw new IllegalArgumentException(String.format("Class %s does not have a public %s(Server) constructor", className, className), ex);
-            } catch (Exception ex) {
-                throw new IllegalArgumentException(String.format("Unexpected exception %s while attempting to construct a new instance of %s", ex.getClass().getName(), loader.getName()), ex);
-            }
-        } else {
-            throw new IllegalArgumentException(String.format("Class %s does not implement interface PluginLoader", loader.getName()));
-        }
-
-        Pattern[] patterns = instance.getPluginFileFilters();
-
-        synchronized (this) {
-            for (Pattern pattern : patterns) {
-                fileAssociations.put(pattern, instance);
-            }
-        }
-    }
-
-    /**
-     * Loads the plugins contained within the specified directory
-     *
-     * @param directory Directory to check for plugins
-     * @return A list of all plugins loaded
-     */
-    public Plugin[] loadPlugins(File directory) {
-        Validate.notNull(directory, "Directory cannot be null");
-        Validate.isTrue(directory.isDirectory(), "Directory must be a directory");
-
-        List<Plugin> result = new ArrayList<Plugin>();
-        Set<Pattern> filters = fileAssociations.keySet();
-
-        if (!(server.getUpdateFolder().equals(""))) {
-            updateDirectory = new File(directory, server.getUpdateFolder());
-        }
-
-        Map<String, File> plugins = new HashMap<String, File>();
-        Set<String> loadedPlugins = new HashSet<String>();
-        Map<String, Collection<String>> dependencies = new HashMap<String, Collection<String>>();
-        Map<String, Collection<String>> softDependencies = new HashMap<String, Collection<String>>();
-
-        // This is where it figures out all possible plugins
-        for (File file : directory.listFiles()) {
-            PluginLoader loader = null;
-            for (Pattern filter : filters) {
-                Matcher match = filter.matcher(file.getName());
-                if (match.find()) {
-                    loader = fileAssociations.get(filter);
-                }
-            }
-
-            if (loader == null) continue;
-
-            PluginDescriptionFile description = null;
-            try {
-                description = loader.getPluginDescription(file);
-                String name = description.getName();
-                if (name.equalsIgnoreCase("bukkit") || name.equalsIgnoreCase("minecraft") || name.equalsIgnoreCase("mojang")) {
-                    server.getLogger().log(Level.SEVERE, "Could not load '" + file.getPath() + "' in folder '" + directory.getPath() + "': Restricted Name");
-                    continue;
-                } else if (description.rawName.indexOf(' ') != -1) {
-                    server.getLogger().warning(String.format(
-                        "Plugin `%s' uses the space-character (0x20) in its name `%s' - this is discouraged",
-                        description.getFullName(),
-                        description.rawName
-                        ));
-                }
-            } catch (InvalidDescriptionException ex) {
-                server.getLogger().log(Level.SEVERE, "Could not load '" + file.getPath() + "' in folder '" + directory.getPath() + "'", ex);
-                continue;
-            }
-
-            File replacedFile = plugins.put(description.getName(), file);
-            if (replacedFile != null) {
-                server.getLogger().severe(String.format(
-                    "Ambiguous plugin name `%s' for files `%s' and `%s' in `%s'",
-                    description.getName(),
-                    file.getPath(),
-                    replacedFile.getPath(),
-                    directory.getPath()
-                    ));
-            }
-
-            Collection<String> softDependencySet = description.getSoftDepend();
-            if (softDependencySet != null && !softDependencySet.isEmpty()) {
-                if (softDependencies.containsKey(description.getName())) {
-                    // Duplicates do not matter, they will be removed together if applicable
-                    softDependencies.get(description.getName()).addAll(softDependencySet);
-                } else {
-                    softDependencies.put(description.getName(), new LinkedList<String>(softDependencySet));
-                }
-            }
-
-            Collection<String> dependencySet = description.getDepend();
-            if (dependencySet != null && !dependencySet.isEmpty()) {
-                dependencies.put(description.getName(), new LinkedList<String>(dependencySet));
-            }
-
-            Collection<String> loadBeforeSet = description.getLoadBefore();
-            if (loadBeforeSet != null && !loadBeforeSet.isEmpty()) {
-                for (String loadBeforeTarget : loadBeforeSet) {
-                    if (softDependencies.containsKey(loadBeforeTarget)) {
-                        softDependencies.get(loadBeforeTarget).add(description.getName());
-                    } else {
-                        // softDependencies is never iterated, so 'ghost' plugins aren't an issue
-                        Collection<String> shortSoftDependency = new LinkedList<String>();
-                        shortSoftDependency.add(description.getName());
-                        softDependencies.put(loadBeforeTarget, shortSoftDependency);
-                    }
-                }
-            }
-        }
-
-        while (!plugins.isEmpty()) {
-            boolean missingDependency = true;
-            Iterator<String> pluginIterator = plugins.keySet().iterator();
-
-            while (pluginIterator.hasNext()) {
-                String plugin = pluginIterator.next();
-
-                if (dependencies.containsKey(plugin)) {
-                    Iterator<String> dependencyIterator = dependencies.get(plugin).iterator();
-
-                    while (dependencyIterator.hasNext()) {
-                        String dependency = dependencyIterator.next();
-
-                        // Dependency loaded
-                        if (loadedPlugins.contains(dependency)) {
-                            dependencyIterator.remove();
-
-                        // We have a dependency not found
-                        } else if (!plugins.containsKey(dependency)) {
-                            missingDependency = false;
-                            File file = plugins.get(plugin);
-                            pluginIterator.remove();
-                            softDependencies.remove(plugin);
-                            dependencies.remove(plugin);
-
-                            server.getLogger().log(
-                                Level.SEVERE,
-                                "Could not load '" + file.getPath() + "' in folder '" + directory.getPath() + "'",
-                                new UnknownDependencyException(dependency));
-                            break;
-                        }
-                    }
-
-                    if (dependencies.containsKey(plugin) && dependencies.get(plugin).isEmpty()) {
-                        dependencies.remove(plugin);
-                    }
-                }
-                if (softDependencies.containsKey(plugin)) {
-                    Iterator<String> softDependencyIterator = softDependencies.get(plugin).iterator();
-
-                    while (softDependencyIterator.hasNext()) {
-                        String softDependency = softDependencyIterator.next();
-
-                        // Soft depend is no longer around
-                        if (!plugins.containsKey(softDependency)) {
-                            softDependencyIterator.remove();
-                        }
-                    }
-
-                    if (softDependencies.get(plugin).isEmpty()) {
-                        softDependencies.remove(plugin);
-                    }
-                }
-                if (!(dependencies.containsKey(plugin) || softDependencies.containsKey(plugin)) && plugins.containsKey(plugin)) {
-                    // We're clear to load, no more soft or hard dependencies left
-                    File file = plugins.get(plugin);
-                    pluginIterator.remove();
-                    missingDependency = false;
-
-                    try {
-                        result.add(loadPlugin(file));
-                        loadedPlugins.add(plugin);
-                        continue;
-                    } catch (InvalidPluginException ex) {
-                        server.getLogger().log(Level.SEVERE, "Could not load '" + file.getPath() + "' in folder '" + directory.getPath() + "'", ex);
-                    }
-                }
-            }
-
-            if (missingDependency) {
-                // We now iterate over plugins until something loads
-                // This loop will ignore soft dependencies
-                pluginIterator = plugins.keySet().iterator();
-
-                while (pluginIterator.hasNext()) {
-                    String plugin = pluginIterator.next();
-
-                    if (!dependencies.containsKey(plugin)) {
-                        softDependencies.remove(plugin);
-                        missingDependency = false;
-                        File file = plugins.get(plugin);
-                        pluginIterator.remove();
-
-                        try {
-                            result.add(loadPlugin(file));
-                            loadedPlugins.add(plugin);
-                            break;
-                        } catch (InvalidPluginException ex) {
-                            server.getLogger().log(Level.SEVERE, "Could not load '" + file.getPath() + "' in folder '" + directory.getPath() + "'", ex);
-                        }
-                    }
-                }
-                // We have no plugins left without a depend
-                if (missingDependency) {
-                    softDependencies.clear();
-                    dependencies.clear();
-                    Iterator<File> failedPluginIterator = plugins.values().iterator();
-
-                    while (failedPluginIterator.hasNext()) {
-                        File file = failedPluginIterator.next();
-                        failedPluginIterator.remove();
-                        server.getLogger().log(Level.SEVERE, "Could not load '" + file.getPath() + "' in folder '" + directory.getPath() + "': circular dependency detected");
-                    }
-                }
-            }
-        }
-
-        return result.toArray(new Plugin[result.size()]);
-    }
-
-    /**
-     * Loads the plugin in the specified file
-     * <p>
-     * File must be valid according to the current enabled Plugin interfaces
-     *
-     * @param file File containing the plugin to load
-     * @return The Plugin loaded, or null if it was invalid
-     * @throws InvalidPluginException Thrown when the specified file is not a
-     *     valid plugin
-     * @throws UnknownDependencyException If a required dependency could not
-     *     be found
-     */
-    public synchronized Plugin loadPlugin(File file) throws InvalidPluginException, UnknownDependencyException {
-        Validate.notNull(file, "File cannot be null");
-
-        checkUpdate(file);
-
-        Set<Pattern> filters = fileAssociations.keySet();
-        Plugin result = null;
-
-        for (Pattern filter : filters) {
-            String name = file.getName();
-            Matcher match = filter.matcher(name);
-
-            if (match.find()) {
-                PluginLoader loader = fileAssociations.get(filter);
-
-                result = loader.loadPlugin(file);
-            }
-        }
-
-        if (result != null) {
-            plugins.add(result);
-            lookupNames.put(result.getDescription().getName(), result);
-        }
-
-        return result;
-    }
-
-    private void checkUpdate(File file) {
-        if (updateDirectory == null || !updateDirectory.isDirectory()) {
-            return;
-        }
-
-        File updateFile = new File(updateDirectory, file.getName());
-        if (updateFile.isFile() && FileUtil.copy(updateFile, file)) {
-            updateFile.delete();
-        }
-    }
-
-    /**
-     * Checks if the given plugin is loaded and returns it when applicable
-     * <p>
-     * Please note that the name of the plugin is case-sensitive
-     *
-     * @param name Name of the plugin to check
-     * @return Plugin if it exists, otherwise null
-     */
-    public synchronized Plugin getPlugin(String name) {
-        return lookupNames.get(name.replace(' ', '_'));
-    }
-
-    public synchronized Plugin[] getPlugins() {
-        return plugins.toArray(new Plugin[0]);
-    }
-
-    /**
-     * Checks if the given plugin is enabled or not
-     * <p>
-     * Please note that the name of the plugin is case-sensitive.
-     *
-     * @param name Name of the plugin to check
-     * @return true if the plugin is enabled, otherwise false
-     */
-    public boolean isPluginEnabled(String name) {
-        Plugin plugin = getPlugin(name);
-
-        return isPluginEnabled(plugin);
-    }
-
-    /**
-     * Checks if the given plugin is enabled or not
-     *
-     * @param plugin Plugin to check
-     * @return true if the plugin is enabled, otherwise false
-     */
-    public boolean isPluginEnabled(Plugin plugin) {
-        if ((plugin != null) && (plugins.contains(plugin))) {
-            return plugin.isEnabled();
-        } else {
-            return false;
-        }
-    }
-
-    public void enablePlugin(final Plugin plugin) {
-        if (!plugin.isEnabled()) {
-            List<Command> pluginCommands = PluginCommandYamlParser.parse(plugin);
-
-            if (!pluginCommands.isEmpty()) {
-                commandMap.registerAll(plugin.getDescription().getName(), pluginCommands);
-            }
-
-            try {
-                plugin.getPluginLoader().enablePlugin(plugin);
-            } catch (Throwable ex) {
-                server.getLogger().log(Level.SEVERE, "Error occurred (in the plugin loader) while enabling " + plugin.getDescription().getFullName() + " (Is it up to date?)", ex);
-            }
-
-            HandlerList.bakeAll();
-        }
-    }
-
-    public void disablePlugins() {
-        Plugin[] plugins = getPlugins();
-        for (int i = plugins.length - 1; i >= 0; i--) {
-            disablePlugin(plugins[i]);
-        }
-    }
-
-    public void disablePlugin(final Plugin plugin) {
-        if (plugin.isEnabled()) {
-            try {
-                plugin.getPluginLoader().disablePlugin(plugin);
-            } catch (Throwable ex) {
-                server.getLogger().log(Level.SEVERE, "Error occurred (in the plugin loader) while disabling " + plugin.getDescription().getFullName() + " (Is it up to date?)", ex);
-            }
-
-            try {
-                server.getScheduler().cancelTasks(plugin);
-            } catch (Throwable ex) {
-                server.getLogger().log(Level.SEVERE, "Error occurred (in the plugin loader) while cancelling tasks for " + plugin.getDescription().getFullName() + " (Is it up to date?)", ex);
-            }
-
-            try {
-                server.getServicesManager().unregisterAll(plugin);
-            } catch (Throwable ex) {
-                server.getLogger().log(Level.SEVERE, "Error occurred (in the plugin loader) while unregistering services for " + plugin.getDescription().getFullName() + " (Is it up to date?)", ex);
-            }
-
-            try {
-                HandlerList.unregisterAll(plugin);
-            } catch (Throwable ex) {
-                server.getLogger().log(Level.SEVERE, "Error occurred (in the plugin loader) while unregistering events for " + plugin.getDescription().getFullName() + " (Is it up to date?)", ex);
-            }
-
-            try {
-                server.getMessenger().unregisterIncomingPluginChannel(plugin);
-                server.getMessenger().unregisterOutgoingPluginChannel(plugin);
-            } catch(Throwable ex) {
-                server.getLogger().log(Level.SEVERE, "Error occurred (in the plugin loader) while unregistering plugin channels for " + plugin.getDescription().getFullName() + " (Is it up to date?)", ex);
-            }
-        }
-    }
-
-    public void clearPlugins() {
-        synchronized (this) {
-            disablePlugins();
-            plugins.clear();
-            lookupNames.clear();
-            HandlerList.unregisterAll();
-            fileAssociations.clear();
-            permissions.clear();
-            defaultPerms.get(true).clear();
-            defaultPerms.get(false).clear();
-        }
-    }
-
-    /**
-     * Calls an event with the given details.
-     * <p>
-     * This method only synchronizes when the event is not asynchronous.
-     *
-     * @param event Event details
-     */
-    public void callEvent(Event event) {
-        if (event.isAsynchronous()) {
-            if (Thread.holdsLock(this)) {
-                throw new IllegalStateException(event.getEventName() + " cannot be triggered asynchronously from inside synchronized code.");
-            }
-            if (server.isPrimaryThread()) {
-                throw new IllegalStateException(event.getEventName() + " cannot be triggered asynchronously from primary server thread.");
-            }
-            fireEvent(event);
-        } else {
-            synchronized (this) {
-                fireEvent(event);
-            }
-        }
-    }
-
-    private void fireEvent(Event event) {
-        HandlerList handlers = event.getHandlers();
-        RegisteredListener[] listeners = handlers.getRegisteredListeners();
-
-        for (RegisteredListener registration : listeners) {
-            if (!registration.getPlugin().isEnabled()) {
-                continue;
-            }
-
-            try {
-                registration.callEvent(event);
-            } catch (AuthorNagException ex) {
-                Plugin plugin = registration.getPlugin();
-
-                if (plugin.isNaggable()) {
-                    plugin.setNaggable(false);
-
-                    server.getLogger().log(Level.SEVERE, String.format(
-                            "Nag author(s): '%s' of '%s' about the following: %s",
-                            plugin.getDescription().getAuthors(),
-                            plugin.getDescription().getFullName(),
-                            ex.getMessage()
-                            ));
-                }
-            } catch (Throwable ex) {
-                server.getLogger().log(Level.SEVERE, "Could not pass event " + event.getEventName() + " to " + registration.getPlugin().getDescription().getFullName(), ex);
-            }
-        }
-    }
-
-    public void registerEvents(Listener listener, Plugin plugin) {
-        if (!plugin.isEnabled()) {
-            throw new IllegalPluginAccessException("Plugin attempted to register " + listener + " while not enabled");
-        }
-
-        for (Map.Entry<Class<? extends Event>, Set<RegisteredListener>> entry : plugin.getPluginLoader().createRegisteredListeners(listener, plugin).entrySet()) {
-            getEventListeners(getRegistrationClass(entry.getKey())).registerAll(entry.getValue());
-        }
-
-    }
-
-    public void registerEvent(Class<? extends Event> event, Listener listener, EventPriority priority, EventExecutor executor, Plugin plugin) {
-        registerEvent(event, listener, priority, executor, plugin, false);
-    }
-
-    /**
-     * Registers the given event to the specified listener using a directly
-     * passed EventExecutor
-     *
-     * @param event Event class to register
-     * @param listener PlayerListener to register
-     * @param priority Priority of this event
-     * @param executor EventExecutor to register
-     * @param plugin Plugin to register
-     * @param ignoreCancelled Do not call executor if event was already
-     *     cancelled
-     */
-    public void registerEvent(Class<? extends Event> event, Listener listener, EventPriority priority, EventExecutor executor, Plugin plugin, boolean ignoreCancelled) {
-        Validate.notNull(listener, "Listener cannot be null");
-        Validate.notNull(priority, "Priority cannot be null");
-        Validate.notNull(executor, "Executor cannot be null");
-        Validate.notNull(plugin, "Plugin cannot be null");
-
-        if (!plugin.isEnabled()) {
-            throw new IllegalPluginAccessException("Plugin attempted to register " + event + " while not enabled");
-        }
-
-        if (useTimings) {
-            getEventListeners(event).register(new TimedRegisteredListener(listener, executor, priority, plugin, ignoreCancelled));
-        } else {
-            getEventListeners(event).register(new RegisteredListener(listener, executor, priority, plugin, ignoreCancelled));
-        }
-    }
-
-    private HandlerList getEventListeners(Class<? extends Event> type) {
-        try {
-            Method method = getRegistrationClass(type).getDeclaredMethod("getHandlerList");
-            method.setAccessible(true);
-            return (HandlerList) method.invoke(null);
-        } catch (Exception e) {
-            throw new IllegalPluginAccessException(e.toString());
-        }
-    }
-
-    private Class<? extends Event> getRegistrationClass(Class<? extends Event> clazz) {
-        try {
-            clazz.getDeclaredMethod("getHandlerList");
-            return clazz;
-        } catch (NoSuchMethodException e) {
-            if (clazz.getSuperclass() != null
-                    && !clazz.getSuperclass().equals(Event.class)
-                    && Event.class.isAssignableFrom(clazz.getSuperclass())) {
-                return getRegistrationClass(clazz.getSuperclass().asSubclass(Event.class));
-            } else {
-                throw new IllegalPluginAccessException("Unable to find handler list for event " + clazz.getName() + ". Static getHandlerList method required!");
-            }
-        }
-    }
-
-    public Permission getPermission(String name) {
-        return permissions.get(name.toLowerCase());
-    }
-
-    public void addPermission(Permission perm) {
-        String name = perm.getName().toLowerCase();
-
-        if (permissions.containsKey(name)) {
-            throw new IllegalArgumentException("The permission " + name + " is already defined!");
-        }
-
-        permissions.put(name, perm);
-        calculatePermissionDefault(perm);
-    }
-
-    public Set<Permission> getDefaultPermissions(boolean op) {
-        return ImmutableSet.copyOf(defaultPerms.get(op));
-    }
-
-    public void removePermission(Permission perm) {
-        removePermission(perm.getName());
-    }
-
-    public void removePermission(String name) {
-        permissions.remove(name.toLowerCase());
-    }
-
-    public void recalculatePermissionDefaults(Permission perm) {
-        if (perm != null && permissions.containsKey(perm.getName().toLowerCase())) {
-            defaultPerms.get(true).remove(perm);
-            defaultPerms.get(false).remove(perm);
-
-            calculatePermissionDefault(perm);
-        }
-    }
-
-    private void calculatePermissionDefault(Permission perm) {
-        if ((perm.getDefault() == PermissionDefault.OP) || (perm.getDefault() == PermissionDefault.TRUE)) {
-            defaultPerms.get(true).add(perm);
-            dirtyPermissibles(true);
-        }
-        if ((perm.getDefault() == PermissionDefault.NOT_OP) || (perm.getDefault() == PermissionDefault.TRUE)) {
-            defaultPerms.get(false).add(perm);
-            dirtyPermissibles(false);
-        }
-    }
-
-    private void dirtyPermissibles(boolean op) {
-        Set<Permissible> permissibles = getDefaultPermSubscriptions(op);
-
-        for (Permissible p : permissibles) {
-            p.recalculatePermissions();
-        }
-    }
-
-    public void subscribeToPermission(String permission, Permissible permissible) {
-        String name = permission.toLowerCase();
-        Map<Permissible, Boolean> map = permSubs.get(name);
-
-        if (map == null) {
-            map = new WeakHashMap<Permissible, Boolean>();
-            permSubs.put(name, map);
-        }
-
-        map.put(permissible, true);
-    }
-
-    public void unsubscribeFromPermission(String permission, Permissible permissible) {
-        String name = permission.toLowerCase();
-        Map<Permissible, Boolean> map = permSubs.get(name);
-
-        if (map != null) {
-            map.remove(permissible);
-
-            if (map.isEmpty()) {
-                permSubs.remove(name);
-            }
-        }
-    }
-
-    public Set<Permissible> getPermissionSubscriptions(String permission) {
-        String name = permission.toLowerCase();
-        Map<Permissible, Boolean> map = permSubs.get(name);
-
-        if (map == null) {
-            return ImmutableSet.of();
-        } else {
-            return ImmutableSet.copyOf(map.keySet());
-        }
-    }
-
-    public void subscribeToDefaultPerms(boolean op, Permissible permissible) {
-        Map<Permissible, Boolean> map = defSubs.get(op);
-
-        if (map == null) {
-            map = new WeakHashMap<Permissible, Boolean>();
-            defSubs.put(op, map);
-        }
-
-        map.put(permissible, true);
-    }
-
-    public void unsubscribeFromDefaultPerms(boolean op, Permissible permissible) {
-        Map<Permissible, Boolean> map = defSubs.get(op);
-
-        if (map != null) {
-            map.remove(permissible);
-
-            if (map.isEmpty()) {
-                defSubs.remove(op);
-            }
-        }
-    }
-
-    public Set<Permissible> getDefaultPermSubscriptions(boolean op) {
-        Map<Permissible, Boolean> map = defSubs.get(op);
-
-        if (map == null) {
-            return ImmutableSet.of();
-        } else {
-            return ImmutableSet.copyOf(map.keySet());
-        }
-    }
-
-    public Set<Permission> getPermissions() {
-        return new HashSet<Permission>(permissions.values());
-    }
-
-    public boolean useTimings() {
-        return useTimings;
-    }
-
-    /**
-     * Sets whether or not per event timing code should be used
-     *
-     * @param use True if per event timing code should be used
-     */
-    public void useTimings(boolean use) {
-        useTimings = use;
-    }
-}
diff --git a/src/main/java/org/bukkit/plugin/SimpleServicesManager.java b/src/main/java/org/bukkit/plugin/SimpleServicesManager.java
deleted file mode 100644
index 4e17711..0000000
--- a/src/main/java/org/bukkit/plugin/SimpleServicesManager.java
+++ /dev/null
@@ -1,306 +0,0 @@
-package org.bukkit.plugin;
-
-import org.bukkit.Bukkit;
-import org.bukkit.event.server.ServiceRegisterEvent;
-import org.bukkit.event.server.ServiceUnregisterEvent;
-
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableSet;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.Map;
-import java.util.List;
-import java.util.NoSuchElementException;
-import java.util.Set;
-
-/**
- * A simple services manager.
- */
-public class SimpleServicesManager implements ServicesManager {
-
-    /**
-     * Map of providers.
-     */
-    private final Map<Class<?>, List<RegisteredServiceProvider<?>>> providers = new HashMap<Class<?>, List<RegisteredServiceProvider<?>>>();
-
-    /**
-     * Register a provider of a service.
-     *
-     * @param <T> Provider
-     * @param service service class
-     * @param provider provider to register
-     * @param plugin plugin with the provider
-     * @param priority priority of the provider
-     */
-    public <T> void register(Class<T> service, T provider, Plugin plugin, ServicePriority priority) {
-        RegisteredServiceProvider<T> registeredProvider = null;
-        synchronized (providers) {
-            List<RegisteredServiceProvider<?>> registered = providers.get(service);
-            if (registered == null) {
-                registered = new ArrayList<RegisteredServiceProvider<?>>();
-                providers.put(service, registered);
-            }
-
-            registeredProvider = new RegisteredServiceProvider<T>(service, provider, priority, plugin);
-
-            // Insert the provider into the collection, much more efficient big O than sort
-            int position = Collections.binarySearch(registered, registeredProvider);
-            if (position < 0) {
-                registered.add(-(position + 1), registeredProvider);
-            } else {
-                registered.add(position, registeredProvider);
-            }
-
-        }
-        Bukkit.getServer().getPluginManager().callEvent(new ServiceRegisterEvent(registeredProvider));
-    }
-
-    /**
-     * Unregister all the providers registered by a particular plugin.
-     *
-     * @param plugin The plugin
-     */
-    public void unregisterAll(Plugin plugin) {
-        ArrayList<ServiceUnregisterEvent> unregisteredEvents = new ArrayList<ServiceUnregisterEvent>();
-        synchronized (providers) {
-            Iterator<Map.Entry<Class<?>, List<RegisteredServiceProvider<?>>>> it = providers.entrySet().iterator();
-
-            try {
-                while (it.hasNext()) {
-                    Map.Entry<Class<?>, List<RegisteredServiceProvider<?>>> entry = it.next();
-                    Iterator<RegisteredServiceProvider<?>> it2 = entry.getValue().iterator();
-
-                    try {
-                        // Removed entries that are from this plugin
-
-                        while (it2.hasNext()) {
-                            RegisteredServiceProvider<?> registered = it2.next();
-
-                            if (registered.getPlugin().equals(plugin)) {
-                                it2.remove();
-                                unregisteredEvents.add(new ServiceUnregisterEvent(registered));
-                            }
-                        }
-                    } catch (NoSuchElementException e) { // Why does Java suck
-                    }
-
-                    // Get rid of the empty list
-                    if (entry.getValue().size() == 0) {
-                        it.remove();
-                    }
-                }
-            } catch (NoSuchElementException e) {}
-        }
-        for (ServiceUnregisterEvent event : unregisteredEvents) {
-            Bukkit.getServer().getPluginManager().callEvent(event);
-        }
-    }
-
-    /**
-     * Unregister a particular provider for a particular service.
-     *
-     * @param service The service interface
-     * @param provider The service provider implementation
-     */
-    public void unregister(Class<?> service, Object provider) {
-        ArrayList<ServiceUnregisterEvent> unregisteredEvents = new ArrayList<ServiceUnregisterEvent>();
-        synchronized (providers) {
-            Iterator<Map.Entry<Class<?>, List<RegisteredServiceProvider<?>>>> it = providers.entrySet().iterator();
-
-            try {
-                while (it.hasNext()) {
-                    Map.Entry<Class<?>, List<RegisteredServiceProvider<?>>> entry = it.next();
-
-                    // We want a particular service
-                    if (entry.getKey() != service) {
-                        continue;
-                    }
-
-                    Iterator<RegisteredServiceProvider<?>> it2 = entry.getValue().iterator();
-
-                    try {
-                        // Removed entries that are from this plugin
-
-                        while (it2.hasNext()) {
-                            RegisteredServiceProvider<?> registered = it2.next();
-
-                            if (registered.getProvider() == provider) {
-                                it2.remove();
-                                unregisteredEvents.add(new ServiceUnregisterEvent(registered));
-                            }
-                        }
-                    } catch (NoSuchElementException e) { // Why does Java suck
-                    }
-
-                    // Get rid of the empty list
-                    if (entry.getValue().size() == 0) {
-                        it.remove();
-                    }
-                }
-            } catch (NoSuchElementException e) {}
-        }
-        for (ServiceUnregisterEvent event : unregisteredEvents) {
-            Bukkit.getServer().getPluginManager().callEvent(event);
-        }
-    }
-
-    /**
-     * Unregister a particular provider.
-     *
-     * @param provider The service provider implementation
-     */
-    public void unregister(Object provider) {
-        ArrayList<ServiceUnregisterEvent> unregisteredEvents = new ArrayList<ServiceUnregisterEvent>();
-        synchronized (providers) {
-            Iterator<Map.Entry<Class<?>, List<RegisteredServiceProvider<?>>>> it = providers.entrySet().iterator();
-
-            try {
-                while (it.hasNext()) {
-                    Map.Entry<Class<?>, List<RegisteredServiceProvider<?>>> entry = it.next();
-                    Iterator<RegisteredServiceProvider<?>> it2 = entry.getValue().iterator();
-
-                    try {
-                        // Removed entries that are from this plugin
-
-                        while (it2.hasNext()) {
-                            RegisteredServiceProvider<?> registered = it2.next();
-
-                            if (registered.getProvider().equals(provider)) {
-                                it2.remove();
-                                unregisteredEvents.add(new ServiceUnregisterEvent(registered));
-                            }
-                        }
-                    } catch (NoSuchElementException e) { // Why does Java suck
-                    }
-
-                    // Get rid of the empty list
-                    if (entry.getValue().size() == 0) {
-                        it.remove();
-                    }
-                }
-            } catch (NoSuchElementException e) {}
-        }
-        for (ServiceUnregisterEvent event : unregisteredEvents) {
-            Bukkit.getServer().getPluginManager().callEvent(event);
-        }
-    }
-
-    /**
-     * Queries for a provider. This may return if no provider has been
-     * registered for a service. The highest priority provider is returned.
-     *
-     * @param <T> The service interface
-     * @param service The service interface
-     * @return provider or null
-     */
-    public <T> T load(Class<T> service) {
-        synchronized (providers) {
-            List<RegisteredServiceProvider<?>> registered = providers.get(service);
-
-            if (registered == null) {
-                return null;
-            }
-
-            // This should not be null!
-            return service.cast(registered.get(0).getProvider());
-        }
-    }
-
-    /**
-     * Queries for a provider registration. This may return if no provider
-     * has been registered for a service.
-     *
-     * @param <T> The service interface
-     * @param service The service interface
-     * @return provider registration or null
-     */
-    @SuppressWarnings("unchecked")
-    public <T> RegisteredServiceProvider<T> getRegistration(Class<T> service) {
-        synchronized (providers) {
-            List<RegisteredServiceProvider<?>> registered = providers.get(service);
-
-            if (registered == null) {
-                return null;
-            }
-
-            // This should not be null!
-            return (RegisteredServiceProvider<T>) registered.get(0);
-        }
-    }
-
-    /**
-     * Get registrations of providers for a plugin.
-     *
-     * @param plugin The plugin
-     * @return provider registration or null
-     */
-    public List<RegisteredServiceProvider<?>> getRegistrations(Plugin plugin) {
-        ImmutableList.Builder<RegisteredServiceProvider<?>> ret = ImmutableList.<RegisteredServiceProvider<?>>builder();
-        synchronized (providers) {
-            for (List<RegisteredServiceProvider<?>> registered : providers.values()) {
-                for (RegisteredServiceProvider<?> provider : registered) {
-                    if (provider.getPlugin().equals(plugin)) {
-                        ret.add(provider);
-                    }
-                }
-            }
-        }
-        return ret.build();
-    }
-
-    /**
-     * Get registrations of providers for a service. The returned list is
-     * an unmodifiable copy.
-     *
-     * @param <T> The service interface
-     * @param service The service interface
-     * @return a copy of the list of registrations
-     */
-    @SuppressWarnings("unchecked")
-    public <T> List<RegisteredServiceProvider<T>> getRegistrations(Class<T> service) {
-        ImmutableList.Builder<RegisteredServiceProvider<T>> ret;
-        synchronized (providers) {
-            List<RegisteredServiceProvider<?>> registered = providers.get(service);
-
-            if (registered == null) {
-                return ImmutableList.<RegisteredServiceProvider<T>>of();
-            }
-
-            ret = ImmutableList.<RegisteredServiceProvider<T>>builder();
-
-            for (RegisteredServiceProvider<?> provider : registered) {
-                ret.add((RegisteredServiceProvider<T>) provider);
-            }
-
-        }
-        return ret.build();
-    }
-
-    /**
-     * Get a list of known services. A service is known if it has registered
-     * providers for it.
-     *
-     * @return a copy of the set of known services
-     */
-    public Set<Class<?>> getKnownServices() {
-        synchronized (providers) {
-            return ImmutableSet.<Class<?>>copyOf(providers.keySet());
-        }
-    }
-
-    /**
-     * Returns whether a provider has been registered for a service.
-     *
-     * @param <T> service
-     * @param service service to check
-     * @return true if and only if there are registered providers
-     */
-    public <T> boolean isProvidedFor(Class<T> service) {
-        synchronized (providers) {
-            return providers.containsKey(service);
-        }
-    }
-}
diff --git a/src/main/java/org/bukkit/plugin/TimedRegisteredListener.java b/src/main/java/org/bukkit/plugin/TimedRegisteredListener.java
deleted file mode 100644
index 164be93..0000000
--- a/src/main/java/org/bukkit/plugin/TimedRegisteredListener.java
+++ /dev/null
@@ -1,97 +0,0 @@
-package org.bukkit.plugin;
-
-import org.bukkit.event.Event;
-import org.bukkit.event.EventException;
-import org.bukkit.event.EventPriority;
-import org.bukkit.event.Listener;
-
-/**
- * Extends RegisteredListener to include timing information
- */
-public class TimedRegisteredListener extends RegisteredListener {
-    private int count;
-    private long totalTime;
-    private Class<? extends Event> eventClass;
-    private boolean multiple = false;
-
-    public TimedRegisteredListener(final Listener pluginListener, final EventExecutor eventExecutor, final EventPriority eventPriority, final Plugin registeredPlugin, final boolean listenCancelled) {
-        super(pluginListener, eventExecutor, eventPriority, registeredPlugin, listenCancelled);
-    }
-
-    @Override
-    public void callEvent(Event event) throws EventException {
-        if (event.isAsynchronous()) {
-            super.callEvent(event);
-            return;
-        }
-        count++;
-        Class<? extends Event> newEventClass = event.getClass();
-        if (this.eventClass == null) {
-            this.eventClass = newEventClass;
-        } else if (!this.eventClass.equals(newEventClass)) {
-            multiple = true;
-            this.eventClass = getCommonSuperclass(newEventClass, this.eventClass).asSubclass(Event.class);
-        }
-        long start = System.nanoTime();
-        super.callEvent(event);
-        totalTime += System.nanoTime() - start;
-    }
-
-    private static Class<?> getCommonSuperclass(Class<?> class1, Class<?> class2) {
-        while (!class1.isAssignableFrom(class2)) {
-            class1 = class1.getSuperclass();
-        }
-        return class1;
-    }
-
-    /**
-     * Resets the call count and total time for this listener
-     */
-    public void reset() {
-        count = 0;
-        totalTime = 0;
-    }
-
-    /**
-     * Gets the total times this listener has been called
-     *
-     * @return Times this listener has been called
-     */
-    public int getCount() {
-        return count;
-    }
-
-    /**
-     * Gets the total time calls to this listener have taken
-     *
-     * @return Total time for all calls of this listener
-     */
-    public long getTotalTime() {
-        return totalTime;
-    }
-
-    /**
-     * Gets the class of the events this listener handled. If it handled
-     * multiple classes of event, the closest shared superclass will be
-     * returned, such that for any event this listener has handled,
-     * <code>this.getEventClass().isAssignableFrom(event.getClass())</code>
-     * and no class <code>this.getEventClass().isAssignableFrom(clazz)
-     * {@literal && this.getEventClass() != clazz &&}
-     * event.getClass().isAssignableFrom(clazz)</code> for all handled events.
-     *
-     * @return the event class handled by this RegisteredListener
-     */
-    public Class<? extends Event> getEventClass() {
-        return eventClass;
-    }
-
-    /**
-     * Gets whether this listener has handled multiple events, such that for
-     * some two events, <code>eventA.getClass() != eventB.getClass()</code>.
-     *
-     * @return true if this listener has handled multiple events
-     */
-    public boolean hasMultiple() {
-        return multiple;
-    }
-}
diff --git a/src/main/java/org/bukkit/plugin/UnknownDependencyException.java b/src/main/java/org/bukkit/plugin/UnknownDependencyException.java
deleted file mode 100644
index a80251e..0000000
--- a/src/main/java/org/bukkit/plugin/UnknownDependencyException.java
+++ /dev/null
@@ -1,46 +0,0 @@
-package org.bukkit.plugin;
-
-/**
- * Thrown when attempting to load an invalid Plugin file
- */
-public class UnknownDependencyException extends RuntimeException {
-
-    private static final long serialVersionUID = 5721389371901775895L;
-
-    /**
-     * Constructs a new UnknownDependencyException based on the given
-     * Exception
-     *
-     * @param throwable Exception that triggered this Exception
-     */
-    public UnknownDependencyException(final Throwable throwable) {
-        super(throwable);
-    }
-
-    /**
-     * Constructs a new UnknownDependencyException with the given message
-     *
-     * @param message Brief message explaining the cause of the exception
-     */
-    public UnknownDependencyException(final String message) {
-        super(message);
-    }
-
-    /**
-     * Constructs a new UnknownDependencyException based on the given
-     * Exception
-     *
-     * @param message Brief message explaining the cause of the exception
-     * @param throwable Exception that triggered this Exception
-     */
-    public UnknownDependencyException(final Throwable throwable, final String message) {
-        super(message, throwable);
-    }
-
-    /**
-     * Constructs a new UnknownDependencyException
-     */
-    public UnknownDependencyException() {
-
-    }
-}
diff --git a/src/main/java/org/bukkit/plugin/java/JavaPlugin.java b/src/main/java/org/bukkit/plugin/java/JavaPlugin.java
deleted file mode 100644
index adbcd83..0000000
--- a/src/main/java/org/bukkit/plugin/java/JavaPlugin.java
+++ /dev/null
@@ -1,533 +0,0 @@
-package org.bukkit.plugin.java;
-
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.OutputStream;
-import java.io.Reader;
-import java.net.URL;
-import java.net.URLConnection;
-import java.nio.charset.Charset;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.Server;
-import org.bukkit.Warning.WarningState;
-import org.bukkit.command.Command;
-import org.bukkit.command.CommandSender;
-import org.bukkit.command.PluginCommand;
-import org.bukkit.configuration.InvalidConfigurationException;
-import org.bukkit.configuration.file.FileConfiguration;
-import org.bukkit.configuration.file.YamlConfiguration;
-import org.bukkit.generator.ChunkGenerator;
-import org.bukkit.plugin.AuthorNagException;
-import org.bukkit.plugin.PluginAwareness;
-import org.bukkit.plugin.PluginBase;
-import org.bukkit.plugin.PluginDescriptionFile;
-import org.bukkit.plugin.PluginLoader;
-import org.bukkit.plugin.PluginLogger;
-
-import com.avaje.ebean.EbeanServer;
-import com.avaje.ebean.EbeanServerFactory;
-import com.avaje.ebean.config.DataSourceConfig;
-import com.avaje.ebean.config.ServerConfig;
-import com.avaje.ebeaninternal.api.SpiEbeanServer;
-import com.avaje.ebeaninternal.server.ddl.DdlGenerator;
-import com.google.common.base.Charsets;
-import com.google.common.base.Preconditions;
-import com.google.common.io.ByteStreams;
-
-/**
- * Represents a Java plugin
- */
-public abstract class JavaPlugin extends PluginBase {
-    private boolean isEnabled = false;
-    private PluginLoader loader = null;
-    private Server server = null;
-    private File file = null;
-    private PluginDescriptionFile description = null;
-    private File dataFolder = null;
-    private ClassLoader classLoader = null;
-    private boolean naggable = true;
-    private EbeanServer ebean = null;
-    private FileConfiguration newConfig = null;
-    private File configFile = null;
-    private PluginLogger logger = null;
-
-    public JavaPlugin() {
-        final ClassLoader classLoader = this.getClass().getClassLoader();
-        if (!(classLoader instanceof PluginClassLoader)) {
-            throw new IllegalStateException("JavaPlugin requires " + PluginClassLoader.class.getName());
-        }
-        ((PluginClassLoader) classLoader).initialize(this);
-    }
-
-    /**
-     * @deprecated This method is intended for unit testing purposes when the
-     *     other {@linkplain #JavaPlugin(JavaPluginLoader,
-     *     PluginDescriptionFile, File, File) constructor} cannot be used.
-     *     <p>
-     *     Its existence may be temporary.
-     * @param loader the plugin loader
-     * @param server the server instance
-     * @param description the plugin's description
-     * @param dataFolder the plugin's data folder
-     * @param file the location of the plugin
-     */
-    @Deprecated
-    protected JavaPlugin(final PluginLoader loader, final Server server, final PluginDescriptionFile description, final File dataFolder, final File file) {
-        final ClassLoader classLoader = this.getClass().getClassLoader();
-        if (classLoader instanceof PluginClassLoader) {
-            throw new IllegalStateException("Cannot use initialization constructor at runtime");
-        }
-        init(loader, server, description, dataFolder, file, classLoader);
-    }
-
-    protected JavaPlugin(final JavaPluginLoader loader, final PluginDescriptionFile description, final File dataFolder, final File file) {
-        final ClassLoader classLoader = this.getClass().getClassLoader();
-        if (classLoader instanceof PluginClassLoader) {
-            throw new IllegalStateException("Cannot use initialization constructor at runtime");
-        }
-        init(loader, loader.server, description, dataFolder, file, classLoader);
-    }
-
-    /**
-     * Returns the folder that the plugin data's files are located in. The
-     * folder may not yet exist.
-     *
-     * @return The folder.
-     */
-    @Override
-    public final File getDataFolder() {
-        return dataFolder;
-    }
-
-    /**
-     * Gets the associated PluginLoader responsible for this plugin
-     *
-     * @return PluginLoader that controls this plugin
-     */
-    @Override
-    public final PluginLoader getPluginLoader() {
-        return loader;
-    }
-
-    /**
-     * Returns the Server instance currently running this plugin
-     *
-     * @return Server running this plugin
-     */
-    @Override
-    public final Server getServer() {
-        return server;
-    }
-
-    /**
-     * Returns a value indicating whether or not this plugin is currently
-     * enabled
-     *
-     * @return true if this plugin is enabled, otherwise false
-     */
-    @Override
-    public final boolean isEnabled() {
-        return isEnabled;
-    }
-
-    /**
-     * Returns the file which contains this plugin
-     *
-     * @return File containing this plugin
-     */
-    protected File getFile() {
-        return file;
-    }
-
-    /**
-     * Returns the plugin.yaml file containing the details for this plugin
-     *
-     * @return Contents of the plugin.yaml file
-     */
-    @Override
-    public final PluginDescriptionFile getDescription() {
-        return description;
-    }
-
-    @Override
-    public FileConfiguration getConfig() {
-        if (newConfig == null) {
-            reloadConfig();
-        }
-        return newConfig;
-    }
-
-    /**
-     * Provides a reader for a text file located inside the jar.
-     * <p>
-     * The returned reader will read text with the UTF-8 charset.
-     *
-     * @param file the filename of the resource to load
-     * @return null if {@link #getResource(String)} returns null
-     * @throws IllegalArgumentException if file is null
-     * @see ClassLoader#getResourceAsStream(String)
-     */
-    @SuppressWarnings("deprecation")
-    protected final Reader getTextResource(String file) {
-        final InputStream in = getResource(file);
-
-        return in == null ? null : new InputStreamReader(in, Charsets.UTF_8);
-    }
-
-    @SuppressWarnings("deprecation")
-    @Override
-    public void reloadConfig() {
-        newConfig = YamlConfiguration.loadConfiguration(configFile);
-
-        final InputStream defConfigStream = getResource("config.yml");
-        if (defConfigStream == null) {
-            return;
-        }
-
-        newConfig.setDefaults(YamlConfiguration.loadConfiguration(new InputStreamReader(defConfigStream, Charsets.UTF_8)));
-    }
-
-    @Override
-    public void saveConfig() {
-        try {
-            getConfig().save(configFile);
-        } catch (IOException ex) {
-            logger.log(Level.SEVERE, "Could not save config to " + configFile, ex);
-        }
-    }
-
-    @Override
-    public void saveDefaultConfig() {
-        if (!configFile.exists()) {
-            saveResource("config.yml", false);
-        }
-    }
-
-    @Override
-    public void saveResource(String resourcePath, boolean replace) {
-        if (resourcePath == null || resourcePath.equals("")) {
-            throw new IllegalArgumentException("ResourcePath cannot be null or empty");
-        }
-
-        resourcePath = resourcePath.replace('\\', '/');
-        InputStream in = getResource(resourcePath);
-        if (in == null) {
-            throw new IllegalArgumentException("The embedded resource '" + resourcePath + "' cannot be found in " + file);
-        }
-
-        File outFile = new File(dataFolder, resourcePath);
-        int lastIndex = resourcePath.lastIndexOf('/');
-        File outDir = new File(dataFolder, resourcePath.substring(0, lastIndex >= 0 ? lastIndex : 0));
-
-        if (!outDir.exists()) {
-            outDir.mkdirs();
-        }
-
-        try {
-            if (!outFile.exists() || replace) {
-                OutputStream out = new FileOutputStream(outFile);
-                byte[] buf = new byte[1024];
-                int len;
-                while ((len = in.read(buf)) > 0) {
-                    out.write(buf, 0, len);
-                }
-                out.close();
-                in.close();
-            } else {
-                logger.log(Level.WARNING, "Could not save " + outFile.getName() + " to " + outFile + " because " + outFile.getName() + " already exists.");
-            }
-        } catch (IOException ex) {
-            logger.log(Level.SEVERE, "Could not save " + outFile.getName() + " to " + outFile, ex);
-        }
-    }
-
-    @Override
-    public InputStream getResource(String filename) {
-        if (filename == null) {
-            throw new IllegalArgumentException("Filename cannot be null");
-        }
-
-        try {
-            URL url = getClassLoader().getResource(filename);
-
-            if (url == null) {
-                return null;
-            }
-
-            URLConnection connection = url.openConnection();
-            connection.setUseCaches(false);
-            return connection.getInputStream();
-        } catch (IOException ex) {
-            return null;
-        }
-    }
-
-    /**
-     * Returns the ClassLoader which holds this plugin
-     *
-     * @return ClassLoader holding this plugin
-     */
-    protected final ClassLoader getClassLoader() {
-        return classLoader;
-    }
-
-    /**
-     * Sets the enabled state of this plugin
-     *
-     * @param enabled true if enabled, otherwise false
-     */
-    protected final void setEnabled(final boolean enabled) {
-        if (isEnabled != enabled) {
-            isEnabled = enabled;
-
-            if (isEnabled) {
-                onEnable();
-            } else {
-                onDisable();
-            }
-        }
-    }
-
-    /**
-     * @param loader the plugin loader
-     * @param server the server instance
-     * @param description the plugin's description
-     * @param dataFolder the plugin's data folder
-     * @param file the location of the plugin
-     * @param classLoader the class loader
-     * @deprecated This method is legacy and will be removed - it must be
-     *     replaced by the specially provided constructor(s).
-     */
-    @Deprecated
-    protected final void initialize(PluginLoader loader, Server server, PluginDescriptionFile description, File dataFolder, File file, ClassLoader classLoader) {
-        if (server.getWarningState() == WarningState.OFF) {
-            return;
-        }
-        getLogger().log(Level.WARNING, getClass().getName() + " is already initialized", server.getWarningState() == WarningState.DEFAULT ? null : new AuthorNagException("Explicit initialization"));
-    }
-
-    final void init(PluginLoader loader, Server server, PluginDescriptionFile description, File dataFolder, File file, ClassLoader classLoader) {
-        this.loader = loader;
-        this.server = server;
-        this.file = file;
-        this.description = description;
-        this.dataFolder = dataFolder;
-        this.classLoader = classLoader;
-        this.configFile = new File(dataFolder, "config.yml");
-        this.logger = new PluginLogger(this);
-
-        if (description.isDatabaseEnabled()) {
-            ServerConfig db = new ServerConfig();
-
-            db.setDefaultServer(false);
-            db.setRegister(false);
-            db.setClasses(getDatabaseClasses());
-            db.setName(description.getName());
-            server.configureDbConfig(db);
-
-            DataSourceConfig ds = db.getDataSourceConfig();
-
-            ds.setUrl(replaceDatabaseString(ds.getUrl()));
-            dataFolder.mkdirs();
-
-            ClassLoader previous = Thread.currentThread().getContextClassLoader();
-
-            Thread.currentThread().setContextClassLoader(classLoader);
-            ebean = EbeanServerFactory.create(db);
-            Thread.currentThread().setContextClassLoader(previous);
-        }
-    }
-
-    /**
-     * Provides a list of all classes that should be persisted in the database
-     *
-     * @return List of Classes that are Ebeans
-     */
-    public List<Class<?>> getDatabaseClasses() {
-        return new ArrayList<Class<?>>();
-    }
-
-    private String replaceDatabaseString(String input) {
-        input = input.replaceAll("\\{DIR\\}", dataFolder.getPath().replaceAll("\\\\", "/") + "/");
-        input = input.replaceAll("\\{NAME\\}", description.getName().replaceAll("[^\\w_-]", ""));
-        return input;
-    }
-
-    /**
-     * Gets the initialization status of this plugin
-     *
-     * @return true if this plugin is initialized, otherwise false
-     * @deprecated This method cannot return false, as {@link
-     *     JavaPlugin} is now initialized in the constructor.
-     */
-    @Deprecated
-    public final boolean isInitialized() {
-        return true;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
-        return false;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public List<String> onTabComplete(CommandSender sender, Command command, String alias, String[] args) {
-        return null;
-    }
-
-    /**
-     * Gets the command with the given name, specific to this plugin. Commands
-     * need to be registered in the {@link PluginDescriptionFile#getCommands()
-     * PluginDescriptionFile} to exist at runtime.
-     *
-     * @param name name or alias of the command
-     * @return the plugin command if found, otherwise null
-     */
-    public PluginCommand getCommand(String name) {
-        String alias = name.toLowerCase();
-        PluginCommand command = getServer().getPluginCommand(alias);
-
-        if (command == null || command.getPlugin() != this) {
-            command = getServer().getPluginCommand(description.getName().toLowerCase() + ":" + alias);
-        }
-
-        if (command != null && command.getPlugin() == this) {
-            return command;
-        } else {
-            return null;
-        }
-    }
-
-    @Override
-    public void onLoad() {}
-
-    @Override
-    public void onDisable() {}
-
-    @Override
-    public void onEnable() {}
-
-    @Override
-    public ChunkGenerator getDefaultWorldGenerator(String worldName, String id) {
-        return null;
-    }
-
-    @Override
-    public final boolean isNaggable() {
-        return naggable;
-    }
-
-    @Override
-    public final void setNaggable(boolean canNag) {
-        this.naggable = canNag;
-    }
-
-    @Override
-    public EbeanServer getDatabase() {
-        Preconditions.checkState(description.isDatabaseEnabled(), "Plugin does not have database: true in plugin.yml");
-
-        return ebean;
-    }
-
-    protected void installDDL() {
-        SpiEbeanServer serv = (SpiEbeanServer) getDatabase();
-        DdlGenerator gen = serv.getDdlGenerator();
-
-        gen.runScript(false, gen.generateCreateDdl());
-    }
-
-    protected void removeDDL() {
-        SpiEbeanServer serv = (SpiEbeanServer) getDatabase();
-        DdlGenerator gen = serv.getDdlGenerator();
-
-        gen.runScript(true, gen.generateDropDdl());
-    }
-
-    @Override
-    public final Logger getLogger() {
-        return logger;
-    }
-
-    @Override
-    public String toString() {
-        return description.getFullName();
-    }
-
-    /**
-     * This method provides fast access to the plugin that has {@link
-     * #getProvidingPlugin(Class) provided} the given plugin class, which is
-     * usually the plugin that implemented it.
-     * <p>
-     * An exception to this would be if plugin's jar that contained the class
-     * does not extend the class, where the intended plugin would have
-     * resided in a different jar / classloader.
-     *
-     * @param <T> a class that extends JavaPlugin
-     * @param clazz the class desired
-     * @return the plugin that provides and implements said class
-     * @throws IllegalArgumentException if clazz is null
-     * @throws IllegalArgumentException if clazz does not extend {@link
-     *     JavaPlugin}
-     * @throws IllegalStateException if clazz was not provided by a plugin,
-     *     for example, if called with
-     *     <code>JavaPlugin.getPlugin(JavaPlugin.class)</code>
-     * @throws IllegalStateException if called from the static initializer for
-     *     given JavaPlugin
-     * @throws ClassCastException if plugin that provided the class does not
-     *     extend the class
-     */
-    public static <T extends JavaPlugin> T getPlugin(Class<T> clazz) {
-        Validate.notNull(clazz, "Null class cannot have a plugin");
-        if (!JavaPlugin.class.isAssignableFrom(clazz)) {
-            throw new IllegalArgumentException(clazz + " does not extend " + JavaPlugin.class);
-        }
-        final ClassLoader cl = clazz.getClassLoader();
-        if (!(cl instanceof PluginClassLoader)) {
-            throw new IllegalArgumentException(clazz + " is not initialized by " + PluginClassLoader.class);
-        }
-        JavaPlugin plugin = ((PluginClassLoader) cl).plugin;
-        if (plugin == null) {
-            throw new IllegalStateException("Cannot get plugin for " + clazz + " from a static initializer");
-        }
-        return clazz.cast(plugin);
-    }
-
-    /**
-     * This method provides fast access to the plugin that has provided the
-     * given class.
-     *
-     * @param clazz a class belonging to a plugin
-     * @return the plugin that provided the class
-     * @throws IllegalArgumentException if the class is not provided by a
-     *     JavaPlugin
-     * @throws IllegalArgumentException if class is null
-     * @throws IllegalStateException if called from the static initializer for
-     *     given JavaPlugin
-     */
-    public static JavaPlugin getProvidingPlugin(Class<?> clazz) {
-        Validate.notNull(clazz, "Null class cannot have a plugin");
-        final ClassLoader cl = clazz.getClassLoader();
-        if (!(cl instanceof PluginClassLoader)) {
-            throw new IllegalArgumentException(clazz + " is not provided by " + PluginClassLoader.class);
-        }
-        JavaPlugin plugin = ((PluginClassLoader) cl).plugin;
-        if (plugin == null) {
-            throw new IllegalStateException("Cannot get plugin for " + clazz + " from a static initializer");
-        }
-        return plugin;
-    }
-}
diff --git a/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java b/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java
deleted file mode 100644
index 2118771..0000000
--- a/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java
+++ /dev/null
@@ -1,373 +0,0 @@
-package org.bukkit.plugin.java;
-
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStream;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.LinkedHashMap;
-import java.util.Map;
-import java.util.Set;
-import java.util.jar.JarEntry;
-import java.util.jar.JarFile;
-import java.util.logging.Level;
-import java.util.regex.Pattern;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.Server;
-import org.bukkit.Warning;
-import org.bukkit.Warning.WarningState;
-import org.bukkit.configuration.serialization.ConfigurationSerializable;
-import org.bukkit.configuration.serialization.ConfigurationSerialization;
-import org.bukkit.event.Event;
-import org.bukkit.event.EventException;
-import org.bukkit.event.EventHandler;
-import org.bukkit.event.Listener;
-import org.bukkit.event.server.PluginDisableEvent;
-import org.bukkit.event.server.PluginEnableEvent;
-import org.bukkit.plugin.AuthorNagException;
-import org.bukkit.plugin.EventExecutor;
-import org.bukkit.plugin.InvalidDescriptionException;
-import org.bukkit.plugin.InvalidPluginException;
-import org.bukkit.plugin.Plugin;
-import org.bukkit.plugin.PluginDescriptionFile;
-import org.bukkit.plugin.PluginLoader;
-import org.bukkit.plugin.RegisteredListener;
-import org.bukkit.plugin.TimedRegisteredListener;
-import org.bukkit.plugin.UnknownDependencyException;
-import org.yaml.snakeyaml.error.YAMLException;
-
-/**
- * Represents a Java plugin loader, allowing plugins in the form of .jar
- */
-public final class JavaPluginLoader implements PluginLoader {
-    final Server server;
-    private final Pattern[] fileFilters = new Pattern[] { Pattern.compile("\\.jar$"), };
-    private final Map<String, Class<?>> classes = new HashMap<String, Class<?>>();
-    private final Map<String, PluginClassLoader> loaders = new LinkedHashMap<String, PluginClassLoader>();
-
-    /**
-     * This class was not meant to be constructed explicitly
-     * 
-     * @param instance the server instance
-     */
-    @Deprecated
-    public JavaPluginLoader(Server instance) {
-        Validate.notNull(instance, "Server cannot be null");
-        server = instance;
-    }
-
-    public Plugin loadPlugin(final File file) throws InvalidPluginException {
-        Validate.notNull(file, "File cannot be null");
-
-        if (!file.exists()) {
-            throw new InvalidPluginException(new FileNotFoundException(file.getPath() + " does not exist"));
-        }
-
-        final PluginDescriptionFile description;
-        try {
-            description = getPluginDescription(file);
-        } catch (InvalidDescriptionException ex) {
-            throw new InvalidPluginException(ex);
-        }
-
-        final File parentFile = file.getParentFile();
-        final File dataFolder = new File(parentFile, description.getName());
-        @SuppressWarnings("deprecation")
-        final File oldDataFolder = new File(parentFile, description.getRawName());
-
-        // Found old data folder
-        if (dataFolder.equals(oldDataFolder)) {
-            // They are equal -- nothing needs to be done!
-        } else if (dataFolder.isDirectory() && oldDataFolder.isDirectory()) {
-            server.getLogger().warning(String.format(
-                "While loading %s (%s) found old-data folder: `%s' next to the new one `%s'",
-                description.getFullName(),
-                file,
-                oldDataFolder,
-                dataFolder
-            ));
-        } else if (oldDataFolder.isDirectory() && !dataFolder.exists()) {
-            if (!oldDataFolder.renameTo(dataFolder)) {
-                throw new InvalidPluginException("Unable to rename old data folder: `" + oldDataFolder + "' to: `" + dataFolder + "'");
-            }
-            server.getLogger().log(Level.INFO, String.format(
-                "While loading %s (%s) renamed data folder: `%s' to `%s'",
-                description.getFullName(),
-                file,
-                oldDataFolder,
-                dataFolder
-            ));
-        }
-
-        if (dataFolder.exists() && !dataFolder.isDirectory()) {
-            throw new InvalidPluginException(String.format(
-                "Projected datafolder: `%s' for %s (%s) exists and is not a directory",
-                dataFolder,
-                description.getFullName(),
-                file
-            ));
-        }
-
-        for (final String pluginName : description.getDepend()) {
-            if (loaders == null) {
-                throw new UnknownDependencyException(pluginName);
-            }
-            PluginClassLoader current = loaders.get(pluginName);
-
-            if (current == null) {
-                throw new UnknownDependencyException(pluginName);
-            }
-        }
-
-        final PluginClassLoader loader;
-        try {
-            loader = new PluginClassLoader(this, getClass().getClassLoader(), description, dataFolder, file);
-        } catch (InvalidPluginException ex) {
-            throw ex;
-        } catch (Throwable ex) {
-            throw new InvalidPluginException(ex);
-        }
-
-        loaders.put(description.getName(), loader);
-
-        return loader.plugin;
-    }
-
-    public PluginDescriptionFile getPluginDescription(File file) throws InvalidDescriptionException {
-        Validate.notNull(file, "File cannot be null");
-
-        JarFile jar = null;
-        InputStream stream = null;
-
-        try {
-            jar = new JarFile(file);
-            JarEntry entry = jar.getJarEntry("plugin.yml");
-
-            if (entry == null) {
-                throw new InvalidDescriptionException(new FileNotFoundException("Jar does not contain plugin.yml"));
-            }
-
-            stream = jar.getInputStream(entry);
-
-            return new PluginDescriptionFile(stream);
-
-        } catch (IOException ex) {
-            throw new InvalidDescriptionException(ex);
-        } catch (YAMLException ex) {
-            throw new InvalidDescriptionException(ex);
-        } finally {
-            if (jar != null) {
-                try {
-                    jar.close();
-                } catch (IOException e) {
-                }
-            }
-            if (stream != null) {
-                try {
-                    stream.close();
-                } catch (IOException e) {
-                }
-            }
-        }
-    }
-
-    public Pattern[] getPluginFileFilters() {
-        return fileFilters.clone();
-    }
-
-    Class<?> getClassByName(final String name) {
-        Class<?> cachedClass = classes.get(name);
-
-        if (cachedClass != null) {
-            return cachedClass;
-        } else {
-            for (String current : loaders.keySet()) {
-                PluginClassLoader loader = loaders.get(current);
-
-                try {
-                    cachedClass = loader.findClass(name, false);
-                } catch (ClassNotFoundException cnfe) {}
-                if (cachedClass != null) {
-                    return cachedClass;
-                }
-            }
-        }
-        return null;
-    }
-
-    void setClass(final String name, final Class<?> clazz) {
-        if (!classes.containsKey(name)) {
-            classes.put(name, clazz);
-
-            if (ConfigurationSerializable.class.isAssignableFrom(clazz)) {
-                Class<? extends ConfigurationSerializable> serializable = clazz.asSubclass(ConfigurationSerializable.class);
-                ConfigurationSerialization.registerClass(serializable);
-            }
-        }
-    }
-
-    private void removeClass(String name) {
-        Class<?> clazz = classes.remove(name);
-
-        try {
-            if ((clazz != null) && (ConfigurationSerializable.class.isAssignableFrom(clazz))) {
-                Class<? extends ConfigurationSerializable> serializable = clazz.asSubclass(ConfigurationSerializable.class);
-                ConfigurationSerialization.unregisterClass(serializable);
-            }
-        } catch (NullPointerException ex) {
-            // Boggle!
-            // (Native methods throwing NPEs is not fun when you can't stop it before-hand)
-        }
-    }
-
-    public Map<Class<? extends Event>, Set<RegisteredListener>> createRegisteredListeners(Listener listener, final Plugin plugin) {
-        Validate.notNull(plugin, "Plugin can not be null");
-        Validate.notNull(listener, "Listener can not be null");
-
-        boolean useTimings = server.getPluginManager().useTimings();
-        Map<Class<? extends Event>, Set<RegisteredListener>> ret = new HashMap<Class<? extends Event>, Set<RegisteredListener>>();
-        Set<Method> methods;
-        try {
-            Method[] publicMethods = listener.getClass().getMethods();
-            Method[] privateMethods = listener.getClass().getDeclaredMethods();
-            methods = new HashSet<Method>(publicMethods.length + privateMethods.length, 1.0f);
-            for (Method method : publicMethods) {
-                methods.add(method);
-            }
-            for (Method method : privateMethods) {
-                methods.add(method);
-            }
-        } catch (NoClassDefFoundError e) {
-            plugin.getLogger().severe("Plugin " + plugin.getDescription().getFullName() + " has failed to register events for " + listener.getClass() + " because " + e.getMessage() + " does not exist.");
-            return ret;
-        }
-
-        for (final Method method : methods) {
-            final EventHandler eh = method.getAnnotation(EventHandler.class);
-            if (eh == null) continue;
-            // Do not register bridge or synthetic methods to avoid event duplication
-            // Fixes SPIGOT-893
-            if (method.isBridge() || method.isSynthetic()) {
-                continue;
-            }
-            final Class<?> checkClass;
-            if (method.getParameterTypes().length != 1 || !Event.class.isAssignableFrom(checkClass = method.getParameterTypes()[0])) {
-                plugin.getLogger().severe(plugin.getDescription().getFullName() + " attempted to register an invalid EventHandler method signature \"" + method.toGenericString() + "\" in " + listener.getClass());
-                continue;
-            }
-            final Class<? extends Event> eventClass = checkClass.asSubclass(Event.class);
-            method.setAccessible(true);
-            Set<RegisteredListener> eventSet = ret.get(eventClass);
-            if (eventSet == null) {
-                eventSet = new HashSet<RegisteredListener>();
-                ret.put(eventClass, eventSet);
-            }
-
-            for (Class<?> clazz = eventClass; Event.class.isAssignableFrom(clazz); clazz = clazz.getSuperclass()) {
-                // This loop checks for extending deprecated events
-                if (clazz.getAnnotation(Deprecated.class) != null) {
-                    Warning warning = clazz.getAnnotation(Warning.class);
-                    WarningState warningState = server.getWarningState();
-                    if (!warningState.printFor(warning)) {
-                        break;
-                    }
-                    plugin.getLogger().log(
-                            Level.WARNING,
-                            String.format(
-                                    "\"%s\" has registered a listener for %s on method \"%s\", but the event is Deprecated." +
-                                    " \"%s\"; please notify the authors %s.",
-                                    plugin.getDescription().getFullName(),
-                                    clazz.getName(),
-                                    method.toGenericString(),
-                                    (warning != null && warning.reason().length() != 0) ? warning.reason() : "Server performance will be affected",
-                                    Arrays.toString(plugin.getDescription().getAuthors().toArray())),
-                            warningState == WarningState.ON ? new AuthorNagException(null) : null);
-                    break;
-                }
-            }
-
-            EventExecutor executor = new EventExecutor() {
-                public void execute(Listener listener, Event event) throws EventException {
-                    try {
-                        if (!eventClass.isAssignableFrom(event.getClass())) {
-                            return;
-                        }
-                        method.invoke(listener, event);
-                    } catch (InvocationTargetException ex) {
-                        throw new EventException(ex.getCause());
-                    } catch (Throwable t) {
-                        throw new EventException(t);
-                    }
-                }
-            };
-            if (useTimings) {
-                eventSet.add(new TimedRegisteredListener(listener, executor, eh.priority(), plugin, eh.ignoreCancelled()));
-            } else {
-                eventSet.add(new RegisteredListener(listener, executor, eh.priority(), plugin, eh.ignoreCancelled()));
-            }
-        }
-        return ret;
-    }
-
-    public void enablePlugin(final Plugin plugin) {
-        Validate.isTrue(plugin instanceof JavaPlugin, "Plugin is not associated with this PluginLoader");
-
-        if (!plugin.isEnabled()) {
-            plugin.getLogger().info("Enabling " + plugin.getDescription().getFullName());
-
-            JavaPlugin jPlugin = (JavaPlugin) plugin;
-
-            String pluginName = jPlugin.getDescription().getName();
-
-            if (!loaders.containsKey(pluginName)) {
-                loaders.put(pluginName, (PluginClassLoader) jPlugin.getClassLoader());
-            }
-
-            try {
-                jPlugin.setEnabled(true);
-            } catch (Throwable ex) {
-                server.getLogger().log(Level.SEVERE, "Error occurred while enabling " + plugin.getDescription().getFullName() + " (Is it up to date?)", ex);
-            }
-
-            // Perhaps abort here, rather than continue going, but as it stands,
-            // an abort is not possible the way it's currently written
-            server.getPluginManager().callEvent(new PluginEnableEvent(plugin));
-        }
-    }
-
-    public void disablePlugin(Plugin plugin) {
-        Validate.isTrue(plugin instanceof JavaPlugin, "Plugin is not associated with this PluginLoader");
-
-        if (plugin.isEnabled()) {
-            String message = String.format("Disabling %s", plugin.getDescription().getFullName());
-            plugin.getLogger().info(message);
-
-            server.getPluginManager().callEvent(new PluginDisableEvent(plugin));
-
-            JavaPlugin jPlugin = (JavaPlugin) plugin;
-            ClassLoader cloader = jPlugin.getClassLoader();
-
-            try {
-                jPlugin.setEnabled(false);
-            } catch (Throwable ex) {
-                server.getLogger().log(Level.SEVERE, "Error occurred while disabling " + plugin.getDescription().getFullName() + " (Is it up to date?)", ex);
-            }
-
-            loaders.remove(jPlugin.getDescription().getName());
-
-            if (cloader instanceof PluginClassLoader) {
-                PluginClassLoader loader = (PluginClassLoader) cloader;
-                Set<String> names = loader.getClasses();
-
-                for (String name : names) {
-                    removeClass(name);
-                }
-            }
-        }
-    }
-}
diff --git a/src/main/java/org/bukkit/plugin/java/PluginClassLoader.java b/src/main/java/org/bukkit/plugin/java/PluginClassLoader.java
deleted file mode 100644
index 13f8633..0000000
--- a/src/main/java/org/bukkit/plugin/java/PluginClassLoader.java
+++ /dev/null
@@ -1,106 +0,0 @@
-package org.bukkit.plugin.java;
-
-import java.io.File;
-import java.net.MalformedURLException;
-import java.net.URL;
-import java.net.URLClassLoader;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Set;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.plugin.InvalidPluginException;
-import org.bukkit.plugin.PluginDescriptionFile;
-
-/**
- * A ClassLoader for plugins, to allow shared classes across multiple plugins
- */
-final class PluginClassLoader extends URLClassLoader {
-    private final JavaPluginLoader loader;
-    private final Map<String, Class<?>> classes = new HashMap<String, Class<?>>();
-    private final PluginDescriptionFile description;
-    private final File dataFolder;
-    private final File file;
-    final JavaPlugin plugin;
-    private JavaPlugin pluginInit;
-    private IllegalStateException pluginState;
-
-    PluginClassLoader(final JavaPluginLoader loader, final ClassLoader parent, final PluginDescriptionFile description, final File dataFolder, final File file) throws InvalidPluginException, MalformedURLException {
-        super(new URL[] {file.toURI().toURL()}, parent);
-        Validate.notNull(loader, "Loader cannot be null");
-
-        this.loader = loader;
-        this.description = description;
-        this.dataFolder = dataFolder;
-        this.file = file;
-
-        try {
-            Class<?> jarClass;
-            try {
-                jarClass = Class.forName(description.getMain(), true, this);
-            } catch (ClassNotFoundException ex) {
-                throw new InvalidPluginException("Cannot find main class `" + description.getMain() + "'", ex);
-            }
-
-            Class<? extends JavaPlugin> pluginClass;
-            try {
-                pluginClass = jarClass.asSubclass(JavaPlugin.class);
-            } catch (ClassCastException ex) {
-                throw new InvalidPluginException("main class `" + description.getMain() + "' does not extend JavaPlugin", ex);
-            }
-
-            plugin = pluginClass.newInstance();
-        } catch (IllegalAccessException ex) {
-            throw new InvalidPluginException("No public constructor", ex);
-        } catch (InstantiationException ex) {
-            throw new InvalidPluginException("Abnormal plugin type", ex);
-        }
-    }
-
-    @Override
-    protected Class<?> findClass(String name) throws ClassNotFoundException {
-        return findClass(name, true);
-    }
-
-    Class<?> findClass(String name, boolean checkGlobal) throws ClassNotFoundException {
-        if (name.startsWith("org.bukkit.") || name.startsWith("net.minecraft.")) {
-            throw new ClassNotFoundException(name);
-        }
-        Class<?> result = classes.get(name);
-
-        if (result == null) {
-            if (checkGlobal) {
-                result = loader.getClassByName(name);
-            }
-
-            if (result == null) {
-                result = super.findClass(name);
-
-                if (result != null) {
-                    loader.setClass(name, result);
-                }
-            }
-
-            classes.put(name, result);
-        }
-
-        return result;
-    }
-
-    Set<String> getClasses() {
-        return classes.keySet();
-    }
-
-    synchronized void initialize(JavaPlugin javaPlugin) {
-        Validate.notNull(javaPlugin, "Initializing plugin cannot be null");
-        Validate.isTrue(javaPlugin.getClass().getClassLoader() == this, "Cannot initialize plugin outside of this class loader");
-        if (this.plugin != null || this.pluginInit != null) {
-            throw new IllegalArgumentException("Plugin already initialized!", pluginState);
-        }
-
-        pluginState = new IllegalStateException("Initial initialization");
-        this.pluginInit = javaPlugin;
-
-        javaPlugin.init(loader, loader.server, description, dataFolder, file, this);
-    }
-}
diff --git a/src/main/java/org/bukkit/plugin/messaging/ChannelNameTooLongException.java b/src/main/java/org/bukkit/plugin/messaging/ChannelNameTooLongException.java
deleted file mode 100644
index 80ef8a2..0000000
--- a/src/main/java/org/bukkit/plugin/messaging/ChannelNameTooLongException.java
+++ /dev/null
@@ -1,15 +0,0 @@
-package org.bukkit.plugin.messaging;
-
-/**
- * Thrown if a Plugin Channel is too long.
- */
-@SuppressWarnings("serial")
-public class ChannelNameTooLongException extends RuntimeException {
-    public ChannelNameTooLongException() {
-        super("Attempted to send a Plugin Message to a channel that was too large. The maximum length a channel may be is " + Messenger.MAX_CHANNEL_SIZE + " chars.");
-    }
-
-    public ChannelNameTooLongException(String channel) {
-        super("Attempted to send a Plugin Message to a channel that was too large. The maximum length a channel may be is " + Messenger.MAX_CHANNEL_SIZE + " chars (attempted " + channel.length() + " - '" + channel + ".");
-    }
-}
diff --git a/src/main/java/org/bukkit/plugin/messaging/ChannelNotRegisteredException.java b/src/main/java/org/bukkit/plugin/messaging/ChannelNotRegisteredException.java
deleted file mode 100644
index 2266f17..0000000
--- a/src/main/java/org/bukkit/plugin/messaging/ChannelNotRegisteredException.java
+++ /dev/null
@@ -1,15 +0,0 @@
-package org.bukkit.plugin.messaging;
-
-/**
- * Thrown if a Plugin attempts to send a message on an unregistered channel.
- */
-@SuppressWarnings("serial")
-public class ChannelNotRegisteredException extends RuntimeException {
-    public ChannelNotRegisteredException() {
-        this("Attempted to send a plugin message through an unregistered channel.");
-    }
-
-    public ChannelNotRegisteredException(String channel) {
-        super("Attempted to send a plugin message through the unregistered channel `" + channel + "'.");
-    }
-}
diff --git a/src/main/java/org/bukkit/plugin/messaging/MessageTooLargeException.java b/src/main/java/org/bukkit/plugin/messaging/MessageTooLargeException.java
deleted file mode 100644
index 61af8c4..0000000
--- a/src/main/java/org/bukkit/plugin/messaging/MessageTooLargeException.java
+++ /dev/null
@@ -1,23 +0,0 @@
-package org.bukkit.plugin.messaging;
-
-/**
- * Thrown if a Plugin Message is sent that is too large to be sent.
- */
-@SuppressWarnings("serial")
-public class MessageTooLargeException extends RuntimeException {
-    public MessageTooLargeException() {
-        this("Attempted to send a plugin message that was too large. The maximum length a plugin message may be is " + Messenger.MAX_MESSAGE_SIZE + " bytes.");
-    }
-
-    public MessageTooLargeException(byte[] message) {
-        this(message.length);
-    }
-
-    public MessageTooLargeException(int length) {
-        this("Attempted to send a plugin message that was too large. The maximum length a plugin message may be is " + Messenger.MAX_MESSAGE_SIZE + " bytes (tried to send one that is " + length + " bytes long).");
-    }
-
-    public MessageTooLargeException(String msg) {
-        super(msg);
-    }
-}
diff --git a/src/main/java/org/bukkit/plugin/messaging/Messenger.java b/src/main/java/org/bukkit/plugin/messaging/Messenger.java
deleted file mode 100644
index 655afaf..0000000
--- a/src/main/java/org/bukkit/plugin/messaging/Messenger.java
+++ /dev/null
@@ -1,216 +0,0 @@
-package org.bukkit.plugin.messaging;
-
-import java.util.Set;
-import org.bukkit.entity.Player;
-import org.bukkit.plugin.Plugin;
-
-/**
- * A class responsible for managing the registrations of plugin channels and
- * their listeners.
- */
-public interface Messenger {
-
-    /**
-     * Represents the largest size that an individual Plugin Message may be.
-     */
-    public static final int MAX_MESSAGE_SIZE = 32766;
-
-    /**
-     * Represents the largest size that a Plugin Channel may be.
-     */
-    public static final int MAX_CHANNEL_SIZE = 20;
-
-    /**
-     * Checks if the specified channel is a reserved name.
-     *
-     * @param channel Channel name to check.
-     * @return True if the channel is reserved, otherwise false.
-     * @throws IllegalArgumentException Thrown if channel is null.
-     */
-    public boolean isReservedChannel(String channel);
-
-    /**
-     * Registers the specific plugin to the requested outgoing plugin channel,
-     * allowing it to send messages through that channel to any clients.
-     *
-     * @param plugin Plugin that wishes to send messages through the channel.
-     * @param channel Channel to register.
-     * @throws IllegalArgumentException Thrown if plugin or channel is null.
-     */
-    public void registerOutgoingPluginChannel(Plugin plugin, String channel);
-
-    /**
-     * Unregisters the specific plugin from the requested outgoing plugin
-     * channel, no longer allowing it to send messages through that channel to
-     * any clients.
-     *
-     * @param plugin Plugin that no longer wishes to send messages through the
-     *     channel.
-     * @param channel Channel to unregister.
-     * @throws IllegalArgumentException Thrown if plugin or channel is null.
-     */
-    public void unregisterOutgoingPluginChannel(Plugin plugin, String channel);
-
-    /**
-     * Unregisters the specific plugin from all outgoing plugin channels, no
-     * longer allowing it to send any plugin messages.
-     *
-     * @param plugin Plugin that no longer wishes to send plugin messages.
-     * @throws IllegalArgumentException Thrown if plugin is null.
-     */
-    public void unregisterOutgoingPluginChannel(Plugin plugin);
-
-    /**
-     * Registers the specific plugin for listening on the requested incoming
-     * plugin channel, allowing it to act upon any plugin messages.
-     *
-     * @param plugin Plugin that wishes to register to this channel.
-     * @param channel Channel to register.
-     * @param listener Listener to receive messages on.
-     * @return The resulting registration that was made as a result of this
-     *     method.
-     * @throws IllegalArgumentException Thrown if plugin, channel or listener
-     *     is null, or the listener is already registered for this channel.
-     */
-    public PluginMessageListenerRegistration registerIncomingPluginChannel(Plugin plugin, String channel, PluginMessageListener listener);
-
-    /**
-     * Unregisters the specific plugin's listener from listening on the
-     * requested incoming plugin channel, no longer allowing it to act upon
-     * any plugin messages.
-     *
-     * @param plugin Plugin that wishes to unregister from this channel.
-     * @param channel Channel to unregister.
-     * @param listener Listener to stop receiving messages on.
-     * @throws IllegalArgumentException Thrown if plugin, channel or listener
-     *     is null.
-     */
-    public void unregisterIncomingPluginChannel(Plugin plugin, String channel, PluginMessageListener listener);
-
-    /**
-     * Unregisters the specific plugin from listening on the requested
-     * incoming plugin channel, no longer allowing it to act upon any plugin
-     * messages.
-     *
-     * @param plugin Plugin that wishes to unregister from this channel.
-     * @param channel Channel to unregister.
-     * @throws IllegalArgumentException Thrown if plugin or channel is null.
-     */
-    public void unregisterIncomingPluginChannel(Plugin plugin, String channel);
-
-    /**
-     * Unregisters the specific plugin from listening on all plugin channels
-     * through all listeners.
-     *
-     * @param plugin Plugin that wishes to unregister from this channel.
-     * @throws IllegalArgumentException Thrown if plugin is null.
-     */
-    public void unregisterIncomingPluginChannel(Plugin plugin);
-
-    /**
-     * Gets a set containing all the outgoing plugin channels.
-     *
-     * @return List of all registered outgoing plugin channels.
-     */
-    public Set<String> getOutgoingChannels();
-
-    /**
-     * Gets a set containing all the outgoing plugin channels that the
-     * specified plugin is registered to.
-     *
-     * @param plugin Plugin to retrieve channels for.
-     * @return List of all registered outgoing plugin channels that a plugin
-     *     is registered to.
-     * @throws IllegalArgumentException Thrown if plugin is null.
-     */
-    public Set<String> getOutgoingChannels(Plugin plugin);
-
-    /**
-     * Gets a set containing all the incoming plugin channels.
-     *
-     * @return List of all registered incoming plugin channels.
-     */
-    public Set<String> getIncomingChannels();
-
-    /**
-     * Gets a set containing all the incoming plugin channels that the
-     * specified plugin is registered for.
-     *
-     * @param plugin Plugin to retrieve channels for.
-     * @return List of all registered incoming plugin channels that the plugin
-     *     is registered for.
-     * @throws IllegalArgumentException Thrown if plugin is null.
-     */
-    public Set<String> getIncomingChannels(Plugin plugin);
-
-    /**
-     * Gets a set containing all the incoming plugin channel registrations
-     * that the specified plugin has.
-     *
-     * @param plugin Plugin to retrieve registrations for.
-     * @return List of all registrations that the plugin has.
-     * @throws IllegalArgumentException Thrown if plugin is null.
-     */
-    public Set<PluginMessageListenerRegistration> getIncomingChannelRegistrations(Plugin plugin);
-
-    /**
-     * Gets a set containing all the incoming plugin channel registrations
-     * that are on the requested channel.
-     *
-     * @param channel Channel to retrieve registrations for.
-     * @return List of all registrations that are on the channel.
-     * @throws IllegalArgumentException Thrown if channel is null.
-     */
-    public Set<PluginMessageListenerRegistration> getIncomingChannelRegistrations(String channel);
-
-    /**
-     * Gets a set containing all the incoming plugin channel registrations
-     * that the specified plugin has on the requested channel.
-     *
-     * @param plugin Plugin to retrieve registrations for.
-     * @param channel Channel to filter registrations by.
-     * @return List of all registrations that the plugin has.
-     * @throws IllegalArgumentException Thrown if plugin or channel is null.
-     */
-    public Set<PluginMessageListenerRegistration> getIncomingChannelRegistrations(Plugin plugin, String channel);
-
-    /**
-     * Checks if the specified plugin message listener registration is valid.
-     * <p>
-     * A registration is considered valid if it has not be unregistered and
-     * that the plugin is still enabled.
-     *
-     * @param registration Registration to check.
-     * @return True if the registration is valid, otherwise false.
-     */
-    public boolean isRegistrationValid(PluginMessageListenerRegistration registration);
-
-    /**
-     * Checks if the specified plugin has registered to receive incoming
-     * messages through the requested channel.
-     *
-     * @param plugin Plugin to check registration for.
-     * @param channel Channel to test for.
-     * @return True if the channel is registered, else false.
-     */
-    public boolean isIncomingChannelRegistered(Plugin plugin, String channel);
-
-    /**
-     * Checks if the specified plugin has registered to send outgoing messages
-     * through the requested channel.
-     *
-     * @param plugin Plugin to check registration for.
-     * @param channel Channel to test for.
-     * @return True if the channel is registered, else false.
-     */
-    public boolean isOutgoingChannelRegistered(Plugin plugin, String channel);
-
-    /**
-     * Dispatches the specified incoming message to any registered listeners.
-     *
-     * @param source Source of the message.
-     * @param channel Channel that the message was sent by.
-     * @param message Raw payload of the message.
-     */
-    public void dispatchIncomingMessage(Player source, String channel, byte[] message);
-}
diff --git a/src/main/java/org/bukkit/plugin/messaging/PluginChannelDirection.java b/src/main/java/org/bukkit/plugin/messaging/PluginChannelDirection.java
deleted file mode 100644
index 3d7ec2e..0000000
--- a/src/main/java/org/bukkit/plugin/messaging/PluginChannelDirection.java
+++ /dev/null
@@ -1,17 +0,0 @@
-package org.bukkit.plugin.messaging;
-
-/**
- * Represents the different directions a plugin channel may go.
- */
-public enum PluginChannelDirection {
-
-    /**
-     * The plugin channel is being sent to the server from a client.
-     */
-    INCOMING,
-
-    /**
-     * The plugin channel is being sent to a client from the server.
-     */
-    OUTGOING
-}
diff --git a/src/main/java/org/bukkit/plugin/messaging/PluginMessageListener.java b/src/main/java/org/bukkit/plugin/messaging/PluginMessageListener.java
deleted file mode 100644
index f1aa080..0000000
--- a/src/main/java/org/bukkit/plugin/messaging/PluginMessageListener.java
+++ /dev/null
@@ -1,20 +0,0 @@
-package org.bukkit.plugin.messaging;
-
-import org.bukkit.entity.Player;
-
-/**
- * A listener for a specific Plugin Channel, which will receive notifications
- * of messages sent from a client.
- */
-public interface PluginMessageListener {
-
-    /**
-     * A method that will be thrown when a PluginMessageSource sends a plugin
-     * message on a registered channel.
-     *
-     * @param channel Channel that the message was sent through.
-     * @param player Source of the message.
-     * @param message The raw message that was sent.
-     */
-    public void onPluginMessageReceived(String channel, Player player, byte[] message);
-}
diff --git a/src/main/java/org/bukkit/plugin/messaging/PluginMessageListenerRegistration.java b/src/main/java/org/bukkit/plugin/messaging/PluginMessageListenerRegistration.java
deleted file mode 100644
index 29929bf..0000000
--- a/src/main/java/org/bukkit/plugin/messaging/PluginMessageListenerRegistration.java
+++ /dev/null
@@ -1,104 +0,0 @@
-package org.bukkit.plugin.messaging;
-
-import org.bukkit.plugin.Plugin;
-
-/**
- * Contains information about a {@link Plugin}s registration to a plugin
- * channel.
- */
-public final class PluginMessageListenerRegistration {
-    private final Messenger messenger;
-    private final Plugin plugin;
-    private final String channel;
-    private final PluginMessageListener listener;
-
-    public PluginMessageListenerRegistration(Messenger messenger, Plugin plugin, String channel, PluginMessageListener listener) {
-        if (messenger == null) {
-            throw new IllegalArgumentException("Messenger cannot be null!");
-        }
-        if (plugin == null) {
-            throw new IllegalArgumentException("Plugin cannot be null!");
-        }
-        if (channel == null) {
-            throw new IllegalArgumentException("Channel cannot be null!");
-        }
-        if (listener == null) {
-            throw new IllegalArgumentException("Listener cannot be null!");
-        }
-
-        this.messenger = messenger;
-        this.plugin = plugin;
-        this.channel = channel;
-        this.listener = listener;
-    }
-
-    /**
-     * Gets the plugin channel that this registration is about.
-     *
-     * @return Plugin channel.
-     */
-    public String getChannel() {
-        return channel;
-    }
-
-    /**
-     * Gets the registered listener described by this registration.
-     *
-     * @return Registered listener.
-     */
-    public PluginMessageListener getListener() {
-        return listener;
-    }
-
-    /**
-     * Gets the plugin that this registration is for.
-     *
-     * @return Registered plugin.
-     */
-    public Plugin getPlugin() {
-        return plugin;
-    }
-
-    /**
-     * Checks if this registration is still valid.
-     *
-     * @return True if this registration is still valid, otherwise false.
-     */
-    public boolean isValid() {
-        return messenger.isRegistrationValid(this);
-    }
-
-    @Override
-    public boolean equals(Object obj) {
-        if (obj == null) {
-            return false;
-        }
-        if (getClass() != obj.getClass()) {
-            return false;
-        }
-        final PluginMessageListenerRegistration other = (PluginMessageListenerRegistration) obj;
-        if (this.messenger != other.messenger && (this.messenger == null || !this.messenger.equals(other.messenger))) {
-            return false;
-        }
-        if (this.plugin != other.plugin && (this.plugin == null || !this.plugin.equals(other.plugin))) {
-            return false;
-        }
-        if ((this.channel == null) ? (other.channel != null) : !this.channel.equals(other.channel)) {
-            return false;
-        }
-        if (this.listener != other.listener && (this.listener == null || !this.listener.equals(other.listener))) {
-            return false;
-        }
-        return true;
-    }
-
-    @Override
-    public int hashCode() {
-        int hash = 7;
-        hash = 53 * hash + (this.messenger != null ? this.messenger.hashCode() : 0);
-        hash = 53 * hash + (this.plugin != null ? this.plugin.hashCode() : 0);
-        hash = 53 * hash + (this.channel != null ? this.channel.hashCode() : 0);
-        hash = 53 * hash + (this.listener != null ? this.listener.hashCode() : 0);
-        return hash;
-    }
-}
diff --git a/src/main/java/org/bukkit/plugin/messaging/PluginMessageRecipient.java b/src/main/java/org/bukkit/plugin/messaging/PluginMessageRecipient.java
deleted file mode 100644
index e5c5916..0000000
--- a/src/main/java/org/bukkit/plugin/messaging/PluginMessageRecipient.java
+++ /dev/null
@@ -1,38 +0,0 @@
-package org.bukkit.plugin.messaging;
-
-import java.util.Set;
-import org.bukkit.plugin.Plugin;
-
-/**
- * Represents a possible recipient for a Plugin Message.
- */
-public interface PluginMessageRecipient {
-    /**
-     * Sends this recipient a Plugin Message on the specified outgoing
-     * channel.
-     * <p>
-     * The message may not be larger than {@link Messenger#MAX_MESSAGE_SIZE}
-     * bytes, and the plugin must be registered to send messages on the
-     * specified channel.
-     *
-     * @param source The plugin that sent this message.
-     * @param channel The channel to send this message on.
-     * @param message The raw message to send.
-     * @throws IllegalArgumentException Thrown if the source plugin is
-     *     disabled.
-     * @throws IllegalArgumentException Thrown if source, channel or message
-     *     is null.
-     * @throws MessageTooLargeException Thrown if the message is too big.
-     * @throws ChannelNotRegisteredException Thrown if the channel is not
-     *     registered for this plugin.
-     */
-    public void sendPluginMessage(Plugin source, String channel, byte[] message);
-
-    /**
-     * Gets a set containing all the Plugin Channels that this client is
-     * listening on.
-     *
-     * @return Set containing all the channels that this client may accept.
-     */
-    public Set<String> getListeningPluginChannels();
-}
diff --git a/src/main/java/org/bukkit/plugin/messaging/ReservedChannelException.java b/src/main/java/org/bukkit/plugin/messaging/ReservedChannelException.java
deleted file mode 100644
index 0221f04..0000000
--- a/src/main/java/org/bukkit/plugin/messaging/ReservedChannelException.java
+++ /dev/null
@@ -1,16 +0,0 @@
-package org.bukkit.plugin.messaging;
-
-/**
- * Thrown if a plugin attempts to register for a reserved channel (such as
- * "REGISTER")
- */
-@SuppressWarnings("serial")
-public class ReservedChannelException extends RuntimeException {
-    public ReservedChannelException() {
-        this("Attempted to register for a reserved channel name.");
-    }
-
-    public ReservedChannelException(String name) {
-        super("Attempted to register for a reserved channel name ('" + name + "')");
-    }
-}
diff --git a/src/main/java/org/bukkit/plugin/messaging/StandardMessenger.java b/src/main/java/org/bukkit/plugin/messaging/StandardMessenger.java
deleted file mode 100644
index a906f8d..0000000
--- a/src/main/java/org/bukkit/plugin/messaging/StandardMessenger.java
+++ /dev/null
@@ -1,481 +0,0 @@
-package org.bukkit.plugin.messaging;
-
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.ImmutableSet.Builder;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Map;
-import java.util.Set;
-import org.bukkit.entity.Player;
-import org.bukkit.plugin.Plugin;
-
-/**
- * Standard implementation to {@link Messenger}
- */
-public class StandardMessenger implements Messenger {
-    private final Map<String, Set<PluginMessageListenerRegistration>> incomingByChannel = new HashMap<String, Set<PluginMessageListenerRegistration>>();
-    private final Map<Plugin, Set<PluginMessageListenerRegistration>> incomingByPlugin = new HashMap<Plugin, Set<PluginMessageListenerRegistration>>();
-    private final Map<String, Set<Plugin>> outgoingByChannel = new HashMap<String, Set<Plugin>>();
-    private final Map<Plugin, Set<String>> outgoingByPlugin = new HashMap<Plugin, Set<String>>();
-    private final Object incomingLock = new Object();
-    private final Object outgoingLock = new Object();
-
-    private void addToOutgoing(Plugin plugin, String channel) {
-        synchronized (outgoingLock) {
-            Set<Plugin> plugins = outgoingByChannel.get(channel);
-            Set<String> channels = outgoingByPlugin.get(plugin);
-
-            if (plugins == null) {
-                plugins = new HashSet<Plugin>();
-                outgoingByChannel.put(channel, plugins);
-            }
-
-            if (channels == null) {
-                channels = new HashSet<String>();
-                outgoingByPlugin.put(plugin, channels);
-            }
-
-            plugins.add(plugin);
-            channels.add(channel);
-        }
-    }
-
-    private void removeFromOutgoing(Plugin plugin, String channel) {
-        synchronized (outgoingLock) {
-            Set<Plugin> plugins = outgoingByChannel.get(channel);
-            Set<String> channels = outgoingByPlugin.get(plugin);
-
-            if (plugins != null) {
-                plugins.remove(plugin);
-
-                if (plugins.isEmpty()) {
-                    outgoingByChannel.remove(channel);
-                }
-            }
-
-            if (channels != null) {
-                channels.remove(channel);
-
-                if (channels.isEmpty()) {
-                    outgoingByChannel.remove(channel);
-                }
-            }
-        }
-    }
-
-    private void removeFromOutgoing(Plugin plugin) {
-        synchronized (outgoingLock) {
-            Set<String> channels = outgoingByPlugin.get(plugin);
-
-            if (channels != null) {
-                String[] toRemove = channels.toArray(new String[0]);
-
-                outgoingByPlugin.remove(plugin);
-
-                for (String channel : toRemove) {
-                    removeFromOutgoing(plugin, channel);
-                }
-            }
-        }
-    }
-
-    private void addToIncoming(PluginMessageListenerRegistration registration) {
-        synchronized (incomingLock) {
-            Set<PluginMessageListenerRegistration> registrations = incomingByChannel.get(registration.getChannel());
-
-            if (registrations == null) {
-                registrations = new HashSet<PluginMessageListenerRegistration>();
-                incomingByChannel.put(registration.getChannel(), registrations);
-            } else {
-                if (registrations.contains(registration)) {
-                    throw new IllegalArgumentException("This registration already exists");
-                }
-            }
-
-            registrations.add(registration);
-
-            registrations = incomingByPlugin.get(registration.getPlugin());
-
-            if (registrations == null) {
-                registrations = new HashSet<PluginMessageListenerRegistration>();
-                incomingByPlugin.put(registration.getPlugin(), registrations);
-            } else {
-                if (registrations.contains(registration)) {
-                    throw new IllegalArgumentException("This registration already exists");
-                }
-            }
-
-            registrations.add(registration);
-        }
-    }
-
-    private void removeFromIncoming(PluginMessageListenerRegistration registration) {
-        synchronized (incomingLock) {
-            Set<PluginMessageListenerRegistration> registrations = incomingByChannel.get(registration.getChannel());
-
-            if (registrations != null) {
-                registrations.remove(registration);
-
-                if (registrations.isEmpty()) {
-                    incomingByChannel.remove(registration.getChannel());
-                }
-            }
-
-            registrations = incomingByPlugin.get(registration.getPlugin());
-
-            if (registrations != null) {
-                registrations.remove(registration);
-
-                if (registrations.isEmpty()) {
-                    incomingByPlugin.remove(registration.getPlugin());
-                }
-            }
-        }
-    }
-
-    private void removeFromIncoming(Plugin plugin, String channel) {
-        synchronized (incomingLock) {
-            Set<PluginMessageListenerRegistration> registrations = incomingByPlugin.get(plugin);
-
-            if (registrations != null) {
-                PluginMessageListenerRegistration[] toRemove = registrations.toArray(new PluginMessageListenerRegistration[0]);
-
-                for (PluginMessageListenerRegistration registration : toRemove) {
-                    if (registration.getChannel().equals(channel)) {
-                        removeFromIncoming(registration);
-                    }
-                }
-            }
-        }
-    }
-
-    private void removeFromIncoming(Plugin plugin) {
-        synchronized (incomingLock) {
-            Set<PluginMessageListenerRegistration> registrations = incomingByPlugin.get(plugin);
-
-            if (registrations != null) {
-                PluginMessageListenerRegistration[] toRemove = registrations.toArray(new PluginMessageListenerRegistration[0]);
-
-                incomingByPlugin.remove(plugin);
-
-                for (PluginMessageListenerRegistration registration : toRemove) {
-                    removeFromIncoming(registration);
-                }
-            }
-        }
-    }
-
-    public boolean isReservedChannel(String channel) {
-        validateChannel(channel);
-
-        return channel.equals("REGISTER") || channel.equals("UNREGISTER");
-    }
-
-    public void registerOutgoingPluginChannel(Plugin plugin, String channel) {
-        if (plugin == null) {
-            throw new IllegalArgumentException("Plugin cannot be null");
-        }
-        validateChannel(channel);
-        if (isReservedChannel(channel)) {
-            throw new ReservedChannelException(channel);
-        }
-
-        addToOutgoing(plugin, channel);
-    }
-
-    public void unregisterOutgoingPluginChannel(Plugin plugin, String channel) {
-        if (plugin == null) {
-            throw new IllegalArgumentException("Plugin cannot be null");
-        }
-        validateChannel(channel);
-
-        removeFromOutgoing(plugin, channel);
-    }
-
-    public void unregisterOutgoingPluginChannel(Plugin plugin) {
-        if (plugin == null) {
-            throw new IllegalArgumentException("Plugin cannot be null");
-        }
-
-        removeFromOutgoing(plugin);
-    }
-
-    public PluginMessageListenerRegistration registerIncomingPluginChannel(Plugin plugin, String channel, PluginMessageListener listener) {
-        if (plugin == null) {
-            throw new IllegalArgumentException("Plugin cannot be null");
-        }
-        validateChannel(channel);
-        if (isReservedChannel(channel)) {
-            throw new ReservedChannelException(channel);
-        }
-        if (listener == null) {
-            throw new IllegalArgumentException("Listener cannot be null");
-        }
-
-        PluginMessageListenerRegistration result = new PluginMessageListenerRegistration(this, plugin, channel, listener);
-
-        addToIncoming(result);
-
-        return result;
-    }
-
-    public void unregisterIncomingPluginChannel(Plugin plugin, String channel, PluginMessageListener listener) {
-        if (plugin == null) {
-            throw new IllegalArgumentException("Plugin cannot be null");
-        }
-        if (listener == null) {
-            throw new IllegalArgumentException("Listener cannot be null");
-        }
-        validateChannel(channel);
-
-        removeFromIncoming(new PluginMessageListenerRegistration(this, plugin, channel, listener));
-    }
-
-    public void unregisterIncomingPluginChannel(Plugin plugin, String channel) {
-        if (plugin == null) {
-            throw new IllegalArgumentException("Plugin cannot be null");
-        }
-        validateChannel(channel);
-
-        removeFromIncoming(plugin, channel);
-    }
-
-    public void unregisterIncomingPluginChannel(Plugin plugin) {
-        if (plugin == null) {
-            throw new IllegalArgumentException("Plugin cannot be null");
-        }
-
-        removeFromIncoming(plugin);
-    }
-
-    public Set<String> getOutgoingChannels() {
-        synchronized (outgoingLock) {
-            Set<String> keys = outgoingByChannel.keySet();
-            return ImmutableSet.copyOf(keys);
-        }
-    }
-
-    public Set<String> getOutgoingChannels(Plugin plugin) {
-        if (plugin == null) {
-            throw new IllegalArgumentException("Plugin cannot be null");
-        }
-
-        synchronized (outgoingLock) {
-            Set<String> channels = outgoingByPlugin.get(plugin);
-
-            if (channels != null) {
-                return ImmutableSet.copyOf(channels);
-            } else {
-                return ImmutableSet.of();
-            }
-        }
-    }
-
-    public Set<String> getIncomingChannels() {
-        synchronized (incomingLock) {
-            Set<String> keys = incomingByChannel.keySet();
-            return ImmutableSet.copyOf(keys);
-        }
-    }
-
-    public Set<String> getIncomingChannels(Plugin plugin) {
-        if (plugin == null) {
-            throw new IllegalArgumentException("Plugin cannot be null");
-        }
-
-        synchronized (incomingLock) {
-            Set<PluginMessageListenerRegistration> registrations = incomingByPlugin.get(plugin);
-
-            if (registrations != null) {
-                Builder<String> builder = ImmutableSet.builder();
-
-                for (PluginMessageListenerRegistration registration : registrations) {
-                    builder.add(registration.getChannel());
-                }
-
-                return builder.build();
-            } else {
-                return ImmutableSet.of();
-            }
-        }
-    }
-
-    public Set<PluginMessageListenerRegistration> getIncomingChannelRegistrations(Plugin plugin) {
-        if (plugin == null) {
-            throw new IllegalArgumentException("Plugin cannot be null");
-        }
-
-        synchronized (incomingLock) {
-            Set<PluginMessageListenerRegistration> registrations = incomingByPlugin.get(plugin);
-
-            if (registrations != null) {
-                return ImmutableSet.copyOf(registrations);
-            } else {
-                return ImmutableSet.of();
-            }
-        }
-    }
-
-    public Set<PluginMessageListenerRegistration> getIncomingChannelRegistrations(String channel) {
-        validateChannel(channel);
-
-        synchronized (incomingLock) {
-            Set<PluginMessageListenerRegistration> registrations = incomingByChannel.get(channel);
-
-            if (registrations != null) {
-                return ImmutableSet.copyOf(registrations);
-            } else {
-                return ImmutableSet.of();
-            }
-        }
-    }
-
-    public Set<PluginMessageListenerRegistration> getIncomingChannelRegistrations(Plugin plugin, String channel) {
-        if (plugin == null) {
-            throw new IllegalArgumentException("Plugin cannot be null");
-        }
-        validateChannel(channel);
-
-        synchronized (incomingLock) {
-            Set<PluginMessageListenerRegistration> registrations = incomingByPlugin.get(plugin);
-
-            if (registrations != null) {
-                Builder<PluginMessageListenerRegistration> builder = ImmutableSet.builder();
-
-                for (PluginMessageListenerRegistration registration : registrations) {
-                    if (registration.getChannel().equals(channel)) {
-                        builder.add(registration);
-                    }
-                }
-
-                return builder.build();
-            } else {
-                return ImmutableSet.of();
-            }
-        }
-    }
-
-    public boolean isRegistrationValid(PluginMessageListenerRegistration registration) {
-        if (registration == null) {
-            throw new IllegalArgumentException("Registration cannot be null");
-        }
-
-        synchronized (incomingLock) {
-            Set<PluginMessageListenerRegistration> registrations = incomingByPlugin.get(registration.getPlugin());
-
-            if (registrations != null) {
-                return registrations.contains(registration);
-            }
-
-            return false;
-        }
-    }
-
-    public boolean isIncomingChannelRegistered(Plugin plugin, String channel) {
-        if (plugin == null) {
-            throw new IllegalArgumentException("Plugin cannot be null");
-        }
-        validateChannel(channel);
-
-        synchronized (incomingLock) {
-            Set<PluginMessageListenerRegistration> registrations = incomingByPlugin.get(plugin);
-
-            if (registrations != null) {
-                for (PluginMessageListenerRegistration registration : registrations) {
-                    if (registration.getChannel().equals(channel)) {
-                        return true;
-                    }
-                }
-            }
-
-            return false;
-        }
-    }
-
-    public boolean isOutgoingChannelRegistered(Plugin plugin, String channel) {
-        if (plugin == null) {
-            throw new IllegalArgumentException("Plugin cannot be null");
-        }
-        validateChannel(channel);
-
-        synchronized (outgoingLock) {
-            Set<String> channels = outgoingByPlugin.get(plugin);
-
-            if (channels != null) {
-                return channels.contains(channel);
-            }
-
-            return false;
-        }
-    }
-
-    public void dispatchIncomingMessage(Player source, String channel, byte[] message) {
-        if (source == null) {
-            throw new IllegalArgumentException("Player source cannot be null");
-        }
-        if (message == null) {
-            throw new IllegalArgumentException("Message cannot be null");
-        }
-        validateChannel(channel);
-
-        Set<PluginMessageListenerRegistration> registrations = getIncomingChannelRegistrations(channel);
-
-        for (PluginMessageListenerRegistration registration : registrations) {
-            registration.getListener().onPluginMessageReceived(channel, source, message);
-        }
-    }
-
-    /**
-     * Validates a Plugin Channel name.
-     *
-     * @param channel Channel name to validate.
-     */
-    public static void validateChannel(String channel) {
-        if (channel == null) {
-            throw new IllegalArgumentException("Channel cannot be null");
-        }
-        if (channel.length() > Messenger.MAX_CHANNEL_SIZE) {
-            throw new ChannelNameTooLongException(channel);
-        }
-    }
-
-    /**
-     * Validates the input of a Plugin Message, ensuring the arguments are all
-     * valid.
-     *
-     * @param messenger Messenger to use for validation.
-     * @param source Source plugin of the Message.
-     * @param channel Plugin Channel to send the message by.
-     * @param message Raw message payload to send.
-     * @throws IllegalArgumentException Thrown if the source plugin is
-     *     disabled.
-     * @throws IllegalArgumentException Thrown if source, channel or message
-     *     is null.
-     * @throws MessageTooLargeException Thrown if the message is too big.
-     * @throws ChannelNameTooLongException Thrown if the channel name is too
-     *     long.
-     * @throws ChannelNotRegisteredException Thrown if the channel is not
-     *     registered for this plugin.
-     */
-    public static void validatePluginMessage(Messenger messenger, Plugin source, String channel, byte[] message) {
-        if (messenger == null) {
-            throw new IllegalArgumentException("Messenger cannot be null");
-        }
-        if (source == null) {
-            throw new IllegalArgumentException("Plugin source cannot be null");
-        }
-        if (!source.isEnabled()) {
-            throw new IllegalArgumentException("Plugin must be enabled to send messages");
-        }
-        if (message == null) {
-            throw new IllegalArgumentException("Message cannot be null");
-        }
-        if (!messenger.isOutgoingChannelRegistered(source, channel)) {
-            throw new ChannelNotRegisteredException(channel);
-        }
-        if (message.length > Messenger.MAX_MESSAGE_SIZE) {
-            throw new MessageTooLargeException(message);
-        }
-        validateChannel(channel);
-    }
-}
diff --git a/src/main/java/org/bukkit/potion/Potion.java b/src/main/java/org/bukkit/potion/Potion.java
deleted file mode 100644
index 28d24f6..0000000
--- a/src/main/java/org/bukkit/potion/Potion.java
+++ /dev/null
@@ -1,468 +0,0 @@
-package org.bukkit.potion;
-
-import java.util.Collection;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.Material;
-import org.bukkit.entity.LivingEntity;
-import org.bukkit.inventory.ItemStack;
-import org.bukkit.inventory.meta.PotionMeta;
-
-/**
- * Potion Adapter for pre-1.9 data values
- * see @PotionMeta for 1.9+
- */
-@Deprecated
-public class Potion {
-    private boolean extended = false;
-    private boolean splash = false;
-    private int level = 1;
-    private PotionType type;
-
-    /**
-     * Construct a new potion of the given type. Unless the type is {@link
-     * PotionType#WATER}, it will be level one, without extended duration.
-     * Don't use this constructor to create a no-effect potion other than
-     * water bottle.
-     *
-     * @param type The potion type
-     * @see #Potion(int)
-     */
-    public Potion(PotionType type) {
-        Validate.notNull(type, "Null PotionType");
-        this.type = type;
-    }
-
-    /**
-     * @deprecated In favour of {@link #Potion(PotionType, int)}
-     */
-    @Deprecated
-    public Potion(PotionType type, Tier tier) {
-        this(type, tier == Tier.TWO ? 2 : 1);
-        Validate.notNull(type, "Type cannot be null");
-    }
-
-    /**
-     * @deprecated In favour of {@link #Potion(PotionType, int, boolean)}
-     */
-    @Deprecated
-    public Potion(PotionType type, Tier tier, boolean splash) {
-        this(type, tier == Tier.TWO ? 2 : 1, splash);
-    }
-
-    /**
-     * @deprecated In favour of {@link #Potion(PotionType, int, boolean,
-     *     boolean)}
-     */
-    @Deprecated
-    public Potion(PotionType type, Tier tier, boolean splash, boolean extended) {
-        this(type, tier, splash);
-        this.extended = extended;
-    }
-
-    /**
-     * Create a new potion of the given type and level.
-     *
-     * @param type The type of potion.
-     * @param level The potion's level.
-     */
-    public Potion(PotionType type, int level) {
-        this(type);
-        Validate.notNull(type, "Type cannot be null");
-        Validate.isTrue(level > 0 && level < 3, "Level must be 1 or 2");
-        this.level = level;
-    }
-
-    /**
-     * Create a new potion of the given type and level.
-     *
-     * @param type The type of potion.
-     * @param level The potion's level.
-     * @param splash Whether it is a splash potion.
-     * @deprecated In favour of using {@link #Potion(PotionType)} with {@link
-     *     #splash()}.
-     */
-    @Deprecated
-    public Potion(PotionType type, int level, boolean splash) {
-        this(type, level);
-        this.splash = splash;
-    }
-
-    /**
-     * Create a new potion of the given type and level.
-     *
-     * @param type The type of potion.
-     * @param level The potion's level.
-     * @param splash Whether it is a splash potion.
-     * @param extended Whether it has an extended duration.
-     * @deprecated In favour of using {@link #Potion(PotionType)} with {@link
-     *     #extend()} and possibly {@link #splash()}.
-     */
-    @Deprecated
-    public Potion(PotionType type, int level, boolean splash, boolean extended) {
-        this(type, level, splash);
-        this.extended = extended;
-    }
-
-    /**
-     * @deprecated
-     */
-    @Deprecated
-    public Potion(int name) {
-        this(PotionType.WATER);
-    }
-
-    /**
-     * Chain this to the constructor to make the potion a splash potion.
-     *
-     * @return The potion.
-     */
-    public Potion splash() {
-        setSplash(true);
-        return this;
-    }
-
-    /**
-     * Chain this to the constructor to extend the potion's duration.
-     *
-     * @return The potion.
-     */
-    public Potion extend() {
-        setHasExtendedDuration(true);
-        return this;
-    }
-
-    /**
-     * Applies the effects of this potion to the given {@link ItemStack}. The
-     * ItemStack must be a potion.
-     *
-     * @param to The itemstack to apply to
-     */
-    public void apply(ItemStack to) {
-        Validate.notNull(to, "itemstack cannot be null");
-        Validate.isTrue(to.hasItemMeta(), "given itemstack is not a potion");
-        Validate.isTrue(to.getItemMeta() instanceof PotionMeta, "given itemstack is not a potion");
-        PotionMeta meta = (PotionMeta) to.getItemMeta();
-        meta.setBasePotionData(new PotionData(type, extended, level == 2));
-        to.setItemMeta(meta);
-    }
-
-    /**
-     * Applies the effects that would be applied by this potion to the given
-     * {@link LivingEntity}.
-     *
-     * @see LivingEntity#addPotionEffects(Collection)
-     * @param to The entity to apply the effects to
-     */
-    public void apply(LivingEntity to) {
-        Validate.notNull(to, "entity cannot be null");
-        to.addPotionEffects(getEffects());
-    }
-
-    @Override
-    public boolean equals(Object obj) {
-        if (this == obj) {
-            return true;
-        }
-        if (obj == null || getClass() != obj.getClass()) {
-            return false;
-        }
-        Potion other = (Potion) obj;
-        return extended == other.extended && splash == other.splash && level == other.level && type == other.type;
-    }
-
-    /**
-     * Returns a collection of {@link PotionEffect}s that this {@link Potion}
-     * would confer upon a {@link LivingEntity}.
-     *
-     * @see PotionBrewer#getEffectsFromDamage(int)
-     * @see Potion#toDamageValue()
-     * @return The effects that this potion applies
-     */
-    public Collection<PotionEffect> getEffects() {
-        return getBrewer().getEffects(type, level == 2, extended);
-    }
-
-    /**
-     * Returns the level of this potion.
-     *
-     * @return The level of this potion
-     */
-    public int getLevel() {
-        return level;
-    }
-
-    /**
-     * Returns the {@link Tier} of this potion.
-     *
-     * @return The tier of this potion
-     * @deprecated
-     */
-    @Deprecated
-    public Tier getTier() {
-        return level == 2 ? Tier.TWO : Tier.ONE;
-    }
-
-    /**
-     * Returns the {@link PotionType} of this potion.
-     *
-     * @return The type of this potion
-     */
-    public PotionType getType() {
-        return type;
-    }
-
-    /**
-     * Returns whether this potion has an extended duration.
-     *
-     * @return Whether this potion has extended duration
-     */
-    public boolean hasExtendedDuration() {
-        return extended;
-    }
-
-    @Override
-    public int hashCode() {
-        final int prime = 31;
-        int result = prime + level;
-        result = prime * result + (extended ? 1231 : 1237);
-        result = prime * result + (splash ? 1231 : 1237);
-        result = prime * result + ((type == null) ? 0 : type.hashCode());
-        return result;
-    }
-
-    /**
-     * Returns whether this potion is a splash potion.
-     *
-     * @return Whether this is a splash potion
-     */
-    public boolean isSplash() {
-        return splash;
-    }
-
-    /**
-     * Set whether this potion has extended duration. This will cause the
-     * potion to have roughly 8/3 more duration than a regular potion.
-     *
-     * @param isExtended Whether the potion should have extended duration
-     */
-    public void setHasExtendedDuration(boolean isExtended) {
-        Validate.isTrue(type == null || !type.isInstant(), "Instant potions cannot be extended");
-        extended = isExtended;
-    }
-
-    /**
-     * Sets whether this potion is a splash potion. Splash potions can be
-     * thrown for a radius effect.
-     *
-     * @param isSplash Whether this is a splash potion
-     */
-    public void setSplash(boolean isSplash) {
-        splash = isSplash;
-    }
-
-    /**
-     * Sets the {@link Tier} of this potion.
-     *
-     * @param tier The new tier of this potion
-     * @deprecated In favour of {@link #setLevel(int)}
-     */
-    @Deprecated
-    public void setTier(Tier tier) {
-        Validate.notNull(tier, "tier cannot be null");
-        this.level = (tier == Tier.TWO ? 2 : 1);
-    }
-
-    /**
-     * Sets the {@link PotionType} of this potion.
-     *
-     * @param type The new type of this potion
-     */
-    public void setType(PotionType type) {
-        this.type = type;
-    }
-
-    /**
-     * Sets the level of this potion.
-     *
-     * @param level The new level of this potion
-     */
-    public void setLevel(int level) {
-        Validate.notNull(this.type, "No-effect potions don't have a level.");
-        Validate.isTrue(level > 0 && level <= 2, "Level must be between 1 and 2 for this potion");
-        this.level = level;
-    }
-
-    /**
-     * Converts this potion to a valid potion damage short, usable for potion
-     * item stacks.
-     *
-     * @return The damage value of this potion
-     * @deprecated Non-functional
-     */
-    @Deprecated
-    public short toDamageValue() {
-        return 0;
-    }
-
-    /**
-     * Converts this potion to an {@link ItemStack} with the specified amount
-     * and a correct damage value.
-     *
-     * @param amount The amount of the ItemStack
-     * @return The created ItemStack
-     */
-    public ItemStack toItemStack(int amount) {
-        Material material;
-        if (isSplash()) {
-            material = Material.SPLASH_POTION;
-        } else {
-            material = Material.POTION;
-        }
-        ItemStack itemStack = new ItemStack(material, amount);
-        PotionMeta meta = (PotionMeta) itemStack.getItemMeta();
-        meta.setBasePotionData(new PotionData(type, level == 2, extended));
-        itemStack.setItemMeta(meta);
-        return itemStack;
-    }
-
-    @Deprecated
-    public enum Tier {
-        ONE(0),
-        TWO(0x20);
-
-        private int damageBit;
-
-        Tier(int bit) {
-            damageBit = bit;
-        }
-
-        public int getDamageBit() {
-            return damageBit;
-        }
-
-        public static Tier getByDamageBit(int damageBit) {
-            for (Tier tier : Tier.values()) {
-                if (tier.damageBit == damageBit)
-                    return tier;
-            }
-            return null;
-        }
-    }
-
-    private static PotionBrewer brewer;
-
-    private static final int EXTENDED_BIT = 0x40;
-    private static final int POTION_BIT = 0xF;
-    private static final int SPLASH_BIT = 0x4000;
-    private static final int TIER_BIT = 0x20;
-    private static final int TIER_SHIFT = 5;
-
-    /**
-     *
-     * @param damage the damage value
-     * @return the produced potion
-     */
-    public static Potion fromDamage(int damage) {
-        PotionType type;
-        switch (damage & POTION_BIT) {
-            case 0:
-                type = PotionType.WATER;
-                break;
-            case 1:
-                type = PotionType.REGEN;
-                break;
-            case 2:
-                type = PotionType.SPEED;
-                break;
-            case 3:
-                type = PotionType.FIRE_RESISTANCE;
-                break;
-            case 4:
-                type = PotionType.POISON;
-                break;
-            case 5:
-                type = PotionType.INSTANT_HEAL;
-                break;
-            case 6:
-                type = PotionType.NIGHT_VISION;
-                break;
-            case 8:
-                type = PotionType.WEAKNESS;
-                break;
-            case 9:
-                type = PotionType.STRENGTH;
-                break;
-            case 10:
-                type = PotionType.SLOWNESS;
-                break;
-            case 11:
-                type = PotionType.JUMP;
-                break;
-            case 12:
-                type = PotionType.INSTANT_DAMAGE;
-                break;
-            case 13:
-                type = PotionType.WATER_BREATHING;
-                break;
-            case 14:
-                type = PotionType.INVISIBILITY;
-                break;
-            default:
-                type = PotionType.WATER;
-        }
-        Potion potion;
-        if (type == null || type == PotionType.WATER) {
-            potion = new Potion(PotionType.WATER);
-        } else {
-            int level = (damage & TIER_BIT) >> TIER_SHIFT;
-            level++;
-            potion = new Potion(type, level);
-        }
-        if ((damage & SPLASH_BIT) > 0) {
-            potion = potion.splash();
-        }
-        if ((damage & EXTENDED_BIT) > 0) {
-            potion = potion.extend();
-        }
-        return potion;
-    }
-
-    public static Potion fromItemStack(ItemStack item) {
-        Validate.notNull(item, "item cannot be null");
-        if (item.getType() != Material.POTION)
-            throw new IllegalArgumentException("item is not a potion");
-        return fromDamage(item.getDurability());
-    }
-
-    /**
-     * Returns an instance of {@link PotionBrewer}.
-     *
-     * @return An instance of PotionBrewer
-     */
-    public static PotionBrewer getBrewer() {
-        return brewer;
-    }
-
-    /**
-     * Sets the current instance of {@link PotionBrewer}. Generally not to be
-     * used from within a plugin.
-     *
-     * @param other The new PotionBrewer
-     */
-    public static void setPotionBrewer(PotionBrewer other) {
-        if (brewer != null)
-            throw new IllegalArgumentException("brewer can only be set internally");
-        brewer = other;
-    }
-
-    /**
-     *
-     * @return the name id
-     * @deprecated Non-functional
-     */
-    @Deprecated
-    public int getNameId() {
-        return 0;
-    }
-}
diff --git a/src/main/java/org/bukkit/potion/PotionBrewer.java b/src/main/java/org/bukkit/potion/PotionBrewer.java
deleted file mode 100644
index 40f8d12..0000000
--- a/src/main/java/org/bukkit/potion/PotionBrewer.java
+++ /dev/null
@@ -1,40 +0,0 @@
-package org.bukkit.potion;
-
-import java.util.Collection;
-
-/**
- * Represents a brewer that can create {@link PotionEffect}s.
- */
-public interface PotionBrewer {
-
-    /**
-     * Creates a {@link PotionEffect} from the given {@link PotionEffectType},
-     * applying duration modifiers and checks.
-     *
-     * @param potion The type of potion
-     * @param duration The duration in ticks
-     * @param amplifier The amplifier of the effect
-     * @return The resulting potion effect
-     */
-    public PotionEffect createEffect(PotionEffectType potion, int duration, int amplifier);
-
-    /**
-     * Returns a collection of {@link PotionEffect} that would be applied from
-     * a potion with the given data value.
-     *
-     * @param damage The data value of the potion
-     * @return The list of effects
-     * @deprecated Non-Functional
-     */
-    @Deprecated
-    public Collection<PotionEffect> getEffectsFromDamage(int damage);
-
-    /**
-     * Returns a collection of {@link PotionEffect} that would be applied from
-     * a potion with the given type.
-     *
-     * @param type The type of the potion
-     * @return The list of effects
-     */
-    public Collection<PotionEffect> getEffects(PotionType type, boolean upgraded, boolean extended);
-}
diff --git a/src/main/java/org/bukkit/potion/PotionData.java b/src/main/java/org/bukkit/potion/PotionData.java
deleted file mode 100644
index 6e8139a..0000000
--- a/src/main/java/org/bukkit/potion/PotionData.java
+++ /dev/null
@@ -1,85 +0,0 @@
-package org.bukkit.potion;
-
-import org.apache.commons.lang.Validate;
-
-public final class PotionData {
-
-    private final PotionType type;
-    private final boolean extended;
-    private final boolean upgraded;
-
-    /**
-     * Instantiates a final PotionData object to contain information about a
-     * Potion
-     *
-     * @param type the type of the Potion
-     * @param extended whether the potion is extended PotionType#isExtendable()
-     * must be true
-     * @param upgraded whether the potion is upgraded PotionType#isUpgradable()
-     * must be true
-     */
-    public PotionData(PotionType type, boolean extended, boolean upgraded) {
-        Validate.notNull(type, "Potion Type must not be null");
-        Validate.isTrue(!upgraded || type.isUpgradeable(), "Potion Type is not upgradable");
-        Validate.isTrue(!extended || type.isExtendable(), "Potion Type is not extendable");
-        Validate.isTrue(!upgraded || !extended, "Potion cannot be both extended and upgraded");
-        this.type = type;
-        this.extended = extended;
-        this.upgraded = upgraded;
-    }
-
-    public PotionData(PotionType type) {
-        this(type, false, false);
-    }
-
-    /**
-     * Gets the type of the potion, Type matches up with each kind of craftable
-     * potion
-     *
-     * @return the potion type
-     */
-    public PotionType getType() {
-        return type;
-    }
-
-    /**
-     * Checks if the potion is in an upgraded state. This refers to whether or
-     * not the potion is Tier 2, such as Potion of Fire Resistance II.
-     *
-     * @return true if the potion is upgraded;
-     */
-    public boolean isUpgraded() {
-        return upgraded;
-    }
-
-    /**
-     * Checks if the potion is in an extended state. This refers to the extended
-     * duration potions
-     *
-     * @return true if the potion is extended
-     */
-    public boolean isExtended() {
-        return extended;
-    }
-
-    @Override
-    public int hashCode() {
-        int hash = 7;
-        hash = 23 * hash + (this.type != null ? this.type.hashCode() : 0);
-        hash = 23 * hash + (this.extended ? 1 : 0);
-        hash = 23 * hash + (this.upgraded ? 1 : 0);
-        return hash;
-    }
-
-    @Override
-    public boolean equals(Object obj) {
-        if (this == obj) {
-            return true;
-        }
-        if (obj == null || getClass() != obj.getClass()) {
-            return false;
-        }
-        PotionData other = (PotionData) obj;
-        return (this.upgraded == other.upgraded) && (this.extended == other.extended) && (this.type == other.type);
-    }
-}
diff --git a/src/main/java/org/bukkit/potion/PotionEffect.java b/src/main/java/org/bukkit/potion/PotionEffect.java
deleted file mode 100644
index 03221bf..0000000
--- a/src/main/java/org/bukkit/potion/PotionEffect.java
+++ /dev/null
@@ -1,229 +0,0 @@
-package org.bukkit.potion;
-
-import java.util.Map;
-import java.util.NoSuchElementException;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.Color;
-import org.bukkit.configuration.serialization.ConfigurationSerializable;
-import org.bukkit.configuration.serialization.SerializableAs;
-import org.bukkit.entity.LivingEntity;
-
-import com.google.common.collect.ImmutableMap;
-
-/**
- * Represents a potion effect, that can be added to a {@link LivingEntity}. A
- * potion effect has a duration that it will last for, an amplifier that will
- * enhance its effects, and a {@link PotionEffectType}, that represents its
- * effect on an entity.
- */
-@SerializableAs("PotionEffect")
-public class PotionEffect implements ConfigurationSerializable {
-    private static final String AMPLIFIER = "amplifier";
-    private static final String DURATION = "duration";
-    private static final String TYPE = "effect";
-    private static final String AMBIENT = "ambient";
-    private static final String PARTICLES = "has-particles";
-    private final int amplifier;
-    private final int duration;
-    private final PotionEffectType type;
-    private final boolean ambient;
-    private final boolean particles;
-    private final Color color;
-
-    /**
-     * Creates a potion effect.
-     * @param type effect type
-     * @param duration measured in ticks, see {@link
-     *     PotionEffect#getDuration()}
-     * @param amplifier the amplifier, see {@link PotionEffect#getAmplifier()}
-     * @param ambient the ambient status, see {@link PotionEffect#isAmbient()}
-     * @param particles the particle status, see {@link PotionEffect#hasParticles()}
-     * @param color the particle color, see {@link PotionEffect#getColor()}
-     */
-    public PotionEffect(PotionEffectType type, int duration, int amplifier, boolean ambient, boolean particles, Color color){
-        Validate.notNull(type, "effect type cannot be null");
-        this.type = type;
-        this.duration = duration;
-        this.amplifier = amplifier;
-        this.ambient = ambient;
-        this.particles = particles;
-        this.color = color;
-    }
-
-    /**
-     * Creates a potion effect with no defined color.
-     *
-     * @param type effect type
-     * @param duration measured in ticks, see {@link
-     *     PotionEffect#getDuration()}
-     * @param amplifier the amplifier, see {@link PotionEffect#getAmplifier()}
-     * @param ambient the ambient status, see {@link PotionEffect#isAmbient()}
-     * @param particles the particle status, see {@link PotionEffect#hasParticles()}
-     */
-    public PotionEffect(PotionEffectType type, int duration, int amplifier, boolean ambient, boolean particles) {
-        this(type, duration, amplifier, ambient, particles, null);
-    }
-
-    /**
-     * Creates a potion effect. Assumes that particles are visible
-     *
-     * @param type effect type
-     * @param duration measured in ticks, see {@link
-     *     PotionEffect#getDuration()}
-     * @param amplifier the amplifier, see {@link PotionEffect#getAmplifier()}
-     * @param ambient the ambient status, see {@link PotionEffect#isAmbient()}
-     */
-    public PotionEffect(PotionEffectType type, int duration, int amplifier, boolean ambient) {
-        this(type, duration, amplifier, ambient, true);
-    }
-
-    /**
-     * Creates a potion effect. Assumes ambient is true.
-     *
-     * @param type Effect type
-     * @param duration measured in ticks
-     * @param amplifier the amplifier for the effect
-     * @see PotionEffect#PotionEffect(PotionEffectType, int, int, boolean)
-     */
-    public PotionEffect(PotionEffectType type, int duration, int amplifier) {
-        this(type, duration, amplifier, true);
-    }
-
-    /**
-     * Constructor for deserialization.
-     *
-     * @param map the map to deserialize from
-     */
-    public PotionEffect(Map<String, Object> map) {
-        this(getEffectType(map), getInt(map, DURATION), getInt(map, AMPLIFIER), getBool(map, AMBIENT, false), getBool(map, PARTICLES, true));
-    }
-
-    private static PotionEffectType getEffectType(Map<?,?> map) {
-        int type = getInt(map, TYPE);
-        PotionEffectType effect = PotionEffectType.getById(type);
-        if (effect != null) {
-            return effect;
-        }
-        throw new NoSuchElementException(map + " does not contain " + TYPE);
-    }
-
-    private static int getInt(Map<?,?> map, Object key) {
-        Object num = map.get(key);
-        if (num instanceof Integer) {
-            return (Integer) num;
-        }
-        throw new NoSuchElementException(map + " does not contain " + key);
-    }
-
-    private static boolean getBool(Map<?,?> map, Object key, boolean def) {
-        Object bool = map.get(key);
-        if (bool instanceof Boolean) {
-            return (Boolean) bool;
-        }
-        return def;
-    }
-
-    public Map<String, Object> serialize() {
-        return ImmutableMap.<String, Object>of(
-            TYPE, type.getId(),
-            DURATION, duration,
-            AMPLIFIER, amplifier,
-            AMBIENT, ambient,
-            PARTICLES, particles
-        );
-    }
-
-    /**
-     * Attempts to add the effect represented by this object to the given
-     * {@link LivingEntity}.
-     *
-     * @see LivingEntity#addPotionEffect(PotionEffect)
-     * @param entity The entity to add this effect to
-     * @return Whether the effect could be added
-     */
-    public boolean apply(LivingEntity entity) {
-        return entity.addPotionEffect(this);
-    }
-
-    @Override
-    public boolean equals(Object obj) {
-        if (this == obj) {
-            return true;
-        }
-        if (!(obj instanceof PotionEffect)) {
-            return false;
-        }
-        PotionEffect that = (PotionEffect) obj;
-        return this.type.equals(that.type) && this.ambient == that.ambient && this.amplifier == that.amplifier && this.duration == that.duration && this.particles == that.particles;
-    }
-
-    /**
-     * Returns the amplifier of this effect. A higher amplifier means the
-     * potion effect happens more often over its duration and in some cases
-     * has more effect on its target.
-     *
-     * @return The effect amplifier
-     */
-    public int getAmplifier() {
-        return amplifier;
-    }
-
-    /**
-     * Returns the duration (in ticks) that this effect will run for when
-     * applied to a {@link LivingEntity}.
-     *
-     * @return The duration of the effect
-     */
-    public int getDuration() {
-        return duration;
-    }
-
-    /**
-     * Returns the {@link PotionEffectType} of this effect.
-     *
-     * @return The potion type of this effect
-     */
-    public PotionEffectType getType() {
-        return type;
-    }
-
-    /**
-     * Makes potion effect produce more, translucent, particles.
-     *
-     * @return if this effect is ambient
-     */
-    public boolean isAmbient() {
-        return ambient;
-    }
-
-    /**
-     * @return whether this effect has particles or not
-     */
-    public boolean hasParticles(){
-        return particles;
-    }
-
-    /**
-     * @return color of this potion's particles. May be null if the potion has no particles or defined color.
-     */
-    public Color getColor() {
-        return color;
-    }
-
-    @Override
-    public int hashCode() {
-        int hash = 1;
-        hash = hash * 31 + type.hashCode();
-        hash = hash * 31 + amplifier;
-        hash = hash * 31 + duration;
-        hash ^= 0x22222222 >> (ambient ? 1 : -1);
-        hash ^= 0x22222222 >> (particles ? 1 : -1);
-        return hash;
-    }
-
-    @Override
-    public String toString() {
-        return type.getName() + (ambient ? ":(" : ":") + duration + "t-x" + amplifier + (ambient ? ")" : "");
-    }
-}
diff --git a/src/main/java/org/bukkit/potion/PotionEffectType.java b/src/main/java/org/bukkit/potion/PotionEffectType.java
deleted file mode 100644
index c62b168..0000000
--- a/src/main/java/org/bukkit/potion/PotionEffectType.java
+++ /dev/null
@@ -1,290 +0,0 @@
-package org.bukkit.potion;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import org.apache.commons.lang.Validate;
-
-/**
- * Represents a type of potion and its effect on an entity.
- */
-public abstract class PotionEffectType {
-    /**
-     * Increases movement speed.
-     */
-    public static final PotionEffectType SPEED = new PotionEffectTypeWrapper(1);
-
-    /**
-     * Decreases movement speed.
-     */
-    public static final PotionEffectType SLOW = new PotionEffectTypeWrapper(2);
-
-    /**
-     * Increases dig speed.
-     */
-    public static final PotionEffectType FAST_DIGGING = new PotionEffectTypeWrapper(3);
-
-    /**
-     * Decreases dig speed.
-     */
-    public static final PotionEffectType SLOW_DIGGING = new PotionEffectTypeWrapper(4);
-
-    /**
-     * Increases damage dealt.
-     */
-    public static final PotionEffectType INCREASE_DAMAGE = new PotionEffectTypeWrapper(5);
-
-    /**
-     * Heals an entity.
-     */
-    public static final PotionEffectType HEAL = new PotionEffectTypeWrapper(6);
-
-    /**
-     * Hurts an entity.
-     */
-    public static final PotionEffectType HARM = new PotionEffectTypeWrapper(7);
-
-    /**
-     * Increases jump height.
-     */
-    public static final PotionEffectType JUMP = new PotionEffectTypeWrapper(8);
-
-    /**
-     * Warps vision on the client.
-     */
-    public static final PotionEffectType CONFUSION = new PotionEffectTypeWrapper(9);
-
-    /**
-     * Regenerates health.
-     */
-    public static final PotionEffectType REGENERATION = new PotionEffectTypeWrapper(10);
-
-    /**
-     * Decreases damage dealt to an entity.
-     */
-    public static final PotionEffectType DAMAGE_RESISTANCE = new PotionEffectTypeWrapper(11);
-
-    /**
-     * Stops fire damage.
-     */
-    public static final PotionEffectType FIRE_RESISTANCE = new PotionEffectTypeWrapper(12);
-
-    /**
-     * Allows breathing underwater.
-     */
-    public static final PotionEffectType WATER_BREATHING = new PotionEffectTypeWrapper(13);
-
-    /**
-     * Grants invisibility.
-     */
-    public static final PotionEffectType INVISIBILITY = new PotionEffectTypeWrapper(14);
-
-    /**
-     * Blinds an entity.
-     */
-    public static final PotionEffectType BLINDNESS = new PotionEffectTypeWrapper(15);
-
-    /**
-     * Allows an entity to see in the dark.
-     */
-    public static final PotionEffectType NIGHT_VISION = new PotionEffectTypeWrapper(16);
-
-    /**
-     * Increases hunger.
-     */
-    public static final PotionEffectType HUNGER = new PotionEffectTypeWrapper(17);
-
-    /**
-     * Decreases damage dealt by an entity.
-     */
-    public static final PotionEffectType WEAKNESS = new PotionEffectTypeWrapper(18);
-
-    /**
-     * Deals damage to an entity over time.
-     */
-    public static final PotionEffectType POISON = new PotionEffectTypeWrapper(19);
-
-    /**
-     * Deals damage to an entity over time and gives the health to the
-     * shooter.
-     */
-    public static final PotionEffectType WITHER = new PotionEffectTypeWrapper(20);
-
-    /**
-     * Increases the maximum health of an entity.
-     */
-    public static final PotionEffectType HEALTH_BOOST = new PotionEffectTypeWrapper(21);
-
-    /**
-     * Increases the maximum health of an entity with health that cannot be
-     * regenerated, but is refilled every 30 seconds.
-     */
-    public static final PotionEffectType ABSORPTION = new PotionEffectTypeWrapper(22);
-
-    /**
-     * Increases the food level of an entity each tick.
-     */
-    public static final PotionEffectType SATURATION = new PotionEffectTypeWrapper(23);
-
-    /**
-     * Outlines the entity so that it can be seen from afar.
-     */
-    public static final PotionEffectType GLOWING = new PotionEffectTypeWrapper(24);
-
-    /**
-     * Causes the entity to float into the air.
-     */
-    public static final PotionEffectType LEVITATION = new PotionEffectTypeWrapper(25);
-
-    /**
-     * Loot table luck.
-     */
-    public static final PotionEffectType LUCK = new PotionEffectTypeWrapper(26);
-
-    /**
-     * Loot table unluck.
-     */
-    public static final PotionEffectType UNLUCK = new PotionEffectTypeWrapper(27);
-
-    private final int id;
-
-    protected PotionEffectType(int id) {
-        this.id = id;
-    }
-
-    /**
-     * Creates a PotionEffect from this PotionEffectType, applying duration
-     * modifiers and checks.
-     *
-     * @see PotionBrewer#createEffect(PotionEffectType, int, int)
-     * @param duration time in ticks
-     * @param amplifier the effect's amplifier
-     * @return a resulting potion effect
-     */
-    public PotionEffect createEffect(int duration, int amplifier) {
-        return new PotionEffect(this, isInstant() ? 1 : (int) (duration * getDurationModifier()), amplifier);
-    }
-
-    /**
-     * Returns the duration modifier applied to effects of this type.
-     *
-     * @return duration modifier
-     */
-    public abstract double getDurationModifier();
-
-    /**
-     * Returns the unique ID of this type.
-     *
-     * @return Unique ID
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public int getId() {
-        return id;
-    }
-
-    /**
-     * Returns the name of this effect type.
-     *
-     * @return The name of this effect type
-     */
-    public abstract String getName();
-
-    /**
-     * Returns whether the effect of this type happens once, immediately.
-     *
-     * @return whether this type is normally instant
-     */
-    public abstract boolean isInstant();
-
-    @Override
-    public boolean equals(Object obj) {
-        if (obj == null) {
-            return false;
-        }
-        if (!(obj instanceof PotionEffectType)) {
-            return false;
-        }
-        final PotionEffectType other = (PotionEffectType) obj;
-        if (this.id != other.id) {
-            return false;
-        }
-        return true;
-    }
-
-    @Override
-    public int hashCode() {
-        return id;
-    }
-
-    @Override
-    public String toString() {
-        return "PotionEffectType[" + id + ", " + getName() + "]";
-    }
-
-    private static final PotionEffectType[] byId = new PotionEffectType[28];
-    private static final Map<String, PotionEffectType> byName = new HashMap<String, PotionEffectType>();
-    // will break on updates.
-    private static boolean acceptingNew = true;
-
-    /**
-     * Gets the effect type specified by the unique id.
-     *
-     * @param id Unique ID to fetch
-     * @return Resulting type, or null if not found.
-     * @deprecated Magic value
-     */
-    @Deprecated
-    public static PotionEffectType getById(int id) {
-        if (id >= byId.length || id < 0)
-            return null;
-        return byId[id];
-    }
-
-    /**
-     * Gets the effect type specified by the given name.
-     *
-     * @param name Name of PotionEffectType to fetch
-     * @return Resulting PotionEffectType, or null if not found.
-     */
-    public static PotionEffectType getByName(String name) {
-        Validate.notNull(name, "name cannot be null");
-        return byName.get(name.toLowerCase());
-    }
-
-    /**
-     * Registers an effect type with the given object.
-     * <p>
-     * Generally not to be used from within a plugin.
-     *
-     * @param type PotionType to register
-     */
-    public static void registerPotionEffectType(PotionEffectType type) {
-        if (byId[type.id] != null || byName.containsKey(type.getName().toLowerCase())) {
-            throw new IllegalArgumentException("Cannot set already-set type");
-        } else if (!acceptingNew) {
-            throw new IllegalStateException(
-                    "No longer accepting new potion effect types (can only be done by the server implementation)");
-        }
-
-        byId[type.id] = type;
-        byName.put(type.getName().toLowerCase(), type);
-    }
-
-    /**
-     * Stops accepting any effect type registrations.
-     */
-    public static void stopAcceptingRegistrations() {
-        acceptingNew = false;
-    }
-
-    /**
-     * Returns an array of all the registered {@link PotionEffectType}s.
-     * This array is not necessarily in any particular order and may contain null.
-     *
-     * @return Array of types.
-     */
-    public static PotionEffectType[] values() {
-        return byId.clone();
-    }
-}
diff --git a/src/main/java/org/bukkit/potion/PotionEffectTypeWrapper.java b/src/main/java/org/bukkit/potion/PotionEffectTypeWrapper.java
deleted file mode 100644
index 5db1ce8..0000000
--- a/src/main/java/org/bukkit/potion/PotionEffectTypeWrapper.java
+++ /dev/null
@@ -1,31 +0,0 @@
-package org.bukkit.potion;
-
-public class PotionEffectTypeWrapper extends PotionEffectType {
-    protected PotionEffectTypeWrapper(int id) {
-        super(id);
-    }
-
-    @Override
-    public double getDurationModifier() {
-        return getType().getDurationModifier();
-    }
-
-    @Override
-    public String getName() {
-        return getType().getName();
-    }
-
-    /**
-     * Get the potion type bound to this wrapper.
-     *
-     * @return The potion effect type
-     */
-    public PotionEffectType getType() {
-        return PotionEffectType.getById(getId());
-    }
-
-    @Override
-    public boolean isInstant() {
-        return getType().isInstant();
-    }
-}
diff --git a/src/main/java/org/bukkit/potion/PotionType.java b/src/main/java/org/bukkit/potion/PotionType.java
deleted file mode 100644
index 60470b8..0000000
--- a/src/main/java/org/bukkit/potion/PotionType.java
+++ /dev/null
@@ -1,101 +0,0 @@
-package org.bukkit.potion;
-
-/**
- * This enum reflects and matches each potion state that can be obtained from
- * the Creative mode inventory
- */
-public enum PotionType {
-    UNCRAFTABLE(null, false, false),
-    WATER(null, false, false),
-    MUNDANE(null, false, false),
-    THICK(null, false, false),
-    AWKWARD(null, false, false),
-    NIGHT_VISION(PotionEffectType.NIGHT_VISION, false, true),
-    INVISIBILITY(PotionEffectType.INVISIBILITY, false, true),
-    JUMP(PotionEffectType.JUMP, true, true),
-    FIRE_RESISTANCE(PotionEffectType.FIRE_RESISTANCE, false, true),
-    SPEED(PotionEffectType.SPEED, true, true),
-    SLOWNESS(PotionEffectType.SLOW, false, true),
-    WATER_BREATHING(PotionEffectType.WATER_BREATHING, false, true),
-    INSTANT_HEAL(PotionEffectType.HEAL, true, false),
-    INSTANT_DAMAGE(PotionEffectType.HARM, true, false),
-    POISON(PotionEffectType.POISON, true, true),
-    REGEN(PotionEffectType.REGENERATION, true, true),
-    STRENGTH(PotionEffectType.INCREASE_DAMAGE, true, true),
-    WEAKNESS(PotionEffectType.WEAKNESS, false, true),
-    LUCK(PotionEffectType.LUCK, false, false);
-    ;
-
-    private final PotionEffectType effect;
-    private final boolean upgradeable;
-    private final boolean extendable;
-
-    PotionType(PotionEffectType effect, boolean upgradeable, boolean extendable) {
-        this.effect = effect;
-        this.upgradeable = upgradeable;
-        this.extendable = extendable;
-    }
-
-    public PotionEffectType getEffectType() {
-        return effect;
-    }
-
-    public boolean isInstant() {
-        return effect != null && effect.isInstant();
-    }
-
-    /**
-     * Checks if the potion type has an upgraded state.
-     * This refers to whether or not the potion type can be Tier 2,
-     * such as Potion of Fire Resistance II.
-     * 
-     * @return true if the potion type can be upgraded;
-     */
-    public boolean isUpgradeable() {
-        return upgradeable;
-    }
-
-    /**
-     * Checks if the potion type has an extended state.
-     * This refers to the extended duration potions
-     * 
-     * @return true if the potion type can be extended
-     */
-    public boolean isExtendable() {
-        return extendable;
-    }
-
-    /**
-     * @deprecated Non-functional
-     */
-    @Deprecated
-    public int getDamageValue() {
-        return this.ordinal();
-    }
-
-    public int getMaxLevel() {
-        return upgradeable ? 2 : 1;
-    }
-
-    /**
-     * @deprecated Non-functional
-     */
-    @Deprecated
-    public static PotionType getByDamageValue(int damage) {
-        return null;
-    }
-
-    /**
-     * @deprecated Misleading
-     */
-    @Deprecated
-    public static PotionType getByEffect(PotionEffectType effectType) {
-        if (effectType == null)
-            return WATER;
-        for (PotionType type : PotionType.values()) {
-            if (effectType.equals(type.effect))
-                return type;
-        }
-        return null;
-    }
-}
diff --git a/src/main/java/org/bukkit/projectiles/BlockProjectileSource.java b/src/main/java/org/bukkit/projectiles/BlockProjectileSource.java
deleted file mode 100644
index e713c0d..0000000
--- a/src/main/java/org/bukkit/projectiles/BlockProjectileSource.java
+++ /dev/null
@@ -1,13 +0,0 @@
-package org.bukkit.projectiles;
-
-import org.bukkit.block.Block;
-
-public interface BlockProjectileSource extends ProjectileSource {
-
-    /**
-     * Gets the block this projectile source belongs to.
-     *
-     * @return Block for the projectile source
-     */
-    public Block getBlock();
-}
diff --git a/src/main/java/org/bukkit/projectiles/ProjectileSource.java b/src/main/java/org/bukkit/projectiles/ProjectileSource.java
deleted file mode 100644
index cf90946..0000000
--- a/src/main/java/org/bukkit/projectiles/ProjectileSource.java
+++ /dev/null
@@ -1,30 +0,0 @@
-package org.bukkit.projectiles;
-
-import org.bukkit.entity.Projectile;
-import org.bukkit.util.Vector;
-
-/**
- * Represents a valid source of a projectile.
- */
-public interface ProjectileSource {
-
-    /**
-     * Launches a {@link Projectile} from the ProjectileSource.
-     *
-     * @param <T> a projectile subclass
-     * @param projectile class of the projectile to launch
-     * @return the launched projectile
-     */
-    public <T extends Projectile> T launchProjectile(Class<? extends T> projectile);
-
-    /**
-     * Launches a {@link Projectile} from the ProjectileSource with an
-     * initial velocity.
-     *
-     * @param <T> a projectile subclass
-     * @param projectile class of the projectile to launch
-     * @param velocity the velocity with which to launch
-     * @return the launched projectile
-     */
-    public <T extends Projectile> T launchProjectile(Class<? extends T> projectile, Vector velocity);
-}
diff --git a/src/main/java/org/bukkit/scheduler/BukkitRunnable.java b/src/main/java/org/bukkit/scheduler/BukkitRunnable.java
deleted file mode 100644
index c146ec7..0000000
--- a/src/main/java/org/bukkit/scheduler/BukkitRunnable.java
+++ /dev/null
@@ -1,149 +0,0 @@
-package org.bukkit.scheduler;
-
-import org.bukkit.Bukkit;
-import org.bukkit.plugin.Plugin;
-
-/**
- * This class is provided as an easy way to handle scheduling tasks.
- */
-public abstract class BukkitRunnable implements Runnable {
-    private int taskId = -1;
-
-    /**
-     * Attempts to cancel this task.
-     *
-     * @throws IllegalStateException if task was not scheduled yet
-     */
-    public synchronized void cancel() throws IllegalStateException {
-        Bukkit.getScheduler().cancelTask(getTaskId());
-    }
-
-    /**
-     * Schedules this in the Bukkit scheduler to run on next tick.
-     *
-     * @param plugin the reference to the plugin scheduling task
-     * @return a BukkitTask that contains the id number
-     * @throws IllegalArgumentException if plugin is null
-     * @throws IllegalStateException if this was already scheduled
-     * @see BukkitScheduler#runTask(Plugin, Runnable)
-     */
-    public synchronized BukkitTask runTask(Plugin plugin) throws IllegalArgumentException, IllegalStateException {
-        checkState();
-        return setupId(Bukkit.getScheduler().runTask(plugin, (Runnable) this));
-    }
-
-    /**
-     * <b>Asynchronous tasks should never access any API in Bukkit. Great care
-     * should be taken to assure the thread-safety of asynchronous tasks.</b>
-     * <p>
-     * Schedules this in the Bukkit scheduler to run asynchronously.
-     *
-     * @param plugin the reference to the plugin scheduling task
-     * @return a BukkitTask that contains the id number
-     * @throws IllegalArgumentException if plugin is null
-     * @throws IllegalStateException if this was already scheduled
-     * @see BukkitScheduler#runTaskAsynchronously(Plugin, Runnable)
-     */
-    public synchronized BukkitTask runTaskAsynchronously(Plugin plugin) throws IllegalArgumentException, IllegalStateException  {
-        checkState();
-        return setupId(Bukkit.getScheduler().runTaskAsynchronously(plugin, (Runnable) this));
-    }
-
-    /**
-     * Schedules this to run after the specified number of server ticks.
-     *
-     * @param plugin the reference to the plugin scheduling task
-     * @param delay the ticks to wait before running the task
-     * @return a BukkitTask that contains the id number
-     * @throws IllegalArgumentException if plugin is null
-     * @throws IllegalStateException if this was already scheduled
-     * @see BukkitScheduler#runTaskLater(Plugin, Runnable, long)
-     */
-    public synchronized BukkitTask runTaskLater(Plugin plugin, long delay) throws IllegalArgumentException, IllegalStateException  {
-        checkState();
-        return setupId(Bukkit.getScheduler().runTaskLater(plugin, (Runnable) this, delay));
-    }
-
-    /**
-     * <b>Asynchronous tasks should never access any API in Bukkit. Great care
-     * should be taken to assure the thread-safety of asynchronous tasks.</b>
-     * <p>
-     * Schedules this to run asynchronously after the specified number of
-     * server ticks.
-     *
-     * @param plugin the reference to the plugin scheduling task
-     * @param delay the ticks to wait before running the task
-     * @return a BukkitTask that contains the id number
-     * @throws IllegalArgumentException if plugin is null
-     * @throws IllegalStateException if this was already scheduled
-     * @see BukkitScheduler#runTaskLaterAsynchronously(Plugin, Runnable, long)
-     */
-    public synchronized BukkitTask runTaskLaterAsynchronously(Plugin plugin, long delay) throws IllegalArgumentException, IllegalStateException  {
-        checkState();
-        return setupId(Bukkit.getScheduler().runTaskLaterAsynchronously(plugin, (Runnable) this, delay));
-    }
-
-    /**
-     * Schedules this to repeatedly run until cancelled, starting after the
-     * specified number of server ticks.
-     *
-     * @param plugin the reference to the plugin scheduling task
-     * @param delay the ticks to wait before running the task
-     * @param period the ticks to wait between runs
-     * @return a BukkitTask that contains the id number
-     * @throws IllegalArgumentException if plugin is null
-     * @throws IllegalStateException if this was already scheduled
-     * @see BukkitScheduler#runTaskTimer(Plugin, Runnable, long, long)
-     */
-    public synchronized BukkitTask runTaskTimer(Plugin plugin, long delay, long period) throws IllegalArgumentException, IllegalStateException  {
-        checkState();
-        return setupId(Bukkit.getScheduler().runTaskTimer(plugin, (Runnable) this, delay, period));
-    }
-
-    /**
-     * <b>Asynchronous tasks should never access any API in Bukkit. Great care
-     * should be taken to assure the thread-safety of asynchronous tasks.</b>
-     * <p>
-     * Schedules this to repeatedly run asynchronously until cancelled,
-     * starting after the specified number of server ticks.
-     *
-     * @param plugin the reference to the plugin scheduling task
-     * @param delay the ticks to wait before running the task for the first
-     *     time
-     * @param period the ticks to wait between runs
-     * @return a BukkitTask that contains the id number
-     * @throws IllegalArgumentException if plugin is null
-     * @throws IllegalStateException if this was already scheduled
-     * @see BukkitScheduler#runTaskTimerAsynchronously(Plugin, Runnable, long,
-     *     long)
-     */
-    public synchronized BukkitTask runTaskTimerAsynchronously(Plugin plugin, long delay, long period) throws IllegalArgumentException, IllegalStateException  {
-        checkState();
-        return setupId(Bukkit.getScheduler().runTaskTimerAsynchronously(plugin, (Runnable) this, delay, period));
-    }
-
-    /**
-     * Gets the task id for this runnable.
-     *
-     * @return the task id that this runnable was scheduled as
-     * @throws IllegalStateException if task was not scheduled yet
-     */
-    public synchronized int getTaskId() throws IllegalStateException {
-        final int id = taskId;
-        if (id == -1) {
-            throw new IllegalStateException("Not scheduled yet");
-        }
-        return id;
-    }
-
-    private void checkState() {
-        if (taskId != -1) {
-            throw new IllegalStateException("Already scheduled as " + taskId);
-        }
-    }
-
-    private BukkitTask setupId(final BukkitTask task) {
-        this.taskId = task.getTaskId();
-        return task;
-    }
-}
diff --git a/src/main/java/org/bukkit/scheduler/BukkitScheduler.java b/src/main/java/org/bukkit/scheduler/BukkitScheduler.java
deleted file mode 100644
index 6e28205..0000000
--- a/src/main/java/org/bukkit/scheduler/BukkitScheduler.java
+++ /dev/null
@@ -1,369 +0,0 @@
-package org.bukkit.scheduler;
-
-import org.bukkit.plugin.Plugin;
-import java.util.concurrent.Callable;
-import java.util.concurrent.Future;
-import java.util.List;
-
-public interface BukkitScheduler {
-
-    /**
-     * Schedules a once off task to occur after a delay.
-     * <p>
-     * This task will be executed by the main server thread.
-     *
-     * @param plugin Plugin that owns the task
-     * @param task Task to be executed
-     * @param delay Delay in server ticks before executing task
-     * @return Task id number (-1 if scheduling failed)
-     */
-    public int scheduleSyncDelayedTask(Plugin plugin, Runnable task, long delay);
-
-    /**
-     * @deprecated Use {@link BukkitRunnable#runTaskLater(Plugin, long)}
-     * @param plugin Plugin that owns the task
-     * @param task Task to be executed
-     * @param delay Delay in server ticks before executing task
-     * @return Task id number (-1 if scheduling failed)
-     */
-    @Deprecated
-    public int scheduleSyncDelayedTask(Plugin plugin, BukkitRunnable task, long delay);
-
-    /**
-     * Schedules a once off task to occur as soon as possible.
-     * <p>
-     * This task will be executed by the main server thread.
-     *
-     * @param plugin Plugin that owns the task
-     * @param task Task to be executed
-     * @return Task id number (-1 if scheduling failed)
-     */
-    public int scheduleSyncDelayedTask(Plugin plugin, Runnable task);
-
-    /**
-     * @deprecated Use {@link BukkitRunnable#runTask(Plugin)}
-     * @param plugin Plugin that owns the task
-     * @param task Task to be executed
-     * @return Task id number (-1 if scheduling failed)
-     */
-    @Deprecated
-    public int scheduleSyncDelayedTask(Plugin plugin, BukkitRunnable task);
-
-    /**
-     * Schedules a repeating task.
-     * <p>
-     * This task will be executed by the main server thread.
-     *
-     * @param plugin Plugin that owns the task
-     * @param task Task to be executed
-     * @param delay Delay in server ticks before executing first repeat
-     * @param period Period in server ticks of the task
-     * @return Task id number (-1 if scheduling failed)
-     */
-    public int scheduleSyncRepeatingTask(Plugin plugin, Runnable task, long delay, long period);
-
-    /**
-     * @deprecated Use {@link BukkitRunnable#runTaskTimer(Plugin, long, long)}     *
-     * @param plugin Plugin that owns the task
-     * @param task Task to be executed
-     * @param delay Delay in server ticks before executing first repeat
-     * @param period Period in server ticks of the task
-     * @return Task id number (-1 if scheduling failed)
-     */
-    @Deprecated
-    public int scheduleSyncRepeatingTask(Plugin plugin, BukkitRunnable task, long delay, long period);
-
-    /**
-     * <b>Asynchronous tasks should never access any API in Bukkit. Great care
-     * should be taken to assure the thread-safety of asynchronous tasks.</b>
-     * <p>
-     * Schedules a once off task to occur after a delay. This task will be
-     * executed by a thread managed by the scheduler.
-     *
-     * @param plugin Plugin that owns the task
-     * @param task Task to be executed
-     * @param delay Delay in server ticks before executing task
-     * @return Task id number (-1 if scheduling failed)
-     * @deprecated This name is misleading, as it does not schedule "a sync"
-     *     task, but rather, "an async" task
-     */
-    @Deprecated
-    public int scheduleAsyncDelayedTask(Plugin plugin, Runnable task, long delay);
-
-    /**
-     * <b>Asynchronous tasks should never access any API in Bukkit. Great care
-     * should be taken to assure the thread-safety of asynchronous tasks.</b>
-     * <p>
-     * Schedules a once off task to occur as soon as possible. This task will
-     * be executed by a thread managed by the scheduler.
-     *
-     * @param plugin Plugin that owns the task
-     * @param task Task to be executed
-     * @return Task id number (-1 if scheduling failed)
-     * @deprecated This name is misleading, as it does not schedule "a sync"
-     *     task, but rather, "an async" task
-     */
-    @Deprecated
-    public int scheduleAsyncDelayedTask(Plugin plugin, Runnable task);
-
-    /**
-     * <b>Asynchronous tasks should never access any API in Bukkit. Great care
-     * should be taken to assure the thread-safety of asynchronous tasks.</b>
-     * <p>
-     * Schedules a repeating task. This task will be executed by a thread
-     * managed by the scheduler.
-     *
-     * @param plugin Plugin that owns the task
-     * @param task Task to be executed
-     * @param delay Delay in server ticks before executing first repeat
-     * @param period Period in server ticks of the task
-     * @return Task id number (-1 if scheduling failed)
-     * @deprecated This name is misleading, as it does not schedule "a sync"
-     *     task, but rather, "an async" task
-     */
-    @Deprecated
-    public int scheduleAsyncRepeatingTask(Plugin plugin, Runnable task, long delay, long period);
-
-    /**
-     * Calls a method on the main thread and returns a Future object. This
-     * task will be executed by the main server thread.
-     * <ul>
-     * <li>Note: The Future.get() methods must NOT be called from the main
-     *     thread.
-     * <li>Note2: There is at least an average of 10ms latency until the
-     *     isDone() method returns true.
-     * </ul>
-     * @param <T> The callable's return type
-     * @param plugin Plugin that owns the task
-     * @param task Task to be executed
-     * @return Future Future object related to the task
-     */
-    public <T> Future<T> callSyncMethod(Plugin plugin, Callable<T> task);
-
-    /**
-     * Removes task from scheduler.
-     *
-     * @param taskId Id number of task to be removed
-     */
-    public void cancelTask(int taskId);
-
-    /**
-     * Removes all tasks associated with a particular plugin from the
-     * scheduler.
-     *
-     * @param plugin Owner of tasks to be removed
-     */
-    public void cancelTasks(Plugin plugin);
-
-    /**
-     * Removes all tasks from the scheduler.
-     */
-    public void cancelAllTasks();
-
-    /**
-     * Check if the task currently running.
-     * <p>
-     * A repeating task might not be running currently, but will be running in
-     * the future. A task that has finished, and does not repeat, will not be
-     * running ever again.
-     * <p>
-     * Explicitly, a task is running if there exists a thread for it, and that
-     * thread is alive.
-     *
-     * @param taskId The task to check.
-     * <p>
-     * @return If the task is currently running.
-     */
-    public boolean isCurrentlyRunning(int taskId);
-
-    /**
-     * Check if the task queued to be run later.
-     * <p>
-     * If a repeating task is currently running, it might not be queued now
-     * but could be in the future. A task that is not queued, and not running,
-     * will not be queued again.
-     *
-     * @param taskId The task to check.
-     * <p>
-     * @return If the task is queued to be run.
-     */
-    public boolean isQueued(int taskId);
-
-    /**
-     * Returns a list of all active workers.
-     * <p>
-     * This list contains asynch tasks that are being executed by separate
-     * threads.
-     *
-     * @return Active workers
-     */
-    public List<BukkitWorker> getActiveWorkers();
-
-    /**
-     * Returns a list of all pending tasks. The ordering of the tasks is not
-     * related to their order of execution.
-     *
-     * @return Active workers
-     */
-    public List<BukkitTask> getPendingTasks();
-
-    /**
-     * Returns a task that will run on the next server tick.
-     *
-     * @param plugin the reference to the plugin scheduling task
-     * @param task the task to be run
-     * @return a BukkitTask that contains the id number
-     * @throws IllegalArgumentException if plugin is null
-     * @throws IllegalArgumentException if task is null
-     */
-    public BukkitTask runTask(Plugin plugin, Runnable task) throws IllegalArgumentException;
-
-    /**
-     * @deprecated Use {@link BukkitRunnable#runTask(Plugin)}
-     *
-     * @param plugin the reference to the plugin scheduling task
-     * @param task the task to be run
-     * @return a BukkitTask that contains the id number
-     * @throws IllegalArgumentException if plugin is null
-     * @throws IllegalArgumentException if task is null
-     */
-    @Deprecated
-    public BukkitTask runTask(Plugin plugin, BukkitRunnable task) throws IllegalArgumentException;
-
-    /**
-     * <b>Asynchronous tasks should never access any API in Bukkit. Great care
-     * should be taken to assure the thread-safety of asynchronous tasks.</b>
-     * <p>
-     * Returns a task that will run asynchronously.
-     *
-     * @param plugin the reference to the plugin scheduling task
-     * @param task the task to be run
-     * @return a BukkitTask that contains the id number
-     * @throws IllegalArgumentException if plugin is null
-     * @throws IllegalArgumentException if task is null
-     */
-    public BukkitTask runTaskAsynchronously(Plugin plugin, Runnable task) throws IllegalArgumentException;
-
-    /**
-     * @deprecated Use {@link BukkitRunnable#runTaskAsynchronously(Plugin)}
-     * @param plugin the reference to the plugin scheduling task
-     * @param task the task to be run
-     * @return a BukkitTask that contains the id number
-     * @throws IllegalArgumentException if plugin is null
-     * @throws IllegalArgumentException if task is null
-     */
-    @Deprecated
-    public BukkitTask runTaskAsynchronously(Plugin plugin, BukkitRunnable task) throws IllegalArgumentException;
-
-    /**
-     * Returns a task that will run after the specified number of server
-     * ticks.
-     *
-     * @param plugin the reference to the plugin scheduling task
-     * @param task the task to be run
-     * @param delay the ticks to wait before running the task
-     * @return a BukkitTask that contains the id number
-     * @throws IllegalArgumentException if plugin is null
-     * @throws IllegalArgumentException if task is null
-     */
-    public BukkitTask runTaskLater(Plugin plugin, Runnable task, long delay) throws IllegalArgumentException;
-
-    /**
-     * @deprecated Use {@link BukkitRunnable#runTaskLater(Plugin, long)}
-     * @param plugin the reference to the plugin scheduling task
-     * @param task the task to be run
-     * @param delay the ticks to wait before running the task
-     * @return a BukkitTask that contains the id number
-     * @throws IllegalArgumentException if plugin is null
-     * @throws IllegalArgumentException if task is null
-     */
-    @Deprecated
-    public BukkitTask runTaskLater(Plugin plugin, BukkitRunnable task, long delay) throws IllegalArgumentException;
-
-    /**
-     * <b>Asynchronous tasks should never access any API in Bukkit. Great care
-     * should be taken to assure the thread-safety of asynchronous tasks.</b>
-     * <p>
-     * Returns a task that will run asynchronously after the specified number
-     * of server ticks.
-     *
-     * @param plugin the reference to the plugin scheduling task
-     * @param task the task to be run
-     * @param delay the ticks to wait before running the task
-     * @return a BukkitTask that contains the id number
-     * @throws IllegalArgumentException if plugin is null
-     * @throws IllegalArgumentException if task is null
-     */
-    public BukkitTask runTaskLaterAsynchronously(Plugin plugin, Runnable task, long delay) throws IllegalArgumentException;
-
-    /**
-     * @deprecated Use {@link BukkitRunnable#runTaskLaterAsynchronously(Plugin, long)}
-     * @param plugin the reference to the plugin scheduling task
-     * @param task the task to be run
-     * @param delay the ticks to wait before running the task
-     * @return a BukkitTask that contains the id number
-     * @throws IllegalArgumentException if plugin is null
-     * @throws IllegalArgumentException if task is null
-     */
-    @Deprecated
-    public BukkitTask runTaskLaterAsynchronously(Plugin plugin, BukkitRunnable task, long delay) throws IllegalArgumentException;
-
-    /**
-     * Returns a task that will repeatedly run until cancelled, starting after
-     * the specified number of server ticks.
-     *
-     * @param plugin the reference to the plugin scheduling task
-     * @param task the task to be run
-     * @param delay the ticks to wait before running the task
-     * @param period the ticks to wait between runs
-     * @return a BukkitTask that contains the id number
-     * @throws IllegalArgumentException if plugin is null
-     * @throws IllegalArgumentException if task is null
-     */
-    public BukkitTask runTaskTimer(Plugin plugin, Runnable task, long delay, long period) throws IllegalArgumentException;
-
-    /**
-     * @deprecated Use {@link BukkitRunnable#runTaskTimer(Plugin, long, long)}
-     * @param plugin the reference to the plugin scheduling task
-     * @param task the task to be run
-     * @param delay the ticks to wait before running the task
-     * @param period the ticks to wait between runs
-     * @return a BukkitTask that contains the id number
-     * @throws IllegalArgumentException if plugin is null
-     * @throws IllegalArgumentException if task is null
-     */
-    @Deprecated
-    public BukkitTask runTaskTimer(Plugin plugin, BukkitRunnable task, long delay, long period) throws IllegalArgumentException;
-
-    /**
-     * <b>Asynchronous tasks should never access any API in Bukkit. Great care
-     * should be taken to assure the thread-safety of asynchronous tasks.</b>
-     * <p>
-     * Returns a task that will repeatedly run asynchronously until cancelled,
-     * starting after the specified number of server ticks.
-     *
-     * @param plugin the reference to the plugin scheduling task
-     * @param task the task to be run
-     * @param delay the ticks to wait before running the task for the first
-     *     time
-     * @param period the ticks to wait between runs
-     * @return a BukkitTask that contains the id number
-     * @throws IllegalArgumentException if plugin is null
-     * @throws IllegalArgumentException if task is null
-     */
-    public BukkitTask runTaskTimerAsynchronously(Plugin plugin, Runnable task, long delay, long period) throws IllegalArgumentException;
-
-    /**
-     * @deprecated Use {@link BukkitRunnable#runTaskTimerAsynchronously(Plugin, long, long)}
-     * @param plugin the reference to the plugin scheduling task
-     * @param task the task to be run
-     * @param delay the ticks to wait before running the task for the first
-     *     time
-     * @param period the ticks to wait between runs
-     * @return a BukkitTask that contains the id number
-     * @throws IllegalArgumentException if plugin is null
-     * @throws IllegalArgumentException if task is null
-     */
-    @Deprecated
-    public BukkitTask runTaskTimerAsynchronously(Plugin plugin, BukkitRunnable task, long delay, long period) throws IllegalArgumentException;
-}
diff --git a/src/main/java/org/bukkit/scheduler/BukkitTask.java b/src/main/java/org/bukkit/scheduler/BukkitTask.java
deleted file mode 100644
index e447e64..0000000
--- a/src/main/java/org/bukkit/scheduler/BukkitTask.java
+++ /dev/null
@@ -1,35 +0,0 @@
-package org.bukkit.scheduler;
-
-import org.bukkit.plugin.Plugin;
-
-/**
- * Represents a task being executed by the scheduler
- */
-public interface BukkitTask {
-
-    /**
-     * Returns the taskId for the task.
-     *
-     * @return Task id number
-     */
-    public int getTaskId();
-
-    /**
-     * Returns the Plugin that owns this task.
-     *
-     * @return The Plugin that owns the task
-     */
-    public Plugin getOwner();
-
-    /**
-     * Returns true if the Task is a sync task.
-     *
-     * @return true if the task is run by main thread
-     */
-    public boolean isSync();
-
-    /**
-     * Will attempt to cancel this task.
-     */
-    public void cancel();
-}
diff --git a/src/main/java/org/bukkit/scheduler/BukkitWorker.java b/src/main/java/org/bukkit/scheduler/BukkitWorker.java
deleted file mode 100644
index fe1afbd..0000000
--- a/src/main/java/org/bukkit/scheduler/BukkitWorker.java
+++ /dev/null
@@ -1,34 +0,0 @@
-package org.bukkit.scheduler;
-
-import org.bukkit.plugin.Plugin;
-
-/**
- * Represents a worker thread for the scheduler. This gives information about
- * the Thread object for the task, owner of the task and the taskId.
- * <p>
- * Workers are used to execute async tasks.
- */
-public interface BukkitWorker {
-
-    /**
-     * Returns the taskId for the task being executed by this worker.
-     *
-     * @return Task id number
-     */
-    public int getTaskId();
-
-    /**
-     * Returns the Plugin that owns this task.
-     *
-     * @return The Plugin that owns the task
-     */
-    public Plugin getOwner();
-
-    /**
-     * Returns the thread for the worker.
-     *
-     * @return The Thread object for the worker
-     */
-    public Thread getThread();
-
-}
diff --git a/src/main/java/org/bukkit/scoreboard/Criterias.java b/src/main/java/org/bukkit/scoreboard/Criterias.java
deleted file mode 100644
index cd81c87..0000000
--- a/src/main/java/org/bukkit/scoreboard/Criterias.java
+++ /dev/null
@@ -1,20 +0,0 @@
-package org.bukkit.scoreboard;
-
-/**
- * Criteria names which trigger an objective to be modified by actions in-game
- */
-public class Criterias {
-    public static final String HEALTH;
-    public static final String PLAYER_KILLS;
-    public static final String TOTAL_KILLS;
-    public static final String DEATHS;
-
-    static {
-        HEALTH="health";
-        PLAYER_KILLS="playerKillCount";
-        TOTAL_KILLS="totalKillCount";
-        DEATHS="deathCount";
-    }
-
-    private Criterias() {}
-}
diff --git a/src/main/java/org/bukkit/scoreboard/DisplaySlot.java b/src/main/java/org/bukkit/scoreboard/DisplaySlot.java
deleted file mode 100644
index 5d58a18..0000000
--- a/src/main/java/org/bukkit/scoreboard/DisplaySlot.java
+++ /dev/null
@@ -1,10 +0,0 @@
-package org.bukkit.scoreboard;
-
-/**
- * Locations for displaying objectives to the player
- */
-public enum DisplaySlot {
-    BELOW_NAME,
-    PLAYER_LIST,
-    SIDEBAR;
-}
diff --git a/src/main/java/org/bukkit/scoreboard/NameTagVisibility.java b/src/main/java/org/bukkit/scoreboard/NameTagVisibility.java
deleted file mode 100644
index d9e9ae1..0000000
--- a/src/main/java/org/bukkit/scoreboard/NameTagVisibility.java
+++ /dev/null
@@ -1,25 +0,0 @@
-package org.bukkit.scoreboard;
-
-/**
- * @deprecated replaced by {@link Team.OptionStatus}
- */
-@Deprecated
-public enum NameTagVisibility {
-
-    /**
-     * Always show the player's nametag.
-     */
-    ALWAYS,
-    /**
-     * Never show the player's nametag.
-     */
-    NEVER,
-    /**
-     * Show the player's nametag only to his own team members.
-     */
-    HIDE_FOR_OTHER_TEAMS,
-    /**
-     * Show the player's nametag only to members of other teams.
-     */
-    HIDE_FOR_OWN_TEAM;
-}
diff --git a/src/main/java/org/bukkit/scoreboard/Objective.java b/src/main/java/org/bukkit/scoreboard/Objective.java
deleted file mode 100644
index 321aac7..0000000
--- a/src/main/java/org/bukkit/scoreboard/Objective.java
+++ /dev/null
@@ -1,110 +0,0 @@
-package org.bukkit.scoreboard;
-
-import org.bukkit.OfflinePlayer;
-
-/**
- * An objective on a scoreboard that can show scores specific to entries. This
- * objective is only relevant to the display of the associated {@link
- * #getScoreboard() scoreboard}.
- */
-public interface Objective {
-
-    /**
-     * Gets the name of this Objective
-     *
-     * @return this objective'ss name
-     * @throws IllegalStateException if this objective has been unregistered
-     */
-    String getName() throws IllegalStateException;
-
-    /**
-     * Gets the name displayed to players for this objective
-     *
-     * @return this objective's display name
-     * @throws IllegalStateException if this objective has been unregistered
-     */
-    String getDisplayName() throws IllegalStateException;
-
-    /**
-     * Sets the name displayed to players for this objective.
-     *
-     * @param displayName Display name to set
-     * @throws IllegalStateException if this objective has been unregistered
-     * @throws IllegalArgumentException if displayName is null
-     * @throws IllegalArgumentException if displayName is longer than 32
-     *     characters.
-     */
-    void setDisplayName(String displayName) throws IllegalStateException, IllegalArgumentException;
-
-    /**
-     * Gets the criteria this objective tracks.
-     *
-     * @return this objective's criteria
-     * @throws IllegalStateException if this objective has been unregistered
-     */
-    String getCriteria() throws IllegalStateException;
-
-    /**
-     * Gets if the objective's scores can be modified directly by a plugin.
-     *
-     * @return true if scores are modifiable
-     * @throws IllegalStateException if this objective has been unregistered
-     * @see Criterias#HEALTH
-     */
-    boolean isModifiable() throws IllegalStateException;
-
-    /**
-     * Gets the scoreboard to which this objective is attached.
-     *
-     * @return Owning scoreboard, or null if it has been {@link #unregister()
-     *     unregistered}
-     */
-    Scoreboard getScoreboard();
-
-    /**
-     * Unregisters this objective from the {@link Scoreboard scoreboard.}
-     *
-     * @throws IllegalStateException if this objective has been unregistered
-     */
-    void unregister() throws IllegalStateException;
-
-    /**
-     * Sets this objective to display on the specified slot for the
-     * scoreboard, removing it from any other display slot.
-     *
-     * @param slot display slot to change, or null to not display
-     * @throws IllegalStateException if this objective has been unregistered
-     */
-    void setDisplaySlot(DisplaySlot slot) throws IllegalStateException;
-
-    /**
-     * Gets the display slot this objective is displayed at.
-     *
-     * @return the display slot for this objective, or null if not displayed
-     * @throws IllegalStateException if this objective has been unregistered
-     */
-    DisplaySlot getDisplaySlot() throws IllegalStateException;
-
-    /**
-     * Gets a player's Score for an Objective on this Scoreboard
-     *
-     * @param player Player for the Score
-     * @return Score tracking the Objective and player specified
-     * @throws IllegalArgumentException if player is null
-     * @throws IllegalStateException if this objective has been unregistered
-     * @deprecated Scoreboards can contain entries that aren't players
-     * @see #getScore(String)
-     */
-    @Deprecated
-    Score getScore(OfflinePlayer player) throws IllegalArgumentException, IllegalStateException;
-
-    /**
-     * Gets an entry's Score for an Objective on this Scoreboard.
-     *
-     * @param entry Entry for the Score
-     * @return Score tracking the Objective and entry specified
-     * @throws IllegalArgumentException if entry is null
-     * @throws IllegalStateException if this objective has been unregistered
-     */
-    Score getScore(String entry) throws IllegalArgumentException, IllegalStateException;
-}
diff --git a/src/main/java/org/bukkit/scoreboard/Score.java b/src/main/java/org/bukkit/scoreboard/Score.java
deleted file mode 100644
index 4c10346..0000000
--- a/src/main/java/org/bukkit/scoreboard/Score.java
+++ /dev/null
@@ -1,61 +0,0 @@
-package org.bukkit.scoreboard;
-
-import org.bukkit.OfflinePlayer;
-
-/**
- * A score entry for an {@link #getEntry() entry} on an {@link
- * #getObjective() objective}. Changing this will not affect any other
- * objective or scoreboard.
- */
-public interface Score {
-
-    /**
-     * Gets the OfflinePlayer being tracked by this Score
-     *
-     * @return this Score's tracked player
-     * @deprecated Scoreboards can contain entries that aren't players
-     * @see #getEntry()
-     */
-    @Deprecated
-    OfflinePlayer getPlayer();
-
-    /**
-     * Gets the entry being tracked by this Score
-     *
-     * @return this Score's tracked entry
-     */
-    String getEntry();
-
-    /**
-     * Gets the Objective being tracked by this Score
-     *
-     * @return this Score's tracked objective
-     */
-    Objective getObjective();
-
-    /**
-     * Gets the current score
-     *
-     * @return the current score
-     * @throws IllegalStateException if the associated objective has been
-     *     unregistered
-     */
-    int getScore() throws IllegalStateException;
-
-    /**
-     * Sets the current score.
-     *
-     * @param score New score
-     * @throws IllegalStateException if the associated objective has been
-     *     unregistered
-     */
-    void setScore(int score) throws IllegalStateException;
-
-    /**
-     * Gets the scoreboard for the associated objective.
-     *
-     * @return the owning objective's scoreboard, or null if it has been
-     *     {@link Objective#unregister() unregistered}
-     */
-    Scoreboard getScoreboard();
-}
diff --git a/src/main/java/org/bukkit/scoreboard/Scoreboard.java b/src/main/java/org/bukkit/scoreboard/Scoreboard.java
deleted file mode 100644
index 7008610..0000000
--- a/src/main/java/org/bukkit/scoreboard/Scoreboard.java
+++ /dev/null
@@ -1,171 +0,0 @@
-package org.bukkit.scoreboard;
-
-import java.util.Set;
-
-import org.bukkit.OfflinePlayer;
-
-/**
- * A scoreboard
- */
-public interface Scoreboard {
-
-    /**
-     * Registers an Objective on this Scoreboard
-     *
-     * @param name Name of the Objective
-     * @param criteria Criteria for the Objective
-     * @return The registered Objective
-     * @throws IllegalArgumentException if name is null
-     * @throws IllegalArgumentException if criteria is null
-     * @throws IllegalArgumentException if an objective by that name already
-     *     exists
-     */
-    Objective registerNewObjective(String name, String criteria) throws IllegalArgumentException;
-
-    /**
-     * Gets an Objective on this Scoreboard by name
-     *
-     * @param name Name of the Objective
-     * @return the Objective or null if it does not exist
-     * @throws IllegalArgumentException if name is null
-     */
-    Objective getObjective(String name) throws IllegalArgumentException;
-
-    /**
-     * Gets all Objectives of a Criteria on the Scoreboard
-     *
-     * @param criteria Criteria to search by
-     * @return an immutable set of Objectives using the specified Criteria
-     */
-    Set<Objective> getObjectivesByCriteria(String criteria) throws IllegalArgumentException;
-
-    /**
-     * Gets all Objectives on this Scoreboard
-     *
-     * @return An immutable set of all Objectives on this Scoreboard
-     */
-    Set<Objective> getObjectives();
-
-    /**
-     * Gets the Objective currently displayed in a DisplaySlot on this
-     * Scoreboard
-     *
-     * @param slot The DisplaySlot
-     * @return the Objective currently displayed or null if nothing is
-     *     displayed in that DisplaySlot
-     * @throws IllegalArgumentException if slot is null
-     */
-    Objective getObjective(DisplaySlot slot) throws IllegalArgumentException;
-
-    /**
-     * Gets all scores for a player on this Scoreboard
-     *
-     * @param player the player whose scores are being retrieved
-     * @return immutable set of all scores tracked for the player
-     * @throws IllegalArgumentException if player is null
-     * @deprecated Scoreboards can contain entries that aren't players
-     * @see #getScores(String)
-     */
-    @Deprecated
-    Set<Score> getScores(OfflinePlayer player) throws IllegalArgumentException;
-
-    /**
-     * Gets all scores for an entry on this Scoreboard
-     *
-     * @param entry the entry whose scores are being retrieved
-     * @return immutable set of all scores tracked for the entry
-     * @throws IllegalArgumentException if entry is null
-     */
-    Set<Score> getScores(String entry) throws IllegalArgumentException;
-
-    /**
-     * Removes all scores for a player on this Scoreboard
-     *
-     * @param player the player to drop all current scores for
-     * @throws IllegalArgumentException if player is null
-     * @deprecated Scoreboards can contain entries that aren't players
-     * @see #resetScores(String)
-     */
-    @Deprecated
-    void resetScores(OfflinePlayer player) throws IllegalArgumentException;
-
-    /**
-     * Removes all scores for an entry on this Scoreboard
-     *
-     * @param entry the entry to drop all current scores for
-     * @throws IllegalArgumentException if entry is null
-     */
-    void resetScores(String entry) throws IllegalArgumentException;
-
-    /**
-     * Gets a player's Team on this Scoreboard
-     *
-     * @param player the player to search for
-     * @return the player's Team or null if the player is not on a team
-     * @throws IllegalArgumentException if player is null
-     * @deprecated Scoreboards can contain entries that aren't players
-     * @see #getEntryTeam(String)
-     */
-    @Deprecated
-    Team getPlayerTeam(OfflinePlayer player) throws IllegalArgumentException;
-
-    /**
-     * Gets a entries Team on this Scoreboard
-     *
-     * @param entry the entry to search for
-     * @return the entries Team or null if the entry is not on a team
-     * @throws IllegalArgumentException if entry is null
-     */
-    Team getEntryTeam(String entry) throws IllegalArgumentException;
-
-    /**
-     * Gets a Team by name on this Scoreboard
-     *
-     * @param teamName Team name
-     * @return the matching Team or null if no matches
-     * @throws IllegalArgumentException if teamName is null
-     */
-    Team getTeam(String teamName) throws IllegalArgumentException;
-
-    /**
-     * Gets all teams on this Scoreboard
-     *
-     * @return an immutable set of Teams
-     */
-    Set<Team> getTeams();
-
-    /**
-     * Registers a Team on this Scoreboard
-     *
-     * @param name Team name
-     * @return registered Team
-     * @throws IllegalArgumentException if name is null
-     * @throws IllegalArgumentException if team by that name already exists
-     */
-    Team registerNewTeam(String name) throws IllegalArgumentException;
-
-    /**
-     * Gets all players tracked by this Scoreboard
-     *
-     * @return immutable set of all tracked players
-     * @deprecated Scoreboards can contain entries that aren't players
-     * @see #getEntries()
-     */
-    @Deprecated
-    Set<OfflinePlayer> getPlayers();
-
-    /**
-     * Gets all entries tracked by this Scoreboard
-     *
-     * @return immutable set of all tracked entries
-     */
-    Set<String> getEntries();
-
-    /**
-     * Clears any objective in the specified slot.
-     *
-     * @param slot the slot to remove objectives
-     * @throws IllegalArgumentException if slot is null
-     */
-    void clearSlot(DisplaySlot slot) throws IllegalArgumentException;
-}
diff --git a/src/main/java/org/bukkit/scoreboard/ScoreboardManager.java b/src/main/java/org/bukkit/scoreboard/ScoreboardManager.java
deleted file mode 100644
index 00b67a1..0000000
--- a/src/main/java/org/bukkit/scoreboard/ScoreboardManager.java
+++ /dev/null
@@ -1,29 +0,0 @@
-package org.bukkit.scoreboard;
-
-import java.lang.ref.WeakReference;
-
-/**
- * Manager of Scoreboards
- */
-public interface ScoreboardManager {
-
-    /**
-     * Gets the primary Scoreboard controlled by the server.
-     * <p>
-     * This Scoreboard is saved by the server, is affected by the /scoreboard
-     * command, and is the scoreboard shown by default to players.
-     *
-     * @return the default sever scoreboard
-     */
-    Scoreboard getMainScoreboard();
-
-    /**
-     * Gets a new Scoreboard to be tracked by the server. This scoreboard will
-     * be tracked as long as a reference is kept, either by a player or by a
-     * plugin.
-     *
-     * @return the registered Scoreboard
-     * @see WeakReference
-     */
-    Scoreboard getNewScoreboard();
-}
diff --git a/src/main/java/org/bukkit/scoreboard/Team.java b/src/main/java/org/bukkit/scoreboard/Team.java
deleted file mode 100644
index 9052b4a..0000000
--- a/src/main/java/org/bukkit/scoreboard/Team.java
+++ /dev/null
@@ -1,305 +0,0 @@
-package org.bukkit.scoreboard;
-
-import java.util.Set;
-
-import org.bukkit.OfflinePlayer;
-import org.bukkit.potion.PotionEffectType;
-
-/**
- * A team on a scoreboard that has a common display theme and other
- * properties. This team is only relevant to the display of the associated
- * {@link #getScoreboard() scoreboard}.
- */
-public interface Team {
-
-    /**
-     * Gets the name of this Team
-     *
-     * @return Objective name
-     * @throws IllegalStateException if this team has been unregistered
-     */
-    String getName() throws IllegalStateException;
-
-    /**
-     * Gets the name displayed to entries for this team
-     *
-     * @return Team display name
-     * @throws IllegalStateException if this team has been unregistered
-     */
-    String getDisplayName() throws IllegalStateException;
-
-    /**
-     * Sets the name displayed to entries for this team
-     *
-     * @param displayName New display name
-     * @throws IllegalArgumentException if displayName is longer than 32
-     *     characters.
-     * @throws IllegalStateException if this team has been unregistered
-     */
-    void setDisplayName(String displayName) throws IllegalStateException, IllegalArgumentException;
-
-    /**
-     * Gets the prefix prepended to the display of entries on this team.
-     *
-     * @return Team prefix
-     * @throws IllegalStateException if this team has been unregistered
-     */
-    String getPrefix() throws IllegalStateException;
-
-    /**
-     * Sets the prefix prepended to the display of entries on this team.
-     *
-     * @param prefix New prefix
-     * @throws IllegalArgumentException if prefix is null
-     * @throws IllegalArgumentException if prefix is longer than 16
-     *     characters
-     * @throws IllegalStateException if this team has been unregistered
-     */
-    void setPrefix(String prefix) throws IllegalStateException, IllegalArgumentException;
-
-    /**
-     * Gets the suffix appended to the display of entries on this team.
-     *
-     * @return the team's current suffix
-     * @throws IllegalStateException if this team has been unregistered
-     */
-    String getSuffix() throws IllegalStateException;
-
-    /**
-     * Sets the suffix appended to the display of entries on this team.
-     *
-     * @param suffix the new suffix for this team.
-     * @throws IllegalArgumentException if suffix is null
-     * @throws IllegalArgumentException if suffix is longer than 16
-     *     characters
-     * @throws IllegalStateException if this team has been unregistered
-     */
-    void setSuffix(String suffix) throws IllegalStateException, IllegalArgumentException;
-
-    /**
-     * Gets the team friendly fire state
-     *
-     * @return true if friendly fire is enabled
-     * @throws IllegalStateException if this team has been unregistered
-     */
-    boolean allowFriendlyFire() throws IllegalStateException;
-
-    /**
-     * Sets the team friendly fire state
-     *
-     * @param enabled true if friendly fire is to be allowed
-     * @throws IllegalStateException if this team has been unregistered
-     */
-    void setAllowFriendlyFire(boolean enabled) throws IllegalStateException;
-
-    /**
-     * Gets the team's ability to see {@link PotionEffectType#INVISIBILITY
-     * invisible} teammates.
-     *
-     * @return true if team members can see invisible members
-     * @throws IllegalStateException if this team has been unregistered
-     */
-    boolean canSeeFriendlyInvisibles() throws IllegalStateException;
-
-    /**
-     * Sets the team's ability to see {@link PotionEffectType#INVISIBILITY
-     * invisible} teammates.
-     *
-     * @param enabled true if invisible teammates are to be visible
-     * @throws IllegalStateException if this team has been unregistered
-     */
-    void setCanSeeFriendlyInvisibles(boolean enabled) throws IllegalStateException;
-
-    /**
-     * Gets the team's ability to see name tags
-     *
-     * @return the current name tag visibilty for the team
-     * @throws IllegalArgumentException if this team has been unregistered
-     * @deprecated see {@link #getOption(org.bukkit.scoreboard.Team.Option)}
-     */
-    @Deprecated
-    NameTagVisibility getNameTagVisibility() throws IllegalArgumentException;
-
-    /**
-     * Set's the team's ability to see name tags
-     *
-     * @param visibility The nameTagVisibilty to set
-     * @throws IllegalArgumentException if this team has been unregistered
-     * @deprecated see
-     * {@link #setOption(org.bukkit.scoreboard.Team.Option, org.bukkit.scoreboard.Team.OptionStatus)}
-     */
-    @Deprecated
-    void setNameTagVisibility(NameTagVisibility visibility) throws IllegalArgumentException;
-
-    /**
-     * Gets the Set of players on the team
-     *
-     * @return players on the team
-     * @throws IllegalStateException if this team has been unregistered\
-     * @deprecated Teams can contain entries that aren't players
-     * @see #getEntries()
-     */
-    @Deprecated
-    Set<OfflinePlayer> getPlayers() throws IllegalStateException;
-
-    /**
-     * Gets the Set of entries on the team
-     *
-     * @return entries on the team
-     * @throws IllegalStateException if this entries has been unregistered\
-     */
-    Set<String> getEntries() throws IllegalStateException;
-
-    /**
-     * Gets the size of the team
-     *
-     * @return number of entries on the team
-     * @throws IllegalStateException if this team has been unregistered
-     */
-    int getSize() throws IllegalStateException;
-
-    /**
-     * Gets the Scoreboard to which this team is attached
-     *
-     * @return Owning scoreboard, or null if this team has been {@link
-     *     #unregister() unregistered}
-     */
-    Scoreboard getScoreboard();
-
-    /**
-     * This puts the specified player onto this team for the scoreboard.
-     * <p>
-     * This will remove the player from any other team on the scoreboard.
-     *
-     * @param player the player to add
-     * @throws IllegalArgumentException if player is null
-     * @throws IllegalStateException if this team has been unregistered
-     * @deprecated Teams can contain entries that aren't players
-     * @see #addEntry(String)
-     */
-    @Deprecated
-    void addPlayer(OfflinePlayer player) throws IllegalStateException, IllegalArgumentException;
-
-    /**
-     * This puts the specified entry onto this team for the scoreboard.
-     * <p>
-     * This will remove the entry from any other team on the scoreboard.
-     *
-     * @param entry the entry to add
-     * @throws IllegalArgumentException if entry is null
-     * @throws IllegalStateException if this team has been unregistered
-     */
-    void addEntry(String entry) throws IllegalStateException, IllegalArgumentException;
-
-    /**
-     * Removes the player from this team.
-     *
-     * @param player the player to remove
-     * @return if the player was on this team
-     * @throws IllegalArgumentException if player is null
-     * @throws IllegalStateException if this team has been unregistered
-     * @deprecated Teams can contain entries that aren't players
-     * @see #removeEntry(String)
-     */
-    @Deprecated
-    boolean removePlayer(OfflinePlayer player) throws IllegalStateException, IllegalArgumentException;
-
-    /**
-     * Removes the entry from this team.
-     *
-     * @param entry the entry to remove
-     * @throws IllegalArgumentException if entry is null
-     * @throws IllegalStateException if this team has been unregistered
-     * @return if the entry was a part of this team
-     */
-    boolean removeEntry(String entry) throws IllegalStateException, IllegalArgumentException;
-
-    /**
-     * Unregisters this team from the Scoreboard
-     *
-     * @throws IllegalStateException if this team has been unregistered
-     */
-    void unregister() throws IllegalStateException;
-
-    /**
-     * Checks to see if the specified player is a member of this team.
-     *
-     * @param player the player to search for
-     * @return true if the player is a member of this team
-     * @throws IllegalArgumentException if player is null
-     * @throws IllegalStateException if this team has been unregistered
-     * @deprecated Teams can contain entries that aren't players
-     * @see #hasEntry(String)
-     */
-    @Deprecated
-    boolean hasPlayer(OfflinePlayer player) throws IllegalArgumentException, IllegalStateException;
-    /**
-     * Checks to see if the specified entry is a member of this team.
-     *
-     * @param entry the entry to search for
-     * @return true if the entry is a member of this team
-     * @throws IllegalArgumentException if entry is null
-     * @throws IllegalStateException if this team has been unregistered
-     */
-    boolean hasEntry(String entry) throws IllegalArgumentException, IllegalStateException;
-
-    /**
-     * Get an option for this team
-     *
-     * @param option the option to get
-     * @return the option status
-     * @throws IllegalStateException if this team has been unregistered
-     */
-    OptionStatus getOption(Option option) throws IllegalStateException;
-
-    /**
-     * Set an option for this team
-     *
-     * @param option the option to set
-     * @param status the new option status
-     * @throws IllegalStateException if this team has been unregistered
-     */
-    void setOption(Option option, OptionStatus status) throws IllegalStateException;
-
-    /**
-     * Represents an option which may be applied to this team.
-     */
-    public enum Option {
-
-        /**
-         * How to display the name tags of players on this team.
-         */
-        NAME_TAG_VISIBILITY,
-        /**
-         * How to display the death messages for players on this team.
-         */
-        DEATH_MESSAGE_VISIBILITY,
-        /**
-         * How players of this team collide with others.
-         */
-        COLLISION_RULE;
-    }
-
-    /**
-     * How an option may be applied to members of this team.
-     */
-    public enum OptionStatus {
-
-        /**
-         * Apply this option to everyone.
-         */
-        ALWAYS,
-        /**
-         * Never apply this option.
-         */
-        NEVER,
-        /**
-         * Apply this option only for opposing teams.
-         */
-        FOR_OTHER_TEAMS,
-        /**
-         * Apply this option for only team members.
-         */
-        FOR_OWN_TEAM;
-    }
-}
diff --git a/src/main/java/org/bukkit/util/BlockIterator.java b/src/main/java/org/bukkit/util/BlockIterator.java
deleted file mode 100644
index 5c85778..0000000
--- a/src/main/java/org/bukkit/util/BlockIterator.java
+++ /dev/null
@@ -1,357 +0,0 @@
-package org.bukkit.util;
-
-import static org.bukkit.util.NumberConversions.*;
-
-import org.bukkit.World;
-import org.bukkit.Location;
-import org.bukkit.block.Block;
-import org.bukkit.block.BlockFace;
-import org.bukkit.entity.LivingEntity;
-
-import java.util.Iterator;
-import java.util.NoSuchElementException;
-
-/**
- * This class performs ray tracing and iterates along blocks on a line
- */
-public class BlockIterator implements Iterator<Block> {
-
-    private final World world;
-    private final int maxDistance;
-
-    private static final int gridSize = 1 << 24;
-
-    private boolean end = false;
-
-    private Block[] blockQueue = new Block[3];
-    private int currentBlock = 0;
-    private int currentDistance = 0;
-    private int maxDistanceInt;
-
-    private int secondError;
-    private int thirdError;
-
-    private int secondStep;
-    private int thirdStep;
-
-    private BlockFace mainFace;
-    private BlockFace secondFace;
-    private BlockFace thirdFace;
-
-    /**
-     * Constructs the BlockIterator
-     *
-     * @param world The world to use for tracing
-     * @param start A Vector giving the initial location for the trace
-     * @param direction A Vector pointing in the direction for the trace
-     * @param yOffset The trace begins vertically offset from the start vector
-     *     by this value
-     * @param maxDistance This is the maximum distance in blocks for the
-     *     trace. Setting this value above 140 may lead to problems with
-     *     unloaded chunks. A value of 0 indicates no limit
-     *
-     */
-    public BlockIterator(World world, Vector start, Vector direction, double yOffset, int maxDistance) {
-        this.world = world;
-        this.maxDistance = maxDistance;
-
-        Vector startClone = start.clone();
-
-        startClone.setY(startClone.getY() + yOffset);
-
-        currentDistance = 0;
-
-        double mainDirection = 0;
-        double secondDirection = 0;
-        double thirdDirection = 0;
-
-        double mainPosition = 0;
-        double secondPosition = 0;
-        double thirdPosition = 0;
-
-        Block startBlock = this.world.getBlockAt(floor(startClone.getX()), floor(startClone.getY()), floor(startClone.getZ()));
-
-        if (getXLength(direction) > mainDirection) {
-            mainFace = getXFace(direction);
-            mainDirection = getXLength(direction);
-            mainPosition = getXPosition(direction, startClone, startBlock);
-
-            secondFace = getYFace(direction);
-            secondDirection = getYLength(direction);
-            secondPosition = getYPosition(direction, startClone, startBlock);
-
-            thirdFace = getZFace(direction);
-            thirdDirection = getZLength(direction);
-            thirdPosition = getZPosition(direction, startClone, startBlock);
-        }
-        if (getYLength(direction) > mainDirection) {
-            mainFace = getYFace(direction);
-            mainDirection = getYLength(direction);
-            mainPosition = getYPosition(direction, startClone, startBlock);
-
-            secondFace = getZFace(direction);
-            secondDirection = getZLength(direction);
-            secondPosition = getZPosition(direction, startClone, startBlock);
-
-            thirdFace = getXFace(direction);
-            thirdDirection = getXLength(direction);
-            thirdPosition = getXPosition(direction, startClone, startBlock);
-        }
-        if (getZLength(direction) > mainDirection) {
-            mainFace = getZFace(direction);
-            mainDirection = getZLength(direction);
-            mainPosition = getZPosition(direction, startClone, startBlock);
-
-            secondFace = getXFace(direction);
-            secondDirection = getXLength(direction);
-            secondPosition = getXPosition(direction, startClone, startBlock);
-
-            thirdFace = getYFace(direction);
-            thirdDirection = getYLength(direction);
-            thirdPosition = getYPosition(direction, startClone, startBlock);
-        }
-
-        // trace line backwards to find intercept with plane perpendicular to the main axis
-
-        double d = mainPosition / mainDirection; // how far to hit face behind
-        double secondd = secondPosition - secondDirection * d;
-        double thirdd = thirdPosition - thirdDirection * d;
-
-        // Guarantee that the ray will pass though the start block.
-        // It is possible that it would miss due to rounding
-        // This should only move the ray by 1 grid position
-        secondError = floor(secondd * gridSize);
-        secondStep = round(secondDirection / mainDirection * gridSize);
-        thirdError = floor(thirdd * gridSize);
-        thirdStep = round(thirdDirection / mainDirection * gridSize);
-
-        if (secondError + secondStep <= 0) {
-            secondError = -secondStep + 1;
-        }
-
-        if (thirdError + thirdStep <= 0) {
-            thirdError = -thirdStep + 1;
-        }
-
-        Block lastBlock;
-
-        lastBlock = startBlock.getRelative(mainFace.getOppositeFace());
-
-        if (secondError < 0) {
-            secondError += gridSize;
-            lastBlock = lastBlock.getRelative(secondFace.getOppositeFace());
-        }
-
-        if (thirdError < 0) {
-            thirdError += gridSize;
-            lastBlock = lastBlock.getRelative(thirdFace.getOppositeFace());
-        }
-
-        // This means that when the variables are positive, it means that the coord=1 boundary has been crossed
-        secondError -= gridSize;
-        thirdError -= gridSize;
-
-        blockQueue[0] = lastBlock;
-        currentBlock = -1;
-
-        scan();
-
-        boolean startBlockFound = false;
-
-        for (int cnt = currentBlock; cnt >= 0; cnt--) {
-            if (blockEquals(blockQueue[cnt], startBlock)) {
-                currentBlock = cnt;
-                startBlockFound = true;
-                break;
-            }
-        }
-
-        if (!startBlockFound) {
-            throw new IllegalStateException("Start block missed in BlockIterator");
-        }
-
-        // Calculate the number of planes passed to give max distance
-        maxDistanceInt = round(maxDistance / (Math.sqrt(mainDirection * mainDirection + secondDirection * secondDirection + thirdDirection * thirdDirection) / mainDirection));
-
-    }
-
-    private boolean blockEquals(Block a, Block b) {
-        return a.getX() == b.getX() && a.getY() == b.getY() && a.getZ() == b.getZ();
-    }
-
-    private BlockFace getXFace(Vector direction) {
-        return ((direction.getX() > 0) ? BlockFace.EAST : BlockFace.WEST);
-    }
-
-    private BlockFace getYFace(Vector direction) {
-        return ((direction.getY() > 0) ? BlockFace.UP : BlockFace.DOWN);
-    }
-
-    private BlockFace getZFace(Vector direction) {
-        return ((direction.getZ() > 0) ? BlockFace.SOUTH : BlockFace.NORTH);
-    }
-
-    private double getXLength(Vector direction) {
-        return Math.abs(direction.getX());
-    }
-
-    private double getYLength(Vector direction) {
-        return Math.abs(direction.getY());
-    }
-
-    private double getZLength(Vector direction) {
-        return Math.abs(direction.getZ());
-    }
-
-    private double getPosition(double direction, double position, int blockPosition) {
-        return direction > 0 ? (position - blockPosition) : (blockPosition + 1 - position);
-    }
-
-    private double getXPosition(Vector direction, Vector position, Block block) {
-        return getPosition(direction.getX(), position.getX(), block.getX());
-    }
-
-    private double getYPosition(Vector direction, Vector position, Block block) {
-        return getPosition(direction.getY(), position.getY(), block.getY());
-    }
-
-    private double getZPosition(Vector direction, Vector position, Block block) {
-        return getPosition(direction.getZ(), position.getZ(), block.getZ());
-    }
-
-    /**
-     * Constructs the BlockIterator
-     *
-     * @param loc The location for the start of the ray trace
-     * @param yOffset The trace begins vertically offset from the start vector
-     *     by this value
-     * @param maxDistance This is the maximum distance in blocks for the
-     *     trace. Setting this value above 140 may lead to problems with
-     *     unloaded chunks. A value of 0 indicates no limit
-     */
-    public BlockIterator(Location loc, double yOffset, int maxDistance) {
-        this(loc.getWorld(), loc.toVector(), loc.getDirection(), yOffset, maxDistance);
-    }
-
-    /**
-     * Constructs the BlockIterator.
-     *
-     * @param loc The location for the start of the ray trace
-     * @param yOffset The trace begins vertically offset from the start vector
-     *     by this value
-     */
-
-    public BlockIterator(Location loc, double yOffset) {
-        this(loc.getWorld(), loc.toVector(), loc.getDirection(), yOffset, 0);
-    }
-
-    /**
-     * Constructs the BlockIterator.
-     *
-     * @param loc The location for the start of the ray trace
-     */
-
-    public BlockIterator(Location loc) {
-        this(loc, 0D);
-    }
-
-    /**
-     * Constructs the BlockIterator.
-     *
-     * @param entity Information from the entity is used to set up the trace
-     * @param maxDistance This is the maximum distance in blocks for the
-     *     trace. Setting this value above 140 may lead to problems with
-     *     unloaded chunks. A value of 0 indicates no limit
-     */
-
-    public BlockIterator(LivingEntity entity, int maxDistance) {
-        this(entity.getLocation(), entity.getEyeHeight(), maxDistance);
-    }
-
-    /**
-     * Constructs the BlockIterator.
-     *
-     * @param entity Information from the entity is used to set up the trace
-     */
-
-    public BlockIterator(LivingEntity entity) {
-        this(entity, 0);
-    }
-
-    /**
-     * Returns true if the iteration has more elements
-     */
-
-    public boolean hasNext() {
-        scan();
-        return currentBlock != -1;
-    }
-
-    /**
-     * Returns the next Block in the trace
-     *
-     * @return the next Block in the trace
-     */
-
-    public Block next() {
-        scan();
-        if (currentBlock <= -1) {
-            throw new NoSuchElementException();
-        } else {
-            return blockQueue[currentBlock--];
-        }
-    }
-
-    public void remove() {
-        throw new UnsupportedOperationException("[BlockIterator] doesn't support block removal");
-    }
-
-    private void scan() {
-        if (currentBlock >= 0) {
-            return;
-        }
-        if (maxDistance != 0 && currentDistance > maxDistanceInt) {
-            end = true;
-            return;
-        }
-        if (end) {
-            return;
-        }
-
-        currentDistance++;
-
-        secondError += secondStep;
-        thirdError += thirdStep;
-
-        if (secondError > 0 && thirdError > 0) {
-            blockQueue[2] = blockQueue[0].getRelative(mainFace);
-            if (((long) secondStep) * ((long) thirdError) < ((long) thirdStep) * ((long) secondError)) {
-                blockQueue[1] = blockQueue[2].getRelative(secondFace);
-                blockQueue[0] = blockQueue[1].getRelative(thirdFace);
-            } else {
-                blockQueue[1] = blockQueue[2].getRelative(thirdFace);
-                blockQueue[0] = blockQueue[1].getRelative(secondFace);
-            }
-            thirdError -= gridSize;
-            secondError -= gridSize;
-            currentBlock = 2;
-            return;
-        } else if (secondError > 0) {
-            blockQueue[1] = blockQueue[0].getRelative(mainFace);
-            blockQueue[0] = blockQueue[1].getRelative(secondFace);
-            secondError -= gridSize;
-            currentBlock = 1;
-            return;
-        } else if (thirdError > 0) {
-            blockQueue[1] = blockQueue[0].getRelative(mainFace);
-            blockQueue[0] = blockQueue[1].getRelative(thirdFace);
-            thirdError -= gridSize;
-            currentBlock = 1;
-            return;
-        } else {
-            blockQueue[0] = blockQueue[0].getRelative(mainFace);
-            currentBlock = 0;
-            return;
-        }
-    }
-}
diff --git a/src/main/java/org/bukkit/util/BlockVector.java b/src/main/java/org/bukkit/util/BlockVector.java
deleted file mode 100644
index bdf8f6d..0000000
--- a/src/main/java/org/bukkit/util/BlockVector.java
+++ /dev/null
@@ -1,128 +0,0 @@
-package org.bukkit.util;
-
-import java.util.Map;
-import org.bukkit.configuration.serialization.SerializableAs;
-
-/**
- * A vector with a hash function that floors the X, Y, Z components, a la
- * BlockVector in WorldEdit. BlockVectors can be used in hash sets and
- * hash maps. Be aware that BlockVectors are mutable, but it is important
- * that BlockVectors are never changed once put into a hash set or hash map.
- */
-@SerializableAs("BlockVector")
-public class BlockVector extends Vector {
-
-    /**
-     * Construct the vector with all components as 0.
-     */
-    public BlockVector() {
-        this.x = 0;
-        this.y = 0;
-        this.z = 0;
-    }
-
-    /**
-     * Construct the vector with another vector.
-     *
-     * @param vec The other vector.
-     */
-    public BlockVector(Vector vec) {
-        this.x = vec.getX();
-        this.y = vec.getY();
-        this.z = vec.getZ();
-    }
-
-    /**
-     * Construct the vector with provided integer components.
-     *
-     * @param x X component
-     * @param y Y component
-     * @param z Z component
-     */
-    public BlockVector(int x, int y, int z) {
-        this.x = x;
-        this.y = y;
-        this.z = z;
-    }
-
-    /**
-     * Construct the vector with provided double components.
-     *
-     * @param x X component
-     * @param y Y component
-     * @param z Z component
-     */
-    public BlockVector(double x, double y, double z) {
-        this.x = x;
-        this.y = y;
-        this.z = z;
-    }
-
-    /**
-     * Construct the vector with provided float components.
-     *
-     * @param x X component
-     * @param y Y component
-     * @param z Z component
-     */
-    public BlockVector(float x, float y, float z) {
-        this.x = x;
-        this.y = y;
-        this.z = z;
-    }
-
-    /**
-     * Checks if another object is equivalent.
-     *
-     * @param obj The other object
-     * @return whether the other object is equivalent
-     */
-    @Override
-    public boolean equals(Object obj) {
-        if (!(obj instanceof BlockVector)) {
-            return false;
-        }
-        BlockVector other = (BlockVector) obj;
-
-        return (int) other.getX() == (int) this.x && (int) other.getY() == (int) this.y && (int) other.getZ() == (int) this.z;
-
-    }
-
-    /**
-     * Returns a hash code for this vector.
-     *
-     * @return hash code
-     */
-    @Override
-    public int hashCode() {
-        return (Integer.valueOf((int) x).hashCode() >> 13) ^ (Integer.valueOf((int) y).hashCode() >> 7) ^ Integer.valueOf((int) z).hashCode();
-    }
-
-    /**
-     * Get a new block vector.
-     *
-     * @return vector
-     */
-    @Override
-    public BlockVector clone() {
-        return (BlockVector) super.clone();
-    }
-
-    public static BlockVector deserialize(Map<String, Object> args) {
-        double x = 0;
-        double y = 0;
-        double z = 0;
-
-        if (args.containsKey("x")) {
-            x = (Double) args.get("x");
-        }
-        if (args.containsKey("y")) {
-            y = (Double) args.get("y");
-        }
-        if (args.containsKey("z")) {
-            z = (Double) args.get("z");
-        }
-
-        return new BlockVector(x, y, z);
-    }
-}
diff --git a/src/main/java/org/bukkit/util/CachedServerIcon.java b/src/main/java/org/bukkit/util/CachedServerIcon.java
deleted file mode 100644
index 5ca863b..0000000
--- a/src/main/java/org/bukkit/util/CachedServerIcon.java
+++ /dev/null
@@ -1,15 +0,0 @@
-package org.bukkit.util;
-
-import org.bukkit.Server;
-import org.bukkit.event.server.ServerListPingEvent;
-
-/**
- * This is a cached version of a server-icon. It's internal representation
- * and implementation is undefined.
- *
- * @see Server#getServerIcon()
- * @see Server#loadServerIcon(java.awt.image.BufferedImage)
- * @see Server#loadServerIcon(java.io.File)
- * @see ServerListPingEvent#setServerIcon(CachedServerIcon)
- */
-public interface CachedServerIcon {}
diff --git a/src/main/java/org/bukkit/util/ChatPaginator.java b/src/main/java/org/bukkit/util/ChatPaginator.java
deleted file mode 100644
index 24802d1..0000000
--- a/src/main/java/org/bukkit/util/ChatPaginator.java
+++ /dev/null
@@ -1,169 +0,0 @@
-package org.bukkit.util;
-
-import org.bukkit.ChatColor;
-
-import java.util.LinkedList;
-import java.util.List;
-
-/**
- * The ChatPaginator takes a raw string of arbitrary length and breaks it down
- * into an array of strings appropriate for displaying on the Minecraft player
- * console.
- */
-public class ChatPaginator {
-    public static final int GUARANTEED_NO_WRAP_CHAT_PAGE_WIDTH = 55; // Will never wrap, even with the largest characters
-    public static final int AVERAGE_CHAT_PAGE_WIDTH = 65; // Will typically not wrap using an average character distribution
-    public static final int UNBOUNDED_PAGE_WIDTH = Integer.MAX_VALUE;
-    public static final int OPEN_CHAT_PAGE_HEIGHT = 20; // The height of an expanded chat window
-    public static final int CLOSED_CHAT_PAGE_HEIGHT = 10; // The height of the default chat window
-    public static final int UNBOUNDED_PAGE_HEIGHT = Integer.MAX_VALUE;
-
-    /**
-     * Breaks a raw string up into pages using the default width and height.
-     *
-     * @param unpaginatedString The raw string to break.
-     * @param pageNumber The page number to fetch.
-     * @return A single chat page.
-     */
-    public static ChatPage paginate(String unpaginatedString, int pageNumber) {
-        return  paginate(unpaginatedString, pageNumber, GUARANTEED_NO_WRAP_CHAT_PAGE_WIDTH, CLOSED_CHAT_PAGE_HEIGHT);
-    }
-
-    /**
-     * Breaks a raw string up into pages using a provided width and height.
-     *
-     * @param unpaginatedString The raw string to break.
-     * @param pageNumber The page number to fetch.
-     * @param lineLength The desired width of a chat line.
-     * @param pageHeight The desired number of lines in a page.
-     * @return A single chat page.
-     */
-    public static ChatPage paginate(String unpaginatedString, int pageNumber, int lineLength, int pageHeight) {
-        String[] lines = wordWrap(unpaginatedString, lineLength);
-
-        int totalPages = lines.length / pageHeight + (lines.length % pageHeight == 0 ? 0 : 1);
-        int actualPageNumber = pageNumber <= totalPages ? pageNumber : totalPages;
-
-        int from = (actualPageNumber - 1) * pageHeight;
-        int to = from + pageHeight <= lines.length  ? from + pageHeight : lines.length;
-        String[] selectedLines = Java15Compat.Arrays_copyOfRange(lines, from, to);
-
-        return new ChatPage(selectedLines, actualPageNumber, totalPages);
-    }
-
-    /**
-     * Breaks a raw string up into a series of lines. Words are wrapped using
-     * spaces as decimeters and the newline character is respected.
-     *
-     * @param rawString The raw string to break.
-     * @param lineLength The length of a line of text.
-     * @return An array of word-wrapped lines.
-     */
-    public static String[] wordWrap(String rawString, int lineLength) {
-        // A null string is a single line
-        if (rawString == null) {
-            return new String[] {""};
-        }
-
-        // A string shorter than the lineWidth is a single line
-        if (rawString.length() <= lineLength && !rawString.contains("\n")) {
-            return new String[] {rawString};
-        }
-
-        char[] rawChars = (rawString + ' ').toCharArray(); // add a trailing space to trigger pagination
-        StringBuilder word = new StringBuilder();
-        StringBuilder line = new StringBuilder();
-        List<String> lines = new LinkedList<String>();
-        int lineColorChars = 0;
-
-        for (int i = 0; i < rawChars.length; i++) {
-            char c = rawChars[i];
-
-            // skip chat color modifiers
-            if (c == ChatColor.COLOR_CHAR) {
-                word.append(ChatColor.getByChar(rawChars[i + 1]));
-                lineColorChars += 2;
-                i++; // Eat the next character as we have already processed it
-                continue;
-            }
-
-            if (c == ' ' || c == '\n') {
-                if (line.length() == 0 && word.length() > lineLength) { // special case: extremely long word begins a line
-                    for (String partialWord : word.toString().split("(?<=\\G.{" + lineLength + "})")) {
-                        lines.add(partialWord);
-                    }
-                } else if (line.length() + word.length() - lineColorChars == lineLength) { // Line exactly the correct length...newline
-                    line.append(word);
-                    lines.add(line.toString());
-                    line = new StringBuilder();
-                    lineColorChars = 0;
-                } else if (line.length() + 1 + word.length() - lineColorChars > lineLength) { // Line too long...break the line
-                    for (String partialWord : word.toString().split("(?<=\\G.{" + lineLength + "})")) {
-                        lines.add(line.toString());
-                        line = new StringBuilder(partialWord);
-                    }
-                    lineColorChars = 0;
-                } else {
-                    if (line.length() > 0) {
-                        line.append(' ');
-                    }
-                    line.append(word);
-                }
-                word = new StringBuilder();
-
-                if (c == '\n') { // Newline forces the line to flush
-                    lines.add(line.toString());
-                    line = new StringBuilder();
-                }
-            } else {
-                word.append(c);
-            }
-        }
-
-        if(line.length() > 0) { // Only add the last line if there is anything to add
-            lines.add(line.toString());
-        }
-
-        // Iterate over the wrapped lines, applying the last color from one line to the beginning of the next
-        if (lines.get(0).length() == 0 || lines.get(0).charAt(0) != ChatColor.COLOR_CHAR) {
-            lines.set(0, ChatColor.WHITE + lines.get(0));
-        }
-        for (int i = 1; i < lines.size(); i++) {
-            final String pLine = lines.get(i-1);
-            final String subLine = lines.get(i);
-
-            char color = pLine.charAt(pLine.lastIndexOf(ChatColor.COLOR_CHAR) + 1);
-            if (subLine.length() == 0 || subLine.charAt(0) != ChatColor.COLOR_CHAR) {
-                lines.set(i, ChatColor.getByChar(color) + subLine);
-            }
-        }
-
-        return lines.toArray(new String[lines.size()]);
-    }
-
-    public static class ChatPage {
-
-        private String[] lines;
-        private int pageNumber;
-        private int totalPages;
-
-        public ChatPage(String[] lines, int pageNumber, int totalPages) {
-            this.lines = lines;
-            this.pageNumber = pageNumber;
-            this.totalPages = totalPages;
-        }
-
-        public int getPageNumber() {
-            return pageNumber;
-        }
-
-        public int getTotalPages() {
-            return totalPages;
-        }
-
-        public String[] getLines() {
-
-            return lines;
-        }
-    }
-}
diff --git a/src/main/java/org/bukkit/util/EulerAngle.java b/src/main/java/org/bukkit/util/EulerAngle.java
deleted file mode 100644
index f5c2773..0000000
--- a/src/main/java/org/bukkit/util/EulerAngle.java
+++ /dev/null
@@ -1,147 +0,0 @@
-package org.bukkit.util;
-
-/**
- * EulerAngle is used to represent 3 angles, one for each
- * axis (x, y, z). The angles are in radians
- */
-public class EulerAngle {
-
-    /**
-     * A EulerAngle with every axis set to 0
-     */
-    public static final EulerAngle ZERO = new EulerAngle(0, 0, 0);
-
-    private final double x;
-    private final double y;
-    private final double z;
-
-    /**
-     * Creates a EularAngle with each axis set to the
-     * passed angle in radians
-     *
-     * @param x the angle for the x axis in radians
-     * @param y the angle for the y axis in radians
-     * @param z the angle for the z axis in radians
-     */
-    public EulerAngle(double x, double y, double z) {
-        this.x = x;
-        this.y = y;
-        this.z = z;
-    }
-
-    /**
-     * Returns the angle on the x axis in radians
-     *
-     * @return the angle in radians
-     */
-    public double getX() {
-        return x;
-    }
-
-    /**
-     * Returns the angle on the y axis in radians
-     *
-     * @return the angle in radians
-     */
-    public double getY() {
-        return y;
-    }
-
-    /**
-     * Returns the angle on the z axis in radians
-     *
-     * @return the angle in radians
-     */
-    public double getZ() {
-        return z;
-    }
-
-    /**
-     * Return a EulerAngle which is the result of changing
-     * the x axis to the passed angle
-     *
-     * @param x the angle in radians
-     * @return the resultant EulerAngle
-     */
-    public EulerAngle setX(double x) {
-        return new EulerAngle(x, y, z);
-    }
-
-    /**
-     * Return a EulerAngle which is the result of changing
-     * the y axis to the passed angle
-     *
-     * @param y the angle in radians
-     * @return the resultant EulerAngle
-     */
-    public EulerAngle setY(double y) {
-        return new EulerAngle(x, y, z);
-    }
-
-    /**
-     * Return a EulerAngle which is the result of changing
-     * the z axis to the passed angle
-     *
-     * @param z the angle in radians
-     * @return the resultant EulerAngle
-     */
-    public EulerAngle setZ(double z) {
-        return new EulerAngle(x, y, z);
-    }
-
-    /**
-     * Creates a new EulerAngle which is the result of adding
-     * the x, y, z components to this EulerAngle
-     *
-     * @param x the angle to add to the x axis in radians
-     * @param y the angle to add to the y axis in radians
-     * @param z the angle to add to the z axis in radians
-     * @return the resultant EulerAngle
-     */
-    public EulerAngle add(double x, double y, double z) {
-        return new EulerAngle(
-                this.x + x,
-                this.y + y,
-                this.z + z
-        );
-    }
-
-    /**
-     * Creates a new EulerAngle which is the result of subtracting
-     * the x, y, z components to this EulerAngle
-     *
-     * @param x the angle to subtract to the x axis in radians
-     * @param y the angle to subtract to the y axis in radians
-     * @param z the angle to subtract to the z axis in radians
-     * @return the resultant EulerAngle
-     */
-    public EulerAngle subtract(double x, double y, double z) {
-        return add(-x, -y, -z);
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        if (this == o) return true;
-        if (o == null || getClass() != o.getClass()) return false;
-
-        EulerAngle that = (EulerAngle) o;
-
-        return Double.compare(that.x, x) == 0
-                && Double.compare(that.y, y) == 0
-                && Double.compare(that.z, z) == 0;
-
-    }
-
-    @Override
-    public int hashCode() {
-        int result;
-        long temp;
-        temp = Double.doubleToLongBits(x);
-        result = (int) (temp ^ (temp >>> 32));
-        temp = Double.doubleToLongBits(y);
-        result = 31 * result + (int) (temp ^ (temp >>> 32));
-        temp = Double.doubleToLongBits(z);
-        result = 31 * result + (int) (temp ^ (temp >>> 32));
-        return result;
-    }
-}
diff --git a/src/main/java/org/bukkit/util/FileUtil.java b/src/main/java/org/bukkit/util/FileUtil.java
deleted file mode 100644
index 7cabf4c..0000000
--- a/src/main/java/org/bukkit/util/FileUtil.java
+++ /dev/null
@@ -1,57 +0,0 @@
-package org.bukkit.util;
-
-import java.nio.channels.FileChannel;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
-import java.io.IOException;
-
-/**
- * Class containing file utilities
- */
-public class FileUtil {
-
-    /**
-     * This method copies one file to another location
-     *
-     * @param inFile the source filename
-     * @param outFile the target filename
-     * @return true on success
-     */
-    public static boolean copy(File inFile, File outFile) {
-        if (!inFile.exists()) {
-            return false;
-        }
-
-        FileChannel in = null;
-        FileChannel out = null;
-
-        try {
-            in = new FileInputStream(inFile).getChannel();
-            out = new FileOutputStream(outFile).getChannel();
-
-            long pos = 0;
-            long size = in.size();
-
-            while (pos < size) {
-                pos += in.transferTo(pos, 10 * 1024 * 1024, out);
-            }
-        } catch (IOException ioe) {
-            return false;
-        } finally {
-            try {
-                if (in != null) {
-                    in.close();
-                }
-                if (out != null) {
-                    out.close();
-                }
-            } catch (IOException ioe) {
-                return false;
-            }
-        }
-
-        return true;
-
-    }
-}
diff --git a/src/main/java/org/bukkit/util/Java15Compat.java b/src/main/java/org/bukkit/util/Java15Compat.java
deleted file mode 100644
index c119742..0000000
--- a/src/main/java/org/bukkit/util/Java15Compat.java
+++ /dev/null
@@ -1,21 +0,0 @@
-package org.bukkit.util;
-
-import java.lang.reflect.Array;
-
-public class Java15Compat {
-    @SuppressWarnings("unchecked")
-    public static <T> T[] Arrays_copyOfRange(T[] original, int start, int end) {
-        if (original.length >= start && 0 <= start) {
-            if (start <= end) {
-                int length = end - start;
-                int copyLength = Math.min(length, original.length - start);
-                T[] copy = (T[]) Array.newInstance(original.getClass().getComponentType(), length);
-
-                System.arraycopy(original, start, copy, 0, copyLength);
-                return copy;
-            }
-            throw new IllegalArgumentException();
-        }
-        throw new ArrayIndexOutOfBoundsException();
-    }
-}
diff --git a/src/main/java/org/bukkit/util/NumberConversions.java b/src/main/java/org/bukkit/util/NumberConversions.java
deleted file mode 100644
index e6af9ec..0000000
--- a/src/main/java/org/bukkit/util/NumberConversions.java
+++ /dev/null
@@ -1,124 +0,0 @@
-package org.bukkit.util;
-
-/**
- * Utils for casting number types to other number types
- */
-public final class NumberConversions {
-    private NumberConversions() {}
-
-    public static int floor(double num) {
-        final int floor = (int) num;
-        return floor == num ? floor : floor - (int) (Double.doubleToRawLongBits(num) >>> 63);
-    }
-
-    public static int ceil(final double num) {
-        final int floor = (int) num;
-        return floor == num ? floor : floor + (int) (~Double.doubleToRawLongBits(num) >>> 63);
-    }
-
-    public static int round(double num) {
-        return floor(num + 0.5d);
-    }
-
-    public static double square(double num) {
-        return num * num;
-    }
-
-    public static int toInt(Object object) {
-        if (object instanceof Number) {
-            return ((Number) object).intValue();
-        }
-
-        try {
-            return Integer.valueOf(object.toString());
-        } catch (NumberFormatException e) {
-        } catch (NullPointerException e) {
-        }
-        return 0;
-    }
-
-    public static float toFloat(Object object) {
-        if (object instanceof Number) {
-            return ((Number) object).floatValue();
-        }
-
-        try {
-            return Float.valueOf(object.toString());
-        } catch (NumberFormatException e) {
-        } catch (NullPointerException e) {
-        }
-        return 0;
-    }
-
-    public static double toDouble(Object object) {
-        if (object instanceof Number) {
-            return ((Number) object).doubleValue();
-        }
-
-        try {
-            return Double.valueOf(object.toString());
-        } catch (NumberFormatException e) {
-        } catch (NullPointerException e) {
-        }
-        return 0;
-    }
-
-    public static long toLong(Object object) {
-        if (object instanceof Number) {
-            return ((Number) object).longValue();
-        }
-
-        try {
-            return Long.valueOf(object.toString());
-        } catch (NumberFormatException e) {
-        } catch (NullPointerException e) {
-        }
-        return 0;
-    }
-
-    public static short toShort(Object object) {
-        if (object instanceof Number) {
-            return ((Number) object).shortValue();
-        }
-
-        try {
-            return Short.valueOf(object.toString());
-        } catch (NumberFormatException e) {
-        } catch (NullPointerException e) {
-        }
-        return 0;
-    }
-
-    public static byte toByte(Object object) {
-        if (object instanceof Number) {
-            return ((Number) object).byteValue();
-        }
-
-        try {
-            return Byte.valueOf(object.toString());
-        } catch (NumberFormatException e) {
-        } catch (NullPointerException e) {
-        }
-        return 0;
-    }
-
-    public static boolean isFinite(double d) {
-        return Math.abs(d) <= Double.MAX_VALUE;
-    }
-
-    public static boolean isFinite(float f) {
-        return Math.abs(f) <= Float.MAX_VALUE;
-    }
-
-    public static void checkFinite(double d, String message) {
-        if (!isFinite(d)) {
-            throw new IllegalArgumentException(message);
-        }
-    }
-
-    public static void checkFinite(float d, String message) {
-        if (!isFinite(d)) {
-            throw new IllegalArgumentException(message);
-        }
-    }
-}
diff --git a/src/main/java/org/bukkit/util/StringUtil.java b/src/main/java/org/bukkit/util/StringUtil.java
deleted file mode 100644
index 7e79393..0000000
--- a/src/main/java/org/bukkit/util/StringUtil.java
+++ /dev/null
@@ -1,58 +0,0 @@
-package org.bukkit.util;
-
-import java.util.Collection;
-import org.apache.commons.lang.Validate;
-
-public class StringUtil {
-
-    /**
-     * Copies all elements from the iterable collection of originals to the
-     * collection provided.
-     *
-     * @param <T> the collection of strings
-     * @param token String to search for
-     * @param originals An iterable collection of strings to filter.
-     * @param collection The collection to add matches to
-     * @return the collection provided that would have the elements copied
-     *     into
-     * @throws UnsupportedOperationException if the collection is immutable
-     *     and originals contains a string which starts with the specified
-     *     search string.
-     * @throws IllegalArgumentException if any parameter is is null
-     * @throws IllegalArgumentException if originals contains a null element.
-     *     <b>Note: the collection may be modified before this is thrown</b>
-     */
-    public static <T extends Collection<? super String>> T copyPartialMatches(final String token, final Iterable<String> originals, final T collection) throws UnsupportedOperationException, IllegalArgumentException {
-        Validate.notNull(token, "Search token cannot be null");
-        Validate.notNull(collection, "Collection cannot be null");
-        Validate.notNull(originals, "Originals cannot be null");
-
-        for (String string : originals) {
-            if (startsWithIgnoreCase(string, token)) {
-                collection.add(string);
-            }
-        }
-
-        return collection;
-    }
-
-    /**
-     * This method uses a region to check case-insensitive equality. This
-     * means the internal array does not need to be copied like a
-     * toLowerCase() call would.
-     *
-     * @param string String to check
-     * @param prefix Prefix of string to compare
-     * @return true if provided string starts with, ignoring case, the prefix
-     *     provided
-     * @throws NullPointerException if prefix is null
-     * @throws IllegalArgumentException if string is null
-     */
-    public static boolean startsWithIgnoreCase(final String string, final String prefix) throws IllegalArgumentException, NullPointerException {
-        Validate.notNull(string, "Cannot check a null string for a match");
-        if (string.length() < prefix.length()) {
-            return false;
-        }
-        return string.regionMatches(true, 0, prefix, 0, prefix.length());
-    }
-}
diff --git a/src/main/java/org/bukkit/util/Vector.java b/src/main/java/org/bukkit/util/Vector.java
deleted file mode 100644
index cebd3cc..0000000
--- a/src/main/java/org/bukkit/util/Vector.java
+++ /dev/null
@@ -1,687 +0,0 @@
-package org.bukkit.util;
-
-import java.util.LinkedHashMap;
-import java.util.Map;
-import java.util.Random;
-import org.bukkit.Location;
-import org.bukkit.World;
-import org.bukkit.configuration.serialization.ConfigurationSerializable;
-import org.bukkit.configuration.serialization.SerializableAs;
-import static org.bukkit.util.NumberConversions.checkFinite;
-
-/**
- * Represents a mutable vector. Because the components of Vectors are mutable,
- * storing Vectors long term may be dangerous if passing code modifies the
- * Vector later. If you want to keep around a Vector, it may be wise to call
- * <code>clone()</code> in order to get a copy.
- */
-@SerializableAs("Vector")
-public class Vector implements Cloneable, ConfigurationSerializable {
-    private static final long serialVersionUID = -2657651106777219169L;
-
-    private static Random random = new Random();
-
-    /**
-     * Threshold for fuzzy equals().
-     */
-    private static final double epsilon = 0.000001;
-
-    protected double x;
-    protected double y;
-    protected double z;
-
-    /**
-     * Construct the vector with all components as 0.
-     */
-    public Vector() {
-        this.x = 0;
-        this.y = 0;
-        this.z = 0;
-    }
-
-    /**
-     * Construct the vector with provided integer components.
-     *
-     * @param x X component
-     * @param y Y component
-     * @param z Z component
-     */
-    public Vector(int x, int y, int z) {
-        this.x = x;
-        this.y = y;
-        this.z = z;
-    }
-
-    /**
-     * Construct the vector with provided double components.
-     *
-     * @param x X component
-     * @param y Y component
-     * @param z Z component
-     */
-    public Vector(double x, double y, double z) {
-        this.x = x;
-        this.y = y;
-        this.z = z;
-    }
-
-    /**
-     * Construct the vector with provided float components.
-     *
-     * @param x X component
-     * @param y Y component
-     * @param z Z component
-     */
-    public Vector(float x, float y, float z) {
-        this.x = x;
-        this.y = y;
-        this.z = z;
-    }
-
-    /**
-     * Adds a vector to this one
-     *
-     * @param vec The other vector
-     * @return the same vector
-     */
-    public Vector add(Vector vec) {
-        x += vec.x;
-        y += vec.y;
-        z += vec.z;
-        return this;
-    }
-
-    /**
-     * Subtracts a vector from this one.
-     *
-     * @param vec The other vector
-     * @return the same vector
-     */
-    public Vector subtract(Vector vec) {
-        x -= vec.x;
-        y -= vec.y;
-        z -= vec.z;
-        return this;
-    }
-
-    /**
-     * Multiplies the vector by another.
-     *
-     * @param vec The other vector
-     * @return the same vector
-     */
-    public Vector multiply(Vector vec) {
-        x *= vec.x;
-        y *= vec.y;
-        z *= vec.z;
-        return this;
-    }
-
-    /**
-     * Divides the vector by another.
-     *
-     * @param vec The other vector
-     * @return the same vector
-     */
-    public Vector divide(Vector vec) {
-        x /= vec.x;
-        y /= vec.y;
-        z /= vec.z;
-        return this;
-    }
-
-    /**
-     * Copies another vector
-     *
-     * @param vec The other vector
-     * @return the same vector
-     */
-    public Vector copy(Vector vec) {
-        x = vec.x;
-        y = vec.y;
-        z = vec.z;
-        return this;
-    }
-
-    /**
-     * Gets the magnitude of the vector, defined as sqrt(x^2+y^2+z^2). The
-     * value of this method is not cached and uses a costly square-root
-     * function, so do not repeatedly call this method to get the vector's
-     * magnitude. NaN will be returned if the inner result of the sqrt()
-     * function overflows, which will be caused if the length is too long.
-     *
-     * @return the magnitude
-     */
-    public double length() {
-        return Math.sqrt(NumberConversions.square(x) + NumberConversions.square(y) + NumberConversions.square(z));
-    }
-
-    /**
-     * Gets the magnitude of the vector squared.
-     *
-     * @return the magnitude
-     */
-    public double lengthSquared() {
-        return NumberConversions.square(x) + NumberConversions.square(y) + NumberConversions.square(z);
-    }
-
-    /**
-     * Get the distance between this vector and another. The value of this
-     * method is not cached and uses a costly square-root function, so do not
-     * repeatedly call this method to get the vector's magnitude. NaN will be
-     * returned if the inner result of the sqrt() function overflows, which
-     * will be caused if the distance is too long.
-     *
-     * @param o The other vector
-     * @return the distance
-     */
-    public double distance(Vector o) {
-        return Math.sqrt(NumberConversions.square(x - o.x) + NumberConversions.square(y - o.y) + NumberConversions.square(z - o.z));
-    }
-
-    /**
-     * Get the squared distance between this vector and another.
-     *
-     * @param o The other vector
-     * @return the distance
-     */
-    public double distanceSquared(Vector o) {
-        return NumberConversions.square(x - o.x) + NumberConversions.square(y - o.y) + NumberConversions.square(z - o.z);
-    }
-
-    /**
-     * Gets the angle between this vector and another in radians.
-     *
-     * @param other The other vector
-     * @return angle in radians
-     */
-    public float angle(Vector other) {
-        double dot = dot(other) / (length() * other.length());
-
-        return (float) Math.acos(dot);
-    }
-
-    /**
-     * Sets this vector to the midpoint between this vector and another.
-     *
-     * @param other The other vector
-     * @return this same vector (now a midpoint)
-     */
-    public Vector midpoint(Vector other) {
-        x = (x + other.x) / 2;
-        y = (y + other.y) / 2;
-        z = (z + other.z) / 2;
-        return this;
-    }
-
-    /**
-     * Gets a new midpoint vector between this vector and another.
-     *
-     * @param other The other vector
-     * @return a new midpoint vector
-     */
-    public Vector getMidpoint(Vector other) {
-        double x = (this.x + other.x) / 2;
-        double y = (this.y + other.y) / 2;
-        double z = (this.z + other.z) / 2;
-        return new Vector(x, y, z);
-    }
-
-    /**
-     * Performs scalar multiplication, multiplying all components with a
-     * scalar.
-     *
-     * @param m The factor
-     * @return the same vector
-     */
-    public Vector multiply(int m) {
-        x *= m;
-        y *= m;
-        z *= m;
-        return this;
-    }
-
-    /**
-     * Performs scalar multiplication, multiplying all components with a
-     * scalar.
-     *
-     * @param m The factor
-     * @return the same vector
-     */
-    public Vector multiply(double m) {
-        x *= m;
-        y *= m;
-        z *= m;
-        return this;
-    }
-
-    /**
-     * Performs scalar multiplication, multiplying all components with a
-     * scalar.
-     *
-     * @param m The factor
-     * @return the same vector
-     */
-    public Vector multiply(float m) {
-        x *= m;
-        y *= m;
-        z *= m;
-        return this;
-    }
-
-    /**
-     * Calculates the dot product of this vector with another. The dot product
-     * is defined as x1*x2+y1*y2+z1*z2. The returned value is a scalar.
-     *
-     * @param other The other vector
-     * @return dot product
-     */
-    public double dot(Vector other) {
-        return x * other.x + y * other.y + z * other.z;
-    }
-
-    /**
-     * Calculates the cross product of this vector with another. The cross
-     * product is defined as:
-     * <ul>
-     * <li>x = y1 * z2 - y2 * z1
-     * <li>y = z1 * x2 - z2 * x1
-     * <li>z = x1 * y2 - x2 * y1
-     * </ul>
-     *
-     * @param o The other vector
-     * @return the same vector
-     */
-    public Vector crossProduct(Vector o) {
-        double newX = y * o.z - o.y * z;
-        double newY = z * o.x - o.z * x;
-        double newZ = x * o.y - o.x * y;
-
-        x = newX;
-        y = newY;
-        z = newZ;
-        return this;
-    }
-
-    /**
-     * Calculates the cross product of this vector with another without mutating
-     * the original. The cross product is defined as:
-     * <ul>
-     * <li>x = y1 * z2 - y2 * z1
-     * <li>y = z1 * x2 - z2 * x1
-     * <li>z = x1 * y2 - x2 * y1
-     * </ul>
-     *
-     * @param o The other vector
-     * @return a new vector
-     */
-    public Vector getCrossProduct(Vector o) {
-        double x = this.y * o.z - o.y * this.z;
-        double y = this.z * o.x - o.z * this.x;
-        double z = this.x * o.y - o.x * this.y;
-        return new Vector(x, y, z);
-    }
-
-    /**
-     * Converts this vector to a unit vector (a vector with length of 1).
-     *
-     * @return the same vector
-     */
-    public Vector normalize() {
-        double length = length();
-
-        x /= length;
-        y /= length;
-        z /= length;
-
-        return this;
-    }
-
-    /**
-     * Zero this vector's components.
-     *
-     * @return the same vector
-     */
-    public Vector zero() {
-        x = 0;
-        y = 0;
-        z = 0;
-        return this;
-    }
-
-    /**
-     * Returns whether this vector is in an axis-aligned bounding box.
-     * <p>
-     * The minimum and maximum vectors given must be truly the minimum and
-     * maximum X, Y and Z components.
-     *
-     * @param min Minimum vector
-     * @param max Maximum vector
-     * @return whether this vector is in the AABB
-     */
-    public boolean isInAABB(Vector min, Vector max) {
-        return x >= min.x && x <= max.x && y >= min.y && y <= max.y && z >= min.z && z <= max.z;
-    }
-
-    /**
-     * Returns whether this vector is within a sphere.
-     *
-     * @param origin Sphere origin.
-     * @param radius Sphere radius
-     * @return whether this vector is in the sphere
-     */
-    public boolean isInSphere(Vector origin, double radius) {
-        return (NumberConversions.square(origin.x - x) + NumberConversions.square(origin.y - y) + NumberConversions.square(origin.z - z)) <= NumberConversions.square(radius);
-    }
-
-    /**
-     * Gets the X component.
-     *
-     * @return The X component.
-     */
-    public double getX() {
-        return x;
-    }
-
-    /**
-     * Gets the floored value of the X component, indicating the block that
-     * this vector is contained with.
-     *
-     * @return block X
-     */
-    public int getBlockX() {
-        return NumberConversions.floor(x);
-    }
-
-    /**
-     * Gets the Y component.
-     *
-     * @return The Y component.
-     */
-    public double getY() {
-        return y;
-    }
-
-    /**
-     * Gets the floored value of the Y component, indicating the block that
-     * this vector is contained with.
-     *
-     * @return block y
-     */
-    public int getBlockY() {
-        return NumberConversions.floor(y);
-    }
-
-    /**
-     * Gets the Z component.
-     *
-     * @return The Z component.
-     */
-    public double getZ() {
-        return z;
-    }
-
-    /**
-     * Gets the floored value of the Z component, indicating the block that
-     * this vector is contained with.
-     *
-     * @return block z
-     */
-    public int getBlockZ() {
-        return NumberConversions.floor(z);
-    }
-
-    /**
-     * Set the X component.
-     *
-     * @param x The new X component.
-     * @return This vector.
-     */
-    public Vector setX(int x) {
-        this.x = x;
-        return this;
-    }
-
-    /**
-     * Set the X component.
-     *
-     * @param x The new X component.
-     * @return This vector.
-     */
-    public Vector setX(double x) {
-        this.x = x;
-        return this;
-    }
-
-    /**
-     * Set the X component.
-     *
-     * @param x The new X component.
-     * @return This vector.
-     */
-    public Vector setX(float x) {
-        this.x = x;
-        return this;
-    }
-
-    /**
-     * Set the Y component.
-     *
-     * @param y The new Y component.
-     * @return This vector.
-     */
-    public Vector setY(int y) {
-        this.y = y;
-        return this;
-    }
-
-    /**
-     * Set the Y component.
-     *
-     * @param y The new Y component.
-     * @return This vector.
-     */
-    public Vector setY(double y) {
-        this.y = y;
-        return this;
-    }
-
-    /**
-     * Set the Y component.
-     *
-     * @param y The new Y component.
-     * @return This vector.
-     */
-    public Vector setY(float y) {
-        this.y = y;
-        return this;
-    }
-
-    /**
-     * Set the Z component.
-     *
-     * @param z The new Z component.
-     * @return This vector.
-     */
-    public Vector setZ(int z) {
-        this.z = z;
-        return this;
-    }
-
-    /**
-     * Set the Z component.
-     *
-     * @param z The new Z component.
-     * @return This vector.
-     */
-    public Vector setZ(double z) {
-        this.z = z;
-        return this;
-    }
-
-    /**
-     * Set the Z component.
-     *
-     * @param z The new Z component.
-     * @return This vector.
-     */
-    public Vector setZ(float z) {
-        this.z = z;
-        return this;
-    }
-
-    /**
-     * Checks to see if two objects are equal.
-     * <p>
-     * Only two Vectors can ever return true. This method uses a fuzzy match
-     * to account for floating point errors. The epsilon can be retrieved
-     * with epsilon.
-     */
-    @Override
-    public boolean equals(Object obj) {
-        if (!(obj instanceof Vector)) {
-            return false;
-        }
-
-        Vector other = (Vector) obj;
-
-        return Math.abs(x - other.x) < epsilon && Math.abs(y - other.y) < epsilon && Math.abs(z - other.z) < epsilon && (this.getClass().equals(obj.getClass()));
-    }
-
-    /**
-     * Returns a hash code for this vector
-     *
-     * @return hash code
-     */
-    @Override
-    public int hashCode() {
-        int hash = 7;
-
-        hash = 79 * hash + (int) (Double.doubleToLongBits(this.x) ^ (Double.doubleToLongBits(this.x) >>> 32));
-        hash = 79 * hash + (int) (Double.doubleToLongBits(this.y) ^ (Double.doubleToLongBits(this.y) >>> 32));
-        hash = 79 * hash + (int) (Double.doubleToLongBits(this.z) ^ (Double.doubleToLongBits(this.z) >>> 32));
-        return hash;
-    }
-
-    /**
-     * Get a new vector.
-     *
-     * @return vector
-     */
-    @Override
-    public Vector clone() {
-        try {
-            return (Vector) super.clone();
-        } catch (CloneNotSupportedException e) {
-            throw new Error(e);
-        }
-    }
-
-    /**
-     * Returns this vector's components as x,y,z.
-     */
-    @Override
-    public String toString() {
-        return x + "," + y + "," + z;
-    }
-
-    /**
-     * Gets a Location version of this vector with yaw and pitch being 0.
-     *
-     * @param world The world to link the location to.
-     * @return the location
-     */
-    public Location toLocation(World world) {
-        return new Location(world, x, y, z);
-    }
-
-    /**
-     * Gets a Location version of this vector.
-     *
-     * @param world The world to link the location to.
-     * @param yaw The desired yaw.
-     * @param pitch The desired pitch.
-     * @return the location
-     */
-    public Location toLocation(World world, float yaw, float pitch) {
-        return new Location(world, x, y, z, yaw, pitch);
-    }
-
-    /**
-     * Get the block vector of this vector.
-     *
-     * @return A block vector.
-     */
-    public BlockVector toBlockVector() {
-        return new BlockVector(x, y, z);
-    }
-
-    /**
-     * Get the threshold used for equals().
-     *
-     * @return The epsilon.
-     */
-    public static double getEpsilon() {
-        return epsilon;
-    }
-
-    /**
-     * Gets the minimum components of two vectors.
-     *
-     * @param v1 The first vector.
-     * @param v2 The second vector.
-     * @return minimum
-     */
-    public static Vector getMinimum(Vector v1, Vector v2) {
-        return new Vector(Math.min(v1.x, v2.x), Math.min(v1.y, v2.y), Math.min(v1.z, v2.z));
-    }
-
-    /**
-     * Gets the maximum components of two vectors.
-     *
-     * @param v1 The first vector.
-     * @param v2 The second vector.
-     * @return maximum
-     */
-    public static Vector getMaximum(Vector v1, Vector v2) {
-        return new Vector(Math.max(v1.x, v2.x), Math.max(v1.y, v2.y), Math.max(v1.z, v2.z));
-    }
-
-    /**
-     * Gets a random vector with components having a random value between 0
-     * and 1.
-     *
-     * @return A random vector.
-     */
-    public static Vector getRandom() {
-        return new Vector(random.nextDouble(), random.nextDouble(), random.nextDouble());
-    }
-
-    public Map<String, Object> serialize() {
-        Map<String, Object> result = new LinkedHashMap<String, Object>();
-
-        result.put("x", getX());
-        result.put("y", getY());
-        result.put("z", getZ());
-
-        return result;
-    }
-
-    public static Vector deserialize(Map<String, Object> args) {
-        double x = 0;
-        double y = 0;
-        double z = 0;
-
-        if (args.containsKey("x")) {
-            x = (Double) args.get("x");
-        }
-        if (args.containsKey("y")) {
-            y = (Double) args.get("y");
-        }
-        if (args.containsKey("z")) {
-            z = (Double) args.get("z");
-        }
-
-        return new Vector(x, y, z);
-    }
-}
diff --git a/src/main/java/org/bukkit/util/io/BukkitObjectInputStream.java b/src/main/java/org/bukkit/util/io/BukkitObjectInputStream.java
deleted file mode 100644
index 1372553..0000000
--- a/src/main/java/org/bukkit/util/io/BukkitObjectInputStream.java
+++ /dev/null
@@ -1,62 +0,0 @@
-package org.bukkit.util.io;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.ObjectInputStream;
-
-import org.bukkit.configuration.serialization.ConfigurationSerializable;
-import org.bukkit.configuration.serialization.ConfigurationSerialization;
-
-/**
- * This class is designed to be used in conjunction with the {@link
- * ConfigurationSerializable} API. It translates objects back to their
- * original implementation after being serialized by {@link
- * BukkitObjectInputStream}.
- * <p>
- * Behavior of implementations extending this class is not guaranteed across
- * future versions.
- */
-public class BukkitObjectInputStream extends ObjectInputStream {
-
-    /**
-     * Constructor provided to mirror super functionality.
-     *
-     * @throws IOException if an I/O error occurs while reading stream heade
-     * @see ObjectInputStream#ObjectInputStream()
-     */
-    protected BukkitObjectInputStream() throws IOException, SecurityException {
-        super();
-        super.enableResolveObject(true);
-    }
-
-    /**
-     * Object input stream decoration constructor.
-     *
-     * @param in the input stream to wrap
-     * @throws IOException if an I/O error occurs while reading stream header
-     * @see ObjectInputStream#ObjectInputStream(InputStream)
-     */
-    public BukkitObjectInputStream(InputStream in) throws IOException {
-        super(in);
-        super.enableResolveObject(true);
-    }
-
-    @Override
-    protected Object resolveObject(Object obj) throws IOException {
-        if (obj instanceof Wrapper) {
-            try {
-                (obj = ConfigurationSerialization.deserializeObject(((Wrapper<?>) obj).map)).getClass(); // NPE
-            } catch (Throwable ex) {
-                throw newIOException("Failed to deserialize object", ex);
-            }
-        }
-
-        return super.resolveObject(obj);
-    }
-
-    private static IOException newIOException(String string, Throwable cause) {
-        IOException exception = new IOException(string);
-        exception.initCause(cause);
-        return exception;
-    }
-}
diff --git a/src/main/java/org/bukkit/util/io/BukkitObjectOutputStream.java b/src/main/java/org/bukkit/util/io/BukkitObjectOutputStream.java
deleted file mode 100644
index 8452850..0000000
--- a/src/main/java/org/bukkit/util/io/BukkitObjectOutputStream.java
+++ /dev/null
@@ -1,52 +0,0 @@
-package org.bukkit.util.io;
-
-import java.io.IOException;
-import java.io.ObjectOutputStream;
-import java.io.OutputStream;
-import java.io.Serializable;
-
-import org.bukkit.configuration.serialization.ConfigurationSerializable;
-
-/**
- * This class is designed to be used in conjunction with the {@link
- * ConfigurationSerializable} API. It translates objects to an internal
- * implementation for later deserialization using {@link
- * BukkitObjectInputStream}.
- * <p>
- * Behavior of implementations extending this class is not guaranteed across
- * future versions.
- */
-public class BukkitObjectOutputStream extends ObjectOutputStream {
-
-    /**
-     * Constructor provided to mirror super functionality.
-     *
-     * @throws IOException if an I/O error occurs while writing stream header
-     * @see ObjectOutputStream#ObjectOutputStream()
-     */
-    protected BukkitObjectOutputStream() throws IOException, SecurityException {
-        super();
-        super.enableReplaceObject(true);
-    }
-
-    /**
-     * Object output stream decoration constructor.
-     *
-     * @param out the stream to wrap
-     * @throws IOException if an I/O error occurs while writing stream header
-     * @see ObjectOutputStream#ObjectOutputStream(OutputStream)
-     */
-    public BukkitObjectOutputStream(OutputStream out) throws IOException {
-        super(out);
-        super.enableReplaceObject(true);
-    }
-
-    @Override
-    protected Object replaceObject(Object obj) throws IOException {
-        if (!(obj instanceof Serializable) && (obj instanceof ConfigurationSerializable)) {
-            obj = Wrapper.newWrapper((ConfigurationSerializable) obj);
-        }
-
-        return super.replaceObject(obj);
-    }
-}
diff --git a/src/main/java/org/bukkit/util/io/Wrapper.java b/src/main/java/org/bukkit/util/io/Wrapper.java
deleted file mode 100644
index e45605b..0000000
--- a/src/main/java/org/bukkit/util/io/Wrapper.java
+++ /dev/null
@@ -1,23 +0,0 @@
-package org.bukkit.util.io;
-
-import java.io.Serializable;
-import java.util.Map;
-
-import org.bukkit.configuration.serialization.ConfigurationSerializable;
-import org.bukkit.configuration.serialization.ConfigurationSerialization;
-
-import com.google.common.collect.ImmutableMap;
-
-class Wrapper<T extends Map<String, ?> & Serializable> implements Serializable {
-    private static final long serialVersionUID = -986209235411767547L;
-
-    final T map;
-
-    static Wrapper<ImmutableMap<String, ?>> newWrapper(ConfigurationSerializable obj) {
-        return new Wrapper<ImmutableMap<String, ?>>(ImmutableMap.<String, Object>builder().put(ConfigurationSerialization.SERIALIZED_TYPE_KEY, ConfigurationSerialization.getAlias(obj.getClass())).putAll(obj.serialize()).build());
-    }
-
-    private Wrapper(T map) {
-        this.map = map;
-    }
-}
diff --git a/src/main/java/org/bukkit/util/noise/NoiseGenerator.java b/src/main/java/org/bukkit/util/noise/NoiseGenerator.java
deleted file mode 100644
index 72c92f3..0000000
--- a/src/main/java/org/bukkit/util/noise/NoiseGenerator.java
+++ /dev/null
@@ -1,176 +0,0 @@
-package org.bukkit.util.noise;
-
-/**
- * Base class for all noise generators
- */
-public abstract class NoiseGenerator {
-    protected final int perm[] = new int[512];
-    protected double offsetX;
-    protected double offsetY;
-    protected double offsetZ;
-
-    /**
-     * Speedy floor, faster than (int)Math.floor(x)
-     *
-     * @param x Value to floor
-     * @return Floored value
-     */
-    public static int floor(double x) {
-        return x >= 0 ? (int) x : (int) x - 1;
-    }
-
-    protected static double fade(double x) {
-        return x * x * x * (x * (x * 6 - 15) + 10);
-    }
-
-    protected static double lerp(double x, double y, double z) {
-        return y + x * (z - y);
-    }
-
-    protected static double grad(int hash, double x, double y, double z) {
-        hash &= 15;
-        double u = hash < 8 ? x : y;
-        double v = hash < 4 ? y : hash == 12 || hash == 14 ? x : z;
-        return ((hash & 1) == 0 ? u : -u) + ((hash & 2) == 0 ? v : -v);
-    }
-
-    /**
-     * Computes and returns the 1D noise for the given coordinate in 1D space
-     *
-     * @param x X coordinate
-     * @return Noise at given location, from range -1 to 1
-     */
-    public double noise(double x) {
-        return noise(x, 0, 0);
-    }
-
-    /**
-     * Computes and returns the 2D noise for the given coordinates in 2D space
-     *
-     * @param x X coordinate
-     * @param y Y coordinate
-     * @return Noise at given location, from range -1 to 1
-     */
-    public double noise(double x, double y) {
-        return noise(x, y, 0);
-    }
-
-    /**
-     * Computes and returns the 3D noise for the given coordinates in 3D space
-     *
-     * @param x X coordinate
-     * @param y Y coordinate
-     * @param z Z coordinate
-     * @return Noise at given location, from range -1 to 1
-     */
-    public abstract double noise(double x, double y, double z);
-
-    /**
-     * Generates noise for the 1D coordinates using the specified number of
-     * octaves and parameters
-     *
-     * @param x X-coordinate
-     * @param octaves Number of octaves to use
-     * @param frequency How much to alter the frequency by each octave
-     * @param amplitude How much to alter the amplitude by each octave
-     * @return Resulting noise
-     */
-    public double noise(double x, int octaves, double frequency, double amplitude) {
-        return noise(x, 0, 0, octaves, frequency, amplitude);
-    }
-
-    /**
-     * Generates noise for the 1D coordinates using the specified number of
-     * octaves and parameters
-     *
-     * @param x X-coordinate
-     * @param octaves Number of octaves to use
-     * @param frequency How much to alter the frequency by each octave
-     * @param amplitude How much to alter the amplitude by each octave
-     * @param normalized If true, normalize the value to [-1, 1]
-     * @return Resulting noise
-     */
-    public double noise(double x, int octaves, double frequency, double amplitude, boolean normalized) {
-        return noise(x, 0, 0, octaves, frequency, amplitude, normalized);
-    }
-
-    /**
-     * Generates noise for the 2D coordinates using the specified number of
-     * octaves and parameters
-     *
-     * @param x X-coordinate
-     * @param y Y-coordinate
-     * @param octaves Number of octaves to use
-     * @param frequency How much to alter the frequency by each octave
-     * @param amplitude How much to alter the amplitude by each octave
-     * @return Resulting noise
-     */
-    public double noise(double x, double y, int octaves, double frequency, double amplitude) {
-        return noise(x, y, 0, octaves, frequency, amplitude);
-    }
-
-    /**
-     * Generates noise for the 2D coordinates using the specified number of
-     * octaves and parameters
-     *
-     * @param x X-coordinate
-     * @param y Y-coordinate
-     * @param octaves Number of octaves to use
-     * @param frequency How much to alter the frequency by each octave
-     * @param amplitude How much to alter the amplitude by each octave
-     * @param normalized If true, normalize the value to [-1, 1]
-     * @return Resulting noise
-     */
-    public double noise(double x, double y, int octaves, double frequency, double amplitude, boolean normalized) {
-        return noise(x, y, 0, octaves, frequency, amplitude, normalized);
-    }
-
-    /**
-     * Generates noise for the 3D coordinates using the specified number of
-     * octaves and parameters
-     *
-     * @param x X-coordinate
-     * @param y Y-coordinate
-     * @param z Z-coordinate
-     * @param octaves Number of octaves to use
-     * @param frequency How much to alter the frequency by each octave
-     * @param amplitude How much to alter the amplitude by each octave
-     * @return Resulting noise
-     */
-    public double noise(double x, double y, double z, int octaves, double frequency, double amplitude) {
-        return noise(x, y, z, octaves, frequency, amplitude, false);
-    }
-
-    /**
-     * Generates noise for the 3D coordinates using the specified number of
-     * octaves and parameters
-     *
-     * @param x X-coordinate
-     * @param y Y-coordinate
-     * @param z Z-coordinate
-     * @param octaves Number of octaves to use
-     * @param frequency How much to alter the frequency by each octave
-     * @param amplitude How much to alter the amplitude by each octave
-     * @param normalized If true, normalize the value to [-1, 1]
-     * @return Resulting noise
-     */
-    public double noise(double x, double y, double z, int octaves, double frequency, double amplitude, boolean normalized) {
-        double result = 0;
-        double amp = 1;
-        double freq = 1;
-        double max = 0;
-
-        for (int i = 0; i < octaves; i++) {
-            result += noise(x * freq, y * freq, z * freq) * amp;
-            max += amp;
-            freq *= frequency;
-            amp *= amplitude;
-        }
-
-        if (normalized) {
-            result /= max;
-        }
-
-        return result;
-    }
-}
diff --git a/src/main/java/org/bukkit/util/noise/OctaveGenerator.java b/src/main/java/org/bukkit/util/noise/OctaveGenerator.java
deleted file mode 100644
index a87304b..0000000
--- a/src/main/java/org/bukkit/util/noise/OctaveGenerator.java
+++ /dev/null
@@ -1,199 +0,0 @@
-package org.bukkit.util.noise;
-
-/**
- * Creates noise using unbiased octaves
- */
-public abstract class OctaveGenerator {
-    protected final NoiseGenerator[] octaves;
-    protected double xScale = 1;
-    protected double yScale = 1;
-    protected double zScale = 1;
-
-    protected OctaveGenerator(NoiseGenerator[] octaves) {
-        this.octaves = octaves;
-    }
-
-    /**
-     * Sets the scale used for all coordinates passed to this generator.
-     * <p>
-     * This is the equivalent to setting each coordinate to the specified
-     * value.
-     *
-     * @param scale New value to scale each coordinate by
-     */
-    public void setScale(double scale) {
-        setXScale(scale);
-        setYScale(scale);
-        setZScale(scale);
-    }
-
-    /**
-     * Gets the scale used for each X-coordinates passed
-     *
-     * @return X scale
-     */
-    public double getXScale() {
-        return xScale;
-    }
-
-    /**
-     * Sets the scale used for each X-coordinates passed
-     *
-     * @param scale New X scale
-     */
-    public void setXScale(double scale) {
-        xScale = scale;
-    }
-
-    /**
-     * Gets the scale used for each Y-coordinates passed
-     *
-     * @return Y scale
-     */
-    public double getYScale() {
-        return yScale;
-    }
-
-    /**
-     * Sets the scale used for each Y-coordinates passed
-     *
-     * @param scale New Y scale
-     */
-    public void setYScale(double scale) {
-        yScale = scale;
-    }
-
-    /**
-     * Gets the scale used for each Z-coordinates passed
-     *
-     * @return Z scale
-     */
-    public double getZScale() {
-        return zScale;
-    }
-
-    /**
-     * Sets the scale used for each Z-coordinates passed
-     *
-     * @param scale New Z scale
-     */
-    public void setZScale(double scale) {
-        zScale = scale;
-    }
-
-    /**
-     * Gets a clone of the individual octaves used within this generator
-     *
-     * @return Clone of the individual octaves
-     */
-    public NoiseGenerator[] getOctaves() {
-        return octaves.clone();
-    }
-
-    /**
-     * Generates noise for the 1D coordinates using the specified number of
-     * octaves and parameters
-     *
-     * @param x X-coordinate
-     * @param frequency How much to alter the frequency by each octave
-     * @param amplitude How much to alter the amplitude by each octave
-     * @return Resulting noise
-     */
-    public double noise(double x, double frequency, double amplitude) {
-        return noise(x, 0, 0, frequency, amplitude);
-    }
-
-    /**
-     * Generates noise for the 1D coordinates using the specified number of
-     * octaves and parameters
-     *
-     * @param x X-coordinate
-     * @param frequency How much to alter the frequency by each octave
-     * @param amplitude How much to alter the amplitude by each octave
-     * @param normalized If true, normalize the value to [-1, 1]
-     * @return Resulting noise
-     */
-    public double noise(double x, double frequency, double amplitude, boolean normalized) {
-        return noise(x, 0, 0, frequency, amplitude, normalized);
-    }
-
-    /**
-     * Generates noise for the 2D coordinates using the specified number of
-     * octaves and parameters
-     *
-     * @param x X-coordinate
-     * @param y Y-coordinate
-     * @param frequency How much to alter the frequency by each octave
-     * @param amplitude How much to alter the amplitude by each octave
-     * @return Resulting noise
-     */
-    public double noise(double x, double y, double frequency, double amplitude) {
-        return noise(x, y, 0, frequency, amplitude);
-    }
-
-    /**
-     * Generates noise for the 2D coordinates using the specified number of
-     * octaves and parameters
-     *
-     * @param x X-coordinate
-     * @param y Y-coordinate
-     * @param frequency How much to alter the frequency by each octave
-     * @param amplitude How much to alter the amplitude by each octave
-     * @param normalized If true, normalize the value to [-1, 1]
-     * @return Resulting noise
-     */
-    public double noise(double x, double y, double frequency, double amplitude, boolean normalized) {
-        return noise(x, y, 0, frequency, amplitude, normalized);
-    }
-
-    /**
-     * Generates noise for the 3D coordinates using the specified number of
-     * octaves and parameters
-     *
-     * @param x X-coordinate
-     * @param y Y-coordinate
-     * @param z Z-coordinate
-     * @param frequency How much to alter the frequency by each octave
-     * @param amplitude How much to alter the amplitude by each octave
-     * @return Resulting noise
-     */
-    public double noise(double x, double y, double z, double frequency, double amplitude) {
-        return noise(x, y, z, frequency, amplitude, false);
-    }
-
-    /**
-     * Generates noise for the 3D coordinates using the specified number of
-     * octaves and parameters
-     *
-     * @param x X-coordinate
-     * @param y Y-coordinate
-     * @param z Z-coordinate
-     * @param frequency How much to alter the frequency by each octave
-     * @param amplitude How much to alter the amplitude by each octave
-     * @param normalized If true, normalize the value to [-1, 1]
-     * @return Resulting noise
-     */
-    public double noise(double x, double y, double z, double frequency, double amplitude, boolean normalized) {
-        double result = 0;
-        double amp = 1;
-        double freq = 1;
-        double max = 0;
-
-        x *= xScale;
-        y *= yScale;
-        z *= zScale;
-
-        for (NoiseGenerator octave : octaves) {
-            result += octave.noise(x * freq, y * freq, z * freq) * amp;
-            max += amp;
-            freq *= frequency;
-            amp *= amplitude;
-        }
-
-        if (normalized) {
-            result /= max;
-        }
-
-        return result;
-    }
-}
diff --git a/src/main/java/org/bukkit/util/noise/PerlinNoiseGenerator.java b/src/main/java/org/bukkit/util/noise/PerlinNoiseGenerator.java
deleted file mode 100644
index 5e034c1..0000000
--- a/src/main/java/org/bukkit/util/noise/PerlinNoiseGenerator.java
+++ /dev/null
@@ -1,217 +0,0 @@
-package org.bukkit.util.noise;
-
-import java.util.Random;
-import org.bukkit.World;
-
-/**
- * Generates noise using the "classic" perlin generator
- *
- * @see SimplexNoiseGenerator "Improved" and faster version with slighly
- *     different results
- */
-public class PerlinNoiseGenerator extends NoiseGenerator {
-    protected static final int grad3[][] = {{1, 1, 0}, {-1, 1, 0}, {1, -1, 0}, {-1, -1, 0},
-        {1, 0, 1}, {-1, 0, 1}, {1, 0, -1}, {-1, 0, -1},
-        {0, 1, 1}, {0, -1, 1}, {0, 1, -1}, {0, -1, -1}};
-    private static final PerlinNoiseGenerator instance = new PerlinNoiseGenerator();
-
-    protected PerlinNoiseGenerator() {
-        int p[] = {151, 160, 137, 91, 90, 15, 131, 13, 201,
-            95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37,
-            240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62,
-            94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56,
-            87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139,
-            48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133,
-            230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25,
-            63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200,
-            196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3,
-            64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255,
-            82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42,
-            223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153,
-            101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79,
-            113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242,
-            193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249,
-            14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204,
-            176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222,
-            114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180};
-
-        for (int i = 0; i < 512; i++) {
-            perm[i] = p[i & 255];
-        }
-    }
-
-    /**
-     * Creates a seeded perlin noise generator for the given world
-     *
-     * @param world World to construct this generator for
-     */
-    public PerlinNoiseGenerator(World world) {
-        this(new Random(world.getSeed()));
-    }
-
-    /**
-     * Creates a seeded perlin noise generator for the given seed
-     *
-     * @param seed Seed to construct this generator for
-     */
-    public PerlinNoiseGenerator(long seed) {
-        this(new Random(seed));
-    }
-
-    /**
-     * Creates a seeded perlin noise generator with the given Random
-     *
-     * @param rand Random to construct with
-     */
-    public PerlinNoiseGenerator(Random rand) {
-        offsetX = rand.nextDouble() * 256;
-        offsetY = rand.nextDouble() * 256;
-        offsetZ = rand.nextDouble() * 256;
-
-        for (int i = 0; i < 256; i++) {
-            perm[i] = rand.nextInt(256);
-        }
-
-        for (int i = 0; i < 256; i++) {
-            int pos = rand.nextInt(256 - i) + i;
-            int old = perm[i];
-
-            perm[i] = perm[pos];
-            perm[pos] = old;
-            perm[i + 256] = perm[i];
-        }
-    }
-
-    /**
-     * Computes and returns the 1D unseeded perlin noise for the given
-     * coordinates in 1D space
-     *
-     * @param x X coordinate
-     * @return Noise at given location, from range -1 to 1
-     */
-    public static double getNoise(double x) {
-        return instance.noise(x);
-    }
-
-    /**
-     * Computes and returns the 2D unseeded perlin noise for the given
-     * coordinates in 2D space
-     *
-     * @param x X coordinate
-     * @param y Y coordinate
-     * @return Noise at given location, from range -1 to 1
-     */
-    public static double getNoise(double x, double y) {
-        return instance.noise(x, y);
-    }
-
-    /**
-     * Computes and returns the 3D unseeded perlin noise for the given
-     * coordinates in 3D space
-     *
-     * @param x X coordinate
-     * @param y Y coordinate
-     * @param z Z coordinate
-     * @return Noise at given location, from range -1 to 1
-     */
-    public static double getNoise(double x, double y, double z) {
-        return instance.noise(x, y, z);
-    }
-
-    /**
-     * Gets the singleton unseeded instance of this generator
-     *
-     * @return Singleton
-     */
-    public static PerlinNoiseGenerator getInstance() {
-        return instance;
-    }
-
-    @Override
-    public double noise(double x, double y, double z) {
-        x += offsetX;
-        y += offsetY;
-        z += offsetZ;
-
-        int floorX = floor(x);
-        int floorY = floor(y);
-        int floorZ = floor(z);
-
-        // Find unit cube containing the point
-        int X = floorX & 255;
-        int Y = floorY & 255;
-        int Z = floorZ & 255;
-
-        // Get relative xyz coordinates of the point within the cube
-        x -= floorX;
-        y -= floorY;
-        z -= floorZ;
-
-        // Compute fade curves for xyz
-        double fX = fade(x);
-        double fY = fade(y);
-        double fZ = fade(z);
-
-        // Hash coordinates of the cube corners
-        int A = perm[X] + Y;
-        int AA = perm[A] + Z;
-        int AB = perm[A + 1] + Z;
-        int B = perm[X + 1] + Y;
-        int BA = perm[B] + Z;
-        int BB = perm[B + 1] + Z;
-
-        return lerp(fZ, lerp(fY, lerp(fX, grad(perm[AA], x, y, z),
-                        grad(perm[BA], x - 1, y, z)),
-                    lerp(fX, grad(perm[AB], x, y - 1, z),
-                        grad(perm[BB], x - 1, y - 1, z))),
-                lerp(fY, lerp(fX, grad(perm[AA + 1], x, y, z - 1),
-                        grad(perm[BA + 1], x - 1, y, z - 1)),
-                    lerp(fX, grad(perm[AB + 1], x, y - 1, z - 1),
-                        grad(perm[BB + 1], x - 1, y - 1, z - 1))));
-    }
-
-    /**
-     * Generates noise for the 1D coordinates using the specified number of
-     * octaves and parameters
-     *
-     * @param x X-coordinate
-     * @param octaves Number of octaves to use
-     * @param frequency How much to alter the frequency by each octave
-     * @param amplitude How much to alter the amplitude by each octave
-     * @return Resulting noise
-     */
-    public static double getNoise(double x, int octaves, double frequency, double amplitude) {
-        return instance.noise(x, octaves, frequency, amplitude);
-    }
-
-    /**
-     * Generates noise for the 2D coordinates using the specified number of
-     * octaves and parameters
-     *
-     * @param x X-coordinate
-     * @param y Y-coordinate
-     * @param octaves Number of octaves to use
-     * @param frequency How much to alter the frequency by each octave
-     * @param amplitude How much to alter the amplitude by each octave
-     * @return Resulting noise
-     */
-    public static double getNoise(double x, double y, int octaves, double frequency, double amplitude) {
-        return instance.noise(x, y, octaves, frequency, amplitude);
-    }
-
-    /**
-     * Generates noise for the 3D coordinates using the specified number of
-     * octaves and parameters
-     *
-     * @param x X-coordinate
-     * @param y Y-coordinate
-     * @param z Z-coordinate
-     * @param octaves Number of octaves to use
-     * @param frequency How much to alter the frequency by each octave
-     * @param amplitude How much to alter the amplitude by each octave
-     * @return Resulting noise
-     */
-    public static double getNoise(double x, double y, double z, int octaves, double frequency, double amplitude) {
-        return instance.noise(x, y, z, octaves, frequency, amplitude);
-    }
-}
diff --git a/src/main/java/org/bukkit/util/noise/PerlinOctaveGenerator.java b/src/main/java/org/bukkit/util/noise/PerlinOctaveGenerator.java
deleted file mode 100644
index 55b7ad7..0000000
--- a/src/main/java/org/bukkit/util/noise/PerlinOctaveGenerator.java
+++ /dev/null
@@ -1,50 +0,0 @@
-package org.bukkit.util.noise;
-
-import java.util.Random;
-import org.bukkit.World;
-
-/**
- * Creates perlin noise through unbiased octaves
- */
-public class PerlinOctaveGenerator extends OctaveGenerator {
-
-    /**
-     * Creates a perlin octave generator for the given world
-     *
-     * @param world World to construct this generator for
-     * @param octaves Amount of octaves to create
-     */
-    public PerlinOctaveGenerator(World world, int octaves) {
-        this(new Random(world.getSeed()), octaves);
-    }
-
-    /**
-     * Creates a perlin octave generator for the given world
-     *
-     * @param seed Seed to construct this generator for
-     * @param octaves Amount of octaves to create
-     */
-    public PerlinOctaveGenerator(long seed, int octaves) {
-        this(new Random(seed), octaves);
-    }
-
-    /**
-     * Creates a perlin octave generator for the given {@link Random}
-     *
-     * @param rand Random object to construct this generator for
-     * @param octaves Amount of octaves to create
-     */
-    public PerlinOctaveGenerator(Random rand, int octaves) {
-        super(createOctaves(rand, octaves));
-    }
-
-    private static NoiseGenerator[] createOctaves(Random rand, int octaves) {
-        NoiseGenerator[] result = new NoiseGenerator[octaves];
-
-        for (int i = 0; i < octaves; i++) {
-            result[i] = new PerlinNoiseGenerator(rand);
-        }
-
-        return result;
-    }
-}
diff --git a/src/main/java/org/bukkit/util/noise/SimplexNoiseGenerator.java b/src/main/java/org/bukkit/util/noise/SimplexNoiseGenerator.java
deleted file mode 100644
index b052f3c..0000000
--- a/src/main/java/org/bukkit/util/noise/SimplexNoiseGenerator.java
+++ /dev/null
@@ -1,520 +0,0 @@
-package org.bukkit.util.noise;
-
-import java.util.Random;
-import org.bukkit.World;
-
-/**
- * Generates simplex-based noise.
- * <p>
- * This is a modified version of the freely published version in the paper by
- * Stefan Gustavson at
- * <a href="http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf">
- * http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf</a>
- */
-public class SimplexNoiseGenerator extends PerlinNoiseGenerator {
-    protected static final double SQRT_3 = Math.sqrt(3);
-    protected static final double SQRT_5 = Math.sqrt(5);
-    protected static final double F2 = 0.5 * (SQRT_3 - 1);
-    protected static final double G2 = (3 - SQRT_3) / 6;
-    protected static final double G22 = G2 * 2.0 - 1;
-    protected static final double F3 = 1.0 / 3.0;
-    protected static final double G3 = 1.0 / 6.0;
-    protected static final double F4 = (SQRT_5 - 1.0) / 4.0;
-    protected static final double G4 = (5.0 - SQRT_5) / 20.0;
-    protected static final double G42 = G4 * 2.0;
-    protected static final double G43 = G4 * 3.0;
-    protected static final double G44 = G4 * 4.0 - 1.0;
-    protected static final int grad4[][] = {{0, 1, 1, 1}, {0, 1, 1, -1}, {0, 1, -1, 1}, {0, 1, -1, -1},
-        {0, -1, 1, 1}, {0, -1, 1, -1}, {0, -1, -1, 1}, {0, -1, -1, -1},
-        {1, 0, 1, 1}, {1, 0, 1, -1}, {1, 0, -1, 1}, {1, 0, -1, -1},
-        {-1, 0, 1, 1}, {-1, 0, 1, -1}, {-1, 0, -1, 1}, {-1, 0, -1, -1},
-        {1, 1, 0, 1}, {1, 1, 0, -1}, {1, -1, 0, 1}, {1, -1, 0, -1},
-        {-1, 1, 0, 1}, {-1, 1, 0, -1}, {-1, -1, 0, 1}, {-1, -1, 0, -1},
-        {1, 1, 1, 0}, {1, 1, -1, 0}, {1, -1, 1, 0}, {1, -1, -1, 0},
-        {-1, 1, 1, 0}, {-1, 1, -1, 0}, {-1, -1, 1, 0}, {-1, -1, -1, 0}};
-    protected static final int simplex[][] = {
-        {0, 1, 2, 3}, {0, 1, 3, 2}, {0, 0, 0, 0}, {0, 2, 3, 1}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {1, 2, 3, 0},
-        {0, 2, 1, 3}, {0, 0, 0, 0}, {0, 3, 1, 2}, {0, 3, 2, 1}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {1, 3, 2, 0},
-        {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0},
-        {1, 2, 0, 3}, {0, 0, 0, 0}, {1, 3, 0, 2}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {2, 3, 0, 1}, {2, 3, 1, 0},
-        {1, 0, 2, 3}, {1, 0, 3, 2}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {2, 0, 3, 1}, {0, 0, 0, 0}, {2, 1, 3, 0},
-        {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0},
-        {2, 0, 1, 3}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {3, 0, 1, 2}, {3, 0, 2, 1}, {0, 0, 0, 0}, {3, 1, 2, 0},
-        {2, 1, 0, 3}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {3, 1, 0, 2}, {0, 0, 0, 0}, {3, 2, 0, 1}, {3, 2, 1, 0}};
-    protected static double offsetW;
-    private static final SimplexNoiseGenerator instance = new SimplexNoiseGenerator();
-
-    protected SimplexNoiseGenerator() {
-        super();
-    }
-
-    /**
-     * Creates a seeded simplex noise generator for the given world
-     *
-     * @param world World to construct this generator for
-     */
-    public SimplexNoiseGenerator(World world) {
-        this(new Random(world.getSeed()));
-    }
-
-    /**
-     * Creates a seeded simplex noise generator for the given seed
-     *
-     * @param seed Seed to construct this generator for
-     */
-    public SimplexNoiseGenerator(long seed) {
-        this(new Random(seed));
-    }
-
-    /**
-     * Creates a seeded simplex noise generator with the given Random
-     *
-     * @param rand Random to construct with
-     */
-    public SimplexNoiseGenerator(Random rand) {
-        super(rand);
-        offsetW = rand.nextDouble() * 256;
-    }
-
-    protected static double dot(int g[], double x, double y) {
-        return g[0] * x + g[1] * y;
-    }
-
-    protected static double dot(int g[], double x, double y, double z) {
-        return g[0] * x + g[1] * y + g[2] * z;
-    }
-
-    protected static double dot(int g[], double x, double y, double z, double w) {
-        return g[0] * x + g[1] * y + g[2] * z + g[3] * w;
-    }
-
-    /**
-     * Computes and returns the 1D unseeded simplex noise for the given
-     * coordinates in 1D space
-     *
-     * @param xin X coordinate
-     * @return Noise at given location, from range -1 to 1
-     */
-    public static double getNoise(double xin) {
-        return instance.noise(xin);
-    }
-
-    /**
-     * Computes and returns the 2D unseeded simplex noise for the given
-     * coordinates in 2D space
-     *
-     * @param xin X coordinate
-     * @param yin Y coordinate
-     * @return Noise at given location, from range -1 to 1
-     */
-    public static double getNoise(double xin, double yin) {
-        return instance.noise(xin, yin);
-    }
-
-    /**
-     * Computes and returns the 3D unseeded simplex noise for the given
-     * coordinates in 3D space
-     *
-     * @param xin X coordinate
-     * @param yin Y coordinate
-     * @param zin Z coordinate
-     * @return Noise at given location, from range -1 to 1
-     */
-    public static double getNoise(double xin, double yin, double zin) {
-        return instance.noise(xin, yin, zin);
-    }
-
-    /**
-     * Computes and returns the 4D simplex noise for the given coordinates in
-     * 4D space
-     *
-     * @param x X coordinate
-     * @param y Y coordinate
-     * @param z Z coordinate
-     * @param w W coordinate
-     * @return Noise at given location, from range -1 to 1
-     */
-    public static double getNoise(double x, double y, double z, double w) {
-        return instance.noise(x, y, z, w);
-    }
-
-    @Override
-    public double noise(double xin, double yin, double zin) {
-        xin += offsetX;
-        yin += offsetY;
-        zin += offsetZ;
-
-        double n0, n1, n2, n3; // Noise contributions from the four corners
-
-        // Skew the input space to determine which simplex cell we're in
-        double s = (xin + yin + zin) * F3; // Very nice and simple skew factor for 3D
-        int i = floor(xin + s);
-        int j = floor(yin + s);
-        int k = floor(zin + s);
-        double t = (i + j + k) * G3;
-        double X0 = i - t; // Unskew the cell origin back to (x,y,z) space
-        double Y0 = j - t;
-        double Z0 = k - t;
-        double x0 = xin - X0; // The x,y,z distances from the cell origin
-        double y0 = yin - Y0;
-        double z0 = zin - Z0;
-
-        // For the 3D case, the simplex shape is a slightly irregular tetrahedron.
-
-        // Determine which simplex we are in.
-        int i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords
-        int i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords
-        if (x0 >= y0) {
-            if (y0 >= z0) {
-                i1 = 1;
-                j1 = 0;
-                k1 = 0;
-                i2 = 1;
-                j2 = 1;
-                k2 = 0;
-            } // X Y Z order
-            else if (x0 >= z0) {
-                i1 = 1;
-                j1 = 0;
-                k1 = 0;
-                i2 = 1;
-                j2 = 0;
-                k2 = 1;
-            } // X Z Y order
-            else {
-                i1 = 0;
-                j1 = 0;
-                k1 = 1;
-                i2 = 1;
-                j2 = 0;
-                k2 = 1;
-            } // Z X Y order
-        } else { // x0<y0
-            if (y0 < z0) {
-                i1 = 0;
-                j1 = 0;
-                k1 = 1;
-                i2 = 0;
-                j2 = 1;
-                k2 = 1;
-            } // Z Y X order
-            else if (x0 < z0) {
-                i1 = 0;
-                j1 = 1;
-                k1 = 0;
-                i2 = 0;
-                j2 = 1;
-                k2 = 1;
-            } // Y Z X order
-            else {
-                i1 = 0;
-                j1 = 1;
-                k1 = 0;
-                i2 = 1;
-                j2 = 1;
-                k2 = 0;
-            } // Y X Z order
-        }
-
-        // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),
-        // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and
-        // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where
-        // c = 1/6.
-        double x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords
-        double y1 = y0 - j1 + G3;
-        double z1 = z0 - k1 + G3;
-        double x2 = x0 - i2 + 2.0 * G3; // Offsets for third corner in (x,y,z) coords
-        double y2 = y0 - j2 + 2.0 * G3;
-        double z2 = z0 - k2 + 2.0 * G3;
-        double x3 = x0 - 1.0 + 3.0 * G3; // Offsets for last corner in (x,y,z) coords
-        double y3 = y0 - 1.0 + 3.0 * G3;
-        double z3 = z0 - 1.0 + 3.0 * G3;
-
-        // Work out the hashed gradient indices of the four simplex corners
-        int ii = i & 255;
-        int jj = j & 255;
-        int kk = k & 255;
-        int gi0 = perm[ii + perm[jj + perm[kk]]] % 12;
-        int gi1 = perm[ii + i1 + perm[jj + j1 + perm[kk + k1]]] % 12;
-        int gi2 = perm[ii + i2 + perm[jj + j2 + perm[kk + k2]]] % 12;
-        int gi3 = perm[ii + 1 + perm[jj + 1 + perm[kk + 1]]] % 12;
-
-        // Calculate the contribution from the four corners
-        double t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
-        if (t0 < 0) {
-            n0 = 0.0;
-        } else {
-            t0 *= t0;
-            n0 = t0 * t0 * dot(grad3[gi0], x0, y0, z0);
-        }
-
-        double t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
-        if (t1 < 0) {
-            n1 = 0.0;
-        } else {
-            t1 *= t1;
-            n1 = t1 * t1 * dot(grad3[gi1], x1, y1, z1);
-        }
-
-        double t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
-        if (t2 < 0) {
-            n2 = 0.0;
-        } else {
-            t2 *= t2;
-            n2 = t2 * t2 * dot(grad3[gi2], x2, y2, z2);
-        }
-
-        double t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
-        if (t3 < 0) {
-            n3 = 0.0;
-        } else {
-            t3 *= t3;
-            n3 = t3 * t3 * dot(grad3[gi3], x3, y3, z3);
-        }
-
-        // Add contributions from each corner to get the final noise value.
-        // The result is scaled to stay just inside [-1,1]
-        return 32.0 * (n0 + n1 + n2 + n3);
-    }
-
-    @Override
-    public double noise(double xin, double yin) {
-        xin += offsetX;
-        yin += offsetY;
-
-        double n0, n1, n2; // Noise contributions from the three corners
-
-        // Skew the input space to determine which simplex cell we're in
-        double s = (xin + yin) * F2; // Hairy factor for 2D
-        int i = floor(xin + s);
-        int j = floor(yin + s);
-        double t = (i + j) * G2;
-        double X0 = i - t; // Unskew the cell origin back to (x,y) space
-        double Y0 = j - t;
-        double x0 = xin - X0; // The x,y distances from the cell origin
-        double y0 = yin - Y0;
-
-        // For the 2D case, the simplex shape is an equilateral triangle.
-
-        // Determine which simplex we are in.
-        int i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords
-        if (x0 > y0) {
-            i1 = 1;
-            j1 = 0;
-        } // lower triangle, XY order: (0,0)->(1,0)->(1,1)
-        else {
-            i1 = 0;
-            j1 = 1;
-        } // upper triangle, YX order: (0,0)->(0,1)->(1,1)
-
-        // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
-        // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
-        // c = (3-sqrt(3))/6
-
-        double x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords
-        double y1 = y0 - j1 + G2;
-        double x2 = x0 + G22; // Offsets for last corner in (x,y) unskewed coords
-        double y2 = y0 + G22;
-
-        // Work out the hashed gradient indices of the three simplex corners
-        int ii = i & 255;
-        int jj = j & 255;
-        int gi0 = perm[ii + perm[jj]] % 12;
-        int gi1 = perm[ii + i1 + perm[jj + j1]] % 12;
-        int gi2 = perm[ii + 1 + perm[jj + 1]] % 12;
-
-        // Calculate the contribution from the three corners
-        double t0 = 0.5 - x0 * x0 - y0 * y0;
-        if (t0 < 0) {
-            n0 = 0.0;
-        } else {
-            t0 *= t0;
-            n0 = t0 * t0 * dot(grad3[gi0], x0, y0); // (x,y) of grad3 used for 2D gradient
-        }
-
-        double t1 = 0.5 - x1 * x1 - y1 * y1;
-        if (t1 < 0) {
-            n1 = 0.0;
-        } else {
-            t1 *= t1;
-            n1 = t1 * t1 * dot(grad3[gi1], x1, y1);
-        }
-
-        double t2 = 0.5 - x2 * x2 - y2 * y2;
-        if (t2 < 0) {
-            n2 = 0.0;
-        } else {
-            t2 *= t2;
-            n2 = t2 * t2 * dot(grad3[gi2], x2, y2);
-        }
-
-        // Add contributions from each corner to get the final noise value.
-        // The result is scaled to return values in the interval [-1,1].
-        return 70.0 * (n0 + n1 + n2);
-    }
-
-    /**
-     * Computes and returns the 4D simplex noise for the given coordinates in
-     * 4D space
-     *
-     * @param x X coordinate
-     * @param y Y coordinate
-     * @param z Z coordinate
-     * @param w W coordinate
-     * @return Noise at given location, from range -1 to 1
-     */
-    public double noise(double x, double y, double z, double w) {
-        x += offsetX;
-        y += offsetY;
-        z += offsetZ;
-        w += offsetW;
-
-        double n0, n1, n2, n3, n4; // Noise contributions from the five corners
-
-        // Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in
-        double s = (x + y + z + w) * F4; // Factor for 4D skewing
-        int i = floor(x + s);
-        int j = floor(y + s);
-        int k = floor(z + s);
-        int l = floor(w + s);
-
-        double t = (i + j + k + l) * G4; // Factor for 4D unskewing
-        double X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space
-        double Y0 = j - t;
-        double Z0 = k - t;
-        double W0 = l - t;
-        double x0 = x - X0; // The x,y,z,w distances from the cell origin
-        double y0 = y - Y0;
-        double z0 = z - Z0;
-        double w0 = w - W0;
-
-        // For the 4D case, the simplex is a 4D shape I won't even try to describe.
-        // To find out which of the 24 possible simplices we're in, we need to
-        // determine the magnitude ordering of x0, y0, z0 and w0.
-        // The method below is a good way of finding the ordering of x,y,z,w and
-        // then find the correct traversal order for the simplex we’re in.
-        // First, six pair-wise comparisons are performed between each possible pair
-        // of the four coordinates, and the results are used to add up binary bits
-        // for an integer index.
-        int c1 = (x0 > y0) ? 32 : 0;
-        int c2 = (x0 > z0) ? 16 : 0;
-        int c3 = (y0 > z0) ? 8 : 0;
-        int c4 = (x0 > w0) ? 4 : 0;
-        int c5 = (y0 > w0) ? 2 : 0;
-        int c6 = (z0 > w0) ? 1 : 0;
-        int c = c1 + c2 + c3 + c4 + c5 + c6;
-        int i1, j1, k1, l1; // The integer offsets for the second simplex corner
-        int i2, j2, k2, l2; // The integer offsets for the third simplex corner
-        int i3, j3, k3, l3; // The integer offsets for the fourth simplex corner
-
-        // simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.
-        // Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w
-        // impossible. Only the 24 indices which have non-zero entries make any sense.
-        // We use a thresholding to set the coordinates in turn from the largest magnitude.
-
-        // The number 3 in the "simplex" array is at the position of the largest coordinate.
-        i1 = simplex[c][0] >= 3 ? 1 : 0;
-        j1 = simplex[c][1] >= 3 ? 1 : 0;
-        k1 = simplex[c][2] >= 3 ? 1 : 0;
-        l1 = simplex[c][3] >= 3 ? 1 : 0;
-
-        // The number 2 in the "simplex" array is at the second largest coordinate.
-        i2 = simplex[c][0] >= 2 ? 1 : 0;
-        j2 = simplex[c][1] >= 2 ? 1 : 0;
-        k2 = simplex[c][2] >= 2 ? 1 : 0;
-        l2 = simplex[c][3] >= 2 ? 1 : 0;
-
-        // The number 1 in the "simplex" array is at the second smallest coordinate.
-        i3 = simplex[c][0] >= 1 ? 1 : 0;
-        j3 = simplex[c][1] >= 1 ? 1 : 0;
-        k3 = simplex[c][2] >= 1 ? 1 : 0;
-        l3 = simplex[c][3] >= 1 ? 1 : 0;
-
-        // The fifth corner has all coordinate offsets = 1, so no need to look that up.
-
-        double x1 = x0 - i1 + G4; // Offsets for second corner in (x,y,z,w) coords
-        double y1 = y0 - j1 + G4;
-        double z1 = z0 - k1 + G4;
-        double w1 = w0 - l1 + G4;
-
-        double x2 = x0 - i2 + G42; // Offsets for third corner in (x,y,z,w) coords
-        double y2 = y0 - j2 + G42;
-        double z2 = z0 - k2 + G42;
-        double w2 = w0 - l2 + G42;
-
-        double x3 = x0 - i3 + G43; // Offsets for fourth corner in (x,y,z,w) coords
-        double y3 = y0 - j3 + G43;
-        double z3 = z0 - k3 + G43;
-        double w3 = w0 - l3 + G43;
-
-        double x4 = x0 + G44; // Offsets for last corner in (x,y,z,w) coords
-        double y4 = y0 + G44;
-        double z4 = z0 + G44;
-        double w4 = w0 + G44;
-
-        // Work out the hashed gradient indices of the five simplex corners
-        int ii = i & 255;
-        int jj = j & 255;
-        int kk = k & 255;
-        int ll = l & 255;
-
-        int gi0 = perm[ii + perm[jj + perm[kk + perm[ll]]]] % 32;
-        int gi1 = perm[ii + i1 + perm[jj + j1 + perm[kk + k1 + perm[ll + l1]]]] % 32;
-        int gi2 = perm[ii + i2 + perm[jj + j2 + perm[kk + k2 + perm[ll + l2]]]] % 32;
-        int gi3 = perm[ii + i3 + perm[jj + j3 + perm[kk + k3 + perm[ll + l3]]]] % 32;
-        int gi4 = perm[ii + 1 + perm[jj + 1 + perm[kk + 1 + perm[ll + 1]]]] % 32;
-
-        // Calculate the contribution from the five corners
-        double t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;
-        if (t0 < 0) {
-            n0 = 0.0;
-        } else {
-            t0 *= t0;
-            n0 = t0 * t0 * dot(grad4[gi0], x0, y0, z0, w0);
-        }
-
-        double t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;
-        if (t1 < 0) {
-            n1 = 0.0;
-        } else {
-            t1 *= t1;
-            n1 = t1 * t1 * dot(grad4[gi1], x1, y1, z1, w1);
-        }
-
-        double t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;
-        if (t2 < 0) {
-            n2 = 0.0;
-        } else {
-            t2 *= t2;
-            n2 = t2 * t2 * dot(grad4[gi2], x2, y2, z2, w2);
-        }
-
-        double t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;
-        if (t3 < 0) {
-            n3 = 0.0;
-        } else {
-            t3 *= t3;
-            n3 = t3 * t3 * dot(grad4[gi3], x3, y3, z3, w3);
-        }
-
-        double t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;
-        if (t4 < 0) {
-            n4 = 0.0;
-        } else {
-            t4 *= t4;
-            n4 = t4 * t4 * dot(grad4[gi4], x4, y4, z4, w4);
-        }
-
-        // Sum up and scale the result to cover the range [-1,1]
-        return 27.0 * (n0 + n1 + n2 + n3 + n4);
-    }
-
-    /**
-     * Gets the singleton unseeded instance of this generator
-     *
-     * @return Singleton
-     */
-    public static SimplexNoiseGenerator getInstance() {
-        return instance;
-    }
-}
diff --git a/src/main/java/org/bukkit/util/noise/SimplexOctaveGenerator.java b/src/main/java/org/bukkit/util/noise/SimplexOctaveGenerator.java
deleted file mode 100644
index 61e66aa..0000000
--- a/src/main/java/org/bukkit/util/noise/SimplexOctaveGenerator.java
+++ /dev/null
@@ -1,129 +0,0 @@
-package org.bukkit.util.noise;
-
-import java.util.Random;
-import org.bukkit.World;
-
-/**
- * Creates simplex noise through unbiased octaves
- */
-public class SimplexOctaveGenerator extends OctaveGenerator {
-    private double wScale = 1;
-
-    /**
-     * Creates a simplex octave generator for the given world
-     *
-     * @param world World to construct this generator for
-     * @param octaves Amount of octaves to create
-     */
-    public SimplexOctaveGenerator(World world, int octaves) {
-        this(new Random(world.getSeed()), octaves);
-    }
-
-    /**
-     * Creates a simplex octave generator for the given world
-     *
-     * @param seed Seed to construct this generator for
-     * @param octaves Amount of octaves to create
-     */
-    public SimplexOctaveGenerator(long seed, int octaves) {
-        this(new Random(seed), octaves);
-    }
-
-    /**
-     * Creates a simplex octave generator for the given {@link Random}
-     *
-     * @param rand Random object to construct this generator for
-     * @param octaves Amount of octaves to create
-     */
-    public SimplexOctaveGenerator(Random rand, int octaves) {
-        super(createOctaves(rand, octaves));
-    }
-
-    @Override
-    public void setScale(double scale) {
-        super.setScale(scale);
-        setWScale(scale);
-    }
-
-    /**
-     * Gets the scale used for each W-coordinates passed
-     *
-     * @return W scale
-     */
-    public double getWScale() {
-        return wScale;
-    }
-
-    /**
-     * Sets the scale used for each W-coordinates passed
-     *
-     * @param scale New W scale
-     */
-    public void setWScale(double scale) {
-        wScale = scale;
-    }
-
-    /**
-     * Generates noise for the 3D coordinates using the specified number of
-     * octaves and parameters
-     *
-     * @param x X-coordinate
-     * @param y Y-coordinate
-     * @param z Z-coordinate
-     * @param w W-coordinate
-     * @param frequency How much to alter the frequency by each octave
-     * @param amplitude How much to alter the amplitude by each octave
-     * @return Resulting noise
-     */
-    public double noise(double x, double y, double z, double w, double frequency, double amplitude) {
-        return noise(x, y, z, w, frequency, amplitude, false);
-    }
-
-    /**
-     * Generates noise for the 3D coordinates using the specified number of
-     * octaves and parameters
-     *
-     * @param x X-coordinate
-     * @param y Y-coordinate
-     * @param z Z-coordinate
-     * @param w W-coordinate
-     * @param frequency How much to alter the frequency by each octave
-     * @param amplitude How much to alter the amplitude by each octave
-     * @param normalized If true, normalize the value to [-1, 1]
-     * @return Resulting noise
-     */
-    public double noise(double x, double y, double z, double w, double frequency, double amplitude, boolean normalized) {
-        double result = 0;
-        double amp = 1;
-        double freq = 1;
-        double max = 0;
-
-        x *= xScale;
-        y *= yScale;
-        z *= zScale;
-        w *= wScale;
-
-        for (NoiseGenerator octave : octaves) {
-            result += ((SimplexNoiseGenerator) octave).noise(x * freq, y * freq, z * freq, w * freq) * amp;
-            max += amp;
-            freq *= frequency;
-            amp *= amplitude;
-        }
-
-        if (normalized) {
-            result /= max;
-        }
-
-        return result;
-    }
-
-    private static NoiseGenerator[] createOctaves(Random rand, int octaves) {
-        NoiseGenerator[] result = new NoiseGenerator[octaves];
-
-        for (int i = 0; i < octaves; i++) {
-            result[i] = new SimplexNoiseGenerator(rand);
-        }
-
-        return result;
-    }
-}
diff --git a/src/main/java/org/bukkit/util/permissions/BroadcastPermissions.java b/src/main/java/org/bukkit/util/permissions/BroadcastPermissions.java
deleted file mode 100644
index 092370e..0000000
--- a/src/main/java/org/bukkit/util/permissions/BroadcastPermissions.java
+++ /dev/null
@@ -1,22 +0,0 @@
-package org.bukkit.util.permissions;
-
-import org.bukkit.permissions.Permission;
-import org.bukkit.permissions.PermissionDefault;
-
-public final class BroadcastPermissions {
-    private static final String ROOT = "bukkit.broadcast";
-    private static final String PREFIX = ROOT + ".";
-
-    private BroadcastPermissions() {}
-
-    public static Permission registerPermissions(Permission parent) {
-        Permission broadcasts = DefaultPermissions.registerPermission(ROOT, "Allows the user to receive all broadcast messages", parent);
-
-        DefaultPermissions.registerPermission(PREFIX + "admin", "Allows the user to receive administrative broadcasts", PermissionDefault.OP, broadcasts);
-        DefaultPermissions.registerPermission(PREFIX + "user", "Allows the user to receive user broadcasts", PermissionDefault.TRUE, broadcasts);
-
-        broadcasts.recalculatePermissibles();
-
-        return broadcasts;
-    }
-}
diff --git a/src/main/java/org/bukkit/util/permissions/CommandPermissions.java b/src/main/java/org/bukkit/util/permissions/CommandPermissions.java
deleted file mode 100644
index 619646e..0000000
--- a/src/main/java/org/bukkit/util/permissions/CommandPermissions.java
+++ /dev/null
@@ -1,23 +0,0 @@
-package org.bukkit.util.permissions;
-
-import org.bukkit.permissions.Permission;
-import org.bukkit.permissions.PermissionDefault;
-
-public final class CommandPermissions {
-    private static final String ROOT = "bukkit.command";
-    private static final String PREFIX = ROOT + ".";
-
-    private CommandPermissions() {}
-
-    public static Permission registerPermissions(Permission parent) {
-        Permission commands = DefaultPermissions.registerPermission(ROOT, "Gives the user the ability to use all CraftBukkit commands", parent);
-
-        DefaultPermissions.registerPermission(PREFIX + "help", "Allows the user to view the vanilla help menu", PermissionDefault.TRUE, commands);
-        DefaultPermissions.registerPermission(PREFIX + "plugins", "Allows the user to view the list of plugins running on this server", PermissionDefault.TRUE, commands);
-        DefaultPermissions.registerPermission(PREFIX + "reload", "Allows the user to reload the server settings", PermissionDefault.OP, commands);
-        DefaultPermissions.registerPermission(PREFIX + "version", "Allows the user to view the version of the server", PermissionDefault.TRUE, commands);
-
-        commands.recalculatePermissibles();
-        return commands;
-    }
-}
diff --git a/src/main/java/org/bukkit/util/permissions/DefaultPermissions.java b/src/main/java/org/bukkit/util/permissions/DefaultPermissions.java
deleted file mode 100644
index 8c0df8e..0000000
--- a/src/main/java/org/bukkit/util/permissions/DefaultPermissions.java
+++ /dev/null
@@ -1,82 +0,0 @@
-package org.bukkit.util.permissions;
-
-import java.util.Map;
-import org.bukkit.Bukkit;
-import org.bukkit.permissions.Permission;
-import org.bukkit.permissions.PermissionDefault;
-
-public final class DefaultPermissions {
-    private static final String ROOT = "craftbukkit";
-    private static final String LEGACY_PREFIX = "craft";
-
-    private DefaultPermissions() {}
-
-    public static Permission registerPermission(Permission perm) {
-        return registerPermission(perm, true);
-    }
-
-    public static Permission registerPermission(Permission perm, boolean withLegacy) {
-        Permission result = perm;
-
-        try {
-            Bukkit.getPluginManager().addPermission(perm);
-        } catch (IllegalArgumentException ex) {
-            result = Bukkit.getPluginManager().getPermission(perm.getName());
-        }
-
-        if (withLegacy) {
-            Permission legacy = new Permission(LEGACY_PREFIX + result.getName(), result.getDescription(), PermissionDefault.FALSE);
-            legacy.getChildren().put(result.getName(), true);
-            registerPermission(perm, false);
-        }
-
-        return result;
-    }
-
-    public static Permission registerPermission(Permission perm, Permission parent) {
-        parent.getChildren().put(perm.getName(), true);
-        return registerPermission(perm);
-    }
-
-    public static Permission registerPermission(String name, String desc) {
-        Permission perm = registerPermission(new Permission(name, desc));
-        return perm;
-    }
-
-    public static Permission registerPermission(String name, String desc, Permission parent) {
-        Permission perm = registerPermission(name, desc);
-        parent.getChildren().put(perm.getName(), true);
-        return perm;
-    }
-
-    public static Permission registerPermission(String name, String desc, PermissionDefault def) {
-        Permission perm = registerPermission(new Permission(name, desc, def));
-        return perm;
-    }
-
-    public static Permission registerPermission(String name, String desc, PermissionDefault def, Permission parent) {
-        Permission perm = registerPermission(name, desc, def);
-        parent.getChildren().put(perm.getName(), true);
-        return perm;
-    }
-
-    public static Permission registerPermission(String name, String desc, PermissionDefault def, Map<String, Boolean> children) {
-        Permission perm = registerPermission(new Permission(name, desc, def, children));
-        return perm;
-    }
-
-    public static Permission registerPermission(String name, String desc, PermissionDefault def, Map<String, Boolean> children, Permission parent) {
-        Permission perm = registerPermission(name, desc, def, children);
-        parent.getChildren().put(perm.getName(), true);
-        return perm;
-    }
-
-    public static void registerCorePermissions() {
-        Permission parent = registerPermission(ROOT, "Gives the user the ability to use all CraftBukkit utilities and commands");
-
-        CommandPermissions.registerPermissions(parent);
-        BroadcastPermissions.registerPermissions(parent);
-
-        parent.recalculatePermissibles();
-    }
-}
-- 
2.8.2.windows.1

