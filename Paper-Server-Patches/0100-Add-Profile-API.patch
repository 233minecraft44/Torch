From 0908272fb318e3bc91740ae3f51400b3bc6c4439 Mon Sep 17 00:00:00 2001
From: SotrForgotten <i@omc.hk>
Date: Sat, 2 Jul 2016 21:44:23 +0800
Subject: [PATCH] Add Profile API


diff --git a/src/main/java/com/destroystokyo/paper/profile/AccountProfile.java b/src/main/java/com/destroystokyo/paper/profile/AccountProfile.java
new file mode 100644
index 0000000..e4c80dc
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/profile/AccountProfile.java
@@ -0,0 +1,180 @@
+package com.destroystokyo.paper.profile;
+
+import java.util.UUID;
+
+import com.google.common.base.Objects;
+import com.google.common.base.Preconditions;
+
+import org.bukkit.Bukkit;
+import org.bukkit.OfflinePlayer;
+import org.bukkit.entity.Player;
+
+/**
+ * Represents a player's profile
+ * Contains their uuid and username
+ * <p>
+ * This may or may not have properties
+ */
+public final class AccountProfile {
+    private final UUID id;
+    private final String name;
+    private final ProfileProperties properties;
+
+    public AccountProfile(UUID id, String name, ProfileProperties properties) {
+        Preconditions.checkNotNull(id, "Null id");
+        Preconditions.checkNotNull(name, "Null name");
+        Preconditions.checkArgument(ProfileLookup.isValidName(name), "Invalid name %s", name);
+        this.id = id;
+        this.name = name;
+        this.properties = properties;
+    }
+
+    public AccountProfile(UUID id, String name) {
+        this(id, name, null);
+    }
+
+    /**
+     * Get this player's uuid
+     *
+     * @return this players uuid
+     */
+    public UUID getId() {
+        return id;
+    }
+
+    /**
+     * Get this player's name
+     *
+     * @return this player's name
+     */
+    public String getName() {
+        return name;
+    }
+
+    /**
+     * Get a json array with this players propertes
+     *
+     * @return a json array with this player's properties or null if not retreived
+     * @throws IllegalStateException if the player's profiles haven't been looked up
+     */
+    public ProfileProperties getProperties() {
+        Preconditions.checkState(hasProperties(), "Profile %s has no properties", this);
+        return properties;
+    }
+
+    /**
+     * Return if the player has its profiles
+     *
+     * @return if the player has its properties
+     */
+    public boolean hasProperties() {
+        return properties != null;
+    }
+
+    /**
+     * Return the player's textures, or null if none
+     *
+     * @return the player's textures, or null if none
+     * @throws IllegalStateException if the player has no properties
+     */
+    public PlayerTextures getTextures() {
+        Preconditions.checkState(hasProperties(), "Profile %s has no properties", this);
+        return PlayerTextures.parseTextures(this);
+    }
+
+    /**
+     * Return the player if online
+     *
+     * @return the player, or null if none
+     */
+    public Player getPlayer() {
+        return Bukkit.getPlayer(this.getId());
+    }
+
+    /**
+     * Return the offline player
+     * <p>Should never return null, even if the player doesn't exist.2</p>
+     *
+     * @return the offline player
+     */
+    public OfflinePlayer getOfflinePlayer() {
+        return Bukkit.getOfflinePlayer(getId());
+    }
+
+    /**
+     * Return a version of this profile with no properties
+     * <p>
+     * Returns this object if this object has no properties
+     *
+     * @return a version of this profile with no properties
+     */
+    public AccountProfile clearProperties() {
+        return withProperties(null);
+    }
+
+    /**
+     * Lookup the properties if needed
+     * <p>
+     * Unlike {@link #lookupProperties()}, this only does a lookup if needed
+     * Looks up from the default lookup.
+     *
+     * @return the profile, with properties looked up
+     * @throws IllegalArgumentException if there is no player found with this profile
+     * @throws LookupFailedException    if unable to lookup properties
+     */
+    public AccountProfile withProperties() {
+        if (hasProperties()) {
+            return this;
+        } else {
+            return lookupProperties();
+        }
+    }
+
+    /**
+     * Return a copy of this profile with properties looked up from the default lookup
+     * <p>
+     * This is just a utility wrapper for {@link ProfileLookup#lookupProperties(AccountProfile)}
+     *
+     * @return a copy of this profile with updated properties
+     * @throws IllegalArgumentException if there is no player found with this profile
+     * @throws LookupFailedException    if unable to lookup properties
+     */
+    public AccountProfile lookupProperties() {
+        return withProperties(Bukkit.getProfileLookup().lookupProperties(this));
+    }
+
+    /**
+     * Return a copy of this profile with the given properties
+     * <p>
+     * Returns this object if the properties are the same as the current properties
+     *
+     * @param properties the properties to use for the new profile
+     * @return a copy of this profile with the given properties
+     */
+    public AccountProfile withProperties(ProfileProperties properties) {
+        return this.properties == properties ? this : new AccountProfile(getId(), getName(), properties);
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (obj == this) return true;
+        if (obj == null) return false;
+        if (obj.getClass() == AccountProfile.class) {
+            AccountProfile other = (AccountProfile) obj;
+            return other.getId().equals(this.getId())
+                    && other.getName().equals(this.getName())
+                    && Objects.equal(this.properties, other.properties);
+        }
+        return false;
+    }
+
+    @Override
+    public int hashCode() {
+        return getId().hashCode();
+    }
+
+    @Override
+    public String toString() {
+        return getName() + ": " + getId();
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/com/destroystokyo/paper/profile/EventProfileLookup.java b/src/main/java/com/destroystokyo/paper/profile/EventProfileLookup.java
new file mode 100644
index 0000000..4cb486d
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/profile/EventProfileLookup.java
@@ -0,0 +1,141 @@
+package com.destroystokyo.paper.profile;
+ 
+ import java.util.ArrayList;
+ import java.util.Collection;
+ import java.util.List;
+ import java.util.UUID;
+ 
+ import com.destroystokyo.paper.profile.event.AsyncPropertiesPreResolveEvent;
+ import com.google.common.base.Preconditions;
+ 
+ import org.bukkit.Bukkit;
+ import com.destroystokyo.paper.profile.event.AsyncNamePreResolveEvent;
+ import com.destroystokyo.paper.profile.event.AsyncProfileResolveEvent;
+ import com.destroystokyo.paper.profile.event.AsyncUUIDPreResolveEvent;
+ 
+ public class EventProfileLookup implements ProfileLookup {
+     private final ProfileLookup delegate;
+ 
+     public EventProfileLookup(ProfileLookup delegate) {
+         Preconditions.checkNotNull(delegate, "Null delegate");
+         this.delegate = Preconditions.checkNotNull(delegate, "Null delegate");;
+     }
+ 
+     @Override
+     public AccountProfile lookup(String name) {
+         Preconditions.checkNotNull(name, "Null name");
+         AsyncNamePreResolveEvent preResolveEvent = new AsyncNamePreResolveEvent(name);
+         Bukkit.getPluginManager().callEvent(preResolveEvent);
+         AsyncProfileResolveEvent resolveEvent;
+         if (preResolveEvent.isResolved()) { // Plugin set result
+             resolveEvent = new AsyncProfileResolveEvent(LookupCause.NAME_LOOKUP, preResolveEvent.getResult(), false);
+         } else {
+             // Lookup result from mojang
+             AccountProfile profile = delegate.lookup(name);
+             if (profile == null) return null; // Not found
+             resolveEvent = new AsyncProfileResolveEvent(LookupCause.NAME_LOOKUP, profile, true);
+         }
+         Bukkit.getPluginManager().callEvent(resolveEvent);
+         return resolveEvent.getResult();
+     }
+ 
+     @Override
+     public AccountProfile lookup(UUID id) {
+         Preconditions.checkNotNull(id, "Null id");
+         AsyncUUIDPreResolveEvent preResolveEvent = new AsyncUUIDPreResolveEvent(id);
+         Bukkit.getPluginManager().callEvent(preResolveEvent);
+         AsyncProfileResolveEvent resolveEvent;
+         if (preResolveEvent.isResolved()) { // Plugin set result
+             resolveEvent = new AsyncProfileResolveEvent(LookupCause.UUID_LOOKUP, preResolveEvent.getResult(), false);
+         } else {
+             // Lookup result from mojang
+             AccountProfile profile = delegate.lookup(id);
+             if (profile == null) return null; // Not found
+             resolveEvent = new AsyncProfileResolveEvent(LookupCause.UUID_LOOKUP, profile, true);
+         }
+         Bukkit.getPluginManager().callEvent(resolveEvent);
+         return resolveEvent.getResult();
+     }
+ 
+     @Override
+     public void lookupIds(Collection<UUID> ids, ProfileLookupCallback<UUID> callback) {
+         List<UUID> toLookup = new ArrayList<>(ids.size());
+         for (UUID id : ids) {
+             Preconditions.checkNotNull(id, "Null id");
+             AsyncUUIDPreResolveEvent preResolveEvent = new AsyncUUIDPreResolveEvent(id);
+             Bukkit.getPluginManager().callEvent(preResolveEvent);
+             if (preResolveEvent.isResolved()) { // Plugin set result
+                 AsyncProfileResolveEvent resolveEvent = new AsyncProfileResolveEvent(LookupCause.UUID_LOOKUP, preResolveEvent.getResult(), false);
+                 Bukkit.getPluginManager().callEvent(resolveEvent);
+                 callback.onLookup(resolveEvent.getResult(), id);
+             } else {
+                 toLookup.add(id);
+             }
+         }
+         delegate.lookupIds(toLookup, new ProfileLookupCallback<UUID>() {
+             @Override
+             public void onLookup(AccountProfile profile, UUID original) {
+                 if (profile != null) {
+                     AsyncProfileResolveEvent resolveEvent = new AsyncProfileResolveEvent(LookupCause.UUID_LOOKUP, profile, true);
+                     Bukkit.getPluginManager().callEvent(resolveEvent);
+                     profile = resolveEvent.getResult();
+                 }
+                 callback.onLookup(profile, original);
+             }
+ 
+             @Override
+             public void onLookupFailed(Throwable t, UUID original) {
+                 callback.onLookupFailed(t, original);
+             }
+         });
+     }
+ 
+     @Override
+     public void lookupNames(Collection<String> names, ProfileLookupCallback<String> callback) {
+         List<String> toLookup = new ArrayList<>(names.size());
+         for (String name : names) {
+             Preconditions.checkNotNull(name, "Null id");
+             AsyncNamePreResolveEvent preResolveEvent = new AsyncNamePreResolveEvent(name);
+             Bukkit.getPluginManager().callEvent(preResolveEvent);
+             if (preResolveEvent.isResolved()) { // Plugin set result
+                 AsyncProfileResolveEvent resolveEvent = new AsyncProfileResolveEvent(LookupCause.NAME_LOOKUP, preResolveEvent.getResult(), false);
+                 Bukkit.getPluginManager().callEvent(resolveEvent);
+                 callback.onLookup(resolveEvent.getResult(), name);
+             } else {
+                 toLookup.add(name);
+             }
+         }
+         delegate.lookupNames(toLookup, new ProfileLookupCallback<String>() {
+             @Override
+             public void onLookup(AccountProfile profile, String original) {
+                 if (profile != null) {
+                     AsyncProfileResolveEvent resolveEvent = new AsyncProfileResolveEvent(LookupCause.NAME_LOOKUP, profile, true);
+                     Bukkit.getPluginManager().callEvent(resolveEvent);
+                     profile = resolveEvent.getResult();
+                 }
+                 callback.onLookup(profile, original);
+             }
+ 
+             @Override
+             public void onLookupFailed(Throwable t, String original) {
+                 callback.onLookupFailed(t, original);
+             }
+         });
+     }
+ 
+     @Override
+     public ProfileProperties lookupProperties(AccountProfile profile) {
+         AsyncPropertiesPreResolveEvent preResolveEvent = new AsyncPropertiesPreResolveEvent(profile);
+         Bukkit.getPluginManager().callEvent(preResolveEvent);
+         AsyncProfileResolveEvent resolveEvent;
+         if (preResolveEvent.isResolved()) {
+             resolveEvent = new AsyncProfileResolveEvent(LookupCause.PROPERTIES_LOOKUP, preResolveEvent.getResult(), false);
+         } else {
+             ProfileProperties properties = delegate.lookupProperties(profile);
+             if (properties == null) return null;
+             resolveEvent = new AsyncProfileResolveEvent(LookupCause.PROPERTIES_LOOKUP, profile.withProperties(properties), true);
+         }
+         Bukkit.getPluginManager().callEvent(resolveEvent);
+         return resolveEvent.getResult().getProperties();
+     }
+ }
\ No newline at end of file
diff --git a/src/main/java/com/destroystokyo/paper/profile/LookupCause.java b/src/main/java/com/destroystokyo/paper/profile/LookupCause.java
new file mode 100644
index 0000000..9252c66
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/profile/LookupCause.java
@@ -0,0 +1,7 @@
+package com.destroystokyo.paper.profile;
+
+public enum LookupCause {
+    UUID_LOOKUP,
+    NAME_LOOKUP,
+    PROPERTIES_LOOKUP;
+}
\ No newline at end of file
diff --git a/src/main/java/com/destroystokyo/paper/profile/LookupFailedException.java b/src/main/java/com/destroystokyo/paper/profile/LookupFailedException.java
new file mode 100644
index 0000000..24dfdc3
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/profile/LookupFailedException.java
@@ -0,0 +1,19 @@
+package com.destroystokyo.paper.profile;
+
+/**
+ * Thrown when the lookup fails, for reason other then a profile not found
+ */
+public class LookupFailedException extends RuntimeException {
+    public LookupFailedException(Throwable cause) {
+        super(cause);
+    }
+
+    public LookupFailedException(String message, Throwable cause) {
+        super(message, cause);
+    }
+
+    public LookupFailedException(String s) {
+        super(s);
+    }
+
+}
\ No newline at end of file
diff --git a/src/main/java/com/destroystokyo/paper/profile/MojangLookup.java b/src/main/java/com/destroystokyo/paper/profile/MojangLookup.java
new file mode 100644
index 0000000..4aafd85
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/profile/MojangLookup.java
@@ -0,0 +1,45 @@
+package com.destroystokyo.paper.profile;
+ 
+ import java.util.Collection;
+ import java.util.UUID;
+ 
+ import com.google.common.base.Preconditions;
+ import com.google.common.collect.ImmutableList;
+ 
+ public final class MojangLookup implements ProfileLookup {
+ 
+     @Override
+     public AccountProfile lookup(String name) {
+         AccountProfile[] profileHolder = new AccountProfile[1];
+         lookupNames(ImmutableList.of(name), (profile, original) -> profileHolder[0] = profile);
+         return profileHolder[0];
+     }
+ 
+     @Override
+     public AccountProfile lookup(UUID id) {
+         return ProfileUtils.requestProfile(id).orElse(null);
+     }
+ 
+     @Override
+     public void lookupNames(Collection<String> names, final ProfileLookupCallback<String> callback) {
+         Preconditions.checkNotNull(callback, "Null callback");
+ 
+     }
+ 
+     @Override
+     public ProfileProperties lookupProperties(AccountProfile profile) {
+         AccountProfile newProfile = lookup(profile.getId());
+         Preconditions.checkArgument(newProfile != null, "%s doesn't exist", profile);
+         return newProfile.getProperties();
+     }
+ 
+     @Override
+     public boolean equals(Object obj) {
+         return obj instanceof MojangLookup;
+     }
+ 
+     @Override
+     public int hashCode() {
+         return 0;
+     }
+ }
\ No newline at end of file
diff --git a/src/main/java/com/destroystokyo/paper/profile/PlayerTextures.java b/src/main/java/com/destroystokyo/paper/profile/PlayerTextures.java
new file mode 100644
index 0000000..767e783
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/profile/PlayerTextures.java
@@ -0,0 +1,265 @@
+package com.destroystokyo.paper.profile;
+
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.Base64;
+import java.util.Map;
+
+import com.google.common.base.Charsets;
+import com.google.common.base.Preconditions;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.Iterables;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonParseException;
+import com.google.gson.JsonParser;
+
+/**
+ * A player's texture data, including skin and cape.
+ */
+ ++public final class PlayerTextures {
+    private final AccountProfile profile;
+    private final TextureData skinData, capeData;
+
+    public PlayerTextures(AccountProfile profile, TextureData skinData, TextureData capeData) {
+        Preconditions.checkNotNull(profile, "Null profile");
+        Preconditions.checkArgument(profile.hasProperties(), "No properties for %s", profile);
+        Preconditions.checkArgument(getProperty(profile.getProperties()) != null, "No texture data for %s", profile);
+        this.profile = profile;
+        this.skinData = skinData;
+        this.capeData = capeData;
+    }
+
+    /**
+     * Return the player's skin data, or null if the player has no skin
+     *
+     * @return the player's skin data, or null if none
+     */
+    public TextureData getSkinData() {
+        return skinData;
+    }
+
+    /**
+     * Return the player's cape data, or null if the player has no cape
+     *
+     * @return the player's cape data, or null if none
+     */
+    public TextureData getCapeData() {
+        return skinData;
+    }
+
+    /**
+     * Return the url of the player's skin, or null if the player has no skin
+     *
+     * @return the url of the player's skin, or null if none
+     */
+    public URL getSkin() {
+        return getSkinData() == null ? null : getSkinData().getUrl();
+    }
+
+    /**
+     * Return if the player has a skin
+     *
+     * @return the player has a skin
+     */
+    public boolean hasSkin() {
+        return getSkinData() != null;
+    }
+
+    /**
+     * Return if the player has a cape
+     *
+     * @return the player has a cape
+     */
+    public boolean hasCape() {
+        return getCapeData() != null;
+    }
+
+    /**
+     * Return the url of the player's cape, or null if the player has no cape
+     *
+     * @return the url of the player's cape, or null if none
+     */
+    public URL getCape() {
+        return getCapeData() == null ? null : getCapeData().getUrl();
+    }
+
+    /**
+     * Return if the player's skin has slim arms, or false if the player has no skin.
+     * <p>Alex style skins should return true. Steve style skins should return false.
+     * If the player has no skin, returns false.</p>
+     *
+     * @return if the player has slim arms
+     */
+    public boolean isSlimSkin() {
+        String model;
+        return hasSkin() && (model = getSkinData().getMetadata().get("model")) != null && model.equals("slim");
+    }
+
+    /**
+     * Get the profile this texture is associated with
+     *
+     * @return the profile
+     */
+    public AccountProfile getProfile() {
+        return profile;
+    }
+
+    public static PlayerTextures parseTextures(final AccountProfile profile) {
+        Preconditions.checkNotNull(profile, "Null profile");
+        Preconditions.checkArgument(profile.hasProperties(), "No properties for %s", profile);
+        ProfileProperty texture = getProperty(profile.getProperties());
+        if (texture == null) return null;
+        TextureData skinData = null;
+        TextureData capeData = null;
+        try {
+            JsonObject textureData = new JsonParser().parse(new String(Base64.getDecoder().decode(texture.getValue()), Charsets.UTF_8)).getAsJsonObject();
+            Preconditions.checkArgument(UUIDUtils.toMojangString(profile.getId()).equals(textureData.get("id").getAsString()), "Unexpected id: %s", textureData.get("id").getAsString());
+            JsonObject textures = textureData.get("textures").getAsJsonObject();
+            JsonObject skinJson = textures.getAsJsonObject("SKIN");
+            JsonObject capeJson = textures.getAsJsonObject("CAPE");
+            if (skinJson != null) {
+                String url = skinJson.getAsJsonPrimitive("url").getAsString();
+                ImmutableMap<String, String> metadata;
+                JsonObject metadataJson = skinJson.getAsJsonObject("metadata");
+                if (metadataJson != null) {
+                    ImmutableMap.Builder<String, String> metadataBuilder = ImmutableMap.builder();
+                    for (Map.Entry<String, JsonElement> entry : metadataJson.entrySet()) {
+                        metadataBuilder.put(entry.getKey(), entry.getValue().getAsString());
+                    }
+                    metadata = metadataBuilder.build();
+                } else {
+                    metadata = ImmutableMap.of();
+                }
+                skinData = new TextureData(url, metadata);
+            }
+            if (capeJson != null) {
+                String url = capeJson.getAsJsonPrimitive("url").getAsString();
+                ImmutableMap<String, String> metadata;
+                JsonObject metadataJson = capeJson.getAsJsonObject("metadata");
+                if (metadataJson != null) {
+                    ImmutableMap.Builder<String, String> metadataBuilder = ImmutableMap.builder();
+                    for (Map.Entry<String, JsonElement> entry : metadataJson.entrySet()) {
+                        metadataBuilder.put(entry.getKey(), entry.getValue().getAsString());
+                    }
+                    metadata = metadataBuilder.build();
+                } else {
+                    metadata = ImmutableMap.of();
+                }
+                capeData = new TextureData(url, metadata);
+            }
+            return new PlayerTextures(profile, skinData, capeData);
+        } catch (JsonParseException | ClassCastException | IllegalStateException e) { // IllegalStateException or ClassCastException is thrown by 'getAs()' methods
+            throw new IllegalArgumentException("Invalid json in textures", e);
+        }
+    }
+
+    private volatile Boolean signedByMojang;
+
+    /**
+     * Return if the texture has been singed by mojang
+     * <p>Clients will not accept textures that have not been signed by mojang.</p>
+     *
+     * @return if signed by mojang
+     */
+    public boolean isSignedByMojang() {
+        // Cache if we have a signature, to avoid verifying the texture twice
+        if (signedByMojang == null) {
+                synchronized (this) {
+                    if (signedByMojang == null) {
+                        signedByMojang = isSigned() && getProperty().isSignedByMojang();
+                    }
+                }
+        }
+        return signedByMojang;
+    }
+
+    /**
+     * Return if the texture has a signature.
+     *
+     * @return if the texture has a signature
+     */
+    public boolean isSigned() {
+        return getProperty().isSigned();
+    }
+
+    public ProfileProperty getProperty() {
+        return getProperty(profile.getProperties());
+    }
+
+    private static ProfileProperty getProperty(ProfileProperties properties) {
+        // Don't worry, getProperties() is immutable and IterableSet has a defined iteration order
+        return Iterables.getFirst(properties.getProperties("textures"), null);
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+
+        PlayerTextures that = (PlayerTextures) o;
+
+        if (!profile.equals(that.profile)) return false;
+        if (skinData != null ? !skinData.equals(that.skinData) : that.skinData != null) return false;
+        return !(capeData != null ? !capeData.equals(that.capeData) : that.capeData != null);
+
+    }
+
+    @Override
+    public int hashCode() {
+        return profile.hashCode();
+    }
+
+    public static final class TextureData {
+        private final URL url;
+        private final ImmutableMap<String, String> metadata;
+
+        public URL getUrl() {
+            return url;
+        }
+
+        public ImmutableMap<String, String> getMetadata() {
+            return metadata;
+        }
+
+        public TextureData(String url, ImmutableMap<String, String> metadata) {
+            Preconditions.checkNotNull(url, "Null url");
+            Preconditions.checkNotNull(metadata, "Null metadata");
+            try {
+                this.url = new URL(url);
+                this.metadata = metadata;
+            } catch (MalformedURLException e) {
+                throw new IllegalArgumentException("Invalid url " + url, e);
+            }
+        }
+
+        public TextureData(URL url, ImmutableMap<String, String> metadata) {
+            Preconditions.checkNotNull(url, "Null url");
+            Preconditions.checkNotNull(metadata, "Null metadata");
+            this.url = url;
+            this.metadata = metadata;
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (o == null || getClass() != o.getClass()) return false;
+
+            TextureData data = (TextureData) o;
+
+            if (!url.equals(data.url)) return false;
+            return metadata.equals(data.metadata);
+
+        }
+
+        @Override
+        public int hashCode() {
+            return url.hashCode();
+        }
+
+        @Override
+        public String toString() {
+            return url.toString();
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/com/destroystokyo/paper/profile/ProfileLookup.java b/src/main/java/com/destroystokyo/paper/profile/ProfileLookup.java
new file mode 100644
index 0000000..65e9732
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/profile/ProfileLookup.java
@@ -0,0 +1,193 @@
+package com.destroystokyo.paper.profile;
+
+import java.util.Collection;
+import java.util.UUID;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import com.google.common.collect.ImmutableList;
+
+public interface ProfileLookup {
+
+    /**
+     * A regex of valid minecraft usernames
+     * <p>
+     * We have to accept spaces due to this bug: https://www.reddit.com/r/Minecraft/comments/276wcb/psa_usernames_can_contain_spaces_this_effectively/
+     * We also have to accept names less than 3 characters
+     */
+    public static final Pattern NAME_PATTERN = Pattern.compile("[ \\w]{1,16}+");
+
+    /**
+     * Return if the name is valid
+     * <p>
+     * This does not mean there is a player with a name, but that there *could* be a player with that name
+     *
+     * @param s the name to check
+     * @return true if valid
+     */
+    public static boolean isValidName(String s) {
+        Matcher m = NAME_PATTERN.matcher(s);
+        return m.matches();
+    }
+
+    /**
+     * Lookup a profile with the given name
+     * <p>
+     * Returns null if there is no player with the given name.
+     * The returned player profile may or may not include properties
+     * If properties are needed, proceed to use a property lookup
+     *
+     * @param name look for a profile with this name
+     * @return a profile with the given name, or null if there is no player
+     * @throws LookupFailedException if unable to lookup
+     * @throws NullPointerException if
+     */
+    public AccountProfile lookup(String name);
+
+    /**
+     * Lookup a profile with the given uuid
+     * <p>
+     * Returns null if there is no player with the given name.
+     * The looked up profiles may or may not include properties
+     * If properties are needed, proceed to use a property lookup
+     *
+     * @param id look for a profile with this uuid
+     * @return a profile with the given id
+     * @throws LookupFailedException if unable to lookup
+     */
+    public AccountProfile lookup(UUID id);
+
+    /**
+     * Lookup a profile with the given name
+     * <p>
+     * The looked up profiles may or may not include properties
+     * If properties are needed, proceed to use a property lookup
+     *
+     * @param name     look for a profile with this name
+     * @param callback the callback to handle the result of the lookups
+     */
+    public default void lookup(String name, ProfileLookupCallback<String> callback) {
+        try {
+            AccountProfile profile = lookup(name);
+            callback.onLookup(profile, name);
+        } catch (LookupFailedException e) {
+            callback.onLookupFailed(e.getCause(), name);
+        } catch (Throwable t) {
+            callback.onLookupFailed(t, name);
+        }
+    }
+
+    /**
+     * Lookup a profile with the given id
+     * <p>
+     * The returned player profile may or may not include properties
+     * If properties are needed, proceed to use a property lookup
+     *
+     * @param id       look for a profile with this id
+     * @param callback the callback to handle the result of the lookups
+     */
+    public default void lookup(UUID id, ProfileLookupCallback<UUID> callback) {
+        try {
+            AccountProfile profile = lookup(id);
+            callback.onLookup(profile, id);
+        } catch (LookupFailedException e) {
+            callback.onLookupFailed(e.getCause(), id);
+        } catch (Throwable t) {
+            callback.onLookupFailed(t, id);
+        }
+    }
+
+    /**
+     * Lookup all profiles with the given ids, earring on non-existent players
+     * <p>
+     * The returned profiles may or may not include properties
+     * If properties are needed, proceed to use a property lookup
+     * <p>
+     * Use the callback version of the method if you want to handle (or ignore) non-existent players.
+     * The ordering of the returned profiles may or may not coincide with the ordering of the passed collection.
+     * Therefore, if you need the original id that you used for lookup, you should use the callback-version,
+     *
+     * @param ids the ids to lookup
+     * @return the resulting profiles
+     * @throws LookupFailedException    if lookup fails
+     * @throws IllegalArgumentException if one of the ids doesn't exist
+     */
+    public default ImmutableList<AccountProfile> lookupIds(Collection<UUID> ids) {
+        ImmutableList.Builder<AccountProfile> profileBuilder = ImmutableList.builder();
+        lookupIds(ids, ProfileLookupCallback.assumeFound((profile, original) -> profileBuilder.add(profile)));
+        return profileBuilder.build();
+    }
+
+    /**
+     * Lookup all profiles with the given names, ignoring non-existent profiles
+     * <p>
+     * The looked up profiles may or may not include properties
+     * If properties are needed, proceed to use a property lookup
+     * <p>
+     * Use the callback version of the method if you want to handle (or ignore) non-existent players.
+     * The ordering of the returned profiles may or may not coincide with the ordering of the passed collection.
+     * Therefore, if you need the original name that you used for lookup, you should use the callback-version,
+     *
+     * @param names the names to lookup
+     * @return the resulting profiles
+     * @throws LookupFailedException    if lookup fails
+     * @throws IllegalArgumentException if one of the names doesn't exist
+     */
+    public default ImmutableList<AccountProfile> lookupNames(Collection<String> names) {
+        ImmutableList.Builder<AccountProfile> profileBuilder = ImmutableList.builder();
+        lookupNames(names, ProfileLookupCallback.assumeFound((profile, original) -> profileBuilder.add(profile)));
+        return profileBuilder.build();
+    }
+
+    /**
+     * Lookup all profiles with the given ids
+     * <p>
+     * The looked up profiles may or may not include properties
+     * If properties are needed, proceed to use a property lookup
+     * <p>
+     * Blocks until the lookups complete
+     *
+     * @param ids      the ids to lookup
+     * @param callback the callback to handle the lookups
+     */
+    public default void lookupIds(Collection<UUID> ids, ProfileLookupCallback<UUID> callback) {
+        ids.forEach((id) -> lookup(id, callback));
+    }
+
+    /**
+     * Lookup all profiles with the given names
+     * <p>
+     * The looked up profiles may or may not include properties
+     * If properties are needed, proceed to use a property lookup
+     * <p>
+     * Blocks until the lookups complete
+     *
+     * @param names    the names to lookup
+     * @param callback the callback to handle the lookups
+     */
+    public default void lookupNames(Collection<String> names, ProfileLookupCallback<String> callback) {
+        names.forEach((name) -> lookup(name, callback));
+    }
+
+    /**
+     * Lookup the player's properties
+     * <p>
+     * Should never return null
+     *
+     * @param profile the profile to lookup properties for
+     * @return the player's properties
+     * @throws IllegalArgumentException if there is no player with the given name/uuid
+     * @throws LookupFailedException    if unable to lookup properties
+     */
+    public ProfileProperties lookupProperties(AccountProfile profile);
+
+    /**
+     * Return if the lookups have the same underlying source
+     * <p>
+     * Two lookups are considered equal if they use the same underlying source
+     *
+     * @param other the object to check equality with
+     * @return if equal
+     */
+    public boolean equals(Object other);
+}
\ No newline at end of file
diff --git a/src/main/java/com/destroystokyo/paper/profile/ProfileLookupCallback.java b/src/main/java/com/destroystokyo/paper/profile/ProfileLookupCallback.java
new file mode 100644
index 0000000..7c060ec
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/profile/ProfileLookupCallback.java
@@ -0,0 +1,51 @@
+package com.destroystokyo.paper.profile;
+
+import com.google.common.base.Preconditions;
+
+/**
+ * A callback for profile lookup
+ * <p/>
+ * Methods may be called multiple times in a bulk lookup.
+ * <b>Just because a success method is called, doesn't mean the lookup wont fail!</b>
+ * Callbacks should take this into account, and wait till completion to handle
+ *
+ * @param <T> the key that is being looked up
+ */
+@FunctionalInterface
+public interface ProfileLookupCallback<T> {
+
+    /**
+     * Calls when a lookup succeeds
+     * <p>
+     * Profile may not be null if the player doesn't exist
+     *
+     * @param profile  the profile that was found, or null if the player
+     * @param original the key that was being looked up
+     */
+    public void onLookup(AccountProfile profile, T original);
+
+    /**
+     * Called when a lookup fails
+     *
+     * @param t        the exception that was caught, may be null
+     * @param original the key that was being looked up
+     */
+    public default void onLookupFailed(Throwable t, T original) {
+        throw new LookupFailedException("Unable to lookup " + original.toString(), t);
+    }
+
+    public static <T> ProfileLookupCallback<T> assumeFound(ProfileLookupCallback<T> delegate) {
+        return new ProfileLookupCallback<T>() {
+            @Override
+            public void onLookup(AccountProfile profile, T original) {
+                Preconditions.checkArgument(profile != null, "%s doesn't exist", original);
+                delegate.onLookup(profile, original);
+            }
+
+            @Override
+            public void onLookupFailed(Throwable t, T original) {
+                delegate.onLookupFailed(t, original);
+            }
+        };
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/com/destroystokyo/paper/profile/ProfileProperties.java b/src/main/java/com/destroystokyo/paper/profile/ProfileProperties.java
new file mode 100644
index 0000000..604afc0
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/profile/ProfileProperties.java
@@ -0,0 +1,112 @@
+package com.destroystokyo.paper.profile;
+ 
+ import java.util.Collection;
+ import java.util.Map;
+ import java.util.function.BiConsumer;
+ 
+ import com.google.common.base.Preconditions;
+ import com.google.common.collect.ImmutableSet;
+ import com.google.common.collect.ImmutableSetMultimap;
+ import com.google.common.collect.SetMultimap;
+ 
+ public final class ProfileProperties {
+     private final ImmutableSetMultimap<String, ProfileProperty> properties;
+ 
+     private ProfileProperties(ImmutableSetMultimap<String, ProfileProperty> properties) {
+         this.properties = Preconditions.checkNotNull(properties);;
+     }
+ 
+     public static final ProfileProperties EMPTY = new ProfileProperties(ImmutableSetMultimap.of());
+ 
+     public ImmutableSet<ProfileProperty> getProperties(String name) {
+         return properties.get(name);
+     }
+ 
+     /**
+      * Get a single property with the given name
+      * <p>
+      * Throws an exception if there is more than one, or none at all
+      *
+      * @param name the name of the property to get
+      * @return the only property with the given name
+      * @throws IllegalStateException if there are no properties
+      * @throws IllegalStateException if there are more than one property with the name
+      */
+     public ProfileProperty getOnlyProperty(String name) {
+         ImmutableSet<ProfileProperty> properties = getProperties(name);
+         Preconditions.checkState(!properties.isEmpty(), "No properties named %s", name);
+         Preconditions.checkState(properties.size() == 1, "%s properties named %s", properties.size(), name);
+         return properties.iterator().next();
+     }
+ 
+     public boolean hasProperty(String name) {
+         return !getProperties(name).isEmpty();
+     }
+ 
+     public static ProfileProperties copyOf(Collection<ProfileProperty> properties) {
+         Builder builder = new Builder();
+         properties.forEach(builder::put);
+         return builder.build();
+     }
+ 
+     public static ProfileProperties copyOf(SetMultimap<String, ProfileProperty> originalMultimap) {
+         Preconditions.checkNotNull(originalMultimap, "Null multimap");
+         ImmutableSetMultimap<String, ProfileProperty> multimap = ImmutableSetMultimap.copyOf(originalMultimap);
+         if (multimap.isEmpty()) return EMPTY;
+         for (Map.Entry<String, ProfileProperty> entry : multimap.entries()) {
+             String name = entry.getKey();
+             ProfileProperty property = entry.getValue();
+             Preconditions.checkArgument(property.getName().equals(name), "Property %s with key %s", property, name);
+         }
+         return new ProfileProperties(multimap);
+     }
+ 
+     public int size() {
+         return properties.size();
+     }
+ 
+     public boolean isEmpty() {
+         return properties.isEmpty();
+     }
+ 
+     @Override
+     public boolean equals(Object obj) {
+         return obj instanceof ProfileProperties && ((ProfileProperties) obj).properties.equals(this.properties);
+     }
+ 
+     public void forEach(BiConsumer<String, ProfileProperty> consumer) {
+         for (Map.Entry<String, ProfileProperty> entry : properties.entries()) {
+             consumer.accept(entry.getKey(), entry.getValue());
+         }
+     }
+ 
+     public static ProfileProperties.Builder builder() {
+         return new Builder();
+     }
+ 
+     public final static class Builder {
+         private final ImmutableSetMultimap.Builder<String, ProfileProperty> builder = ImmutableSetMultimap.builder();
+         private int size;
+ 
+         public void put(ProfileProperty property) {
+             Preconditions.checkNotNull(property, "Null property");
+             put0(property.getName(), property);
+         }
+ 
+         public void put(String name, ProfileProperty value) {
+             Preconditions.checkNotNull(name, "Null name");
+             Preconditions.checkNotNull(value, "Null property");
+             Preconditions.checkArgument(name.equals(value.getName()), "Name %s doesn't match property %s", name, value);
+             put0(name, value);
+         }
+ 
+         private void put0(String name, ProfileProperty property) {
+             builder.put(name, property);
+             size++;
+         }
+ 
+         public ProfileProperties build() {
+             return size == 0 ? EMPTY : new ProfileProperties(builder.build());
+         }
+     }
+ }
\ No newline at end of file
diff --git a/src/main/java/com/destroystokyo/paper/profile/ProfileProperty.java b/src/main/java/com/destroystokyo/paper/profile/ProfileProperty.java
new file mode 100644
index 0000000..321c3c0
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/profile/ProfileProperty.java
@@ -0,0 +1,128 @@
+package com.destroystokyo.paper.profile;
+
+import java.io.BufferedInputStream;
+import java.io.IOException;
+import java.security.InvalidKeyException;
+import java.security.KeyFactory;
+import java.security.NoSuchAlgorithmException;
+import java.security.PublicKey;
+import java.security.Signature;
+import java.security.SignatureException;
+import java.security.spec.InvalidKeySpecException;
+import java.security.spec.X509EncodedKeySpec;
+import java.util.Base64;
+
+import com.google.common.base.Preconditions;
+import com.google.common.io.ByteStreams;
+
+public final class ProfileProperty {
+    private final String name, value, signature;
+
+    public ProfileProperty(String name, String value, String signature) {
+        this.name = Preconditions.checkNotNull(name, "Name of the property can't be null");
+        this.value = Preconditions.checkNotNull(value, "Value of the property can't be null");
+        this.signature = signature;
+    }
+
+    public ProfileProperty(String name, String value) {
+        this(name, value, null);
+    }
+
+    /**
+     * Return the name of this property
+     *
+     * @return the name of this property
+     */
+    public String getName() {
+        return name;
+    }
+
+    /**
+     * Return the value of this property
+     *
+     * @return the value of this property
+     */
+    public String getValue() {
+        return value;
+    }
+
+    /**
+     * Return the signature of this property
+     * <p>
+     * This performs no verification of the returned signature.
+     *
+     * @return the signature of this property
+     * @throws IllegalStateException if the property is not singed
+     */
+    public String getSignature() {
+        Preconditions.checkState(signature != null, "Property is not signed");
+        return signature;
+    }
+
+    /**
+     * Return if the property is signed
+     *
+     * @return if the property is signed
+     */
+    public boolean isSigned() {
+        return signature != null;
+    }
+
+    /**
+     * Return if the signature is valid with the specified public key
+     *
+     * @param key the public key
+     * @return if valid
+     * @throws IllegalArgumentException if the key is invalid
+     * @throws IllegalStateException    if the property is not signed
+     * @throws RuntimeException         if unable to verify for some other reason
+     */
+    public boolean isSignatureValid(PublicKey key) {
+        try {
+            Signature signature = Signature.getInstance("SHA1withRSA");
+            signature.initVerify(key);
+            signature.update(this.value.getBytes());
+            return signature.verify(Base64.getDecoder().decode(getSignature()));
+        } catch (InvalidKeyException e) {
+            throw new IllegalArgumentException("Invalid key", e);
+        } catch (SignatureException e) {
+            throw new RuntimeException("Unable to verify", e);
+        } catch (NoSuchAlgorithmException e) {
+            throw new AssertionError("Couldn't find required algorithm", e);
+        }
+    }
+
+    /**
+     * Return if the signature has been signed by mojang
+     *
+     * @return if valid with mojang
+     * @throws IllegalStateException if the property is not signed
+     * @throws RuntimeException      if unable to verify for some other reason
+     */
+    public boolean isSignedByMojang() {
+        try {
+            return isSignatureValid(YGGDRASIL_PUBLIC_KEY);
+        } catch (IllegalArgumentException e) {
+            throw new RuntimeException("Invalid mojang key", e);
+        }
+    }
+
+    public static final PublicKey YGGDRASIL_PUBLIC_KEY;
+
+    static {
+        try (
+                // NOTE: Update this if yggdrasil public key location changes
+                BufferedInputStream in = new BufferedInputStream(ProfileProperty.class.getResourceAsStream("/yggdrasil_session_pubkey.der"))
+        ) {
+            X509EncodedKeySpec spec = new X509EncodedKeySpec(ByteStreams.toByteArray(in));
+            KeyFactory factory = KeyFactory.getInstance("RSA");
+            YGGDRASIL_PUBLIC_KEY = factory.generatePublic(spec);
+        } catch (InvalidKeySpecException e) {
+            throw new AssertionError("Missing/invalid yggdrasil public key!", e);
+        } catch (IOException e) {
+            throw new AssertionError("Couldn't load key", e);
+        } catch (NoSuchAlgorithmException e) {
+            throw new AssertionError("Missing RSA", e);
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/com/destroystokyo/paper/profile/ProfileUtils.java b/src/main/java/com/destroystokyo/paper/profile/ProfileUtils.java
new file mode 100644
index 0000000..3a9a723
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/profile/ProfileUtils.java
@@ -0,0 +1,290 @@
+package com.destroystokyo.paper.profile;
+ 
+ import java.io.BufferedReader;
+ import java.io.BufferedWriter;
+ import java.io.IOException;
+ import java.io.InputStreamReader;
+ import java.io.OutputStreamWriter;
+ import java.net.HttpURLConnection;
+ import java.net.MalformedURLException;
+ import java.net.URL;
+ import java.util.List;
+ import java.util.Map;
+ import java.util.Optional;
+ import java.util.UUID;
+ 
+ import com.destroystokyo.paper.utils.json.ProfilePropertyTypeAdapter;
+ import com.destroystokyo.paper.utils.json.UUIDTypeAdapter;
+ import com.google.common.base.Charsets;
+ import com.google.common.base.Preconditions;
+ import com.google.common.collect.ImmutableList;
+ import com.google.common.collect.ImmutableSet;
+ import com.google.common.collect.UnmodifiableIterator;
+ import com.google.common.net.HttpHeaders;
+ import com.google.gson.Gson;
+ import com.google.gson.GsonBuilder;
+ import com.google.gson.JsonIOException;
+ import com.google.gson.JsonParseException;
+ import com.google.gson.stream.JsonReader;
+ import com.google.gson.stream.JsonWriter;
+ import com.mojang.authlib.GameProfile;
+ import com.mojang.authlib.properties.Property;
+ import com.mojang.authlib.properties.PropertyMap;
+ 
+ import static com.destroystokyo.paper.profile.UUIDUtils.fromString;
+ import static com.destroystokyo.paper.profile.UUIDUtils.toMojangString;
+ 
+ public class ProfileUtils {
+ 
+     private static final Gson GSON = new GsonBuilder()
+             .registerTypeAdapter(UUID.class, UUIDTypeAdapter.createMojang())
+             .registerTypeAdapter(ProfileProperty.class, new ProfilePropertyTypeAdapter())
+             .create();
+ 
+     public static Optional<AccountProfile> requestProfile(UUID id) {
+         Preconditions.checkNotNull(id, "Null id");
+         try {
+             URL url = new URL("https://sessionserver.mojang.com/session/minecraft/profile/" + toMojangString(id) + "?unsigned=false");
+             HttpURLConnection connection = (HttpURLConnection) url.openConnection();
+             connection.connect();
+             if (connection.getResponseCode() == HttpURLConnection.HTTP_NO_CONTENT) {
+                 return Optional.empty(); // Profile not found
+             }
+             if (connection.getResponseCode() == 429) {
+                 throw new LookupFailedException("Mojang rate limited request for: " + id);
+             }
+             try (BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), Charsets.UTF_8))) {
+                 ProfileResponse response = GSON.fromJson(reader, ProfileResponse.class);
+ 
+                 if (response.errorMessage != null) {
+                     throw new LookupFailedException("Mojang returned error: " + response.errorMessage);
+                 } else if (response.id == null || response.name == null || response.profile == null) {
+                     throw new LookupFailedException("Unknown error looking up " + id.toString());
+                 }
+ 
+                 return Optional.of(new AccountProfile(response.id, response.name, ProfileProperties.copyOf(response.profile)));
+             }
+         } catch (JsonIOException e) {
+             throw new LookupFailedException("Error contacting mojang", e.getCause());
+         } catch (MalformedURLException e) {
+             // This shouldn't happen as UUID.toString() is a perfectly valid url
+             throw new AssertionError("Unable to parse url " + e);
+         } catch (IOException | JsonParseException e) {
+             throw new LookupFailedException("Error contacting mojang", e);
+         }
+     }
+ 
+     private static class ProfileResponse {
+         private String errorMessage;
+         private UUID id;
+         private String name;
+         private List<ProfileProperty> profile;
+     }
+ 
+     public static Optional<AccountProfile> lookup(String name) {
+         Preconditions.checkNotNull(name, "Null name");
+         Preconditions.checkArgument(ProfileLookup.isValidName(name), "Invalid name %s", name);
+         try {
+             URL url = new URL("https://api.mojang.com/users/profiles/minecraft/" + name);
+             HttpURLConnection connection = (HttpURLConnection) url.openConnection();
+             connection.connect();
+             if (connection.getResponseCode() == HttpURLConnection.HTTP_NO_CONTENT) {
+                 return Optional.empty(); // Profile not found
+             }
+             if (connection.getResponseCode() == 429) {
+                 throw new LookupFailedException("Mojang rate limited request for: " + name);
+             }
+ 
+             try (JsonReader reader = new JsonReader(new BufferedReader(new InputStreamReader(connection.getInputStream(), Charsets.UTF_8)))) {
+                 reader.beginObject();
+                 UUID id = null;
+                 name = null; // Reset to null so we can check for errors
+                 while (reader.hasNext()) {
+                     String key;
+                     switch ((key = reader.nextName())) {
+                         case "id":
+                             String s = reader.nextString();
+                             if (s == null) throw new LookupFailedException("Mojang returned null id");
+                             id = fromString(s);
+                             break;
+                         case "name":
+                             name = reader.nextString(); // Now reset to case-corrected name
+                             if (name == null) throw new LookupFailedException("Mojang returned null name");
+                             break;
+                         case "legacy":
+                         case "demo":
+                             break;
+                         default:
+                             throw new LookupFailedException("Invalid json, unexpected object key: " + key);
+                     }
+                 }
+ 
+                 if (id == null) {
+                     throw new LookupFailedException("Mojang didn't return id");
+                 } else if (name == null) {
+                     throw new LookupFailedException("Mojang didn't return name");
+                 }
+                 reader.endObject();
+                 if (reader.hasNext()) {
+                     throw new LookupFailedException("Didn't read all data mojang sent. Unexpected " + reader.peek());
+                 }
+                 return Optional.of(new AccountProfile(id, name));
+             }
+         } catch (JsonIOException e) {
+             throw new LookupFailedException("Error contacting mojang", e.getCause());
+         } catch (MalformedURLException e) {
+             // This shouldn't happen as names are perfectly valid urls
+             throw new AssertionError("Unable to parse url " + e);
+         } catch (IOException | JsonParseException e) {
+             throw new LookupFailedException("Error contacting mojang", e);
+         }
+     }
+ 
+     public static final URL BULK_NAME_LOOKUP_URL;
+ 
+     static {
+         try {
+             BULK_NAME_LOOKUP_URL = new URL("https://api.mojang.com/profiles/minecraft");
+         } catch (MalformedURLException e) {
+             throw new AssertionError("Couldn't  parse URL", e);
+         }
+     }
+ 
+     public static ImmutableList<AccountProfile> lookupNames(ImmutableSet<String> names) {
+         Preconditions.checkNotNull(names, "Null names");
+         if (names.isEmpty()) return ImmutableList.of();
+         if (names.size() > 100) {
+             ImmutableList.Builder<AccountProfile> result = ImmutableList.builder();
+             // Split up the request to meet mojang's limit of 100 names per request
+             UnmodifiableIterator<String> iterator = names.iterator();
+             while (iterator.hasNext()) {
+                 ImmutableSet.Builder<String> split = ImmutableSet.builder();
+                 for (int i = 0; i < 100 && iterator.hasNext(); i++) {
+                     String name = iterator.next();
+                     split.add(name);
+                 }
+                 result.addAll(lookupNames(split.build()));
+             }
+             return result.build();
+         }
+         try {
+             HttpURLConnection connection = (HttpURLConnection) BULK_NAME_LOOKUP_URL.openConnection();
+             connection.setDoOutput(true);
+             connection.setRequestProperty(HttpHeaders.CONTENT_TYPE, "application/json");
+             connection.connect();
+             if (connection.getResponseCode() == 429) {
+                 throw new LookupFailedException("Mojang rate limited request for " + names.size() + " names");
+             }
+             try (JsonWriter writer = new JsonWriter(new BufferedWriter(new OutputStreamWriter(connection.getOutputStream(), Charsets.UTF_8)))) {
+                 writer.beginArray();
+                 for (String name : names) {
+                     writer.value(name);
+                 }
+                 writer.endArray();
+             }
+             ImmutableList.Builder<AccountProfile> profiles = ImmutableList.builder();
+             try (JsonReader reader = new JsonReader(new BufferedReader(new InputStreamReader(connection.getInputStream(), Charsets.UTF_8)))) {
+                 reader.beginArray();
+                 while (reader.hasNext()) {
+                     reader.beginObject();
+                     UUID id = null;
+                     String name = null;
+                     while (reader.hasNext()) {
+                         String key;
+                         switch ((key = reader.nextName())) {
+                             case "id":
+                                 String s = reader.nextString();
+                                 if (s == null) throw new LookupFailedException("Mojang returned null id");
+                                 id = fromString(s);
+                                 break;
+                             case "name":
+                                 name = reader.nextString();
+                                 if (name == null) throw new LookupFailedException("Mojang returned null name");
+                                 break;
+                             case "legacy":
+                             case "demo":
+                                 break;
+                             default:
+                                 throw new LookupFailedException("Invalid json. Unexpected object key: " + key);
+                         }
+                     }
+ 
+                     if (id == null) {
+                         throw new LookupFailedException("Mojang didn't return id");
+                     } else if (name == null) {
+                         throw new LookupFailedException("Mojang didn't return name");
+                     }
+                     profiles.add(new AccountProfile(id, name));
+                     reader.endObject();
+                 }
+                 reader.endArray();
+                 if (reader.hasNext()) {
+                     throw new LookupFailedException("Didn't read response fully. Unexpected: " + reader.peek());
+                 }
+                 return profiles.build();
+             }
+         } catch (IOException e) {
+             throw new LookupFailedException("Error contacting mojang", e);
+         }
+     }
+ 
+     //
+     // Converters
+     //
+ 
+     public static GameProfile toMojang(AccountProfile paper) {
+         if (paper == null) return null;
+         GameProfile mojang = new GameProfile(paper.getId(), paper.getName());
+         if (paper.hasProperties()) {
+             mojang.getProperties().clear();
+             addAllToMojang(paper.getProperties(), mojang.getProperties());
+         }
+         return mojang;
+     }
+ 
+     public static AccountProfile toPaper(GameProfile mojang) {
+         if (mojang == null) return null;
+         // If the profile's properties aren't empty, we must know them
+         return toPaper0(mojang, !mojang.getProperties().isEmpty());
+     }
+ 
+     public static AccountProfile toPaperWithProperties(GameProfile mojang) {
+         if (mojang == null) return null;
+         return toPaper0(mojang, true);
+     }
+ 
+     private static AccountProfile toPaper0(GameProfile mojang, boolean propertiesKnown) {
+         Preconditions.checkArgument(mojang.isComplete(), "Incomplete profile %s", mojang);
+         return new AccountProfile(mojang.getId(), mojang.getName(), propertiesKnown ? toPaper(mojang.getProperties()) : null);
+     }
+ 
+     public static PropertyMap toMojang(ProfileProperties paper) {
+         if (paper == null) return null;
+         PropertyMap mojang = new PropertyMap();
+         addAllToMojang(paper, mojang);
+         return mojang;
+     }
+ 
+     private static void addAllToMojang(ProfileProperties paper, PropertyMap mojang) {
+         paper.forEach((name, property) -> mojang.put(name, toMojang(property)));
+     }
+ 
+     public static ProfileProperties toPaper(PropertyMap mojang) {
+         if (mojang == null) return null;
+         ProfileProperties.Builder builder = ProfileProperties.builder();
+         for (Map.Entry<String, Property> entry : mojang.entries()) {
+             builder.put(entry.getKey(), toPaper(entry.getValue()));
+         }
+         return builder.build();
+     }
+ 
+     public static Property toMojang(ProfileProperty paper) {
+         if (paper == null) return null;
+         return new Property(paper.getName(), paper.getValue(), paper.isSigned() ? paper.getSignature() : null);
+     }
+ 
+     public static ProfileProperty toPaper(Property mojang) {
+         if (mojang == null) return null;
+         return new ProfileProperty(mojang.getName(), mojang.getValue(), mojang.getSignature());
+     }
+ }
\ No newline at end of file
diff --git a/src/main/java/com/destroystokyo/paper/profile/UUIDUtils.java b/src/main/java/com/destroystokyo/paper/profile/UUIDUtils.java
new file mode 100644
index 0000000..3146d6c
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/profile/UUIDUtils.java
@@ -0,0 +1,56 @@
+package com.destroystokyo.paper.profile;
+ 
+ import java.util.UUID;
+ 
+ import com.destroystokyo.paper.utils.Hex;
+ import com.google.common.base.Preconditions;
+ import com.google.common.primitives.Longs;
+ 
+ public class UUIDUtils {
+     private UUIDUtils() {}
+ 
+     public static String toMojangString(UUID id) {
+         Preconditions.checkNotNull(id, "Null id");
+         return Hex.encodeString(toBytes(id));
+     }
+ 
+     public static UUID fromString(String s) {
+         Preconditions.checkNotNull(s, "Null string");
+         if (s.length() == 36) { // UUID.toString() uuid
+             s = s.replace("-", "");
+         } else if (s.length() != 32) {
+             throw new IllegalArgumentException("Invalid UUID: " + s);
+         }
+         try {
+             return fromBytes(Hex.decode(s));
+         } catch (IllegalArgumentException e) {
+             throw new IllegalArgumentException("Invalid UUID: " + s);
+         }
+     }
+ 
+     public static byte[] toBytes(UUID id) {
+         Preconditions.checkNotNull(id, "Null id");
+         byte[] result = new byte[16];
+         long lsb = id.getLeastSignificantBits();
+         for (int i = 15; i >= 8; i--) {
+             result[i] = (byte) (lsb & 0xffL);
+             lsb >>= 8;
+         }
+         long msb = id.getMostSignificantBits();
+         for (int i = 7; i >= 0; i--) {
+             result[i] = (byte) (msb & 0xffL);
+             msb >>= 8;
+         }
+         return result;
+     }
+ 
+     public static UUID fromBytes(byte[] bytes) {
+         Preconditions.checkNotNull(bytes, "Null bytes");
+         Preconditions.checkArgument(bytes.length == 16, "Invalid length: %s", bytes.length);
+         long msb = Longs.fromBytes(bytes[0], bytes[1], bytes[2], bytes[3],
+                 bytes[4], bytes[5], bytes[6], bytes[7]);
+         long lsb = Longs.fromBytes(bytes[8], bytes[9], bytes[10], bytes[11],
+                 bytes[12], bytes[13], bytes[14], bytes[15]);
+         return new UUID(msb, lsb);
+     }
+ }
\ No newline at end of file
diff --git a/src/main/java/com/destroystokyo/paper/profile/event/AsyncNamePreResolveEvent.java b/src/main/java/com/destroystokyo/paper/profile/event/AsyncNamePreResolveEvent.java
new file mode 100644
index 0000000..7008e72
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/profile/event/AsyncNamePreResolveEvent.java
@@ -0,0 +1,55 @@
+package com.destroystokyo.paper.profile.event;
+ 
+ import com.destroystokyo.paper.profile.LookupCause;
+ import com.destroystokyo.paper.profile.AccountProfile;
+ import com.google.common.base.Preconditions;
+ 
+ import org.bukkit.event.HandlerList;
+ 
+ /**
+  * Called before a uuid is requested from mojang.
+  * <p>
+  * <p>The event may be called synchronouslys if the uuid is resolved on the main thread</p>
+  */
+ public class AsyncNamePreResolveEvent extends AsyncProfilePreResolveEvent {
+     private final String name;
+ 
+     public AsyncNamePreResolveEvent(String name) {
+         super(LookupCause.NAME_LOOKUP);
+         Preconditions.checkNotNull(name, "Null name");
+         this.name = name;
+     }
+ 
+     /**
+      * Return the name that was used to request the profile
+      *
+      * @return the name that was requested
+      */
+     public String getName() {
+         return name;
+     }
+ 
+     /**
+      * {@inheritDoc}
+      *
+      * @throws IllegalArgumentException if the profile's name doesn't match the looked up names
+      */
+     @Override
+     public void setResult(AccountProfile result) {
+         if (result != null) {
+             Preconditions.checkArgument(result.getName().equalsIgnoreCase(this.getName()), "Name %s doesn't match looked up name: %s", result.getName(), this.getName());
+         }
+         super.setResult(result);
+     }
+ 
+     private static final HandlerList handlerList = new HandlerList();
+ 
+     public static HandlerList getHandlerList() {
+         return handlerList;
+     }
+ 
+     @Override
+     public HandlerList getHandlers() {
+         return handlerList;
+     }
+ }
\ No newline at end of file
diff --git a/src/main/java/com/destroystokyo/paper/profile/event/AsyncProfilePreResolveEvent.java b/src/main/java/com/destroystokyo/paper/profile/event/AsyncProfilePreResolveEvent.java
new file mode 100644
index 0000000..ca6dcb0
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/profile/event/AsyncProfilePreResolveEvent.java
@@ -0,0 +1,62 @@
+package com.destroystokyo.paper.profile.event;
+ 
+ import com.destroystokyo.paper.profile.AccountProfile;
+ import com.google.common.base.Preconditions;
+ 
+ import org.bukkit.Bukkit;
+ import org.bukkit.event.Event;
+ import com.destroystokyo.paper.profile.LookupCause;
+ 
+ /**
+  * Called before a profile is looked up from mojang.
+  * Plugins can set a profile, which will effectively 'cancel' the lookup from mojang.
+  * <p>May be called from the main thread if the lookup is from the main thread.</p>
+  */
+ public abstract class AsyncProfilePreResolveEvent extends Event {
+     private final LookupCause cause;
+     private AccountProfile result;
+ 
+     public AsyncProfilePreResolveEvent(LookupCause cause) {
+         super(!Bukkit.isPrimaryThread());
+         this.cause = Preconditions.checkNotNull(cause, "Null cause");;
+     }
+ 
+     /**
+      * Get the reason this profile is being looked up
+      * @return the reason this profile is being looked up
+      */
+     public LookupCause getCause() {
+         return cause;
+     }
+ 
+     /**
+      * Set the profile that will be returned by the lookup
+      * <p>Overrides any existing profile, and prevents a lookup from mojang.
+      * Setting to null re-allows a mojang lookup.</p>
+      *
+      * @param result the profile that will be returned by the lookup
+      */
+     public void setResult(AccountProfile result) {
+         this.result = result;
+     }
+ 
+     /**
+      * Get if a plugin has set the profile to be returned, and prevented a lookup to mojang
+      * <p>If not, it must be looked up from mojang</p>
+      *
+      * @return if a plugin has overriden the profile to be returned
+      */
+     public boolean isResolved() {
+         return result != null;
+     }
+ 
+     /**
+      * Get the profile that will be returned by the lookup, if another plugin has set it
+      * <p>If this returns null, than no plugin has set the profile and it must be looked up from mojang</p>
+      *
+      * @return the profile that has been set, or null if not set
+      */
+     public AccountProfile getResult() {
+         return result;
+     }
+ }
\ No newline at end of file
diff --git a/src/main/java/com/destroystokyo/paper/profile/event/AsyncProfileResolveEvent.java b/src/main/java/com/destroystokyo/paper/profile/event/AsyncProfileResolveEvent.java
new file mode 100644
index 0000000..7bf6f9e
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/profile/event/AsyncProfileResolveEvent.java
@@ -0,0 +1,80 @@
+package com.destroystokyo.paper.profile.event;
+ 
+ import com.google.common.base.Preconditions;
+ 
+ import org.bukkit.Bukkit;
+ import org.bukkit.event.Event;
+ import org.bukkit.event.HandlerList;
+ import com.destroystokyo.paper.profile.LookupCause;
+ import com.destroystokyo.paper.profile.AccountProfile;
+ 
+ /**
+  * Called once a profile is resolved.
+  * <p>May come from a plugin or from mojang.</p>
+  */
+ public class AsyncProfileResolveEvent extends Event {
+     private final LookupCause cause;
+     private AccountProfile result;
+     private boolean mojang;
+ 
+     public AsyncProfileResolveEvent(LookupCause cause, AccountProfile result, boolean mojang) {
+         super(!Bukkit.isPrimaryThread());
+         this.cause = Preconditions.checkNotNull(cause, "Null cause");;
+         setResult(result);
+         this.mojang = mojang;
+     }
+ 
+     /**
+      * Return the result of this lookup
+      *
+      * @return the result of the lookup
+      */
+     public AccountProfile getResult() {
+         return result;
+     }
+ 
+     /**
+      * Set the result of this lookup
+      * <p>Can't be null. If the lookup is a properties lookup, the properties must be set.</p>
+      *
+      * @param result the result of the lookup
+      */
+     public void setResult(AccountProfile result) {
+         Preconditions.checkNotNull(result, "Null result");
+         if (this.getCause() == LookupCause.PROPERTIES_LOOKUP) {
+             Preconditions.checkArgument(result.hasProperties(), "Result doesn't have properties in properties lookup: %s", result);
+         }
+         this.result = result;
+         this.mojang = false;
+     }
+ 
+     /**
+      * Get what caused this lookup
+      *
+      * @return what caused this lookup
+      */
+     public LookupCause getCause() {
+         return cause;
+     }
+ 
+     /**
+      * Return if the profile is known to come from mojang
+      * <p>If not, it is probably from a plugin.</p>
+      *
+      * @return if the profile is known to come from mojang
+      */
+     public boolean isFromMojang() {
+         return mojang;
+     }
+ 
+     private static final HandlerList handlerList = new HandlerList();
+ 
+     public HandlerList getHandlerList() {
+         return handlerList;
+     }
+ 
+     @Override
+     public HandlerList getHandlers() {
+         return getHandlerList();
+     }
+ }
\ No newline at end of file
diff --git a/src/main/java/com/destroystokyo/paper/profile/event/AsyncPropertiesPreResolveEvent.java b/src/main/java/com/destroystokyo/paper/profile/event/AsyncPropertiesPreResolveEvent.java
new file mode 100644
index 0000000..393b1ff
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/profile/event/AsyncPropertiesPreResolveEvent.java
@@ -0,0 +1,68 @@
+package com.destroystokyo.paper.profile.event;
+ 
+ import com.destroystokyo.paper.profile.ProfileProperties;
+ import com.google.common.base.Preconditions;
+ 
+ import org.bukkit.event.HandlerList;
+ import com.destroystokyo.paper.profile.LookupCause;
+ import com.destroystokyo.paper.profile.AccountProfile;
+ 
+ /**
+  * Called before profile properties are requested from mojang.
+  * Plugins can set a profile, which will effectively 'cancel' the lookup from mojang.
+  * <p>The event may be called synchronously if the uuid is resolved on the main thread</p>
+  */
+ public class AsyncPropertiesPreResolveEvent extends AsyncProfilePreResolveEvent {
+     private final AccountProfile profile;
+ 
+     public AsyncPropertiesPreResolveEvent(AccountProfile profile) {
+         super(LookupCause.PROPERTIES_LOOKUP);
+         Preconditions.checkNotNull(profile, "Null profile");
+         this.profile = profile.withProperties(null);
+     }
+ 
+     /**
+      * Set the profile whose properties are being looked up
+      */
+     public AccountProfile getProfile() {
+         return profile;
+     }
+ 
+     /**
+      * Set the properties that will be returned by the lookup
+      * <p>Overrides any existing profile, and prevents a lookup from mojang.
+      * Setting to null re-allows a mojang lookup.</p>
+      *
+      * @param properties the properties that will be returned by the lookup
+      */
+     public void setProperties(ProfileProperties properties) {
+         setResult(properties == null ? null : getResult().withProperties(properties));
+     }
+ 
+     /**
+      * {@inheritDoc}
+      * @throws IllegalArgumentException if the profile's id doesn't match the looked up id
+      * @throws IllegalArgumentException if the profile's id doesn't match the looked up name
+      * @throws IllegalArgumentException if the profile has 'unset' properties
+      */
+     @Override
+     public void setResult(AccountProfile result) {
+         if (result != null) {
+             Preconditions.checkArgument(result.hasProperties(), "Profile has unset properties");
+             Preconditions.checkArgument(result.getId().equals(this.getProfile().getId()), "Profile id %s doesn't match looked up %s", result.getId(), getProfile().getId());
+             Preconditions.checkArgument(result.getName().equals(this.getProfile().getName()), "Profile name %s doesn't match looked up %s", result.getName(), getProfile().getName());
+         }
+         super.setResult(result);
+     }
+ 
+     private static final HandlerList handlerList = new HandlerList();
+ 
+     public static HandlerList getHandlerList() {
+         return handlerList;
+     }
+ 
+     @Override
+     public HandlerList getHandlers() {
+         return getHandlerList();
+     }
+ }
\ No newline at end of file
diff --git a/src/main/java/com/destroystokyo/paper/profile/event/AsyncUUIDPreResolveEvent.java b/src/main/java/com/destroystokyo/paper/profile/event/AsyncUUIDPreResolveEvent.java
new file mode 100644
index 0000000..541d870
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/profile/event/AsyncUUIDPreResolveEvent.java
@@ -0,0 +1,55 @@
+package com.destroystokyo.paper.profile.event;
+ 
+ import java.util.UUID;
+ 
+ import com.destroystokyo.paper.profile.LookupCause;
+ import com.destroystokyo.paper.profile.AccountProfile;
+ import com.google.common.base.Preconditions;
+ 
+ import org.bukkit.event.HandlerList;
+ 
+ /**
+  * Called before a profile is requested from mojang.
+  * Plugins can set a profile, which will effectively 'cancel' the lookup from mojang.
+  * <p>The event may be called synchronously if the uuid is resolved on the main thread</p>
+  */
+ public class AsyncUUIDPreResolveEvent extends AsyncProfilePreResolveEvent {
+     private final UUID id;
+ 
+     public AsyncUUIDPreResolveEvent(UUID id) {
+         super(LookupCause.UUID_LOOKUP);
+         this.id = Preconditions.checkNotNull(id, "Null id");;
+     }
+ 
+     /**
+      * Return the id whose profile was requested
+      *
+      * @return the id that was requested
+      */
+     public UUID getId() {
+         return id;
+     }
+ 
+     /**
+      * {@inheritDoc}
+      *
+      * @throws IllegalArgumentException if the profile's id doesn't match the looked up id
+      */
+     @Override
+     public void setResult(AccountProfile result) {
+         if (result != null) {
+             Preconditions.checkArgument(result.getId().equals(this.getId()), "Id %s doesn't match looked up id: %s", result.getId(), this.getId());
+         }
+         super.setResult(result);
+     }
+     private static final HandlerList handlerList = new HandlerList();
+ 
+     public static HandlerList getHandlerList() {
+         return handlerList;
+     }
+ 
+     @Override
+     public HandlerList getHandlers() {
+         return getHandlerList();
+     }
+ }
\ No newline at end of file
diff --git a/src/main/java/com/destroystokyo/paper/utils/Hex.java b/src/main/java/com/destroystokyo/paper/utils/Hex.java
new file mode 100644
index 0000000..8bb29d1
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/utils/Hex.java
@@ -0,0 +1,113 @@
+package com.destroystokyo.paper.utils;
+ 
+ import java.util.Arrays;
+ import java.util.Objects;
+ 
+ public class Hex {
+ 
+     public static byte[] decode(CharSequence chars) {
+         byte[] bytes = new byte[chars.length() >> 1];
+         decode(chars, 0, bytes, 0, bytes.length);
+         return bytes;
+     }
+ 
+     public static void decode(char[] chars, int charOffset, byte[] dest, int offset, int length) {
+         decode(new CharSequence() {
+             @Override
+             public int length() {
+                 return chars.length;
+             }
+ 
+             @Override
+             public char charAt(int index) {
+                 return chars[index];
+             }
+ 
+             @Override
+             public CharSequence subSequence(int start, int end) {
+                 return toString().substring(start, end);
+             }
+ 
+             @Override
+             public String toString() {
+                 return new String(chars, charOffset, chars.length);
+             }
+         });
+     }
+ 
+     public static void decode(CharSequence chars, int charOffset, byte[] dest, int offset, int length) {
+         Objects.requireNonNull(chars, "Null chars");
+         Objects.requireNonNull(chars, "Null destination");
+         final int numChars = chars.length();
+         if ((numChars & 0x01) != 0) {
+             throw new IllegalArgumentException("Odd number of characters: " + numChars);
+         } else if (length < (numChars - charOffset) >> 1) {
+             throw new IllegalArgumentException("Too many bytes to fill with " + numChars + " characters: " + length);
+         } else if (offset < 0 || charOffset < 0 || length < 0 || length * 2 > numChars - charOffset || length > dest.length - offset) {
+             throw new IndexOutOfBoundsException();
+         }
+         for (int i = 0, charIndex = charOffset; i < length; i++) {
+             char first = chars.charAt(charIndex++);
+             char second = chars.charAt(charIndex++);
+             dest[i + offset] = (byte) ((toDigit(first) << 4) | (toDigit(second)));
+         }
+     }
+ 
+     public static String encodeString(byte[] bytes) {
+         return new String(encode(bytes));
+     }
+ 
+     public static char[] encode(byte[] bytes) {
+         char[] chars = new char[bytes.length << 1];
+         encode(chars, 0, bytes, 0, bytes.length);
+         return chars;
+     }
+ 
+     public static void encode(char[] chars, int charOffset, byte[] source, int offset, int length) {
+         Objects.requireNonNull(chars, "Null chars");
+         Objects.requireNonNull(chars, "Null bytes");
+         if (offset < 0 || charOffset < 0 || length < 0 || length * 2 > chars.length - charOffset || length > source.length - offset) {
+             throw new IndexOutOfBoundsException();
+         } else if (length == 0) {
+             return;
+         }
+         for (int i = 0, charIndex = charOffset; i < length; i++) {
+             byte b = source[i + offset];
+             chars[charIndex++] = fromDigit((byte) ((b >> 4) & 0xF));
+             chars[charIndex++] = fromDigit((byte) (b & 0xF));
+         }
+     }
+     private static final char[] ENCODE_TABLE = new char[]{
+             '0', '1', '2', '3', '4', '5', '6', '7',
+             '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
+     };
+     private static final byte[] DECODE_TABLE = new byte[128];
+ 
+     static {
+         Arrays.fill(DECODE_TABLE, (byte) -1);
+         for (int value = 0; value < ENCODE_TABLE.length; value++) {
+             char c = ENCODE_TABLE[value];
+             DECODE_TABLE[c] = (byte) value;
+             char upper;
+             if ((upper = Character.toUpperCase(c)) != c) {
+                 DECODE_TABLE[upper] = (byte) value;
+             }
+         }
+     }
+ 
+     private static byte toDigit(char c) {
+         byte value;
+         if (c < DECODE_TABLE.length) {
+             value = DECODE_TABLE[c];
+         } else {
+             value = -1;
+         }
+         if (value < 0) throw new IllegalArgumentException("Invalid character " + c);
+         return value;
+     }
+ 
+     private static char fromDigit(byte b) {
+         assert (b & 0xF) == b : "Out of range " + b;
+         return ENCODE_TABLE[b];
+     }
+ }
\ No newline at end of file
diff --git a/src/main/java/com/destroystokyo/paper/utils/json/ProfilePropertyTypeAdapter.java b/src/main/java/com/destroystokyo/paper/utils/json/ProfilePropertyTypeAdapter.java
new file mode 100644
index 0000000..9b59312
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/utils/json/ProfilePropertyTypeAdapter.java
@@ -0,0 +1,31 @@
+package com.destroystokyo.paper.utils.json;
+ 
+ import java.io.IOException;
+ 
+ import com.destroystokyo.paper.profile.ProfileProperty;
+ import com.google.gson.TypeAdapter;
+ import com.google.gson.stream.JsonReader;
+ import com.google.gson.stream.JsonWriter;
+ 
+ public class ProfilePropertyTypeAdapter extends TypeAdapter<ProfileProperty> {
+     @Override
+     public void write(JsonWriter out, ProfileProperty property) throws IOException {
+         if (property != null) {
+             out.beginObject();
+             out.name("name");
+             out.value(property.getName());
+             out.name("value");
+             out.value(property.getName());
+             if (property.isSigned()) {
+                 out.name("signature");
+                 out.name(property.getSignature());
+             }
+             out.endObject();
+         }
+     }
+ 
+     @Override
+     public ProfileProperty read(JsonReader in) throws IOException {
+         return null;
+     }
+ }
\ No newline at end of file
diff --git a/src/main/java/com/destroystokyo/paper/utils/json/UUIDTypeAdapter.java b/src/main/java/com/destroystokyo/paper/utils/json/UUIDTypeAdapter.java
new file mode 100644
index 0000000..8df3156
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/utils/json/UUIDTypeAdapter.java
@@ -0,0 +1,54 @@
+package com.destroystokyo.paper.utils.json;
+ 
+ import java.io.IOException;
+ import java.util.UUID;
+ 
+ import com.google.gson.TypeAdapter;
+ import com.google.gson.stream.JsonReader;
+ import com.google.gson.stream.JsonToken;
+ import com.google.gson.stream.JsonWriter;
+ 
+ import com.destroystokyo.paper.profile.UUIDUtils;
+ 
+ public class UUIDTypeAdapter extends TypeAdapter<UUID> {
+     private final boolean mojangStyle;
+     private final boolean lenient;
+ 
+     private UUIDTypeAdapter(boolean mojangStyle, boolean lenient) {
+         if (mojangStyle && !lenient) throw new AssertionError("Mojang style should imply lenient");
+         this.mojangStyle = mojangStyle;
+         this.lenient = lenient;
+     }
+ 
+     public static UUIDTypeAdapter create() {
+         return new UUIDTypeAdapter(false, false);
+     }
+ 
+     public static UUIDTypeAdapter createMojang() {
+         return new UUIDTypeAdapter(true, true);
+     }
+ 
+     public static UUIDTypeAdapter createLenient() {
+         return new UUIDTypeAdapter(false, true);
+     }
+ 
+     @Override
+     public void write(JsonWriter out, UUID value) throws IOException {
+         if (value != null) {
+             out.value(mojangStyle ? UUIDUtils.toMojangString(value) : value.toString());
+         } else {
+             out.nullValue();
+         }
+     }
+ 
+     @Override
+     public UUID read(JsonReader in) throws IOException {
+         if (in.peek() != JsonToken.NULL) {
+             String s = in.nextString();
+             return lenient ? UUIDUtils.fromString(s) : UUID.fromString(s);
+         } else {
+             in.nextNull();
+             return null;
+         }
+     }
+ }
\ No newline at end of file
diff --git a/src/main/java/net/minecraft/server/EntityHuman.java b/src/main/java/net/minecraft/server/EntityHuman.java
index 78ccaa2..8e0f28d 100644
--- a/src/main/java/net/minecraft/server/EntityHuman.java
+++ b/src/main/java/net/minecraft/server/EntityHuman.java
@@ -12,6 +12,8 @@ import java.util.UUID;
 import javax.annotation.Nullable;
 
 import java.util.Queue;
+import com.destroystokyo.paper.profile.AccountProfile;
+import com.destroystokyo.paper.profile.ProfileUtils;
 
 // CraftBukkit start
 import org.bukkit.craftbukkit.entity.CraftHumanEntity;
@@ -1219,6 +1221,14 @@ public abstract class EntityHuman extends EntityLiving {
     public GameProfile getProfile() {
         return this.bS;
     }
+	
+	// Paper start - bukkit profile method
+    private final AccountProfile bukkitProfile = ProfileUtils.toPaperWithProperties(getProfile());
+
+    public AccountProfile getBukkitProfile() {
+        return bukkitProfile;
+    }
+    // Paper end
 
     public EntityHuman.EnumBedResult a(BlockPosition blockposition) {
         if (!this.world.isClientSide) {
diff --git a/src/main/java/org/bukkit/Bukkit.java b/src/main/java/org/bukkit/Bukkit.java
new file mode 100644
index 0000000..e9dcd14
--- /dev/null
+++ b/src/main/java/org/bukkit/Bukkit.java
@@ -0,0 +1,1221 @@
+package org.bukkit;
+
+import java.awt.image.BufferedImage;
+import java.io.File;
+import java.io.Serializable;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.UUID;
+import java.util.logging.Logger;
+
+import com.destroystokyo.paper.profile.ProfileLookup; // Paper
+
+import org.bukkit.Warning.WarningState;
+import org.bukkit.boss.BarColor;
+import org.bukkit.boss.BarFlag;
+import org.bukkit.boss.BarStyle;
+import org.bukkit.boss.BossBar;
+import org.bukkit.command.*;
+import org.bukkit.entity.Entity;
+import org.bukkit.entity.Player;
+import org.bukkit.event.inventory.InventoryType;
+import org.bukkit.event.server.ServerListPingEvent;
+import org.bukkit.help.HelpMap;
+import org.bukkit.inventory.Inventory;
+import org.bukkit.inventory.InventoryHolder;
+import org.bukkit.inventory.ItemStack;
+import org.bukkit.inventory.Recipe;
+import org.bukkit.map.MapView;
+import org.bukkit.permissions.Permissible;
+import org.bukkit.plugin.PluginManager;
+import org.bukkit.plugin.ServicesManager;
+import org.bukkit.plugin.messaging.Messenger;
+import org.bukkit.scheduler.BukkitScheduler;
+import org.bukkit.scoreboard.ScoreboardManager;
+import org.bukkit.util.CachedServerIcon;
+
+import com.avaje.ebean.config.ServerConfig;
+import com.google.common.collect.ImmutableList;
+import org.bukkit.generator.ChunkGenerator;
+
+import org.bukkit.inventory.ItemFactory;
+import org.bukkit.inventory.meta.ItemMeta;
+
+/**
+ * Represents the Bukkit core, for version and Server singleton handling
+ */
+public final class Bukkit {
+    private static Server server;
+
+    /**
+     * Static class cannot be initialized.
+     */
+    private Bukkit() {}
+
+    /**
+     * Gets the current {@link Server} singleton
+     *
+     * @return Server instance being ran
+     */
+    public static Server getServer() {
+        return server;
+    }
+
+    /**
+     * Attempts to set the {@link Server} singleton.
+     * <p>
+     * This cannot be done if the Server is already set.
+     *
+     * @param server Server instance
+     */
+    public static void setServer(Server server) {
+        if (Bukkit.server != null) {
+            throw new UnsupportedOperationException("Cannot redefine singleton Server");
+        }
+
+        Bukkit.server = server;
+        server.getLogger().info("This server is running " + getName() + " version " + getVersion() + " (Implementing API version " + getBukkitVersion() + ")");
+    }
+
+    /**
+     * Gets the name of this server implementation.
+     *
+     * @return name of this server implementation
+     */
+    public static String getName() {
+        return server.getName();
+    }
+
+    /**
+     * Gets the version string of this server implementation.
+     *
+     * @return version of this server implementation
+     */
+    public static String getVersion() {
+        return server.getVersion();
+    }
+
+    /**
+     * Gets the Bukkit version that this server is running.
+     *
+     * @return version of Bukkit
+     */
+    public static String getBukkitVersion() {
+        return server.getBukkitVersion();
+    }
+
+    /**
+     * Gets an array copy of all currently logged in players.
+     * <p>
+     * This method exists for legacy reasons to provide backwards
+     * compatibility. It will not exist at runtime and should not be used
+     * under any circumstances.
+     *
+     * @deprecated superseded by {@link #getOnlinePlayers()}
+     * @return an array of Players that are currently online
+     */
+    @Deprecated
+    public static Player[] _INVALID_getOnlinePlayers() {
+        return server._INVALID_getOnlinePlayers();
+    }
+
+    /**
+     * Gets a view of all currently logged in players. This {@linkplain
+     * Collections#unmodifiableCollection(Collection) view} is a reused
+     * object, making some operations like {@link Collection#size()}
+     * zero-allocation.
+     * <p>
+     * The collection is a view backed by the internal representation, such
+     * that, changes to the internal state of the server will be reflected
+     * immediately. However, the reuse of the returned collection (identity)
+     * is not strictly guaranteed for future or all implementations. Casting
+     * the collection, or relying on interface implementations (like {@link
+     * Serializable} or {@link List}), is deprecated.
+     * <p>
+     * Iteration behavior is undefined outside of self-contained main-thread
+     * uses. Normal and immediate iterator use without consequences that
+     * affect the collection are fully supported. The effects following
+     * (non-exhaustive) {@link Entity#teleport(Location) teleportation},
+     * {@link Player#setHealth(double) death}, and {@link Player#kickPlayer(
+     * String) kicking} are undefined. Any use of this collection from
+     * asynchronous threads is unsafe.
+     * <p>
+     * For safe consequential iteration or mimicking the old array behavior,
+     * using {@link Collection#toArray(Object[])} is recommended. For making
+     * snapshots, {@link ImmutableList#copyOf(Collection)} is recommended.
+     *
+     * @return a view of currently online players.
+     */
+    public static Collection<? extends Player> getOnlinePlayers() {
+        return server.getOnlinePlayers();
+    }
+
+    /**
+     * Get the maximum amount of players which can login to this server.
+     *
+     * @return the amount of players this server allows
+     */
+    public static int getMaxPlayers() {
+        return server.getMaxPlayers();
+    }
+
+    /**
+     * Get the game port that the server runs on.
+     *
+     * @return the port number of this server
+     */
+    public static int getPort() {
+        return server.getPort();
+    }
+
+    /**
+     * Get the view distance from this server.
+     *
+     * @return the view distance from this server.
+     */
+    public static int getViewDistance() {
+        return server.getViewDistance();
+    }
+
+    /**
+     * Get the IP that this server is bound to, or empty string if not
+     * specified.
+     *
+     * @return the IP string that this server is bound to, otherwise empty
+     *     string
+     */
+    public static String getIp() {
+        return server.getIp();
+    }
+
+    /**
+     * Get the name of this server.
+     *
+     * @return the name of this server
+     */
+    public static String getServerName() {
+        return server.getServerName();
+    }
+
+    /**
+     * Get an ID of this server. The ID is a simple generally alphanumeric ID
+     * that can be used for uniquely identifying this server.
+     *
+     * @return the ID of this server
+     */
+    public static String getServerId() {
+        return server.getServerId();
+    }
+    
+    /**
+     * Get world type (level-type setting) for default world.
+     *
+     * @return the value of level-type (e.g. DEFAULT, FLAT, DEFAULT_1_1)
+     */
+    public static String getWorldType() {
+        return server.getWorldType();
+    }
+
+    /**
+     * Get generate-structures setting.
+     *
+     * @return true if structure generation is enabled, false otherwise
+     */
+    public static boolean getGenerateStructures() {
+        return server.getGenerateStructures();
+    }
+
+    /**
+     * Gets whether this server allows the End or not.
+     *
+     * @return whether this server allows the End or not
+     */
+    public static boolean getAllowEnd() {
+        return server.getAllowEnd();
+    }
+
+    /**
+     * Gets whether this server allows the Nether or not.
+     *
+     * @return whether this server allows the Nether or not
+     */
+    public static boolean getAllowNether() {
+        return server.getAllowNether();
+    }
+
+    /**
+     * Gets whether this server has a whitelist or not.
+     *
+     * @return whether this server has a whitelist or not
+     */
+    public static boolean hasWhitelist() {
+        return server.hasWhitelist();
+    }
+
+    /**
+     * Sets if the server is whitelisted.
+     *
+     * @param value true for whitelist on, false for off
+     */
+    public static void setWhitelist(boolean value) {
+        server.setWhitelist(value);
+    }
+
+    /**
+     * Gets a list of whitelisted players.
+     *
+     * @return a set containing all whitelisted players
+     */
+    public static Set<OfflinePlayer> getWhitelistedPlayers() {
+        return server.getWhitelistedPlayers();
+    }
+
+    /**
+     * Reloads the whitelist from disk.
+     */
+    public static void reloadWhitelist() {
+        server.reloadWhitelist();
+    }
+
+    /**
+     * Broadcast a message to all players.
+     * <p>
+     * This is the same as calling {@link #broadcast(java.lang.String,
+     * java.lang.String)} to {@link Server#BROADCAST_CHANNEL_USERS}
+     *
+     * @param message the message
+     * @return the number of players
+     */
+    public static int broadcastMessage(String message) {
+        return server.broadcastMessage(message);
+    }
+
+    // Paper start
+    /**
+     * Sends the component to all online players.
+     *
+     * @param component the component to send
+     */
+    public static void broadcast(net.md_5.bungee.api.chat.BaseComponent component) {
+        server.broadcast(component);
+    }
+
+    /**
+     * Sends an array of components as a single message to all online players.
+     *
+     * @param components the components to send
+     */
+    public static void broadcast(net.md_5.bungee.api.chat.BaseComponent... components) {
+        server.broadcast(components);
+    }
+    // Paper end
+
+    /**
+     * Gets the name of the update folder. The update folder is used to safely
+     * update plugins at the right moment on a plugin load.
+     * <p>
+     * The update folder name is relative to the plugins folder.
+     *
+     * @return the name of the update folder
+     */
+    public static String getUpdateFolder() {
+        return server.getUpdateFolder();
+    }
+
+    /**
+     * Gets the update folder. The update folder is used to safely update
+     * plugins at the right moment on a plugin load.
+     *
+     * @return the update folder
+     */
+    public static File getUpdateFolderFile() {
+        return server.getUpdateFolderFile();
+    }
+
+    /**
+     * Gets the value of the connection throttle setting.
+     *
+     * @return the value of the connection throttle setting
+     */
+    public static long getConnectionThrottle() {
+        return server.getConnectionThrottle();
+    }
+
+    /**
+     * Gets default ticks per animal spawns value.
+     * <p>
+     * <b>Example Usage:</b>
+     * <ul>
+     * <li>A value of 1 will mean the server will attempt to spawn monsters
+     *     every tick.
+     * <li>A value of 400 will mean the server will attempt to spawn monsters
+     *     every 400th tick.
+     * <li>A value below 0 will be reset back to Minecraft's default.
+     * </ul>
+     * <p>
+     * <b>Note:</b> If set to 0, animal spawning will be disabled. We
+     * recommend using spawn-animals to control this instead.
+     * <p>
+     * Minecraft default: 400.
+     *
+     * @return the default ticks per animal spawns value
+     */
+    public static int getTicksPerAnimalSpawns() {
+        return server.getTicksPerAnimalSpawns();
+    }
+
+    /**
+     * Gets the default ticks per monster spawns value.
+     * <p>
+     * <b>Example Usage:</b>
+     * <ul>
+     * <li>A value of 1 will mean the server will attempt to spawn monsters
+     *     every tick.
+     * <li>A value of 400 will mean the server will attempt to spawn monsters
+     *     every 400th tick.
+     * <li>A value below 0 will be reset back to Minecraft's default.
+     * </ul>
+     * <p>
+     * <b>Note:</b> If set to 0, monsters spawning will be disabled. We
+     * recommend using spawn-monsters to control this instead.
+     * <p>
+     * Minecraft default: 1.
+     *
+     * @return the default ticks per monsters spawn value
+     */
+    public static int getTicksPerMonsterSpawns() {
+        return server.getTicksPerMonsterSpawns();
+    }
+
+    /**
+     * Gets a player object by the given username.
+     * <p>
+     * This method may not return objects for offline players.
+     *
+     * @param name the name to look up
+     * @return a player if one was found, null otherwise
+     */
+    public static Player getPlayer(String name) {
+        return server.getPlayer(name);
+    }
+
+    /**
+     * Gets the player with the exact given name, case insensitive.
+     *
+     * @param name Exact name of the player to retrieve
+     * @return a player object if one was found, null otherwise
+     */
+    public static Player getPlayerExact(String name) {
+        return server.getPlayerExact(name);
+    }
+
+    /**
+     * Attempts to match any players with the given name, and returns a list
+     * of all possibly matches.
+     * <p>
+     * This list is not sorted in any particular order. If an exact match is
+     * found, the returned list will only contain a single result.
+     *
+     * @param name the (partial) name to match
+     * @return list of all possible players
+     */
+    public static List<Player> matchPlayer(String name) {
+        return server.matchPlayer(name);
+    }
+
+    /**
+     * Gets the player with the given UUID.
+     *
+     * @param id UUID of the player to retrieve
+     * @return a player object if one was found, null otherwise
+     */
+    public static Player getPlayer(UUID id) {
+        return server.getPlayer(id);
+    }
+
+    /**
+     * Gets the plugin manager for interfacing with plugins.
+     *
+     * @return a plugin manager for this Server instance
+     */
+    public static PluginManager getPluginManager() {
+        return server.getPluginManager();
+    }
+
+    /**
+     * Gets the scheduler for managing scheduled events.
+     *
+     * @return a scheduling service for this server
+     */
+    public static BukkitScheduler getScheduler() {
+        return server.getScheduler();
+    }
+
+    /**
+     * Gets a services manager.
+     *
+     * @return s services manager
+     */
+    public static ServicesManager getServicesManager() {
+        return server.getServicesManager();
+    }
+
+    /**
+     * Gets a list of all worlds on this server.
+     *
+     * @return a list of worlds
+     */
+    public static List<World> getWorlds() {
+        return server.getWorlds();
+    }
+
+    /**
+     * Creates or loads a world with the given name using the specified
+     * options.
+     * <p>
+     * If the world is already loaded, it will just return the equivalent of
+     * getWorld(creator.name()).
+     *
+     * @param creator the options to use when creating the world
+     * @return newly created or loaded world
+     */
+    public static World createWorld(WorldCreator creator) {
+        return server.createWorld(creator);
+    }
+
+    /**
+     * Unloads a world with the given name.
+     *
+     * @param name Name of the world to unload
+     * @param save whether to save the chunks before unloading
+     * @return true if successful, false otherwise
+     */
+    public static boolean unloadWorld(String name, boolean save) {
+        return server.unloadWorld(name, save);
+    }
+
+    /**
+     * Unloads the given world.
+     *
+     * @param world the world to unload
+     * @param save whether to save the chunks before unloading
+     * @return true if successful, false otherwise
+     */
+    public static boolean unloadWorld(World world, boolean save) {
+        return server.unloadWorld(world, save);
+    }
+
+    /**
+     * Gets the world with the given name.
+     *
+     * @param name the name of the world to retrieve
+     * @return a world with the given name, or null if none exists
+     */
+    public static World getWorld(String name) {
+        return server.getWorld(name);
+    }
+
+    /**
+     * Gets the world from the given Unique ID.
+     *
+     * @param uid a unique-id of the world to retrieve
+     * @return a world with the given Unique ID, or null if none exists
+     */
+    public static World getWorld(UUID uid) {
+        return server.getWorld(uid);
+    }
+
+    /**
+     * Gets the map from the given item ID.
+     *
+     * @param id the id of the map to get
+     * @return a map view if it exists, or null otherwise
+     * @deprecated Magic value
+     */
+    @Deprecated
+    public static MapView getMap(short id) {
+        return server.getMap(id);
+    }
+
+    /**
+     * Create a new map with an automatically assigned ID.
+     *
+     * @param world the world the map will belong to
+     * @return a newly created map view
+     */
+    public static MapView createMap(World world) {
+        return server.createMap(world);
+    }
+
+    /**
+     * Reloads the server, refreshing settings and plugin information.
+     */
+    public static void reload() {
+        server.reload();
+    }
+
+    /**
+     * Returns the primary logger associated with this server instance.
+     *
+     * @return Logger associated with this server
+     */
+    public static Logger getLogger() {
+        return server.getLogger();
+    }
+
+    /**
+     * Gets a {@link PluginCommand} with the given name or alias.
+     *
+     * @param name the name of the command to retrieve
+     * @return a plugin command if found, null otherwise
+     */
+    public static PluginCommand getPluginCommand(String name) {
+        return server.getPluginCommand(name);
+    }
+
+    /**
+     * Writes loaded players to disk.
+     */
+    public static void savePlayers() {
+        server.savePlayers();
+    }
+    
+    /**
+     * Dispatches a command on this server, and executes it if found.
+     *
+     * @param sender the apparent sender of the command
+     * @param commandLine the command + arguments. Example: <code>test abc
+     *     123</code>
+     * @return returns false if no target is found
+     * @throws CommandException thrown when the executor for the given command
+     *     fails with an unhandled exception
+     */
+    public static boolean dispatchCommand(CommandSender sender, String commandLine) throws CommandException {
+        return server.dispatchCommand(sender, commandLine);
+    }
+
+    /**
+     * Populates a given {@link ServerConfig} with values attributes to this
+     * server.
+     *
+     * @param config the server config to populate
+     */
+    public static void configureDbConfig(ServerConfig config) {
+        server.configureDbConfig(config);
+    }
+
+    /**
+     * Adds a recipe to the crafting manager.
+     *
+     * @param recipe the recipe to add
+     * @return true if the recipe was added, false if it wasn't for some
+     *     reason
+     */
+    public static boolean addRecipe(Recipe recipe) {
+        return server.addRecipe(recipe);
+    }
+
+    /**
+     * Get a list of all recipes for a given item. The stack size is ignored
+     * in comparisons. If the durability is -1, it will match any data value.
+     *
+     * @param result the item to match against recipe results
+     * @return a list of recipes with the given result
+     */
+    public static List<Recipe> getRecipesFor(ItemStack result) {
+        return server.getRecipesFor(result);
+    }
+
+    /**
+     * Get an iterator through the list of crafting recipes.
+     *
+     * @return an iterator
+     */
+    public static Iterator<Recipe> recipeIterator() {
+        return server.recipeIterator();
+    }
+
+    /**
+     * Clears the list of crafting recipes.
+     */
+    public static void clearRecipes() {
+        server.clearRecipes();
+    }
+
+    /**
+     * Resets the list of crafting recipes to the default.
+     */
+    public static void resetRecipes() {
+        server.resetRecipes();
+    }
+    
+    /**
+     * Gets a list of command aliases defined in the server properties.
+     *
+     * @return a map of aliases to command names
+     */
+    public static Map<String, String[]> getCommandAliases() {
+        return server.getCommandAliases();
+    }
+
+    /**
+     * Gets the radius, in blocks, around each worlds spawn point to protect.
+     *
+     * @return spawn radius, or 0 if none
+     */
+    public static int getSpawnRadius() {
+        return server.getSpawnRadius();
+    }
+
+    /**
+     * Sets the radius, in blocks, around each worlds spawn point to protect.
+     *
+     * @param value new spawn radius, or 0 if none
+     */
+    public static void setSpawnRadius(int value) {
+        server.setSpawnRadius(value);
+    }
+
+    /**
+     * Gets whether the Server is in online mode or not.
+     *
+     * @return true if the server authenticates clients, false otherwise
+     */
+    public static boolean getOnlineMode() {
+        return server.getOnlineMode();
+    }
+
+    /**
+     * Gets whether this server allows flying or not.
+     *
+     * @return true if the server allows flight, false otherwise
+     */
+    public static boolean getAllowFlight() {
+        return server.getAllowFlight();
+    }
+
+    /**
+     * Gets whether the server is in hardcore mode or not.
+     *
+     * @return true if the server mode is hardcore, false otherwise
+     */
+    public static boolean isHardcore() {
+        return server.isHardcore();
+    }
+
+    /**
+     * Gets whether to use vanilla (false) or exact behaviour (true).
+     *
+     * <ul>
+     * <li>Vanilla behaviour: check for collisions and move the player if
+     *     needed.
+     * <li>Exact behaviour: spawn players exactly where they should be.
+     * </ul>
+     *
+     * @return true if exact location locations are used for spawning, false
+     *     for vanilla collision detection or otherwise
+     *
+     * @deprecated non standard and unused feature.
+     */
+    @Deprecated
+    public static boolean useExactLoginLocation() {
+        return server.useExactLoginLocation();
+    }
+ 
+    /**
+     * Shutdowns the server, stopping everything.
+     */
+    public static void shutdown() {
+        server.shutdown();
+    }
+
+    /**
+     * Broadcasts the specified message to every user with the given
+     * permission name.
+     *
+     * @param message message to broadcast
+     * @param permission the required permission {@link Permissible
+     *     permissibles} must have to receive the broadcast
+     * @return number of message recipients
+     */
+    public static int broadcast(String message, String permission) {
+        return server.broadcast(message, permission);
+    }
+
+    /**
+     * Gets the player by the given name, regardless if they are offline or
+     * online.
+     * <p>
+     * This method may involve a blocking web request to get the UUID for the
+     * given name.
+     * <p>
+     * This will return an object even if the player does not exist. To this
+     * method, all players will exist.
+     *
+     * @deprecated Persistent storage of users should be by UUID as names are no longer
+     *             unique past a single session.
+     * @param name the name the player to retrieve
+     * @return an offline player
+     * @see #getOfflinePlayer(java.util.UUID)
+     */
+    @Deprecated
+    public static OfflinePlayer getOfflinePlayer(String name) {
+        return server.getOfflinePlayer(name);
+    }
+
+    /**
+     * Gets the player by the given UUID, regardless if they are offline or
+     * online.
+     * <p>
+     * This will return an object even if the player does not exist. To this
+     * method, all players will exist.
+     *
+     * @param id the UUID of the player to retrieve
+     * @return an offline player
+     */
+    public static OfflinePlayer getOfflinePlayer(UUID id) {
+        return server.getOfflinePlayer(id);
+    }
+
+    /**
+     * Gets a set containing all current IPs that are banned.
+     *
+     * @return a set containing banned IP addresses
+     */
+    public static Set<String> getIPBans() {
+        return server.getIPBans();
+    }
+
+    /**
+     * Bans the specified address from the server.
+     *
+     * @param address the IP address to ban
+     */
+    public static void banIP(String address) {
+        server.banIP(address);
+    }
+
+    /**
+     * Unbans the specified address from the server.
+     *
+     * @param address the IP address to unban
+     */
+    public static void unbanIP(String address) {
+        server.unbanIP(address);
+    }
+
+    /**
+     * Gets a set containing all banned players.
+     *
+     * @return a set containing banned players
+     */
+    public static Set<OfflinePlayer> getBannedPlayers() {
+        return server.getBannedPlayers();
+    }
+
+    /**
+     * Gets a ban list for the supplied type.
+     * <p>
+     * Bans by name are no longer supported and this method will return
+     * null when trying to request them. The replacement is bans by UUID.
+     *
+     * @param type the type of list to fetch, cannot be null
+     * @return a ban list of the specified type
+     */
+    public static BanList getBanList(BanList.Type type){
+        return server.getBanList(type);
+    }
+
+    /**
+     * Gets a set containing all player operators.
+     *
+     * @return a set containing player operators
+     */
+    public static Set<OfflinePlayer> getOperators() {
+        return server.getOperators();
+    }
+
+    /**
+     * Gets the default {@link GameMode} for new players.
+     *
+     * @return the default game mode
+     */
+    public static GameMode getDefaultGameMode() {
+        return server.getDefaultGameMode();
+    }
+
+    /**
+     * Sets the default {@link GameMode} for new players.
+     *
+     * @param mode the new game mode
+     */
+    public static void setDefaultGameMode(GameMode mode) {
+        server.setDefaultGameMode(mode);
+    }
+
+    /**
+     * Gets a {@link ConsoleCommandSender} that may be used as an input source
+     * for this server.
+     *
+     * @return a console command sender
+     */
+    public static ConsoleCommandSender getConsoleSender() {
+        return server.getConsoleSender();
+    }
+
+    /**
+     * Gets the folder that contains all of the various {@link World}s.
+     *
+     * @return folder that contains all worlds
+     */
+    public static File getWorldContainer() {
+        return server.getWorldContainer();
+    }
+
+    /**
+     * Gets every player that has ever played on this server.
+     *
+     * @return an array containing all previous players
+     */
+    public static OfflinePlayer[] getOfflinePlayers() {
+        return server.getOfflinePlayers();
+    }
+
+    /**
+     * Gets the {@link Messenger} responsible for this server.
+     *
+     * @return messenger responsible for this server
+     */
+    public static Messenger getMessenger() {
+        return server.getMessenger();
+    }
+
+    /**
+     * Gets the {@link HelpMap} providing help topics for this server.
+     *
+     * @return a help map for this server
+     */
+    public static HelpMap getHelpMap() {
+        return server.getHelpMap();
+    }
+
+    /**
+     * Creates an empty inventory of the specified type. If the type is {@link
+     * InventoryType#CHEST}, the new inventory has a size of 27; otherwise the
+     * new inventory has the normal size for its type.
+     *
+     * @param owner the holder of the inventory, or null to indicate no holder
+     * @param type the type of inventory to create
+     * @return a new inventory
+     */
+    public static Inventory createInventory(InventoryHolder owner, InventoryType type) {
+        return server.createInventory(owner, type);
+    }
+
+    /**
+     * Creates an empty inventory with the specified type and title. If the type
+     * is {@link InventoryType#CHEST}, the new inventory has a size of 27;
+     * otherwise the new inventory has the normal size for its type.<br>
+     * It should be noted that some inventory types do not support titles and
+     * may not render with said titles on the Minecraft client.
+     *
+     * @param owner The holder of the inventory; can be null if there's no holder.
+     * @param type The type of inventory to create.
+     * @param title The title of the inventory, to be displayed when it is viewed.
+     * @return The new inventory.
+     */
+    public static Inventory createInventory(InventoryHolder owner, InventoryType type, String title) {
+        return server.createInventory(owner, type, title);
+    }
+
+    /**
+     * Creates an empty inventory of type {@link InventoryType#CHEST} with the
+     * specified size.
+     *
+     * @param owner the holder of the inventory, or null to indicate no holder
+     * @param size a multiple of 9 as the size of inventory to create
+     * @return a new inventory
+     * @throws IllegalArgumentException if the size is not a multiple of 9
+     */
+    public static Inventory createInventory(InventoryHolder owner, int size) throws IllegalArgumentException {
+        return server.createInventory(owner, size);
+    }
+
+    /**
+     * Creates an empty inventory of type {@link InventoryType#CHEST} with the
+     * specified size and title.
+     *
+     * @param owner the holder of the inventory, or null to indicate no holder
+     * @param size a multiple of 9 as the size of inventory to create
+     * @param title the title of the inventory, displayed when inventory is
+     *     viewed
+     * @return a new inventory
+     * @throws IllegalArgumentException if the size is not a multiple of 9
+     */
+    public static Inventory createInventory(InventoryHolder owner, int size, String title) throws IllegalArgumentException {
+        return server.createInventory(owner, size, title);
+    }
+
+    /**
+     * Gets user-specified limit for number of monsters that can spawn in a
+     * chunk.
+     *
+     * @return the monster spawn limit
+     */
+    public static int getMonsterSpawnLimit() {
+        return server.getMonsterSpawnLimit();
+    }
+
+    /**
+     * Gets user-specified limit for number of animals that can spawn in a
+     * chunk.
+     *
+     * @return the animal spawn limit
+     */
+    public static int getAnimalSpawnLimit() {
+        return server.getAnimalSpawnLimit();
+    }
+
+    /**
+     * Gets user-specified limit for number of water animals that can spawn in
+     * a chunk.
+     *
+     * @return the water animal spawn limit
+     */
+    public static int getWaterAnimalSpawnLimit() {
+        return server.getWaterAnimalSpawnLimit();
+    }
+    
+    /**
+     * Gets user-specified limit for number of ambient mobs that can spawn in
+     * a chunk.
+     *
+     * @return the ambient spawn limit
+     */
+    public static int getAmbientSpawnLimit() {
+        return server.getAmbientSpawnLimit();
+    }
+
+    /**
+     * Checks the current thread against the expected primary thread for the
+     * server.
+     * <p>
+     * <b>Note:</b> this method should not be used to indicate the current
+     * synchronized state of the runtime. A current thread matching the main
+     * thread indicates that it is synchronized, but a mismatch <b>does not
+     * preclude</b> the same assumption.
+     *
+     * @return true if the current thread matches the expected primary thread,
+     *     false otherwise
+     */
+    public static boolean isPrimaryThread() {
+        return server.isPrimaryThread();
+    }
+
+    /**
+     * Gets the message that is displayed on the server list.
+     *
+     * @return the servers MOTD
+     */
+    public static String getMotd() {
+        return server.getMotd();
+    }
+
+    /**
+     * Gets the default message that is displayed when the server is stopped.
+     *
+     * @return the shutdown message
+     */
+    public static String getShutdownMessage() {
+        return server.getShutdownMessage();
+    }
+
+    /**
+     * Gets the current warning state for the server.
+     *
+     * @return the configured warning state
+     */
+    public static WarningState getWarningState() {
+        return server.getWarningState();
+    }
+
+    /**
+     * Gets the instance of the item factory (for {@link ItemMeta}).
+     *
+     * @return the item factory
+     * @see ItemFactory
+     */
+    public static ItemFactory getItemFactory() {
+        return server.getItemFactory();
+    }
+
+    /**
+     * Gets the instance of the scoreboard manager.
+     * <p>
+     * This will only exist after the first world has loaded.
+     *
+     * @return the scoreboard manager or null if no worlds are loaded.
+     */
+    public static ScoreboardManager getScoreboardManager() {
+        return server.getScoreboardManager();
+    }
+
+    /**
+     * Gets an instance of the server's default server-icon.
+     *
+     * @return the default server-icon; null values may be used by the
+     *     implementation to indicate no defined icon, but this behavior is
+     *     not guaranteed
+     */
+    public static CachedServerIcon getServerIcon() {
+        return server.getServerIcon();
+    }
+
+    /**
+     * Loads an image from a file, and returns a cached image for the specific
+     * server-icon.
+     * <p>
+     * Size and type are implementation defined. An incompatible file is
+     * guaranteed to throw an implementation-defined {@link Exception}.
+     *
+     * @param file the file to load the from
+     * @throws IllegalArgumentException if image is null
+     * @throws Exception if the image does not meet current server server-icon
+     *     specifications
+     * @return a cached server-icon that can be used for a {@link
+     *     ServerListPingEvent#setServerIcon(CachedServerIcon)}
+     */
+    public static CachedServerIcon loadServerIcon(File file) throws IllegalArgumentException, Exception {
+        return server.loadServerIcon(file);
+    }
+
+    /**
+     * Creates a cached server-icon for the specific image.
+     * <p>
+     * Size and type are implementation defined. An incompatible file is
+     * guaranteed to throw an implementation-defined {@link Exception}.
+     *
+     * @param image the image to use
+     * @throws IllegalArgumentException if image is null
+     * @throws Exception if the image does not meet current server
+     *     server-icon specifications
+     * @return a cached server-icon that can be used for a {@link
+     *     ServerListPingEvent#setServerIcon(CachedServerIcon)}
+     */
+    public static CachedServerIcon loadServerIcon(BufferedImage image) throws IllegalArgumentException, Exception {
+        return server.loadServerIcon(image);
+    }
+
+    /**
+     * Set the idle kick timeout. Any players idle for the specified amount of
+     * time will be automatically kicked.
+     * <p>
+     * A value of 0 will disable the idle kick timeout.
+     *
+     * @param threshold the idle timeout in minutes
+     */
+    public static void setIdleTimeout(int threshold) {
+        server.setIdleTimeout(threshold);
+    }
+
+    /**
+     * Gets the idle kick timeout.
+     *
+     * @return the idle timeout in minutes
+     */
+    public static int getIdleTimeout() {
+        return server.getIdleTimeout();
+    }
+
+    /**
+     * Create a ChunkData for use in a generator.
+     * 
+     * See {@link ChunkGenerator#generateChunkData(org.bukkit.World, java.util.Random, int, int, org.bukkit.generator.ChunkGenerator.BiomeGrid)}
+     * 
+     * @param world the world to create the ChunkData for
+     * @return a new ChunkData for the world
+     * 
+     */
+    public static ChunkGenerator.ChunkData createChunkData(World world) {
+        return server.createChunkData(world);
+    }
+
+    /**
+     * Creates a boss bar instance to display to players. The progress
+     * defaults to 1.0
+     *
+     * @param title the title of the boss bar
+     * @param color the color of the boss bar
+     * @param style the style of the boss bar
+     * @param flags an optional list of flags to set on the boss bar
+     * @return the created boss bar
+     */
+    public static BossBar createBossBar(String title, BarColor color, BarStyle style, BarFlag... flags) {
+        return server.createBossBar(title, color, style, flags);
+    }
+
+    /**
+     * Gets the current server TPS
+     * @return current server TPS (1m, 5m, 15m in Paper-Server)
+     */
+    public static double[] getTPS() {
+        return server.getTPS();
+    }
+
+    /**
+     * @see UnsafeValues
+     * @return the unsafe values instance
+     */
+    @Deprecated
+    public static UnsafeValues getUnsafe() {
+        return server.getUnsafe();
+    }
+
+    // Paper start
+    /**
+     * Gets the active {@link CommandMap}
+     *
+     * @return the active command map
+     */
+    public static CommandMap getCommandMap() {
+        return server.getCommandMap();
+    }
+
+    /**
+     * Reload the Permissions in permissions.yml
+     */
+    public static void reloadPermissions() {
+        server.reloadPermissions();
+    }
+
+    /**
+     * Find an entity on the server by its UUID
+     *
+     * @param uuid The UUID of the entity
+     * @return The entity that is identified by the given UUID, or null if one isn't found
+     */
+    public static Entity getEntity(UUID uuid) {
+        return server.getEntity(uuid);
+    }
+    // Paper end
+
+    public static Server.Spigot spigot()
+    {
+        return server.spigot();
+    }
+	
+	// Paper start
+    /**
+     * Get the server's profile lookup
+     *
+     * @return the server's profile lookup
+     */
+    public static ProfileLookup getProfileLookup() {
+        return getServer().getProfileLookup();
+    }
+    // Paper end
+}
diff --git a/src/main/java/org/bukkit/OfflinePlayer.java b/src/main/java/org/bukkit/OfflinePlayer.java
new file mode 100644
index 0000000..dfaefba
--- /dev/null
+++ b/src/main/java/org/bukkit/OfflinePlayer.java
@@ -0,0 +1,129 @@
+package org.bukkit;
+
+import java.util.Date;
+import java.util.UUID;
+
+import org.bukkit.configuration.serialization.ConfigurationSerializable;
+import org.bukkit.entity.AnimalTamer;
+import org.bukkit.entity.Player;
+import org.bukkit.permissions.ServerOperator;
+
+import com.destroystokyo.paper.profile.AccountProfile; // Paper
+
+public interface OfflinePlayer extends ServerOperator, AnimalTamer, ConfigurationSerializable {
+
+    /**
+     * Checks if this player is currently online
+     *
+     * @return true if they are online
+     */
+    public boolean isOnline();
+
+    /**
+     * Returns the name of this player
+     * <p>
+     * Names are no longer unique past a single game session. For persistent storage
+     * it is recommended that you use {@link #getUniqueId()} instead.
+     *
+     * @return Player name or null if we have not seen a name for this player yet
+     */
+    public String getName();
+
+    /**
+     * Returns the UUID of this player
+     *
+     * @return Player UUID
+     */
+    public UUID getUniqueId();
+
+    /**
+     * Checks if this player is banned or not
+     *
+     * @return true if banned, otherwise false
+     */
+    public boolean isBanned();
+
+    /**
+     * Bans or unbans this player
+     *
+     * @param banned true if banned
+     * @deprecated Use {@link org.bukkit.BanList#addBan(String, String, Date,
+     *     String)} or {@link org.bukkit.BanList#pardon(String)} to enhance
+     *     functionality
+     */
+    @Deprecated
+    public void setBanned(boolean banned);
+
+    /**
+     * Checks if this player is whitelisted or not
+     *
+     * @return true if whitelisted
+     */
+    public boolean isWhitelisted();
+
+    /**
+     * Sets if this player is whitelisted or not
+     *
+     * @param value true if whitelisted
+     */
+    public void setWhitelisted(boolean value);
+
+    /**
+     * Gets a {@link Player} object that this represents, if there is one
+     * <p>
+     * If the player is online, this will return that player. Otherwise,
+     * it will return null.
+     *
+     * @return Online player
+     */
+    public Player getPlayer();
+
+    /**
+     * Gets the first date and time that this player was witnessed on this
+     * server.
+     * <p>
+     * If the player has never played before, this will return 0. Otherwise,
+     * it will be the amount of milliseconds since midnight, January 1, 1970
+     * UTC.
+     *
+     * @return Date of first log-in for this player, or 0
+     */
+    public long getFirstPlayed();
+
+    /**
+     * Gets the last date and time that this player was witnessed on this
+     * server.
+     * <p>
+     * If the player has never played before, this will return 0. Otherwise,
+     * it will be the amount of milliseconds since midnight, January 1, 1970
+     * UTC.
+     *
+     * @return Date of last log-in for this player, or 0
+     */
+    public long getLastPlayed();
+
+    /**
+     * Checks if this player has played on this server before.
+     *
+     * @return True if the player has played before, otherwise false
+     */
+    public boolean hasPlayedBefore();
+
+    /**
+     * Gets the Location where the player will spawn at their bed, null if
+     * they have not slept in one or their current bed spawn is invalid.
+     *
+     * @return Bed Spawn Location if bed exists, otherwise null.
+     */
+    public Location getBedSpawnLocation();
+	
+	// Paper start
+    /**
+     * Return this player's profile
+     *
+     * @return this player's profile
+     */
+    public AccountProfile getAccount();
+    // Paper end
+
+}
diff --git a/src/main/java/org/bukkit/Player.java b/src/main/java/org/bukkit/Player.java
new file mode 100644
index 0000000..9436cc7
--- /dev/null
+++ b/src/main/java/org/bukkit/Player.java
@@ -0,0 +1,1622 @@
+package org.bukkit.entity;
+
+import java.net.InetSocketAddress;
+
+import com.destroystokyo.paper.Title;
+import org.bukkit.Achievement;
+import org.bukkit.ChatColor;
+import org.bukkit.Effect;
+import org.bukkit.GameMode;
+import org.bukkit.Instrument;
+import org.bukkit.Location;
+import org.bukkit.Material;
+import org.bukkit.Note;
+import org.bukkit.OfflinePlayer;
+import org.bukkit.Particle;
+import org.bukkit.Sound;
+import org.bukkit.Statistic;
+import org.bukkit.WeatherType;
+import org.bukkit.command.CommandSender;
+import org.bukkit.conversations.Conversable;
+import org.bukkit.map.MapView;
+import org.bukkit.plugin.messaging.PluginMessageRecipient;
+import org.bukkit.scoreboard.Scoreboard;
+
+import com.destroystokyo.paper.profile.AccountProfile; // Paper
+
+/**
+ * Represents a player, connected or not
+ */
+public interface Player extends HumanEntity, Conversable, CommandSender, OfflinePlayer, PluginMessageRecipient {
+
+    /**
+     * Gets the "friendly" name to display of this player. This may include
+     * color.
+     * <p>
+     * Note that this name will not be displayed in game, only in chat and
+     * places defined by plugins.
+     *
+     * @return the friendly name
+     */
+    public String getDisplayName();
+
+    /**
+     * Sets the "friendly" name to display of this player. This may include
+     * color.
+     * <p>
+     * Note that this name will not be displayed in game, only in chat and
+     * places defined by plugins.
+     *
+     * @param name The new display name.
+     */
+    public void setDisplayName(String name);
+
+    /**
+     * Gets the name that is shown on the player list.
+     *
+     * @return the player list name
+     */
+    public String getPlayerListName();
+
+    /**
+     * Sets the name that is shown on the in-game player list.
+     * <p>
+     * The name cannot be longer than 16 characters, but {@link ChatColor} is
+     * supported.
+     * <p>
+     * If the value is null, the name will be identical to {@link #getName()}.
+     * <p>
+     * This name is case sensitive and unique, two names with different casing
+     * will appear as two different people. If a player joins afterwards with
+     * a name that conflicts with a player's custom list name, the joining
+     * player's player list name will have a random number appended to it (1-2
+     * characters long in the default implementation). If the joining player's
+     * name is 15 or 16 characters long, part of the name will be truncated at
+     * the end to allow the addition of the two digits.
+     *
+     * @param name new player list name
+     * @throws IllegalArgumentException if the name is already used by someone
+     *     else
+     * @throws IllegalArgumentException if the length of the name is too long
+     */
+    public void setPlayerListName(String name);
+
+    /**
+     * Set the target of the player's compass.
+     *
+     * @param loc Location to point to
+     */
+    public void setCompassTarget(Location loc);
+
+    /**
+     * Get the previously set compass target.
+     *
+     * @return location of the target
+     */
+    public Location getCompassTarget();
+
+    /**
+     * Gets the socket address of this player
+     *
+     * @return the player's address
+     */
+    public InetSocketAddress getAddress();
+
+    /**
+     * Sends this sender a message raw
+     *
+     * @param message Message to be displayed
+     */
+    public void sendRawMessage(String message);
+
+    /**
+     * Kicks player with custom kick message.
+     *
+     * @param message kick message
+     */
+    public void kickPlayer(String message);
+
+    /**
+     * Says a message (or runs a command).
+     *
+     * @param msg message to print
+     */
+    public void chat(String msg);
+
+    /**
+     * Makes the player perform the given command
+     *
+     * @param command Command to perform
+     * @return true if the command was successful, otherwise false
+     */
+    public boolean performCommand(String command);
+
+    /**
+     * Returns if the player is in sneak mode
+     *
+     * @return true if player is in sneak mode
+     */
+    public boolean isSneaking();
+
+    /**
+     * Sets the sneak mode the player
+     *
+     * @param sneak true if player should appear sneaking
+     */
+    public void setSneaking(boolean sneak);
+
+    /**
+     * Gets whether the player is sprinting or not.
+     *
+     * @return true if player is sprinting.
+     */
+    public boolean isSprinting();
+
+    /**
+     * Sets whether the player is sprinting or not.
+     *
+     * @param sprinting true if the player should be sprinting
+     */
+    public void setSprinting(boolean sprinting);
+
+    /**
+     * Saves the players current location, health, inventory, motion, and
+     * other information into the username.dat file, in the world/player
+     * folder
+     */
+    public void saveData();
+
+    /**
+     * Loads the players current location, health, inventory, motion, and
+     * other information from the username.dat file, in the world/player
+     * folder.
+     * <p>
+     * Note: This will overwrite the players current inventory, health,
+     * motion, etc, with the state from the saved dat file.
+     */
+    public void loadData();
+
+    /**
+     * Sets whether the player is ignored as not sleeping. If everyone is
+     * either sleeping or has this flag set, then time will advance to the
+     * next day. If everyone has this flag set but no one is actually in bed,
+     * then nothing will happen.
+     *
+     * @param isSleeping Whether to ignore.
+     */
+    public void setSleepingIgnored(boolean isSleeping);
+
+    /**
+     * Returns whether the player is sleeping ignored.
+     *
+     * @return Whether player is ignoring sleep.
+     */
+    public boolean isSleepingIgnored();
+
+    /**
+     * Play a note for a player at a location. This requires a note block
+     * at the particular location (as far as the client is concerned). This
+     * will not work without a note block. This will not work with cake.
+     *
+     * @param loc The location of a note block.
+     * @param instrument The instrument ID.
+     * @param note The note ID.
+     * @deprecated Magic value
+     */
+    @Deprecated
+    public void playNote(Location loc, byte instrument, byte note);
+
+    /**
+     * Play a note for a player at a location. This requires a note block
+     * at the particular location (as far as the client is concerned). This
+     * will not work without a note block. This will not work with cake.
+     *
+     * @param loc The location of a note block
+     * @param instrument The instrument
+     * @param note The note
+     */
+    public void playNote(Location loc, Instrument instrument, Note note);
+
+
+    /**
+     * Play a sound for a player at the location.
+     * <p>
+     * This function will fail silently if Location or Sound are null.
+     *
+     * @param location The location to play the sound
+     * @param sound The sound to play
+     * @param volume The volume of the sound
+     * @param pitch The pitch of the sound
+     */
+    public void playSound(Location location, Sound sound, float volume, float pitch);
+
+    /**
+     * Play a sound for a player at the location.
+     * <p>
+     * This function will fail silently if Location or Sound are null. No
+     * sound will be heard by the player if their client does not have the
+     * respective sound for the value passed.
+     *
+     * @param location the location to play the sound
+     * @param sound the internal sound name to play
+     * @param volume the volume of the sound
+     * @param pitch the pitch of the sound
+     */
+    public void playSound(Location location, String sound, float volume, float pitch);
+
+    /**
+     * Plays an effect to just this player.
+     *
+     * @param loc the location to play the effect at
+     * @param effect the {@link Effect}
+     * @param data a data bit needed for some effects
+     * @deprecated Magic value
+     */
+    @Deprecated
+    public void playEffect(Location loc, Effect effect, int data);
+
+    /**
+     * Plays an effect to just this player.
+     *
+     * @param <T> the data based based on the type of the effect
+     * @param loc the location to play the effect at
+     * @param effect the {@link Effect}
+     * @param data a data bit needed for some effects
+     */
+    public <T> void playEffect(Location loc, Effect effect, T data);
+
+    /**
+     * Send a block change. This fakes a block change packet for a user at a
+     * certain location. This will not actually change the world in any way.
+     *
+     * @param loc The location of the changed block
+     * @param material The new block
+     * @param data The block data
+     * @deprecated Magic value
+     */
+    @Deprecated
+    public void sendBlockChange(Location loc, Material material, byte data);
+
+    /**
+     * Send a chunk change. This fakes a chunk change packet for a user at a
+     * certain location. The updated cuboid must be entirely within a single
+     * chunk. This will not actually change the world in any way.
+     * <p>
+     * At least one of the dimensions of the cuboid must be even. The size of
+     * the data buffer must be 2.5*sx*sy*sz and formatted in accordance with
+     * the Packet51 format.
+     *
+     * @param loc The location of the cuboid
+     * @param sx The x size of the cuboid
+     * @param sy The y size of the cuboid
+     * @param sz The z size of the cuboid
+     * @param data The data to be sent
+     * @return true if the chunk change packet was sent
+     * @deprecated Magic value
+     */
+    @Deprecated
+    public boolean sendChunkChange(Location loc, int sx, int sy, int sz, byte[] data);
+
+    /**
+     * Send a block change. This fakes a block change packet for a user at a
+     * certain location. This will not actually change the world in any way.
+     *
+     * @param loc The location of the changed block
+     * @param material The new block ID
+     * @param data The block data
+     * @deprecated Magic value
+     */
+    @Deprecated
+    public void sendBlockChange(Location loc, int material, byte data);
+
+    /**
+     * Send a sign change. This fakes a sign change packet for a user at
+     * a certain location. This will not actually change the world in any way.
+     * This method will use a sign at the location's block or a faked sign
+     * sent via {@link #sendBlockChange(org.bukkit.Location, int, byte)} or
+     * {@link #sendBlockChange(org.bukkit.Location, org.bukkit.Material, byte)}.
+     * <p>
+     * If the client does not have a sign at the given location it will
+     * display an error message to the user.
+     *
+     * @param loc the location of the sign
+     * @param lines the new text on the sign or null to clear it
+     * @throws IllegalArgumentException if location is null
+     * @throws IllegalArgumentException if lines is non-null and has a length less than 4
+     */
+    public void sendSignChange(Location loc, String[] lines) throws IllegalArgumentException;
+
+    /**
+     * Render a map and send it to the player in its entirety. This may be
+     * used when streaming the map in the normal manner is not desirable.
+     *
+     * @param map The map to be sent
+     */
+    public void sendMap(MapView map);
+
+    // Paper start
+    /**
+     * Sends the component to the player
+     *
+     * @param component the components to send
+     */
+    @Override
+    public void sendMessage(net.md_5.bungee.api.chat.BaseComponent component);
+
+    /**
+     * Sends an array of components as a single message to the player
+     *
+     * @param components the components to send
+     */
+    @Override
+    public void sendMessage(net.md_5.bungee.api.chat.BaseComponent... components);
+
+    /**
+     * Sends an array of components as a single message to the specified screen position of this player
+     *
+     * @param position the screen position
+     * @param components the components to send
+     */
+    public void sendMessage(net.md_5.bungee.api.ChatMessageType position, net.md_5.bungee.api.chat.BaseComponent... components);
+
+    /**
+     * Set the text displayed in the player list header and footer for this player
+     *
+     * @param header content for the top of the player list
+     * @param footer content for the bottom of the player list
+     */
+    public void setPlayerListHeaderFooter(net.md_5.bungee.api.chat.BaseComponent[] header, net.md_5.bungee.api.chat.BaseComponent[] footer);
+
+    /**
+     * Set the text displayed in the player list header and footer for this player
+     *
+     * @param header content for the top of the player list
+     * @param footer content for the bottom of the player list
+     */
+    public void setPlayerListHeaderFooter(net.md_5.bungee.api.chat.BaseComponent header, net.md_5.bungee.api.chat.BaseComponent footer);
+
+    /**
+     * Update the times for titles displayed to the player
+     *
+     * @param fadeInTicks  ticks to fade-in
+     * @param stayTicks    ticks to stay visible
+     * @param fadeOutTicks ticks to fade-out
+     * @deprecated Use {@link #updateTitle(Title)}
+     */
+    @Deprecated
+    public void setTitleTimes(int fadeInTicks, int stayTicks, int fadeOutTicks);
+
+    /**
+     * Update the subtitle of titles displayed to the player
+     *
+     * @deprecated Use {@link #updateTitle(Title)}
+     */
+    @Deprecated
+    public void setSubtitle(net.md_5.bungee.api.chat.BaseComponent[] subtitle);
+
+    /**
+     * Update the subtitle of titles displayed to the player
+     *
+     * @deprecated Use {@link #updateTitle(Title)}
+     */
+    @Deprecated
+    public void setSubtitle(net.md_5.bungee.api.chat.BaseComponent subtitle);
+
+    /**
+     * Show the given title to the player, along with the last subtitle set, using the last set times
+     *
+     * @deprecated Use {@link #sendTitle(Title)} or {@link #updateTitle(Title)}
+     */
+    @Deprecated
+    public void showTitle(net.md_5.bungee.api.chat.BaseComponent[] title);
+
+    /**
+     * Show the given title to the player, along with the last subtitle set, using the last set times
+     *
+     * @deprecated Use {@link #sendTitle(Title)} or {@link #updateTitle(Title)}
+     */
+    @Deprecated
+    public void showTitle(net.md_5.bungee.api.chat.BaseComponent title);
+
+    /**
+     * Show the given title and subtitle to the player using the given times
+     *
+     * @param title        big text
+     * @param subtitle     little text under it
+     * @param fadeInTicks  ticks to fade-in
+     * @param stayTicks    ticks to stay visible
+     * @param fadeOutTicks ticks to fade-out
+     * @deprecated Use {@link #sendTitle(Title)} or {@link #updateTitle(Title)}
+     */
+    @Deprecated
+    public void showTitle(net.md_5.bungee.api.chat.BaseComponent[] title, net.md_5.bungee.api.chat.BaseComponent[] subtitle, int fadeInTicks, int stayTicks, int fadeOutTicks);
+
+    /**
+     * Show the given title and subtitle to the player using the given times
+     *
+     * @param title        big text
+     * @param subtitle     little text under it
+     * @param fadeInTicks  ticks to fade-in
+     * @param stayTicks    ticks to stay visible
+     * @param fadeOutTicks ticks to fade-out
+     * @deprecated Use {@link #sendTitle(Title)} or {@link #updateTitle(Title)}
+     */
+    @Deprecated
+    public void showTitle(net.md_5.bungee.api.chat.BaseComponent title, net.md_5.bungee.api.chat.BaseComponent subtitle, int fadeInTicks, int stayTicks, int fadeOutTicks);
+
+    /**
+     * Show the title to the player, overriding any previously displayed title.
+     * <p>
+     * <p>This method overrides any previous title, use {@link #updateTitle(Title)} to change the existing one.</p>
+     *
+     * @param title the title to send
+     * @throws NullPointerException if the title is null
+     */
+    void sendTitle(Title title);
+
+    /**
+     * Show the title to the player, overriding any previously displayed title.
+     * <p>
+     * <p>This method doesn't override previous titles, but changes their values.</p>
+     *
+     * @param title the title to send
+     * @throws NullPointerException if title is null
+     */
+    void updateTitle(Title title);
+
+    /**
+     * Hide any title that is currently visible to the player
+     */
+    public void hideTitle();
+    // Paper end
+
+    /**
+     * Forces an update of the player's entire inventory.
+     *
+     */
+    //@Deprecated // Spigot - undeprecate
+    public void updateInventory();
+
+    /**
+     * Awards the given achievement and any parent achievements that the
+     * player does not have.
+     *
+     * @param achievement Achievement to award
+     * @throws IllegalArgumentException if achievement is null
+     */
+    public void awardAchievement(Achievement achievement);
+
+    /**
+     * Removes the given achievement and any children achievements that the
+     * player has.
+     *
+     * @param achievement Achievement to remove
+     * @throws IllegalArgumentException if achievement is null
+     */
+    public void removeAchievement(Achievement achievement);
+
+    /**
+     * Gets whether this player has the given achievement.
+     *
+     * @param achievement the achievement to check
+     * @return whether the player has the achievement
+     * @throws IllegalArgumentException if achievement is null
+     */
+    public boolean hasAchievement(Achievement achievement);
+
+    /**
+     * Increments the given statistic for this player.
+     * <p>
+     * This is equivalent to the following code:
+     * <code>incrementStatistic(Statistic, 1)</code>
+     *
+     * @param statistic Statistic to increment
+     * @throws IllegalArgumentException if statistic is null
+     * @throws IllegalArgumentException if the statistic requires an
+     *     additional parameter
+     */
+    public void incrementStatistic(Statistic statistic) throws IllegalArgumentException;
+
+    /**
+     * Decrements the given statistic for this player.
+     * <p>
+     * This is equivalent to the following code:
+     * <code>decrementStatistic(Statistic, 1)</code>
+     *
+     * @param statistic Statistic to decrement
+     * @throws IllegalArgumentException if statistic is null
+     * @throws IllegalArgumentException if the statistic requires an
+     *     additional parameter
+     */
+    public void decrementStatistic(Statistic statistic) throws IllegalArgumentException;
+
+    /**
+     * Increments the given statistic for this player.
+     *
+     * @param statistic Statistic to increment
+     * @param amount Amount to increment this statistic by
+     * @throws IllegalArgumentException if statistic is null
+     * @throws IllegalArgumentException if amount is negative
+     * @throws IllegalArgumentException if the statistic requires an
+     *     additional parameter
+     */
+    public void incrementStatistic(Statistic statistic, int amount) throws IllegalArgumentException;
+
+    /**
+     * Decrements the given statistic for this player.
+     *
+     * @param statistic Statistic to decrement
+     * @param amount Amount to decrement this statistic by
+     * @throws IllegalArgumentException if statistic is null
+     * @throws IllegalArgumentException if amount is negative
+     * @throws IllegalArgumentException if the statistic requires an
+     *     additional parameter
+     */
+    public void decrementStatistic(Statistic statistic, int amount) throws IllegalArgumentException;
+
+    /**
+     * Sets the given statistic for this player.
+     *
+     * @param statistic Statistic to set
+     * @param newValue The value to set this statistic to
+     * @throws IllegalArgumentException if statistic is null
+     * @throws IllegalArgumentException if newValue is negative
+     * @throws IllegalArgumentException if the statistic requires an
+     *     additional parameter
+     */
+    public void setStatistic(Statistic statistic, int newValue) throws IllegalArgumentException;
+
+    /**
+     * Gets the value of the given statistic for this player.
+     *
+     * @param statistic Statistic to check
+     * @return the value of the given statistic
+     * @throws IllegalArgumentException if statistic is null
+     * @throws IllegalArgumentException if the statistic requires an
+     *     additional parameter
+     */
+    public int getStatistic(Statistic statistic) throws IllegalArgumentException;
+
+    /**
+     * Increments the given statistic for this player for the given material.
+     * <p>
+     * This is equivalent to the following code:
+     * <code>incrementStatistic(Statistic, Material, 1)</code>
+     *
+     * @param statistic Statistic to increment
+     * @param material Material to offset the statistic with
+     * @throws IllegalArgumentException if statistic is null
+     * @throws IllegalArgumentException if material is null
+     * @throws IllegalArgumentException if the given parameter is not valid
+     *     for the statistic
+     */
+    public void incrementStatistic(Statistic statistic, Material material) throws IllegalArgumentException;
+
+    /**
+     * Decrements the given statistic for this player for the given material.
+     * <p>
+     * This is equivalent to the following code:
+     * <code>decrementStatistic(Statistic, Material, 1)</code>
+     *
+     * @param statistic Statistic to decrement
+     * @param material Material to offset the statistic with
+     * @throws IllegalArgumentException if statistic is null
+     * @throws IllegalArgumentException if material is null
+     * @throws IllegalArgumentException if the given parameter is not valid
+     *     for the statistic
+     */
+    public void decrementStatistic(Statistic statistic, Material material) throws IllegalArgumentException;
+
+    /**
+     * Gets the value of the given statistic for this player.
+     *
+     * @param statistic Statistic to check
+     * @param material Material offset of the statistic
+     * @return the value of the given statistic
+     * @throws IllegalArgumentException if statistic is null
+     * @throws IllegalArgumentException if material is null
+     * @throws IllegalArgumentException if the given parameter is not valid
+     *     for the statistic
+     */
+    public int getStatistic(Statistic statistic, Material material) throws IllegalArgumentException;
+
+    /**
+     * Increments the given statistic for this player for the given material.
+     *
+     * @param statistic Statistic to increment
+     * @param material Material to offset the statistic with
+     * @param amount Amount to increment this statistic by
+     * @throws IllegalArgumentException if statistic is null
+     * @throws IllegalArgumentException if material is null
+     * @throws IllegalArgumentException if amount is negative
+     * @throws IllegalArgumentException if the given parameter is not valid
+     *     for the statistic
+     */
+    public void incrementStatistic(Statistic statistic, Material material, int amount) throws IllegalArgumentException;
+
+    /**
+     * Decrements the given statistic for this player for the given material.
+     *
+     * @param statistic Statistic to decrement
+     * @param material Material to offset the statistic with
+     * @param amount Amount to decrement this statistic by
+     * @throws IllegalArgumentException if statistic is null
+     * @throws IllegalArgumentException if material is null
+     * @throws IllegalArgumentException if amount is negative
+     * @throws IllegalArgumentException if the given parameter is not valid
+     *     for the statistic
+     */
+    public void decrementStatistic(Statistic statistic, Material material, int amount) throws IllegalArgumentException;
+
+    /**
+     * Sets the given statistic for this player for the given material.
+     *
+     * @param statistic Statistic to set
+     * @param material Material to offset the statistic with
+     * @param newValue The value to set this statistic to
+     * @throws IllegalArgumentException if statistic is null
+     * @throws IllegalArgumentException if material is null
+     * @throws IllegalArgumentException if newValue is negative
+     * @throws IllegalArgumentException if the given parameter is not valid
+     *     for the statistic
+     */
+    public void setStatistic(Statistic statistic, Material material, int newValue) throws IllegalArgumentException;
+
+    /**
+     * Increments the given statistic for this player for the given entity.
+     * <p>
+     * This is equivalent to the following code:
+     * <code>incrementStatistic(Statistic, EntityType, 1)</code>
+     *
+     * @param statistic Statistic to increment
+     * @param entityType EntityType to offset the statistic with
+     * @throws IllegalArgumentException if statistic is null
+     * @throws IllegalArgumentException if entityType is null
+     * @throws IllegalArgumentException if the given parameter is not valid
+     *     for the statistic
+     */
+    public void incrementStatistic(Statistic statistic, EntityType entityType) throws IllegalArgumentException;
+
+    /**
+     * Decrements the given statistic for this player for the given entity.
+     * <p>
+     * This is equivalent to the following code:
+     * <code>decrementStatistic(Statistic, EntityType, 1)</code>
+     *
+     * @param statistic Statistic to decrement
+     * @param entityType EntityType to offset the statistic with
+     * @throws IllegalArgumentException if statistic is null
+     * @throws IllegalArgumentException if entityType is null
+     * @throws IllegalArgumentException if the given parameter is not valid
+     *     for the statistic
+     */
+    public void decrementStatistic(Statistic statistic, EntityType entityType) throws IllegalArgumentException;
+
+    /**
+     * Gets the value of the given statistic for this player.
+     *
+     * @param statistic Statistic to check
+     * @param entityType EntityType offset of the statistic
+     * @return the value of the given statistic
+     * @throws IllegalArgumentException if statistic is null
+     * @throws IllegalArgumentException if entityType is null
+     * @throws IllegalArgumentException if the given parameter is not valid
+     *     for the statistic
+     */
+    public int getStatistic(Statistic statistic, EntityType entityType) throws IllegalArgumentException;
+
+    /**
+     * Increments the given statistic for this player for the given entity.
+     *
+     * @param statistic Statistic to increment
+     * @param entityType EntityType to offset the statistic with
+     * @param amount Amount to increment this statistic by
+     * @throws IllegalArgumentException if statistic is null
+     * @throws IllegalArgumentException if entityType is null
+     * @throws IllegalArgumentException if amount is negative
+     * @throws IllegalArgumentException if the given parameter is not valid
+     *     for the statistic
+     */
+    public void incrementStatistic(Statistic statistic, EntityType entityType, int amount) throws IllegalArgumentException;
+
+    /**
+     * Decrements the given statistic for this player for the given entity.
+     *
+     * @param statistic Statistic to decrement
+     * @param entityType EntityType to offset the statistic with
+     * @param amount Amount to decrement this statistic by
+     * @throws IllegalArgumentException if statistic is null
+     * @throws IllegalArgumentException if entityType is null
+     * @throws IllegalArgumentException if amount is negative
+     * @throws IllegalArgumentException if the given parameter is not valid
+     *     for the statistic
+     */
+    public void decrementStatistic(Statistic statistic, EntityType entityType, int amount);
+
+    /**
+     * Sets the given statistic for this player for the given entity.
+     *
+     * @param statistic Statistic to set
+     * @param entityType EntityType to offset the statistic with
+     * @param newValue The value to set this statistic to
+     * @throws IllegalArgumentException if statistic is null
+     * @throws IllegalArgumentException if entityType is null
+     * @throws IllegalArgumentException if newValue is negative
+     * @throws IllegalArgumentException if the given parameter is not valid
+     *     for the statistic
+     */
+    public void setStatistic(Statistic statistic, EntityType entityType, int newValue);
+
+    /**
+     * Sets the current time on the player's client. When relative is true the
+     * player's time will be kept synchronized to its world time with the
+     * specified offset.
+     * <p>
+     * When using non relative time the player's time will stay fixed at the
+     * specified time parameter. It's up to the caller to continue updating
+     * the player's time. To restore player time to normal use
+     * resetPlayerTime().
+     *
+     * @param time The current player's perceived time or the player's time
+     *     offset from the server time.
+     * @param relative When true the player time is kept relative to its world
+     *     time.
+     */
+    public void setPlayerTime(long time, boolean relative);
+
+    /**
+     * Returns the player's current timestamp.
+     *
+     * @return The player's time
+     */
+    public long getPlayerTime();
+
+    /**
+     * Returns the player's current time offset relative to server time, or
+     * the current player's fixed time if the player's time is absolute.
+     *
+     * @return The player's time
+     */
+    public long getPlayerTimeOffset();
+
+    /**
+     * Returns true if the player's time is relative to the server time,
+     * otherwise the player's time is absolute and will not change its current
+     * time unless done so with setPlayerTime().
+     *
+     * @return true if the player's time is relative to the server time.
+     */
+    public boolean isPlayerTimeRelative();
+
+    /**
+     * Restores the normal condition where the player's time is synchronized
+     * with the server time.
+     * <p>
+     * Equivalent to calling setPlayerTime(0, true).
+     */
+    public void resetPlayerTime();
+
+    /**
+     * Sets the type of weather the player will see.  When used, the weather
+     * status of the player is locked until {@link #resetPlayerWeather()} is
+     * used.
+     *
+     * @param type The WeatherType enum type the player should experience
+     */
+    public void setPlayerWeather(WeatherType type);
+
+    /**
+     * Returns the type of weather the player is currently experiencing.
+     *
+     * @return The WeatherType that the player is currently experiencing or
+     *     null if player is seeing server weather.
+     */
+    public WeatherType getPlayerWeather();
+
+    /**
+     * Restores the normal condition where the player's weather is controlled
+     * by server conditions.
+     */
+    public void resetPlayerWeather();
+
+    /**
+     * Gives the player the amount of experience specified.
+     *
+     * @param amount Exp amount to give
+     */
+    public void giveExp(int amount);
+
+    /**
+     * Gives the player the amount of experience levels specified. Levels can
+     * be taken by specifying a negative amount.
+     *
+     * @param amount amount of experience levels to give or take
+     */
+    public void giveExpLevels(int amount);
+
+    /**
+     * Gets the players current experience points towards the next level.
+     * <p>
+     * This is a percentage value. 0 is "no progress" and 1 is "next level".
+     *
+     * @return Current experience points
+     */
+    public float getExp();
+
+    /**
+     * Sets the players current experience points towards the next level
+     * <p>
+     * This is a percentage value. 0 is "no progress" and 1 is "next level".
+     *
+     * @param exp New experience points
+     */
+    public void setExp(float exp);
+
+    /**
+     * Gets the players current experience level
+     *
+     * @return Current experience level
+     */
+    public int getLevel();
+
+    /**
+     * Sets the players current experience level
+     *
+     * @param level New experience level
+     */
+    public void setLevel(int level);
+
+    /**
+     * Gets the players total experience points
+     *
+     * @return Current total experience points
+     */
+    public int getTotalExperience();
+
+    /**
+     * Sets the players current experience level
+     *
+     * @param exp New experience level
+     */
+    public void setTotalExperience(int exp);
+
+    /**
+     * Gets the players current exhaustion level.
+     * <p>
+     * Exhaustion controls how fast the food level drops. While you have a
+     * certain amount of exhaustion, your saturation will drop to zero, and
+     * then your food will drop to zero.
+     *
+     * @return Exhaustion level
+     */
+    public float getExhaustion();
+
+    /**
+     * Sets the players current exhaustion level
+     *
+     * @param value Exhaustion level
+     */
+    public void setExhaustion(float value);
+
+    /**
+     * Gets the players current saturation level.
+     * <p>
+     * Saturation is a buffer for food level. Your food level will not drop if
+     * you are saturated {@literal >} 0.
+     *
+     * @return Saturation level
+     */
+    public float getSaturation();
+
+    /**
+     * Sets the players current saturation level
+     *
+     * @param value Saturation level
+     */
+    public void setSaturation(float value);
+
+    /**
+     * Gets the players current food level
+     *
+     * @return Food level
+     */
+    public int getFoodLevel();
+
+    /**
+     * Sets the players current food level
+     *
+     * @param value New food level
+     */
+    public void setFoodLevel(int value);
+
+    /**
+     * Gets the Location where the player will spawn at their bed, null if
+     * they have not slept in one or their current bed spawn is invalid.
+     *
+     * @return Bed Spawn Location if bed exists, otherwise null.
+     */
+    public Location getBedSpawnLocation();
+
+    /**
+     * Sets the Location where the player will spawn at their bed.
+     *
+     * @param location where to set the respawn location
+     */
+    public void setBedSpawnLocation(Location location);
+
+    /**
+     * Sets the Location where the player will spawn at their bed.
+     *
+     * @param location where to set the respawn location
+     * @param force whether to forcefully set the respawn location even if a
+     *     valid bed is not present
+     */
+    public void setBedSpawnLocation(Location location, boolean force);
+
+    /**
+     * Determines if the Player is allowed to fly via jump key double-tap like
+     * in creative mode.
+     *
+     * @return True if the player is allowed to fly.
+     */
+    public boolean getAllowFlight();
+
+    /**
+     * Sets if the Player is allowed to fly via jump key double-tap like in
+     * creative mode.
+     *
+     * @param flight If flight should be allowed.
+     */
+    public void setAllowFlight(boolean flight);
+
+    /**
+     * Hides a player from this player
+     *
+     * @param player Player to hide
+     */
+    public void hidePlayer(Player player);
+
+    /**
+     * Allows this player to see a player that was previously hidden
+     *
+     * @param player Player to show
+     */
+    public void showPlayer(Player player);
+
+    /**
+     * Checks to see if a player has been hidden from this player
+     *
+     * @param player Player to check
+     * @return True if the provided player is not being hidden from this
+     *     player
+     */
+    public boolean canSee(Player player);
+
+    /**
+     * Checks to see if this player is currently standing on a block. This
+     * information may not be reliable, as it is a state provided by the
+     * client, and may therefore not be accurate.
+     *
+     * @return True if the player standing on a solid block, else false.
+     * @deprecated Inconsistent with {@link
+     *     org.bukkit.entity.Entity#isOnGround()}
+     */
+    @Deprecated
+    public boolean isOnGround();
+
+    /**
+     * Checks to see if this player is currently flying or not.
+     *
+     * @return True if the player is flying, else false.
+     */
+    public boolean isFlying();
+
+    /**
+     * Makes this player start or stop flying.
+     *
+     * @param value True to fly.
+     */
+    public void setFlying(boolean value);
+
+    /**
+     * Sets the speed at which a client will fly. Negative values indicate
+     * reverse directions.
+     *
+     * @param value The new speed, from -1 to 1.
+     * @throws IllegalArgumentException If new speed is less than -1 or
+     *     greater than 1
+     */
+    public void setFlySpeed(float value) throws IllegalArgumentException;
+
+    /**
+     * Sets the speed at which a client will walk. Negative values indicate
+     * reverse directions.
+     *
+     * @param value The new speed, from -1 to 1.
+     * @throws IllegalArgumentException If new speed is less than -1 or
+     *     greater than 1
+     */
+    public void setWalkSpeed(float value) throws IllegalArgumentException;
+
+    /**
+     * Gets the current allowed speed that a client can fly.
+     *
+     * @return The current allowed speed, from -1 to 1
+     */
+    public float getFlySpeed();
+
+    /**
+     * Gets the current allowed speed that a client can walk.
+     *
+     * @return The current allowed speed, from -1 to 1
+     */
+    public float getWalkSpeed();
+
+    /**
+     * Request that the player's client download and switch texture packs.
+     * <p>
+     * The player's client will download the new texture pack asynchronously
+     * in the background, and will automatically switch to it once the
+     * download is complete. If the client has downloaded and cached the same
+     * texture pack in the past, it will perform a quick timestamp check over
+     * the network to determine if the texture pack has changed and needs to
+     * be downloaded again. When this request is sent for the very first time
+     * from a given server, the client will first display a confirmation GUI
+     * to the player before proceeding with the download.
+     * <p>
+     * Notes:
+     * <ul>
+     * <li>Players can disable server textures on their client, in which
+     *     case this method will have no affect on them.
+     * <li>There is no concept of resetting texture packs back to default
+     *     within Minecraft, so players will have to relog to do so.
+     * </ul>
+     *
+     * @param url The URL from which the client will download the texture
+     *     pack. The string must contain only US-ASCII characters and should
+     *     be encoded as per RFC 1738.
+     * @throws IllegalArgumentException Thrown if the URL is null.
+     * @throws IllegalArgumentException Thrown if the URL is too long.
+     * @deprecated Minecraft no longer uses textures packs. Instead you
+     *     should use {@link #setResourcePack(String)}.
+     */
+    @Deprecated
+    public void setTexturePack(String url);
+
+    /**
+     * Request that the player's client download and switch resource packs.
+     * <p>
+     * The player's client will download the new resource pack asynchronously
+     * in the background, and will automatically switch to it once the
+     * download is complete. If the client has downloaded and cached the same
+     * resource pack in the past, it will perform a quick timestamp check
+     * over the network to determine if the resource pack has changed and
+     * needs to be downloaded again. When this request is sent for the very
+     * first time from a given server, the client will first display a
+     * confirmation GUI to the player before proceeding with the download.
+     * <p>
+     * Notes:
+     * <ul>
+     * <li>Players can disable server resources on their client, in which
+     *     case this method will have no affect on them.
+     * <li>There is no concept of resetting resource packs back to default
+     *     within Minecraft, so players will have to relog to do so.
+     * </ul>
+     *
+     * @param url The URL from which the client will download the resource
+     *     pack. The string must contain only US-ASCII characters and should
+     *     be encoded as per RFC 1738.
+     * @throws IllegalArgumentException Thrown if the URL is null.
+     * @throws IllegalArgumentException Thrown if the URL is too long. The
+     *     length restriction is an implementation specific arbitrary value.
+     * @deprecated use {@link #setResourcePack(String, String)}
+     */
+    @Deprecated // Paper
+    public void setResourcePack(String url);
+
+    /**
+     * Gets the Scoreboard displayed to this player
+     *
+     * @return The current scoreboard seen by this player
+     */
+    public Scoreboard getScoreboard();
+
+    /**
+     * Sets the player's visible Scoreboard.
+     *
+     * @param scoreboard New Scoreboard for the player
+     * @throws IllegalArgumentException if scoreboard is null
+     * @throws IllegalArgumentException if scoreboard was not created by the
+     *     {@link org.bukkit.scoreboard.ScoreboardManager scoreboard manager}
+     * @throws IllegalStateException if this is a player that is not logged
+     *     yet or has logged out
+     */
+    public void setScoreboard(Scoreboard scoreboard) throws IllegalArgumentException, IllegalStateException;
+
+    /**
+     * Gets if the client is displayed a 'scaled' health, that is, health on a
+     * scale from 0-{@link #getHealthScale()}.
+     *
+     * @return if client health display is scaled
+     * @see Player#setHealthScaled(boolean)
+     */
+    public boolean isHealthScaled();
+
+    /**
+     * Sets if the client is displayed a 'scaled' health, that is, health on a
+     * scale from 0-{@link #getHealthScale()}.
+     * <p>
+     * Displayed health follows a simple formula <code>displayedHealth =
+     * getHealth() / getMaxHealth() * getHealthScale()</code>.
+     *
+     * @param scale if the client health display is scaled
+     */
+    public void setHealthScaled(boolean scale);
+
+    /**
+     * Sets the number to scale health to for the client; this will also
+     * {@link #setHealthScaled(boolean) setHealthScaled(true)}.
+     * <p>
+     * Displayed health follows a simple formula <code>displayedHealth =
+     * getHealth() / getMaxHealth() * getHealthScale()</code>.
+     *
+     * @param scale the number to scale health to
+     * @throws IllegalArgumentException if scale is &lt;0
+     * @throws IllegalArgumentException if scale is {@link Double#NaN}
+     * @throws IllegalArgumentException if scale is too high
+     */
+    public void setHealthScale(double scale) throws IllegalArgumentException;
+
+    /**
+     * Gets the number that health is scaled to for the client.
+     *
+     * @return the number that health would be scaled to for the client if
+     *     HealthScaling is set to true
+     * @see Player#setHealthScale(double)
+     * @see Player#setHealthScaled(boolean)
+     */
+    public double getHealthScale();
+
+    /**
+     * Gets the entity which is followed by the camera when in
+     * {@link GameMode#SPECTATOR}.
+     *
+     * @return the followed entity, or null if not in spectator mode or not
+     * following a specific entity.
+     */
+    public Entity getSpectatorTarget();
+
+    /**
+     * Sets the entity which is followed by the camera when in
+     * {@link GameMode#SPECTATOR}.
+     *
+     * @param entity the entity to follow or null to reset
+     * @throws IllegalStateException if the player is not in
+     * {@link GameMode#SPECTATOR}
+     */
+    public void setSpectatorTarget(Entity entity);
+
+    /**
+     * Sends a title and a subtitle message to the player. If either of these
+     * values are null, they will not be sent and the display will remain
+     * unchanged. If they are empty strings, the display will be updated as
+     * such. If the strings contain a new line, only the first line will be
+     * sent.
+     *
+     * @param title Title text
+     * @param subtitle Subtitle text
+     * @deprecated API subject to change
+     */
+    @Deprecated
+    public void sendTitle(String title, String subtitle);
+
+    /**
+     * Resets the title displayed to the player.
+     * @deprecated API subject to change.
+     */
+    // Paper - undeprecate
+    public void resetTitle();
+
+
+    /**
+     * Spawns the particle (the number of times specified by count)
+     * at the target location.
+     *
+     * @param particle the particle to spawn
+     * @param location the location to spawn at
+     * @param count the number of particles
+     */
+    public void spawnParticle(Particle particle, Location location, int count);
+
+    /**
+     * Spawns the particle (the number of times specified by count)
+     * at the target location.
+     *
+     * @param particle the particle to spawn
+     * @param x the position on the x axis to spawn at
+     * @param y the position on the y axis to spawn at
+     * @param z the position on the z axis to spawn at
+     * @param count the number of particles
+     */
+    public void spawnParticle(Particle particle, double x, double y, double z, int count);
+
+    /**
+     * Spawns the particle (the number of times specified by count)
+     * at the target location.
+     *
+     * @param particle the particle to spawn
+     * @param location the location to spawn at
+     * @param count the number of particles
+     * @param data the data to use for the particle or null,
+     *             the type of this depends on {@link Particle#getDataType()}
+     */
+    public <T> void spawnParticle(Particle particle, Location location, int count, T data);
+
+
+    /**
+     * Spawns the particle (the number of times specified by count)
+     * at the target location.
+     *
+     * @param particle the particle to spawn
+     * @param x the position on the x axis to spawn at
+     * @param y the position on the y axis to spawn at
+     * @param z the position on the z axis to spawn at
+     * @param count the number of particles
+     * @param data the data to use for the particle or null,
+     *             the type of this depends on {@link Particle#getDataType()}
+     */
+    public <T> void spawnParticle(Particle particle, double x, double y, double z, int count, T data);
+
+    /**
+     * Spawns the particle (the number of times specified by count)
+     * at the target location. The position of each particle will be
+     * randomized positively and negatively by the offset parameters
+     * on each axis.
+     *
+     * @param particle the particle to spawn
+     * @param location the location to spawn at
+     * @param count the number of particles
+     * @param offsetX the maximum random offset on the X axis
+     * @param offsetY the maximum random offset on the Y axis
+     * @param offsetZ the maximum random offset on the Z axis
+     */
+    public void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ);
+
+    /**
+     * Spawns the particle (the number of times specified by count)
+     * at the target location. The position of each particle will be
+     * randomized positively and negatively by the offset parameters
+     * on each axis.
+     *
+     * @param particle the particle to spawn
+     * @param x the position on the x axis to spawn at
+     * @param y the position on the y axis to spawn at
+     * @param z the position on the z axis to spawn at
+     * @param count the number of particles
+     * @param offsetX the maximum random offset on the X axis
+     * @param offsetY the maximum random offset on the Y axis
+     * @param offsetZ the maximum random offset on the Z axis
+     */
+    public void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ);
+
+    /**
+     * Spawns the particle (the number of times specified by count)
+     * at the target location. The position of each particle will be
+     * randomized positively and negatively by the offset parameters
+     * on each axis.
+     *
+     * @param particle the particle to spawn
+     * @param location the location to spawn at
+     * @param count the number of particles
+     * @param offsetX the maximum random offset on the X axis
+     * @param offsetY the maximum random offset on the Y axis
+     * @param offsetZ the maximum random offset on the Z axis
+     * @param data the data to use for the particle or null,
+     *             the type of this depends on {@link Particle#getDataType()}
+     */
+    public <T> void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ, T data);
+
+    /**
+     * Spawns the particle (the number of times specified by count)
+     * at the target location. The position of each particle will be
+     * randomized positively and negatively by the offset parameters
+     * on each axis.
+     *
+     * @param particle the particle to spawn
+     * @param x the position on the x axis to spawn at
+     * @param y the position on the y axis to spawn at
+     * @param z the position on the z axis to spawn at
+     * @param count the number of particles
+     * @param offsetX the maximum random offset on the X axis
+     * @param offsetY the maximum random offset on the Y axis
+     * @param offsetZ the maximum random offset on the Z axis
+     * @param data the data to use for the particle or null,
+     *             the type of this depends on {@link Particle#getDataType()}
+     */
+    public <T> void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ, T data);
+
+    /**
+     * Spawns the particle (the number of times specified by count)
+     * at the target location. The position of each particle will be
+     * randomized positively and negatively by the offset parameters
+     * on each axis.
+     *
+     * @param particle the particle to spawn
+     * @param location the location to spawn at
+     * @param count the number of particles
+     * @param offsetX the maximum random offset on the X axis
+     * @param offsetY the maximum random offset on the Y axis
+     * @param offsetZ the maximum random offset on the Z axis
+     * @param extra the extra data for this particle, depends on the
+     *              particle used (normally speed)
+     */
+    public void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ, double extra);
+
+    /**
+     * Spawns the particle (the number of times specified by count)
+     * at the target location. The position of each particle will be
+     * randomized positively and negatively by the offset parameters
+     * on each axis.
+     *
+     * @param particle the particle to spawn
+     * @param x the position on the x axis to spawn at
+     * @param y the position on the y axis to spawn at
+     * @param z the position on the z axis to spawn at
+     * @param count the number of particles
+     * @param offsetX the maximum random offset on the X axis
+     * @param offsetY the maximum random offset on the Y axis
+     * @param offsetZ the maximum random offset on the Z axis
+     * @param extra the extra data for this particle, depends on the
+     *              particle used (normally speed)
+     */
+    public void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ, double extra);
+
+    /**
+     * Spawns the particle (the number of times specified by count)
+     * at the target location. The position of each particle will be
+     * randomized positively and negatively by the offset parameters
+     * on each axis.
+     *
+     * @param particle the particle to spawn
+     * @param location the location to spawn at
+     * @param count the number of particles
+     * @param offsetX the maximum random offset on the X axis
+     * @param offsetY the maximum random offset on the Y axis
+     * @param offsetZ the maximum random offset on the Z axis
+     * @param extra the extra data for this particle, depends on the
+     *              particle used (normally speed)
+     * @param data the data to use for the particle or null,
+     *             the type of this depends on {@link Particle#getDataType()}
+     */
+    public <T> void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ, double extra, T data);
+
+    /**
+     * Spawns the particle (the number of times specified by count)
+     * at the target location. The position of each particle will be
+     * randomized positively and negatively by the offset parameters
+     * on each axis.
+     *
+     * @param particle the particle to spawn
+     * @param x the position on the x axis to spawn at
+     * @param y the position on the y axis to spawn at
+     * @param z the position on the z axis to spawn at
+     * @param count the number of particles
+     * @param offsetX the maximum random offset on the X axis
+     * @param offsetY the maximum random offset on the Y axis
+     * @param offsetZ the maximum random offset on the Z axis
+     * @param extra the extra data for this particle, depends on the
+     *              particle used (normally speed)
+     * @param data the data to use for the particle or null,
+     *             the type of this depends on {@link Particle#getDataType()}
+     */
+    public <T> void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ, double extra, T data);
+
+    /**
+     * Get whether the player can affect mob spawning
+     *
+     * @return if the player can affect mob spawning
+     */
+    public boolean getAffectsSpawning();
+
+    /**
+     * Set whether the player can affect mob spawning
+     *
+     * @param affects Whether the player can affect mob spawning
+     */
+    public void setAffectsSpawning(boolean affects);
+
+    /**
+     * Gets the view distance for this player
+     *
+     * @return the player's view distance
+     */
+    public int getViewDistance();
+
+    /**
+     * Sets the view distance for this player
+     *
+     * @param viewDistance the player's view distance
+     */
+    public void setViewDistance(int viewDistance);
+
+    // Paper start
+    /**
+     * Request that the player's client download and switch resource packs.
+     * <p>
+     * The player's client will download the new resource pack asynchronously
+     * in the background, and will automatically switch to it once the
+     * download is complete. If the client has downloaded and cached the same
+     * resource pack in the past, it will perform a quick timestamp check
+     * over the network to determine if the resource pack has changed and
+     * needs to be downloaded again. When this request is sent for the very
+     * first time from a given server, the client will first display a
+     * confirmation GUI to the player before proceeding with the download.
+     * <p>
+     * Notes:
+     * <ul>
+     * <li>Players can disable server resources on their client, in which
+     *     case this method will have no affect on them.
+     * <li>There is no concept of resetting resource packs back to default
+     *     within Minecraft, so players will have to relog to do so.
+     * </ul>
+     *
+     * @param url The URL from which the client will download the resource
+     *     pack. The string must contain only US-ASCII characters and should
+     *     be encoded as per RFC 1738.
+     * @param hash A 40 character hexadecimal and lowercase SHA-1 digest of
+     *     the resource pack file.
+     * @throws IllegalArgumentException Thrown if the URL is null.
+     * @throws IllegalArgumentException Thrown if the URL is too long. The
+     *     length restriction is an implementation specific arbitrary value.
+     */
+    void setResourcePack(String url, String hash);
+
+    /**
+     * @return the most recent resource pack status received from the player,
+     *         or null if no status has ever been received from this player.
+     */
+    org.bukkit.event.player.PlayerResourcePackStatusEvent.Status getResourcePackStatus();
+
+    /**
+     * @return the most recent resource pack hash received from the player,
+     *         or null if no hash has ever been received from this player.
+     */
+    String getResourcePackHash();
+
+    /**
+     * @return true if the last resource pack status received from this player
+     *         was {@link org.bukkit.event.player.PlayerResourcePackStatusEvent.Status#SUCCESSFULLY_LOADED}
+     */
+    boolean hasResourcePack();
+    // Paper end
+
+    // Spigot start
+    public class Spigot extends Entity.Spigot
+    {
+
+        /**
+         * Gets the connection address of this player, regardless of whether it
+         * has been spoofed or not.
+         *
+         * @return the player's connection address
+         */
+        public InetSocketAddress getRawAddress()
+        {
+            throw new UnsupportedOperationException( "Not supported yet." );
+        }
+
+        public void playEffect(Location location, Effect effect, int id, int data, float offsetX, float offsetY, float offsetZ, float speed, int particleCount, int radius)
+        {
+            throw new UnsupportedOperationException( "Not supported yet." );
+        }
+
+        /**
+         * Gets whether the player collides with entities
+         *
+         * @return the player's collision toggle state
+         * @deprecated see {@link LivingEntity#isCollidable()}
+         */
+        @Deprecated
+        public boolean getCollidesWithEntities()
+        {
+            throw new UnsupportedOperationException( "Not supported yet." );
+        }
+
+        /**
+         * Sets whether the player collides with entities
+         *
+         * @param collides whether the player should collide with entities or
+         * not.
+         * @deprecated {@link LivingEntity#setCollidable(boolean)}
+         */
+        @Deprecated
+        public void setCollidesWithEntities(boolean collides)
+        {
+            throw new UnsupportedOperationException( "Not supported yet." );
+        }
+
+        /**
+         * Respawns the player if dead.
+         */
+        public void respawn()
+        {
+            throw new UnsupportedOperationException( "Not supported yet." );
+        }
+
+        /**
+         * Gets player locale language.
+         *
+         * @return the player's client language settings
+         */
+        public String getLocale()
+        {
+            throw new UnsupportedOperationException( "Not supported yet." );
+        }
+
+        /**
+         * Gets all players hidden with {@link #hidePlayer(org.bukkit.entity.Player)}.
+         *
+         * @return a Set with all hidden players
+         */
+        public java.util.Set<Player> getHiddenPlayers()
+        {
+            throw new UnsupportedOperationException( "Not supported yet." );
+        }
+
+        /**
+         * Sends the component to the player
+         *
+         * @param component the components to send
+         */
+        public void sendMessage(net.md_5.bungee.api.chat.BaseComponent component) {
+            throw new UnsupportedOperationException("Not supported yet.");
+        }
+
+        /**
+         * Sends an array of components as a single message to the player
+         *
+         * @param components the components to send
+         */
+        public void sendMessage(net.md_5.bungee.api.chat.BaseComponent... components) {
+            throw new UnsupportedOperationException("Not supported yet.");
+        }
+
+        /**
+         * Sends the component to the specified screen position of this player
+         *
+         * @param position the screen position
+         * @param component the components to send
+         */
+        public void sendMessage(net.md_5.bungee.api.ChatMessageType position, net.md_5.bungee.api.chat.BaseComponent component) {
+            throw new UnsupportedOperationException("Not supported yet.");
+        }
+
+        /**
+         * Sends an array of components as a single message to the specified screen position of this player
+         *
+         * @param position the screen position
+         * @param component the components to send
+         */
+        public void sendMessage(net.md_5.bungee.api.ChatMessageType position, net.md_5.bungee.api.chat.BaseComponent... components) {
+            throw new UnsupportedOperationException("Not supported yet.");
+        }
+
+        public int getPing()
+        {
+            throw new UnsupportedOperationException( "Not supported yet." );
+        }
+    }
+
+    Spigot spigot();
+    // Spigot end
+	
+	// Paper start
+    /**
+     * Return this player's profile
+     *
+     * @return this player's profile
+     */
+    @Override
+    public AccountProfile getAccount();
+    // Paper end
+}
diff --git a/src/main/java/org/bukkit/Server.java b/src/main/java/org/bukkit/Server.java
new file mode 100644
index 0000000..4e5083b
--- /dev/null
+++ b/src/main/java/org/bukkit/Server.java
@@ -0,0 +1,1042 @@
+package org.bukkit;
+
+import java.awt.image.BufferedImage;
+import java.io.File;
+import java.io.Serializable;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.UUID;
+import java.util.logging.Logger;
+
+import com.destroystokyo.paper.profile.ProfileLookup; // Paper
+
+import org.bukkit.Warning.WarningState;
+import org.bukkit.boss.BarColor;
+import org.bukkit.boss.BarFlag;
+import org.bukkit.boss.BarStyle;
+import org.bukkit.boss.BossBar;
+import org.bukkit.command.*;
+import org.bukkit.entity.Entity;
+import org.bukkit.entity.Player;
+import org.bukkit.event.inventory.InventoryType;
+import org.bukkit.event.server.ServerListPingEvent;
+import org.bukkit.help.HelpMap;
+import org.bukkit.inventory.Inventory;
+import org.bukkit.inventory.InventoryHolder;
+import org.bukkit.inventory.ItemStack;
+import org.bukkit.inventory.Recipe;
+import org.bukkit.map.MapView;
+import org.bukkit.permissions.Permissible;
+import org.bukkit.plugin.PluginManager;
+import org.bukkit.plugin.ServicesManager;
+import org.bukkit.plugin.messaging.Messenger;
+import org.bukkit.plugin.messaging.PluginMessageRecipient;
+import org.bukkit.scheduler.BukkitScheduler;
+import org.bukkit.scoreboard.ScoreboardManager;
+import org.bukkit.util.CachedServerIcon;
+
+import com.avaje.ebean.config.ServerConfig;
+import com.google.common.collect.ImmutableList;
+import org.bukkit.generator.ChunkGenerator;
+
+import org.bukkit.inventory.ItemFactory;
+import org.bukkit.inventory.meta.ItemMeta;
+
+/**
+ * Represents a server implementation.
+ */
+public interface Server extends PluginMessageRecipient {
+
+    /**
+     * Used for all administrative messages, such as an operator using a
+     * command.
+     * <p>
+     * For use in {@link #broadcast(java.lang.String, java.lang.String)}.
+     */
+    public static final String BROADCAST_CHANNEL_ADMINISTRATIVE = "bukkit.broadcast.admin";
+
+    /**
+     * Used for all announcement messages, such as informing users that a
+     * player has joined.
+     * <p>
+     * For use in {@link #broadcast(java.lang.String, java.lang.String)}.
+     */
+    public static final String BROADCAST_CHANNEL_USERS = "bukkit.broadcast.user";
+
+    /**
+     * Gets the name of this server implementation.
+     *
+     * @return name of this server implementation
+     */
+    public String getName();
+
+    /**
+     * Gets the version string of this server implementation.
+     *
+     * @return version of this server implementation
+     */
+    public String getVersion();
+
+    /**
+     * Gets the Bukkit version that this server is running.
+     *
+     * @return version of Bukkit
+     */
+    public String getBukkitVersion();
+
+    /**
+     * Gets an array copy of all currently logged in players.
+     * <p>
+     * This method exists for legacy reasons to provide backwards
+     * compatibility. It will not exist at runtime and should not be used
+     * under any circumstances.
+     *
+     * @deprecated superseded by {@link #getOnlinePlayers()}
+     * @return an array of Players that are currently online
+     */
+    @Deprecated
+    public Player[] _INVALID_getOnlinePlayers();
+
+    /**
+     * Gets a view of all currently logged in players. This {@linkplain
+     * Collections#unmodifiableCollection(Collection) view} is a reused
+     * object, making some operations like {@link Collection#size()}
+     * zero-allocation.
+     * <p>
+     * The collection is a view backed by the internal representation, such
+     * that, changes to the internal state of the server will be reflected
+     * immediately. However, the reuse of the returned collection (identity)
+     * is not strictly guaranteed for future or all implementations. Casting
+     * the collection, or relying on interface implementations (like {@link
+     * Serializable} or {@link List}), is deprecated.
+     * <p>
+     * Iteration behavior is undefined outside of self-contained main-thread
+     * uses. Normal and immediate iterator use without consequences that
+     * affect the collection are fully supported. The effects following
+     * (non-exhaustive) {@link Entity#teleport(Location) teleportation},
+     * {@link Player#setHealth(double) death}, and {@link Player#kickPlayer(
+     * String) kicking} are undefined. Any use of this collection from
+     * asynchronous threads is unsafe.
+     * <p>
+     * For safe consequential iteration or mimicking the old array behavior,
+     * using {@link Collection#toArray(Object[])} is recommended. For making
+     * snapshots, {@link ImmutableList#copyOf(Collection)} is recommended.
+     *
+     * @return a view of currently online players.
+     */
+    public Collection<? extends Player> getOnlinePlayers();
+
+    /**
+     * Get the maximum amount of players which can login to this server.
+     *
+     * @return the amount of players this server allows
+     */
+    public int getMaxPlayers();
+
+    /**
+     * Get the game port that the server runs on.
+     *
+     * @return the port number of this server
+     */
+    public int getPort();
+
+    /**
+     * Get the view distance from this server.
+     *
+     * @return the view distance from this server.
+     */
+    public int getViewDistance();
+
+    /**
+     * Get the IP that this server is bound to, or empty string if not
+     * specified.
+     *
+     * @return the IP string that this server is bound to, otherwise empty
+     *     string
+     */
+    public String getIp();
+
+    /**
+     * Get the name of this server.
+     *
+     * @return the name of this server
+     */
+    public String getServerName();
+
+    /**
+     * Get an ID of this server. The ID is a simple generally alphanumeric ID
+     * that can be used for uniquely identifying this server.
+     *
+     * @return the ID of this server
+     */
+    public String getServerId();
+
+    /**
+     * Get world type (level-type setting) for default world.
+     *
+     * @return the value of level-type (e.g. DEFAULT, FLAT, DEFAULT_1_1)
+     */
+    public String getWorldType();
+
+    /**
+     * Get generate-structures setting.
+     *
+     * @return true if structure generation is enabled, false otherwise
+     */
+    public boolean getGenerateStructures();
+
+    /**
+     * Gets whether this server allows the End or not.
+     *
+     * @return whether this server allows the End or not
+     */
+    public boolean getAllowEnd();
+
+    /**
+     * Gets whether this server allows the Nether or not.
+     *
+     * @return whether this server allows the Nether or not
+     */
+    public boolean getAllowNether();
+
+    /**
+     * Gets whether this server has a whitelist or not.
+     *
+     * @return whether this server has a whitelist or not
+     */
+    public boolean hasWhitelist();
+
+    /**
+     * Sets if the server is whitelisted.
+     *
+     * @param value true for whitelist on, false for off
+     */
+    public void setWhitelist(boolean value);
+
+    /**
+     * Gets a list of whitelisted players.
+     *
+     * @return a set containing all whitelisted players
+     */
+    public Set<OfflinePlayer> getWhitelistedPlayers();
+
+    /**
+     * Reloads the whitelist from disk.
+     */
+    public void reloadWhitelist();
+
+    /**
+     * Broadcast a message to all players.
+     * <p>
+     * This is the same as calling {@link #broadcast(java.lang.String,
+     * java.lang.String)} to {@link #BROADCAST_CHANNEL_USERS}
+     *
+     * @param message the message
+     * @return the number of players
+     */
+    public int broadcastMessage(String message);
+
+    // Paper start
+    /**
+     * Sends the component to all online players.
+     *
+     * @param component the component to send
+     */
+    public void broadcast(net.md_5.bungee.api.chat.BaseComponent component);
+
+    /**
+     * Sends an array of components as a single message to all online players.
+     *
+     * @param components the components to send
+     */
+    public void broadcast(net.md_5.bungee.api.chat.BaseComponent... components);
+    // Paper end
+
+    /**
+     * Gets the name of the update folder. The update folder is used to safely
+     * update plugins at the right moment on a plugin load.
+     * <p>
+     * The update folder name is relative to the plugins folder.
+     *
+     * @return the name of the update folder
+     */
+    public String getUpdateFolder();
+
+    /**
+     * Gets the update folder. The update folder is used to safely update
+     * plugins at the right moment on a plugin load.
+     *
+     * @return the update folder
+     */
+    public File getUpdateFolderFile();
+
+    /**
+     * Gets the value of the connection throttle setting.
+     *
+     * @return the value of the connection throttle setting
+     */
+    public long getConnectionThrottle();
+
+    /**
+     * Gets default ticks per animal spawns value.
+     * <p>
+     * <b>Example Usage:</b>
+     * <ul>
+     * <li>A value of 1 will mean the server will attempt to spawn monsters
+     *     every tick.
+     * <li>A value of 400 will mean the server will attempt to spawn monsters
+     *     every 400th tick.
+     * <li>A value below 0 will be reset back to Minecraft's default.
+     * </ul>
+     * <p>
+     * <b>Note:</b> If set to 0, animal spawning will be disabled. We
+     * recommend using spawn-animals to control this instead.
+     * <p>
+     * Minecraft default: 400.
+     *
+     * @return the default ticks per animal spawns value
+     */
+    public int getTicksPerAnimalSpawns();
+
+    /**
+     * Gets the default ticks per monster spawns value.
+     * <p>
+     * <b>Example Usage:</b>
+     * <ul>
+     * <li>A value of 1 will mean the server will attempt to spawn monsters
+     *     every tick.
+     * <li>A value of 400 will mean the server will attempt to spawn monsters
+     *     every 400th tick.
+     * <li>A value below 0 will be reset back to Minecraft's default.
+     * </ul>
+     * <p>
+     * <b>Note:</b> If set to 0, monsters spawning will be disabled. We
+     * recommend using spawn-monsters to control this instead.
+     * <p>
+     * Minecraft default: 1.
+     *
+     * @return the default ticks per monsters spawn value
+     */
+    public int getTicksPerMonsterSpawns();
+
+    /**
+     * Gets a player object by the given username.
+     * <p>
+     * This method may not return objects for offline players.
+     *
+     * @param name the name to look up
+     * @return a player if one was found, null otherwise
+     */
+    public Player getPlayer(String name);
+
+    /**
+     * Gets the player with the exact given name, case insensitive.
+     *
+     * @param name Exact name of the player to retrieve
+     * @return a player object if one was found, null otherwise
+     */
+    public Player getPlayerExact(String name);
+
+    /**
+     * Attempts to match any players with the given name, and returns a list
+     * of all possibly matches.
+     * <p>
+     * This list is not sorted in any particular order. If an exact match is
+     * found, the returned list will only contain a single result.
+     *
+     * @param name the (partial) name to match
+     * @return list of all possible players
+     */
+    public List<Player> matchPlayer(String name);
+
+    /**
+     * Gets the player with the given UUID.
+     *
+     * @param id UUID of the player to retrieve
+     * @return a player object if one was found, null otherwise
+     */
+    public Player getPlayer(UUID id);
+
+    /**
+     * Gets the plugin manager for interfacing with plugins.
+     *
+     * @return a plugin manager for this Server instance
+     */
+    public PluginManager getPluginManager();
+
+    /**
+     * Gets the scheduler for managing scheduled events.
+     *
+     * @return a scheduling service for this server
+     */
+    public BukkitScheduler getScheduler();
+
+    /**
+     * Gets a services manager.
+     *
+     * @return s services manager
+     */
+    public ServicesManager getServicesManager();
+
+    /**
+     * Gets a list of all worlds on this server.
+     *
+     * @return a list of worlds
+     */
+    public List<World> getWorlds();
+
+    /**
+     * Creates or loads a world with the given name using the specified
+     * options.
+     * <p>
+     * If the world is already loaded, it will just return the equivalent of
+     * getWorld(creator.name()).
+     *
+     * @param creator the options to use when creating the world
+     * @return newly created or loaded world
+     */
+    public World createWorld(WorldCreator creator);
+
+    /**
+     * Unloads a world with the given name.
+     *
+     * @param name Name of the world to unload
+     * @param save whether to save the chunks before unloading
+     * @return true if successful, false otherwise
+     */
+    public boolean unloadWorld(String name, boolean save);
+
+    /**
+     * Unloads the given world.
+     *
+     * @param world the world to unload
+     * @param save whether to save the chunks before unloading
+     * @return true if successful, false otherwise
+     */
+    public boolean unloadWorld(World world, boolean save);
+
+    /**
+     * Gets the world with the given name.
+     *
+     * @param name the name of the world to retrieve
+     * @return a world with the given name, or null if none exists
+     */
+    public World getWorld(String name);
+
+    /**
+     * Gets the world from the given Unique ID.
+     *
+     * @param uid a unique-id of the world to retrieve
+     * @return a world with the given Unique ID, or null if none exists
+     */
+    public World getWorld(UUID uid);
+
+    /**
+     * Gets the map from the given item ID.
+     *
+     * @param id the id of the map to get
+     * @return a map view if it exists, or null otherwise
+     * @deprecated Magic value
+     */
+    @Deprecated
+    public MapView getMap(short id);
+
+    /**
+     * Create a new map with an automatically assigned ID.
+     *
+     * @param world the world the map will belong to
+     * @return a newly created map view
+     */
+    public MapView createMap(World world);
+
+    /**
+     * Reloads the server, refreshing settings and plugin information.
+     */
+    public void reload();
+
+    /**
+     * Returns the primary logger associated with this server instance.
+     *
+     * @return Logger associated with this server
+     */
+    public Logger getLogger();
+
+    /**
+     * Gets a {@link PluginCommand} with the given name or alias.
+     *
+     * @param name the name of the command to retrieve
+     * @return a plugin command if found, null otherwise
+     */
+    public PluginCommand getPluginCommand(String name);
+
+    /**
+     * Writes loaded players to disk.
+     */
+    public void savePlayers();
+
+    /**
+     * Dispatches a command on this server, and executes it if found.
+     *
+     * @param sender the apparent sender of the command
+     * @param commandLine the command + arguments. Example: <code>test abc
+     *     123</code>
+     * @return returns false if no target is found
+     * @throws CommandException thrown when the executor for the given command
+     *     fails with an unhandled exception
+     */
+    public boolean dispatchCommand(CommandSender sender, String commandLine) throws CommandException;
+
+    /**
+     * Populates a given {@link ServerConfig} with values attributes to this
+     * server.
+     *
+     * @param config the server config to populate
+     */
+    public void configureDbConfig(ServerConfig config);
+
+    /**
+     * Adds a recipe to the crafting manager.
+     *
+     * @param recipe the recipe to add
+     * @return true if the recipe was added, false if it wasn't for some
+     *     reason
+     */
+    public boolean addRecipe(Recipe recipe);
+
+    /**
+     * Get a list of all recipes for a given item. The stack size is ignored
+     * in comparisons. If the durability is -1, it will match any data value.
+     *
+     * @param result the item to match against recipe results
+     * @return a list of recipes with the given result
+     */
+    public List<Recipe> getRecipesFor(ItemStack result);
+
+    /**
+     * Get an iterator through the list of crafting recipes.
+     *
+     * @return an iterator
+     */
+    public Iterator<Recipe> recipeIterator();
+
+    /**
+     * Clears the list of crafting recipes.
+     */
+    public void clearRecipes();
+
+    /**
+     * Resets the list of crafting recipes to the default.
+     */
+    public void resetRecipes();
+
+    /**
+     * Gets a list of command aliases defined in the server properties.
+     *
+     * @return a map of aliases to command names
+     */
+    public Map<String, String[]> getCommandAliases();
+
+    /**
+     * Gets the radius, in blocks, around each worlds spawn point to protect.
+     *
+     * @return spawn radius, or 0 if none
+     */
+    public int getSpawnRadius();
+
+    /**
+     * Sets the radius, in blocks, around each worlds spawn point to protect.
+     *
+     * @param value new spawn radius, or 0 if none
+     */
+    public void setSpawnRadius(int value);
+
+    /**
+     * Gets whether the Server is in online mode or not.
+     *
+     * @return true if the server authenticates clients, false otherwise
+     */
+    public boolean getOnlineMode();
+
+    /**
+     * Gets whether this server allows flying or not.
+     *
+     * @return true if the server allows flight, false otherwise
+     */
+    public boolean getAllowFlight();
+
+    /**
+     * Gets whether the server is in hardcore mode or not.
+     *
+     * @return true if the server mode is hardcore, false otherwise
+     */
+    public boolean isHardcore();
+
+    /**
+     * Gets whether to use vanilla (false) or exact behaviour (true).
+     *
+     * <ul>
+     * <li>Vanilla behaviour: check for collisions and move the player if
+     *     needed.
+     * <li>Exact behaviour: spawn players exactly where they should be.
+     * </ul>
+     *
+     * @return true if exact location locations are used for spawning, false
+     *     for vanilla collision detection or otherwise
+     *
+     * @deprecated non standard and unused feature.
+     */
+    @Deprecated
+    public boolean useExactLoginLocation();
+
+    /**
+     * Shutdowns the server, stopping everything.
+     */
+    public void shutdown();
+
+    /**
+     * Broadcasts the specified message to every user with the given
+     * permission name.
+     *
+     * @param message message to broadcast
+     * @param permission the required permission {@link Permissible
+     *     permissibles} must have to receive the broadcast
+     * @return number of message recipients
+     */
+    public int broadcast(String message, String permission);
+
+    /**
+     * Gets the player by the given name, regardless if they are offline or
+     * online.
+     * <p>
+     * This method may involve a blocking web request to get the UUID for the
+     * given name.
+     * <p>
+     * This will return an object even if the player does not exist. To this
+     * method, all players will exist.
+     *
+     * @deprecated Persistent storage of users should be by UUID as names are no longer
+     *             unique past a single session.
+     * @param name the name the player to retrieve
+     * @return an offline player
+     * @see #getOfflinePlayer(java.util.UUID)
+     */
+    @Deprecated
+    public OfflinePlayer getOfflinePlayer(String name);
+
+    /**
+     * Gets the player by the given UUID, regardless if they are offline or
+     * online.
+     * <p>
+     * This will return an object even if the player does not exist. To this
+     * method, all players will exist.
+     *
+     * @param id the UUID of the player to retrieve
+     * @return an offline player
+     */
+    public OfflinePlayer getOfflinePlayer(UUID id);
+
+    /**
+     * Gets a set containing all current IPs that are banned.
+     *
+     * @return a set containing banned IP addresses
+     */
+    public Set<String> getIPBans();
+
+    /**
+     * Bans the specified address from the server.
+     *
+     * @param address the IP address to ban
+     */
+    public void banIP(String address);
+
+    /**
+     * Unbans the specified address from the server.
+     *
+     * @param address the IP address to unban
+     */
+    public void unbanIP(String address);
+
+    /**
+     * Gets a set containing all banned players.
+     *
+     * @return a set containing banned players
+     */
+    public Set<OfflinePlayer> getBannedPlayers();
+
+    /**
+     * Gets a ban list for the supplied type.
+     * <p>
+     * Bans by name are no longer supported and this method will return
+     * null when trying to request them. The replacement is bans by UUID.
+     *
+     * @param type the type of list to fetch, cannot be null
+     * @return a ban list of the specified type
+     */
+    public BanList getBanList(BanList.Type type);
+
+    /**
+     * Gets a set containing all player operators.
+     *
+     * @return a set containing player operators
+     */
+    public Set<OfflinePlayer> getOperators();
+
+    /**
+     * Gets the default {@link GameMode} for new players.
+     *
+     * @return the default game mode
+     */
+    public GameMode getDefaultGameMode();
+
+    /**
+     * Sets the default {@link GameMode} for new players.
+     *
+     * @param mode the new game mode
+     */
+    public void setDefaultGameMode(GameMode mode);
+
+    /**
+     * Gets a {@link ConsoleCommandSender} that may be used as an input source
+     * for this server.
+     *
+     * @return a console command sender
+     */
+    public ConsoleCommandSender getConsoleSender();
+
+    /**
+     * Gets the folder that contains all of the various {@link World}s.
+     *
+     * @return folder that contains all worlds
+     */
+    public File getWorldContainer();
+
+    /**
+     * Gets every player that has ever played on this server.
+     *
+     * @return an array containing all previous players
+     */
+    public OfflinePlayer[] getOfflinePlayers();
+
+    /**
+     * Gets the {@link Messenger} responsible for this server.
+     *
+     * @return messenger responsible for this server
+     */
+    public Messenger getMessenger();
+
+    /**
+     * Gets the {@link HelpMap} providing help topics for this server.
+     *
+     * @return a help map for this server
+     */
+    public HelpMap getHelpMap();
+
+    /**
+     * Creates an empty inventory of the specified type. If the type is {@link
+     * InventoryType#CHEST}, the new inventory has a size of 27; otherwise the
+     * new inventory has the normal size for its type.
+     *
+     * @param owner the holder of the inventory, or null to indicate no holder
+     * @param type the type of inventory to create
+     * @return a new inventory
+     */
+    Inventory createInventory(InventoryHolder owner, InventoryType type);
+
+    /**
+     * Creates an empty inventory with the specified type and title. If the type
+     * is {@link InventoryType#CHEST}, the new inventory has a size of 27;
+     * otherwise the new inventory has the normal size for its type.<br>
+     * It should be noted that some inventory types do not support titles and
+     * may not render with said titles on the Minecraft client.
+     *
+     * @param owner The holder of the inventory; can be null if there's no holder.
+     * @param type The type of inventory to create.
+     * @param title The title of the inventory, to be displayed when it is viewed.
+     * @return The new inventory.
+     */
+    Inventory createInventory(InventoryHolder owner, InventoryType type, String title);
+
+    /**
+     * Creates an empty inventory of type {@link InventoryType#CHEST} with the
+     * specified size.
+     *
+     * @param owner the holder of the inventory, or null to indicate no holder
+     * @param size a multiple of 9 as the size of inventory to create
+     * @return a new inventory
+     * @throws IllegalArgumentException if the size is not a multiple of 9
+     */
+    Inventory createInventory(InventoryHolder owner, int size) throws IllegalArgumentException;
+
+    /**
+     * Creates an empty inventory of type {@link InventoryType#CHEST} with the
+     * specified size and title.
+     *
+     * @param owner the holder of the inventory, or null to indicate no holder
+     * @param size a multiple of 9 as the size of inventory to create
+     * @param title the title of the inventory, displayed when inventory is
+     *     viewed
+     * @return a new inventory
+     * @throws IllegalArgumentException if the size is not a multiple of 9
+     */
+    Inventory createInventory(InventoryHolder owner, int size, String title) throws IllegalArgumentException;
+
+    /**
+     * Gets user-specified limit for number of monsters that can spawn in a
+     * chunk.
+     *
+     * @return the monster spawn limit
+     */
+    int getMonsterSpawnLimit();
+
+    /**
+     * Gets user-specified limit for number of animals that can spawn in a
+     * chunk.
+     *
+     * @return the animal spawn limit
+     */
+    int getAnimalSpawnLimit();
+
+    /**
+     * Gets user-specified limit for number of water animals that can spawn in
+     * a chunk.
+     *
+     * @return the water animal spawn limit
+     */
+    int getWaterAnimalSpawnLimit();
+
+    /**
+     * Gets user-specified limit for number of ambient mobs that can spawn in
+     * a chunk.
+     *
+     * @return the ambient spawn limit
+     */
+    int getAmbientSpawnLimit();
+
+    /**
+     * Checks the current thread against the expected primary thread for the
+     * server.
+     * <p>
+     * <b>Note:</b> this method should not be used to indicate the current
+     * synchronized state of the runtime. A current thread matching the main
+     * thread indicates that it is synchronized, but a mismatch <b>does not
+     * preclude</b> the same assumption.
+     *
+     * @return true if the current thread matches the expected primary thread,
+     *     false otherwise
+     */
+    boolean isPrimaryThread();
+
+    /**
+     * Gets the message that is displayed on the server list.
+     *
+     * @return the servers MOTD
+     */
+    String getMotd();
+
+    /**
+     * Gets the default message that is displayed when the server is stopped.
+     *
+     * @return the shutdown message
+     */
+    String getShutdownMessage();
+
+    /**
+     * Gets the current warning state for the server.
+     *
+     * @return the configured warning state
+     */
+    public WarningState getWarningState();
+
+    /**
+     * Gets the instance of the item factory (for {@link ItemMeta}).
+     *
+     * @return the item factory
+     * @see ItemFactory
+     */
+    ItemFactory getItemFactory();
+
+    /**
+     * Gets the instance of the scoreboard manager.
+     * <p>
+     * This will only exist after the first world has loaded.
+     *
+     * @return the scoreboard manager or null if no worlds are loaded.
+     */
+    ScoreboardManager getScoreboardManager();
+
+    /**
+     * Gets an instance of the server's default server-icon.
+     *
+     * @return the default server-icon; null values may be used by the
+     *     implementation to indicate no defined icon, but this behavior is
+     *     not guaranteed
+     */
+    CachedServerIcon getServerIcon();
+
+    /**
+     * Loads an image from a file, and returns a cached image for the specific
+     * server-icon.
+     * <p>
+     * Size and type are implementation defined. An incompatible file is
+     * guaranteed to throw an implementation-defined {@link Exception}.
+     *
+     * @param file the file to load the from
+     * @throws IllegalArgumentException if image is null
+     * @throws Exception if the image does not meet current server server-icon
+     *     specifications
+     * @return a cached server-icon that can be used for a {@link
+     *     ServerListPingEvent#setServerIcon(CachedServerIcon)}
+     */
+    CachedServerIcon loadServerIcon(File file) throws IllegalArgumentException, Exception;
+
+    /**
+     * Creates a cached server-icon for the specific image.
+     * <p>
+     * Size and type are implementation defined. An incompatible file is
+     * guaranteed to throw an implementation-defined {@link Exception}.
+     *
+     * @param image the image to use
+     * @throws IllegalArgumentException if image is null
+     * @throws Exception if the image does not meet current server
+     *     server-icon specifications
+     * @return a cached server-icon that can be used for a {@link
+     *     ServerListPingEvent#setServerIcon(CachedServerIcon)}
+     */
+    CachedServerIcon loadServerIcon(BufferedImage image) throws IllegalArgumentException, Exception;
+
+    /**
+     * Set the idle kick timeout. Any players idle for the specified amount of
+     * time will be automatically kicked.
+     * <p>
+     * A value of 0 will disable the idle kick timeout.
+     *
+     * @param threshold the idle timeout in minutes
+     */
+    public void setIdleTimeout(int threshold);
+
+    /**
+     * Gets the idle kick timeout.
+     *
+     * @return the idle timeout in minutes
+     */
+    public int getIdleTimeout();
+
+    /**
+     * Create a ChunkData for use in a generator.
+     * 
+     * See {@link ChunkGenerator#generateChunkData(org.bukkit.World, java.util.Random, int, int, org.bukkit.generator.ChunkGenerator.BiomeGrid)}
+     * 
+     * @param world the world to create the ChunkData for
+     * @return a new ChunkData for the world
+     * 
+     */
+    public ChunkGenerator.ChunkData createChunkData(World world);
+
+    /**
+     * Creates a boss bar instance to display to players. The progress
+     * defaults to 1.0
+     *
+     * @param title the title of the boss bar
+     * @param color the color of the boss bar
+     * @param style the style of the boss bar
+     * @param flags an optional list of flags to set on the boss bar
+     * @return the created boss bar
+     */
+    BossBar createBossBar(String title, BarColor color, BarStyle style, BarFlag ...flags);
+
+    /**
+     * Gets the current server TPS
+     *
+     * @return current server TPS (1m, 5m, 15m in Paper-Server)
+     */
+    public double[] getTPS();
+
+    // Paper start
+    /**
+     * Gets the active {@link CommandMap}
+     *
+     * @return the active command map
+     */
+    CommandMap getCommandMap();
+
+    /**
+     * @see UnsafeValues
+     * @return the unsafe values instance
+     */
+    @Deprecated
+    UnsafeValues getUnsafe();
+
+    public class Spigot
+    {
+        @Deprecated
+        public org.bukkit.configuration.file.YamlConfiguration getConfig()
+        {
+            throw new UnsupportedOperationException( "Not supported yet." );
+        }
+
+        public org.bukkit.configuration.file.YamlConfiguration getBukkitConfig()
+        {
+            throw new UnsupportedOperationException( "Not supported yet." );
+        }
+
+        public org.bukkit.configuration.file.YamlConfiguration getSpigotConfig()
+        {
+            throw new UnsupportedOperationException("Not supported yet.");
+        }
+
+        public org.bukkit.configuration.file.YamlConfiguration getPaperConfig()
+        {
+            throw new UnsupportedOperationException("Not supported yet.");
+        }
+
+        /**
+         * Sends the component to the player
+         *
+         * @param component the components to send
+         */
+        public void broadcast(net.md_5.bungee.api.chat.BaseComponent component) {
+            throw new UnsupportedOperationException("Not supported yet.");
+        }
+
+        /**
+         * Sends an array of components as a single message to the player
+         *
+         * @param components the components to send
+         */
+        public void broadcast(net.md_5.bungee.api.chat.BaseComponent... components) {
+            throw new UnsupportedOperationException("Not supported yet.");
+        }
+
+        /**
+         * Restart the server. If the server administrator has not configured restarting, the server will stop.
+         */
+        public void restart() {
+            throw new UnsupportedOperationException("Not supported yet.");
+        }
+    }
+
+    Spigot spigot();
+	
+	// Paper start - profile api
+    /**
+     * Get the server's profile lookup
+     *
+     * @return the server's profile lookup
+     */
+    public ProfileLookup getProfileLookup();
+    // Paper end
+
+    void reloadPermissions(); // Paper
+
+    /**
+     * Find an entity on the server by its UUID
+     *
+     * @param uuid The UUID of the entity
+     * @return The entity that is identified by the given UUID, or null if one isn't found
+     */
+    Entity getEntity(UUID uuid); // Paper
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftOfflinePlayer.java b/src/main/java/org/bukkit/craftbukkit/CraftOfflinePlayer.java
index 4521786..37cf39c 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftOfflinePlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftOfflinePlayer.java
@@ -10,6 +10,8 @@ import java.util.UUID;
 import net.minecraft.server.EntityPlayer;
 import net.minecraft.server.NBTTagCompound;
 import net.minecraft.server.WorldNBTStorage;
+import com.destroystokyo.paper.profile.ProfileUtils;
+import com.destroystokyo.paper.profile.AccountProfile;
 
 import org.bukkit.BanList;
 import org.bukkit.Bukkit;
@@ -32,9 +34,22 @@ public class CraftOfflinePlayer implements OfflinePlayer, ConfigurationSerializa
         this.server = server;
         this.profile = profile;
         this.storage = (WorldNBTStorage) (server.console.worlds.get(0).getDataManager());
+		// Paper start - store our profile
+        this.paperProfile = ProfileUtils.toPaper(profile);
+    }
+    private final AccountProfile paperProfile;
 
+    protected CraftOfflinePlayer(CraftServer server, AccountProfile profile) {
+        this.server = server;
+        this.profile = ProfileUtils.toMojang(profile);
+        this.storage = (WorldNBTStorage) (server.console.worlds.get(0).getDataManager());
+        this.paperProfile = profile;
     }
 
+    public AccountProfile getAccount() {
+        return paperProfile;
+     }
+
     public GameProfile getProfile() {
         return profile;
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index dc3598e..f332a33 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -22,7 +22,10 @@ import java.util.logging.Logger;
 import java.util.regex.Pattern;
 
 import javax.imageio.ImageIO;
-
+import com.destroystokyo.paper.profile.EventProfileLookup;
+import com.destroystokyo.paper.profile.MojangLookup;
+import com.destroystokyo.paper.profile.AccountProfile;
+import com.destroystokyo.paper.profile.ProfileLookup;
 import net.minecraft.server.*;
 
 import net.minecraft.server.WorldType;
@@ -1347,11 +1350,11 @@ public final class CraftServer implements Server {
         OfflinePlayer result = getPlayerExact(name);
         if (result == null) {
             // Spigot Start
-            GameProfile profile = null;
+            AccountProfile profile = null;
             // Only fetch an online UUID in online mode
             if ( MinecraftServer.getServer().getOnlineMode() || org.spigotmc.SpigotConfig.bungee )
             {
-                profile = console.getUserCache().getProfile( name );
+                profile = getProfileLookup().lookup(name);
             }
             // Spigot end
             if (profile == null) {
@@ -1359,7 +1362,8 @@ public final class CraftServer implements Server {
                 result = getOfflinePlayer(new GameProfile(UUID.nameUUIDFromBytes(("OfflinePlayer:" + name).getBytes(Charsets.UTF_8)), name));
             } else {
                 // Use the GameProfile even when we get a UUID so we ensure we still have a name
-                result = getOfflinePlayer(profile);
+                result = new CraftOfflinePlayer(this, profile);
+                offlinePlayers.put(result.getUniqueId(), result);
             }
         } else {
             offlinePlayers.remove(result.getUniqueId());
@@ -1376,7 +1380,7 @@ public final class CraftServer implements Server {
         if (result == null) {
             result = offlinePlayers.get(id);
             if (result == null) {
-                result = new CraftOfflinePlayer(this, new GameProfile(id, null));
+                result = new CraftOfflinePlayer(this, getProfileLookup().lookup(id)); // Paper - do lookup
                 offlinePlayers.put(id, result);
             }
         } else {
@@ -1853,6 +1857,15 @@ public final class CraftServer implements Server {
         return spigot;
     }
 
+	// Paper start - uuid api
+    private final ProfileLookup lookup = new EventProfileLookup(new MojangLookup());
+
+    @Override
+    public ProfileLookup getProfileLookup() {
+        return lookup;
+    }
+    // Paper end
+	
     // Paper start
     @Override
     public void reloadPermissions() {
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index d1d958c..2a40bb3 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -22,6 +22,8 @@ import java.util.logging.Level;
 import java.util.logging.Logger;
 import net.md_5.bungee.api.chat.BaseComponent;
 
+import com.destroystokyo.paper.profile.AccountProfile; // Paper
+
 import net.minecraft.server.*;
 import net.minecraft.server.PacketPlayOutTitle.EnumTitleAction;
 
@@ -82,6 +84,13 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
 
         firstPlayed = System.currentTimeMillis();
     }
+	
+	// Paper start
+    @Override
+    public AccountProfile getAccount() {
+        return getHandle().getBukkitProfile();
+    }
+    // Paper end
 
     public GameProfile getProfile() {
         return getHandle().getProfile();
-- 
2.8.2.windows.1

