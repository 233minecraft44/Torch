From 1e1913fb3664367027df432f6a028b4257802b6e Mon Sep 17 00:00:00 2001
From: SotrForgotten <i@omc.hk>
Date: Tue, 9 Aug 2016 02:18:54 +0800
Subject: [PATCH] SPIGOT-2581: EntityAirChangeEvent


diff --git a/src/main/java/com/mrpowergamerbr/utils/LightRNG.java b/src/main/java/com/mrpowergamerbr/utils/LightRNG.java
new file mode 100644
index 0000000..988a3ee
--- /dev/null
+++ b/src/main/java/com/mrpowergamerbr/utils/LightRNG.java
@@ -0,0 +1,246 @@
+/*
+Written in 2015 by Sebastiano Vigna (vigna@acm.org)
+
+To the extent possible under law, the author has dedicated all copyright
+and related and neighboring rights to this software to the public domain
+worldwide. This software is distributed without any warranty.
+
+See <http://creativecommons.org/publicdomain/zero/1.0/>. */
+
+package com.mrpowergamerbr.utils;
+
+/**
+ * From DreamSpigotPlus project.
+ * @Link: https://github.com/DreamSpigotMC/DreamSpigotPlus/blob/master/PaperSpigot-Server-Patches/0024-DreamSpigotPlus-Use-a-Shared-LightRNG-for-Entities.patch
+ */
+
+/**
+ * This is a SplittableRandom-style generator, meant to have a tiny state
+ * that permits storing many different generators with low overhead.
+ * It should be rather fast, though no guarantees can be made on all hardware.
+ * <br>
+ * Benchmarking on a Windows laptop with an i7-4700MQ processor running OpenJDK 8
+ * reports generation of 64-bit random long output as 17.8x faster than generating
+ * an equivalent number of random longs with java.util.Random, and generation of
+ * 32-bit random int output as 9.8x faster. Specifically, generating 1 billion longs
+ * took about 1.28 nanoseconds per long (1.277 seconds for the whole group) with
+ * LightRNG, while java.util.Random (which is meant to produce int, to be fair) took
+ * about 22.8 nanoseconds per long (22.797 seconds for the whole group). XorRNG
+ * appears to be occasionally faster on int output than LightRNG, but it isn't clear
+ * why or what causes that (JIT or GC internals, possibly). XorRNG is slightly
+ * slower at generating 64-bit random data, including long and double, but not by
+ * a significant degree (a multiplier between 0.9 and 1.2 times). The only deciding
+ * factor then is state size, where LightRNG is as small as possible for any JVM
+ * object with even a single field: 16 bytes (on a 64-bit JVM; 8-byte objects with
+ * 4 bytes or less of non-static members may be possible on 32-bit JVMs but I can't
+ * find anything confirming that guess).
+ * <br>
+ * So yes, this should be very fast, and with only a single long used per LightRNG,
+ * it is about as memory-efficient as these generators get.
+ * <br>
+ * Written in 2015 by Sebastiano Vigna (vigna@acm.org)
+ * @author Sebastiano Vigna
+ * @author Tommy Ettinger
+ */
+public class LightRNG implements RandomnessSource, StatefulRandomness
+{
+	/** 2 raised to the 53, - 1. */
+    private static final long DOUBLE_MASK = ( 1L << 53 ) - 1;
+    /** 2 raised to the -53. */
+    private static final double NORM_53 = 1. / ( 1L << 53 );
+    /** 2 raised to the 24, -1. */
+    private static final long FLOAT_MASK = ( 1L << 24 ) - 1;
+    /** 2 raised to the -24. */
+    private static final double NORM_24 = 1. / ( 1L << 24 );
+
+    private static final long serialVersionUID = -374415589203474497L;
+
+    public long state; /* The state can be seeded with any value. */
+
+    /** Creates a new generator seeded using Math.random. */
+    public LightRNG() {
+        this((long) Math.floor(Math.random() * Long.MAX_VALUE));
+    }
+
+    public LightRNG( final long seed ) {
+        setSeed(seed);
+    }
+
+    @Override
+    public int next( int bits ) {
+        return (int)( nextLong() & ( 1L << bits ) - 1 );
+    }
+
+    /**
+     * Can return any long, positive or negative, of any size permissible in a 64-bit signed integer.
+     * @return any long, all 64 bits are random
+     */
+    @Override
+    public long nextLong() {
+        long z = ( state += 0x9E3779B97F4A7C15L );
+        z = (z ^ (z >>> 30)) * 0xBF58476D1CE4E5B9L;
+        z = (z ^ (z >>> 27)) * 0x94D049BB133111EBL;
+        return z ^ (z >>> 31);
+    }
+
+    /**
+     * Produces a copy of this RandomnessSource that, if next() and/or nextLong() are called on this object and the
+     * copy, both will generate the same sequence of random numbers from the point copy() was called. This just need to
+     * copy the state so it isn't shared, usually, and produce a new value with the same exact state.
+     *
+     * @return a copy of this RandomnessSource
+     */
+    @Override
+    public RandomnessSource copy() {
+        return new LightRNG(state);
+    }
+
+    /**
+     * Can return any int, positive or negative, of any size permissible in a 32-bit signed integer.
+     * @return any int, all 32 bits are random
+     */
+    public int nextInt() {
+        return (int)nextLong();
+    }
+
+    /**
+     * Exclusive on the upper bound.  The lower bound is 0.
+     * @param bound the upper bound; should be positive
+     * @return a random int less than n and at least equal to 0
+     */
+    public int nextInt( final int bound ) {
+        if ( bound <= 0 ) return 0;
+        int threshold = (0x7fffffff - bound + 1) % bound;
+        for (;;) {
+            int bits = (int)(nextLong() & 0x7fffffff);
+            if (bits >= threshold)
+                return bits % bound;
+        }
+    }
+    /**
+     * Inclusive lower, exclusive upper.
+     * @param lower the lower bound, inclusive, can be positive or negative
+     * @param upper the upper bound, exclusive, should be positive, must be greater than lower
+     * @return a random int at least equal to lower and less than upper
+     */
+    public int nextInt( final int lower, final int upper ) {
+        if ( upper - lower <= 0 ) throw new IllegalArgumentException("Upper bound must be greater than lower bound");
+        return lower + nextInt(upper - lower);
+    }
+
+    /**
+     * Exclusive on the upper bound. The lower bound is 0.
+     * @param bound the upper bound; should be positive
+     * @return a random long less than n
+     */
+    public long nextLong( final long bound ) {
+        if ( bound <= 0 ) return 0;
+        long threshold = (0x7fffffffffffffffL - bound + 1) % bound;
+        for (;;) {
+            long bits = nextLong() & 0x7fffffffffffffffL;
+            if (bits >= threshold)
+                return bits % bound;
+        }
+    }
+
+    /**
+     * Inclusive lower, exclusive upper.
+     * @param lower the lower bound, inclusive, can be positive or negative
+     * @param upper the upper bound, exclusive, should be positive, must be greater than lower
+     * @return a random long at least equal to lower and less than upper
+     */
+    public long nextLong( final long lower, final long upper ) {
+        if ( upper - lower <= 0 )  throw new IllegalArgumentException("Upper bound must be greater than lower bound");
+        return lower + nextLong(upper - lower);
+    }
+    /**
+     * Gets a uniform random double in the range [0.0,1.0)
+     * @return a random double at least equal to 0.0 and less than 1.0
+     */
+    public double nextDouble() {
+        return ( nextLong() & DOUBLE_MASK ) * NORM_53;
+    }
+
+    /**
+     * Gets a uniform random double in the range [0.0,outer) given a positive parameter outer. If outer
+     * is negative, it will be the (exclusive) lower bound and 0.0 will be the (inclusive) upper bound.
+     * @param outer the exclusive outer bound, can be negative
+     * @return a random double between 0.0 (inclusive) and outer (exclusive)
+     */
+    public double nextDouble(final double outer) {
+        return nextDouble() * outer;
+    }
+
+    /**
+     * Gets a uniform random float in the range [0.0,1.0)
+     * @return a random float at least equal to 0.0 and less than 1.0
+     */
+    public float nextFloat() {
+        return (float)( ( nextLong() & FLOAT_MASK ) * NORM_24 );
+    }
+
+    /**
+     * Gets a random value, true or false.
+     * Calls nextLong() once.
+     * @return a random true or false value.
+     */
+    public boolean nextBoolean() {
+        return ( nextLong() & 1 ) != 0L;
+    }
+
+    /**
+     * Given a byte array as a parameter, this will fill the array with random bytes (modifying it
+     * in-place). Calls nextLong() {@code Math.ceil(bytes.length / 8.0)} times.
+     * @param bytes a byte array that will have its contents overwritten with random bytes.
+     */
+    public void nextBytes( final byte[] bytes ) {
+        int i = bytes.length, n = 0;
+        while( i != 0 ) {
+            n = Math.min( i, 8 );
+            for ( long bits = nextLong(); n-- != 0; bits >>= 8 ) bytes[ --i ] = (byte)bits;
+        }
+    }
+
+
+
+    /**
+     * Sets the seed of this generator (which is also the current state).
+     * @param seed the seed to use for this LightRNG, as if it was constructed with this seed.
+     */
+    public void setSeed( final long seed ) {
+        state = seed;
+    }
+    /**
+     * Sets the seed (also the current state) of this generator.
+     * @param seed the seed to use for this LightRNG, as if it was constructed with this seed.
+     */
+    @Override
+    public void setState( final long seed ) {
+        state = seed;
+    }
+    /**
+     * Gets the current state of this generator.
+     * @return the current seed of this LightRNG, changed once per call to nextLong()
+     */
+    @Override
+    public long getState() {
+        return state;
+    }
+
+    /**
+     * Advances or rolls back the LightRNG's state without actually generating numbers. Skip forward
+     * or backward a number of steps specified by advance, where a step is equal to one call to nextInt().
+     * @param advance Number of future generations to skip past. Can be negative to backtrack.
+     * @return the state after skipping.
+     */
+    public long skip(long advance)
+    {
+        return state += 0x9E3779B97F4A7C15L * advance;
+    }
+
+    @Override
+    public String toString() {
+        return "LightRNG";
+    }
+
+}
\ No newline at end of file
diff --git a/src/main/java/com/mrpowergamerbr/utils/LightRandom.java b/src/main/java/com/mrpowergamerbr/utils/LightRandom.java
new file mode 100644
index 0000000..4da2306
--- /dev/null
+++ b/src/main/java/com/mrpowergamerbr/utils/LightRandom.java
@@ -0,0 +1,60 @@
+package com.mrpowergamerbr.utils;
+
+import java.util.Random;
+
+/**
+ * From DreamSpigotPlus project.
+ * @Link: https://github.com/DreamSpigotMC/DreamSpigotPlus/blob/master/PaperSpigot-Server-Patches/0024-DreamSpigotPlus-Use-a-Shared-LightRNG-for-Entities.patch
+ */
+
+/**
+ * This is a "fake" LightRandom, backed by the LightRNG.
+ * 
+ * This is useful if you want to quickly replace a Random variable with
+ * LightRNG without breaking every code.
+ */
+public class LightRandom extends Random {
+	public static LightRNG light = new LightRNG(); // LightRNG, static.
+	
+	private static final long serialVersionUID = 1L;
+
+	@Override
+	public int next(int bits) {
+		return light.next(bits);
+	}
+	
+	@Override
+	public void nextBytes(byte[] bytes) {
+		light.nextBytes(bytes);
+	}
+	
+	@Override
+	public int nextInt() {
+		return light.nextInt();
+	}
+	
+	@Override
+	public int nextInt(int n) {
+		return light.nextInt(n);
+	}
+	
+	@Override
+	public long nextLong() {
+		return light.nextLong();
+	}
+	
+	@Override
+	public boolean nextBoolean() {
+		return light.nextBoolean();
+	}
+	
+	@Override
+	public float nextFloat() {
+		return light.nextFloat();
+	}
+	
+	@Override
+	public double nextDouble() {
+		return light.nextDouble();
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/com/mrpowergamerbr/utils/RandomnessSource.java b/src/main/java/com/mrpowergamerbr/utils/RandomnessSource.java
new file mode 100644
index 0000000..55cc7a4
--- /dev/null
+++ b/src/main/java/com/mrpowergamerbr/utils/RandomnessSource.java
@@ -0,0 +1,45 @@
+package com.mrpowergamerbr.utils;
+
+import java.io.Serializable;
+
+/**
+ * From DreamSpigotPlus project.
+ * @Link: https://github.com/DreamSpigotMC/DreamSpigotPlus/blob/master/PaperSpigot-Server-Patches/0024-DreamSpigotPlus-Use-a-Shared-LightRNG-for-Entities.patch
+ */
+
+/**
+ * This interface defines the interactions required of a random number
+ * generator. It is a replacement for Java's built-in Random because for
+ * improved performance.
+ *
+ * @author Eben Howard - http://squidpony.com - howard@squidpony.com
+ */
+public interface RandomnessSource extends Serializable {
+
+    /**
+     * Using this method, any algorithm that might use the built-in Java Random
+     * can interface with this randomness source.
+     *
+     * @param bits the number of bits to be returned
+     * @return the integer containing the appropriate number of bits
+     */
+    int next(int bits);
+
+    /**
+     *
+     * Using this method, any algorithm that needs to efficiently generate more
+     * than 32 bits of random data can interface with this randomness source.
+     *
+     * Get a random long between Long.MIN_VALUE and Long.MAX_VALUE (both inclusive).
+     * @return a random long between Long.MIN_VALUE and Long.MAX_VALUE (both inclusive)
+     */
+    long nextLong();
+
+    /**
+     * Produces a copy of this RandomnessSource that, if next() and/or nextLong() are called on this object and the
+     * copy, both will generate the same sequence of random numbers from the point copy() was called. This just need to
+     * copy the state so it isn't shared, usually, and produce a new value with the same exact state.
+     * @return a copy of this RandomnessSource
+     */
+    RandomnessSource copy();
+}
\ No newline at end of file
diff --git a/src/main/java/com/mrpowergamerbr/utils/StatefulRandomness.java b/src/main/java/com/mrpowergamerbr/utils/StatefulRandomness.java
new file mode 100644
index 0000000..eeff45c
--- /dev/null
+++ b/src/main/java/com/mrpowergamerbr/utils/StatefulRandomness.java
@@ -0,0 +1,25 @@
+package com.mrpowergamerbr.utils;
+
+/**
+ * From DreamSpigotPlus project.
+ * @Link: https://github.com/DreamSpigotMC/DreamSpigotPlus/blob/master/PaperSpigot-Server-Patches/0024-DreamSpigotPlus-Use-a-Shared-LightRNG-for-Entities.patch
+ */
+
+/**
+ * A simple interface for RandomnessSources that have the additional property of a state that can be re-set.
+ * Created by Tommy Ettinger on 9/15/2015.
+ */
+public interface StatefulRandomness extends RandomnessSource {
+    /**
+     * Get the current internal state of the StatefulRandomness as a long.
+     * @return the current internal state of this object.
+     */
+    long getState();
+
+    /**
+     * Set the current internal state of this StatefulRandomness with a long.
+     *
+     * @param state a 64-bit long. You should avoid passing 0, even though some implementations can handle that.
+     */
+    void setState(long state);
+}
\ No newline at end of file
diff --git a/src/main/java/net/minecraft/server/DedicatedServer.java b/src/main/java/net/minecraft/server/DedicatedServer.java
index 41ba0a6..b3c0440 100644
--- a/src/main/java/net/minecraft/server/DedicatedServer.java
+++ b/src/main/java/net/minecraft/server/DedicatedServer.java
@@ -28,7 +28,7 @@ import org.bukkit.craftbukkit.util.Waitable;
 import org.bukkit.event.server.RemoteServerCommandEvent;
 // CraftBukkit end
 
-import org.torch.light.LightRandom;
+import com.mrpowergamerbr.utils.LightRandom;
 
 public class DedicatedServer extends MinecraftServer implements IMinecraftServer {
 
diff --git a/src/main/java/net/minecraft/server/Entity.java b/src/main/java/net/minecraft/server/Entity.java
index b1c76eb..d204c0d 100644
--- a/src/main/java/net/minecraft/server/Entity.java
+++ b/src/main/java/net/minecraft/server/Entity.java
@@ -14,7 +14,7 @@ import javax.annotation.Nullable;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
-import org.torch.light.LightRandom; // Torch
+import com.mrpowergamerbr.utils.LightRandom; // Torch
 
 import java.util.concurrent.RecursiveAction;
 import java.util.Map;
@@ -31,6 +31,7 @@ import org.bukkit.Server;
 import org.bukkit.TravelAgent;
 import org.bukkit.block.BlockFace;
 import org.bukkit.entity.Hanging;
+import org.bukkit.event.entity.EntityAirChangeEvent;
 import org.bukkit.entity.LivingEntity;
 import org.bukkit.entity.Vehicle;
 import co.aikar.timings.MinecraftTimings; // Paper
@@ -2366,7 +2367,13 @@ public abstract class Entity implements ICommandListener, org.spigotmc.Optimized
     }
 
     public void setAirTicks(int i) {
-        this.datawatcher.set(Entity.az, Integer.valueOf(i));
+        // CraftBukkit start
+        EntityAirChangeEvent event = new EntityAirChangeEvent(this.getBukkitEntity(), i);
+        if (event.isCancelled()) {
+            return;
+        }
+        this.datawatcher.set(Entity.az, Integer.valueOf(event.getAmount()));
+        // CraftBukkit end
     }
 
     public void onLightningStrike(EntityLightning entitylightning) {
diff --git a/src/main/java/net/minecraft/server/LoginListener.java b/src/main/java/net/minecraft/server/LoginListener.java
index 77aafcd..045f65b 100644
--- a/src/main/java/net/minecraft/server/LoginListener.java
+++ b/src/main/java/net/minecraft/server/LoginListener.java
@@ -26,7 +26,7 @@ import org.bukkit.event.player.AsyncPlayerPreLoginEvent;
 import org.bukkit.event.player.PlayerPreLoginEvent;
 // CraftBukkit end
 
-import org.torch.light.LightRandom;
+import com.mrpowergamerbr.utils.LightRandom;
 import org.torch.event.PremiumAccountLoginEvent;
 import org.torch.event.PremiumAccountPreLoginEvent;
 
diff --git a/src/main/java/net/minecraft/server/MathHelper.java b/src/main/java/net/minecraft/server/MathHelper.java
index c3aa69b..ab298ad 100644
--- a/src/main/java/net/minecraft/server/MathHelper.java
+++ b/src/main/java/net/minecraft/server/MathHelper.java
@@ -3,13 +3,13 @@ package net.minecraft.server;
 import java.util.Random;
 import java.util.UUID;
 
-import org.torch.light.LightRandom; // Torch
+import com.mrpowergamerbr.utils.LightRandom; // Torch
 
 public class MathHelper {
 
     public static final float a = c(2.0F);
     private static final float[] b = new float[65536];
-    private static final Random c = new LightRandom();
+    private static final LightRandom c = new LightRandom();
     private static final int[] d;
     private static final double e;
     private static final double[] f;
diff --git a/src/main/java/net/minecraft/server/NBTTagList.java b/src/main/java/net/minecraft/server/NBTTagList.java
index e86ca6c..3f13cc1 100644
--- a/src/main/java/net/minecraft/server/NBTTagList.java
+++ b/src/main/java/net/minecraft/server/NBTTagList.java
@@ -5,6 +5,7 @@ import java.io.DataInput;
 import java.io.DataOutput;
 import java.io.IOException;
 import java.util.Iterator;
+import java.util.Collections;
 import java.util.List;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -12,7 +13,7 @@ import org.apache.logging.log4j.Logger;
 public class NBTTagList extends NBTBase {
 
     private static final Logger b = LogManager.getLogger();
-    public List<NBTBase> list = Lists.newArrayList(); // Paper
+    public List<NBTBase> list = Collections.synchronizedList(Lists.newArrayList()); // Paper
     private byte type = 0;
 
     public NBTTagList() {}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutPlayerInfo.java b/src/main/java/net/minecraft/server/PacketPlayOutPlayerInfo.java
new file mode 100644
index 0000000..476da40
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutPlayerInfo.java
@@ -0,0 +1,256 @@
+package net.minecraft.server;
+
+import com.google.common.base.Objects;
+import com.google.common.collect.Lists;
+import com.mojang.authlib.GameProfile;
+import com.mojang.authlib.properties.Property;
+import java.io.IOException;
+import java.util.Iterator;
+import java.util.List;
+import javax.annotation.Nullable;
+
+public class PacketPlayOutPlayerInfo implements Packet<PacketListenerPlayOut> {
+
+    private PacketPlayOutPlayerInfo.EnumPlayerInfoAction a;
+    private final List<PacketPlayOutPlayerInfo.PlayerInfoData> b = Lists.newArrayList();
+
+    public PacketPlayOutPlayerInfo() {}
+
+    public PacketPlayOutPlayerInfo(PacketPlayOutPlayerInfo.EnumPlayerInfoAction packetplayoutplayerinfo_enumplayerinfoaction, EntityPlayer... aentityplayer) {
+        this.a = packetplayoutplayerinfo_enumplayerinfoaction;
+        EntityPlayer[] aentityplayer1 = aentityplayer;
+        int i = aentityplayer.length;
+
+        for (int j = 0; j < i; ++j) {
+            EntityPlayer entityplayer = aentityplayer1[j];
+
+            this.b.add(new PacketPlayOutPlayerInfo.PlayerInfoData(entityplayer.getProfile(), entityplayer.ping, entityplayer.playerInteractManager.getGameMode(), entityplayer.getPlayerListName()));
+        }
+
+    }
+
+    public PacketPlayOutPlayerInfo(PacketPlayOutPlayerInfo.EnumPlayerInfoAction packetplayoutplayerinfo_enumplayerinfoaction, Iterable<EntityPlayer> iterable) {
+        this.a = packetplayoutplayerinfo_enumplayerinfoaction;
+        Iterator iterator = iterable.iterator();
+
+        while (iterator.hasNext()) {
+            EntityPlayer entityplayer = (EntityPlayer) iterator.next();
+
+            this.b.add(new PacketPlayOutPlayerInfo.PlayerInfoData(entityplayer.getProfile(), entityplayer.ping, entityplayer.playerInteractManager.getGameMode(), entityplayer.getPlayerListName()));
+        }
+
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) throws IOException {
+        this.a = (PacketPlayOutPlayerInfo.EnumPlayerInfoAction) packetdataserializer.a(PacketPlayOutPlayerInfo.EnumPlayerInfoAction.class);
+        int i = packetdataserializer.g();
+
+        for (int j = 0; j < i; ++j) {
+            GameProfile gameprofile = null;
+            int k = 0;
+            WorldSettings.EnumGamemode worldsettings_enumgamemode = null;
+            IChatBaseComponent ichatbasecomponent = null;
+
+            switch (PacketPlayOutPlayerInfo.SyntheticClass_1.a[this.a.ordinal()]) {
+            case 1:
+                gameprofile = new GameProfile(packetdataserializer.i(), packetdataserializer.e(16));
+                int l = packetdataserializer.g();
+
+                for (int i1 = 0; i1 < l; ++i1) {
+                    String s = packetdataserializer.e(32767);
+                    String s1 = packetdataserializer.e(32767);
+
+                    if (packetdataserializer.readBoolean()) {
+                        gameprofile.getProperties().put(s, new Property(s, s1, packetdataserializer.e(32767)));
+                    } else {
+                        gameprofile.getProperties().put(s, new Property(s, s1));
+                    }
+                }
+
+                worldsettings_enumgamemode = WorldSettings.EnumGamemode.getById(packetdataserializer.g());
+                k = packetdataserializer.g();
+                if (packetdataserializer.readBoolean()) {
+                    ichatbasecomponent = packetdataserializer.f();
+                }
+                break;
+
+            case 2:
+                gameprofile = new GameProfile(packetdataserializer.i(), (String) null);
+                worldsettings_enumgamemode = WorldSettings.EnumGamemode.getById(packetdataserializer.g());
+                break;
+
+            case 3:
+                gameprofile = new GameProfile(packetdataserializer.i(), (String) null);
+                k = packetdataserializer.g();
+                break;
+
+            case 4:
+                gameprofile = new GameProfile(packetdataserializer.i(), (String) null);
+                if (packetdataserializer.readBoolean()) {
+                    ichatbasecomponent = packetdataserializer.f();
+                }
+                break;
+
+            case 5:
+                gameprofile = new GameProfile(packetdataserializer.i(), (String) null);
+            }
+
+            this.b.add(new PacketPlayOutPlayerInfo.PlayerInfoData(gameprofile, k, worldsettings_enumgamemode, ichatbasecomponent));
+        }
+
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) throws IOException {
+        packetdataserializer.a((Enum) this.a);
+        packetdataserializer.d(this.b.size());
+        Iterator iterator = this.b.iterator();
+
+        while (iterator.hasNext()) {
+            PacketPlayOutPlayerInfo.PlayerInfoData packetplayoutplayerinfo_playerinfodata = (PacketPlayOutPlayerInfo.PlayerInfoData) iterator.next();
+
+            switch (PacketPlayOutPlayerInfo.SyntheticClass_1.a[this.a.ordinal()]) {
+            case 1:
+                packetdataserializer.a(packetplayoutplayerinfo_playerinfodata.a().getId());
+                packetdataserializer.a(packetplayoutplayerinfo_playerinfodata.a().getName());
+                packetdataserializer.d(packetplayoutplayerinfo_playerinfodata.a().getProperties().size());
+                Iterator iterator1 = packetplayoutplayerinfo_playerinfodata.a().getProperties().values().iterator();
+
+                while (iterator1.hasNext()) {
+                    Property property = (Property) iterator1.next();
+
+                    packetdataserializer.a(property.getName());
+                    packetdataserializer.a(property.getValue());
+                    if (property.hasSignature()) {
+                        packetdataserializer.writeBoolean(true);
+                        packetdataserializer.a(property.getSignature());
+                    } else {
+                        packetdataserializer.writeBoolean(false);
+                    }
+                }
+
+                packetdataserializer.d(packetplayoutplayerinfo_playerinfodata.c().getId());
+                packetdataserializer.d(packetplayoutplayerinfo_playerinfodata.b());
+                if (packetplayoutplayerinfo_playerinfodata.d() == null) {
+                    packetdataserializer.writeBoolean(false);
+                } else {
+                    packetdataserializer.writeBoolean(true);
+                    packetdataserializer.a(packetplayoutplayerinfo_playerinfodata.d());
+                }
+                break;
+
+            case 2:
+                packetdataserializer.a(packetplayoutplayerinfo_playerinfodata.a().getId());
+                packetdataserializer.d(packetplayoutplayerinfo_playerinfodata.c().getId());
+                break;
+
+            case 3:
+                packetdataserializer.a(packetplayoutplayerinfo_playerinfodata.a().getId());
+                packetdataserializer.d(packetplayoutplayerinfo_playerinfodata.b());
+                break;
+
+            case 4:
+                packetdataserializer.a(packetplayoutplayerinfo_playerinfodata.a().getId());
+                if (packetplayoutplayerinfo_playerinfodata.d() == null) {
+                    packetdataserializer.writeBoolean(false);
+                } else {
+                    packetdataserializer.writeBoolean(true);
+                    packetdataserializer.a(packetplayoutplayerinfo_playerinfodata.d());
+                }
+                break;
+
+            case 5:
+                packetdataserializer.a(packetplayoutplayerinfo_playerinfodata.a().getId());
+            }
+        }
+
+    }
+
+    public void a(PacketListenerPlayOut packetlistenerplayout) {
+        packetlistenerplayout.a(this);
+    }
+
+    public String toString() {
+        return Objects.toStringHelper(this).add("action", this.a).add("entries", this.b).toString();
+    }
+
+    static class SyntheticClass_1 {
+
+        static final int[] a = new int[PacketPlayOutPlayerInfo.EnumPlayerInfoAction.values().length];
+
+        static {
+            try {
+                PacketPlayOutPlayerInfo.SyntheticClass_1.a[PacketPlayOutPlayerInfo.EnumPlayerInfoAction.ADD_PLAYER.ordinal()] = 1;
+            } catch (NoSuchFieldError nosuchfielderror) {
+                ;
+            }
+
+            try {
+                PacketPlayOutPlayerInfo.SyntheticClass_1.a[PacketPlayOutPlayerInfo.EnumPlayerInfoAction.UPDATE_GAME_MODE.ordinal()] = 2;
+            } catch (NoSuchFieldError nosuchfielderror1) {
+                ;
+            }
+
+            try {
+                PacketPlayOutPlayerInfo.SyntheticClass_1.a[PacketPlayOutPlayerInfo.EnumPlayerInfoAction.UPDATE_LATENCY.ordinal()] = 3;
+            } catch (NoSuchFieldError nosuchfielderror2) {
+                ;
+            }
+
+            try {
+                PacketPlayOutPlayerInfo.SyntheticClass_1.a[PacketPlayOutPlayerInfo.EnumPlayerInfoAction.UPDATE_DISPLAY_NAME.ordinal()] = 4;
+            } catch (NoSuchFieldError nosuchfielderror3) {
+                ;
+            }
+
+            try {
+                PacketPlayOutPlayerInfo.SyntheticClass_1.a[PacketPlayOutPlayerInfo.EnumPlayerInfoAction.REMOVE_PLAYER.ordinal()] = 5;
+            } catch (NoSuchFieldError nosuchfielderror4) {
+                ;
+            }
+
+        }
+    }
+
+    public class PlayerInfoData {
+
+        private final int b;
+        private final WorldSettings.EnumGamemode c;
+        private final GameProfile d;
+        private final IChatBaseComponent e;
+
+        public PlayerInfoData(GameProfile gameprofile, int i, WorldSettings.EnumGamemode worldsettings_enumgamemode, @Nullable IChatBaseComponent ichatbasecomponent) {
+            this.d = gameprofile;
+            this.b = i;
+            this.c = worldsettings_enumgamemode;
+            this.e = ichatbasecomponent;
+        }
+
+        public GameProfile a() {
+            return this.d;
+        }
+
+        public int b() {
+            return this.b;
+        }
+
+        public WorldSettings.EnumGamemode c() {
+            return this.c;
+        }
+
+        @Nullable
+        public IChatBaseComponent d() {
+            return this.e;
+        }
+
+        public String toString() {
+            return Objects.toStringHelper(this).add("latency", this.b).add("gameMode", this.c).add("profile", this.d).add("displayName", this.e == null ? null : IChatBaseComponent.ChatSerializer.a(this.e)).toString();
+        }
+    }
+
+    public static enum EnumPlayerInfoAction {
+
+        ADD_PLAYER, UPDATE_GAME_MODE, UPDATE_LATENCY, UPDATE_DISPLAY_NAME, REMOVE_PLAYER;
+
+        private EnumPlayerInfoAction() {}
+    }
+}
diff --git a/src/main/java/net/minecraft/server/RegionFile.java b/src/main/java/net/minecraft/server/RegionFile.java
index bf5f952..32cf73e 100644
--- a/src/main/java/net/minecraft/server/RegionFile.java
+++ b/src/main/java/net/minecraft/server/RegionFile.java
@@ -25,6 +25,8 @@ import java.io.RandomAccessFile;
 import java.nio.ByteBuffer;
 import java.nio.IntBuffer;
 import java.util.List;
+import java.util.ArrayList;
+import java.util.Collections;
 import java.util.zip.DeflaterOutputStream;
 import java.util.zip.GZIPInputStream;
 import java.util.zip.InflaterInputStream;
@@ -50,6 +52,10 @@ public class RegionFile {
     private void addCoordinatesToCache(int i, int j) {
         this.existingChunkCache[i + j * 32] = true;
     }
+	
+	public static <E> List<E> newSyncArrayListWithCapacity(int initialArraySize) {
+		return Collections.synchronizedList(new ArrayList<E>(initialArraySize));
+	}
     // Migot end
 
     public RegionFile(File file) {
@@ -78,7 +84,7 @@ public class RegionFile {
             }
 
             i = (int) this.c.length() / 4096;
-            this.f = Lists.newArrayListWithCapacity(i);
+            this.f = this.newSyncArrayListWithCapacity(i); // Torch
 
             int j;
 
diff --git a/src/main/java/org/bukkit/event/entity/EntityAirChangeEvent.java b/src/main/java/org/bukkit/event/entity/EntityAirChangeEvent.java
new file mode 100644
index 0000000..02f191a
--- /dev/null
+++ b/src/main/java/org/bukkit/event/entity/EntityAirChangeEvent.java
@@ -0,0 +1,59 @@
+package org.bukkit.event.entity;
+
+import org.bukkit.entity.Entity;
+import org.bukkit.event.Cancellable;
+import org.bukkit.event.HandlerList;
+
+/**
+ * Called when the amount of air an entity has remaining changes.
+ */
+public class EntityAirChangeEvent extends EntityEvent implements Cancellable {
+
+    private static final HandlerList handlers = new HandlerList();
+    //
+    private int amount;
+    //
+    private boolean cancelled;
+
+    public EntityAirChangeEvent(Entity what, int amount) {
+        super(what);
+        this.amount = amount;
+    }
+
+    /**
+     * Gets the amount of air the entity has left (measured in ticks).
+     *
+     * @return amount of air remaining
+     */
+    public int getAmount() {
+        return amount;
+    }
+
+    /**
+     * Sets the amount of air remaining for the entity (measured in ticks.
+     *
+     * @param amount amount of air remaining
+     */
+    public void setAmount(int amount) {
+        this.amount = amount;
+    }
+
+    @Override
+    public boolean isCancelled() {
+        return cancelled;
+    }
+
+    @Override
+    public void setCancelled(boolean cancelled) {
+        this.cancelled = cancelled;
+    }
+
+    @Override
+    public HandlerList getHandlers() {
+        return handlers;
+    }
+
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/org/torch/light/LightRNG.java b/src/main/java/org/torch/light/LightRNG.java
deleted file mode 100644
index b48aa65..0000000
--- a/src/main/java/org/torch/light/LightRNG.java
+++ /dev/null
@@ -1,240 +0,0 @@
-/*
-Written in 2015 by Sebastiano Vigna (vigna@acm.org)
-
-To the extent possible under law, the author has dedicated all copyright
-and related and neighboring rights to this software to the public domain
-worldwide. This software is distributed without any warranty.
-
-See <http://creativecommons.org/publicdomain/zero/1.0/>. */
-package org.torch.light;
-
-/**
- * This is a SplittableRandom-style generator, meant to have a tiny state
- * that permits storing many different generators with low overhead.
- * It should be rather fast, though no guarantees can be made on all hardware.
- * <br>
- * Benchmarking on a Windows laptop with an i7-4700MQ processor running OpenJDK 8
- * reports generation of 64-bit random long output as 17.8x faster than generating
- * an equivalent number of random longs with java.util.Random, and generation of
- * 32-bit random int output as 9.8x faster. Specifically, generating 1 billion longs
- * took about 1.28 nanoseconds per long (1.277 seconds for the whole group) with
- * LightRNG, while java.util.Random (which is meant to produce int, to be fair) took
- * about 22.8 nanoseconds per long (22.797 seconds for the whole group). XorRNG
- * appears to be occasionally faster on int output than LightRNG, but it isn't clear
- * why or what causes that (JIT or GC internals, possibly). XorRNG is slightly
- * slower at generating 64-bit random data, including long and double, but not by
- * a significant degree (a multiplier between 0.9 and 1.2 times). The only deciding
- * factor then is state size, where LightRNG is as small as possible for any JVM
- * object with even a single field: 16 bytes (on a 64-bit JVM; 8-byte objects with
- * 4 bytes or less of non-static members may be possible on 32-bit JVMs but I can't
- * find anything confirming that guess).
- * <br>
- * So yes, this should be very fast, and with only a single long used per LightRNG,
- * it is about as memory-efficient as these generators get.
- * <br>
- * Written in 2015 by Sebastiano Vigna (vigna@acm.org)
- * @author Sebastiano Vigna
- * @author Tommy Ettinger
- */
-public class LightRNG implements RandomnessSource, StatefulRandomness
-{
-	/** 2 raised to the 53, - 1. */
-    private static final long DOUBLE_MASK = ( 1L << 53 ) - 1;
-    /** 2 raised to the -53. */
-    private static final double NORM_53 = 1. / ( 1L << 53 );
-    /** 2 raised to the 24, -1. */
-    private static final long FLOAT_MASK = ( 1L << 24 ) - 1;
-    /** 2 raised to the -24. */
-    private static final double NORM_24 = 1. / ( 1L << 24 );
-
-    private static final long serialVersionUID = -374415589203474497L;
-
-    public long state; /* The state can be seeded with any value. */
-
-    /** Creates a new generator seeded using Math.random. */
-    public LightRNG() {
-        this((long) Math.floor(Math.random() * Long.MAX_VALUE));
-    }
-
-    public LightRNG( final long seed ) {
-        setSeed(seed);
-    }
-
-    @Override
-    public int next( int bits ) {
-        return (int)( nextLong() & ( 1L << bits ) - 1 );
-    }
-
-    /**
-     * Can return any long, positive or negative, of any size permissible in a 64-bit signed integer.
-     * @return any long, all 64 bits are random
-     */
-    @Override
-    public long nextLong() {
-        long z = ( state += 0x9E3779B97F4A7C15L );
-        z = (z ^ (z >>> 30)) * 0xBF58476D1CE4E5B9L;
-        z = (z ^ (z >>> 27)) * 0x94D049BB133111EBL;
-        return z ^ (z >>> 31);
-    }
-
-    /**
-     * Produces a copy of this RandomnessSource that, if next() and/or nextLong() are called on this object and the
-     * copy, both will generate the same sequence of random numbers from the point copy() was called. This just need to
-     * copy the state so it isn't shared, usually, and produce a new value with the same exact state.
-     *
-     * @return a copy of this RandomnessSource
-     */
-    @Override
-    public RandomnessSource copy() {
-        return new LightRNG(state);
-    }
-
-    /**
-     * Can return any int, positive or negative, of any size permissible in a 32-bit signed integer.
-     * @return any int, all 32 bits are random
-     */
-    public int nextInt() {
-        return (int)nextLong();
-    }
-
-    /**
-     * Exclusive on the upper bound.  The lower bound is 0.
-     * @param bound the upper bound; should be positive
-     * @return a random int less than n and at least equal to 0
-     */
-    public int nextInt( final int bound ) {
-        if ( bound <= 0 ) return 0;
-        int threshold = (0x7fffffff - bound + 1) % bound;
-        for (;;) {
-            int bits = (int)(nextLong() & 0x7fffffff);
-            if (bits >= threshold)
-                return bits % bound;
-        }
-    }
-    /**
-     * Inclusive lower, exclusive upper.
-     * @param lower the lower bound, inclusive, can be positive or negative
-     * @param upper the upper bound, exclusive, should be positive, must be greater than lower
-     * @return a random int at least equal to lower and less than upper
-     */
-    public int nextInt( final int lower, final int upper ) {
-        if ( upper - lower <= 0 ) throw new IllegalArgumentException("Upper bound must be greater than lower bound");
-        return lower + nextInt(upper - lower);
-    }
-
-    /**
-     * Exclusive on the upper bound. The lower bound is 0.
-     * @param bound the upper bound; should be positive
-     * @return a random long less than n
-     */
-    public long nextLong( final long bound ) {
-        if ( bound <= 0 ) return 0;
-        long threshold = (0x7fffffffffffffffL - bound + 1) % bound;
-        for (;;) {
-            long bits = nextLong() & 0x7fffffffffffffffL;
-            if (bits >= threshold)
-                return bits % bound;
-        }
-    }
-
-    /**
-     * Inclusive lower, exclusive upper.
-     * @param lower the lower bound, inclusive, can be positive or negative
-     * @param upper the upper bound, exclusive, should be positive, must be greater than lower
-     * @return a random long at least equal to lower and less than upper
-     */
-    public long nextLong( final long lower, final long upper ) {
-        if ( upper - lower <= 0 )  throw new IllegalArgumentException("Upper bound must be greater than lower bound");
-        return lower + nextLong(upper - lower);
-    }
-    /**
-     * Gets a uniform random double in the range [0.0,1.0)
-     * @return a random double at least equal to 0.0 and less than 1.0
-     */
-    public double nextDouble() {
-        return ( nextLong() & DOUBLE_MASK ) * NORM_53;
-    }
-
-    /**
-     * Gets a uniform random double in the range [0.0,outer) given a positive parameter outer. If outer
-     * is negative, it will be the (exclusive) lower bound and 0.0 will be the (inclusive) upper bound.
-     * @param outer the exclusive outer bound, can be negative
-     * @return a random double between 0.0 (inclusive) and outer (exclusive)
-     */
-    public double nextDouble(final double outer) {
-        return nextDouble() * outer;
-    }
-
-    /**
-     * Gets a uniform random float in the range [0.0,1.0)
-     * @return a random float at least equal to 0.0 and less than 1.0
-     */
-    public float nextFloat() {
-        return (float)( ( nextLong() & FLOAT_MASK ) * NORM_24 );
-    }
-
-    /**
-     * Gets a random value, true or false.
-     * Calls nextLong() once.
-     * @return a random true or false value.
-     */
-    public boolean nextBoolean() {
-        return ( nextLong() & 1 ) != 0L;
-    }
-
-    /**
-     * Given a byte array as a parameter, this will fill the array with random bytes (modifying it
-     * in-place). Calls nextLong() {@code Math.ceil(bytes.length / 8.0)} times.
-     * @param bytes a byte array that will have its contents overwritten with random bytes.
-     */
-    public void nextBytes( final byte[] bytes ) {
-        int i = bytes.length, n = 0;
-        while( i != 0 ) {
-            n = Math.min( i, 8 );
-            for ( long bits = nextLong(); n-- != 0; bits >>= 8 ) bytes[ --i ] = (byte)bits;
-        }
-    }
-
-
-
-    /**
-     * Sets the seed of this generator (which is also the current state).
-     * @param seed the seed to use for this LightRNG, as if it was constructed with this seed.
-     */
-    public void setSeed( final long seed ) {
-        state = seed;
-    }
-    /**
-     * Sets the seed (also the current state) of this generator.
-     * @param seed the seed to use for this LightRNG, as if it was constructed with this seed.
-     */
-    @Override
-    public void setState( final long seed ) {
-        state = seed;
-    }
-    /**
-     * Gets the current state of this generator.
-     * @return the current seed of this LightRNG, changed once per call to nextLong()
-     */
-    @Override
-    public long getState() {
-        return state;
-    }
-
-    /**
-     * Advances or rolls back the LightRNG's state without actually generating numbers. Skip forward
-     * or backward a number of steps specified by advance, where a step is equal to one call to nextInt().
-     * @param advance Number of future generations to skip past. Can be negative to backtrack.
-     * @return the state after skipping.
-     */
-    public long skip(long advance)
-    {
-        return state += 0x9E3779B97F4A7C15L * advance;
-    }
-
-    @Override
-    public String toString() {
-        return "LightRNG";
-    }
-
-}
\ No newline at end of file
diff --git a/src/main/java/org/torch/light/LightRandom.java b/src/main/java/org/torch/light/LightRandom.java
deleted file mode 100644
index 5793605..0000000
--- a/src/main/java/org/torch/light/LightRandom.java
+++ /dev/null
@@ -1,55 +0,0 @@
-package org.torch.light;
-
-import java.util.Random;
-
-/**
- * This is a "fake" LightRandom, backed by the LightRNG.
- * 
- * This is useful if you want to quickly replace a Random variable with
- * LightRNG without breaking every code.
- */
-public class LightRandom extends Random {
-	public static LightRNG light = new LightRNG(); // LightRNG, static.
-	
-	private static final long serialVersionUID = 1L;
-
-	@Override
-	public int next(int bits) {
-		return light.next(bits);
-	}
-	
-	@Override
-	public void nextBytes(byte[] bytes) {
-		light.nextBytes(bytes);
-	}
-	
-	@Override
-	public int nextInt() {
-		return light.nextInt();
-	}
-	
-	@Override
-	public int nextInt(int n) {
-		return light.nextInt(n);
-	}
-	
-	@Override
-	public long nextLong() {
-		return light.nextLong();
-	}
-	
-	@Override
-	public boolean nextBoolean() {
-		return light.nextBoolean();
-	}
-	
-	@Override
-	public float nextFloat() {
-		return light.nextFloat();
-	}
-	
-	@Override
-	public double nextDouble() {
-		return light.nextDouble();
-	}
-}
\ No newline at end of file
diff --git a/src/main/java/org/torch/light/RandomnessSource.java b/src/main/java/org/torch/light/RandomnessSource.java
deleted file mode 100644
index 5a3442a..0000000
--- a/src/main/java/org/torch/light/RandomnessSource.java
+++ /dev/null
@@ -1,40 +0,0 @@
-package org.torch.light;
-
-import java.io.Serializable;
-
-/**
- * This interface defines the interactions required of a random number
- * generator. It is a replacement for Java's built-in Random because for
- * improved performance.
- *
- * @author Eben Howard - http://squidpony.com - howard@squidpony.com
- */
-public interface RandomnessSource extends Serializable {
-
-    /**
-     * Using this method, any algorithm that might use the built-in Java Random
-     * can interface with this randomness source.
-     *
-     * @param bits the number of bits to be returned
-     * @return the integer containing the appropriate number of bits
-     */
-    int next(int bits);
-
-    /**
-     *
-     * Using this method, any algorithm that needs to efficiently generate more
-     * than 32 bits of random data can interface with this randomness source.
-     *
-     * Get a random long between Long.MIN_VALUE and Long.MAX_VALUE (both inclusive).
-     * @return a random long between Long.MIN_VALUE and Long.MAX_VALUE (both inclusive)
-     */
-    long nextLong();
-
-    /**
-     * Produces a copy of this RandomnessSource that, if next() and/or nextLong() are called on this object and the
-     * copy, both will generate the same sequence of random numbers from the point copy() was called. This just need to
-     * copy the state so it isn't shared, usually, and produce a new value with the same exact state.
-     * @return a copy of this RandomnessSource
-     */
-    RandomnessSource copy();
-}
\ No newline at end of file
diff --git a/src/main/java/org/torch/light/StatefulRandomness.java b/src/main/java/org/torch/light/StatefulRandomness.java
deleted file mode 100644
index 584caa9..0000000
--- a/src/main/java/org/torch/light/StatefulRandomness.java
+++ /dev/null
@@ -1,20 +0,0 @@
-package org.torch.light;
-
-/**
- * A simple interface for RandomnessSources that have the additional property of a state that can be re-set.
- * Created by Tommy Ettinger on 9/15/2015.
- */
-public interface StatefulRandomness extends RandomnessSource {
-    /**
-     * Get the current internal state of the StatefulRandomness as a long.
-     * @return the current internal state of this object.
-     */
-    long getState();
-
-    /**
-     * Set the current internal state of this StatefulRandomness with a long.
-     *
-     * @param state a 64-bit long. You should avoid passing 0, even though some implementations can handle that.
-     */
-    void setState(long state);
-}
\ No newline at end of file
-- 
2.8.2.windows.1

