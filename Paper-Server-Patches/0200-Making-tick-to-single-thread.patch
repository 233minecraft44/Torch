From 823dcbda2abd1673ab0320c62bcc290980a89e52 Mon Sep 17 00:00:00 2001
From: SotrForgotten <i@omc.hk>
Date: Fri, 29 Jul 2016 05:57:25 +0800
Subject: [PATCH] Making tick to single thread.


diff --git a/src/main/java/co/aikar/timings/TimingHandler.java b/src/main/java/co/aikar/timings/TimingHandler.java
index 6615ac0..850f3b7 100644
--- a/src/main/java/co/aikar/timings/TimingHandler.java
+++ b/src/main/java/co/aikar/timings/TimingHandler.java
@@ -108,12 +108,16 @@ class TimingHandler implements Timing {
 
     public void stopTiming() {
         if (enabled && --timingDepth == 0 && start != 0) {
-            if (!Bukkit.isPrimaryThread()) {
+            /* if (!Bukkit.isPrimaryThread()) { // Torch start - Temporary workaround for timings
                 Bukkit.getLogger().log(Level.SEVERE, "Timing issue occour in " + name + ", please report it to Torch!");
                 new Throwable().printStackTrace();
                 start = 0;
                 return;
-            }
+            } */
+			if (!Bukkit.isPrimaryThread()) {
+				start = 0;
+                return;
+			} // Torch end
             addDiff(System.nanoTime() - start);
             start = 0;
         }
diff --git a/src/main/java/de/minetick/Migot.java b/src/main/java/de/minetick/Migot.java
index 5b962c4..8fedfd5 100644
--- a/src/main/java/de/minetick/Migot.java
+++ b/src/main/java/de/minetick/Migot.java
@@ -32,8 +32,8 @@ public class Migot {
     private boolean failedToLoadConfig = false;
     private TickTimer tickTimerObject;
     private int timerDelay = 45;
-    private ScheduledExecutorService timerService = Executors.newScheduledThreadPool(1, new MigotThreadFactory(Thread.NORM_PRIORITY + 2, "Torch_TimerService")); // Torch
-	private ExecutorService nbtFileService = Executors.newSingleThreadExecutor(new MigotThreadFactory(Thread.NORM_PRIORITY - 2, "Torch_NBTFileSaver")); // Torch
+    private ScheduledExecutorService timerService = Executors.newScheduledThreadPool(1, new MigotThreadFactory(Thread.NORM_PRIORITY + 2, "Timer Service")); // Torch
+	private ExecutorService nbtFileService = Executors.newSingleThreadExecutor(new MigotThreadFactory(Thread.NORM_PRIORITY - 2, "NBT File Saver")); // Torch
     private ScheduledFuture<Object> tickTimerTask;
     private static Migot instance;
     private boolean initDone = false;
diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java
index f3a2192..b399f6a 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java
@@ -92,7 +92,6 @@ public class ChunkProviderServer implements IChunkProvider {
             this.unloadQueue.add(Long.valueOf(ChunkCoordIntPair.a(chunk.locX, chunk.locZ)));
             chunk.d = true;
         }
-
     }
 
     public void b() {
diff --git a/src/main/java/net/minecraft/server/EntityInsentient.java b/src/main/java/net/minecraft/server/EntityInsentient.java
index d170e1b..7f9b38f 100644
--- a/src/main/java/net/minecraft/server/EntityInsentient.java
+++ b/src/main/java/net/minecraft/server/EntityInsentient.java
@@ -635,8 +635,6 @@ public abstract class EntityInsentient extends EntityLiving {
         }
     }
 
-	// navigation nav_task;
-    // targetSelector tar_task;
     protected final void doTick() {
         ++this.ticksFarFromPlayer;
 		
@@ -660,23 +658,12 @@ public abstract class EntityInsentient extends EntityLiving {
         this.world.methodProfiler.b();
         this.world.methodProfiler.a("targetSelector");
         this.targetSelector.a();
-		// tar_task = new targetSelector();
-        // tar_task.fork();
         this.world.methodProfiler.b();
         this.world.methodProfiler.a("goalSelector");
         this.goalSelector.a();
-		/* // Torch - ForkJoin shouldn't in do tick.
-		try {
-            this.goalSelector.a();
-        } catch (Exception ex) {
-            world.getServer().getLogger().log(java.util.logging.Level.WARNING, "Entityliving doTick - Goal cannot find.");
-        }
-		*/
         this.world.methodProfiler.b();
         this.world.methodProfiler.a("navigation");
         this.navigation.l();
-		// nav_task = new navigation();
-        // nav_task.fork();
         this.world.methodProfiler.b();
         this.world.methodProfiler.a("mob tick");
         this.M();
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index cd93c15..bf23f42 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -236,31 +236,6 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
         this.a(s);
         this.b("menu.loadingLevel");
         this.worldServer = new WorldServer[3];
-        /* CraftBukkit start - Remove ticktime arrays and worldsettings
-        this.i = new long[this.worldServer.length][100];
-        IDataManager idatamanager = this.convertable.a(s, true);
-
-        this.a(this.S(), idatamanager);
-        WorldData worlddata = idatamanager.getWorldData();
-        WorldSettings worldsettings;
-
-        if (worlddata == null) {
-            if (this.V()) {
-                worldsettings = DemoWorldServer.a;
-            } else {
-                worldsettings = new WorldSettings(i, this.getGamemode(), this.getGenerateStructures(), this.isHardcore(), worldtype);
-                worldsettings.setGeneratorSettings(s2);
-                if (this.M) {
-                    worldsettings.a();
-                }
-            }
-
-            worlddata = new WorldData(worldsettings, s1);
-        } else {
-            worlddata.a(s1);
-            worldsettings = new WorldSettings(worlddata);
-        }
-        */
         int worldCount = 3;
 
         for (int j = 0; j < worldCount; ++j) {
@@ -663,8 +638,7 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
     }
     // Paper End
 	
-	private static double calcTps(double avg, double exp, double tps)
-    {
+	private static double calcTps(double avg, double exp, double tps) {
         return ( avg * exp ) + ( tps * ( 1 - exp ) );
     }
 
@@ -897,9 +871,11 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
 
         this.methodProfiler.c("levels");
 
+		/*
         MinecraftTimings.bukkitSchedulerTimer.startTiming(); // Paper
         // CraftBukkit start
         MinecraftTimings.bukkitSchedulerTimer.stopTiming(); // Paper
+		*/
 
         // Run tasks that are waiting on processing
         MinecraftTimings.processQueueTimer.startTiming(); // Spigot
@@ -948,7 +924,11 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
 
                 try {
                     worldserver.timings.doTick.startTiming(); // Spigot
-                    worldserver.doTick();
+					// Torch start
+					Thread worldtick = new Thread(new WorldTickThread(worldserver), "World Ticking Thread");
+                    // worldserver.doTick();
+					worldtick.start(); // do server tick
+					// Torch end
                     worldserver.timings.doTick.stopTiming(); // Spigot
                 } catch (Throwable throwable) {
                     // Spigot Start
@@ -965,7 +945,11 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
 				processNetworkQueue(); // Paper
                 try {
                     worldserver.timings.tickEntities.startTiming(); // Spigot
+					// Torch start
+					// Thread entitytick = new Thread(new EntityTickThread(worldserver), "Entities Ticking Thread");
                     worldserver.tickEntities();
+					// entitytick.start(); // do entity tick
+					// Torch end
                     worldserver.timings.tickEntities.stopTiming(); // Spigot
                 } catch (Throwable throwable1) {
                     // Spigot Start
@@ -1014,6 +998,24 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
 		processNetworkQueue(); // Paper
     }
 
+	// Torch start
+	class WorldTickThread extends Thread {
+		WorldServer worldserver;
+		WorldTickThread(WorldServer worldserver) {
+			this.worldserver = worldserver;
+		}
+        public void run() { worldserver.doTick(); }
+    }
+	/*
+	class EntityTickThread extends Thread {
+		WorldServer worldserver;
+		EntityTickThread(WorldServer worldserver) {
+			this.worldserver = worldserver;
+		}
+        public void run() { worldserver.tickEntities(); }
+    }
+	*/ // Torch end
+
     public boolean getAllowNether() {
         return true;
     }
@@ -1034,39 +1036,6 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
             UserCache usercache = new UserCache(gameprofilerepository, new File(s1, MinecraftServer.a.getName()));
             final DedicatedServer dedicatedserver = new DedicatedServer(options, DataConverterRegistry.a(), yggdrasilauthenticationservice, minecraftsessionservice, gameprofilerepository, usercache);
 
-            /* CraftBukkit start
-            if (s != null) {
-                dedicatedserver.i(s);
-            }
-
-            if (s2 != null) {
-                dedicatedserver.setWorld(s2);
-            }
-
-            if (i >= 0) {
-                dedicatedserver.setPort(i);
-            }
-
-            if (flag1) {
-                dedicatedserver.b(true);
-            }
-
-            if (flag2) {
-                dedicatedserver.c(true);
-            }
-
-            if (flag && !GraphicsEnvironment.isHeadless()) {
-                dedicatedserver.aN();
-            }
-
-            dedicatedserver.F();
-            Runtime.getRuntime().addShutdownHook(new Thread("Server Shutdown Thread") {
-                public void run() {
-                    dedicatedserver.stop();
-                }
-            });
-            */
-
             if (options.has("port")) {
                 int port = (Integer) options.valueOf("port");
                 if (port > 0) {
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index 5408f91..778d1ce 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -1684,12 +1684,11 @@ public abstract class World implements IBlockAccess {
         int entitiesThisCycle = 0;
         // Paper start - Disable tick limiters
         //if (tickPosition < 0) tickPosition = 0;
-		Queue<RecursiveAction> forks = Queues.newConcurrentLinkedQueue();
         for (tickPosition = 0; tickPosition < entityList.size(); tickPosition++) {
             // Paper end
             tickPosition = (tickPosition < entityList.size()) ? tickPosition : 0;
             entity = (Entity) this.entityList.get(this.tickPosition);
-			tick_hose(entity);
+			synchronized(this) { tick_hose(entity); }
             // CraftBukkit end
         }
         guardEntityList = false; // Spigot
diff --git a/src/main/java/net/minecraft/server/WorldServer.java b/src/main/java/net/minecraft/server/WorldServer.java
index e5b40bc..e4bf6f4 100644
--- a/src/main/java/net/minecraft/server/WorldServer.java
+++ b/src/main/java/net/minecraft/server/WorldServer.java
@@ -251,7 +251,7 @@ public class WorldServer extends World implements IAsyncTaskHandler {
 
         timings.doChunkUnload.startTiming(); // Spigot
         this.methodProfiler.c("chunkSource");
-        this.chunkProvider.unloadChunks();
+		synchronized(this) { this.chunkProvider.unloadChunks(); }
         int j = this.a(1.0F);
 
         if (j != this.af()) {
-- 
2.8.2.windows.1

