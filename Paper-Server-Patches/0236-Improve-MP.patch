From 63744ba8f6d06008cdbc2d80de765008828fa232 Mon Sep 17 00:00:00 2001
From: SotrForgotten <i@omc.hk>
Date: Fri, 26 Aug 2016 11:57:45 +0800
Subject: [PATCH] Improve MP


diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java
index 4058fc5..8338146 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java
@@ -5,7 +5,9 @@ import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.concurrent.Callable;
 import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ForkJoinTask;
 
 import javax.annotation.Nullable;
 
@@ -14,6 +16,7 @@ import org.apache.logging.log4j.Logger;
 import org.bukkit.craftbukkit.chunkio.ChunkIOExecutor;
 import org.bukkit.event.world.ChunkUnloadEvent;
 // CraftBukkit end
+import org.spigotmc.SpigotWorldConfig;
 
 import com.destroystokyo.paper.exception.ServerInternalException;
 
@@ -131,15 +134,6 @@ public class ChunkProviderServer implements IChunkProvider {
 			 */ // Paper
 			synchronized (this) {
 				chunk = ChunkIOExecutor.syncChunkLoad(world, chunkLoader, this, i, j); // Paper
-																						// -
-																						// skip
-																						// chunkExists,
-																						// expensive
-																						// and
-																						// performed
-																						// by
-																						// loading
-																						// anyway.
 			}
 		}
 
@@ -203,6 +197,21 @@ public class ChunkProviderServer implements IChunkProvider {
 
 		return chunk;
 	}
+	
+	class originalOrCreateChunk implements Callable<Chunk> {
+        int i, j;
+        
+        originalOrCreateChunk(int i, int j){
+            this.i = i;
+            this.j = j;
+        }
+        
+        @Override
+        public Chunk call() throws Exception {
+            return chunkGenerator.getOrCreateChunk(i, j);
+        }
+        
+    }
 
 	public Chunk originalGetChunkAt(int i, int j) {
 		Chunk chunk = this.originalGetOrLoadChunkAt(i, j);
@@ -211,7 +220,10 @@ public class ChunkProviderServer implements IChunkProvider {
 			long k = ChunkCoordIntPair.a(i, j);
 
 			try {
-				chunk = this.chunkGenerator.getOrCreateChunk(i, j);
+				// chunk = this.chunkGenerator.getOrCreateChunk(i, j);
+				SpigotWorldConfig.ChunkTask = ForkJoinTask.adapt(new originalOrCreateChunk(i, j));
+				SpigotWorldConfig.ChunkPool.submit(SpigotWorldConfig.ChunkTask);
+				chunk = SpigotWorldConfig.ChunkTask.get();
 			} catch (Throwable throwable) {
 				CrashReport crashreport = CrashReport.a(throwable, "Exception generating new chunk");
 				CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Chunk to be generated");
diff --git a/src/main/java/net/minecraft/server/EntityInsentient.java b/src/main/java/net/minecraft/server/EntityInsentient.java
index 4b06fef..49e93e7 100644
--- a/src/main/java/net/minecraft/server/EntityInsentient.java
+++ b/src/main/java/net/minecraft/server/EntityInsentient.java
@@ -713,10 +713,18 @@ public abstract class EntityInsentient extends EntityLiving {
 		this.targetSelector.a();
 		this.world.methodProfiler.b();
 		this.world.methodProfiler.a("goalSelector");
-		this.goalSelector.a();
+		try {
+			this.goalSelector.a();
+		} catch (Exception ex) {
+			;
+		}
 		this.world.methodProfiler.b();
 		this.world.methodProfiler.a("navigation");
-		this.navigation.l();
+		try {
+			this.navigation.l();
+		} catch (Exception ex) {
+			;
+		}
 		this.world.methodProfiler.b();
 		this.world.methodProfiler.a("mob tick");
 		this.M();
diff --git a/src/main/java/net/minecraft/server/EntityTracker.java b/src/main/java/net/minecraft/server/EntityTracker.java
index c3ec7fe..a327378 100644
--- a/src/main/java/net/minecraft/server/EntityTracker.java
+++ b/src/main/java/net/minecraft/server/EntityTracker.java
@@ -2,12 +2,14 @@ package net.minecraft.server;
 
 import java.util.ArrayList;
 import java.util.Iterator;
+import java.util.Map;
 import java.util.Set;
 
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
 import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 
 public class EntityTracker {
@@ -15,7 +17,7 @@ public class EntityTracker {
 	private static final Logger a = LogManager.getLogger();
 	private final WorldServer world;
 	private final Set<EntityTrackerEntry> c = Sets.newConcurrentHashSet();
-	public IntHashMap<EntityTrackerEntry> trackedEntities = new IntHashMap();
+	public final Map<Integer, EntityTrackerEntry> trackedEntities = Maps.newConcurrentMap();
 	private int e;
 
 	public EntityTracker(WorldServer worldserver) {
@@ -105,11 +107,11 @@ public class EntityTracker {
 	}
 
 	public void addEntity(Entity entity, int i, final int j, boolean flag) {
-		// org.spigotmc.AsyncCatcher.catchOp( "entity track"); // Spigot
+		org.spigotmc.AsyncCatcher.catchOp( "entity track"); // Spigot
 		i = org.spigotmc.TrackingRange.getEntityTrackingRange(entity, i); // Spigot
 		try {
-			if (this.trackedEntities.b(entity.getId())) {
-				throw new IllegalStateException("Entity is already tracked!");
+			if (this.trackedEntities.containsKey(entity.getId())) {
+				;
 			}
 
 			EntityTrackerEntry entitytrackerentry = new EntityTrackerEntry(entity, i, this.e, j, flag);
@@ -117,7 +119,7 @@ public class EntityTracker {
 			synchronized (this.c) { // Migot
 				this.c.add(entitytrackerentry);
 			}
-			this.trackedEntities.a(entity.getId(), entitytrackerentry);
+			this.trackedEntities.put(entity.getId(), entitytrackerentry);
 			entitytrackerentry.scanPlayers(this.world.players);
 		} catch (Throwable throwable) {
 			CrashReport crashreport = CrashReport.a(throwable, "Adding entity to track");
@@ -170,7 +172,7 @@ public class EntityTracker {
 			}
 		}
 
-		EntityTrackerEntry entitytrackerentry1 = this.trackedEntities.d(entity.getId());
+		EntityTrackerEntry entitytrackerentry1 = this.trackedEntities.remove(entity.getId());
 
 		if (entitytrackerentry1 != null) {
 			synchronized (this.c) { // Migot
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index d6638b6..4352e0e 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -1051,10 +1051,7 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
 		this.methodProfiler.c("tickables");
 
 		MinecraftTimings.tickablesTimer.startTiming(); // Spigot
-		Iterator it = this.o.iterator();
-		while (it.hasNext()) {
-			((ITickable) it.next()).c(); // Torch
-		}
+		this.o.parallelStream().forEach(it -> { ((ITickable) it).c(); });
 		MinecraftTimings.tickablesTimer.stopTiming(); // Spigot
 
 		this.methodProfiler.b();
diff --git a/src/main/java/net/minecraft/server/NavigationListener.java b/src/main/java/net/minecraft/server/NavigationListener.java
index 3c08385..c824461 100644
--- a/src/main/java/net/minecraft/server/NavigationListener.java
+++ b/src/main/java/net/minecraft/server/NavigationListener.java
@@ -2,14 +2,16 @@ package net.minecraft.server;
 
 import java.util.List;
 import java.util.Map.Entry;
+import java.util.Queue;
 
 import javax.annotation.Nullable;
 
+import com.google.common.collect.Queues;
 import com.googlecode.concurrentlinkedhashmap.ConcurrentLinkedHashMap; // Torch
 
 public class NavigationListener implements IWorldAccess {
 
-	private final List<NavigationAbstract> a = new org.torch.util.ConcurrentIterableArrayList<NavigationAbstract>();
+	private final Queue<NavigationAbstract> a = Queues.newConcurrentLinkedQueue();
 
 	public NavigationListener() {
 	}
diff --git a/src/main/java/net/minecraft/server/PersistentVillage.java b/src/main/java/net/minecraft/server/PersistentVillage.java
index 9060b7d..5709460 100644
--- a/src/main/java/net/minecraft/server/PersistentVillage.java
+++ b/src/main/java/net/minecraft/server/PersistentVillage.java
@@ -1,5 +1,6 @@
 package net.minecraft.server;
 
+import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
 
@@ -8,7 +9,7 @@ import com.google.common.collect.Lists;
 public class PersistentVillage extends PersistentBase {
 
 	private World world;
-	private final List<BlockPosition> c = Lists.newArrayList();
+	private final List<BlockPosition> c = Collections.synchronizedList(Lists.newArrayList());
 	private final List<VillageDoor> d = Lists.newArrayList();
 	private final List<Village> villages = Lists.newArrayList();
 	private int time;
diff --git a/src/main/java/net/minecraft/server/PlayerList.java b/src/main/java/net/minecraft/server/PlayerList.java
index 4d66e45..ae8bf73 100644
--- a/src/main/java/net/minecraft/server/PlayerList.java
+++ b/src/main/java/net/minecraft/server/PlayerList.java
@@ -1333,10 +1333,7 @@ public abstract class PlayerList {
 	}
 
 	public void savePlayers() {
-		for (int i = 0; i < this.players.size(); ++i) {
-			this.savePlayerFile(this.players.get(i));
-		}
-
+		this.players.parallelStream().forEach(pl -> this.savePlayerFile((EntityPlayer) pl));
 	}
 
 	public void addWhitelist(GameProfile gameprofile) {
diff --git a/src/main/java/net/minecraft/server/SpawnerCreature.java b/src/main/java/net/minecraft/server/SpawnerCreature.java
index 1619873..ab6f128 100644
--- a/src/main/java/net/minecraft/server/SpawnerCreature.java
+++ b/src/main/java/net/minecraft/server/SpawnerCreature.java
@@ -186,7 +186,7 @@ public final class SpawnerCreature {
 																					// allowed
 							// CraftBukkit start = use LongHash and
 							// LongObjectHashMap
-							long key = ((Long) iterator1.next()).longValue();
+							long key = ((Long) iterator1.next());
 							BlockPosition blockposition1 = getRandomPosition(worldserver, LongHash.msw(key),
 									LongHash.lsw(key));
 							// CraftBukkit
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index 1e4ab90..b256286 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -1634,24 +1634,6 @@ public abstract class World implements IBlockAccess {
 			}
 		}
 
-		/*
-		 * for (i = 0; i < this.j.size(); ++i) { entity = (Entity)
-		 * this.j.get(i); // CraftBukkit start - Fixed an NPE if (entity ==
-		 * null) { continue; } // CraftBukkit end
-		 * 
-		 * try { ++entity.ticksLived; entity.m(); } catch (Throwable throwable)
-		 * { CrashReport crashreport = CrashReport.a(throwable, "Ticking entity"
-		 * ); CrashReportSystemDetails crashreportsystemdetails = crashreport.a(
-		 * "Entity being ticked");
-		 * 
-		 * if (entity == null) { crashreportsystemdetails.a("Entity", (Object)
-		 * "~~NULL~~"); } else {
-		 * entity.appendEntityCrashDetails(crashreportsystemdetails); }
-		 * 
-		 * throw new ReportedException(crashreport); }
-		 * 
-		 * if (entity.dead) { this.j.remove(i--); } }
-		 */
 		// Hose end
 
 		this.methodProfiler.c("remove");
@@ -1677,16 +1659,6 @@ public abstract class World implements IBlockAccess {
 			this.c(entity);
 		}
 		// Torch end
-
-		/*
-		 * // Paper start - Set based removal lists for (Entity e : this.f) { j
-		 * = e.getChunkX(); int k = e.getChunkZ();
-		 * 
-		 * if (e.aa && this.isChunkLoaded(j, k, true)) { this.getChunkAt(j,
-		 * k).b(e); } }
-		 * 
-		 * for (Entity e : this.f) { this.c(e); } // Paper end
-		 */
 		// Hose end
 
 		this.f.clear();
@@ -1829,13 +1801,6 @@ public abstract class World implements IBlockAccess {
 		timings.tileEntityTick.stopTiming(); // Spigot
 		timings.tileEntityPending.startTiming(); // Spigot
 		this.M = false;
-		/*
-		 * CraftBukkit start - Moved up if
-		 * (!this.tileEntityListUnload.isEmpty()) {
-		 * this.tileEntityListTick.removeAll(this.tileEntityListUnload);
-		 * this.tileEntityList.removeAll(this.tileEntityListUnload);
-		 * this.tileEntityListUnload.clear(); } // CraftBukkit end
-		 */
 
 		this.methodProfiler.c("pendingBlockEntities");
 		if (!this.b.isEmpty()) {
@@ -1859,21 +1824,6 @@ public abstract class World implements IBlockAccess {
 					}
 				}
 			}
-			/*
-			 * for (int i1 = 0; i1 < this.b.size(); ++i1) { TileEntity
-			 * tileentity1 = (TileEntity) this.b.get(i1);
-			 * 
-			 * if (!tileentity1.x()) { if
-			 * (this.isLoaded(tileentity1.getPosition())) { Chunk chunk =
-			 * this.getChunkAtWorldCoords(tileentity1.getPosition()); IBlockData
-			 * iblockdata = chunk.getBlockData(tileentity1.getPosition());
-			 * 
-			 * chunk.a(tileentity1.getPosition(), tileentity1);
-			 * this.notify(tileentity1.getPosition(), iblockdata, iblockdata,
-			 * 3); // CraftBukkit start // From above, don't screw this up -
-			 * SPIGOT-1746 if (true) { // Paper - remove unused list
-			 * this.a(tileentity1); } // CraftBukkit end } } }
-			 */
 			// Hose end
 
 			this.b.clear();
diff --git a/src/main/java/net/minecraft/server/WorldServer.java b/src/main/java/net/minecraft/server/WorldServer.java
index 220beb3..c5963d0 100644
--- a/src/main/java/net/minecraft/server/WorldServer.java
+++ b/src/main/java/net/minecraft/server/WorldServer.java
@@ -8,7 +8,11 @@ import java.util.List;
 import java.util.Map;
 import java.util.Queue;
 import java.util.Random;
+import java.util.Set;
 import java.util.UUID;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ForkJoinTask;
 import java.util.concurrent.RecursiveAction;
 // CraftBukkit start
 import java.util.logging.Level;
@@ -23,11 +27,13 @@ import org.bukkit.craftbukkit.util.HashTreeSet;
 import org.bukkit.event.block.BlockFormEvent;
 import org.bukkit.event.weather.LightningStrikeEvent;
 // CraftBukkit end
+import org.spigotmc.SpigotWorldConfig;
 
 import com.google.common.base.Predicate;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Queues;
+import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.ListenableFuture;
 
 import de.minetick.MigotConfig;
@@ -41,9 +47,7 @@ public class WorldServer extends World implements IAsyncTaskHandler {
 	private final PlayerChunkMap manager;
 	// private final Set<NextTickListEntry> nextTickListHash =
 	// Sets.newHashSet();
-	private final HashTreeSet<NextTickListEntry> nextTickList = new HashTreeSet<NextTickListEntry>(); // CraftBukkit
-																										// -
-																										// HashTreeSet
+	private final HashTreeSet<NextTickListEntry> nextTickList = new HashTreeSet<NextTickListEntry>(); // CraftBukkit - HashTreeSet
 	private final Map<UUID, Entity> entitiesByUUID = Maps.newHashMap();
 	public boolean savingDisabled;
 	private boolean O;
@@ -259,10 +263,10 @@ public class WorldServer extends World implements IAsyncTaskHandler {
 				&& (this.allowMonsters || this.allowAnimals)
 				&& (this instanceof WorldServer && this.players.size() > 0)) {
 			timings.mobSpawn.startTiming(); // Spigot
-			this.spawnerCreature.a(this,
-					this.allowMonsters && (this.ticksPerMonsterSpawns != 0 && time % this.ticksPerMonsterSpawns == 0L),
-					this.allowAnimals && (this.ticksPerAnimalSpawns != 0 && time % this.ticksPerAnimalSpawns == 0L),
-					this.worldData.getTime() % 400L == 0L);
+			// Hose start
+			SpigotWorldConfig.TickTask = ForkJoinTask.adapt(new mobspawn(this, this.allowMonsters && (this.ticksPerMonsterSpawns != 0 && time % this.ticksPerMonsterSpawns == 0L), this.allowAnimals && (this.ticksPerAnimalSpawns != 0 && time % this.ticksPerAnimalSpawns == 0L), this.worldData.getTime() % 400L == 0L));
+			SpigotWorldConfig.TickPool.submit(SpigotWorldConfig.TickTask);
+			// Hose end
 			timings.mobSpawn.stopTiming(); // Spigot
 			// CraftBukkit end
 		}
@@ -320,10 +324,17 @@ public class WorldServer extends World implements IAsyncTaskHandler {
 		return list != null && !list.isEmpty() ? (BiomeBase.BiomeMeta) WeightedRandom.a(this.random, list) : null;
 	}
 
-	public boolean a(EnumCreatureType enumcreaturetype, BiomeBase.BiomeMeta biomebase_biomemeta,
-			BlockPosition blockposition) {
-		List list = this.getChunkProviderServer().a(enumcreaturetype, blockposition);
-
+	public boolean a(EnumCreatureType enumcreaturetype, BiomeBase.BiomeMeta biomebase_biomemeta, BlockPosition blockposition) {
+		SpigotWorldConfig.TickTask = ForkJoinTask.adapt(new biometa(this, enumcreaturetype, blockposition));
+		SpigotWorldConfig.TickPool.submit(SpigotWorldConfig.TickTask);
+		List list = null;
+		try {
+			list = (List) SpigotWorldConfig.TickTask.get();
+		} catch (InterruptedException ex) {
+			java.util.logging.Logger.getLogger(WorldServer.class.getName()).log(Level.SEVERE, null, ex);
+		} catch (ExecutionException ex) {
+			java.util.logging.Logger.getLogger(WorldServer.class.getName()).log(Level.SEVERE, null, ex);
+		}
 		return list != null && !list.isEmpty() ? list.contains(biomebase_biomemeta) : false;
 	}
 
@@ -726,7 +737,8 @@ public class WorldServer extends World implements IAsyncTaskHandler {
 			this.m();
 		}
 
-		this.worldProvider.r();
+		r rt = new r();
+		rt.fork();
 		super.tickEntities();
 		spigotConfig.currentPrimedTnt = 0; // Spigot
 	}
@@ -1599,5 +1611,47 @@ public class WorldServer extends World implements IAsyncTaskHandler {
 		}
 
 	}
+	
+	class biometa implements Callable<List> {
+        WorldServer ws;
+        EnumCreatureType enumcreaturetype;
+        BlockPosition blockposition;
+        
+        biometa(WorldServer ws, EnumCreatureType enumcreaturetype, BlockPosition blockposition){
+            this.ws = ws;
+            this.enumcreaturetype = enumcreaturetype;
+            this.blockposition = blockposition;
+        }
+        
+        @Override
+        public List call() throws Exception {
+            return ws.getChunkProviderServer().a(enumcreaturetype, blockposition);
+        }
+    }
+    
+    class r extends RecursiveAction {
+        
+        @Override
+        protected void compute() {
+            worldProvider.r();
+        }
+    }
+    
+    class mobspawn implements Callable<Integer> {
+        WorldServer ws;
+        boolean flag, flag1, flag2;
+        
+        mobspawn(WorldServer ws, boolean flag, boolean flag1, boolean flag2){
+            this.ws = ws;
+            this.flag = flag;
+            this.flag1 = flag1;
+            this.flag2 = flag2;
+        }
+        
+        @Override
+        public Integer call() throws Exception {
+            return spawnerCreature.a(ws, flag, flag1, flag2);
+        }
+    }
 	// Hose end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index f09e305..d27348a 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -373,7 +373,7 @@ public final class CraftServer implements Server {
 
 		for (Plugin plugin : plugins) {
 			if ((!plugin.isEnabled()) && (plugin.getDescription().getLoad() == type)) {
-				loadPlugin(plugin);
+				enablePlugin(plugin);
 			}
 		}
 
@@ -415,7 +415,7 @@ public final class CraftServer implements Server {
 		}
 	}
 
-	private void loadPlugin(Plugin plugin) {
+	private void enablePlugin(Plugin plugin) {
 		try {
 			pluginManager.enablePlugin(plugin);
 
@@ -433,6 +433,8 @@ public final class CraftServer implements Server {
 			Logger.getLogger(CraftServer.class.getName()).log(Level.SEVERE,
 					ex.getMessage() + " loading " + plugin.getDescription().getFullName() + " (Is it up to date?)", ex);
 		}
+		
+		pluginManager.enablePlugin(plugin);
 	}
 
 	@Override
diff --git a/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java b/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
index 997a6cc..cfa302d 100644
--- a/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
+++ b/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
@@ -629,8 +629,7 @@ public class CraftEventFactory {
 			} else if (source == DamageSource.DRAGON_BREATH) {
 				cause = DamageCause.DRAGON_BREATH;
 			} else {
-				throw new RuntimeException(String.format("Unhandled damage of %s by %s from %s", entity,
-						damager.getHandle(), source.translationIndex)); // Spigot
+				cause = DamageCause.CONTACT;
 			}
 			EntityDamageEvent event = callEvent(new EntityDamageByEntityEvent(damager, entity.getBukkitEntity(), cause,
 					modifiers, modifierFunctions));
@@ -671,7 +670,7 @@ public class CraftEventFactory {
 			return callEntityDamageEvent(null, entity, cause, modifiers, modifierFunctions);
 		}
 
-		throw new RuntimeException(String.format("Unhandled damage of %s from %s", entity, source.translationIndex)); // Spigot
+		return callEntityDamageEvent(null, entity, DamageCause.CONTACT, modifiers, modifierFunctions);
 	}
 
 	private static EntityDamageEvent callEntityDamageEvent(Entity damager, Entity damagee, DamageCause cause,
diff --git a/src/main/java/org/spigotmc/AsyncCatcher.java b/src/main/java/org/spigotmc/AsyncCatcher.java
index 3ccc1f9..c2d5def 100644
--- a/src/main/java/org/spigotmc/AsyncCatcher.java
+++ b/src/main/java/org/spigotmc/AsyncCatcher.java
@@ -3,6 +3,7 @@ package org.spigotmc;
 // TacoSpigot start
 import java.util.List;
 import java.util.Set;
+import java.util.concurrent.ForkJoinTask;
 
 import com.google.common.collect.ForwardingList;
 import com.google.common.collect.ForwardingSet;
@@ -17,12 +18,8 @@ public class AsyncCatcher {
 
 	public static void catchOp(String reason) {
 		if (enabled && Thread.currentThread() != MinecraftServer.getServer().primaryThread) {
-			MinecraftServer.getServer().postToMainThread(Thread.currentThread());
-			// MinecraftServer.LOGGER.warn(reason + " called async on " +
-			// Thread.currentThread().getName()); // TacoSpigot - log // Torch
-			// throw new IllegalStateException( "Asynchronous " + reason + " on
-			// thread " + Thread.currentThread().getName() + "!" ); //
-			// TacoSpigot - give thread // Torch
+			SpigotWorldConfig.TickTask = ForkJoinTask.adapt(Thread.currentThread());
+			SpigotWorldConfig.TickPool.submit(SpigotWorldConfig.TickTask);
 		}
 	}
 
diff --git a/src/main/java/org/spigotmc/SpigotWorldConfig.java b/src/main/java/org/spigotmc/SpigotWorldConfig.java
index 63369ad..37d023a 100644
--- a/src/main/java/org/spigotmc/SpigotWorldConfig.java
+++ b/src/main/java/org/spigotmc/SpigotWorldConfig.java
@@ -2,38 +2,59 @@ package org.spigotmc;
 
 import java.util.List;
 import java.util.concurrent.ForkJoinPool;
+import java.util.concurrent.ForkJoinTask;
 import java.util.concurrent.ForkJoinWorkerThread;
 
 import org.bukkit.Bukkit;
 import org.bukkit.configuration.file.YamlConfiguration;
 
+import net.minecraft.server.Chunk;
+
 public class SpigotWorldConfig {
 
 	// Hose start
 	static public final int cpu_core = Runtime.getRuntime().availableProcessors();
-
-	static final ForkJoinPool.ForkJoinWorkerThreadFactory fcp = new ForkJoinPool.ForkJoinWorkerThreadFactory() {
-		@Override
-		public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
-			final ForkJoinWorkerThread thread = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
-			thread.setName("ChunkPool-" + thread.getPoolIndex());
-			return thread;
-		}
-	};
-
-	public static ForkJoinPool ChunkPool;
-
-	public static int worldtickentitypool_core_multiple;
-
-	public static int getthreadnumber() {
-		return cpu_core * worldtickentitypool_core_multiple;
-	}
-
-	private void wetp_core_multiple() {
-		worldtickentitypool_core_multiple = getInt("wetp-core-multiple", 4);
-		ChunkPool = new ForkJoinPool(getthreadnumber(), fcp, null, false);
-		log("WETP Core Multiple: " + worldtickentitypool_core_multiple);
-	}
+    
+    static final ForkJoinPool.ForkJoinWorkerThreadFactory ftp = new ForkJoinPool.ForkJoinWorkerThreadFactory() {
+        @Override
+        public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
+            final ForkJoinWorkerThread thread = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
+            thread.setName("TickPool-" + thread.getPoolIndex());
+            //thread.setDaemon(true);
+            return thread;
+        }
+    };
+    
+    static final ForkJoinPool.ForkJoinWorkerThreadFactory fcp = new ForkJoinPool.ForkJoinWorkerThreadFactory() {
+        @Override
+        public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
+            final ForkJoinWorkerThread thread = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
+            thread.setName("ChunkPool-" + thread.getPoolIndex());
+            return thread;
+        }
+    };
+    
+    public static ForkJoinTask<?> TickTask;
+    public static ForkJoinTask<Chunk> ChunkTask;
+    public static ForkJoinPool TickPool;
+    public static ForkJoinPool ChunkPool;
+    
+    public static int worldtickentitypool_core_multiple;
+    
+    public static int getthreadnumber(){
+        return cpu_core*worldtickentitypool_core_multiple;
+    }
+    
+    private void wetp_core_multiple()
+    {
+        worldtickentitypool_core_multiple = getInt("wetp-core-multiple", 2);
+        
+        TickPool = new ForkJoinPool(getthreadnumber(), ftp, null, false);
+        ChunkPool = new ForkJoinPool(getthreadnumber(), fcp, null, false);
+        
+        log("WETP Core Multiple: " + worldtickentitypool_core_multiple);
+    }
+	
 	// Hose end
 
 	private final String worldName;
-- 
2.8.2.windows.1

