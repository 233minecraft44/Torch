From 7f9dc9f8d2f03b81d103d702016df4028cdc3eae Mon Sep 17 00:00:00 2001
From: SotrForgotten <i@omc.hk>
Date: Fri, 26 Aug 2016 11:57:45 +0800
Subject: [PATCH] Improve MP


diff --git a/src/main/java/co/aikar/timings/TimingHandler.java b/src/main/java/co/aikar/timings/TimingHandler.java
index 85ece22..b644570 100644
--- a/src/main/java/co/aikar/timings/TimingHandler.java
+++ b/src/main/java/co/aikar/timings/TimingHandler.java
@@ -110,7 +110,8 @@ class TimingHandler implements Timing {
 	public void stopTiming() {
 		if (enabled && --timingDepth == 0 && start != 0) {
 			if (!Bukkit.isPrimaryThread()) {
-				// Bukkit.getLogger().log(Level.SEVERE, "Timing issue occour in" + name + ", please report it to Torch!");
+				// Bukkit.getLogger().log(Level.SEVERE, "Timing issue occour in"
+				// + name + ", please report it to Torch!");
 				// new Throwable().printStackTrace();
 				synchronized (this) {
 					addDiff(System.nanoTime() - start);
@@ -141,7 +142,9 @@ class TimingHandler implements Timing {
 		if (!added) {
 			added = true;
 			timed = true;
-			synchronized(this) { TimingsManager.HANDLERS.add(this); }
+			synchronized (this) {
+				TimingsManager.HANDLERS.add(this);
+			}
 		}
 		if (groupHandler != null) {
 			groupHandler.addDiff(diff);
diff --git a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
index c9bc5ab..6f2b45c 100644
--- a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
+++ b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
@@ -452,26 +452,27 @@ public class PaperWorldConfig {
 	}
 
 	public boolean antiXray;
-    public boolean asynchronous;
-    public int engineMode;
-    public int neighborsMode;
-    public int maxChunkY;
-    public List<Object> hiddenBlocks;
-    public List<Object> replaceBlocks;
-    private void antiXray() {
-        antiXray = getBoolean("anti-xray.enabled", false);
-        asynchronous = getBoolean("anti-xray.asynchronous", false);
-        engineMode = getInt("anti-xray.engine-mode", 3);
-        neighborsMode = getInt("anti-xray.neighbors-mode", 1);
-        maxChunkY = getInt("anti-xray.max-chunk-y", 3);
-        hiddenBlocks = getList("anti-xray.hide-blocks", Arrays.asList(new Object[] {
-            "gold_ore", "iron_ore", "coal_ore", "lapis_ore", "mossy_cobblestone", "obsidian", "chest", "diamond_ore", "redstone_ore", "lit_redstone_ore", "clay", "emerald_ore", "ender_chest"
-        }));
-        replaceBlocks = getList("anti-xray.replace-blocks", Arrays.asList(new Object[] {
-            "stone", "planks"
-        }));
-        log("Anti-Xray: " + (antiXray ? "enabled" : "disabled") + " / Engine Mode: " + engineMode + " / Neighbors Mode: " + neighborsMode + " / Obfuscating up to " + ((maxChunkY + 1) * 16) + " blocks");
-    }
+	public boolean asynchronous;
+	public int engineMode;
+	public int neighborsMode;
+	public int maxChunkY;
+	public List<Object> hiddenBlocks;
+	public List<Object> replaceBlocks;
+
+	private void antiXray() {
+		antiXray = getBoolean("anti-xray.enabled", false);
+		asynchronous = getBoolean("anti-xray.asynchronous", false);
+		engineMode = getInt("anti-xray.engine-mode", 3);
+		neighborsMode = getInt("anti-xray.neighbors-mode", 1);
+		maxChunkY = getInt("anti-xray.max-chunk-y", 3);
+		hiddenBlocks = getList("anti-xray.hide-blocks",
+				Arrays.asList(new Object[] { "gold_ore", "iron_ore", "coal_ore", "lapis_ore", "mossy_cobblestone",
+						"obsidian", "chest", "diamond_ore", "redstone_ore", "lit_redstone_ore", "clay", "emerald_ore",
+						"ender_chest" }));
+		replaceBlocks = getList("anti-xray.replace-blocks", Arrays.asList(new Object[] { "stone", "planks" }));
+		log("Anti-Xray: " + (antiXray ? "enabled" : "disabled") + " / Engine Mode: " + engineMode
+				+ " / Neighbors Mode: " + neighborsMode + " / Obfuscating up to " + ((maxChunkY + 1) * 16) + " blocks");
+	}
 
 	public boolean isHopperPushBased;
 
diff --git a/src/main/java/com/destroystokyo/paper/antixray/BlockPacketController.java b/src/main/java/com/destroystokyo/paper/antixray/BlockPacketController.java
index 8a0f154..f7b053b 100644
--- a/src/main/java/com/destroystokyo/paper/antixray/BlockPacketController.java
+++ b/src/main/java/com/destroystokyo/paper/antixray/BlockPacketController.java
@@ -10,143 +10,187 @@ import net.minecraft.server.PacketDataSerializer;
 import net.minecraft.server.World;
 
 /**
- * BlockPacketController is the default (vanilla) implementation of the interface IBlockPacketController.
- * The singleton instance should be used.
+ * BlockPacketController is the default (vanilla) implementation of the
+ * interface IBlockPacketController. The singleton instance should be used.
  */
 public class BlockPacketController implements IBlockPacketController {
 
-    private static BlockPacketController instance = null;
-    private final Lock noOpLock;
+	private static BlockPacketController instance = null;
+	private final Lock noOpLock;
 
-    /**
-     * Protected constructor for invocation by subclass constructors.
-     * Direct invocation is prevented because of the singleton pattern.
-     */
-    protected BlockPacketController() {
-        noOpLock = Lock.getNoOpInstance();
-    }
+	/**
+	 * Protected constructor for invocation by subclass constructors. Direct
+	 * invocation is prevented because of the singleton pattern.
+	 */
+	protected BlockPacketController() {
+		noOpLock = Lock.getNoOpInstance();
+	}
 
-    /**
-     * Protected constructor for invocation by subclass constructors.
-     * Direct invocation is prevented because of the singleton pattern.
-     * Use this constructor to prevent unnecessary intantiation of the Lock singleton
-     * incase of overriding getChunkBlocksLock(Chunk chunk) and getChunkDataLock(Chunk chunk).
-     *
-     * @param lock The lock instance used by this instance
-     */
-    protected BlockPacketController(Lock lock) {
-        noOpLock = lock;
-    }
+	/**
+	 * Protected constructor for invocation by subclass constructors. Direct
+	 * invocation is prevented because of the singleton pattern. Use this
+	 * constructor to prevent unnecessary intantiation of the Lock singleton
+	 * incase of overriding getChunkBlocksLock(Chunk chunk) and
+	 * getChunkDataLock(Chunk chunk).
+	 *
+	 * @param lock
+	 *            The lock instance used by this instance
+	 */
+	protected BlockPacketController(Lock lock) {
+		noOpLock = lock;
+	}
 
-    /**
-     * Thread-safe (synchronized) singleton getter.
-     *
-     * @return The singleton instance of this implementation of IBlockPacketController
-     */
-    public static synchronized BlockPacketController getInstance() {
-        if (instance == null) {
-            instance = new BlockPacketController();
-        }
+	/**
+	 * Thread-safe (synchronized) singleton getter.
+	 *
+	 * @return The singleton instance of this implementation of
+	 *         IBlockPacketController
+	 */
+	public static synchronized BlockPacketController getInstance() {
+		if (instance == null) {
+			instance = new BlockPacketController();
+		}
 
-        return instance;
-    }
+		return instance;
+	}
 
-    /**
-     * Returns an instance of a Lock implementation used by the specified chunk to lock blocks or chunk sections from modification.
-     * This implementation returns the singleton Lock.getNoOpInstance().
-     *
-     * @param chunk The chunk which needs the lock
-     * @return The singleton Lock.getNoOpInstance()
-     */
-    @Override
-    public Lock getChunkBlocksLock(Chunk chunk) {
-        return noOpLock;
-    }
+	/**
+	 * Returns an instance of a Lock implementation used by the specified chunk
+	 * to lock blocks or chunk sections from modification. This implementation
+	 * returns the singleton Lock.getNoOpInstance().
+	 *
+	 * @param chunk
+	 *            The chunk which needs the lock
+	 * @return The singleton Lock.getNoOpInstance()
+	 */
+	@Override
+	public Lock getChunkBlocksLock(Chunk chunk) {
+		return noOpLock;
+	}
 
-    /**
-     * Returns an instance of a Lock implementation used by the specified chunk to lock chunk data (everything that is needed to create the packet) from modification.
-     * This implementation returns the singleton Lock.getNoOpInstance().
-     *
-     * @param chunk The chunk which needs the lock
-     * @return The singleton Lock.getNoOpInstance()
-     */
-    @Override
-    public Lock getChunkDataLock(Chunk chunk) {
-        return noOpLock;
-    }
+	/**
+	 * Returns an instance of a Lock implementation used by the specified chunk
+	 * to lock chunk data (everything that is needed to create the packet) from
+	 * modification. This implementation returns the singleton
+	 * Lock.getNoOpInstance().
+	 *
+	 * @param chunk
+	 *            The chunk which needs the lock
+	 * @return The singleton Lock.getNoOpInstance()
+	 */
+	@Override
+	public Lock getChunkDataLock(Chunk chunk) {
+		return noOpLock;
+	}
 
-    /**
-     * Called when a new chunk section is created.
-     * Returns an array of predefined block data for the DataPaletteBlock of the specified chunk section or null if there is no block data.
-     * This implementation does nothing and will always return null.
-     *
-     * @param chunk The chunk which contains the chunk section
-     * @param chunkY The y-coordinate of the chunk section from 0 to 15
-     * @return null
-     */
-    @Override
-    public IBlockData[] getPredefinedBlockData(Chunk chunk, int chunkY) {
-        return null;
-    }
+	/**
+	 * Called when a new chunk section is created. Returns an array of
+	 * predefined block data for the DataPaletteBlock of the specified chunk
+	 * section or null if there is no block data. This implementation does
+	 * nothing and will always return null.
+	 *
+	 * @param chunk
+	 *            The chunk which contains the chunk section
+	 * @param chunkY
+	 *            The y-coordinate of the chunk section from 0 to 15
+	 * @return null
+	 */
+	@Override
+	public IBlockData[] getPredefinedBlockData(Chunk chunk, int chunkY) {
+		return null;
+	}
 
-    /**
-     * Called before the server attempts to create and send a PacketPlayOutMapChunk for the specified chunk (not for chunk updates).
-     * Returns false if and only if the packet should not be created now.
-     * In this case the chunk remains in the PlayerChunkMap and this method is called again later until this method returns true or the chunk is unloaded.
-     * This implementation does nothing and will always return true.
-     *
-     * @param chunk The chunk which the packet is created for
-     * @param chunkSectionSelector The chunk sections which should be sent (each bit represents for one chunk section, the LSB represents the lowest chunk section, 0 = don't send, 1 = send)
-     * @return true
-     */
-    @Override
-    public boolean onPacketCreate(Chunk chunk, int chunkSectionSelector) {
-        return true;
-    }
+	/**
+	 * Called before the server attempts to create and send a
+	 * PacketPlayOutMapChunk for the specified chunk (not for chunk updates).
+	 * Returns false if and only if the packet should not be created now. In
+	 * this case the chunk remains in the PlayerChunkMap and this method is
+	 * called again later until this method returns true or the chunk is
+	 * unloaded. This implementation does nothing and will always return true.
+	 *
+	 * @param chunk
+	 *            The chunk which the packet is created for
+	 * @param chunkSectionSelector
+	 *            The chunk sections which should be sent (each bit represents
+	 *            for one chunk section, the LSB represents the lowest chunk
+	 *            section, 0 = don't send, 1 = send)
+	 * @return true
+	 */
+	@Override
+	public boolean onPacketCreate(Chunk chunk, int chunkSectionSelector) {
+		return true;
+	}
 
-    /**
-     * Called when packetPlayOutMapChunk is created and the data of chunk should be written to packetDataSerializer.
-     * This method is called instead of packetPlayOutMapChunk.a(packetDataSerializer, chunk, writeSkyLightArray, chunkSectionSelector, nearbyChunks).
-     * This implementation is equal to the vanilla code.
-     *
-     * @param packetPlayOutMapChunk The packet which is created
-     * @param packetDataSerializer The data serializer of the specified packet
-     * @param chunk The chunk which the packet is created for and should be written to the data serializer
-     * @param writeSkyLightArray Whether or not the sky light array should be written to the data serializer
-     * @param chunkSectionSelector The chunk sections which should be sent (each bit represents for one chunk section, the LSB represents the lowest chunk section, 0 = don't send, 1 = send)
-     */
-    @Override
-    public void createPacket(PacketPlayOutMapChunk packetPlayOutMapChunk, PacketDataSerializer packetDataSerializer, Chunk chunk, boolean writeSkyLightArray, int chunkSectionSelector) {
-        packetPlayOutMapChunk.setWrittenChunkSections(packetPlayOutMapChunk.a(packetDataSerializer, chunk, writeSkyLightArray, chunkSectionSelector, null));
-        packetPlayOutMapChunk.setReady(true);
-    }
+	/**
+	 * Called when packetPlayOutMapChunk is created and the data of chunk should
+	 * be written to packetDataSerializer. This method is called instead of
+	 * packetPlayOutMapChunk.a(packetDataSerializer, chunk, writeSkyLightArray,
+	 * chunkSectionSelector, nearbyChunks). This implementation is equal to the
+	 * vanilla code.
+	 *
+	 * @param packetPlayOutMapChunk
+	 *            The packet which is created
+	 * @param packetDataSerializer
+	 *            The data serializer of the specified packet
+	 * @param chunk
+	 *            The chunk which the packet is created for and should be
+	 *            written to the data serializer
+	 * @param writeSkyLightArray
+	 *            Whether or not the sky light array should be written to the
+	 *            data serializer
+	 * @param chunkSectionSelector
+	 *            The chunk sections which should be sent (each bit represents
+	 *            for one chunk section, the LSB represents the lowest chunk
+	 *            section, 0 = don't send, 1 = send)
+	 */
+	@Override
+	public void createPacket(PacketPlayOutMapChunk packetPlayOutMapChunk, PacketDataSerializer packetDataSerializer,
+			Chunk chunk, boolean writeSkyLightArray, int chunkSectionSelector) {
+		packetPlayOutMapChunk.setWrittenChunkSections(
+				packetPlayOutMapChunk.a(packetDataSerializer, chunk, writeSkyLightArray, chunkSectionSelector, null));
+		packetPlayOutMapChunk.setReady(true);
+	}
 
-    /**
-     * Called when a PacketPlayOutMapChunk is created and the blocks of the specified chunk section should be written to packetDataSerializer.
-     * This method is called instead of packetDataSerializer.a(dataBits.a()).
-     * This implementation is equal to the vanilla code.
-     *
-     * @param packetDataSerializer The data serializer of the created packet
-     * @param chunk The chunk which the packet is created for and contains the chunk section
-     * @param chunkY The y-coordinate of the chunk section from 0 to 15
-     * @param dataPaletteBlock The data palette for the blocks of the specified chunk section
-     * @param dataBits The dataBits of the blocks
-     * @param nearbyChunks An array with the length of 4 containing the chunks around the specified chunk or null if not loaded used for thread-safe chunk access (index 0 = x--, 1 = x++, 2 = z--, 3 = z++)
-     */
-    @Override
-    public void writeBlocks(PacketDataSerializer packetDataSerializer, Chunk chunk, int chunkY, DataPaletteBlock dataPaletteBlock, DataBits dataBits, Chunk[] nearbyChunks) {
-        packetDataSerializer.a(dataBits.a());
-    }
+	/**
+	 * Called when a PacketPlayOutMapChunk is created and the blocks of the
+	 * specified chunk section should be written to packetDataSerializer. This
+	 * method is called instead of packetDataSerializer.a(dataBits.a()). This
+	 * implementation is equal to the vanilla code.
+	 *
+	 * @param packetDataSerializer
+	 *            The data serializer of the created packet
+	 * @param chunk
+	 *            The chunk which the packet is created for and contains the
+	 *            chunk section
+	 * @param chunkY
+	 *            The y-coordinate of the chunk section from 0 to 15
+	 * @param dataPaletteBlock
+	 *            The data palette for the blocks of the specified chunk section
+	 * @param dataBits
+	 *            The dataBits of the blocks
+	 * @param nearbyChunks
+	 *            An array with the length of 4 containing the chunks around the
+	 *            specified chunk or null if not loaded used for thread-safe
+	 *            chunk access (index 0 = x--, 1 = x++, 2 = z--, 3 = z++)
+	 */
+	@Override
+	public void writeBlocks(PacketDataSerializer packetDataSerializer, Chunk chunk, int chunkY,
+			DataPaletteBlock dataPaletteBlock, DataBits dataBits, Chunk[] nearbyChunks) {
+		packetDataSerializer.a(dataBits.a());
+	}
 
-    /**
-     * Called when the block at the specified block position in the specified world changes and nearby blocks become visible for players.
-     * This implementation does nothing.
-     *
-     * @param world The world of the changed block
-     * @param blockPosition The block position of the changed block
-     */
-    @Override
-    public void updateNearbyBlocks(World world, BlockPosition blockPosition) {
+	/**
+	 * Called when the block at the specified block position in the specified
+	 * world changes and nearby blocks become visible for players. This
+	 * implementation does nothing.
+	 *
+	 * @param world
+	 *            The world of the changed block
+	 * @param blockPosition
+	 *            The block position of the changed block
+	 */
+	@Override
+	public void updateNearbyBlocks(World world, BlockPosition blockPosition) {
 
-    }
+	}
 }
\ No newline at end of file
diff --git a/src/main/java/com/destroystokyo/paper/antixray/BlockPacketControllerObfuscate.java b/src/main/java/com/destroystokyo/paper/antixray/BlockPacketControllerObfuscate.java
index 49a56c5..be67848 100644
--- a/src/main/java/com/destroystokyo/paper/antixray/BlockPacketControllerObfuscate.java
+++ b/src/main/java/com/destroystokyo/paper/antixray/BlockPacketControllerObfuscate.java
@@ -19,368 +19,453 @@ import net.minecraft.server.PacketPlayOutMapChunk;
 import net.minecraft.server.PacketDataSerializer;
 import net.minecraft.server.World;
 
- /**
-  * BlockPacketControllerObfuscate is an implementation of the interface IBlockPacketController which aims to obfuscate blocks which are sent with chunk packets.
-  */
- public class BlockPacketControllerObfuscate implements IBlockPacketController {
- 
-    private static ExecutorService executorServiceInstance = null;
-    protected ExecutorService executorService = null;
-    protected Lock noOpLock = null;
-    protected boolean asynchronous = true;
-    protected int engineMode = 3;
-    protected int neighborsMode = 1;
-    protected int maxChunkY = 3;
-    protected final boolean[] obfuscateBlocks = new boolean[Short.MAX_VALUE];
-    protected IBlockData[] replacementOres = null;
-
-    /**
-     * Protected constructor for invocation by subclass constructors.
-     * Use this constructor to prevent unnecessary intantiation of the Lock and ExecutorService singletons
-     * incase of overriding for example getChunkBlocksLock(Chunk chunk) and getChunkDataLock(Chunk chunk).
-     */
-    protected BlockPacketControllerObfuscate() {
-
-    }
-
-    /**
-     * Public (normal) constructor.
-     *
-     * @param config The config for for this instance
-     */
-    public BlockPacketControllerObfuscate(PaperWorldConfig config) {
-        asynchronous = config.asynchronous;
-        engineMode = config.engineMode;
-        neighborsMode = config.neighborsMode;
-        maxChunkY = config.maxChunkY;
-
-        if (asynchronous) {
-            executorService = getExecutorServiceInstance();
-        } else {
-            noOpLock = Lock.getNoOpInstance();
-        }
-
-        for (Object id : (engineMode == 1) ? config.hiddenBlocks : config.replaceBlocks) {
-            Block block = Block.getByName(String.valueOf(id));
-
-            if (block != null) {
-                int intId = Block.getId(block);
-                obfuscateBlocks[intId] = true;
-            }
-        }
-
-        Set<IBlockData> replacementOreList = new HashSet<IBlockData>();
-
-        for (Object id : config.hiddenBlocks) {
-            Block block = Block.getByName(String.valueOf(id));
-
-            if (block != null && !block.isTileEntity()) {
-                replacementOreList.add(block.getBlockData());
-            }
-        }
-
-        replacementOres = replacementOreList.toArray(new IBlockData[replacementOreList.size()]);
-    }
-
-    /**
-     * Thread-safe (synchronized) singleton getter.
-     *
-     * @return The singleton instance of the executor service (Executors.newSingleThreadExecutor())
-     */
-    public static synchronized ExecutorService getExecutorServiceInstance() {
-        if (executorServiceInstance == null) {
-            executorServiceInstance = Executors.newSingleThreadExecutor();
-        }
-
-        return executorServiceInstance;
-    }
-
-    /**
-     * Returns an instance of a Lock implementation used by the specified chunk to lock blocks or chunk sections from modification.
-     * This implementation returns a new instance of Lock in asynchronous mode and the singleton Lock.getNoOpInstance() else.
-     *
-     * @param chunk The chunk which needs the lock
-     * @return An instance of a Lock implementation
-     */
-    @Override
-    public Lock getChunkBlocksLock(Chunk chunk) {
-        return asynchronous ? new Lock() : noOpLock;
-    }
-
-    /**
-     * Returns an instance of a Lock implementation used by the specified chunk to lock chunk data (everything that is needed to create the packet) from modification.
-     * This implementation returns a new instance of Lock in asynchronous mode and the singleton Lock.getNoOpInstance() else.
-     *
-     * @param chunk The chunk which needs the lock
-     * @return An instance of a Lock implementation
-     */
-    @Override
-    public Lock getChunkDataLock(Chunk chunk) {
-        return asynchronous ? new Lock() : noOpLock;
-    }
-
-    /**
-     * Called when a new chunk section is created.
-     * Returns an array of predefined block data for the DataPaletteBlock of the specified chunk section or null if there is no block data.
-     * This implementation returns the blocks which are used to obfuscate the original blocks.
-     *
-     * @param chunk The chunk which contains the chunk section
-     * @param chunkY The y-coordinate of the chunk section from 0 to 15
-     * @return The array of predefined block data or null
-     */
-    @Override
-    public IBlockData[] getPredefinedBlockData(Chunk chunk, int chunkY) {
-        if (chunkY <= maxChunkY) {
-            switch (engineMode) {
-                case 1:
-                    switch (chunk.world.getWorld().getEnvironment()) {
-                        case NETHER:
-                            return new IBlockData[] {Blocks.NETHERRACK.getBlockData()};
-                        case THE_END:
-                            return new IBlockData[] {Blocks.END_STONE.getBlockData()};
-                        default:
-                            return new IBlockData[] {Blocks.STONE.getBlockData()};
-                    }
-                case 2:
-                case 3:
-                    return replacementOres;
-            }
-        }
-
-        return null;
-    }
-
-    /**
-     * Called before the server attempts to create and send a PacketPlayOutMapChunk for the specified chunk (not for chunk updates).
-     * Returns false if and only if the packet should not be created now.
-     * In this case the chunk remains in the PlayerChunkMap and this method is called again later until this method returns true or the chunk is unloaded.
-     * This implementation returns false in neighbors mode 2 if and only if not all neighbors of the specified chunk are loaded or loads all neighbors in mode 3.
-     *
-     * @param chunk The chunk which the packet is created for
-     * @param chunkSectionSelector The chunk sections which should be sent (each bit represents for one chunk section, the LSB represents the lowest chunk section, 0 = don't send, 1 = send)
-     * @return <code>false</code> in neighbors mode 2 if and only if not all neighbors of the specified chunk are loaded
-     */
-    @Override
-    public boolean onPacketCreate(Chunk chunk, int chunkSectionSelector) {
-        if (neighborsMode == 2) {
-            if (chunk.world.getChunkIfLoaded(chunk.locX - 1, chunk.locZ) == null || chunk.world.getChunkIfLoaded(chunk.locX + 1, chunk.locZ) == null || chunk.world.getChunkIfLoaded(chunk.locX, chunk.locZ - 1) == null || chunk.world.getChunkIfLoaded(chunk.locX, chunk.locZ + 1) == null) {
-                return false;
-            }
-        } else if (neighborsMode == 3) {
-            chunk.world.getChunkAt(chunk.locX - 1, chunk.locZ);
-            chunk.world.getChunkAt(chunk.locX + 1, chunk.locZ);
-            chunk.world.getChunkAt(chunk.locX, chunk.locZ - 1);
-            chunk.world.getChunkAt(chunk.locX, chunk.locZ + 1);
-        }
-
-        return true;
-    }
-
-    /**
-     * Called when packetPlayOutMapChunk is created and the data of chunk should be written to packetDataSerializer.
-     * This method is called instead of packetPlayOutMapChunk.a(packetDataSerializer, chunk, writeSkyLightArray, chunkSectionSelector, nearbyChunks).
-     * This implementation tries to get the nearby chunks synchronously (if loaded) and executes the code asynchronously in asynchronous mode.
-     *
-     * @param packetPlayOutMapChunk The packet which is created
-     * @param packetDataSerializer The data serializer of the specified packet
-     * @param chunk The chunk which the packet is created for and should be written to the data serializer
-     * @param writeSkyLightArray Whether or not the sky light array should be written to the data serializer
-     * @param chunkSectionSelector The chunk sections which should be sent (each bit represents for one chunk section, the LSB represents the lowest chunk section, 0 = don't send, 1 = send)
-     */
-    @Override
-    public void createPacket(PacketPlayOutMapChunk packetPlayOutMapChunk, PacketDataSerializer packetDataSerializer, Chunk chunk, boolean writeSkyLightArray, int chunkSectionSelector) {
-        Chunk[] nearbyChunks = {chunk.world.getChunkIfLoaded(chunk.locX - 1, chunk.locZ), chunk.world.getChunkIfLoaded(chunk.locX + 1, chunk.locZ), chunk.world.getChunkIfLoaded(chunk.locX, chunk.locZ - 1), chunk.world.getChunkIfLoaded(chunk.locX, chunk.locZ + 1)};
-
-        if (asynchronous) {
-            executorService.execute(new ObfuscatorRunnable(packetPlayOutMapChunk, packetDataSerializer, chunk, writeSkyLightArray, chunkSectionSelector, nearbyChunks));
-        } else {
-            packetPlayOutMapChunk.setWrittenChunkSections(packetPlayOutMapChunk.a(packetDataSerializer, chunk, writeSkyLightArray, chunkSectionSelector, nearbyChunks));
-            packetPlayOutMapChunk.setReady(true);
-        }
-    }
-
-    /**
-     * Called when a PacketPlayOutMapChunk is created and the blocks of the specified chunk section should be written to packetDataSerializer.
-     * This method is called instead of packetDataSerializer.a(dataBits.a()).
-     * This implementation obfuscates the data bits depending on the settings.
-     *
-     * @param packetDataSerializer The data serializer of the created packet
-     * @param chunk The chunk which the packet is created for and contains the chunk section
-     * @param chunkY The y-coordinate of the chunk section from 0 to 15
-     * @param dataPaletteBlock The data palette for the blocks of the specified chunk section
-     * @param dataBits The dataBits of the blocks
-     * @param nearbyChunks An array with the length of 4 containing the chunks around the specified chunk or null if not loaded used for thread-safe chunk access (index 0 = x--, 1 = x++, 2 = z--, 3 = z++)
-     */
-    @Override
-    public void writeBlocks(PacketDataSerializer packetDataSerializer, Chunk chunk, int chunkY, DataPaletteBlock dataPaletteBlock, DataBits dataBits, Chunk[] nearbyChunks) {
-        long[] dataBitsArray = dataBits.a();
-
-        if (chunkY <= maxChunkY && dataPaletteBlock.getCurrentPredefinedBlockData() != null && dataPaletteBlock.getCurrentPredefinedBlockData().length > 0 && nearbyChunks != null) {
-            // The iterator marking which random ore we should use next
-            int randomOre = 0;
-            // Boolean used to check if the engine mode is 3 (used for the initial value of x in the inner loop)
-            boolean engineMode3 = engineMode == 3;
-            // Increment the inner loop by 3 in engine mode 3 for more efficiency
-            int increment = engineMode3 ? 3 : 1;
-            // Stores the last array index of the data bits array which was obfuscated
-            int dataBitsIndex = 0;
-            // Stores the last data which was obfuscated but not written to the packet
-            long currentData = dataBitsArray[0];
-            // Write the length of the data bits array to the packet as it is in vanilla
-            packetDataSerializer.d(dataBitsArray.length);
-            // Optimization: Don't try to obfuscate edge blocks of this section if neighbor sections are not loaded or don't exist
-            // We can also add a check for ChunkSection#nonEmptyBlockCount == 0 here
-            int xMin = nearbyChunks[0] == null || nearbyChunks[0].getSections()[chunkY] == Chunk.a ? 1 : 0;
-            int xMax = nearbyChunks[1] == null || nearbyChunks[1].getSections()[chunkY] == Chunk.a ? 15 : 16;
-            int zMin = nearbyChunks[2] == null || nearbyChunks[2].getSections()[chunkY] == Chunk.a ? 1 : 0;
-            int zMax = nearbyChunks[3] == null || nearbyChunks[3].getSections()[chunkY] == Chunk.a ? 15 : 16;
-            int yMin = chunkY == 0 || chunk.getSections()[chunkY - 1] == Chunk.a ? 1 : 0;
-            int yMax = chunkY == chunk.getSections().length - 1 || chunk.getSections()[chunkY + 1] == Chunk.a ? 15 : 16;
-            // Work through the blocks and write the obfuscated data bits array to the packet
-            for (int y = yMin; y < yMax; y++) {
-                for (int z = zMin; z < zMax; z++) {
-                    // Shift the initial value of x and increment by 3 in engine mode 3
-                    int x;
-
-                    if (engineMode3) {
-                        x = (y + z) % 3;
-
-                        if (x < xMin) {
-                            x += 3;
-                        }
-                    } else {
-                        x = xMin;
-                    }
-
-                    for (; x < xMax; x += increment) {
-                        // Calculate the blockIndex from y, z, x and get the blockData from dataPaletteBlock
-                        // More efficient because we may use the blockIndex again later
-                        int blockIndex = y << 8 | z << 4 | x;
-                        IBlockData blockData = dataPaletteBlock.a(blockIndex);
-                        // Check if the block should be obfuscated
-                        if (obfuscateBlocks[Block.getId(blockData.getBlock())]) {
-                            // Check if the nearby blocks are not transparent, we can obfuscate
-                            if (isHiddenBlock(x, y, z, chunk, chunkY, nearbyChunks)) {
-                                // Get one of the predefined blocks which can be used for obfuscation
-                                if (randomOre >= dataPaletteBlock.getCurrentPredefinedBlockData().length) {
-                                    randomOre = 0;
-                                }
-
-                                int newBlockData = dataPaletteBlock.getCurrentPredefinedBlockData()[randomOre++];
-                                // Get the current index of the block in the data bits array
-                                int currentDataBitsIndex = dataBits.getArrayIndex(blockIndex);
-                                // Check if it has been changed
-                                if (currentDataBitsIndex != dataBitsIndex) {
-                                    // If so, we can write the last obfuscated data to the packet because it is finished with the obfuscation
-                                    packetDataSerializer.writeLong(currentData);
-                                    dataBitsIndex++;
-                                    // We can also write all further content of the data bits array to the packet (until currentDataBitsIndex is reached) because it didn't change
-                                    while (dataBitsIndex < currentDataBitsIndex) {
-                                        packetDataSerializer.writeLong(dataBitsArray[dataBitsIndex]);
-                                        dataBitsIndex++;
-                                    }
-                                    // Now we get the data which has to be obfuscated
-                                    currentData = dataBitsArray[dataBitsIndex];
-                                }
-                                // Obfuscate currentData
-                                currentData = dataBits.obfuscate(blockIndex, newBlockData, currentData);
-                                // Check if the data of the current block is splitted to the next index of the data bits array
-                                if (dataBits.isSplitted(blockIndex, dataBitsIndex)) {
-                                    // If so, we can write currentData to the packet because it is finished with the obfuscation
-                                    packetDataSerializer.writeLong(currentData);
-                                    dataBitsIndex++;
-                                    // Get the data at the next index
-                                    currentData = dataBitsArray[dataBitsIndex];
-                                    // And obfuscate it
-                                    currentData = dataBits.obfuscateSplittedPart(blockIndex, newBlockData, currentData);
-                                }
-                            }
-                        }
-                    }
-                }
-            }
-            // Write the rest of the data bits array to the packet
-            packetDataSerializer.writeLong(currentData);
-            dataBitsIndex++;
-
-            while (dataBitsIndex < dataBitsArray.length) {
-                packetDataSerializer.writeLong(dataBitsArray[dataBitsIndex]);
-                dataBitsIndex++;
-            }
-        } else {
-            packetDataSerializer.a(dataBitsArray);
-        }
-    }
-
-    /**
-     * Called when the block at the specified block position in the specified world changes and nearby blocks become visible for players.
-     * This implementation marks the blocks arround the specified block position as dirty so that a block update is forced.
-     *
-     * @param world The world of the changed block
-     * @param blockPosition The block position of the changed block
-     */
-    @Override
-    public void updateNearbyBlocks(World world, BlockPosition blockPosition) {
-        // 2 is the radius, we shouldn't change it as that would make it exponentially slower
-        updateNearbyBlocks(world, blockPosition, 2, false);
-    }
-
-    private void updateNearbyBlocks(World world, BlockPosition blockPosition, int radius, boolean updateSelf) {
-        // If the block in question is loaded
-        if (world.isLoaded(blockPosition)) {
-            // Get block id
-            Block block = world.getType(blockPosition).getBlock();
-            // See if it needs update
-            if (updateSelf && obfuscateBlocks[Block.getId(block)]) {
-                // Send the update
-                world.notify(blockPosition);
-            }
-            // Check other blocks for updates
-            if (radius > 0) {
-                updateNearbyBlocks(world, blockPosition.east(), radius - 1, true);
-                updateNearbyBlocks(world, blockPosition.west(), radius - 1, true);
-                updateNearbyBlocks(world, blockPosition.up(), radius - 1, true);
-                updateNearbyBlocks(world, blockPosition.down(), radius - 1, true);
-                updateNearbyBlocks(world, blockPosition.south(), radius - 1, true);
-                updateNearbyBlocks(world, blockPosition.north(), radius - 1, true);
-            }
-        }
-    }
-
-    private static boolean isHiddenBlock(int x, int y, int z, Chunk chunk, int chunkY, Chunk[] nearbyChunks) {
-        return isSolidBlock(getType(x, y + 1, z, chunk, chunkY, nearbyChunks).getBlock())
-            && isSolidBlock(getType(x + 1, y, z, chunk, chunkY, nearbyChunks).getBlock())
-            && isSolidBlock(getType(x - 1, y, z, chunk, chunkY, nearbyChunks).getBlock())
-            && isSolidBlock(getType(x, y, z + 1, chunk, chunkY, nearbyChunks).getBlock())
-            && isSolidBlock(getType(x, y, z - 1, chunk, chunkY, nearbyChunks).getBlock())
-            && isSolidBlock(getType(x, y - 1, z, chunk, chunkY, nearbyChunks).getBlock());
-    }
-
-    private static IBlockData getType(int x, int y, int z, Chunk chunk, int chunkY, Chunk[] nearbyChunks) {
-        if (x < 0) {
-            chunk = nearbyChunks[0];
-        } else if (x > 15) {
-            chunk = nearbyChunks[1];
-        } else if (z < 0) {
-            chunk = nearbyChunks[2];
-        } else if (z > 15) {
-            chunk = nearbyChunks[3];
-        }
-
-        int blockY = (chunkY << 4) + y;
-
-        if (blockY >= 0 && blockY >> 4 < chunk.getSections().length) {
-            ChunkSection chunkSection = chunk.getSections()[blockY >> 4];
-
-            if (chunkSection != Chunk.a) {
-                return chunkSection.getType(x & 15, y & 15, z & 15);
-            }
-        }
-
-        return Blocks.AIR.getBlockData();
-    }
-
-    private static boolean isSolidBlock(Block block) {
-        return block.isOccluding(block.getBlockData()) && block != Blocks.MOB_SPAWNER && block != Blocks.BARRIER;
-    }
+/**
+ * BlockPacketControllerObfuscate is an implementation of the interface
+ * IBlockPacketController which aims to obfuscate blocks which are sent with
+ * chunk packets.
+ */
+public class BlockPacketControllerObfuscate implements IBlockPacketController {
+
+	private static ExecutorService executorServiceInstance = null;
+	protected ExecutorService executorService = null;
+	protected Lock noOpLock = null;
+	protected boolean asynchronous = true;
+	protected int engineMode = 3;
+	protected int neighborsMode = 1;
+	protected int maxChunkY = 3;
+	protected final boolean[] obfuscateBlocks = new boolean[Short.MAX_VALUE];
+	protected IBlockData[] replacementOres = null;
+
+	/**
+	 * Protected constructor for invocation by subclass constructors. Use this
+	 * constructor to prevent unnecessary intantiation of the Lock and
+	 * ExecutorService singletons incase of overriding for example
+	 * getChunkBlocksLock(Chunk chunk) and getChunkDataLock(Chunk chunk).
+	 */
+	protected BlockPacketControllerObfuscate() {
+
+	}
+
+	/**
+	 * Public (normal) constructor.
+	 *
+	 * @param config
+	 *            The config for for this instance
+	 */
+	public BlockPacketControllerObfuscate(PaperWorldConfig config) {
+		asynchronous = config.asynchronous;
+		engineMode = config.engineMode;
+		neighborsMode = config.neighborsMode;
+		maxChunkY = config.maxChunkY;
+
+		if (asynchronous) {
+			executorService = getExecutorServiceInstance();
+		} else {
+			noOpLock = Lock.getNoOpInstance();
+		}
+
+		for (Object id : (engineMode == 1) ? config.hiddenBlocks : config.replaceBlocks) {
+			Block block = Block.getByName(String.valueOf(id));
+
+			if (block != null) {
+				int intId = Block.getId(block);
+				obfuscateBlocks[intId] = true;
+			}
+		}
+
+		Set<IBlockData> replacementOreList = new HashSet<IBlockData>();
+
+		for (Object id : config.hiddenBlocks) {
+			Block block = Block.getByName(String.valueOf(id));
+
+			if (block != null && !block.isTileEntity()) {
+				replacementOreList.add(block.getBlockData());
+			}
+		}
+
+		replacementOres = replacementOreList.toArray(new IBlockData[replacementOreList.size()]);
+	}
+
+	/**
+	 * Thread-safe (synchronized) singleton getter.
+	 *
+	 * @return The singleton instance of the executor service
+	 *         (Executors.newSingleThreadExecutor())
+	 */
+	public static synchronized ExecutorService getExecutorServiceInstance() {
+		if (executorServiceInstance == null) {
+			executorServiceInstance = Executors.newSingleThreadExecutor();
+		}
+
+		return executorServiceInstance;
+	}
+
+	/**
+	 * Returns an instance of a Lock implementation used by the specified chunk
+	 * to lock blocks or chunk sections from modification. This implementation
+	 * returns a new instance of Lock in asynchronous mode and the singleton
+	 * Lock.getNoOpInstance() else.
+	 *
+	 * @param chunk
+	 *            The chunk which needs the lock
+	 * @return An instance of a Lock implementation
+	 */
+	@Override
+	public Lock getChunkBlocksLock(Chunk chunk) {
+		return asynchronous ? new Lock() : noOpLock;
+	}
+
+	/**
+	 * Returns an instance of a Lock implementation used by the specified chunk
+	 * to lock chunk data (everything that is needed to create the packet) from
+	 * modification. This implementation returns a new instance of Lock in
+	 * asynchronous mode and the singleton Lock.getNoOpInstance() else.
+	 *
+	 * @param chunk
+	 *            The chunk which needs the lock
+	 * @return An instance of a Lock implementation
+	 */
+	@Override
+	public Lock getChunkDataLock(Chunk chunk) {
+		return asynchronous ? new Lock() : noOpLock;
+	}
+
+	/**
+	 * Called when a new chunk section is created. Returns an array of
+	 * predefined block data for the DataPaletteBlock of the specified chunk
+	 * section or null if there is no block data. This implementation returns
+	 * the blocks which are used to obfuscate the original blocks.
+	 *
+	 * @param chunk
+	 *            The chunk which contains the chunk section
+	 * @param chunkY
+	 *            The y-coordinate of the chunk section from 0 to 15
+	 * @return The array of predefined block data or null
+	 */
+	@Override
+	public IBlockData[] getPredefinedBlockData(Chunk chunk, int chunkY) {
+		if (chunkY <= maxChunkY) {
+			switch (engineMode) {
+			case 1:
+				switch (chunk.world.getWorld().getEnvironment()) {
+				case NETHER:
+					return new IBlockData[] { Blocks.NETHERRACK.getBlockData() };
+				case THE_END:
+					return new IBlockData[] { Blocks.END_STONE.getBlockData() };
+				default:
+					return new IBlockData[] { Blocks.STONE.getBlockData() };
+				}
+			case 2:
+			case 3:
+				return replacementOres;
+			}
+		}
+
+		return null;
+	}
+
+	/**
+	 * Called before the server attempts to create and send a
+	 * PacketPlayOutMapChunk for the specified chunk (not for chunk updates).
+	 * Returns false if and only if the packet should not be created now. In
+	 * this case the chunk remains in the PlayerChunkMap and this method is
+	 * called again later until this method returns true or the chunk is
+	 * unloaded. This implementation returns false in neighbors mode 2 if and
+	 * only if not all neighbors of the specified chunk are loaded or loads all
+	 * neighbors in mode 3.
+	 *
+	 * @param chunk
+	 *            The chunk which the packet is created for
+	 * @param chunkSectionSelector
+	 *            The chunk sections which should be sent (each bit represents
+	 *            for one chunk section, the LSB represents the lowest chunk
+	 *            section, 0 = don't send, 1 = send)
+	 * @return <code>false</code> in neighbors mode 2 if and only if not all
+	 *         neighbors of the specified chunk are loaded
+	 */
+	@Override
+	public boolean onPacketCreate(Chunk chunk, int chunkSectionSelector) {
+		if (neighborsMode == 2) {
+			if (chunk.world.getChunkIfLoaded(chunk.locX - 1, chunk.locZ) == null
+					|| chunk.world.getChunkIfLoaded(chunk.locX + 1, chunk.locZ) == null
+					|| chunk.world.getChunkIfLoaded(chunk.locX, chunk.locZ - 1) == null
+					|| chunk.world.getChunkIfLoaded(chunk.locX, chunk.locZ + 1) == null) {
+				return false;
+			}
+		} else if (neighborsMode == 3) {
+			chunk.world.getChunkAt(chunk.locX - 1, chunk.locZ);
+			chunk.world.getChunkAt(chunk.locX + 1, chunk.locZ);
+			chunk.world.getChunkAt(chunk.locX, chunk.locZ - 1);
+			chunk.world.getChunkAt(chunk.locX, chunk.locZ + 1);
+		}
+
+		return true;
+	}
+
+	/**
+	 * Called when packetPlayOutMapChunk is created and the data of chunk should
+	 * be written to packetDataSerializer. This method is called instead of
+	 * packetPlayOutMapChunk.a(packetDataSerializer, chunk, writeSkyLightArray,
+	 * chunkSectionSelector, nearbyChunks). This implementation tries to get the
+	 * nearby chunks synchronously (if loaded) and executes the code
+	 * asynchronously in asynchronous mode.
+	 *
+	 * @param packetPlayOutMapChunk
+	 *            The packet which is created
+	 * @param packetDataSerializer
+	 *            The data serializer of the specified packet
+	 * @param chunk
+	 *            The chunk which the packet is created for and should be
+	 *            written to the data serializer
+	 * @param writeSkyLightArray
+	 *            Whether or not the sky light array should be written to the
+	 *            data serializer
+	 * @param chunkSectionSelector
+	 *            The chunk sections which should be sent (each bit represents
+	 *            for one chunk section, the LSB represents the lowest chunk
+	 *            section, 0 = don't send, 1 = send)
+	 */
+	@Override
+	public void createPacket(PacketPlayOutMapChunk packetPlayOutMapChunk, PacketDataSerializer packetDataSerializer,
+			Chunk chunk, boolean writeSkyLightArray, int chunkSectionSelector) {
+		Chunk[] nearbyChunks = { chunk.world.getChunkIfLoaded(chunk.locX - 1, chunk.locZ),
+				chunk.world.getChunkIfLoaded(chunk.locX + 1, chunk.locZ),
+				chunk.world.getChunkIfLoaded(chunk.locX, chunk.locZ - 1),
+				chunk.world.getChunkIfLoaded(chunk.locX, chunk.locZ + 1) };
+
+		if (asynchronous) {
+			executorService.execute(new ObfuscatorRunnable(packetPlayOutMapChunk, packetDataSerializer, chunk,
+					writeSkyLightArray, chunkSectionSelector, nearbyChunks));
+		} else {
+			packetPlayOutMapChunk.setWrittenChunkSections(packetPlayOutMapChunk.a(packetDataSerializer, chunk,
+					writeSkyLightArray, chunkSectionSelector, nearbyChunks));
+			packetPlayOutMapChunk.setReady(true);
+		}
+	}
+
+	/**
+	 * Called when a PacketPlayOutMapChunk is created and the blocks of the
+	 * specified chunk section should be written to packetDataSerializer. This
+	 * method is called instead of packetDataSerializer.a(dataBits.a()). This
+	 * implementation obfuscates the data bits depending on the settings.
+	 *
+	 * @param packetDataSerializer
+	 *            The data serializer of the created packet
+	 * @param chunk
+	 *            The chunk which the packet is created for and contains the
+	 *            chunk section
+	 * @param chunkY
+	 *            The y-coordinate of the chunk section from 0 to 15
+	 * @param dataPaletteBlock
+	 *            The data palette for the blocks of the specified chunk section
+	 * @param dataBits
+	 *            The dataBits of the blocks
+	 * @param nearbyChunks
+	 *            An array with the length of 4 containing the chunks around the
+	 *            specified chunk or null if not loaded used for thread-safe
+	 *            chunk access (index 0 = x--, 1 = x++, 2 = z--, 3 = z++)
+	 */
+	@Override
+	public void writeBlocks(PacketDataSerializer packetDataSerializer, Chunk chunk, int chunkY,
+			DataPaletteBlock dataPaletteBlock, DataBits dataBits, Chunk[] nearbyChunks) {
+		long[] dataBitsArray = dataBits.a();
+
+		if (chunkY <= maxChunkY && dataPaletteBlock.getCurrentPredefinedBlockData() != null
+				&& dataPaletteBlock.getCurrentPredefinedBlockData().length > 0 && nearbyChunks != null) {
+			// The iterator marking which random ore we should use next
+			int randomOre = 0;
+			// Boolean used to check if the engine mode is 3 (used for the
+			// initial value of x in the inner loop)
+			boolean engineMode3 = engineMode == 3;
+			// Increment the inner loop by 3 in engine mode 3 for more
+			// efficiency
+			int increment = engineMode3 ? 3 : 1;
+			// Stores the last array index of the data bits array which was
+			// obfuscated
+			int dataBitsIndex = 0;
+			// Stores the last data which was obfuscated but not written to the
+			// packet
+			long currentData = dataBitsArray[0];
+			// Write the length of the data bits array to the packet as it is in
+			// vanilla
+			packetDataSerializer.d(dataBitsArray.length);
+			// Optimization: Don't try to obfuscate edge blocks of this section
+			// if neighbor sections are not loaded or don't exist
+			// We can also add a check for ChunkSection#nonEmptyBlockCount == 0
+			// here
+			int xMin = nearbyChunks[0] == null || nearbyChunks[0].getSections()[chunkY] == Chunk.a ? 1 : 0;
+			int xMax = nearbyChunks[1] == null || nearbyChunks[1].getSections()[chunkY] == Chunk.a ? 15 : 16;
+			int zMin = nearbyChunks[2] == null || nearbyChunks[2].getSections()[chunkY] == Chunk.a ? 1 : 0;
+			int zMax = nearbyChunks[3] == null || nearbyChunks[3].getSections()[chunkY] == Chunk.a ? 15 : 16;
+			int yMin = chunkY == 0 || chunk.getSections()[chunkY - 1] == Chunk.a ? 1 : 0;
+			int yMax = chunkY == chunk.getSections().length - 1 || chunk.getSections()[chunkY + 1] == Chunk.a ? 15 : 16;
+			// Work through the blocks and write the obfuscated data bits array
+			// to the packet
+			for (int y = yMin; y < yMax; y++) {
+				for (int z = zMin; z < zMax; z++) {
+					// Shift the initial value of x and increment by 3 in engine
+					// mode 3
+					int x;
+
+					if (engineMode3) {
+						x = (y + z) % 3;
+
+						if (x < xMin) {
+							x += 3;
+						}
+					} else {
+						x = xMin;
+					}
+
+					for (; x < xMax; x += increment) {
+						// Calculate the blockIndex from y, z, x and get the
+						// blockData from dataPaletteBlock
+						// More efficient because we may use the blockIndex
+						// again later
+						int blockIndex = y << 8 | z << 4 | x;
+						IBlockData blockData = dataPaletteBlock.a(blockIndex);
+						// Check if the block should be obfuscated
+						if (obfuscateBlocks[Block.getId(blockData.getBlock())]) {
+							// Check if the nearby blocks are not transparent,
+							// we can obfuscate
+							if (isHiddenBlock(x, y, z, chunk, chunkY, nearbyChunks)) {
+								// Get one of the predefined blocks which can be
+								// used for obfuscation
+								if (randomOre >= dataPaletteBlock.getCurrentPredefinedBlockData().length) {
+									randomOre = 0;
+								}
+
+								int newBlockData = dataPaletteBlock.getCurrentPredefinedBlockData()[randomOre++];
+								// Get the current index of the block in the
+								// data bits array
+								int currentDataBitsIndex = dataBits.getArrayIndex(blockIndex);
+								// Check if it has been changed
+								if (currentDataBitsIndex != dataBitsIndex) {
+									// If so, we can write the last obfuscated
+									// data to the packet because it is finished
+									// with the obfuscation
+									packetDataSerializer.writeLong(currentData);
+									dataBitsIndex++;
+									// We can also write all further content of
+									// the data bits array to the packet (until
+									// currentDataBitsIndex is reached) because
+									// it didn't change
+									while (dataBitsIndex < currentDataBitsIndex) {
+										packetDataSerializer.writeLong(dataBitsArray[dataBitsIndex]);
+										dataBitsIndex++;
+									}
+									// Now we get the data which has to be
+									// obfuscated
+									currentData = dataBitsArray[dataBitsIndex];
+								}
+								// Obfuscate currentData
+								currentData = dataBits.obfuscate(blockIndex, newBlockData, currentData);
+								// Check if the data of the current block is
+								// splitted to the next index of the data bits
+								// array
+								if (dataBits.isSplitted(blockIndex, dataBitsIndex)) {
+									// If so, we can write currentData to the
+									// packet because it is finished with the
+									// obfuscation
+									packetDataSerializer.writeLong(currentData);
+									dataBitsIndex++;
+									// Get the data at the next index
+									currentData = dataBitsArray[dataBitsIndex];
+									// And obfuscate it
+									currentData = dataBits.obfuscateSplittedPart(blockIndex, newBlockData, currentData);
+								}
+							}
+						}
+					}
+				}
+			}
+			// Write the rest of the data bits array to the packet
+			packetDataSerializer.writeLong(currentData);
+			dataBitsIndex++;
+
+			while (dataBitsIndex < dataBitsArray.length) {
+				packetDataSerializer.writeLong(dataBitsArray[dataBitsIndex]);
+				dataBitsIndex++;
+			}
+		} else {
+			packetDataSerializer.a(dataBitsArray);
+		}
+	}
+
+	/**
+	 * Called when the block at the specified block position in the specified
+	 * world changes and nearby blocks become visible for players. This
+	 * implementation marks the blocks arround the specified block position as
+	 * dirty so that a block update is forced.
+	 *
+	 * @param world
+	 *            The world of the changed block
+	 * @param blockPosition
+	 *            The block position of the changed block
+	 */
+	@Override
+	public void updateNearbyBlocks(World world, BlockPosition blockPosition) {
+		// 2 is the radius, we shouldn't change it as that would make it
+		// exponentially slower
+		updateNearbyBlocks(world, blockPosition, 2, false);
+	}
+
+	private void updateNearbyBlocks(World world, BlockPosition blockPosition, int radius, boolean updateSelf) {
+		// If the block in question is loaded
+		if (world.isLoaded(blockPosition)) {
+			// Get block id
+			Block block = world.getType(blockPosition).getBlock();
+			// See if it needs update
+			if (updateSelf && obfuscateBlocks[Block.getId(block)]) {
+				// Send the update
+				world.notify(blockPosition);
+			}
+			// Check other blocks for updates
+			if (radius > 0) {
+				updateNearbyBlocks(world, blockPosition.east(), radius - 1, true);
+				updateNearbyBlocks(world, blockPosition.west(), radius - 1, true);
+				updateNearbyBlocks(world, blockPosition.up(), radius - 1, true);
+				updateNearbyBlocks(world, blockPosition.down(), radius - 1, true);
+				updateNearbyBlocks(world, blockPosition.south(), radius - 1, true);
+				updateNearbyBlocks(world, blockPosition.north(), radius - 1, true);
+			}
+		}
+	}
+
+	private static boolean isHiddenBlock(int x, int y, int z, Chunk chunk, int chunkY, Chunk[] nearbyChunks) {
+		return isSolidBlock(getType(x, y + 1, z, chunk, chunkY, nearbyChunks).getBlock())
+				&& isSolidBlock(getType(x + 1, y, z, chunk, chunkY, nearbyChunks).getBlock())
+				&& isSolidBlock(getType(x - 1, y, z, chunk, chunkY, nearbyChunks).getBlock())
+				&& isSolidBlock(getType(x, y, z + 1, chunk, chunkY, nearbyChunks).getBlock())
+				&& isSolidBlock(getType(x, y, z - 1, chunk, chunkY, nearbyChunks).getBlock())
+				&& isSolidBlock(getType(x, y - 1, z, chunk, chunkY, nearbyChunks).getBlock());
+	}
+
+	private static IBlockData getType(int x, int y, int z, Chunk chunk, int chunkY, Chunk[] nearbyChunks) {
+		if (x < 0) {
+			chunk = nearbyChunks[0];
+		} else if (x > 15) {
+			chunk = nearbyChunks[1];
+		} else if (z < 0) {
+			chunk = nearbyChunks[2];
+		} else if (z > 15) {
+			chunk = nearbyChunks[3];
+		}
+
+		int blockY = (chunkY << 4) + y;
+
+		if (blockY >= 0 && blockY >> 4 < chunk.getSections().length) {
+			ChunkSection chunkSection = chunk.getSections()[blockY >> 4];
+
+			if (chunkSection != Chunk.a) {
+				return chunkSection.getType(x & 15, y & 15, z & 15);
+			}
+		}
+
+		return Blocks.AIR.getBlockData();
+	}
+
+	private static boolean isSolidBlock(Block block) {
+		return block.isOccluding(block.getBlockData()) && block != Blocks.MOB_SPAWNER && block != Blocks.BARRIER;
+	}
 }
\ No newline at end of file
diff --git a/src/main/java/com/destroystokyo/paper/antixray/IBlockPacketController.java b/src/main/java/com/destroystokyo/paper/antixray/IBlockPacketController.java
index ab0ab12..6eeb07f 100644
--- a/src/main/java/com/destroystokyo/paper/antixray/IBlockPacketController.java
+++ b/src/main/java/com/destroystokyo/paper/antixray/IBlockPacketController.java
@@ -10,77 +10,120 @@ import net.minecraft.server.PacketDataSerializer;
 import net.minecraft.server.World;
 
 /**
- * IBlockPacketController is an interface which defines methods used to control which and how blocks are sent to the client.
+ * IBlockPacketController is an interface which defines methods used to control
+ * which and how blocks are sent to the client.
  */
 public interface IBlockPacketController {
 
-    /**
-     * Returns an instance of a Lock implementation used by the specified chunk to lock blocks or chunk sections from modification.
-     *
-     * @param chunk The chunk which needs the lock
-     * @return An instance of a Lock implementation
-     */
-    public Lock getChunkBlocksLock(Chunk chunk);
+	/**
+	 * Returns an instance of a Lock implementation used by the specified chunk
+	 * to lock blocks or chunk sections from modification.
+	 *
+	 * @param chunk
+	 *            The chunk which needs the lock
+	 * @return An instance of a Lock implementation
+	 */
+	public Lock getChunkBlocksLock(Chunk chunk);
 
-    /**
-     * Returns an instance of a Lock implementation used by the specified chunk to lock chunk data (everything that is needed to create the packet) from modification.
-     *
-     * @param chunk The chunk which needs the lock
-     * @return An instance of a Lock implementation
-     */
-    public Lock getChunkDataLock(Chunk chunk);
+	/**
+	 * Returns an instance of a Lock implementation used by the specified chunk
+	 * to lock chunk data (everything that is needed to create the packet) from
+	 * modification.
+	 *
+	 * @param chunk
+	 *            The chunk which needs the lock
+	 * @return An instance of a Lock implementation
+	 */
+	public Lock getChunkDataLock(Chunk chunk);
 
-    /**
-     * Called when a new chunk section is created.
-     * Returns an array of predefined block data for the DataPaletteBlock of the specified chunk section or null if there is no block data.
-     *
-     * @param chunk The chunk which contains the chunk section
-     * @param chunkY The y-coordinate of the chunk section from 0 to 15
-     * @return The array of predefined block data or null
-     */
-    public IBlockData[] getPredefinedBlockData(Chunk chunk, int chunkY);
+	/**
+	 * Called when a new chunk section is created. Returns an array of
+	 * predefined block data for the DataPaletteBlock of the specified chunk
+	 * section or null if there is no block data.
+	 *
+	 * @param chunk
+	 *            The chunk which contains the chunk section
+	 * @param chunkY
+	 *            The y-coordinate of the chunk section from 0 to 15
+	 * @return The array of predefined block data or null
+	 */
+	public IBlockData[] getPredefinedBlockData(Chunk chunk, int chunkY);
 
-    /**
-     * Called before the server attempts to create and send a PacketPlayOutMapChunk for the specified chunk (not for chunk updates).
-     * Returns false if and only if the packet should not be created now.
-     * In this case the chunk remains in the PlayerChunkMap and this method is called again later until this method returns true or the chunk is unloaded.
-     *
-     * @param chunk The chunk which the packet is created for
-     * @param chunkSectionSelector The chunk sections which should be sent (each bit represents for one chunk section, the LSB represents the lowest chunk section, 0 = don't send, 1 = send)
-     * @return <code>true</code> if the packet should be sent now, or <code>false</code> if the packet should be sent later
-     */
-    public boolean onPacketCreate(Chunk chunk, int chunkSectionSelector);
+	/**
+	 * Called before the server attempts to create and send a
+	 * PacketPlayOutMapChunk for the specified chunk (not for chunk updates).
+	 * Returns false if and only if the packet should not be created now. In
+	 * this case the chunk remains in the PlayerChunkMap and this method is
+	 * called again later until this method returns true or the chunk is
+	 * unloaded.
+	 *
+	 * @param chunk
+	 *            The chunk which the packet is created for
+	 * @param chunkSectionSelector
+	 *            The chunk sections which should be sent (each bit represents
+	 *            for one chunk section, the LSB represents the lowest chunk
+	 *            section, 0 = don't send, 1 = send)
+	 * @return <code>true</code> if the packet should be sent now, or
+	 *         <code>false</code> if the packet should be sent later
+	 */
+	public boolean onPacketCreate(Chunk chunk, int chunkSectionSelector);
 
-    /**
-     * Called when packetPlayOutMapChunk is created and the data of chunk should be written to packetDataSerializer.
-     * This method is called instead of packetPlayOutMapChunk.a(packetDataSerializer, chunk, writeSkyLightArray, chunkSectionSelector, nearbyChunks).
-     *
-     * @param packetPlayOutMapChunk The packet which is created
-     * @param packetDataSerializer The data serializer of the specified packet
-     * @param chunk The chunk which the packet is created for and should be written to the data serializer
-     * @param writeSkyLightArray Whether or not the sky light array should be written to the data serializer
-     * @param chunkSectionSelector The chunk sections which should be sent (each bit represents for one chunk section, the LSB represents the lowest chunk section, 0 = don't send, 1 = send)
-     */
-    public void createPacket(PacketPlayOutMapChunk packetPlayOutMapChunk, PacketDataSerializer packetDataSerializer, Chunk chunk, boolean writeSkyLightArray, int chunkSectionSelector);
+	/**
+	 * Called when packetPlayOutMapChunk is created and the data of chunk should
+	 * be written to packetDataSerializer. This method is called instead of
+	 * packetPlayOutMapChunk.a(packetDataSerializer, chunk, writeSkyLightArray,
+	 * chunkSectionSelector, nearbyChunks).
+	 *
+	 * @param packetPlayOutMapChunk
+	 *            The packet which is created
+	 * @param packetDataSerializer
+	 *            The data serializer of the specified packet
+	 * @param chunk
+	 *            The chunk which the packet is created for and should be
+	 *            written to the data serializer
+	 * @param writeSkyLightArray
+	 *            Whether or not the sky light array should be written to the
+	 *            data serializer
+	 * @param chunkSectionSelector
+	 *            The chunk sections which should be sent (each bit represents
+	 *            for one chunk section, the LSB represents the lowest chunk
+	 *            section, 0 = don't send, 1 = send)
+	 */
+	public void createPacket(PacketPlayOutMapChunk packetPlayOutMapChunk, PacketDataSerializer packetDataSerializer,
+			Chunk chunk, boolean writeSkyLightArray, int chunkSectionSelector);
 
-    /**
-     * Called when a PacketPlayOutMapChunk is created and the blocks of the specified chunk section should be written to packetDataSerializer.
-     * This method is called instead of packetDataSerializer.a(dataBits.a()).
-     *
-     * @param packetDataSerializer The data serializer of the created packet
-     * @param chunk The chunk which the packet is created for and contains the chunk section
-     * @param chunkY The y-coordinate of the chunk section from 0 to 15
-     * @param dataPaletteBlock The data palette for the blocks of the specified chunk section
-     * @param dataBits The dataBits of the blocks
-     * @param nearbyChunks An array with the length of 4 containing the chunks around the specified chunk or null if not loaded used for thread-safe chunk access (index 0 = x--, 1 = x++, 2 = z--, 3 = z++)
-     */
-    public void writeBlocks(PacketDataSerializer packetDataSerializer, Chunk chunk, int chunkY, DataPaletteBlock dataPaletteBlock, DataBits dataBits, Chunk[] nearbyChunks);
+	/**
+	 * Called when a PacketPlayOutMapChunk is created and the blocks of the
+	 * specified chunk section should be written to packetDataSerializer. This
+	 * method is called instead of packetDataSerializer.a(dataBits.a()).
+	 *
+	 * @param packetDataSerializer
+	 *            The data serializer of the created packet
+	 * @param chunk
+	 *            The chunk which the packet is created for and contains the
+	 *            chunk section
+	 * @param chunkY
+	 *            The y-coordinate of the chunk section from 0 to 15
+	 * @param dataPaletteBlock
+	 *            The data palette for the blocks of the specified chunk section
+	 * @param dataBits
+	 *            The dataBits of the blocks
+	 * @param nearbyChunks
+	 *            An array with the length of 4 containing the chunks around the
+	 *            specified chunk or null if not loaded used for thread-safe
+	 *            chunk access (index 0 = x--, 1 = x++, 2 = z--, 3 = z++)
+	 */
+	public void writeBlocks(PacketDataSerializer packetDataSerializer, Chunk chunk, int chunkY,
+			DataPaletteBlock dataPaletteBlock, DataBits dataBits, Chunk[] nearbyChunks);
 
-    /**
-     * Called when the block at the specified block position in the specified world changes and nearby blocks become visible for players.
-     *
-     * @param world The world of the changed block
-     * @param blockPosition The block position of the changed block
-     */
-    public void updateNearbyBlocks(World world, BlockPosition blockPosition);
+	/**
+	 * Called when the block at the specified block position in the specified
+	 * world changes and nearby blocks become visible for players.
+	 *
+	 * @param world
+	 *            The world of the changed block
+	 * @param blockPosition
+	 *            The block position of the changed block
+	 */
+	public void updateNearbyBlocks(World world, BlockPosition blockPosition);
 }
\ No newline at end of file
diff --git a/src/main/java/com/destroystokyo/paper/antixray/Lock.java b/src/main/java/com/destroystokyo/paper/antixray/Lock.java
index 15f305d..19d9946 100644
--- a/src/main/java/com/destroystokyo/paper/antixray/Lock.java
+++ b/src/main/java/com/destroystokyo/paper/antixray/Lock.java
@@ -1,18 +1,24 @@
 package com.destroystokyo.paper.antixray;
 
- import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicInteger;
 
 /**
  * Example use case of this Lock class:
- * <pre><code>String[] lines;
+ * 
+ * <pre>
+ * <code>String[] lines;
  *void setLine(int i, String line) { //only invoked by main thread
  *    lines[i] = line;
  *}
  *void printLines() { //only invoked by main thread
  *    for (String line : lines) {System.out.println(line);}
- *}</code></pre>
+ *}</code>
+ * </pre>
+ * 
  * Make printLines() async:
- * <pre><code>String[] lines;
+ * 
+ * <pre>
+ * <code>String[] lines;
  *void setLine(int i, String line) { //only invoked by main thread
  *    //lock
  *    lines[i] = line;
@@ -27,18 +33,20 @@ package com.destroystokyo.paper.antixray;
  *        for (String line : lines) {System.out.println(line);}
  *        //unlock
  *    }}.start();
- *}</code></pre>
- * The goal is to ensure that the correct state of the array is printed
- * (-> the state when printLines() is invoked).
- * As shown with the //lock and //unlock comments a normal locking system
- * can't help here.
- * Possible solutions:
+ *}</code>
+ * </pre>
+ * 
+ * The goal is to ensure that the correct state of the array is printed (-> the
+ * state when printLines() is invoked). As shown with the //lock and //unlock
+ * comments a normal locking system can't help here. Possible solutions:
  * <ul>
  * <li>Copy the array before starting the new thread and print the copy
  * <li>Or use this Lock implementation (if setLine() is invoked infrequently)
  * </ul>
  * Code:
- * <pre><code>Lock lock = new Lock();
+ * 
+ * <pre>
+ * <code>Lock lock = new Lock();
  *String[] lines;
  *void setLine(int i, String line) { //only invoked by main thread
  *    lock.waitUntilUnlock();
@@ -52,66 +60,68 @@ package com.destroystokyo.paper.antixray;
  *        for (String line : lines) {System.out.println(line);}
  *        lock.unlock();
  *    }}.start();
- *}</code></pre>
+ *}</code>
+ * </pre>
  */
 public class Lock {
 
-    private static Lock noOpInstance = null;
-    private final AtomicInteger lockCount = new AtomicInteger();
+	private static Lock noOpInstance = null;
+	private final AtomicInteger lockCount = new AtomicInteger();
 
-    /**
-     * Thread-safe (synchronized) singleton getter.
-     *
-     * @return The singleton instance of a no operation implementation of this class
-     */
-    public static synchronized Lock getNoOpInstance() {
-        if (noOpInstance == null) {
-            noOpInstance = new Lock() {
-                @Override
-                public void lock() {
+	/**
+	 * Thread-safe (synchronized) singleton getter.
+	 *
+	 * @return The singleton instance of a no operation implementation of this
+	 *         class
+	 */
+	public static synchronized Lock getNoOpInstance() {
+		if (noOpInstance == null) {
+			noOpInstance = new Lock() {
+				@Override
+				public void lock() {
 
-                }
+				}
 
-                @Override
-                public void unlock() {
+				@Override
+				public void unlock() {
 
-                }
+				}
 
-                @Override
-                public void waitUntilUnlock() {
+				@Override
+				public void waitUntilUnlock() {
 
-                }
-            };
-        }
+				}
+			};
+		}
 
-        return noOpInstance;
-    }
+		return noOpInstance;
+	}
 
-    /**
-     * See example use case in class doc.
-     */
-    public void lock() {
-        lockCount.incrementAndGet();
-    }
+	/**
+	 * See example use case in class doc.
+	 */
+	public void lock() {
+		lockCount.incrementAndGet();
+	}
 
-    /**
-     * See example use case in class doc.
-     */
-    public synchronized void unlock() {
-        lockCount.decrementAndGet();
-        notifyAll();
-    }
+	/**
+	 * See example use case in class doc.
+	 */
+	public synchronized void unlock() {
+		lockCount.decrementAndGet();
+		notifyAll();
+	}
 
-    /**
-     * See example use case in class doc.
-     */
-    public synchronized void waitUntilUnlock() {
-        try {
-            while (lockCount.get() > 0) {
-                wait();
-            }
-        } catch (InterruptedException e) {
-            Thread.currentThread().interrupt();
-        }
-    }
+	/**
+	 * See example use case in class doc.
+	 */
+	public synchronized void waitUntilUnlock() {
+		try {
+			while (lockCount.get() > 0) {
+				wait();
+			}
+		} catch (InterruptedException e) {
+			Thread.currentThread().interrupt();
+		}
+	}
 }
\ No newline at end of file
diff --git a/src/main/java/com/destroystokyo/paper/event/player/PlayerHandshakeEvent.java b/src/main/java/com/destroystokyo/paper/event/player/PlayerHandshakeEvent.java
index 59f7e5c..d7c2bad 100644
--- a/src/main/java/com/destroystokyo/paper/event/player/PlayerHandshakeEvent.java
+++ b/src/main/java/com/destroystokyo/paper/event/player/PlayerHandshakeEvent.java
@@ -182,7 +182,9 @@ public class PlayerHandshakeEvent extends Event implements Cancellable {
 	 * @return {@code true} if authentication failed, {@code false} otherwise
 	 */
 	public boolean isFailed() {
-		if (de.minetick.MigotConfig.bungeeForwardingCompatible) { return false; }
+		if (de.minetick.MigotConfig.bungeeForwardingCompatible) {
+			return false;
+		}
 		return this.failed;
 	}
 
diff --git a/src/main/java/de/minetick/AutoSaveJob.java b/src/main/java/de/minetick/AutoSaveJob.java
index 680be0e..5b62ce9 100644
--- a/src/main/java/de/minetick/AutoSaveJob.java
+++ b/src/main/java/de/minetick/AutoSaveJob.java
@@ -42,7 +42,9 @@ public class AutoSaveJob {
 			if (FileIOThread.a().isDone()) {
 				MinecraftTimings.worldSaveTimer.startTiming();
 				FileIOThread.a().setNoDelay(false);
-				synchronized(this) { RegionFileCache.a(); }
+				synchronized (this) {
+					RegionFileCache.a();
+				}
 				Bukkit.getPluginManager().callEvent(new WorldSaveEvent(this.worldserver.getWorld()));
 				MinecraftTimings.worldSaveTimer.stopTiming();
 			} else {
diff --git a/src/main/java/net/minecraft/server/BiomeCache.java b/src/main/java/net/minecraft/server/BiomeCache.java
index ce21cce..a6963bf 100644
--- a/src/main/java/net/minecraft/server/BiomeCache.java
+++ b/src/main/java/net/minecraft/server/BiomeCache.java
@@ -6,78 +6,78 @@ import java.util.concurrent.ConcurrentHashMap;
 
 public class BiomeCache {
 
-    private final WorldChunkManager a;
-    private long b;
-    private final Map<Long, BiomeCache.a> c = new ConcurrentHashMap(4096);
-    private final List<BiomeCache.a> d = new org.torch.util.ConcurrentIterableArrayList();
-
-    public BiomeCache(WorldChunkManager worldchunkmanager) {
-        this.a = worldchunkmanager;
-    }
-
-    public BiomeCache.a a(int i, int j) {
-        i >>= 4;
-        j >>= 4;
-        long k = (long) i & 4294967295L | ((long) j & 4294967295L) << 32;
-        BiomeCache.a biomecache_a = (BiomeCache.a) this.c.get(k);
-
-        if (biomecache_a == null) {
-            biomecache_a = new BiomeCache.a(i, j);
-            this.c.put(k, biomecache_a);
-            this.d.add(biomecache_a);
-        }
-
-        biomecache_a.d = MinecraftServer.av();
-        return biomecache_a;
-    }
-
-    public BiomeBase a(int i, int j, BiomeBase biomebase) {
-        BiomeBase biomebase1 = this.a(i, j).a(i, j);
-
-        return biomebase1 == null ? biomebase : biomebase1;
-    }
-
-    public void a() {
-        long i = MinecraftServer.av();
-        long j = i - this.b;
-
-        if (j > 7500L || j < 0L) {
-            this.b = i;
-
-            for (int k = 0; k < this.d.size(); ++k) {
-                BiomeCache.a biomecache_a = (BiomeCache.a) this.d.get(k);
-                long l = i - biomecache_a.d;
-
-                if (l > 30000L || l < 0L) {
-                    this.d.remove(k--);
-                    long i1 = (long) biomecache_a.b & 4294967295L | ((long) biomecache_a.c & 4294967295L) << 32;
-
-                    this.c.remove(i1);
-                }
-            }
-        }
-
-    }
-
-    public BiomeBase[] b(int i, int j) {
-        return this.a(i, j).a;
-    }
-
-    public class a {
-
-        public BiomeBase[] a = new BiomeBase[256];
-        public int b;
-        public int c;
-        public long d;
-
-        public a(int i, int j) {
-            this.b = i;
-            this.c = j;
-            BiomeCache.this.a.a(this.a, i << 4, j << 4, 16, 16, false);
-        }
-
-        public BiomeBase a(int i, int j) {
-            return this.a[i & 15 | (j & 15) << 4];
-        }
-    }
+	private final WorldChunkManager a;
+	private long b;
+	private final Map<Long, BiomeCache.a> c = new ConcurrentHashMap(4096);
+	private final List<BiomeCache.a> d = new org.torch.util.ConcurrentIterableArrayList();
+
+	public BiomeCache(WorldChunkManager worldchunkmanager) {
+		this.a = worldchunkmanager;
+	}
+
+	public BiomeCache.a a(int i, int j) {
+		i >>= 4;
+		j >>= 4;
+		long k = (long) i & 4294967295L | ((long) j & 4294967295L) << 32;
+		BiomeCache.a biomecache_a = (BiomeCache.a) this.c.get(k);
+
+		if (biomecache_a == null) {
+			biomecache_a = new BiomeCache.a(i, j);
+			this.c.put(k, biomecache_a);
+			this.d.add(biomecache_a);
+		}
+
+		biomecache_a.d = MinecraftServer.av();
+		return biomecache_a;
+	}
+
+	public BiomeBase a(int i, int j, BiomeBase biomebase) {
+		BiomeBase biomebase1 = this.a(i, j).a(i, j);
+
+		return biomebase1 == null ? biomebase : biomebase1;
+	}
+
+	public void a() {
+		long i = MinecraftServer.av();
+		long j = i - this.b;
+
+		if (j > 7500L || j < 0L) {
+			this.b = i;
+
+			for (int k = 0; k < this.d.size(); ++k) {
+				BiomeCache.a biomecache_a = (BiomeCache.a) this.d.get(k);
+				long l = i - biomecache_a.d;
+
+				if (l > 30000L || l < 0L) {
+					this.d.remove(k--);
+					long i1 = (long) biomecache_a.b & 4294967295L | ((long) biomecache_a.c & 4294967295L) << 32;
+
+					this.c.remove(i1);
+				}
+			}
+		}
+
+	}
+
+	public BiomeBase[] b(int i, int j) {
+		return this.a(i, j).a;
+	}
+
+	public class a {
+
+		public BiomeBase[] a = new BiomeBase[256];
+		public int b;
+		public int c;
+		public long d;
+
+		public a(int i, int j) {
+			this.b = i;
+			this.c = j;
+			BiomeCache.this.a.a(this.a, i << 4, j << 4, 16, 16, false);
+		}
+
+		public BiomeBase a(int i, int j) {
+			return this.a[i & 15 | (j & 15) << 4];
+		}
+	}
 }
diff --git a/src/main/java/net/minecraft/server/BlockStateEnum.java b/src/main/java/net/minecraft/server/BlockStateEnum.java
index 98df79e..6bd8071 100644
--- a/src/main/java/net/minecraft/server/BlockStateEnum.java
+++ b/src/main/java/net/minecraft/server/BlockStateEnum.java
@@ -12,17 +12,17 @@ import java.util.Map;
 
 public class BlockStateEnum<T extends Enum<T> & INamable> extends BlockState<T> {
 
-    private final ImmutableSet<T> a;
-    private final Map<String, T> b = Maps.newHashMap();
-	
+	private final ImmutableSet<T> a;
+	private final Map<String, T> b = Maps.newHashMap();
+
 	boolean hasHashCode = false;
-    int cachedHashCode = 0;
+	int cachedHashCode = 0;
 
 	protected BlockStateEnum(String paramString, Class<T> paramClass, Collection<T> paramCollection) {
 		super(paramString, paramClass);
 		this.a = ImmutableSet.copyOf(paramCollection);
 		for (Enum localEnum : paramCollection) {
-			String str = ((INamable)localEnum).getName();
+			String str = ((INamable) localEnum).getName();
 			if (this.b.containsKey(str)) {
 				throw new IllegalArgumentException("Multiple values have the same name '" + str + "'");
 			}
@@ -30,41 +30,42 @@ public class BlockStateEnum<T extends Enum<T> & INamable> extends BlockState<T>
 		}
 	}
 
-    public Collection<T> c() {
-        return this.a;
-    }
-    public String a(T t0) {
-        return ((INamable) t0).getName();
-    }
-
-    // TacoSpigot start
-    @Override
-    public int getValueId(T value) {
-        return value.ordinal();
-    }
-
-    @Override
-    public T getByValueId(int id) {
-        T[] values = this.b().getEnumConstants();
-        if (id >= 0 && id < values.length) {
-            return values[id];
-        } else {
-            throw new IllegalArgumentException("Invalid id: " + id);
-        }
-    }
-    // TacoSpigot end
-
-    public boolean equals(Object object) {
-        if (this == object) {
-            return true;
-        } else if (object instanceof BlockStateEnum && super.equals(object)) {
-            BlockStateEnum blockstateenum = (BlockStateEnum) object;
-
-            return this.a.equals(blockstateenum.a) && this.b.equals(blockstateenum.b);
-        } else {
-            return false;
-        }
-    }
+	public Collection<T> c() {
+		return this.a;
+	}
+
+	public String a(T t0) {
+		return ((INamable) t0).getName();
+	}
+
+	// TacoSpigot start
+	@Override
+	public int getValueId(T value) {
+		return value.ordinal();
+	}
+
+	@Override
+	public T getByValueId(int id) {
+		T[] values = this.b().getEnumConstants();
+		if (id >= 0 && id < values.length) {
+			return values[id];
+		} else {
+			throw new IllegalArgumentException("Invalid id: " + id);
+		}
+	}
+	// TacoSpigot end
+
+	public boolean equals(Object object) {
+		if (this == object) {
+			return true;
+		} else if (object instanceof BlockStateEnum && super.equals(object)) {
+			BlockStateEnum blockstateenum = (BlockStateEnum) object;
+
+			return this.a.equals(blockstateenum.a) && this.b.equals(blockstateenum.b);
+		} else {
+			return false;
+		}
+	}
 
 	public int hashCode() {
 		if (hasHashCode) {
@@ -77,19 +78,21 @@ public class BlockStateEnum<T extends Enum<T> & INamable> extends BlockState<T>
 		return cachedHashCode = i;
 	}
 
-    public static <T extends Enum<T> & INamable> BlockStateEnum<T> of(String s, Class<T> oclass) {
-        return a(s, oclass, Predicates.alwaysTrue());
-    }
+	public static <T extends Enum<T> & INamable> BlockStateEnum<T> of(String s, Class<T> oclass) {
+		return a(s, oclass, Predicates.alwaysTrue());
+	}
 
-    public static <T extends Enum<T> & INamable> BlockStateEnum<T> a(String s, Class<T> oclass, Predicate<T> predicate) {
-        return a(s, oclass, Collections2.filter(Lists.newArrayList(oclass.getEnumConstants()), predicate));
-    }
+	public static <T extends Enum<T> & INamable> BlockStateEnum<T> a(String s, Class<T> oclass,
+			Predicate<T> predicate) {
+		return a(s, oclass, Collections2.filter(Lists.newArrayList(oclass.getEnumConstants()), predicate));
+	}
 
-    public static <T extends Enum<T> & INamable> BlockStateEnum<T> of(String s, Class<T> oclass, T... at) {
-        return a(s, oclass, (Collection) Lists.newArrayList(at));
-    }
+	public static <T extends Enum<T> & INamable> BlockStateEnum<T> of(String s, Class<T> oclass, T... at) {
+		return a(s, oclass, (Collection) Lists.newArrayList(at));
+	}
 
-    public static <T extends Enum<T> & INamable> BlockStateEnum<T> a(String s, Class<T> oclass, Collection<T> collection) {
-        return new BlockStateEnum(s, oclass, collection);
-    }
+	public static <T extends Enum<T> & INamable> BlockStateEnum<T> a(String s, Class<T> oclass,
+			Collection<T> collection) {
+		return new BlockStateEnum(s, oclass, collection);
+	}
 }
diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java
index c899cbb..7bf1105 100644
--- a/src/main/java/net/minecraft/server/Chunk.java
+++ b/src/main/java/net/minecraft/server/Chunk.java
@@ -25,11 +25,23 @@ import com.google.common.collect.Lists; // CraftBukkit
 import com.google.common.collect.Queues;
 import com.mrpowergamerbr.utils.LightRandom;
 
-
 public class Chunk {
 
-	public final Lock blocksLock; // Paper - Async-Anti-Xray - Locks blocks and sections and is applied before a packet of this chunk or a neighbor-chunk is added to the obfuscation-executor-service on the main-thread until the obfuscator-thread is finished to ensure "single-thread-behavior" and thread-safety
-	public final Lock dataLock; // Paper - Async-Anti-Xray - Locks sky light, emitted light and biome index and is applied before a packet of this chunk is added to the obfuscation-executor-service on the main-thread until the obfuscator-thread is finished to ensure "single-thread-behavior" and thread-safety
+	public final Lock blocksLock; // Paper - Async-Anti-Xray - Locks blocks and
+									// sections and is applied before a packet
+									// of this chunk or a neighbor-chunk is
+									// added to the obfuscation-executor-service
+									// on the main-thread until the
+									// obfuscator-thread is finished to ensure
+									// "single-thread-behavior" and
+									// thread-safety
+	public final Lock dataLock; // Paper - Async-Anti-Xray - Locks sky light,
+								// emitted light and biome index and is applied
+								// before a packet of this chunk is added to the
+								// obfuscation-executor-service on the
+								// main-thread until the obfuscator-thread is
+								// finished to ensure "single-thread-behavior"
+								// and thread-safety
 	private static final Logger e = LogManager.getLogger();
 	public static final ChunkSection a = null;
 	private final ChunkSection[] sections;
@@ -120,8 +132,12 @@ public class Chunk {
 		// this.entitySlices = (Queue[]) (new ConcurrentLinkedQueue[16]); //
 		// Hose
 		this.world = world;
-		this.blocksLock = this.world.blockPacketController.getChunkBlocksLock(this); // Paper - Async-Anti-Xray
-		this.dataLock = this.world.blockPacketController.getChunkDataLock(this); // Paper - Async-Anti-Xray
+		this.blocksLock = this.world.blockPacketController.getChunkBlocksLock(this); // Paper
+																						// -
+																						// Async-Anti-Xray
+		this.dataLock = this.world.blockPacketController.getChunkDataLock(this); // Paper
+																					// -
+																					// Async-Anti-Xray
 		this.locX = i;
 		this.locZ = j;
 		this.chunkKey = org.bukkit.craftbukkit.util.LongHash.toLong(this.locX, this.locZ); // Paper
@@ -157,7 +173,19 @@ public class Chunk {
 
 						if (this.sections[j1] == Chunk.a) {
 							///
-                            this.sections[j1] = new ChunkSection(j1 << 4, flag, world.blockPacketController.getPredefinedBlockData(this, j1)); // Paper - Anti-Xray - Add blocks used for obfuscation to the DataPalette
+							this.sections[j1] = new ChunkSection(j1 << 4, flag,
+									world.blockPacketController.getPredefinedBlockData(this, j1)); // Paper
+																									// -
+																									// Anti-Xray
+																									// -
+																									// Add
+																									// blocks
+																									// used
+																									// for
+																									// obfuscation
+																									// to
+																									// the
+																									// DataPalette
 							///
 						}
 
@@ -201,16 +229,17 @@ public class Chunk {
 	public ChunkSection[] getSections() {
 		return this.sections;
 	}
-	
+
 	public class LightingTask extends RecursiveAction {
-		LightingTask() {}
+		LightingTask() {
+		}
 
 		@Override
 		protected void compute() {
 			initLighting_task();
 		}
 	}
-	
+
 	public void initLighting() {
 		LightingTask task = new LightingTask();
 		task.fork();
@@ -544,8 +573,20 @@ public class Chunk {
 				}
 
 				///
-				chunksection = this.sections[j >> 4] = new ChunkSection(j >> 4 << 4, !this.world.worldProvider.m(), this.world.blockPacketController.getPredefinedBlockData(this, j >> 4)); // Paper - Anti-Xray - Add blocks used for obfuscation to the DataPalette
-                this.blocksLock.waitUntilUnlock();
+				chunksection = this.sections[j >> 4] = new ChunkSection(j >> 4 << 4, !this.world.worldProvider.m(),
+						this.world.blockPacketController.getPredefinedBlockData(this, j >> 4)); // Paper
+																								// -
+																								// Anti-Xray
+																								// -
+																								// Add
+																								// blocks
+																								// used
+																								// for
+																								// obfuscation
+																								// to
+																								// the
+																								// DataPalette
+				this.blocksLock.waitUntilUnlock();
 				///
 				flag = j >= i1;
 			}
@@ -639,7 +680,19 @@ public class Chunk {
 
 		if (chunksection == Chunk.a) {
 			///
-            chunksection = this.sections[k >> 4] = new ChunkSection(k >> 4 << 4, !this.world.worldProvider.m(), this.world.blockPacketController.getPredefinedBlockData(this, k >> 4)); // Paper - Anti-Xray - Add blocks used for obfuscation to the DataPalette
+			chunksection = this.sections[k >> 4] = new ChunkSection(k >> 4 << 4, !this.world.worldProvider.m(),
+					this.world.blockPacketController.getPredefinedBlockData(this, k >> 4)); // Paper
+																							// -
+																							// Anti-Xray
+																							// -
+																							// Add
+																							// blocks
+																							// used
+																							// for
+																							// obfuscation
+																							// to
+																							// the
+																							// DataPalette
 			this.blocksLock.waitUntilUnlock();
 			///
 			this.initLighting();
diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java
index 4058fc5..9237bbf 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java
@@ -5,7 +5,9 @@ import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.concurrent.Callable;
 import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ForkJoinTask;
 
 import javax.annotation.Nullable;
 
@@ -14,6 +16,7 @@ import org.apache.logging.log4j.Logger;
 import org.bukkit.craftbukkit.chunkio.ChunkIOExecutor;
 import org.bukkit.event.world.ChunkUnloadEvent;
 // CraftBukkit end
+import org.spigotmc.SpigotWorldConfig;
 
 import com.destroystokyo.paper.exception.ServerInternalException;
 
@@ -33,25 +36,17 @@ public class ChunkProviderServer implements IChunkProvider {
 	protected Chunk lastChunkByPos = null;
 
 	/*
-	public Long2ObjectOpenHashMap<Chunk> chunks = new Long2ObjectOpenHashMap<Chunk>(8192) {
-
-		@Override
-		public Chunk get(long key) {
-			if (lastChunkByPos != null && key == lastChunkByPos.chunkKey) {
-				return lastChunkByPos;
-			}
-			return lastChunkByPos = super.get(key);
-		}
-
-		@Override
-		public Chunk remove(long key) {
-			if (lastChunkByPos != null && key == lastChunkByPos.chunkKey) {
-				lastChunkByPos = null;
-			}
-			return super.remove(key);
-		}
-	}; // CraftBukkit
-	*/
+	 * public Long2ObjectOpenHashMap<Chunk> chunks = new
+	 * Long2ObjectOpenHashMap<Chunk>(8192) {
+	 * 
+	 * @Override public Chunk get(long key) { if (lastChunkByPos != null && key
+	 * == lastChunkByPos.chunkKey) { return lastChunkByPos; } return
+	 * lastChunkByPos = super.get(key); }
+	 * 
+	 * @Override public Chunk remove(long key) { if (lastChunkByPos != null &&
+	 * key == lastChunkByPos.chunkKey) { lastChunkByPos = null; } return
+	 * super.remove(key); } }; // CraftBukkit
+	 */
 
 	// Paper end
 	public final WorldServer world;
@@ -131,15 +126,6 @@ public class ChunkProviderServer implements IChunkProvider {
 			 */ // Paper
 			synchronized (this) {
 				chunk = ChunkIOExecutor.syncChunkLoad(world, chunkLoader, this, i, j); // Paper
-																						// -
-																						// skip
-																						// chunkExists,
-																						// expensive
-																						// and
-																						// performed
-																						// by
-																						// loading
-																						// anyway.
 			}
 		}
 
@@ -154,7 +140,9 @@ public class ChunkProviderServer implements IChunkProvider {
 		if (chunk == null) {
 			chunk = this.loadChunk(i, j);
 			if (chunk != null) {
-				synchronized(this) { this.chunks.put(ChunkCoordIntPair.a(i, j), chunk); }
+				synchronized (this) {
+					this.chunks.put(ChunkCoordIntPair.a(i, j), chunk);
+				}
 				chunk.addEntities();
 				chunk.loadNearby(this, this.chunkGenerator, false); // CraftBukkit
 			}
@@ -204,6 +192,21 @@ public class ChunkProviderServer implements IChunkProvider {
 		return chunk;
 	}
 
+	class originalOrCreateChunk implements Callable<Chunk> {
+		int i, j;
+
+		originalOrCreateChunk(int i, int j) {
+			this.i = i;
+			this.j = j;
+		}
+
+		@Override
+		public Chunk call() throws Exception {
+			return chunkGenerator.getOrCreateChunk(i, j);
+		}
+
+	}
+
 	public Chunk originalGetChunkAt(int i, int j) {
 		Chunk chunk = this.originalGetOrLoadChunkAt(i, j);
 		if (chunk == null) {
@@ -211,7 +214,10 @@ public class ChunkProviderServer implements IChunkProvider {
 			long k = ChunkCoordIntPair.a(i, j);
 
 			try {
-				chunk = this.chunkGenerator.getOrCreateChunk(i, j);
+				// chunk = this.chunkGenerator.getOrCreateChunk(i, j);
+				SpigotWorldConfig.ChunkTask = ForkJoinTask.adapt(new originalOrCreateChunk(i, j));
+				SpigotWorldConfig.ChunkPool.submit(SpigotWorldConfig.ChunkTask);
+				chunk = SpigotWorldConfig.ChunkTask.get();
 			} catch (Throwable throwable) {
 				CrashReport crashreport = CrashReport.a(throwable, "Exception generating new chunk");
 				CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Chunk to be generated");
@@ -223,7 +229,9 @@ public class ChunkProviderServer implements IChunkProvider {
 				throw new ReportedException(crashreport);
 			}
 
-			synchronized(this) { this.chunks.put(k, chunk); }
+			synchronized (this) {
+				this.chunks.put(k, chunk);
+			}
 			chunk.addEntities();
 
 			chunk.loadNearby(this, this.chunkGenerator, true); // CraftBukkit
@@ -383,7 +391,9 @@ public class ChunkProviderServer implements IChunkProvider {
 			this.saveChunk(chunk);
 			this.saveChunkNOP(chunk);
 		}
-		synchronized(this) { this.chunks.remove(chunk.chunkKey); }
+		synchronized (this) {
+			this.chunks.remove(chunk.chunkKey);
+		}
 		return true;
 	}
 	// CraftBukkit end
diff --git a/src/main/java/net/minecraft/server/ChunkRegionLoader.java b/src/main/java/net/minecraft/server/ChunkRegionLoader.java
index 8eea856..ca90b89 100644
--- a/src/main/java/net/minecraft/server/ChunkRegionLoader.java
+++ b/src/main/java/net/minecraft/server/ChunkRegionLoader.java
@@ -418,7 +418,19 @@ public class ChunkRegionLoader implements IChunkLoader, IAsyncChunkSaver {
 			NBTTagCompound nbttagcompound1 = nbttaglist.get(k);
 			byte b1 = nbttagcompound1.getByte("Y");
 			///
-			ChunkSection chunksection = new ChunkSection(b1 << 4, flag, world.blockPacketController.getPredefinedBlockData(chunk, b1)); // Paper - Anti-Xray - Add blocks used for obfuscation to the DataPalette
+			ChunkSection chunksection = new ChunkSection(b1 << 4, flag,
+					world.blockPacketController.getPredefinedBlockData(chunk, b1)); // Paper
+																					// -
+																					// Anti-Xray
+																					// -
+																					// Add
+																					// blocks
+																					// used
+																					// for
+																					// obfuscation
+																					// to
+																					// the
+																					// DataPalette
 			///
 			byte[] abyte = nbttagcompound1.getByteArray("Blocks");
 			NibbleArray nibblearray = new NibbleArray(nbttagcompound1.getByteArray("Data"));
diff --git a/src/main/java/net/minecraft/server/Container.java b/src/main/java/net/minecraft/server/Container.java
index a6449a1..6db9b54 100644
--- a/src/main/java/net/minecraft/server/Container.java
+++ b/src/main/java/net/minecraft/server/Container.java
@@ -89,7 +89,9 @@ public abstract class Container {
 			ItemStack itemstack = this.c.get(i).getItem();
 			ItemStack itemstack1 = this.b.get(i);
 
-			if (!ItemStack.fastMatches(itemstack1, itemstack) || (tickCount % org.spigotmc.SpigotConfig.itemDirtyTicks == 0 && !ItemStack.matches(itemstack1, itemstack))) { // Spigot
+			if (!ItemStack.fastMatches(itemstack1, itemstack)
+					|| (tickCount % org.spigotmc.SpigotConfig.itemDirtyTicks == 0
+							&& !ItemStack.matches(itemstack1, itemstack))) { // Spigot
 				itemstack1 = itemstack == null ? null : itemstack.cloneItemStack();
 				this.b.set(i, itemstack1);
 
@@ -99,7 +101,7 @@ public abstract class Container {
 			}
 		}
 
-	tickCount++; // Spigot
+		tickCount++; // Spigot
 	}
 
 	public boolean a(EntityHuman entityhuman, int i) {
diff --git a/src/main/java/net/minecraft/server/DataBits.java b/src/main/java/net/minecraft/server/DataBits.java
index c34316b..437e349 100644
--- a/src/main/java/net/minecraft/server/DataBits.java
+++ b/src/main/java/net/minecraft/server/DataBits.java
@@ -34,7 +34,8 @@ public class DataBits {
 
 	}
 
-	// Paper start - Anti-Xray - Add methods used inside the obfuscator loop to set fake-blocks to data
+	// Paper start - Anti-Xray - Add methods used inside the obfuscator loop to
+	// set fake-blocks to data
 	public long obfuscate(int blockIndex, int bits, long data) { // Paper
 		int j1 = (blockIndex * this.b) % 64;
 		return data & ~(this.c << j1) | (bits & this.c) << j1;
diff --git a/src/main/java/net/minecraft/server/DataPaletteBlock.java b/src/main/java/net/minecraft/server/DataPaletteBlock.java
index 3b113b2..1dab5bd 100644
--- a/src/main/java/net/minecraft/server/DataPaletteBlock.java
+++ b/src/main/java/net/minecraft/server/DataPaletteBlock.java
@@ -21,7 +21,8 @@ public class DataPaletteBlock implements DataPaletteExpandable {
 	// Paper start - Anti-Xray - Modified constructor
 	public DataPaletteBlock(@Nullable IBlockData[] predefinedBlockData) { // Paper
 		this.predefinedBlockData = predefinedBlockData;
-		if (predefinedBlockData == null) { // Paper - Anti-Xray - default constructor
+		if (predefinedBlockData == null) { // Paper - Anti-Xray - default
+											// constructor
 			this.currentPredefinedBlockData = null;
 			this.b(4);
 		} else {
@@ -32,7 +33,9 @@ public class DataPaletteBlock implements DataPaletteExpandable {
 				maxIndex >>= 1;
 				bitCount++;
 			}
-			this.b(bitCount == 0 ? 4 : bitCount); // Paper - Anti-Xray - initialize a DataPalette with bitCount
+			this.b(bitCount == 0 ? 4 : bitCount); // Paper - Anti-Xray -
+													// initialize a DataPalette
+													// with bitCount
 		}
 	}
 	// Paper end
diff --git a/src/main/java/net/minecraft/server/EntityFallingBlock.java b/src/main/java/net/minecraft/server/EntityFallingBlock.java
index b5069df..fb42b80 100644
--- a/src/main/java/net/minecraft/server/EntityFallingBlock.java
+++ b/src/main/java/net/minecraft/server/EntityFallingBlock.java
@@ -79,7 +79,9 @@ public class EntityFallingBlock extends Entity {
 				if (this.world.getType(blockposition).getBlock() == block && !CraftEventFactory
 						.callEntityChangeBlockEvent(this, blockposition, Blocks.AIR, 0).isCancelled()) {
 					this.world.setAir(blockposition);
-					this.world.blockPacketController.updateNearbyBlocks(this.world, blockposition); // Paper - Anti-Xray
+					this.world.blockPacketController.updateNearbyBlocks(this.world, blockposition); // Paper
+																									// -
+																									// Anti-Xray
 				} else if (!this.world.isClientSide) {
 					this.die();
 					return;
@@ -129,7 +131,9 @@ public class EntityFallingBlock extends Entity {
 									return;
 								}
 								this.world.setTypeAndData(blockposition, this.block, 3);
-								this.world.blockPacketController.updateNearbyBlocks(this.world, blockposition); // Paper - Anti-Xray
+								this.world.blockPacketController.updateNearbyBlocks(this.world, blockposition); // Paper
+																												// -
+																												// Anti-Xray
 								// CraftBukkit end
 								if (block instanceof BlockFalling) {
 									((BlockFalling) block).a_(this.world, blockposition);
diff --git a/src/main/java/net/minecraft/server/EntityInsentient.java b/src/main/java/net/minecraft/server/EntityInsentient.java
index 4b06fef..49e93e7 100644
--- a/src/main/java/net/minecraft/server/EntityInsentient.java
+++ b/src/main/java/net/minecraft/server/EntityInsentient.java
@@ -713,10 +713,18 @@ public abstract class EntityInsentient extends EntityLiving {
 		this.targetSelector.a();
 		this.world.methodProfiler.b();
 		this.world.methodProfiler.a("goalSelector");
-		this.goalSelector.a();
+		try {
+			this.goalSelector.a();
+		} catch (Exception ex) {
+			;
+		}
 		this.world.methodProfiler.b();
 		this.world.methodProfiler.a("navigation");
-		this.navigation.l();
+		try {
+			this.navigation.l();
+		} catch (Exception ex) {
+			;
+		}
 		this.world.methodProfiler.b();
 		this.world.methodProfiler.a("mob tick");
 		this.M();
diff --git a/src/main/java/net/minecraft/server/EntityTracker.java b/src/main/java/net/minecraft/server/EntityTracker.java
index c3ec7fe..94d7b94 100644
--- a/src/main/java/net/minecraft/server/EntityTracker.java
+++ b/src/main/java/net/minecraft/server/EntityTracker.java
@@ -2,12 +2,14 @@ package net.minecraft.server;
 
 import java.util.ArrayList;
 import java.util.Iterator;
+import java.util.Map;
 import java.util.Set;
 
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
 import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 
 public class EntityTracker {
@@ -15,7 +17,7 @@ public class EntityTracker {
 	private static final Logger a = LogManager.getLogger();
 	private final WorldServer world;
 	private final Set<EntityTrackerEntry> c = Sets.newConcurrentHashSet();
-	public IntHashMap<EntityTrackerEntry> trackedEntities = new IntHashMap();
+	public final Map<Integer, EntityTrackerEntry> trackedEntities = Maps.newConcurrentMap();
 	private int e;
 
 	public EntityTracker(WorldServer worldserver) {
@@ -105,11 +107,11 @@ public class EntityTracker {
 	}
 
 	public void addEntity(Entity entity, int i, final int j, boolean flag) {
-		// org.spigotmc.AsyncCatcher.catchOp( "entity track"); // Spigot
+		org.spigotmc.AsyncCatcher.catchOp("entity track"); // Spigot
 		i = org.spigotmc.TrackingRange.getEntityTrackingRange(entity, i); // Spigot
 		try {
-			if (this.trackedEntities.b(entity.getId())) {
-				throw new IllegalStateException("Entity is already tracked!");
+			if (this.trackedEntities.containsKey(entity.getId())) {
+				;
 			}
 
 			EntityTrackerEntry entitytrackerentry = new EntityTrackerEntry(entity, i, this.e, j, flag);
@@ -117,7 +119,7 @@ public class EntityTracker {
 			synchronized (this.c) { // Migot
 				this.c.add(entitytrackerentry);
 			}
-			this.trackedEntities.a(entity.getId(), entitytrackerentry);
+			this.trackedEntities.put(entity.getId(), entitytrackerentry);
 			entitytrackerentry.scanPlayers(this.world.players);
 		} catch (Throwable throwable) {
 			CrashReport crashreport = CrashReport.a(throwable, "Adding entity to track");
@@ -170,7 +172,7 @@ public class EntityTracker {
 			}
 		}
 
-		EntityTrackerEntry entitytrackerentry1 = this.trackedEntities.d(entity.getId());
+		EntityTrackerEntry entitytrackerentry1 = this.trackedEntities.remove(entity.getId());
 
 		if (entitytrackerentry1 != null) {
 			synchronized (this.c) { // Migot
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index d6638b6..2c776dc 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -1051,10 +1051,9 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
 		this.methodProfiler.c("tickables");
 
 		MinecraftTimings.tickablesTimer.startTiming(); // Spigot
-		Iterator it = this.o.iterator();
-		while (it.hasNext()) {
-			((ITickable) it.next()).c(); // Torch
-		}
+		this.o.parallelStream().forEach(it -> {
+			((ITickable) it).c();
+		});
 		MinecraftTimings.tickablesTimer.stopTiming(); // Spigot
 
 		this.methodProfiler.b();
diff --git a/src/main/java/net/minecraft/server/MobSpawnerAbstract.java b/src/main/java/net/minecraft/server/MobSpawnerAbstract.java
index e3d0a05..edfa08c 100644
--- a/src/main/java/net/minecraft/server/MobSpawnerAbstract.java
+++ b/src/main/java/net/minecraft/server/MobSpawnerAbstract.java
@@ -44,88 +44,107 @@ public abstract class MobSpawnerAbstract {
 
 	// Torch start
 	public void c() {
-        // Paper start - Configurable mob spawner tick rate
-        if (spawnDelay > 0 && --tickDelay > 0) return;
-        tickDelay = this.a().paperConfig.mobSpawnerTickRate;
-        // Paper end
-		
-        if (!this.h()) {
-            this.e = this.d;
-        } else {
-            BlockPosition blockposition = this.b();
-
-            if (this.a().isClientSide) {
-                double d0 = (double) ((float) blockposition.getX() + this.a().random.nextFloat());
-                double d1 = (double) ((float) blockposition.getY() + this.a().random.nextFloat());
-                double d2 = (double) ((float) blockposition.getZ() + this.a().random.nextFloat());
-
-                this.a().addParticle(EnumParticle.SMOKE_NORMAL, d0, d1, d2, 0.0D, 0.0D, 0.0D, new int[0]);
-                this.a().addParticle(EnumParticle.FLAME, d0, d1, d2, 0.0D, 0.0D, 0.0D, new int[0]);
-                if (this.spawnDelay > 0) {
-                    this.spawnDelay -= tickDelay; // Paper
-                }
-
-                this.e = this.d;
-                this.d = (this.d + (double) (1000.0F / ((float) this.spawnDelay + 200.0F))) % 360.0D;
-            } else {
-                if (this.spawnDelay < -tickDelay) { // Paper
-                    this.i();
-                }
-
-                if (this.spawnDelay > 0) {
-                    this.spawnDelay -= tickDelay; // Paper
-                    return;
-                }
-
-                for (int i = 0; i < this.spawnCount; ++i) {
-                    NBTTagCompound nbttagcompound = this.spawnData.b();
-                    NBTTagList nbttaglist = nbttagcompound.getList("Pos", 6);
-                    World world = this.a();
-                    int j = nbttaglist.size();
-                    double d3 = j >= 1 ? nbttaglist.e(0) : (double) blockposition.getX() + (world.random.nextDouble() - world.random.nextDouble()) * (double) this.spawnRange + 0.5D;
-                    double d4 = j >= 2 ? nbttaglist.e(1) : (double) (blockposition.getY() + world.random.nextInt(3) - 1);
-                    double d5 = j >= 3 ? nbttaglist.e(2) : (double) blockposition.getZ() + (world.random.nextDouble() - world.random.nextDouble()) * (double) this.spawnRange + 0.5D;
-                    Entity entity = ChunkRegionLoader.a(nbttagcompound, world, d3, d4, d5, false);
-
-                    if (entity == null) {
-                        return;
-                    }
-
-                    int k = world.a(entity.getClass(), (new AxisAlignedBB((double) blockposition.getX(), (double) blockposition.getY(), (double) blockposition.getZ(), (double) (blockposition.getX() + 1), (double) (blockposition.getY() + 1), (double) (blockposition.getZ() + 1))).g((double) this.spawnRange)).size();
-
-                    if (k >= this.maxNearbyEntities) {
-                        this.i();
-                        return;
-                    }
-
-                    EntityInsentient entityinsentient = entity instanceof EntityInsentient ? (EntityInsentient) entity : null;
-
-                    entity.setPositionRotation(entity.locX, entity.locY, entity.locZ, world.random.nextFloat() * 360.0F, 0.0F);
-                    if (entityinsentient == null || entityinsentient.cG() && entityinsentient.canSpawn()) {
-                        if (this.spawnData.b().d() == 1 && this.spawnData.b().hasKeyOfType("id", 8) && entity instanceof EntityInsentient) {
-                            ((EntityInsentient) entity).prepare(world.D(new BlockPosition(entity)), (GroupDataEntity) null);
-                        }
+		// Paper start - Configurable mob spawner tick rate
+		if (spawnDelay > 0 && --tickDelay > 0)
+			return;
+		tickDelay = this.a().paperConfig.mobSpawnerTickRate;
+		// Paper end
+
+		if (!this.h()) {
+			this.e = this.d;
+		} else {
+			BlockPosition blockposition = this.b();
+
+			if (this.a().isClientSide) {
+				double d0 = (double) ((float) blockposition.getX() + this.a().random.nextFloat());
+				double d1 = (double) ((float) blockposition.getY() + this.a().random.nextFloat());
+				double d2 = (double) ((float) blockposition.getZ() + this.a().random.nextFloat());
+
+				this.a().addParticle(EnumParticle.SMOKE_NORMAL, d0, d1, d2, 0.0D, 0.0D, 0.0D, new int[0]);
+				this.a().addParticle(EnumParticle.FLAME, d0, d1, d2, 0.0D, 0.0D, 0.0D, new int[0]);
+				if (this.spawnDelay > 0) {
+					this.spawnDelay -= tickDelay; // Paper
+				}
+
+				this.e = this.d;
+				this.d = (this.d + (double) (1000.0F / ((float) this.spawnDelay + 200.0F))) % 360.0D;
+			} else {
+				if (this.spawnDelay < -tickDelay) { // Paper
+					this.i();
+				}
+
+				if (this.spawnDelay > 0) {
+					this.spawnDelay -= tickDelay; // Paper
+					return;
+				}
+
+				for (int i = 0; i < this.spawnCount; ++i) {
+					NBTTagCompound nbttagcompound = this.spawnData.b();
+					NBTTagList nbttaglist = nbttagcompound.getList("Pos", 6);
+					World world = this.a();
+					int j = nbttaglist.size();
+					double d3 = j >= 1 ? nbttaglist.e(0)
+							: (double) blockposition.getX()
+									+ (world.random.nextDouble() - world.random.nextDouble()) * (double) this.spawnRange
+									+ 0.5D;
+					double d4 = j >= 2 ? nbttaglist.e(1)
+							: (double) (blockposition.getY() + world.random.nextInt(3) - 1);
+					double d5 = j >= 3 ? nbttaglist.e(2)
+							: (double) blockposition.getZ()
+									+ (world.random.nextDouble() - world.random.nextDouble()) * (double) this.spawnRange
+									+ 0.5D;
+					Entity entity = ChunkRegionLoader.a(nbttagcompound, world, d3, d4, d5, false);
+
+					if (entity == null) {
+						return;
+					}
+
+					int k = world.a(entity.getClass(),
+							(new AxisAlignedBB((double) blockposition.getX(), (double) blockposition.getY(),
+									(double) blockposition.getZ(), (double) (blockposition.getX() + 1),
+									(double) (blockposition.getY() + 1), (double) (blockposition.getZ() + 1)))
+											.g((double) this.spawnRange))
+							.size();
+
+					if (k >= this.maxNearbyEntities) {
+						this.i();
+						return;
+					}
+
+					EntityInsentient entityinsentient = entity instanceof EntityInsentient ? (EntityInsentient) entity
+							: null;
+
+					entity.setPositionRotation(entity.locX, entity.locY, entity.locZ, world.random.nextFloat() * 360.0F,
+							0.0F);
+					if (entityinsentient == null || entityinsentient.cG() && entityinsentient.canSpawn()) {
+						if (this.spawnData.b().d() == 1 && this.spawnData.b().hasKeyOfType("id", 8)
+								&& entity instanceof EntityInsentient) {
+							((EntityInsentient) entity).prepare(world.D(new BlockPosition(entity)),
+									(GroupDataEntity) null);
+						}
 						// Spigot Start
 						if (entity.world.spigotConfig.nerfSpawnerMobs) {
 							entity.fromMobSpawner = true;
 						}
-                        if (org.bukkit.craftbukkit.event.CraftEventFactory.callSpawnerSpawnEvent(entity, blockposition).isCancelled()) {
-                            continue;
-                        }
+						if (org.bukkit.craftbukkit.event.CraftEventFactory.callSpawnerSpawnEvent(entity, blockposition)
+								.isCancelled()) {
+							continue;
+						}
 						// Spigot End
-                        ChunkRegionLoader.a(entity, world, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.SPAWNER); // CraftBukkit
-                        world.triggerEffect(2004, blockposition, 0);
-                        if (entityinsentient != null) {
-                            entityinsentient.doSpawnEffect();
-                        }
-                    }
-                }
-
-                this.i();
-            }
-
-        }
-    }
+						ChunkRegionLoader.a(entity, world,
+								org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.SPAWNER); // CraftBukkit
+						world.triggerEffect(2004, blockposition, 0);
+						if (entityinsentient != null) {
+							entityinsentient.doSpawnEffect();
+						}
+					}
+				}
+
+				this.i();
+			}
+
+		}
+	}
 	// Torch end
 
 	private void i() {
diff --git a/src/main/java/net/minecraft/server/NBTCompressedStreamTools.java b/src/main/java/net/minecraft/server/NBTCompressedStreamTools.java
index 0dca353..598c412 100644
--- a/src/main/java/net/minecraft/server/NBTCompressedStreamTools.java
+++ b/src/main/java/net/minecraft/server/NBTCompressedStreamTools.java
@@ -73,7 +73,7 @@ public class NBTCompressedStreamTools {
 			nbtbase.write(dataoutput);
 		}
 	}
-	
+
 	private static NBTBase a(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) throws IOException {
 		byte b0 = datainput.readByte();
 
diff --git a/src/main/java/net/minecraft/server/NBTTagCompound.java b/src/main/java/net/minecraft/server/NBTTagCompound.java
index c02941f..b30c816 100644
--- a/src/main/java/net/minecraft/server/NBTTagCompound.java
+++ b/src/main/java/net/minecraft/server/NBTTagCompound.java
@@ -398,7 +398,7 @@ public class NBTTagCompound extends NBTBase {
 	private static String b(DataInput datainput, NBTReadLimiter nbtreadlimiter) throws IOException {
 		return datainput.readUTF();
 	}
-	
+
 	static NBTBase a(byte b0, String s, DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) throws IOException {
 		NBTBase nbtbase = NBTBase.createTag(b0);
 
diff --git a/src/main/java/net/minecraft/server/NavigationListener.java b/src/main/java/net/minecraft/server/NavigationListener.java
index 3c08385..c824461 100644
--- a/src/main/java/net/minecraft/server/NavigationListener.java
+++ b/src/main/java/net/minecraft/server/NavigationListener.java
@@ -2,14 +2,16 @@ package net.minecraft.server;
 
 import java.util.List;
 import java.util.Map.Entry;
+import java.util.Queue;
 
 import javax.annotation.Nullable;
 
+import com.google.common.collect.Queues;
 import com.googlecode.concurrentlinkedhashmap.ConcurrentLinkedHashMap; // Torch
 
 public class NavigationListener implements IWorldAccess {
 
-	private final List<NavigationAbstract> a = new org.torch.util.ConcurrentIterableArrayList<NavigationAbstract>();
+	private final Queue<NavigationAbstract> a = Queues.newConcurrentLinkedQueue();
 
 	public NavigationListener() {
 	}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutMapChunk.java b/src/main/java/net/minecraft/server/PacketPlayOutMapChunk.java
index f797800..d020509 100644
--- a/src/main/java/net/minecraft/server/PacketPlayOutMapChunk.java
+++ b/src/main/java/net/minecraft/server/PacketPlayOutMapChunk.java
@@ -38,7 +38,9 @@ public class PacketPlayOutMapChunk implements Packet<PacketListenerPlayOut> {
 
 		this.d = new byte[this.a(chunk, flag, i)];
 		// this.c = this.a(new PacketDataSerializer(this.g()), chunk, flag, i);
-		chunk.world.blockPacketController.createPacket(this, new PacketDataSerializer(this.g()), chunk, flag, i); // Paper - Async-Anti-Xray
+		chunk.world.blockPacketController.createPacket(this, new PacketDataSerializer(this.g()), chunk, flag, i); // Paper
+																													// -
+																													// Async-Anti-Xray
 		this.e = Lists.newArrayList();
 		Iterator iterator = chunk.getTileEntities().entrySet().iterator();
 
@@ -189,8 +191,24 @@ public class PacketPlayOutMapChunk implements Packet<PacketListenerPlayOut> {
 
 			if (chunksection != Chunk.a && (!this.e() || !chunksection.a()) && (i & 1 << k) != 0) {
 				j |= 1 << k;
-				// chunksection.getBlocks().b(packetdataserializer); // Paper - Anti-Xray - Call writeBlocks instead
-                chunksection.getBlocks().writeBlocks(packetdataserializer, chunk, k, nearbyChunks); // Paper - (Async-)Anti-Xray - Call this method instead (with nearbyChunks as parameter for the async part)
+				// chunksection.getBlocks().b(packetdataserializer); // Paper -
+				// Anti-Xray - Call writeBlocks instead
+				chunksection.getBlocks().writeBlocks(packetdataserializer, chunk, k, nearbyChunks); // Paper
+																									// -
+																									// (Async-)Anti-Xray
+																									// -
+																									// Call
+																									// this
+																									// method
+																									// instead
+																									// (with
+																									// nearbyChunks
+																									// as
+																									// parameter
+																									// for
+																									// the
+																									// async
+																									// part)
 				packetdataserializer.writeBytes(chunksection.getEmittedLightArray().asBytes());
 				if (flag) {
 					packetdataserializer.writeBytes(chunksection.getSkyLightArray().asBytes());
@@ -199,7 +217,7 @@ public class PacketPlayOutMapChunk implements Packet<PacketListenerPlayOut> {
 		}
 
 		if (this.e()) {
-			synchronized(this) {
+			synchronized (this) {
 				packetdataserializer.writeBytes(chunk.getBiomeIndex());
 			}
 		}
diff --git a/src/main/java/net/minecraft/server/PacketStatusListener.java b/src/main/java/net/minecraft/server/PacketStatusListener.java
index c8f43cd..0155447 100644
--- a/src/main/java/net/minecraft/server/PacketStatusListener.java
+++ b/src/main/java/net/minecraft/server/PacketStatusListener.java
@@ -23,11 +23,11 @@ public class PacketStatusListener implements PacketStatusInListener {
 		this.minecraftServer = minecraftserver;
 		this.networkManager = networkmanager;
 	}
-	
+
 	@Override
 	public void a(IChatBaseComponent ichatbasecomponent) {
 	}
-	
+
 	class StatusTask extends RecursiveAction {
 		PacketStatusInStart packetstatusinstart;
 
@@ -51,7 +51,7 @@ public class PacketStatusListener implements PacketStatusInListener {
 			a_task(packetstatusinstart);
 		}
 	}
-	
+
 	public void a_task(PacketStatusInStart packetstatusinstart) {
 		if (this.d) {
 			this.networkManager.close(PacketStatusListener.a);
@@ -67,7 +67,7 @@ public class PacketStatusListener implements PacketStatusInListener {
 
 				ServerListPingEvent() {
 					super(((InetSocketAddress) networkManager.getSocketAddress()).getAddress(),
-minecraftServer.getMotd(), minecraftServer.getPlayerList().getMaxPlayers(), networkManager);
+							minecraftServer.getMotd(), minecraftServer.getPlayerList().getMaxPlayers(), networkManager);
 				}
 
 				@Override
diff --git a/src/main/java/net/minecraft/server/PersistentVillage.java b/src/main/java/net/minecraft/server/PersistentVillage.java
index 9060b7d..5709460 100644
--- a/src/main/java/net/minecraft/server/PersistentVillage.java
+++ b/src/main/java/net/minecraft/server/PersistentVillage.java
@@ -1,5 +1,6 @@
 package net.minecraft.server;
 
+import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
 
@@ -8,7 +9,7 @@ import com.google.common.collect.Lists;
 public class PersistentVillage extends PersistentBase {
 
 	private World world;
-	private final List<BlockPosition> c = Lists.newArrayList();
+	private final List<BlockPosition> c = Collections.synchronizedList(Lists.newArrayList());
 	private final List<VillageDoor> d = Lists.newArrayList();
 	private final List<Village> villages = Lists.newArrayList();
 	private int time;
diff --git a/src/main/java/net/minecraft/server/PlayerChunk.java b/src/main/java/net/minecraft/server/PlayerChunk.java
index 2bdb18e..7c7b59d 100644
--- a/src/main/java/net/minecraft/server/PlayerChunk.java
+++ b/src/main/java/net/minecraft/server/PlayerChunk.java
@@ -147,7 +147,31 @@ public class PlayerChunk {
 			return false;
 		} else if (!this.chunk.isReady()) {
 			return false;
-		} else if (!this.chunk.world.blockPacketController.onPacketCreate(this.chunk, '\uffff')) { // Paper - Anti-Xray - Nearby chunks should be loaded before creating the packet to make the obfuscation of the chunk-edges possible (depending on anti-xray settings)
+		} else if (!this.chunk.world.blockPacketController.onPacketCreate(this.chunk, '\uffff')) { // Paper
+																									// -
+																									// Anti-Xray
+																									// -
+																									// Nearby
+																									// chunks
+																									// should
+																									// be
+																									// loaded
+																									// before
+																									// creating
+																									// the
+																									// packet
+																									// to
+																									// make
+																									// the
+																									// obfuscation
+																									// of
+																									// the
+																									// chunk-edges
+																									// possible
+																									// (depending
+																									// on
+																									// anti-xray
+																									// settings)
 			return false; // Paper - Anti-Xray - If the nearby chunks are not
 							// loaded and should be loaded first, return false
 							// so that this method is called again
diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java
index ed5ed4f..81df9d5 100644
--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java
@@ -432,7 +432,7 @@ public class PlayerChunkMap {
 	public final void setViewDistanceForAll(int viewDistance) {
 		this.a(viewDistance);
 	} // Paper - OBFHELPER
-	// Paper start - Separate into two methods
+		// Paper start - Separate into two methods
 
 	public void a(int i) {
 		i = MathHelper.clamp(i, 3, 32);
diff --git a/src/main/java/net/minecraft/server/PlayerConnection.java b/src/main/java/net/minecraft/server/PlayerConnection.java
index 4d67ba9..04d86e8 100644
--- a/src/main/java/net/minecraft/server/PlayerConnection.java
+++ b/src/main/java/net/minecraft/server/PlayerConnection.java
@@ -1231,7 +1231,7 @@ public class PlayerConnection implements PacketListenerPlayIn, ITickable {
 		}
 
 	}
-	
+
 	// Torch start
 	class SendTask extends RecursiveAction {
 		Packet<?> packet;
@@ -1254,11 +1254,11 @@ public class PlayerConnection implements PacketListenerPlayIn, ITickable {
 			this.networkManager.sendPacket(packet);
 			return;
 		}
-		
+
 		SendTask task = new SendTask(packet);
 		task.fork();
 	}
-	
+
 	public void sendPacket_sub(final Packet<?> packet) {
 		if (packet instanceof PacketPlayOutChat) {
 			PacketPlayOutChat packetplayoutchat = (PacketPlayOutChat) packet;
@@ -1277,7 +1277,8 @@ public class PlayerConnection implements PacketListenerPlayIn, ITickable {
 		// Torch end
 		if (packet instanceof PacketPlayOutSpawnPosition) {
 			PacketPlayOutSpawnPosition packet6 = (PacketPlayOutSpawnPosition) packet;
-			this.player.compassTarget = new Location(this.getPlayer().getWorld(), packet6.position.getX(), packet6.position.getY(), packet6.position.getZ());
+			this.player.compassTarget = new Location(this.getPlayer().getWorld(), packet6.position.getX(),
+					packet6.position.getY(), packet6.position.getZ());
 		}
 		// CraftBukkit end
 
diff --git a/src/main/java/net/minecraft/server/PlayerInteractManager.java b/src/main/java/net/minecraft/server/PlayerInteractManager.java
index d139107..65f4feb 100644
--- a/src/main/java/net/minecraft/server/PlayerInteractManager.java
+++ b/src/main/java/net/minecraft/server/PlayerInteractManager.java
@@ -213,7 +213,9 @@ public class PlayerInteractManager {
 			}
 
 		}
-		this.world.blockPacketController.updateNearbyBlocks(this.world, blockposition); // Paper - Anti-Xray
+		this.world.blockPacketController.updateNearbyBlocks(this.world, blockposition); // Paper
+																						// -
+																						// Anti-Xray
 	}
 
 	public void a(BlockPosition blockposition) {
diff --git a/src/main/java/net/minecraft/server/PlayerList.java b/src/main/java/net/minecraft/server/PlayerList.java
index 4d66e45..2991c63 100644
--- a/src/main/java/net/minecraft/server/PlayerList.java
+++ b/src/main/java/net/minecraft/server/PlayerList.java
@@ -1333,10 +1333,7 @@ public abstract class PlayerList {
 	}
 
 	public void savePlayers() {
-		for (int i = 0; i < this.players.size(); ++i) {
-			this.savePlayerFile(this.players.get(i));
-		}
-
+		this.players.parallelStream().forEach(pl -> this.savePlayerFile((EntityPlayer) pl));
 	}
 
 	public void addWhitelist(GameProfile gameprofile) {
@@ -1460,7 +1457,12 @@ public abstract class PlayerList {
 		// Paper start - Fix players being skipped due to concurrent list
 		// modification
 		for (EntityPlayer player : com.google.common.collect.ImmutableList.copyOf(this.players)) {
-			player.playerConnection.disconnect(this.server.server.getShutdownMessage()); // CraftBukkit - add custom shutdown message
+			player.playerConnection.disconnect(this.server.server.getShutdownMessage()); // CraftBukkit
+																							// -
+																							// add
+																							// custom
+																							// shutdown
+																							// message
 		}
 		// Paper end
 	}
diff --git a/src/main/java/net/minecraft/server/RegionFile.java b/src/main/java/net/minecraft/server/RegionFile.java
index 889ed6f..3010dcf 100644
--- a/src/main/java/net/minecraft/server/RegionFile.java
+++ b/src/main/java/net/minecraft/server/RegionFile.java
@@ -298,7 +298,9 @@ public class RegionFile {
 
 			this.b(i, j, (int) (MinecraftServer.av() / 1000L));
 		} catch (IOException ioexception) {
-			org.spigotmc.SneakyThrow.sneaky(ioexception); // Paper - we want the upper try/catch to retry this
+			org.spigotmc.SneakyThrow.sneaky(ioexception); // Paper - we want the
+															// upper try/catch
+															// to retry this
 		}
 
 	}
diff --git a/src/main/java/net/minecraft/server/RegionFileCache.java b/src/main/java/net/minecraft/server/RegionFileCache.java
index f23a5ca..3015fa8 100644
--- a/src/main/java/net/minecraft/server/RegionFileCache.java
+++ b/src/main/java/net/minecraft/server/RegionFileCache.java
@@ -99,7 +99,7 @@ public class RegionFileCache {
 
 		try {
 			return NBTCompressedStreamTools.a(datainputstream);
-		} catch(ReportedException exception) {
+		} catch (ReportedException exception) {
 			if (de.minetick.MigotConfig.deleteCorruptChunk) {
 				file.delete();
 				return null;
diff --git a/src/main/java/net/minecraft/server/SpawnerCreature.java b/src/main/java/net/minecraft/server/SpawnerCreature.java
index 1619873..ab6f128 100644
--- a/src/main/java/net/minecraft/server/SpawnerCreature.java
+++ b/src/main/java/net/minecraft/server/SpawnerCreature.java
@@ -186,7 +186,7 @@ public final class SpawnerCreature {
 																					// allowed
 							// CraftBukkit start = use LongHash and
 							// LongObjectHashMap
-							long key = ((Long) iterator1.next()).longValue();
+							long key = ((Long) iterator1.next());
 							BlockPosition blockposition1 = getRandomPosition(worldserver, LongHash.msw(key),
 									LongHash.lsw(key));
 							// CraftBukkit
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index 1e4ab90..e66ced3 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -54,7 +54,26 @@ public abstract class World implements IBlockAccess {
 	// Spigot start - guard entity list from removals
 	protected boolean cancelHeavyCalculations = false;
 
-	public final List<Entity> entityList = new java.util.concurrent.CopyOnWriteArrayList();
+	public final Queue<Entity> entityQueue = Queues.newConcurrentLinkedQueue();
+	public List<Entity> entityList = new java.util.ArrayList<Entity>() {
+		@Override
+		public Entity remove(int index) {
+			guard();
+			return super.remove(index);
+		}
+
+		@Override
+		public boolean remove(Object o) {
+			guard();
+			return super.remove(o);
+		}
+
+		private void guard() {
+			if (guardEntityList) {
+				throw new java.util.ConcurrentModificationException();
+			}
+		}
+	};
 	// Spigot end
 	protected final Queue<Entity> f = Queues.newConcurrentLinkedQueue();
 	// public final List<TileEntity> tileEntityList = Lists.newArrayList(); //
@@ -124,7 +143,18 @@ public abstract class World implements IBlockAccess {
 	public final org.spigotmc.SpigotWorldConfig spigotConfig; // Spigot
 
 	public final com.destroystokyo.paper.PaperWorldConfig paperConfig; // Paper
-	public final IBlockPacketController blockPacketController; // Paper - Anti-Xray - This per world instance handles all tasks related with Anti-Xray depending on the configuration
+	public final IBlockPacketController blockPacketController; // Paper -
+																// Anti-Xray -
+																// This per
+																// world
+																// instance
+																// handles all
+																// tasks related
+																// with
+																// Anti-Xray
+																// depending on
+																// the
+																// configuration
 	public final net.techcable.tacospigot.TacoSpigotWorldConfig tacoSpigotConfig; // TacoSpigot
 
 	public final co.aikar.timings.WorldTimingsHandler timings; // Paper
@@ -137,9 +167,9 @@ public abstract class World implements IBlockAccess {
 	private org.spigotmc.TickLimiter tileLimiter;
 	private int tileTickPosition;
 	public final Map<Explosion.CacheKey, Float> explosionDensityCache = new java.util.concurrent.ConcurrentHashMap<>(); // Paper
-																																// -
-																																// Optimize
-																																// explosions
+																														// -
+																														// Optimize
+																														// explosions
 
 	// Paper - Start Peristence counters.
 	private long nextPersistenceCountersTick = System.nanoTime();
@@ -167,7 +197,15 @@ public abstract class World implements IBlockAccess {
 			MethodProfiler methodprofiler, boolean flag, ChunkGenerator gen, org.bukkit.World.Environment env) {
 		this.spigotConfig = new org.spigotmc.SpigotWorldConfig(worlddata.getName()); // Spigot
 		this.paperConfig = new com.destroystokyo.paper.PaperWorldConfig(worlddata.getName(), this.spigotConfig); // Paper
-		this.blockPacketController = this.paperConfig.antiXray ? new BlockPacketControllerObfuscate(paperConfig) : BlockPacketController.getInstance(); // Paper - Anti-Xray - If enabled use the obfuscate implementation else use the default singleton implementation for vanilla
+		this.blockPacketController = this.paperConfig.antiXray ? new BlockPacketControllerObfuscate(paperConfig)
+				: BlockPacketController.getInstance(); // Paper - Anti-Xray - If
+														// enabled use the
+														// obfuscate
+														// implementation else
+														// use the default
+														// singleton
+														// implementation for
+														// vanilla
 		this.dragonConfig = new com.domnian.paperdragon.DragonWorldConfig(worlddata.getName(), this.spigotConfig,
 				this.paperConfig); // PaperDragon
 		this.tacoSpigotConfig = new net.techcable.tacospigot.TacoSpigotWorldConfig(worlddata.getName()); // TacoSpigot
@@ -591,7 +629,9 @@ public abstract class World implements IBlockAccess {
 	}
 
 	public void applyPhysics(BlockPosition blockposition, Block block) {
-		this.blockPacketController.updateNearbyBlocks(this, blockposition); // Paper - Anti-Xray
+		this.blockPacketController.updateNearbyBlocks(this, blockposition); // Paper
+																			// -
+																			// Anti-Xray
 		if (captureBlockStates) {
 			return;
 		} // Paper - Cancel all physics during placement
@@ -1251,7 +1291,7 @@ public abstract class World implements IBlockAccess {
 			}
 
 			this.getChunkAt(i, j).a(entity);
-			this.entityList.add(entity);
+			this.entityQueue.add(entity);
 			this.b(entity);
 			return true;
 		}
@@ -1339,13 +1379,12 @@ public abstract class World implements IBlockAccess {
 
 			// CraftBukkit start - Decrement loop variable field if we've
 			// already ticked this entity
-			int index = this.entityList.indexOf(entity);
-			if (index != -1) {
-				if (index <= this.tickPosition) {
-					this.tickPosition--;
-				}
-				this.entityList.remove(index);
-			}
+			/*
+			 * int index = this.entityList.indexOf(entity); if (index != -1) {
+			 * if (index <= this.tickPosition) { this.tickPosition--; }
+			 * this.entityList.remove(index); }
+			 */
+			this.entityQueue.remove(entity);
 			// CraftBukkit end
 		} // Spigot
 		this.c(entity);
@@ -1634,29 +1673,11 @@ public abstract class World implements IBlockAccess {
 			}
 		}
 
-		/*
-		 * for (i = 0; i < this.j.size(); ++i) { entity = (Entity)
-		 * this.j.get(i); // CraftBukkit start - Fixed an NPE if (entity ==
-		 * null) { continue; } // CraftBukkit end
-		 * 
-		 * try { ++entity.ticksLived; entity.m(); } catch (Throwable throwable)
-		 * { CrashReport crashreport = CrashReport.a(throwable, "Ticking entity"
-		 * ); CrashReportSystemDetails crashreportsystemdetails = crashreport.a(
-		 * "Entity being ticked");
-		 * 
-		 * if (entity == null) { crashreportsystemdetails.a("Entity", (Object)
-		 * "~~NULL~~"); } else {
-		 * entity.appendEntityCrashDetails(crashreportsystemdetails); }
-		 * 
-		 * throw new ReportedException(crashreport); }
-		 * 
-		 * if (entity.dead) { this.j.remove(i--); } }
-		 */
 		// Hose end
 
 		this.methodProfiler.c("remove");
 		timings.entityRemoval.startTiming(); // Paper
-		this.entityList.removeAll(this.f);
+		this.entityQueue.removeAll(this.f);
 
 		int j;
 		int k; // Torch
@@ -1677,16 +1698,6 @@ public abstract class World implements IBlockAccess {
 			this.c(entity);
 		}
 		// Torch end
-
-		/*
-		 * // Paper start - Set based removal lists for (Entity e : this.f) { j
-		 * = e.getChunkX(); int k = e.getChunkZ();
-		 * 
-		 * if (e.aa && this.isChunkLoaded(j, k, true)) { this.getChunkAt(j,
-		 * k).b(e); } }
-		 * 
-		 * for (Entity e : this.f) { this.c(e); } // Paper end
-		 */
 		// Hose end
 
 		this.f.clear();
@@ -1703,56 +1714,60 @@ public abstract class World implements IBlockAccess {
 		// if (tickPosition < 0) tickPosition = 0;
 		for (tickPosition = 0; tickPosition < entityList.size(); tickPosition++) {
 			// Paper end
-            tickPosition = (tickPosition < entityList.size()) ? tickPosition : 0;
-            entity = (Entity) this.entityList.get(this.tickPosition);
-            // CraftBukkit end
-            Entity entity1 = entity.bz();
-
-            if (entity1 != null) {
-                if (!entity1.dead && entity1.w(entity)) {
-                    continue;
-                }
-
-                entity.stopRiding();
-            }
-
-            this.methodProfiler.a("tick");
-            if (!entity.dead && !(entity instanceof EntityPlayer)) {
-                try {
-                    entity.tickTimer.startTiming(); // Paper
-                    this.g(entity);
-                    entity.tickTimer.stopTiming(); // Paper
-                } catch (Throwable throwable1) {
-                    entity.tickTimer.stopTiming();
-                    // Paper start - Prevent tile entity and entity crashes
-                    String msg = "Entity threw exception at " + entity.world.getWorld().getName() + ":" + entity.locX + "," + entity.locY + "," + entity.locZ;
-                    System.err.println(msg);
-                    throwable1.printStackTrace();
-                    getServer().getPluginManager().callEvent(new ServerExceptionEvent(new ServerInternalException(msg, throwable1)));
-                    entity.dead = true;
-                    continue;
-                    // Paper end
-                }
-            }
-
-            this.methodProfiler.b();
-            this.methodProfiler.a("remove");
-            if (entity.dead) {
-                j = entity.ab;
-                int l = entity.ad;
-
-                if (entity.aa && this.isChunkLoaded(j, l, true)) {
-                    this.getChunkAt(j, l).b(entity);
-                }
-
-                guardEntityList = false; // Spigot
-                this.entityList.remove(this.tickPosition--); // CraftBukkit - Use field for loop variable
-                guardEntityList = true; // Spigot
-                this.c(entity);
-            }
-
-            this.methodProfiler.b();
-        }
+			tickPosition = (tickPosition < entityList.size()) ? tickPosition : 0;
+			entity = (Entity) this.entityList.get(this.tickPosition);
+			// CraftBukkit end
+			Entity entity1 = entity.bz();
+
+			if (entity1 != null) {
+				if (!entity1.dead && entity1.w(entity)) {
+					continue;
+				}
+
+				entity.stopRiding();
+			}
+
+			this.methodProfiler.a("tick");
+			if (!entity.dead && !(entity instanceof EntityPlayer)) {
+				try {
+					entity.tickTimer.startTiming(); // Paper
+					this.g(entity);
+					entity.tickTimer.stopTiming(); // Paper
+				} catch (Throwable throwable1) {
+					entity.tickTimer.stopTiming();
+					// Paper start - Prevent tile entity and entity crashes
+					String msg = "Entity threw exception at " + entity.world.getWorld().getName() + ":" + entity.locX
+							+ "," + entity.locY + "," + entity.locZ;
+					System.err.println(msg);
+					throwable1.printStackTrace();
+					getServer().getPluginManager()
+							.callEvent(new ServerExceptionEvent(new ServerInternalException(msg, throwable1)));
+					entity.dead = true;
+					continue;
+					// Paper end
+				}
+			}
+
+			this.methodProfiler.b();
+			this.methodProfiler.a("remove");
+			if (entity.dead) {
+				j = entity.ab;
+				int l = entity.ad;
+
+				if (entity.aa && this.isChunkLoaded(j, l, true)) {
+					this.getChunkAt(j, l).b(entity);
+				}
+
+				guardEntityList = false; // Spigot
+				this.entityList.remove(this.tickPosition--); // CraftBukkit -
+																// Use field for
+																// loop variable
+				guardEntityList = true; // Spigot
+				this.c(entity);
+			}
+
+			this.methodProfiler.b();
+		}
 		guardEntityList = false; // Spigot
 
 		timings.entityTick.stopTiming(); // Spigot
@@ -1767,7 +1782,12 @@ public abstract class World implements IBlockAccess {
 			this.tileEntityListUnload.clear();
 		}
 		// CraftBukkit end
-
+		// Hose start
+		if (!WorldServer.nextTickQueue.isEmpty()) {
+			WorldServer.nextTickList.addAll(WorldServer.nextTickQueue);
+			WorldServer.nextTickQueue.clear();
+		}
+		// Hose end
 		for (tileTickPosition = 0; tileTickPosition < tileEntityListTick.size(); tileTickPosition++) { // Paper
 																										// -
 																										// Disable
@@ -1829,13 +1849,6 @@ public abstract class World implements IBlockAccess {
 		timings.tileEntityTick.stopTiming(); // Spigot
 		timings.tileEntityPending.startTiming(); // Spigot
 		this.M = false;
-		/*
-		 * CraftBukkit start - Moved up if
-		 * (!this.tileEntityListUnload.isEmpty()) {
-		 * this.tileEntityListTick.removeAll(this.tileEntityListUnload);
-		 * this.tileEntityList.removeAll(this.tileEntityListUnload);
-		 * this.tileEntityListUnload.clear(); } // CraftBukkit end
-		 */
 
 		this.methodProfiler.c("pendingBlockEntities");
 		if (!this.b.isEmpty()) {
@@ -1859,21 +1872,6 @@ public abstract class World implements IBlockAccess {
 					}
 				}
 			}
-			/*
-			 * for (int i1 = 0; i1 < this.b.size(); ++i1) { TileEntity
-			 * tileentity1 = (TileEntity) this.b.get(i1);
-			 * 
-			 * if (!tileentity1.x()) { if
-			 * (this.isLoaded(tileentity1.getPosition())) { Chunk chunk =
-			 * this.getChunkAtWorldCoords(tileentity1.getPosition()); IBlockData
-			 * iblockdata = chunk.getBlockData(tileentity1.getPosition());
-			 * 
-			 * chunk.a(tileentity1.getPosition(), tileentity1);
-			 * this.notify(tileentity1.getPosition(), iblockdata, iblockdata,
-			 * 3); // CraftBukkit start // From above, don't screw this up -
-			 * SPIGOT-1746 if (true) { // Paper - remove unused list
-			 * this.a(tileentity1); } // CraftBukkit end } } }
-			 */
 			// Hose end
 
 			this.b.clear();
@@ -2907,6 +2905,7 @@ public abstract class World implements IBlockAccess {
 
 	public <T extends Entity> List<T> a(Class<? extends T> oclass, Predicate<? super T> predicate) {
 		ArrayList arraylist = Lists.newArrayList();
+		this.entityList = new ArrayList(this.entityQueue);
 		Iterator iterator = this.entityList.iterator();
 
 		while (iterator.hasNext()) {
@@ -2999,6 +2998,7 @@ public abstract class World implements IBlockAccess {
 
 	public int a(Class<?> oclass) {
 		int i = 0;
+		this.entityList = new ArrayList(this.entityQueue);
 		Iterator iterator = Queues.newConcurrentLinkedQueue(this.entityList).iterator();
 
 		while (iterator.hasNext()) {
@@ -3036,7 +3036,7 @@ public abstract class World implements IBlockAccess {
 			if (entity == null) {
 				continue;
 			}
-			this.entityList.add(entity);
+			this.entityQueue.add(entity);
 			// CraftBukkit end
 			this.b(entity);
 		}
diff --git a/src/main/java/net/minecraft/server/WorldServer.java b/src/main/java/net/minecraft/server/WorldServer.java
index 220beb3..9b17f3b 100644
--- a/src/main/java/net/minecraft/server/WorldServer.java
+++ b/src/main/java/net/minecraft/server/WorldServer.java
@@ -8,7 +8,11 @@ import java.util.List;
 import java.util.Map;
 import java.util.Queue;
 import java.util.Random;
+import java.util.Set;
 import java.util.UUID;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ForkJoinTask;
 import java.util.concurrent.RecursiveAction;
 // CraftBukkit start
 import java.util.logging.Level;
@@ -23,11 +27,13 @@ import org.bukkit.craftbukkit.util.HashTreeSet;
 import org.bukkit.event.block.BlockFormEvent;
 import org.bukkit.event.weather.LightningStrikeEvent;
 // CraftBukkit end
+import org.spigotmc.SpigotWorldConfig;
 
 import com.google.common.base.Predicate;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Queues;
+import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.ListenableFuture;
 
 import de.minetick.MigotConfig;
@@ -41,9 +47,15 @@ public class WorldServer extends World implements IAsyncTaskHandler {
 	private final PlayerChunkMap manager;
 	// private final Set<NextTickListEntry> nextTickListHash =
 	// Sets.newHashSet();
-	private final HashTreeSet<NextTickListEntry> nextTickList = new HashTreeSet<NextTickListEntry>(); // CraftBukkit
+
+	// Hose start
+	public static HashTreeSet<NextTickListEntry> nextTickList = new HashTreeSet<NextTickListEntry>(); // CraftBukkit
 																										// -
 																										// HashTreeSet
+	public static final Set<NextTickListEntry> nextTickQueue = Sets.newConcurrentHashSet();
+	private final Set<NextTickListEntry> nextTickList_remove = Sets.newConcurrentHashSet();
+	// Hose end
+
 	private final Map<UUID, Entity> entitiesByUUID = Maps.newHashMap();
 	public boolean savingDisabled;
 	private boolean O;
@@ -259,10 +271,13 @@ public class WorldServer extends World implements IAsyncTaskHandler {
 				&& (this.allowMonsters || this.allowAnimals)
 				&& (this instanceof WorldServer && this.players.size() > 0)) {
 			timings.mobSpawn.startTiming(); // Spigot
-			this.spawnerCreature.a(this,
+			// Hose start
+			SpigotWorldConfig.TickTask = ForkJoinTask.adapt(new mobspawn(this,
 					this.allowMonsters && (this.ticksPerMonsterSpawns != 0 && time % this.ticksPerMonsterSpawns == 0L),
 					this.allowAnimals && (this.ticksPerAnimalSpawns != 0 && time % this.ticksPerAnimalSpawns == 0L),
-					this.worldData.getTime() % 400L == 0L);
+					this.worldData.getTime() % 400L == 0L));
+			SpigotWorldConfig.TickPool.submit(SpigotWorldConfig.TickTask);
+			// Hose end
 			timings.mobSpawn.stopTiming(); // Spigot
 			// CraftBukkit end
 		}
@@ -322,8 +337,16 @@ public class WorldServer extends World implements IAsyncTaskHandler {
 
 	public boolean a(EnumCreatureType enumcreaturetype, BiomeBase.BiomeMeta biomebase_biomemeta,
 			BlockPosition blockposition) {
-		List list = this.getChunkProviderServer().a(enumcreaturetype, blockposition);
-
+		SpigotWorldConfig.TickTask = ForkJoinTask.adapt(new biometa(this, enumcreaturetype, blockposition));
+		SpigotWorldConfig.TickPool.submit(SpigotWorldConfig.TickTask);
+		List list = null;
+		try {
+			list = (List) SpigotWorldConfig.TickTask.get();
+		} catch (InterruptedException ex) {
+			java.util.logging.Logger.getLogger(WorldServer.class.getName()).log(Level.SEVERE, null, ex);
+		} catch (ExecutionException ex) {
+			java.util.logging.Logger.getLogger(WorldServer.class.getName()).log(Level.SEVERE, null, ex);
+		}
 		return list != null && !list.isEmpty() ? list.contains(biomebase_biomemeta) : false;
 	}
 
@@ -683,7 +706,7 @@ public class WorldServer extends World implements IAsyncTaskHandler {
 
 			// CraftBukkit - use nextTickList
 			if (!this.nextTickList.contains(nextticklistentry)) {
-				this.nextTickList.add(nextticklistentry);
+				this.nextTickQueue.add(nextticklistentry);
 			}
 		}
 
@@ -709,7 +732,7 @@ public class WorldServer extends World implements IAsyncTaskHandler {
 
 		// CraftBukkit - use nextTickList
 		if (!this.nextTickList.contains(nextticklistentry)) {
-			this.nextTickList.add(nextticklistentry);
+			this.nextTickQueue.add(nextticklistentry);
 		}
 
 	}
@@ -726,7 +749,8 @@ public class WorldServer extends World implements IAsyncTaskHandler {
 			this.m();
 		}
 
-		this.worldProvider.r();
+		r rt = new r();
+		rt.fork();
 		super.tickEntities();
 		spigotConfig.currentPrimedTnt = 0; // Spigot
 	}
@@ -771,7 +795,7 @@ public class WorldServer extends World implements IAsyncTaskHandler {
 					this.getChunkAt(j, k).b(entity);
 				}
 
-				this.entityList.remove(entity);
+				this.entityQueue.remove(entity);
 				this.c(entity);
 			}
 
@@ -1211,7 +1235,7 @@ public class WorldServer extends World implements IAsyncTaskHandler {
 			Entity entity = (Entity) iterator.next();
 
 			if (this.i(entity)) {
-				this.entityList.add(entity);
+				this.entityQueue.add(entity);
 				this.b(entity);
 			}
 		}
@@ -1599,5 +1623,47 @@ public class WorldServer extends World implements IAsyncTaskHandler {
 		}
 
 	}
+
+	class biometa implements Callable<List> {
+		WorldServer ws;
+		EnumCreatureType enumcreaturetype;
+		BlockPosition blockposition;
+
+		biometa(WorldServer ws, EnumCreatureType enumcreaturetype, BlockPosition blockposition) {
+			this.ws = ws;
+			this.enumcreaturetype = enumcreaturetype;
+			this.blockposition = blockposition;
+		}
+
+		@Override
+		public List call() throws Exception {
+			return ws.getChunkProviderServer().a(enumcreaturetype, blockposition);
+		}
+	}
+
+	class r extends RecursiveAction {
+
+		@Override
+		protected void compute() {
+			worldProvider.r();
+		}
+	}
+
+	class mobspawn implements Callable<Integer> {
+		WorldServer ws;
+		boolean flag, flag1, flag2;
+
+		mobspawn(WorldServer ws, boolean flag, boolean flag1, boolean flag2) {
+			this.ws = ws;
+			this.flag = flag;
+			this.flag1 = flag1;
+			this.flag2 = flag2;
+		}
+
+		@Override
+		public Integer call() throws Exception {
+			return spawnerCreature.a(ws, flag, flag1, flag2);
+		}
+	}
 	// Hose end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index f09e305..349ae2f 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -373,7 +373,7 @@ public final class CraftServer implements Server {
 
 		for (Plugin plugin : plugins) {
 			if ((!plugin.isEnabled()) && (plugin.getDescription().getLoad() == type)) {
-				loadPlugin(plugin);
+				enablePlugin(plugin);
 			}
 		}
 
@@ -415,7 +415,7 @@ public final class CraftServer implements Server {
 		}
 	}
 
-	private void loadPlugin(Plugin plugin) {
+	private void enablePlugin(Plugin plugin) {
 		try {
 			pluginManager.enablePlugin(plugin);
 
@@ -433,6 +433,8 @@ public final class CraftServer implements Server {
 			Logger.getLogger(CraftServer.class.getName()).log(Level.SEVERE,
 					ex.getMessage() + " loading " + plugin.getDescription().getFullName() + " (Is it up to date?)", ex);
 		}
+
+		pluginManager.enablePlugin(plugin);
 	}
 
 	@Override
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index 4fdfe36..9daace7 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -816,6 +816,7 @@ public class CraftWorld implements World {
 	public List<Entity> getEntities() {
 		List<Entity> list = new ArrayList<Entity>();
 
+		world.entityList = new ArrayList(world.entityQueue);
 		for (Object o : world.entityList) {
 			if (o instanceof net.minecraft.server.Entity) {
 				net.minecraft.server.Entity mcEnt = (net.minecraft.server.Entity) o;
@@ -835,6 +836,7 @@ public class CraftWorld implements World {
 	public List<LivingEntity> getLivingEntities() {
 		List<LivingEntity> list = new ArrayList<LivingEntity>();
 
+		world.entityList = new ArrayList(world.entityQueue);
 		for (Object o : world.entityList) {
 			if (o instanceof net.minecraft.server.Entity) {
 				net.minecraft.server.Entity mcEnt = (net.minecraft.server.Entity) o;
@@ -862,6 +864,7 @@ public class CraftWorld implements World {
 	public <T extends Entity> Collection<T> getEntitiesByClass(Class<T> clazz) {
 		Collection<T> list = new ArrayList<T>();
 
+		world.entityList = new ArrayList(world.entityQueue);
 		for (Object entity : world.entityList) {
 			if (entity instanceof net.minecraft.server.Entity) {
 				Entity bukkitEntity = ((net.minecraft.server.Entity) entity).getBukkitEntity();
@@ -885,6 +888,7 @@ public class CraftWorld implements World {
 	public Collection<Entity> getEntitiesByClasses(Class<?>... classes) {
 		Collection<Entity> list = new ArrayList<Entity>();
 
+		world.entityList = new ArrayList(world.entityQueue);
 		for (Object entity : world.entityList) {
 			if (entity instanceof net.minecraft.server.Entity) {
 				Entity bukkitEntity = ((net.minecraft.server.Entity) entity).getBukkitEntity();
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
index 1db0295..eaa32ce 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
@@ -387,8 +387,10 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
 
 	@Override
 	public void setVelocity(Vector vel) {
-		// Paper start - Warn server owners when plugins try to set super high velocities
-		if (!(this instanceof org.bukkit.entity.Projectile) && (vel.getX() > 4 || vel.getX() < -4 || vel.getY() > 4 || vel.getY() < -4 || vel.getZ() > 4 || vel.getZ() < -4) && MigotConfig.enableVelocityWarning) {
+		// Paper start - Warn server owners when plugins try to set super high
+		// velocities
+		if (!(this instanceof org.bukkit.entity.Projectile) && (vel.getX() > 4 || vel.getX() < -4 || vel.getY() > 4
+				|| vel.getY() < -4 || vel.getZ() > 4 || vel.getZ() < -4) && MigotConfig.enableVelocityWarning) {
 			getServer().getLogger().warning("Excessive velocity set detected: tried to set velocity of entity #"
 					+ getEntityId() + " to (" + vel.getX() + "," + vel.getY() + "," + vel.getZ() + ").");
 			Thread.dumpStack();
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftZombie.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftZombie.java
index 6c44dee..7453995 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftZombie.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftZombie.java
@@ -63,7 +63,8 @@ public class CraftZombie extends CraftMonster implements Zombie {
 
 	@Override
 	public Villager.Profession getVillagerProfession() {
-		if (!isVillager()) return null;
-        return Villager.Profession.getProfession(getHandle().getVillagerType());
+		if (!isVillager())
+			return null;
+		return Villager.Profession.getProfession(getHandle().getVillagerType());
 	}
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java b/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
index 997a6cc..cfa302d 100644
--- a/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
+++ b/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
@@ -629,8 +629,7 @@ public class CraftEventFactory {
 			} else if (source == DamageSource.DRAGON_BREATH) {
 				cause = DamageCause.DRAGON_BREATH;
 			} else {
-				throw new RuntimeException(String.format("Unhandled damage of %s by %s from %s", entity,
-						damager.getHandle(), source.translationIndex)); // Spigot
+				cause = DamageCause.CONTACT;
 			}
 			EntityDamageEvent event = callEvent(new EntityDamageByEntityEvent(damager, entity.getBukkitEntity(), cause,
 					modifiers, modifierFunctions));
@@ -671,7 +670,7 @@ public class CraftEventFactory {
 			return callEntityDamageEvent(null, entity, cause, modifiers, modifierFunctions);
 		}
 
-		throw new RuntimeException(String.format("Unhandled damage of %s from %s", entity, source.translationIndex)); // Spigot
+		return callEntityDamageEvent(null, entity, DamageCause.CONTACT, modifiers, modifierFunctions);
 	}
 
 	private static EntityDamageEvent callEntityDamageEvent(Entity damager, Entity damagee, DamageCause cause,
diff --git a/src/main/java/org/bukkit/craftbukkit/generator/CustomChunkGenerator.java b/src/main/java/org/bukkit/craftbukkit/generator/CustomChunkGenerator.java
index c166991..64066a7 100644
--- a/src/main/java/org/bukkit/craftbukkit/generator/CustomChunkGenerator.java
+++ b/src/main/java/org/bukkit/craftbukkit/generator/CustomChunkGenerator.java
@@ -84,7 +84,7 @@ public class CustomChunkGenerator extends InternalChunkGenerator {
 				// Build chunk section
 				if (emptyTest != 0) {
 					csect[sec] = new ChunkSection(sec << 4, true, section,
-					this.world.blockPacketController.getPredefinedBlockData(chunk, sec)); // Paper
+							this.world.blockPacketController.getPredefinedBlockData(chunk, sec)); // Paper
 				}
 			}
 		} else {
@@ -109,7 +109,7 @@ public class CustomChunkGenerator extends InternalChunkGenerator {
 					}
 					// Build chunk section
 					csect[sec] = new ChunkSection(sec << 4, true, secBlkID,
-					this.world.blockPacketController.getPredefinedBlockData(chunk, sec)); // Paper
+							this.world.blockPacketController.getPredefinedBlockData(chunk, sec)); // Paper
 				}
 			} else { // Else check for byte-per-block section data
 				byte[][] btypes = generator.generateBlockSections(this.world.getWorld(), this.random, x, z, biomegrid);
@@ -129,9 +129,10 @@ public class CustomChunkGenerator extends InternalChunkGenerator {
 															// bytes
 						for (int i = 0; i < secBlkID.length; i++) {
 							Block b = Block.getById(btypes[sec][i] & 0xFF);
-                            secBlkID[i] = (char) Block.REGISTRY_ID.getId(b.getBlockData());
+							secBlkID[i] = (char) Block.REGISTRY_ID.getId(b.getBlockData());
 						}
-						csect[sec] = new ChunkSection(sec << 4, true, secBlkID, this.world.blockPacketController.getPredefinedBlockData(chunk, sec)); // Paper
+						csect[sec] = new ChunkSection(sec << 4, true, secBlkID,
+								this.world.blockPacketController.getPredefinedBlockData(chunk, sec)); // Paper
 					}
 				} else { // Else, fall back to pre 1.2 method
 					@SuppressWarnings("deprecation")
@@ -173,7 +174,7 @@ public class CustomChunkGenerator extends InternalChunkGenerator {
 						// If section built, finish prepping its state
 						if (csbytes != null) {
 							ChunkSection cs = csect[sec] = new ChunkSection(sec << 4, true, csbytes,
-							this.world.blockPacketController.getPredefinedBlockData(chunk, sec)); // Paper
+									this.world.blockPacketController.getPredefinedBlockData(chunk, sec)); // Paper
 							cs.recalcBlockCounts();
 						}
 					}
diff --git a/src/main/java/org/bukkit/craftbukkit/scoreboard/CraftTeam.java b/src/main/java/org/bukkit/craftbukkit/scoreboard/CraftTeam.java
index 85916e0..750d9e7 100644
--- a/src/main/java/org/bukkit/craftbukkit/scoreboard/CraftTeam.java
+++ b/src/main/java/org/bukkit/craftbukkit/scoreboard/CraftTeam.java
@@ -238,51 +238,68 @@ final class CraftTeam extends CraftScoreboardComponent implements Team {
 			throw new IllegalArgumentException("Unrecognised option " + option);
 		}
 	}
-	
+
 	public static EnumNameTagVisibility mojangVisibility(OptionStatus bukkit) {
-        switch(bukkit) {
-            case ALWAYS: return EnumNameTagVisibility.ALWAYS;
-            case NEVER: return EnumNameTagVisibility.NEVER;
-
-            // Order of these are flipped since the Mojang versions have negated meaning
-            case FOR_OWN_TEAM: return EnumNameTagVisibility.HIDE_FOR_OTHER_TEAMS;
-            case FOR_OTHER_TEAMS: return EnumNameTagVisibility.HIDE_FOR_OWN_TEAM;
-        }
-        throw new Error();
-    }
-
-    public static ScoreboardTeamBase.EnumTeamPush mojangCollision(OptionStatus bukkit) {
-        switch(bukkit) {
-            case ALWAYS: return ScoreboardTeamBase.EnumTeamPush.ALWAYS;
-            case NEVER: return ScoreboardTeamBase.EnumTeamPush.NEVER;
-
-            // These are NOT flipped since Mojang didn't use the negative here
-            // i.e. HIDE_FOR_OWN_TEAM is actually "pushOwnTeam".
-            case FOR_OWN_TEAM: return ScoreboardTeamBase.EnumTeamPush.HIDE_FOR_OWN_TEAM;
-            case FOR_OTHER_TEAMS: return ScoreboardTeamBase.EnumTeamPush.HIDE_FOR_OTHER_TEAMS;
-        }
-        throw new Error();
-    }
-
-    public static OptionStatus bukkitVisibility(EnumNameTagVisibility mojang) {
-        switch(mojang) {
-            case ALWAYS: return OptionStatus.ALWAYS;
-            case NEVER: return OptionStatus.NEVER;
-            case HIDE_FOR_OTHER_TEAMS: return OptionStatus.FOR_OWN_TEAM;
-            case HIDE_FOR_OWN_TEAM: return OptionStatus.FOR_OTHER_TEAMS;
-        }
-        throw new Error();
-    }
-
-    public static OptionStatus bukkitCollision(ScoreboardTeamBase.EnumTeamPush mojang) {
-        switch(mojang) {
-            case ALWAYS: return OptionStatus.ALWAYS;
-            case NEVER: return OptionStatus.NEVER;
-            case HIDE_FOR_OWN_TEAM: return OptionStatus.FOR_OWN_TEAM;
-            case HIDE_FOR_OTHER_TEAMS: return OptionStatus.FOR_OTHER_TEAMS;
-        }
-        throw new Error();
-    }
+		switch (bukkit) {
+		case ALWAYS:
+			return EnumNameTagVisibility.ALWAYS;
+		case NEVER:
+			return EnumNameTagVisibility.NEVER;
+
+		// Order of these are flipped since the Mojang versions have negated
+		// meaning
+		case FOR_OWN_TEAM:
+			return EnumNameTagVisibility.HIDE_FOR_OTHER_TEAMS;
+		case FOR_OTHER_TEAMS:
+			return EnumNameTagVisibility.HIDE_FOR_OWN_TEAM;
+		}
+		throw new Error();
+	}
+
+	public static ScoreboardTeamBase.EnumTeamPush mojangCollision(OptionStatus bukkit) {
+		switch (bukkit) {
+		case ALWAYS:
+			return ScoreboardTeamBase.EnumTeamPush.ALWAYS;
+		case NEVER:
+			return ScoreboardTeamBase.EnumTeamPush.NEVER;
+
+		// These are NOT flipped since Mojang didn't use the negative here
+		// i.e. HIDE_FOR_OWN_TEAM is actually "pushOwnTeam".
+		case FOR_OWN_TEAM:
+			return ScoreboardTeamBase.EnumTeamPush.HIDE_FOR_OWN_TEAM;
+		case FOR_OTHER_TEAMS:
+			return ScoreboardTeamBase.EnumTeamPush.HIDE_FOR_OTHER_TEAMS;
+		}
+		throw new Error();
+	}
+
+	public static OptionStatus bukkitVisibility(EnumNameTagVisibility mojang) {
+		switch (mojang) {
+		case ALWAYS:
+			return OptionStatus.ALWAYS;
+		case NEVER:
+			return OptionStatus.NEVER;
+		case HIDE_FOR_OTHER_TEAMS:
+			return OptionStatus.FOR_OWN_TEAM;
+		case HIDE_FOR_OWN_TEAM:
+			return OptionStatus.FOR_OTHER_TEAMS;
+		}
+		throw new Error();
+	}
+
+	public static OptionStatus bukkitCollision(ScoreboardTeamBase.EnumTeamPush mojang) {
+		switch (mojang) {
+		case ALWAYS:
+			return OptionStatus.ALWAYS;
+		case NEVER:
+			return OptionStatus.NEVER;
+		case HIDE_FOR_OWN_TEAM:
+			return OptionStatus.FOR_OWN_TEAM;
+		case HIDE_FOR_OTHER_TEAMS:
+			return OptionStatus.FOR_OTHER_TEAMS;
+		}
+		throw new Error();
+	}
 
 	public static EnumNameTagVisibility bukkitToNotch(NameTagVisibility visibility) {
 		switch (visibility) {
diff --git a/src/main/java/org/bukkit/craftbukkit/util/LazyHashSet.java b/src/main/java/org/bukkit/craftbukkit/util/LazyHashSet.java
index e2a9643..c6ff60b 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/LazyHashSet.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/LazyHashSet.java
@@ -5,106 +5,106 @@ import java.util.Iterator;
 import java.util.Set;
 
 public abstract class LazyHashSet<E> implements Set<E> {
-	Set<E> reference = null;
-
-	@Override
-	public int size() {
-		return getReference().size();
-	}
-
-	@Override
-	public boolean isEmpty() {
-		return getReference().isEmpty();
-	}
-
-	@Override
-	public boolean contains(Object o) {
-		return getReference().contains(o);
-	}
-
-	@Override
-	public Iterator<E> iterator() {
-		return getReference().iterator();
-	}
-
-	@Override
-	public Object[] toArray() {
-		return getReference().toArray();
-	}
-
-	@Override
-	public <T> T[] toArray(T[] a) {
-		return getReference().toArray(a);
-	}
-
-	@Override
-	public boolean add(E o) {
-		return getReference().add(o);
-	}
-
-	@Override
-	public boolean remove(Object o) {
-		return getReference().remove(o);
-	}
-
-	@Override
-	public boolean containsAll(Collection<?> c) {
-		return getReference().containsAll(c);
-	}
-
-	@Override
-	public boolean addAll(Collection<? extends E> c) {
-		return getReference().addAll(c);
-	}
-
-	@Override
-	public boolean retainAll(Collection<?> c) {
-		return getReference().retainAll(c);
-	}
-
-	@Override
-	public boolean removeAll(Collection<?> c) {
-		return getReference().removeAll(c);
-	}
-
-	@Override
-	public void clear() {
-		getReference().clear();
-	}
-
-	public Set<E> getReference() {
-		Set<E> reference = this.reference;
-		if (reference != null) {
-			return reference;
-		}
-		return this.reference = makeReference();
-	}
-
-	abstract Set<E> makeReference();
-
-	public boolean isLazy() {
-		return reference == null;
-	}
-
-	@Override
-	public int hashCode() {
-		return 157 * getReference().hashCode();
-	}
-
-	@Override
-	public boolean equals(Object obj) {
-		if (obj == this) {
-			return true;
-		}
-		if (obj == null || this.getClass() != obj.getClass()) {
-			return false;
-		}
-		LazyHashSet<?> that = (LazyHashSet<?>) obj;
-		return (this.isLazy() && that.isLazy()) || this.getReference().equals(that.getReference());
-	}
-
-	@Override
-	public String toString() {
-		return getReference().toString();
-	}
+	Set<E> reference = null;
+
+	@Override
+	public int size() {
+		return getReference().size();
+	}
+
+	@Override
+	public boolean isEmpty() {
+		return getReference().isEmpty();
+	}
+
+	@Override
+	public boolean contains(Object o) {
+		return getReference().contains(o);
+	}
+
+	@Override
+	public Iterator<E> iterator() {
+		return getReference().iterator();
+	}
+
+	@Override
+	public Object[] toArray() {
+		return getReference().toArray();
+	}
+
+	@Override
+	public <T> T[] toArray(T[] a) {
+		return getReference().toArray(a);
+	}
+
+	@Override
+	public boolean add(E o) {
+		return getReference().add(o);
+	}
+
+	@Override
+	public boolean remove(Object o) {
+		return getReference().remove(o);
+	}
+
+	@Override
+	public boolean containsAll(Collection<?> c) {
+		return getReference().containsAll(c);
+	}
+
+	@Override
+	public boolean addAll(Collection<? extends E> c) {
+		return getReference().addAll(c);
+	}
+
+	@Override
+	public boolean retainAll(Collection<?> c) {
+		return getReference().retainAll(c);
+	}
+
+	@Override
+	public boolean removeAll(Collection<?> c) {
+		return getReference().removeAll(c);
+	}
+
+	@Override
+	public void clear() {
+		getReference().clear();
+	}
+
+	public Set<E> getReference() {
+		Set<E> reference = this.reference;
+		if (reference != null) {
+			return reference;
+		}
+		return this.reference = makeReference();
+	}
+
+	abstract Set<E> makeReference();
+
+	public boolean isLazy() {
+		return reference == null;
+	}
+
+	@Override
+	public int hashCode() {
+		return 157 * getReference().hashCode();
+	}
+
+	@Override
+	public boolean equals(Object obj) {
+		if (obj == this) {
+			return true;
+		}
+		if (obj == null || this.getClass() != obj.getClass()) {
+			return false;
+		}
+		LazyHashSet<?> that = (LazyHashSet<?>) obj;
+		return (this.isLazy() && that.isLazy()) || this.getReference().equals(that.getReference());
+	}
+
+	@Override
+	public String toString() {
+		return getReference().toString();
+	}
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/util/permissions/CommandPermissions.java b/src/main/java/org/bukkit/craftbukkit/util/permissions/CommandPermissions.java
index 1d1a790..c86c2c9 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/permissions/CommandPermissions.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/permissions/CommandPermissions.java
@@ -5,53 +5,53 @@ import org.bukkit.permissions.PermissionDefault;
 import org.bukkit.util.permissions.DefaultPermissions;
 
 public final class CommandPermissions {
-	private static final String ROOT = "minecraft.command";
-	private static final String PREFIX = ROOT + ".";
+	private static final String ROOT = "minecraft.command";
+	private static final String PREFIX = ROOT + ".";
 
-	private CommandPermissions() {
-	}
+	private CommandPermissions() {
+	}
 
-	public static Permission registerPermissions(Permission parent) {
-		Permission commands = DefaultPermissions.registerPermission(ROOT,
-				"Gives the user the ability to use all vanilla minecraft commands", parent);
+	public static Permission registerPermissions(Permission parent) {
+		Permission commands = DefaultPermissions.registerPermission(ROOT,
+				"Gives the user the ability to use all vanilla minecraft commands", parent);
 
-		DefaultPermissions.registerPermission(PREFIX + "kill", "Allows the user to commit suicide",
-				PermissionDefault.OP, commands);
-		DefaultPermissions.registerPermission(PREFIX + "me", "Allows the user to perform a chat action",
-				PermissionDefault.TRUE, commands);
-		DefaultPermissions.registerPermission(PREFIX + "tell", "Allows the user to privately message another player",
-				PermissionDefault.TRUE, commands);
-		DefaultPermissions.registerPermission(PREFIX + "say", "Allows the user to talk as the console",
-				PermissionDefault.OP, commands);
-		DefaultPermissions.registerPermission(PREFIX + "give", "Allows the user to give items to players",
-				PermissionDefault.OP, commands);
-		DefaultPermissions.registerPermission(PREFIX + "teleport", "Allows the user to teleport players",
-				PermissionDefault.OP, commands);
-		DefaultPermissions.registerPermission(PREFIX + "kick", "Allows the user to kick players", PermissionDefault.OP,
-				commands);
-		DefaultPermissions.registerPermission(PREFIX + "stop", "Allows the user to stop the server",
-				PermissionDefault.OP, commands);
-		DefaultPermissions.registerPermission(PREFIX + "list", "Allows the user to list all online players",
-				PermissionDefault.OP, commands);
-		DefaultPermissions.registerPermission(PREFIX + "gamemode",
-				"Allows the user to change the gamemode of another player", PermissionDefault.OP, commands);
-		DefaultPermissions.registerPermission(PREFIX + "xp",
-				"Allows the user to give themselves or others arbitrary values of experience", PermissionDefault.OP,
-				commands);
-		DefaultPermissions.registerPermission(PREFIX + "toggledownfall",
-				"Allows the user to toggle rain on/off for a given world", PermissionDefault.OP, commands);
-		DefaultPermissions.registerPermission(PREFIX + "defaultgamemode",
-				"Allows the user to change the default gamemode of the server", PermissionDefault.OP, commands);
-		DefaultPermissions.registerPermission(PREFIX + "seed", "Allows the user to view the seed of the world",
-				PermissionDefault.OP, commands);
-		DefaultPermissions.registerPermission(PREFIX + "effect", "Allows the user to add/remove effects on players",
-				PermissionDefault.OP, commands);
-		DefaultPermissions.registerPermission(PREFIX + "selector", "Allows the use of selectors", PermissionDefault.OP,
-				commands);
-		DefaultPermissions.registerPermission(PREFIX + "trigger", "Allows the use of the trigger command",
-				PermissionDefault.TRUE, commands);
+		DefaultPermissions.registerPermission(PREFIX + "kill", "Allows the user to commit suicide",
+				PermissionDefault.OP, commands);
+		DefaultPermissions.registerPermission(PREFIX + "me", "Allows the user to perform a chat action",
+				PermissionDefault.TRUE, commands);
+		DefaultPermissions.registerPermission(PREFIX + "tell", "Allows the user to privately message another player",
+				PermissionDefault.TRUE, commands);
+		DefaultPermissions.registerPermission(PREFIX + "say", "Allows the user to talk as the console",
+				PermissionDefault.OP, commands);
+		DefaultPermissions.registerPermission(PREFIX + "give", "Allows the user to give items to players",
+				PermissionDefault.OP, commands);
+		DefaultPermissions.registerPermission(PREFIX + "teleport", "Allows the user to teleport players",
+				PermissionDefault.OP, commands);
+		DefaultPermissions.registerPermission(PREFIX + "kick", "Allows the user to kick players", PermissionDefault.OP,
+				commands);
+		DefaultPermissions.registerPermission(PREFIX + "stop", "Allows the user to stop the server",
+				PermissionDefault.OP, commands);
+		DefaultPermissions.registerPermission(PREFIX + "list", "Allows the user to list all online players",
+				PermissionDefault.OP, commands);
+		DefaultPermissions.registerPermission(PREFIX + "gamemode",
+				"Allows the user to change the gamemode of another player", PermissionDefault.OP, commands);
+		DefaultPermissions.registerPermission(PREFIX + "xp",
+				"Allows the user to give themselves or others arbitrary values of experience", PermissionDefault.OP,
+				commands);
+		DefaultPermissions.registerPermission(PREFIX + "toggledownfall",
+				"Allows the user to toggle rain on/off for a given world", PermissionDefault.OP, commands);
+		DefaultPermissions.registerPermission(PREFIX + "defaultgamemode",
+				"Allows the user to change the default gamemode of the server", PermissionDefault.OP, commands);
+		DefaultPermissions.registerPermission(PREFIX + "seed", "Allows the user to view the seed of the world",
+				PermissionDefault.OP, commands);
+		DefaultPermissions.registerPermission(PREFIX + "effect", "Allows the user to add/remove effects on players",
+				PermissionDefault.OP, commands);
+		DefaultPermissions.registerPermission(PREFIX + "selector", "Allows the use of selectors", PermissionDefault.OP,
+				commands);
+		DefaultPermissions.registerPermission(PREFIX + "trigger", "Allows the use of the trigger command",
+				PermissionDefault.TRUE, commands);
 
-		commands.recalculatePermissibles();
-		return commands;
-	}
+		commands.recalculatePermissibles();
+		return commands;
+	}
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/util/permissions/CraftDefaultPermissions.java b/src/main/java/org/bukkit/craftbukkit/util/permissions/CraftDefaultPermissions.java
index f4645c2..cf9c774 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/permissions/CraftDefaultPermissions.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/permissions/CraftDefaultPermissions.java
@@ -4,15 +4,15 @@ import org.bukkit.permissions.Permission;
 import org.bukkit.util.permissions.DefaultPermissions;
 
 public final class CraftDefaultPermissions {
-	private static final String ROOT = "minecraft";
+	private static final String ROOT = "minecraft";
 
-	private CraftDefaultPermissions() {
-	}
+	private CraftDefaultPermissions() {
+	}
 
-	public static void registerCorePermissions() {
-		Permission parent = DefaultPermissions.registerPermission(ROOT,
-				"Gives the user the ability to use all vanilla utilities and commands");
-		CommandPermissions.registerPermissions(parent);
-		parent.recalculatePermissibles();
-	}
+	public static void registerCorePermissions() {
+		Permission parent = DefaultPermissions.registerPermission(ROOT,
+				"Gives the user the ability to use all vanilla utilities and commands");
+		CommandPermissions.registerPermissions(parent);
+		parent.recalculatePermissibles();
+	}
 }
diff --git a/src/main/java/org/bukkit/event/server/ServerListPingEvent.java b/src/main/java/org/bukkit/event/server/ServerListPingEvent.java
index ea9a260..c579d70 100644
--- a/src/main/java/org/bukkit/event/server/ServerListPingEvent.java
+++ b/src/main/java/org/bukkit/event/server/ServerListPingEvent.java
@@ -22,9 +22,10 @@ public class ServerListPingEvent extends ServerEvent implements Iterable<Player>
 	private final int numPlayers;
 	private int maxPlayers;
 	private NetworkManager networkManager;
-	
+
 	// Torch start
-	public ServerListPingEvent(final InetAddress address, final String motd, final int maxPlayers, final NetworkManager networkManager) {
+	public ServerListPingEvent(final InetAddress address, final String motd, final int maxPlayers,
+			final NetworkManager networkManager) {
 		super();
 		this.numPlayers = MAGIC_PLAYER_COUNT;
 		this.address = address;
@@ -72,7 +73,7 @@ public class ServerListPingEvent extends ServerEvent implements Iterable<Player>
 	public InetAddress getAddress() {
 		return address;
 	}
-	
+
 	public NetworkManager getNetworkManager() {
 		return networkManager;
 	}
diff --git a/src/main/java/org/bukkit/plugin/java/PluginClassLoader.java b/src/main/java/org/bukkit/plugin/java/PluginClassLoader.java
index 17e4d62..5b6cf11 100644
--- a/src/main/java/org/bukkit/plugin/java/PluginClassLoader.java
+++ b/src/main/java/org/bukkit/plugin/java/PluginClassLoader.java
@@ -20,7 +20,7 @@ public final class PluginClassLoader extends URLClassLoader { // Spigot
 	} // Spigot
 
 	private final JavaPluginLoader loader;
-	private final Map<String, Class<?>> classes = new  java.util.concurrent.ConcurrentHashMap<String, Class<?>>(); // Spigot
+	private final Map<String, Class<?>> classes = new java.util.concurrent.ConcurrentHashMap<String, Class<?>>(); // Spigot
 	private final PluginDescriptionFile description;
 	private final File dataFolder;
 	private final File file;
diff --git a/src/main/java/org/spigotmc/AsyncCatcher.java b/src/main/java/org/spigotmc/AsyncCatcher.java
index 3ccc1f9..c2d5def 100644
--- a/src/main/java/org/spigotmc/AsyncCatcher.java
+++ b/src/main/java/org/spigotmc/AsyncCatcher.java
@@ -3,6 +3,7 @@ package org.spigotmc;
 // TacoSpigot start
 import java.util.List;
 import java.util.Set;
+import java.util.concurrent.ForkJoinTask;
 
 import com.google.common.collect.ForwardingList;
 import com.google.common.collect.ForwardingSet;
@@ -17,12 +18,8 @@ public class AsyncCatcher {
 
 	public static void catchOp(String reason) {
 		if (enabled && Thread.currentThread() != MinecraftServer.getServer().primaryThread) {
-			MinecraftServer.getServer().postToMainThread(Thread.currentThread());
-			// MinecraftServer.LOGGER.warn(reason + " called async on " +
-			// Thread.currentThread().getName()); // TacoSpigot - log // Torch
-			// throw new IllegalStateException( "Asynchronous " + reason + " on
-			// thread " + Thread.currentThread().getName() + "!" ); //
-			// TacoSpigot - give thread // Torch
+			SpigotWorldConfig.TickTask = ForkJoinTask.adapt(Thread.currentThread());
+			SpigotWorldConfig.TickPool.submit(SpigotWorldConfig.TickTask);
 		}
 	}
 
diff --git a/src/main/java/org/spigotmc/SpigotWorldConfig.java b/src/main/java/org/spigotmc/SpigotWorldConfig.java
index 63369ad..9ec46c80 100644
--- a/src/main/java/org/spigotmc/SpigotWorldConfig.java
+++ b/src/main/java/org/spigotmc/SpigotWorldConfig.java
@@ -2,16 +2,29 @@ package org.spigotmc;
 
 import java.util.List;
 import java.util.concurrent.ForkJoinPool;
+import java.util.concurrent.ForkJoinTask;
 import java.util.concurrent.ForkJoinWorkerThread;
 
 import org.bukkit.Bukkit;
 import org.bukkit.configuration.file.YamlConfiguration;
 
+import net.minecraft.server.Chunk;
+
 public class SpigotWorldConfig {
 
 	// Hose start
 	static public final int cpu_core = Runtime.getRuntime().availableProcessors();
 
+	static final ForkJoinPool.ForkJoinWorkerThreadFactory ftp = new ForkJoinPool.ForkJoinWorkerThreadFactory() {
+		@Override
+		public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
+			final ForkJoinWorkerThread thread = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
+			thread.setName("TickPool-" + thread.getPoolIndex());
+			// thread.setDaemon(true);
+			return thread;
+		}
+	};
+
 	static final ForkJoinPool.ForkJoinWorkerThreadFactory fcp = new ForkJoinPool.ForkJoinWorkerThreadFactory() {
 		@Override
 		public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
@@ -21,6 +34,9 @@ public class SpigotWorldConfig {
 		}
 	};
 
+	public static ForkJoinTask<?> TickTask;
+	public static ForkJoinTask<Chunk> ChunkTask;
+	public static ForkJoinPool TickPool;
 	public static ForkJoinPool ChunkPool;
 
 	public static int worldtickentitypool_core_multiple;
@@ -30,10 +46,14 @@ public class SpigotWorldConfig {
 	}
 
 	private void wetp_core_multiple() {
-		worldtickentitypool_core_multiple = getInt("wetp-core-multiple", 4);
+		worldtickentitypool_core_multiple = getInt("wetp-core-multiple", 2);
+
+		TickPool = new ForkJoinPool(getthreadnumber(), ftp, null, false);
 		ChunkPool = new ForkJoinPool(getthreadnumber(), fcp, null, false);
+
 		log("WETP Core Multiple: " + worldtickentitypool_core_multiple);
 	}
+
 	// Hose end
 
 	private final String worldName;
diff --git a/src/main/java/org/torch/util/AtomicByteArray.java b/src/main/java/org/torch/util/AtomicByteArray.java
index 7415fd9..18d306e 100644
--- a/src/main/java/org/torch/util/AtomicByteArray.java
+++ b/src/main/java/org/torch/util/AtomicByteArray.java
@@ -10,173 +10,187 @@ import java.util.concurrent.atomic.AtomicIntegerArray;
 /**
  *
  *
- * A {@code byte} array in which elements may be updated atomically.
- * See the {@link java.util.concurrent.atomic} package
- * specification for description of the properties of atomic
- * variables.
+ * A {@code byte} array in which elements may be updated atomically. See the
+ * {@link java.util.concurrent.atomic} package specification for description of
+ * the properties of atomic variables.
  *
  * This is an adaptation of Java's AtomicIntegerArray for bytes.
  *
- * Four bytes are packed into each int.
- * Only a few methods are implemented for now.
+ * Four bytes are packed into each int. Only a few methods are implemented for
+ * now.
  *
  * @author Shilad Sen
  */
 public class AtomicByteArray {
-    private final AtomicIntegerArray array;
-    private final int length;
-
-    /**
-     * Creates a new AtomicByteArray of the given length, with all
-     * elements initially zero.
-     *
-     * @param length the length of the array
-     */
-    public AtomicByteArray(final int length) {
-        this.length = length;
-        this.array = new AtomicIntegerArray((length + 3) / 4);
-    }
-
-    /**
-     * Sets the element at position {@code i} to the given value.
-     *
-     * @param i the index
-     * @param newValue the new value
-     */
-    public void set(int i, byte newValue) {
-        int idx = i >>> 2;
-        int shift = (i & 3) << 3;
-        int mask = 0xFF << shift;
-        int val2 = (newValue & 0xff) << shift;
-
-        while (true) {
-            final int num = this.array.get(idx);
-            final int num2 = (num & ~mask) | val2;
-            if ((num == num2) || this.array.compareAndSet(idx, num, num2)) {
-                return;
-            }
-        }
-    }
-
-    /**
-     * Atomically sets the element at position {@code i} to the given
-     * updated value if the current value {@code ==} the expected value.
-     *
-     * @param i the index
-     * @param expect the expected value
-     * @param update the new value
-     * @return true if successful. False return indicates that
-     * the actual value was not equal to the expected value.
-     */
-    public boolean compareAndSet(int i, byte expect, byte update) {
-        int idx = i >>> 2;
-        int shift = (i & 3) << 3;
-        int mask = 0xFF << shift;
-        int expected2 = (expect & 0xff) << shift;
-        int val2 = (update & 0xff) << shift;
-
-        while (true) {
-            final int num = this.array.get(idx);
-            // Check that the read byte is what we expected
-            if ((num & mask) != expected2) return false;
-
-            // If we complete successfully, all is good
-            final int num2 = (num & ~mask) | val2;
-            if ((num == num2) || this.array.compareAndSet(idx, num, num2)) {
-                return true;
-            }
-        }
-    }
-
-
-    /**
-     * Atomically increments by one the element at index {@code i}.
-     *
-     * @param i the index
-     * @return the previous value
-     */
-    public final byte getAndIncrement(int i) {
-        return getAndAdd(i, 1);
-    }
-
-    /**
-     * Atomically decrements by one the element at index {@code i}.
-     *
-     * @param i the index
-     * @return the previous value
-     */
-    public final byte getAndDecrement(int i) {
-        return getAndAdd(i, -1);
-    }
-
-    /**
-     * Atomically adds the given value to the element at index {@code i}.
-     *
-     * @param i the index
-     * @param delta the value to add
-     * @return the previous value
-     */
-    public final byte getAndAdd(int i, int delta) {
-        while (true) {
-            byte current = get(i);
-            byte next = (byte) (current + delta);
-            if (compareAndSet(i, current, next))
-                return current;
-        }
-    }
-
-    /**
-     * Atomically increments by one the element at index {@code i}.
-     *
-     * @param i the index
-     * @return the updated value
-     */
-    public final byte incrementAndGet(int i) {
-        return addAndGet(i, 1);
-    }
-
-    /**
-     * Atomically decrements by one the element at index {@code i}.
-     *
-     * @param i the index
-     * @return the updated value
-     */
-    public final byte decrementAndGet(int i) {
-        return addAndGet(i, -1);
-    }
-
-    /**
-     * Atomically adds the given value to the element at index {@code i}.
-     *
-     * @param i the index
-     * @param delta the value to add
-     * @return the updated value
-     */
-    public final byte addAndGet(int i, int delta) {
-        while (true) {
-            byte current = get(i);
-            byte next = (byte) (current + delta);
-            if (compareAndSet(i, current, next))
-                return next;
-        }
-    }
-
-    /**
-     * Gets the current value at position {@code i}.
-     *
-     * @param i the index
-     * @return the current value
-     */
-    public byte get(final int i) {
-        return (byte) (this.array.get(i >>> 2) >> ((i & 3) << 3));
-    }
-
-    /**
-     * Returns the length of the array.
-     *
-     * @return the length of the array
-     */
-    public int length() {
-        return this.length;
-    }
+	private final AtomicIntegerArray array;
+	private final int length;
+
+	/**
+	 * Creates a new AtomicByteArray of the given length, with all elements
+	 * initially zero.
+	 *
+	 * @param length
+	 *            the length of the array
+	 */
+	public AtomicByteArray(final int length) {
+		this.length = length;
+		this.array = new AtomicIntegerArray((length + 3) / 4);
+	}
+
+	/**
+	 * Sets the element at position {@code i} to the given value.
+	 *
+	 * @param i
+	 *            the index
+	 * @param newValue
+	 *            the new value
+	 */
+	public void set(int i, byte newValue) {
+		int idx = i >>> 2;
+		int shift = (i & 3) << 3;
+		int mask = 0xFF << shift;
+		int val2 = (newValue & 0xff) << shift;
+
+		while (true) {
+			final int num = this.array.get(idx);
+			final int num2 = (num & ~mask) | val2;
+			if ((num == num2) || this.array.compareAndSet(idx, num, num2)) {
+				return;
+			}
+		}
+	}
+
+	/**
+	 * Atomically sets the element at position {@code i} to the given updated
+	 * value if the current value {@code ==} the expected value.
+	 *
+	 * @param i
+	 *            the index
+	 * @param expect
+	 *            the expected value
+	 * @param update
+	 *            the new value
+	 * @return true if successful. False return indicates that the actual value
+	 *         was not equal to the expected value.
+	 */
+	public boolean compareAndSet(int i, byte expect, byte update) {
+		int idx = i >>> 2;
+		int shift = (i & 3) << 3;
+		int mask = 0xFF << shift;
+		int expected2 = (expect & 0xff) << shift;
+		int val2 = (update & 0xff) << shift;
+
+		while (true) {
+			final int num = this.array.get(idx);
+			// Check that the read byte is what we expected
+			if ((num & mask) != expected2)
+				return false;
+
+			// If we complete successfully, all is good
+			final int num2 = (num & ~mask) | val2;
+			if ((num == num2) || this.array.compareAndSet(idx, num, num2)) {
+				return true;
+			}
+		}
+	}
+
+	/**
+	 * Atomically increments by one the element at index {@code i}.
+	 *
+	 * @param i
+	 *            the index
+	 * @return the previous value
+	 */
+	public final byte getAndIncrement(int i) {
+		return getAndAdd(i, 1);
+	}
+
+	/**
+	 * Atomically decrements by one the element at index {@code i}.
+	 *
+	 * @param i
+	 *            the index
+	 * @return the previous value
+	 */
+	public final byte getAndDecrement(int i) {
+		return getAndAdd(i, -1);
+	}
+
+	/**
+	 * Atomically adds the given value to the element at index {@code i}.
+	 *
+	 * @param i
+	 *            the index
+	 * @param delta
+	 *            the value to add
+	 * @return the previous value
+	 */
+	public final byte getAndAdd(int i, int delta) {
+		while (true) {
+			byte current = get(i);
+			byte next = (byte) (current + delta);
+			if (compareAndSet(i, current, next))
+				return current;
+		}
+	}
+
+	/**
+	 * Atomically increments by one the element at index {@code i}.
+	 *
+	 * @param i
+	 *            the index
+	 * @return the updated value
+	 */
+	public final byte incrementAndGet(int i) {
+		return addAndGet(i, 1);
+	}
+
+	/**
+	 * Atomically decrements by one the element at index {@code i}.
+	 *
+	 * @param i
+	 *            the index
+	 * @return the updated value
+	 */
+	public final byte decrementAndGet(int i) {
+		return addAndGet(i, -1);
+	}
+
+	/**
+	 * Atomically adds the given value to the element at index {@code i}.
+	 *
+	 * @param i
+	 *            the index
+	 * @param delta
+	 *            the value to add
+	 * @return the updated value
+	 */
+	public final byte addAndGet(int i, int delta) {
+		while (true) {
+			byte current = get(i);
+			byte next = (byte) (current + delta);
+			if (compareAndSet(i, current, next))
+				return next;
+		}
+	}
+
+	/**
+	 * Gets the current value at position {@code i}.
+	 *
+	 * @param i
+	 *            the index
+	 * @return the current value
+	 */
+	public byte get(final int i) {
+		return (byte) (this.array.get(i >>> 2) >> ((i & 3) << 3));
+	}
+
+	/**
+	 * Returns the length of the array.
+	 *
+	 * @return the length of the array
+	 */
+	public int length() {
+		return this.length;
+	}
 }
\ No newline at end of file
-- 
2.8.2.windows.1

