From a8bbecdb06c4dccc3013ac6fe7248238363b02ad Mon Sep 17 00:00:00 2001
From: SotrForgotten <i@omc.hk>
Date: Fri, 9 Sep 2016 14:37:39 +0800
Subject: [PATCH] Better align combustion with vanilla behaviour


diff --git a/pom.xml b/pom.xml
index 027fe68..31c3915 100644
--- a/pom.xml
+++ b/pom.xml
@@ -101,7 +101,7 @@
         <dependency>
             <groupId>org.hamcrest</groupId>
             <artifactId>hamcrest-library</artifactId>
-            <version>1.3.RC2</version>
+            <version>1.3</version>
             <scope>test</scope>
         </dependency>
     </dependencies>
diff --git a/src/main/java/de/minetick/MigotConfig.java b/src/main/java/de/minetick/MigotConfig.java
index 5a76adc..cb0d64d 100644
--- a/src/main/java/de/minetick/MigotConfig.java
+++ b/src/main/java/de/minetick/MigotConfig.java
@@ -12,6 +12,7 @@ import org.apache.logging.log4j.Logger;
 import org.bukkit.configuration.InvalidConfigurationException;
 import org.bukkit.configuration.file.FileConfiguration;
 import org.bukkit.configuration.file.YamlConfiguration;
+import org.spigotmc.SpigotWorldConfig;
 
 import com.google.common.base.Charsets;
 
@@ -51,6 +52,7 @@ public class MigotConfig {
 		bungeeForwardingCompatible = configuration.getBoolean("settings.bungee-redirect-compatible", false);
 		deleteCorruptChunk = configuration.getBoolean("settings.delete-corrupt-chunk", false);
 		enableVelocityWarning = configuration.getBoolean("settings.enable-velocity-warn", true);
+		SpigotWorldConfig.worldtickentitypool_core_multiple = configuration.getInt("settings.wetp-core-multiple", 2); // Hose
 		// World settings
 		disableSleepChecking = configuration.getBoolean("world-settings.disable-sleep-checking", false);
 		disableSpawnerModify = configuration.getBoolean("world-settings.disable-mob-spanwer-modify", false);
diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java
index 9708474..3a05a93 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java
@@ -159,7 +159,7 @@ public class ChunkProviderServer implements IChunkProvider {
 		if (chunk == null) {
 			chunk = this.loadChunk(i, j);
 			if (chunk != null) {
-				synchronized(this) { this.chunks.put(ChunkCoordIntPair.a(i, j), chunk); }
+				this.chunks.put(ChunkCoordIntPair.a(i, j), chunk);
 				chunk.addEntities();
 				chunk.loadNearby(this, this.chunkGenerator, false); // CraftBukkit
 			}
@@ -228,7 +228,7 @@ public class ChunkProviderServer implements IChunkProvider {
 				throw new ReportedException(crashreport);
 			}
 
-			synchronized(chunks) { this.chunks.put(k, chunk); }
+			this.chunks.put(k, chunk);
 			chunk.addEntities();
 
 			chunk.loadNearby(this, this.chunkGenerator, true); // CraftBukkit
@@ -388,7 +388,7 @@ public class ChunkProviderServer implements IChunkProvider {
 			this.saveChunk(chunk);
 			this.saveChunkNOP(chunk);
 		}
-		synchronized(this) { this.chunks.remove(chunk.chunkKey); }
+		this.chunks.remove(chunk.chunkKey);
 		return true;
 	}
 	// CraftBukkit end
diff --git a/src/main/java/net/minecraft/server/Entity.java b/src/main/java/net/minecraft/server/Entity.java
index a96db1a..2c4e1a4 100644
--- a/src/main/java/net/minecraft/server/Entity.java
+++ b/src/main/java/net/minecraft/server/Entity.java
@@ -588,344 +588,6 @@ public abstract class Entity implements ICommandListener, org.spigotmc.Optimized
 		return this.world.getCubes(this, axisalignedbb).isEmpty() && !this.world.containsLiquid(axisalignedbb);
 	}
 
-	public void move_hose(double d0, double d1, double d2) { // Hose
-		if (this.noclip) {
-			this.a(this.getBoundingBox().c(d0, d1, d2));
-			this.recalcPosition();
-		} else {
-			// CraftBukkit start - Don't do anything if we aren't moving
-			// We need to do this regardless of whether or not we are moving
-			// thanks to portals
-			try {
-				this.checkBlockCollisions();
-			} catch (Throwable throwable) {
-				CrashReport crashreport = CrashReport.a(throwable, "Checking entity block collision");
-				CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Entity being checked for collision");
-
-				this.appendEntityCrashDetails(crashreportsystemdetails);
-				throw new ReportedException(crashreport);
-			}
-			// Check if we're moving
-			if (d0 == 0 && d1 == 0 && d2 == 0 && this.isVehicle() && this.isPassenger()) {
-				return;
-			}
-			// CraftBukkit end
-			this.world.methodProfiler.a("move");
-			double d3 = this.locX;
-			double d4 = this.locY;
-			double d5 = this.locZ;
-
-			if (this.E) {
-				this.E = false;
-				d0 *= 0.25D;
-				d1 *= 0.05000000074505806D;
-				d2 *= 0.25D;
-				this.motX = 0.0D;
-				this.motY = 0.0D;
-				this.motZ = 0.0D;
-			}
-
-			double d6 = d0;
-			double d7 = d1;
-			double d8 = d2;
-			boolean flag = this.onGround && this.isSneaking() && this instanceof EntityHuman;
-
-			if (flag) {
-				double d9;
-
-				for (d9 = 0.05D; d0 != 0.0D
-						&& this.world.getCubes(this, this.getBoundingBox().c(d0, -1.0D, 0.0D)).isEmpty(); d6 = d0) {
-					if (d0 < d9 && d0 >= -d9) {
-						d0 = 0.0D;
-					} else if (d0 > 0.0D) {
-						d0 -= d9;
-					} else {
-						d0 += d9;
-					}
-				}
-
-				for (; d2 != 0.0D
-						&& this.world.getCubes(this, this.getBoundingBox().c(0.0D, -1.0D, d2)).isEmpty(); d8 = d2) {
-					if (d2 < d9 && d2 >= -d9) {
-						d2 = 0.0D;
-					} else if (d2 > 0.0D) {
-						d2 -= d9;
-					} else {
-						d2 += d9;
-					}
-				}
-
-				for (; d0 != 0.0D && d2 != 0.0D
-						&& this.world.getCubes(this, this.getBoundingBox().c(d0, -1.0D, d2)).isEmpty(); d8 = d2) {
-					if (d0 < d9 && d0 >= -d9) {
-						d0 = 0.0D;
-					} else if (d0 > 0.0D) {
-						d0 -= d9;
-					} else {
-						d0 += d9;
-					}
-
-					d6 = d0;
-					if (d2 < d9 && d2 >= -d9) {
-						d2 = 0.0D;
-					} else if (d2 > 0.0D) {
-						d2 -= d9;
-					} else {
-						d2 += d9;
-					}
-				}
-			}
-
-			List list = this.world.getCubes(this, this.getBoundingBox().a(d0, d1, d2));
-			AxisAlignedBB axisalignedbb = this.getBoundingBox();
-
-			int j;
-
-			for (Object ab : list) {
-				d1 = ((AxisAlignedBB) ab).b(this.getBoundingBox(), d1);
-			}
-
-			this.a(this.getBoundingBox().c(0.0D, d1, 0.0D));
-			boolean flag1 = this.onGround || d7 != d1 && d7 < 0.0D;
-
-			j = 0;
-
-			int k;
-
-			for (Object ab : list) {
-				d0 = ((AxisAlignedBB) ab).a(this.getBoundingBox(), d0);
-			}
-
-			this.a(this.getBoundingBox().c(d0, 0.0D, 0.0D));
-			j = 0;
-
-			for (Object ab : list) {
-				d2 = ((AxisAlignedBB) ab).c(this.getBoundingBox(), d2);
-			}
-
-			this.a(this.getBoundingBox().c(0.0D, 0.0D, d2));
-			double d10;
-
-			if (this.P > 0.0F && flag1 && (d6 != d0 || d8 != d2)) {
-				double d11 = d0;
-				double d12 = d1;
-				double d13 = d2;
-				AxisAlignedBB axisalignedbb1 = this.getBoundingBox();
-
-				this.a(axisalignedbb);
-				d1 = this.P;
-				List list1 = this.world.getCubes(this, this.getBoundingBox().a(d6, d1, d8));
-				AxisAlignedBB axisalignedbb2 = this.getBoundingBox();
-				AxisAlignedBB axisalignedbb3 = axisalignedbb2.a(d6, 0.0D, d8);
-
-				d10 = d1;
-				for (Object ab : list1) {
-					d10 = ((AxisAlignedBB) ab).b(axisalignedbb3, d10);
-				}
-
-				axisalignedbb2 = axisalignedbb2.c(0.0D, d10, 0.0D);
-				double d14 = d6;
-				for (Object ab : list1) {
-					d14 = ((AxisAlignedBB) ab).a(axisalignedbb2, d14);
-				}
-
-				axisalignedbb2 = axisalignedbb2.c(d14, 0.0D, 0.0D);
-				double d15 = d8;
-				for (Object ab : list1) {
-					d15 = ((AxisAlignedBB) ab).c(axisalignedbb2, d15);
-				}
-
-				axisalignedbb2 = axisalignedbb2.c(0.0D, 0.0D, d15);
-				AxisAlignedBB axisalignedbb4 = this.getBoundingBox();
-				double d16 = d1;
-				for (Object ab : list1) {
-					d16 = ((AxisAlignedBB) ab).b(axisalignedbb4, d16);
-				}
-
-				axisalignedbb4 = axisalignedbb4.c(0.0D, d16, 0.0D);
-				double d17 = d6;
-				for (Object ab : list1) {
-					d17 = ((AxisAlignedBB) ab).a(axisalignedbb4, d17);
-				}
-
-				axisalignedbb4 = axisalignedbb4.c(d17, 0.0D, 0.0D);
-				double d18 = d8;
-				for (Object ab : list1) {
-					d18 = ((AxisAlignedBB) ab).c(axisalignedbb4, d18);
-				}
-
-				axisalignedbb4 = axisalignedbb4.c(0.0D, 0.0D, d18);
-				double d19 = d14 * d14 + d15 * d15;
-				double d20 = d17 * d17 + d18 * d18;
-
-				if (d19 > d20) {
-					d0 = d14;
-					d2 = d15;
-					d1 = -d10;
-					this.a(axisalignedbb2);
-				} else {
-					d0 = d17;
-					d2 = d18;
-					d1 = -d16;
-					this.a(axisalignedbb4);
-				}
-
-				for (Object ab : list1) {
-					d1 = ((AxisAlignedBB) ab).b(this.getBoundingBox(), d1);
-				}
-
-				this.a(this.getBoundingBox().c(0.0D, d1, 0.0D));
-				if (d11 * d11 + d13 * d13 >= d0 * d0 + d2 * d2) {
-					d0 = d11;
-					d1 = d12;
-					d2 = d13;
-					this.a(axisalignedbb1);
-				}
-			}
-
-			this.world.methodProfiler.b();
-			this.world.methodProfiler.a("rest");
-			this.recalcPosition();
-			this.positionChanged = d6 != d0 || d8 != d2;
-			this.B = d7 != d1;
-			this.onGround = this.B && d7 < 0.0D;
-			this.C = this.positionChanged || this.B;
-			j = MathHelper.floor(this.locX);
-			k = MathHelper.floor(this.locY - 0.20000000298023224D);
-			int j4 = MathHelper.floor(this.locZ);
-			BlockPosition blockposition = new BlockPosition(j, k, j4);
-			IBlockData iblockdata = this.world.getType(blockposition);
-
-			if (iblockdata.getMaterial() == Material.AIR) {
-				BlockPosition blockposition1 = blockposition.down();
-				IBlockData iblockdata1 = this.world.getType(blockposition1);
-				Block block = iblockdata1.getBlock();
-
-				if (block instanceof BlockFence || block instanceof BlockCobbleWall
-						|| block instanceof BlockFenceGate) {
-					iblockdata = iblockdata1;
-					blockposition = blockposition1;
-				}
-			}
-
-			this.a(d1, this.onGround, iblockdata, blockposition);
-			if (d6 != d0) {
-				this.motX = 0.0D;
-			}
-
-			if (d8 != d2) {
-				this.motZ = 0.0D;
-			}
-
-			Block block1 = iblockdata.getBlock();
-
-			if (d7 != d1) {
-				block1.a(this.world, this);
-			}
-
-			// CraftBukkit start
-			if (positionChanged && getBukkitEntity() instanceof Vehicle) {
-				Vehicle vehicle = (Vehicle) this.getBukkitEntity();
-				org.bukkit.block.Block bl = this.world.getWorld().getBlockAt(MathHelper.floor(this.locX),
-						MathHelper.floor(this.locY), MathHelper.floor(this.locZ));
-
-				if (d6 > d0) {
-					bl = bl.getRelative(BlockFace.EAST);
-				} else if (d6 < d0) {
-					bl = bl.getRelative(BlockFace.WEST);
-				} else if (d8 > d2) {
-					bl = bl.getRelative(BlockFace.SOUTH);
-				} else if (d8 < d2) {
-					bl = bl.getRelative(BlockFace.NORTH);
-				}
-
-				VehicleBlockCollisionEvent event = new VehicleBlockCollisionEvent(vehicle, bl);
-				world.getServer().getPluginManager().callEvent(event);
-			}
-			// CraftBukkit end
-
-			if (this.playStepSound() && !flag && !this.isPassenger()) {
-				double d21 = this.locX - d3;
-				double d22 = this.locY - d4;
-
-				d10 = this.locZ - d5;
-				if (block1 != Blocks.LADDER) {
-					d22 = 0.0D;
-				}
-
-				if (block1 != null && this.onGround) {
-					// block1.stepOn(this.world, blockposition, this); //
-					// CraftBukkit moved down
-				}
-
-				this.J = (float) (this.J + MathHelper.sqrt(d21 * d21 + d10 * d10) * 0.6D);
-				this.K = (float) (this.K + MathHelper.sqrt(d21 * d21 + d22 * d22 + d10 * d10) * 0.6D);
-				if (this.K > this.aw && iblockdata.getMaterial() != Material.AIR) {
-					this.aw = (int) this.K + 1;
-					if (this.isInWater()) {
-						float f = MathHelper.sqrt(this.motX * this.motX * 0.20000000298023224D + this.motY * this.motY
-								+ this.motZ * this.motZ * 0.20000000298023224D) * 0.35F;
-
-						if (f > 1.0F) {
-							f = 1.0F;
-						}
-
-						this.a(this.aa(), f, 1.0F + (this.random.nextFloat() - this.random.nextFloat()) * 0.4F);
-					}
-
-					this.a(blockposition, block1);
-					block1.stepOn(this.world, blockposition, this); // CraftBukkit
-																	// moved
-																	// from
-																	// above
-				}
-			}
-
-			// Hose start
-			boolean flag2 = this.ah(); // Torch - fix method name
-
-			if (this.world.f(this.getBoundingBox().shrink(0.001D))) {
-				this.burn(1);
-				if (!flag2) {
-					++this.fireTicks;
-					// CraftBukkit start - Not on fire yet
-					if (this.fireTicks <= 0 && !this.isInWater()) { // Only
-																	// throw
-																	// events on
-																	// the first
-																	// combust,
-																	// otherwise
-																	// it spams
-																	// // Torch
-																	// - do not
-																	// fire
-																	// entity if
-																	// it is in
-																	// water
-						EntityCombustEvent event = new org.bukkit.event.entity.EntityCombustByBlockEvent(null,
-								getBukkitEntity(), 8);
-						world.getServer().getPluginManager().callEvent(event);
-
-						if (!event.isCancelled()) {
-							this.setOnFire(event.getDuration());
-						}
-					} else {
-						// CraftBukkit end
-						this.setOnFire(8);
-					}
-				}
-			} else if (this.fireTicks <= 0) {
-				this.fireTicks = -this.maxFireTicks;
-			}
-
-			if (flag2 && this.fireTicks > 0) {
-				this.a(SoundEffects.bG, 0.7F, 1.6F + (this.random.nextFloat() - this.random.nextFloat()) * 0.4F);
-				this.fireTicks = -this.maxFireTicks;
-			}
-
-			this.world.methodProfiler.b();
-		}
-	}
 
 	public void move(double d0, double d1, double d2) {
 		if (this.noclip) {
@@ -1228,22 +890,9 @@ public abstract class Entity implements ICommandListener, org.spigotmc.Optimized
 				this.burn(1);
 				if (!flag2) {
 					++this.fireTicks;
-					// CraftBukkit start - Not on fire yet
-					if (this.fireTicks <= 0 && !this.isInWater()) { // Only
-																	// throw
-																	// events on
-																	// the first
-																	// combust,
-																	// otherwise
-																	// it spams
-																	// // Torch
-																	// - do not
-																	// fire
-																	// entity if
-																	// it is in
-																	// water
-						EntityCombustEvent event = new org.bukkit.event.entity.EntityCombustByBlockEvent(null,
-								getBukkitEntity(), 8); // Torch - SPIGOT-2405
+					if (this.fireTicks == 0 && !this.isInWater()) { // Only throw events on the first combust, otherwise it spams // Torch
+						// CraftBukkit start
+						EntityCombustEvent event = new org.bukkit.event.entity.EntityCombustByBlockEvent(null, getBukkitEntity(), 8); // Torch - SPIGOT-2405
 						world.getServer().getPluginManager().callEvent(event);
 
 						if (!event.isCancelled()) {
@@ -3275,7 +2924,7 @@ public abstract class Entity implements ICommandListener, org.spigotmc.Optimized
 
 		@Override
 		protected void compute() {
-			move_hose(d0, d1, d2);
+			move(d0, d1, d2);
 		}
 
 	}
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index 0abab0d..2e1968b 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -10,6 +10,7 @@ import java.util.Queue;
 import java.util.Random;
 // Paper start
 import java.util.Set;
+import java.util.Collections;
 import com.destroystokyo.paper.antixray.BlockPacketController; // Paper - Anti-Xray - Default singleton implementation for vanilla
 import com.destroystokyo.paper.antixray.BlockPacketControllerObfuscate; // Paper - Anti-Xray - Anti-Xray implementation
 import com.destroystokyo.paper.antixray.IBlockPacketController; // Paper - Anti-Xray - Interface with methods used to control which and how blocks are sent
@@ -20,6 +21,7 @@ import java.util.concurrent.ForkJoinTask;
 // Paper end
 import java.util.concurrent.RecursiveAction;
 import java.util.concurrent.RecursiveTask;
+import java.util.concurrent.atomic.AtomicInteger;
 
 import javax.annotation.Nullable;
 
@@ -63,7 +65,8 @@ public abstract class World implements IBlockAccess {
 	// Spigot start - guard entity list from removals
 	protected boolean cancelHeavyCalculations = false;
 
-	public final List<Entity> entityList = new java.util.concurrent.CopyOnWriteArrayList();
+	// public final List<Entity> entityList = new java.util.concurrent.CopyOnWriteArrayList();
+	public final List<Entity> entityList = Collections.synchronizedList(new java.util.ArrayList());
 	// Spigot end
 	protected final Queue<Entity> f = Queues.newConcurrentLinkedQueue();
 	// public final List<TileEntity> tileEntityList = Lists.newArrayList(); //
@@ -129,7 +132,7 @@ public abstract class World implements IBlockAccess {
 	public long ticksPerAnimalSpawns;
 	public long ticksPerMonsterSpawns;
 	public boolean populating;
-	private int tickPosition;
+	private AtomicInteger tickPosition;
 	public final org.spigotmc.SpigotWorldConfig spigotConfig; // Spigot
 
 	public final com.destroystokyo.paper.PaperWorldConfig paperConfig; // Paper
@@ -252,6 +255,7 @@ public abstract class World implements IBlockAccess {
 		this.keepSpawnInMemory = this.paperConfig.keepSpawnInMemory; // Paper
 		this.entityLimiter = new org.spigotmc.TickLimiter(spigotConfig.entityMaxTickTime);
 		this.tileLimiter = new org.spigotmc.TickLimiter(spigotConfig.tileMaxTickTime);
+		this.tickPosition = new AtomicInteger();
 	}
 
 	public World b() {
@@ -1363,8 +1367,9 @@ public abstract class World implements IBlockAccess {
 			// already ticked this entity
 			int index = this.entityList.indexOf(entity);
 			if (index != -1) {
-				if (index <= this.tickPosition) {
-					this.tickPosition--;
+				if (index <= this.tickPosition.get()) {
+					// this.tickPosition--;
+					this.tickPosition.getAndDecrement();
 				}
 				this.entityList.remove(index);
 			}
@@ -1618,56 +1623,6 @@ public abstract class World implements IBlockAccess {
 	public void b(BlockPosition blockposition, Block block, int i, int j) {
 	}
 	
-	public void tick_task(Entity entity) {
-        // CraftBukkit end
-        Entity entity1 = entity.bz();
-
-        if (entity1 != null) {
-            if (!entity1.dead && entity1.w(entity)) {
-            	return;
-            }
-
-            entity.stopRiding();
-        }
-
-        this.methodProfiler.a("tick");
-        if (!entity.dead && !(entity instanceof EntityPlayer)) {
-            try {
-                entity.tickTimer.startTiming(); // Paper
-                this.g(entity);
-                entity.tickTimer.stopTiming(); // Paper
-            } catch (Throwable throwable1) {
-                entity.tickTimer.stopTiming();
-                // Paper start - Prevent tile entity and entity crashes
-                String msg = "Entity threw exception at " + entity.world.getWorld().getName() + ":" + entity.locX + "," + entity.locY + "," + entity.locZ;
-                System.err.println(msg);
-                throwable1.printStackTrace();
-                getServer().getPluginManager().callEvent(new ServerExceptionEvent(new ServerInternalException(msg, throwable1)));
-                entity.dead = true;
-                return;
-                // Paper end
-            }
-        }
-
-        this.methodProfiler.b();
-        this.methodProfiler.a("remove");
-        if (entity.dead) {
-            int j = entity.ab;
-            int l = entity.ad;
-
-            if (entity.aa && this.isChunkLoaded(j, l, true)) {
-                this.getChunkAt(j, l).b(entity);
-            }
-
-            guardEntityList = false; // Spigot
-            this.entityList.remove(this.tickPosition--); // CraftBukkit - Use field for loop variable
-            guardEntityList = true; // Spigot
-            this.c(entity);
-        }
-
-        this.methodProfiler.b();
-	}
-	
 	// Torch start
 	class tickEntitiesTask extends RecursiveAction {
 		tickEntitiesTask() {}
@@ -1750,26 +1705,71 @@ public abstract class World implements IBlockAccess {
 		this.methodProfiler.c("regular");
 
 		org.spigotmc.ActivationRange.activateEntities(this); // Spigot
-		timings.entityTick.startTiming(); // Spigot
-		guardEntityList = true; // Spigot
-		// CraftBukkit start - Use field for loop variable
-		co.aikar.timings.TimingHistory.entityTicks += this.entityList.size(); // Paper
-		// Paper start - Disable tick limiters
-		// if (tickPosition < 0) tickPosition = 0;
-		for (tickPosition = 0; tickPosition < entityList.size(); tickPosition++) {
-			// Paper end
-			tickPosition = (tickPosition < entityList.size()) ? tickPosition : 0;
-			// Torch start
-	        entity = (Entity) this.entityList.get(this.tickPosition);
-	        Tick_task task = new Tick_task(entity);
-	        SpigotWorldConfig.EntityPool.invoke(task);
-	        // tick_task(entity);
-	        // Torch end
-	        // CraftBukkit end
+        timings.entityTick.startTiming(); // Spigot
+        guardEntityList = true; // Spigot
+        // CraftBukkit start - Use field for loop variable
+        co.aikar.timings.TimingHistory.entityTicks += this.entityList.size(); // Paper
+        int entitiesThisCycle = 0;
+        // Paper start - Disable tick limiters
+        //if (tickPosition < 0) tickPosition = 0;
+        for (tickPosition.set(0); tickPosition.get() < entityList.size(); tickPosition.getAndIncrement()) {
+            // Paper end
+        	if (!(tickPosition.get() < entityList.size())) {
+        		tickPosition.set(0);
+        	}
+            // tickPosition = (tickPosition < entityList.size()) ? tickPosition : 0;
+            entity = (Entity) this.entityList.get(this.tickPosition.get());
+            // CraftBukkit end
+            Entity entity1 = entity.bz();
+
+            if (entity1 != null) {
+                if (!entity1.dead && entity1.w(entity)) {
+                    continue;
+                }
+
+                entity.stopRiding();
+            }
+
+            this.methodProfiler.a("tick");
+            if (!entity.dead && !(entity instanceof EntityPlayer)) {
+                try {
+                    entity.tickTimer.startTiming(); // Paper
+                    this.g(entity);
+                    entity.tickTimer.stopTiming(); // Paper
+                } catch (Throwable throwable1) {
+                    entity.tickTimer.stopTiming();
+                    // Paper start - Prevent tile entity and entity crashes
+                    String msg = "Entity threw exception at " + entity.world.getWorld().getName() + ":" + entity.locX + "," + entity.locY + "," + entity.locZ;
+                    System.err.println(msg);
+                    throwable1.printStackTrace();
+                    getServer().getPluginManager().callEvent(new ServerExceptionEvent(new ServerInternalException(msg, throwable1)));
+                    entity.dead = true;
+                    continue;
+                    // Paper end
+                }
+            }
+
+            this.methodProfiler.b();
+            this.methodProfiler.a("remove");
+            if (entity.dead) {
+                j = entity.ab;
+                int l = entity.ad;
+
+                if (entity.aa && this.isChunkLoaded(j, l, true)) {
+                    this.getChunkAt(j, l).b(entity);
+                }
+
+                guardEntityList = false; // Spigot
+                this.entityList.remove(this.tickPosition.getAndDecrement()); // CraftBukkit - Use field for loop variable
+                guardEntityList = true; // Spigot
+                this.c(entity);
+            }
+
+            this.methodProfiler.b();
         }
-		guardEntityList = false; // Spigot
+        guardEntityList = false; // Spigot
 
-		timings.entityTick.stopTiming(); // Spigot
+        timings.entityTick.stopTiming(); // Spigot
 		this.methodProfiler.c("blockEntities");
 		this.M = true;
 		// CraftBukkit start - From below, clean up tile entities before ticking
@@ -1908,8 +1908,25 @@ public abstract class World implements IBlockAccess {
 	public void g(Entity entity) {
 		this.entityJoinedWorld(entity, true);
 	}
+	
+	class entityJoinedTask extends RecursiveAction {
+		Entity entity; boolean flag;
+		public entityJoinedTask(Entity entity, boolean flag) {
+			this.entity = entity; this.flag = flag;
+		}
+
+		@Override
+		protected void compute() {
+			entityJoinedWorld_task(entity, flag);
+		}
+	}
 
 	public void entityJoinedWorld(Entity entity, boolean flag) {
+		entityJoinedTask task = new entityJoinedTask(entity, flag);
+		SpigotWorldConfig.EntityPool.invoke(task);
+	}
+
+	public void entityJoinedWorld_task(Entity entity, boolean flag) {
 		MathHelper.floor(entity.locX);
 		MathHelper.floor(entity.locZ);
 		// Spigot start
@@ -3639,20 +3656,6 @@ public abstract class World implements IBlockAccess {
 	public LootTableRegistry ak() {
 		return this.B;
 	}
-	
-	class Tick_task extends RecursiveAction {
-		Entity entity;
-		
-		Tick_task(Entity entity) {
-			this.entity = entity;
-		}
-
-		@Override
-		protected void compute() {
-			tick_task(entity);
-		}
-
-	}
 
 	class get_en extends RecursiveAction {
 		World world;
diff --git a/src/main/java/net/minecraft/server/WorldServer.java b/src/main/java/net/minecraft/server/WorldServer.java
index 50a42b3..b021fcb 100644
--- a/src/main/java/net/minecraft/server/WorldServer.java
+++ b/src/main/java/net/minecraft/server/WorldServer.java
@@ -492,15 +492,9 @@ public class WorldServer extends World implements IAsyncTaskHandler {
 				int k = chunk.locZ * 16;
 
 				this.methodProfiler.c("checkNextLight");
-				// chunk.n();
-				light_tick l_task = new light_tick(chunk);
-				SpigotWorldConfig.TickPool.invoke(l_task);
-				// l_task.fork();
+				chunk.n();
 				this.methodProfiler.c("tickChunk");
-				// chunk.b(false);
-				chunk_tick c_task = new chunk_tick(chunk);
-				SpigotWorldConfig.TickPool.invoke(c_task);
-				// c_tick.fork();
+				chunk.b(false);
 				if (!chunk.areNeighborsLoaded(1)) {
 					continue; // Spigot
 				}
diff --git a/src/main/java/org/bukkit/command/defaults/VersionCommand.java b/src/main/java/org/bukkit/command/defaults/VersionCommand.java
index 46c08bf..56b4b5c 100644
--- a/src/main/java/org/bukkit/command/defaults/VersionCommand.java
+++ b/src/main/java/org/bukkit/command/defaults/VersionCommand.java
@@ -1,316 +1,327 @@
 package org.bukkit.command.defaults;
 
-import java.io.BufferedReader;
-import java.io.IOException;
-// Paper start
-import java.io.InputStreamReader;
-import java.net.HttpURLConnection;
-// Paper end
-import java.net.URL;
+import com.google.common.base.Charsets;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.HashSet;
 import java.util.List;
-import java.util.Set;
-import java.util.concurrent.locks.ReentrantLock;
 
-import org.apache.commons.lang3.Validate;
+import org.apache.commons.lang.Validate;
 import org.bukkit.Bukkit;
 import org.bukkit.ChatColor;
 import org.bukkit.command.CommandSender;
 import org.bukkit.plugin.Plugin;
 import org.bukkit.plugin.PluginDescriptionFile;
 import org.bukkit.util.StringUtil;
+
+import com.google.common.collect.ImmutableList;
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.net.URL;
+import java.util.HashSet;
+import java.util.Set;
+import java.util.concurrent.locks.ReentrantLock;
+import com.alibaba.fastjson.JSONObject; // Torch
 import org.json.simple.parser.JSONParser;
 import org.json.simple.parser.ParseException;
 
-// import org.json.simple.JSONObject;
-import com.alibaba.fastjson.JSONObject;
-import com.google.common.base.Charsets;
-import com.google.common.collect.ImmutableList;
+// Paper start
+import java.io.InputStreamReader;
+import java.net.HttpURLConnection;
+// Paper end
 
 public class VersionCommand extends BukkitCommand {
-	public VersionCommand(String name) {
-		super(name);
-
-		this.description = "Gets the version of this server including any plugins in use";
-		this.usageMessage = "/version [plugin name]";
-		this.setPermission("bukkit.command.version");
-		this.setAliases(Arrays.asList("ver", "about"));
-	}
-
-	@Override
-	public boolean execute(CommandSender sender, String currentAlias, String[] args) {
-		if (!testPermission(sender)) {
-			return true;
-		}
-
-		if (args.length == 0) {
-			sender.sendMessage("This server is running " + Bukkit.getName() + " version " + Bukkit.getVersion()
-					+ " (Implementing API version " + Bukkit.getBukkitVersion() + ")");
-			sendVersion(sender);
-		} else {
-			StringBuilder name = new StringBuilder();
-
-			for (String arg : args) {
-				if (name.length() > 0) {
-					name.append(' ');
-				}
-
-				name.append(arg);
-			}
-
-			String pluginName = name.toString();
-			Plugin exactPlugin = Bukkit.getPluginManager().getPlugin(pluginName);
-			if (exactPlugin != null) {
-				describeToSender(exactPlugin, sender);
-				return true;
-			}
-
-			boolean found = false;
-			pluginName = pluginName.toLowerCase();
-			for (Plugin plugin : Bukkit.getPluginManager().getPlugins()) {
-				if (plugin.getName().toLowerCase().contains(pluginName)) {
-					describeToSender(plugin, sender);
-					found = true;
-				}
-			}
-
-			if (!found) {
-				sender.sendMessage("This server is not running any plugin by that name.");
-				sender.sendMessage("Use /plugins to get a list of plugins.");
-			}
-		}
-		return true;
-	}
-
-	private void describeToSender(Plugin plugin, CommandSender sender) {
-		PluginDescriptionFile desc = plugin.getDescription();
-		sender.sendMessage(
-				ChatColor.GREEN + desc.getName() + ChatColor.WHITE + " version " + ChatColor.GREEN + desc.getVersion());
-
-		if (desc.getDescription() != null) {
-			sender.sendMessage(desc.getDescription());
-		}
-
-		if (desc.getWebsite() != null) {
-			sender.sendMessage("Website: " + ChatColor.GREEN + desc.getWebsite());
-		}
-
-		if (!desc.getAuthors().isEmpty()) {
-			if (desc.getAuthors().size() == 1) {
-				sender.sendMessage("Author: " + getAuthors(desc));
-			} else {
-				sender.sendMessage("Authors: " + getAuthors(desc));
-			}
-		}
-	}
-
-	private String getAuthors(final PluginDescriptionFile desc) {
-		StringBuilder result = new StringBuilder();
-		List<String> authors = desc.getAuthors();
-
-		for (int i = 0; i < authors.size(); i++) {
-			if (result.length() > 0) {
-				result.append(ChatColor.WHITE);
-
-				if (i < authors.size() - 1) {
-					result.append(", ");
-				} else {
-					result.append(" and ");
-				}
-			}
-
-			result.append(ChatColor.GREEN);
-			result.append(authors.get(i));
-		}
-
-		return result.toString();
-	}
-
-	@Override
-	public List<String> tabComplete(CommandSender sender, String alias, String[] args) {
-		Validate.notNull(sender, "Sender cannot be null");
-		Validate.notNull(args, "Arguments cannot be null");
-		Validate.notNull(alias, "Alias cannot be null");
-
-		if (args.length == 1) {
-			List<String> completions = new ArrayList<String>();
-			String toComplete = args[0].toLowerCase();
-			for (Plugin plugin : Bukkit.getPluginManager().getPlugins()) {
-				if (StringUtil.startsWithIgnoreCase(plugin.getName(), toComplete)) {
-					completions.add(plugin.getName());
-				}
-			}
-			return completions;
-		}
-		return ImmutableList.of();
-	}
-
-	private final ReentrantLock versionLock = new ReentrantLock();
-	private boolean hasVersion = false;
-	private String versionMessage = null;
-	private final Set<CommandSender> versionWaiters = new HashSet<CommandSender>();
-	private boolean versionTaskStarted = false;
-	private long lastCheck = 0;
-
-	private void sendVersion(CommandSender sender) {
-		if (hasVersion) {
-			if (System.currentTimeMillis() - lastCheck > 21600000) {
-				lastCheck = System.currentTimeMillis();
-				hasVersion = false;
-			} else {
-				sender.sendMessage(versionMessage);
-				return;
-			}
-		}
-		versionLock.lock();
-		// try {
-		if (hasVersion) {
-			sender.sendMessage(versionMessage);
-			return;
-		}
-		/*
-		 * versionWaiters.add(sender); sender.sendMessage(
-		 * "Checking version, please wait..."); if (!versionTaskStarted) {
-		 * versionTaskStarted = true; new Thread(new Runnable() {
-		 * 
-		 * @Override public void run() { obtainVersion(); } }).start(); }
-		 */
-		// } finally {
-		versionLock.unlock();
-		// }
-	}
-
-	// Paper start
-	private void obtainVersion() {
-		String version = Bukkit.getVersion();
-		if (version == null) {
-			version = "Custom";
-		}
-		// TacoSpigot start
-		if (version.startsWith("git-Torch-")) {
-			String[] parts = version.substring("git-Torch-".length()).split("[-\\s]");
-			// TacoSpigot end
-			int distance = getDistance(null, parts[0]);
-			switch (distance) {
-			case -1:
-				setVersionMessage("Error obtaining version information");
-				break;
-			case 0:
-				setVersionMessage("You are running the latest version");
-				break;
-			case -2:
-				setVersionMessage("Unknown version");
-				break;
-			default:
-				setVersionMessage("You are " + distance + " commit(s) behind"); // TacoSpigot
-																				// -
-																				// version
-																				// ->
-																				// commit
-			}
-		} else if (version.startsWith("git-Bukkit-")) {
-			// Paper end
-			version = version.substring("git-Bukkit-".length());
-			int cbVersions = getDistance("craftbukkit", version.substring(0, version.indexOf(' ')));
-			if (cbVersions == -1) {
-				setVersionMessage("Error obtaining version information");
-			} else {
-				if (cbVersions == 0) {
-					setVersionMessage("You are running the latest version");
-				} else {
-					setVersionMessage("You are " + cbVersions + " version(s) behind");
-				}
-			}
-		} else {
-			setVersionMessage("Unknown version, custom build?");
-		}
-	}
-
-	private void setVersionMessage(String msg) {
-		lastCheck = System.currentTimeMillis();
-		versionMessage = msg;
-		versionLock.lock();
-		try {
-			hasVersion = true;
-			versionTaskStarted = false;
-			for (CommandSender sender : versionWaiters) {
-				sender.sendMessage(versionMessage);
-			}
-			versionWaiters.clear();
-		} finally {
-			versionLock.unlock();
-		}
-	}
-
-	// Paper start
-	private static int getDistance(String repo, String verInfo) {
-		// TacoSpigot start - remove jenkins check
-		/*
-		 * try { int currentVer = Integer.decode(verInfo); return
-		 * getFromJenkins(currentVer); } catch (NumberFormatException ex) {
-		 */
-		verInfo = verInfo.replace("\"", "");
-		return getFromRepo("TorchSpigot/Torch", verInfo); // 'PaperMC/Paper' ->
-															// 'TacoSpigot/TacoSpigot'
-		// }
-		// TacoSpigot end
-		/*
-		 * BufferedReader reader = Resources.asCharSource( new URL(
-		 * "https://hub.spigotmc.org/stash/rest/api/1.0/projects/SPIGOT/repos/"
-		 * + repo + "/commits?since=" + URLEncoder.encode(hash, "UTF-8") +
-		 * "&withCounts=true"), Charsets.UTF_8 ).openBufferedStream(); try {
-		 * JSONObject obj = (JSONObject) new JSONParser().parse(reader); return
-		 * ((Number) obj.get("totalCount")).intValue(); } catch (ParseException
-		 * ex) { ex.printStackTrace(); return -1; } finally { reader.close(); }
-		 */
-	}
-
-	// TacoSpigot start - remove jenkins check
-	/*
-	 * private static int getFromJenkins(int currentVer) { try { BufferedReader
-	 * reader = Resources.asCharSource( new URL(
-	 * "https://ci.destroystokyo.com/job/PaperSpigot/lastSuccessfulBuild/buildNumber"
-	 * ), // Paper Charsets.UTF_8 ).openBufferedStream(); try { int newVer =
-	 * Integer.decode(reader.readLine()); return newVer - currentVer; } catch
-	 * (NumberFormatException ex) { ex.printStackTrace(); return -2; } finally {
-	 * reader.close(); } } catch (IOException e) { e.printStackTrace(); return
-	 * -1; } }
-	 */
-	// TacoSpigot end
-
-	// Contributed by Techcable <Techcable@outlook.com> in GH PR #65
-	private static final String BRANCH = "master";
-
-	private static int getFromRepo(String repo, String hash) {
-		try {
-			HttpURLConnection connection = (HttpURLConnection) new URL(
-					"https://api.github.com/repos/" + repo + "/compare/" + BRANCH + "..." + hash).openConnection();
-			connection.connect();
-			if (connection.getResponseCode() == HttpURLConnection.HTTP_NOT_FOUND) {
-				return -2; // Unknown commit
-			}
-			try (BufferedReader reader = new BufferedReader(
-					new InputStreamReader(connection.getInputStream(), Charsets.UTF_8))) {
-				JSONObject obj = (JSONObject) new JSONParser().parse(reader);
-				String status = (String) obj.get("status");
-				switch (status) {
-				case "identical":
-					return 0;
-				case "behind":
-					return ((Number) obj.get("behind_by")).intValue();
-				default:
-					return -2;
-				}
-			} catch (ParseException | NumberFormatException e) {
-				e.printStackTrace();
-				return -1;
-			}
-		} catch (IOException e) {
-			e.printStackTrace();
-			return -1;
-		}
-	}
-	// Paper end
+    public VersionCommand(String name) {
+        super(name);
+
+        this.description = "Gets the version of this server including any plugins in use";
+        this.usageMessage = "/version [plugin name]";
+        this.setPermission("bukkit.command.version");
+        this.setAliases(Arrays.asList("ver", "about"));
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
+        if (!testPermission(sender)) return true;
+
+        if (args.length == 0) {
+            sender.sendMessage("This server is running " + Bukkit.getName() + " version " + Bukkit.getVersion() + " (Implementing API version " + Bukkit.getBukkitVersion() + ")");
+            sendVersion(sender);
+        } else {
+            StringBuilder name = new StringBuilder();
+
+            for (String arg : args) {
+                if (name.length() > 0) {
+                    name.append(' ');
+                }
+
+                name.append(arg);
+            }
+
+            String pluginName = name.toString();
+            Plugin exactPlugin = Bukkit.getPluginManager().getPlugin(pluginName);
+            if (exactPlugin != null) {
+                describeToSender(exactPlugin, sender);
+                return true;
+            }
+
+            boolean found = false;
+            pluginName = pluginName.toLowerCase();
+            for (Plugin plugin : Bukkit.getPluginManager().getPlugins()) {
+                if (plugin.getName().toLowerCase().contains(pluginName)) {
+                    describeToSender(plugin, sender);
+                    found = true;
+                }
+            }
+
+            if (!found) {
+                sender.sendMessage("This server is not running any plugin by that name.");
+                sender.sendMessage("Use /plugins to get a list of plugins.");
+            }
+        }
+        return true;
+    }
+
+    private void describeToSender(Plugin plugin, CommandSender sender) {
+        PluginDescriptionFile desc = plugin.getDescription();
+        sender.sendMessage(ChatColor.GREEN + desc.getName() + ChatColor.WHITE + " version " + ChatColor.GREEN + desc.getVersion());
+
+        if (desc.getDescription() != null) {
+            sender.sendMessage(desc.getDescription());
+        }
+
+        if (desc.getWebsite() != null) {
+            sender.sendMessage("Website: " + ChatColor.GREEN + desc.getWebsite());
+        }
+
+        if (!desc.getAuthors().isEmpty()) {
+            if (desc.getAuthors().size() == 1) {
+                sender.sendMessage("Author: " + getAuthors(desc));
+            } else {
+                sender.sendMessage("Authors: " + getAuthors(desc));
+            }
+        }
+    }
+
+    private String getAuthors(final PluginDescriptionFile desc) {
+        StringBuilder result = new StringBuilder();
+        List<String> authors = desc.getAuthors();
+
+        for (int i = 0; i < authors.size(); i++) {
+            if (result.length() > 0) {
+                result.append(ChatColor.WHITE);
+
+                if (i < authors.size() - 1) {
+                    result.append(", ");
+                } else {
+                    result.append(" and ");
+                }
+            }
+
+            result.append(ChatColor.GREEN);
+            result.append(authors.get(i));
+        }
+
+        return result.toString();
+    }
+
+    @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args) {
+        Validate.notNull(sender, "Sender cannot be null");
+        Validate.notNull(args, "Arguments cannot be null");
+        Validate.notNull(alias, "Alias cannot be null");
+
+        if (args.length == 1) {
+            List<String> completions = new ArrayList<String>();
+            String toComplete = args[0].toLowerCase();
+            for (Plugin plugin : Bukkit.getPluginManager().getPlugins()) {
+                if (StringUtil.startsWithIgnoreCase(plugin.getName(), toComplete)) {
+                    completions.add(plugin.getName());
+                }
+            }
+            return completions;
+        }
+        return ImmutableList.of();
+    }
+
+    private final ReentrantLock versionLock = new ReentrantLock();
+    private boolean hasVersion = false;
+    private String versionMessage = null;
+    private final Set<CommandSender> versionWaiters = new HashSet<CommandSender>();
+    private boolean versionTaskStarted = false;
+    private long lastCheck = 0;
+
+    private void sendVersion(CommandSender sender) {
+        if (hasVersion) {
+            if (System.currentTimeMillis() - lastCheck > 21600000) {
+                lastCheck = System.currentTimeMillis();
+                hasVersion = false;
+            } else {
+                sender.sendMessage(versionMessage);
+                return;
+            }
+        }
+        versionLock.lock();
+        try {
+            if (hasVersion) {
+                sender.sendMessage(versionMessage);
+                return;
+            }
+            versionWaiters.add(sender);
+            sender.sendMessage("Checking version, please wait...");
+            if (!versionTaskStarted) {
+                versionTaskStarted = true;
+                new Thread(new Runnable() {
+
+                    @Override
+                    public void run() {
+                        obtainVersion();
+                    }
+                }).start();
+            }
+        } finally {
+            versionLock.unlock();
+        }
+    }
+
+    // Paper start
+    private void obtainVersion() {
+        String version = Bukkit.getVersion();
+        if (version == null) version = "Custom";
+        // TacoSpigot start
+        if (version.startsWith("git-Torch-")) {
+            String[] parts = version.substring("git-TorchSpigot-".length()).split("[-\\s]");
+            // TacoSpigot end
+            int distance = getDistance(null, parts[0]);
+            switch (distance) {
+                case -1:
+                    setVersionMessage("Error obtaining version information");
+                    break;
+                case 0:
+                    setVersionMessage("You are running the latest version");
+                    break;
+                case -2:
+                    setVersionMessage("Unknown version");
+                    break;
+                default:
+                    setVersionMessage("You are " + distance + " commit(s) behind"); // TacoSpigot - version -> commit
+            }
+        } else if (version.startsWith("git-Bukkit-")) {
+            // Paper end
+            version = version.substring("git-Bukkit-".length());
+            int cbVersions = getDistance("craftbukkit", version.substring(0, version.indexOf(' ')));
+            if (cbVersions == -1) {
+                setVersionMessage("Error obtaining version information");
+            } else {
+                if (cbVersions == 0) {
+                    setVersionMessage("You are running the latest version");
+                } else {
+                    setVersionMessage("You are " + cbVersions + " version(s) behind");
+                }
+            }
+        } else {
+            setVersionMessage("Unknown version, custom build?");
+        }
+    }
+
+    private void setVersionMessage(String msg) {
+        lastCheck = System.currentTimeMillis();
+        versionMessage = msg;
+        versionLock.lock();
+        try {
+            hasVersion = true;
+            versionTaskStarted = false;
+            for (CommandSender sender : versionWaiters) {
+                sender.sendMessage(versionMessage);
+            }
+            versionWaiters.clear();
+        } finally {
+            versionLock.unlock();
+        }
+    }
+
+    // Paper start
+    private static int getDistance(String repo, String verInfo) {
+        // TacoSpigot start - remove jenkins check
+        /*
+        try {
+            int currentVer = Integer.decode(verInfo);
+            return getFromJenkins(currentVer);
+        } catch (NumberFormatException ex) {
+            */
+            verInfo = verInfo.replace("\"", "");
+            return getFromRepo("TorchSpigot/Torch", verInfo); // 'PaperMC/Paper' -> 'TacoSpigot/TacoSpigot'
+        //}
+        // TacoSpigot end
+            /*
+            BufferedReader reader = Resources.asCharSource(
+                    new URL("https://hub.spigotmc.org/stash/rest/api/1.0/projects/SPIGOT/repos/" + repo + "/commits?since=" + URLEncoder.encode(hash, "UTF-8") + "&withCounts=true"),
+                    Charsets.UTF_8
+            ).openBufferedStream();
+            try {
+                JSONObject obj = (JSONObject) new JSONParser().parse(reader);
+                return ((Number) obj.get("totalCount")).intValue();
+            } catch (ParseException ex) {
+                ex.printStackTrace();
+                return -1;
+            } finally {
+                reader.close();
+            }
+            */
+    }
+
+    // TacoSpigot start - remove jenkins check
+    /*
+    private static int getFromJenkins(int currentVer) {
+        try {
+            BufferedReader reader = Resources.asCharSource(
+                    new URL("https://ci.destroystokyo.com/job/PaperSpigot/lastSuccessfulBuild/buildNumber"), // Paper
+                    Charsets.UTF_8
+            ).openBufferedStream();
+            try {
+                int newVer = Integer.decode(reader.readLine());
+                return newVer - currentVer;
+            } catch (NumberFormatException ex) {
+                ex.printStackTrace();
+                return -2;
+            } finally {
+                reader.close();
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+            return -1;
+        }
+    }
+    */
+    // TacoSpigot end
+
+    // Contributed by Techcable <Techcable@outlook.com> in GH PR #65
+    private static final String BRANCH = "master";
+    private static int getFromRepo(String repo, String hash) {
+        try {
+            HttpURLConnection connection = (HttpURLConnection) new URL("https://api.github.com/repos/" + repo + "/compare/" + BRANCH + "..." + hash).openConnection();
+            connection.connect();
+            if (connection.getResponseCode() == HttpURLConnection.HTTP_NOT_FOUND) return -2; // Unknown commit
+            try (
+                    BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), Charsets.UTF_8))
+            ) {
+                JSONObject obj = (JSONObject) new JSONParser().parse(reader);
+                String status = (String) obj.get("status");
+                switch (status) {
+                    case "identical":
+                        return 0;
+                    case "behind":
+                        return ((Number) obj.get("behind_by")).intValue();
+                    default:
+                        return -2;
+                }
+            } catch (ParseException | NumberFormatException e) {
+                e.printStackTrace();
+                return -1;
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+            return -1;
+        }
+    }
+    // Paper end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/util/LazyHashSet.java b/src/main/java/org/bukkit/craftbukkit/util/LazyHashSet.java
index e2a9643..8bb7c9f 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/LazyHashSet.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/LazyHashSet.java
@@ -1,10 +1,10 @@
-package org.bukkit.craftbukkit.util;
-
-import java.util.Collection;
-import java.util.Iterator;
-import java.util.Set;
-
-public abstract class LazyHashSet<E> implements Set<E> {
+package org.bukkit.craftbukkit.util;
+
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.Set;
+
+public abstract class LazyHashSet<E> implements Set<E> {
 	Set<E> reference = null;
 
 	@Override
@@ -107,4 +107,4 @@ public abstract class LazyHashSet<E> implements Set<E> {
 	public String toString() {
 		return getReference().toString();
 	}
-}
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/util/permissions/CommandPermissions.java b/src/main/java/org/bukkit/craftbukkit/util/permissions/CommandPermissions.java
index 1d1a790..7bda02e 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/permissions/CommandPermissions.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/permissions/CommandPermissions.java
@@ -1,20 +1,20 @@
-package org.bukkit.craftbukkit.util.permissions;
-
-import org.bukkit.permissions.Permission;
-import org.bukkit.permissions.PermissionDefault;
-import org.bukkit.util.permissions.DefaultPermissions;
-
-public final class CommandPermissions {
+package org.bukkit.craftbukkit.util.permissions;
+
+import org.bukkit.permissions.Permission;
+import org.bukkit.permissions.PermissionDefault;
+import org.bukkit.util.permissions.DefaultPermissions;
+
+public final class CommandPermissions {
 	private static final String ROOT = "minecraft.command";
 	private static final String PREFIX = ROOT + ".";
-
+
 	private CommandPermissions() {
 	}
-
+
 	public static Permission registerPermissions(Permission parent) {
 		Permission commands = DefaultPermissions.registerPermission(ROOT,
 				"Gives the user the ability to use all vanilla minecraft commands", parent);
-
+
 		DefaultPermissions.registerPermission(PREFIX + "kill", "Allows the user to commit suicide",
 				PermissionDefault.OP, commands);
 		DefaultPermissions.registerPermission(PREFIX + "me", "Allows the user to perform a chat action",
@@ -50,8 +50,8 @@ public final class CommandPermissions {
 				commands);
 		DefaultPermissions.registerPermission(PREFIX + "trigger", "Allows the use of the trigger command",
 				PermissionDefault.TRUE, commands);
-
+
 		commands.recalculatePermissibles();
 		return commands;
 	}
-}
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/util/permissions/CraftDefaultPermissions.java b/src/main/java/org/bukkit/craftbukkit/util/permissions/CraftDefaultPermissions.java
index f4645c2..fec145d 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/permissions/CraftDefaultPermissions.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/permissions/CraftDefaultPermissions.java
@@ -1,18 +1,18 @@
-package org.bukkit.craftbukkit.util.permissions;
-
-import org.bukkit.permissions.Permission;
-import org.bukkit.util.permissions.DefaultPermissions;
-
-public final class CraftDefaultPermissions {
+package org.bukkit.craftbukkit.util.permissions;
+
+import org.bukkit.permissions.Permission;
+import org.bukkit.util.permissions.DefaultPermissions;
+
+public final class CraftDefaultPermissions {
 	private static final String ROOT = "minecraft";
-
+
 	private CraftDefaultPermissions() {
 	}
-
+
 	public static void registerCorePermissions() {
 		Permission parent = DefaultPermissions.registerPermission(ROOT,
 				"Gives the user the ability to use all vanilla utilities and commands");
 		CommandPermissions.registerPermissions(parent);
 		parent.recalculatePermissibles();
 	}
-}
+}
diff --git a/src/main/java/org/spigotmc/SpigotWorldConfig.java b/src/main/java/org/spigotmc/SpigotWorldConfig.java
index 4de93ce..f8694b9 100644
--- a/src/main/java/org/spigotmc/SpigotWorldConfig.java
+++ b/src/main/java/org/spigotmc/SpigotWorldConfig.java
@@ -52,11 +52,11 @@ public class SpigotWorldConfig {
     };
     
     public static int getthreadnumber() {
-        return cpu_core*worldtickentitypool_core_multiple;
+        return cpu_core * worldtickentitypool_core_multiple;
     }
     
     private void wetp_core_multiple() {
-        worldtickentitypool_core_multiple = getInt("wetp-core-multiple", 2);
+        // worldtickentitypool_core_multiple = getInt("wetp-core-multiple", 2);
         
         TickPool = new ForkJoinPool(getthreadnumber(), ftp, null, false);
         ChunkPool = new ForkJoinPool(getthreadnumber(), fcp, null, false);
diff --git a/src/main/resources/configurations/migot.yml b/src/main/resources/configurations/migot.yml
index 6ed9e33..8969bd9 100644
--- a/src/main/resources/configurations/migot.yml
+++ b/src/main/resources/configurations/migot.yml
@@ -4,6 +4,7 @@
 # ( GH: https://github.com/Poweruser/Migot )
 
 settings:
+  wetp-core-multiple: 2
   auto-save: false
   fork-ping: false
   bungee-redirect-compatible: false
-- 
2.8.2.windows.1

