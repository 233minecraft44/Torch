From cc431953fff29a3b9d0c80f53f38c96e024ff870 Mon Sep 17 00:00:00 2001
From: SotrForgotten <i@omc.hk>
Date: Mon, 11 Jul 2016 20:04:20 +0800
Subject: [PATCH] Use-lang3-keeps-lang2-for-compatibility


diff --git a/pom.xml b/pom.xml
index 30f915f..ae3c932 100644
--- a/pom.xml
+++ b/pom.xml
@@ -35,6 +35,11 @@
             <scope>compile</scope>
         </dependency>
         <dependency>
+		 <groupId>org.apache.commons</groupId>
+            <artifactId>commons-lang3</artifactId>
+            <version>3.4</version>
+        </dependency>
+        <dependency>
             <groupId>org.spigotmc</groupId>
             <artifactId>minecraft-server</artifactId>
             <version>${minecraft.version}-SNAPSHOT</version>
diff --git a/src/main/java/co/aikar/timings/FullServerTickHandler.java b/src/main/java/co/aikar/timings/FullServerTickHandler.java
new file mode 100644
index 0000000..007ab9c
--- /dev/null
+++ b/src/main/java/co/aikar/timings/FullServerTickHandler.java
@@ -0,0 +1,79 @@
+package co.aikar.timings;
+
+import static co.aikar.timings.TimingsManager.*;
+
+public class FullServerTickHandler extends TimingHandler {
+    static final TimingIdentifier IDENTITY = new TimingIdentifier("Minecraft", "Full Server Tick", null, false);
+    final TimingData minuteData;
+    double avgFreeMemory = -1D;
+    double avgUsedMemory = -1D;
+    FullServerTickHandler() {
+        super(IDENTITY);
+        minuteData = new TimingData(id);
+
+        TIMING_MAP.put(IDENTITY, this);
+    }
+
+    @Override
+    public Timing startTiming() {
+        if (TimingsManager.needsFullReset) {
+            TimingsManager.resetTimings();
+        } else if (TimingsManager.needsRecheckEnabled) {
+            TimingsManager.recheckEnabled();
+        }
+        return super.startTiming();
+    }
+
+    @Override
+    public void stopTiming() {
+        super.stopTiming();
+        if (!enabled) {
+            return;
+        }
+        if (TimingHistory.timedTicks % 20 == 0) {
+            final Runtime runtime = Runtime.getRuntime();
+            double usedMemory = runtime.totalMemory() - runtime.freeMemory();
+            double freeMemory = runtime.maxMemory() - usedMemory;
+            if (this.avgFreeMemory == -1) {
+                this.avgFreeMemory = freeMemory;
+            } else {
+                this.avgFreeMemory = (this.avgFreeMemory * (59 / 60D)) + (freeMemory * (1 / 60D));
+            }
+
+            if (this.avgUsedMemory == -1) {
+                this.avgUsedMemory = usedMemory;
+            } else {
+                this.avgUsedMemory = (this.avgUsedMemory * (59 / 60D)) + (usedMemory * (1 / 60D));
+            }
+        }
+
+        long start = System.nanoTime();
+        TimingsManager.tick();
+        long diff = System.nanoTime() - start;
+        CURRENT = TIMINGS_TICK;
+        TIMINGS_TICK.addDiff(diff);
+        // addDiff for TIMINGS_TICK incremented this, bring it back down to 1 per tick.
+        record.curTickCount--;
+        minuteData.curTickTotal = record.curTickTotal;
+        minuteData.curTickCount = 1;
+        boolean violated = isViolated();
+        minuteData.processTick(violated);
+        TIMINGS_TICK.processTick(violated);
+        processTick(violated);
+
+
+        if (TimingHistory.timedTicks % 1200 == 0) {
+            MINUTE_REPORTS.add(new TimingHistory.MinuteReport());
+            TimingHistory.resetTicks(false);
+            minuteData.reset();
+        }
+        if (TimingHistory.timedTicks % Timings.getHistoryInterval() == 0) {
+            TimingsManager.HISTORY.add(new TimingHistory());
+            TimingsManager.resetTimings();
+        }
+    }
+
+    boolean isViolated() {
+        return record.curTickTotal > 50000000;
+    }
+}
diff --git a/src/main/java/co/aikar/timings/NullTimingHandler.java b/src/main/java/co/aikar/timings/NullTimingHandler.java
new file mode 100644
index 0000000..8c43e20
--- /dev/null
+++ b/src/main/java/co/aikar/timings/NullTimingHandler.java
@@ -0,0 +1,61 @@
+/*
+ * This file is licensed under the MIT License (MIT).
+ *
+ * Copyright (c) 2014 Daniel Ennis <http://aikar.co>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package co.aikar.timings;
+
+public final class NullTimingHandler implements Timing {
+    @Override
+    public Timing startTiming() {
+        return this;
+    }
+
+    @Override
+    public void stopTiming() {
+
+    }
+
+    @Override
+    public Timing startTimingIfSync() {
+        return this;
+    }
+
+    @Override
+    public void stopTimingIfSync() {
+
+    }
+
+    @Override
+    public void abort() {
+
+    }
+
+    @Override
+    public TimingHandler getTimingHandler() {
+        return null;
+    }
+
+    @Override
+    public void close() {
+
+    }
+}
diff --git a/src/main/java/co/aikar/timings/TimedEventExecutor.java b/src/main/java/co/aikar/timings/TimedEventExecutor.java
new file mode 100644
index 0000000..96057fc
--- /dev/null
+++ b/src/main/java/co/aikar/timings/TimedEventExecutor.java
@@ -0,0 +1,81 @@
+/*
+ * This file is licensed under the MIT License (MIT).
+ *
+ * Copyright (c) 2014 Daniel Ennis <http://aikar.co>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package co.aikar.timings;
+
+import org.bukkit.Bukkit;
+import org.bukkit.event.Event;
+import org.bukkit.event.EventException;
+import org.bukkit.event.Listener;
+import org.bukkit.plugin.EventExecutor;
+import org.bukkit.plugin.Plugin;
+
+import java.lang.reflect.Method;
+
+public class TimedEventExecutor implements EventExecutor {
+
+    private final EventExecutor executor;
+    private final Timing timings;
+
+    /**
+     * Wraps an event executor and associates a timing handler to it.
+     *
+     * @param executor
+     * @param plugin
+     * @param method
+     * @param eventClass
+     */
+    public TimedEventExecutor(EventExecutor executor, Plugin plugin, Method method, Class<? extends Event> eventClass) {
+        this.executor = executor;
+        String id;
+
+        if (method == null) {
+            if (executor.getClass().getEnclosingClass() != null) { // Oh Skript, how we love you
+                method = executor.getClass().getEnclosingMethod();
+            }
+        }
+
+        if (method != null) {
+            id = method.getDeclaringClass().getName();
+        } else {
+            id = executor.getClass().getName();
+        }
+
+
+        final String eventName = eventClass.getSimpleName();
+        boolean verbose = "BlockPhysicsEvent".equals(eventName);
+        this.timings = Timings.ofSafe(plugin.getName(), (verbose ? "## " : "") +
+            "Event: " + id + " (" + eventName + ")", null);
+    }
+
+    @Override
+    public void execute(Listener listener, Event event) throws EventException {
+        if (event.isAsynchronous() || !Timings.timingsEnabled || !Bukkit.isPrimaryThread()) {
+            executor.execute(listener, event);
+            return;
+        }
+        timings.startTiming();
+        executor.execute(listener, event);
+        timings.stopTiming();
+    }
+}
diff --git a/src/main/java/co/aikar/timings/Timing.java b/src/main/java/co/aikar/timings/Timing.java
new file mode 100644
index 0000000..8b2d1b8
--- /dev/null
+++ b/src/main/java/co/aikar/timings/Timing.java
@@ -0,0 +1,72 @@
+/*
+ * This file is licensed under the MIT License (MIT).
+ *
+ * Copyright (c) 2014 Daniel Ennis <http://aikar.co>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package co.aikar.timings;
+
+/**
+ * Provides an ability to time sections of code within the Minecraft Server
+ */
+public interface Timing extends AutoCloseable {
+    /**
+     * Starts timing the execution until {@link #stopTiming()} is called.
+     */
+    Timing startTiming();
+
+    /**
+     * <p>Stops timing and records the data. Propagates the data up to group handlers.</p>
+     *
+     * Will automatically be called when this Timing is used with try-with-resources
+     */
+    void stopTiming();
+
+    /**
+     * Starts timing the execution until {@link #stopTiming()} is called.
+     *
+     * But only if we are on the primary thread.
+     */
+    Timing startTimingIfSync();
+
+    /**
+     * <p>Stops timing and records the data. Propagates the data up to group handlers.</p>
+     *
+     * <p>Will automatically be called when this Timing is used with try-with-resources</p>
+     *
+     * But only if we are on the primary thread.
+     */
+    void stopTimingIfSync();
+
+    /**
+     * Stops timing and disregards current timing data.
+     */
+    void abort();
+
+    /**
+     * Used internally to get the actual backing Handler in the case of delegated Handlers
+     *
+     * @return TimingHandler
+     */
+    TimingHandler getTimingHandler();
+
+    @Override
+    void close();
+}
diff --git a/src/main/java/co/aikar/timings/TimingData.java b/src/main/java/co/aikar/timings/TimingData.java
new file mode 100644
index 0000000..b62e428
--- /dev/null
+++ b/src/main/java/co/aikar/timings/TimingData.java
@@ -0,0 +1,105 @@
+/*
+ * This file is licensed under the MIT License (MIT).
+ *
+ * Copyright (c) 2014 Daniel Ennis <http://aikar.co>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package co.aikar.timings;
+
+import com.google.common.base.Function;
+
+import java.util.List;
+
+import static co.aikar.util.JSONUtil.toArray;
+
+/**
+ * <p>Lightweight object for tracking timing data</p>
+ *
+ * This is broken out to reduce memory usage
+ */
+class TimingData {
+    static Function<Integer, TimingData> LOADER = new Function<Integer, TimingData>() {
+        @Override
+        public TimingData apply(Integer input) {
+            return new TimingData(input);
+        }
+    };
+    int id;
+    int count = 0;
+    int lagCount = 0;
+    long totalTime = 0;
+    long lagTotalTime = 0;
+
+    int curTickCount = 0;
+    int curTickTotal = 0;
+
+    TimingData(int id) {
+        this.id = id;
+    }
+
+    TimingData(TimingData data) {
+        this.id = data.id;
+        this.totalTime = data.totalTime;
+        this.lagTotalTime = data.lagTotalTime;
+        this.count = data.count;
+        this.lagCount = data.lagCount;
+    }
+
+    void add(long diff) {
+        ++curTickCount;
+        curTickTotal += diff;
+    }
+
+    void processTick(boolean violated) {
+        totalTime += curTickTotal;
+        count += curTickCount;
+        if (violated) {
+            lagTotalTime += curTickTotal;
+            lagCount += curTickCount;
+        }
+        curTickTotal = 0;
+        curTickCount = 0;
+    }
+
+    void reset() {
+        count = 0;
+        lagCount = 0;
+        curTickTotal = 0;
+        curTickCount = 0;
+        totalTime = 0;
+        lagTotalTime = 0;
+    }
+
+    protected TimingData clone() {
+        return new TimingData(this);
+    }
+
+    public List export() {
+        List list = toArray(
+            id,
+            count,
+            totalTime);
+        if (lagCount > 0) {
+            list.add(lagCount);
+            list.add(lagTotalTime);
+        }
+        return list;
+    }
+}
diff --git a/src/main/java/co/aikar/timings/TimingHandler.java b/src/main/java/co/aikar/timings/TimingHandler.java
new file mode 100644
index 0000000..0914417
--- /dev/null
+++ b/src/main/java/co/aikar/timings/TimingHandler.java
@@ -0,0 +1,192 @@
+/*
+ * This file is licensed under the MIT License (MIT).
+ *
+ * Copyright (c) 2014 Daniel Ennis <http://aikar.co>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package co.aikar.timings;
+
+import co.aikar.util.LoadingIntMap;
+import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
+import org.bukkit.Bukkit;
+
+import java.util.logging.Level;
+
+class TimingHandler implements Timing {
+
+    private static int idPool = 1;
+    final int id = idPool++;
+
+    final String name;
+    final boolean verbose;
+
+    final Int2ObjectOpenHashMap<TimingData> children = new LoadingIntMap<>(TimingData.LOADER);
+
+    final TimingData record;
+    final TimingHandler groupHandler;
+
+    long start = 0;
+    int timingDepth = 0;
+    boolean added;
+    boolean timed;
+    boolean enabled;
+    TimingHandler parent;
+
+    TimingHandler(TimingIdentifier id) {
+        if (id.name.startsWith("##")) {
+            verbose = true;
+            this.name = id.name.substring(3);
+        } else {
+            this.name = id.name;
+            verbose = false;
+        }
+
+        this.record = new TimingData(this.id);
+        this.groupHandler = id.groupHandler;
+
+        TimingIdentifier.getGroup(id.group).handlers.add(this);
+        checkEnabled();
+    }
+
+    final void checkEnabled() {
+        enabled = Timings.timingsEnabled && (!verbose || Timings.verboseEnabled);
+    }
+
+    void processTick(boolean violated) {
+        if (timingDepth != 0 || record.curTickCount == 0) {
+            timingDepth = 0;
+            start = 0;
+            return;
+        }
+
+        record.processTick(violated);
+        for (TimingData handler : children.values()) {
+            handler.processTick(violated);
+        }
+    }
+
+    @Override
+    public Timing startTimingIfSync() {
+        if (Bukkit.isPrimaryThread()) {
+            startTiming();
+        }
+        return this;
+    }
+
+    @Override
+    public void stopTimingIfSync() {
+        if (Bukkit.isPrimaryThread()) {
+            stopTiming();
+        }
+    }
+
+    public Timing startTiming() {
+        if (enabled && ++timingDepth == 1) {
+            start = System.nanoTime();
+            parent = TimingsManager.CURRENT;
+            TimingsManager.CURRENT = this;
+        }
+        return this;
+    }
+
+    public void stopTiming() {
+        if (enabled && --timingDepth == 0 && start != 0) {
+            if (!Bukkit.isPrimaryThread()) {
+                Bukkit.getLogger().log(Level.SEVERE, "stopTiming called async for " + name);
+                new Throwable().printStackTrace();
+                start = 0;
+                return;
+            }
+            addDiff(System.nanoTime() - start);
+            start = 0;
+        }
+    }
+
+    @Override
+    public void abort() {
+        if (enabled && timingDepth > 0) {
+            start = 0;
+        }
+    }
+
+    void addDiff(long diff) {
+        if (TimingsManager.CURRENT == this) {
+            TimingsManager.CURRENT = parent;
+            if (parent != null) {
+                parent.children.get(id).add(diff);
+            }
+        }
+        record.add(diff);
+        if (!added) {
+            added = true;
+            timed = true;
+            TimingsManager.HANDLERS.add(this);
+        }
+        if (groupHandler != null) {
+            groupHandler.addDiff(diff);
+            groupHandler.children.get(id).add(diff);
+        }
+    }
+
+    /**
+     * Reset this timer, setting all values to zero.
+     *
+     * @param full
+     */
+    void reset(boolean full) {
+        record.reset();
+        if (full) {
+            timed = false;
+        }
+        start = 0;
+        timingDepth = 0;
+        added = false;
+        children.clear();
+        checkEnabled();
+    }
+
+    @Override
+    public TimingHandler getTimingHandler() {
+        return this;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        return (this == o);
+    }
+
+    @Override
+    public int hashCode() {
+        return id;
+    }
+
+    /**
+     * This is simply for the Closeable interface so it can be used with
+     * try-with-resources ()
+     */
+    @Override
+    public void close() {
+        stopTimingIfSync();
+    }
+
+    public boolean isSpecial() {
+        return this == TimingsManager.FULL_SERVER_TICK || this == TimingsManager.TIMINGS_TICK;
+    }
+}
diff --git a/src/main/java/co/aikar/timings/TimingHistory.java b/src/main/java/co/aikar/timings/TimingHistory.java
new file mode 100644
index 0000000..9206569
--- /dev/null
+++ b/src/main/java/co/aikar/timings/TimingHistory.java
@@ -0,0 +1,338 @@
+/*
+ * This file is licensed under the MIT License (MIT).
+ *
+ * Copyright (c) 2014 Daniel Ennis <http://aikar.co>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package co.aikar.timings;
+
+import co.aikar.timings.TimingHistory.RegionData.RegionId;
+import co.aikar.util.JSONUtil;
+import com.google.common.base.Function;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
+import org.bukkit.Bukkit;
+import org.bukkit.Chunk;
+import org.bukkit.Material;
+import org.bukkit.World;
+import org.bukkit.block.BlockState;
+import org.bukkit.entity.Entity;
+import org.bukkit.entity.EntityType;
+import org.bukkit.entity.Player;
+import co.aikar.util.LoadingMap;
+import co.aikar.util.MRUMapCache;
+
+import java.lang.management.ManagementFactory;
+import java.util.Collection;
+import java.util.EnumMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import static co.aikar.timings.TimingsManager.FULL_SERVER_TICK;
+import static co.aikar.timings.TimingsManager.MINUTE_REPORTS;
+import static co.aikar.util.JSONUtil.*;
+
+@SuppressWarnings({"deprecation", "SuppressionAnnotation", "Convert2Lambda", "Anonymous2MethodRef"})
+public class TimingHistory {
+    public static long lastMinuteTime;
+    public static long timedTicks;
+    public static long playerTicks;
+    public static long entityTicks;
+    public static long tileEntityTicks;
+    public static long activatedEntityTicks;
+    private static int worldIdPool = 1;
+    static Map<String, Integer> worldMap = LoadingMap.newHashMap(new Function<String, Integer>() {
+        @Override
+        public Integer apply(String input) {
+            return worldIdPool++;
+        }
+    });
+    private final long endTime;
+    private final long startTime;
+    private final long totalTicks;
+    private final long totalTime; // Represents all time spent running the server this history
+    private final MinuteReport[] minuteReports;
+
+    private final TimingHistoryEntry[] entries;
+    final Set<Material> tileEntityTypeSet = Sets.newHashSet();
+    final Set<EntityType> entityTypeSet = Sets.newHashSet();
+    private final Map<Object, Object> worlds;
+
+    TimingHistory() {
+        this.endTime = System.currentTimeMillis() / 1000;
+        this.startTime = TimingsManager.historyStart / 1000;
+        if (timedTicks % 1200 != 0 || MINUTE_REPORTS.isEmpty()) {
+            this.minuteReports = MINUTE_REPORTS.toArray(new MinuteReport[MINUTE_REPORTS.size() + 1]);
+            this.minuteReports[this.minuteReports.length - 1] = new MinuteReport();
+        } else {
+            this.minuteReports = MINUTE_REPORTS.toArray(new MinuteReport[MINUTE_REPORTS.size()]);
+        }
+        long ticks = 0;
+        for (MinuteReport mp : this.minuteReports) {
+            ticks += mp.ticksRecord.timed;
+        }
+        this.totalTicks = ticks;
+        this.totalTime = FULL_SERVER_TICK.record.totalTime;
+        this.entries = new TimingHistoryEntry[TimingsManager.HANDLERS.size()];
+
+        int i = 0;
+        for (TimingHandler handler : TimingsManager.HANDLERS) {
+            entries[i++] = new TimingHistoryEntry(handler);
+        }
+
+
+        // Information about all loaded chunks/entities
+        //noinspection unchecked
+        this.worlds = toObjectMapper(Bukkit.getWorlds(), new Function<World, JSONPair>() {
+            @Override
+            public JSONPair apply(World world) {
+                Map<RegionId, RegionData> regions = LoadingMap.newHashMap(RegionData.LOADER);
+
+                for (Chunk chunk : world.getLoadedChunks()) {
+                    RegionData data = regions.get(new RegionId(chunk.getX(), chunk.getZ()));
+
+                    for (Entity entity : chunk.getEntities()) {
+                        data.entityCounts.get(entity.getType()).increment();
+                    }
+
+                    for (BlockState tileEntity : chunk.getTileEntities()) {
+                        data.tileEntityCounts.get(tileEntity.getBlock().getType()).increment();
+                    }
+                }
+                return pair(
+                    worldMap.get(world.getName()),
+                    toArrayMapper(regions.values(),new Function<RegionData, Object>() {
+                        @Override
+                        public Object apply(RegionData input) {
+                            return toArray(
+                                input.regionId.x,
+                                input.regionId.z,
+                                toObjectMapper(input.entityCounts.entrySet(),
+                                    new Function<Map.Entry<EntityType, Counter>, JSONPair>() {
+                                        @Override
+                                        public JSONPair apply(Map.Entry<EntityType, Counter> entry) {
+                                            entityTypeSet.add(entry.getKey());
+                                            return pair(
+                                                    String.valueOf(entry.getKey().getTypeId()),
+                                                    entry.getValue().count()
+                                            );
+                                        }
+                                    }
+                                ),
+                                toObjectMapper(input.tileEntityCounts.entrySet(),
+                                    new Function<Map.Entry<Material, Counter>, JSONPair>() {
+                                        @Override
+                                        public JSONPair apply(Map.Entry<Material, Counter> entry) {
+                                            tileEntityTypeSet.add(entry.getKey());
+                                            return pair(
+                                                    String.valueOf(entry.getKey().getId()),
+                                                    entry.getValue().count()
+                                            );
+                                        }
+                                    }
+                                )
+                            );
+                        }
+                    })
+                );
+            }
+        });
+    }
+    static class RegionData {
+        private final RegionId regionId;
+        @SuppressWarnings("Guava")
+        static Function<RegionId, RegionData> LOADER = new Function<RegionId, RegionData>() {
+            @Override
+            public RegionData apply(RegionId id) {
+                return new RegionData(id);
+            }
+        };
+        RegionData(RegionId id) {
+            this.regionId = id;
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (o == null || getClass() != o.getClass()) return false;
+
+            RegionData that = (RegionData) o;
+
+            return regionId.equals(that.regionId);
+
+        }
+
+        @Override
+        public int hashCode() {
+            return regionId.hashCode();
+        }
+
+        @SuppressWarnings("unchecked")
+        final Map<EntityType, Counter> entityCounts = MRUMapCache.of(LoadingMap.of(
+                new EnumMap<EntityType, Counter>(EntityType.class), Counter.LOADER
+        ));
+        @SuppressWarnings("unchecked")
+        final Map<Material, Counter> tileEntityCounts = MRUMapCache.of(LoadingMap.of(
+                new EnumMap<Material, Counter>(Material.class), Counter.LOADER
+        ));
+
+        static class RegionId {
+            final int x, z;
+            final long regionId;
+            RegionId(int x, int z) {
+                this.x = x >> 5 << 5;
+                this.z = z >> 5 << 5;
+                this.regionId = ((long) (this.x) << 32) + (this.z >> 5 << 5) - Integer.MIN_VALUE;
+            }
+
+            @Override
+            public boolean equals(Object o) {
+                if (this == o) return true;
+                if (o == null || getClass() != o.getClass()) return false;
+
+                RegionId regionId1 = (RegionId) o;
+
+                return regionId == regionId1.regionId;
+
+            }
+
+            @Override
+            public int hashCode() {
+                return (int) (regionId ^ (regionId >>> 32));
+            }
+        }
+    }
+    static void resetTicks(boolean fullReset) {
+        if (fullReset) {
+            // Non full is simply for 1 minute reports
+            timedTicks = 0;
+        }
+        lastMinuteTime = System.nanoTime();
+        playerTicks = 0;
+        tileEntityTicks = 0;
+        entityTicks = 0;
+        activatedEntityTicks = 0;
+    }
+
+    Object export() {
+        return createObject(
+            pair("s", startTime),
+            pair("e", endTime),
+            pair("tk", totalTicks),
+            pair("tm", totalTime),
+            pair("w", worlds),
+            pair("h", toArrayMapper(entries, new Function<TimingHistoryEntry, Object>() {
+                @Override
+                public Object apply(TimingHistoryEntry entry) {
+                    TimingData record = entry.data;
+                    if (record.count == 0) {
+                        return null;
+                    }
+                    return entry.export();
+                }
+            })),
+            pair("mp", toArrayMapper(minuteReports, new Function<MinuteReport, Object>() {
+                @Override
+                public Object apply(MinuteReport input) {
+                    return input.export();
+                }
+            }))
+        );
+    }
+
+    static class MinuteReport {
+        final long time = System.currentTimeMillis() / 1000;
+
+        final TicksRecord ticksRecord = new TicksRecord();
+        final PingRecord pingRecord = new PingRecord();
+        final TimingData fst = TimingsManager.FULL_SERVER_TICK.minuteData.clone();
+        final double tps = 1E9 / ( System.nanoTime() - lastMinuteTime ) * ticksRecord.timed;
+        final double usedMemory = TimingsManager.FULL_SERVER_TICK.avgUsedMemory;
+        final double freeMemory = TimingsManager.FULL_SERVER_TICK.avgFreeMemory;
+        final double loadAvg = ManagementFactory.getOperatingSystemMXBean().getSystemLoadAverage();
+
+        public List export() {
+            return toArray(
+                time,
+                Math.round(tps * 100D) / 100D,
+                Math.round(pingRecord.avg * 100D) / 100D,
+                fst.export(),
+                toArray(ticksRecord.timed,
+                    ticksRecord.player,
+                    ticksRecord.entity,
+                    ticksRecord.activatedEntity,
+                    ticksRecord.tileEntity
+                ),
+                usedMemory,
+                freeMemory,
+                loadAvg
+            );
+        }
+    }
+
+    private static class TicksRecord {
+        final long timed;
+        final long player;
+        final long entity;
+        final long tileEntity;
+        final long activatedEntity;
+
+        TicksRecord() {
+            timed = timedTicks - (TimingsManager.MINUTE_REPORTS.size() * 1200);
+            player = playerTicks;
+            entity = entityTicks;
+            tileEntity = tileEntityTicks;
+            activatedEntity = activatedEntityTicks;
+        }
+
+    }
+
+    private static class PingRecord {
+        final double avg;
+
+        PingRecord() {
+            final Collection<? extends Player> onlinePlayers = Bukkit.getOnlinePlayers();
+            int totalPing = 0;
+            for (Player player : onlinePlayers) {
+                totalPing += player.spigot().getPing();
+            }
+            avg = onlinePlayers.isEmpty() ? 0 : totalPing / onlinePlayers.size();
+        }
+    }
+
+    @SuppressWarnings("WeakerAccess")
+    public static class Counter {
+        int count = 0;
+        @SuppressWarnings({"rawtypes", "SuppressionAnnotation", "Guava"})
+        static Function LOADER = new LoadingMap.Feeder<Counter>() {
+            @Override
+            public Counter apply() {
+                return new Counter();
+            }
+        };
+        public int increment() {
+            return ++count;
+        }
+        public int count() {
+            return count;
+        }
+    }
+}
diff --git a/src/main/java/co/aikar/timings/TimingHistoryEntry.java b/src/main/java/co/aikar/timings/TimingHistoryEntry.java
new file mode 100644
index 0000000..a5c5dfd
--- /dev/null
+++ b/src/main/java/co/aikar/timings/TimingHistoryEntry.java
@@ -0,0 +1,59 @@
+/*
+ * This file is licensed under the MIT License (MIT).
+ *
+ * Copyright (c) 2014 Daniel Ennis <http://aikar.co>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package co.aikar.timings;
+
+import com.google.common.base.Function;
+
+import java.util.List;
+
+import static co.aikar.util.JSONUtil.toArrayMapper;
+
+class TimingHistoryEntry {
+    final TimingData data;
+    final TimingData[] children;
+
+    TimingHistoryEntry(TimingHandler handler) {
+        this.data = handler.record.clone();
+        children = new TimingData[handler.children.size()];
+        int i = 0;
+        for (TimingData child : handler.children.values()) {
+            children[i++] = child.clone();
+        }
+    }
+
+    List export() {
+        List result = data.export();
+        if (children.length > 0) {
+            result.add(
+                toArrayMapper(children, new Function<TimingData, Object>() {
+                    @Override
+                    public Object apply(TimingData child) {
+                        return child.export();
+                    }
+                })
+            );
+        }
+        return result;
+    }
+}
diff --git a/src/main/java/co/aikar/timings/TimingIdentifier.java b/src/main/java/co/aikar/timings/TimingIdentifier.java
new file mode 100644
index 0000000..623dda4
--- /dev/null
+++ b/src/main/java/co/aikar/timings/TimingIdentifier.java
@@ -0,0 +1,102 @@
+/*
+ * This file is licensed under the MIT License (MIT).
+ *
+ * Copyright (c) 2014 Daniel Ennis <http://aikar.co>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package co.aikar.timings;
+
+import com.google.common.base.Function;
+import co.aikar.util.LoadingMap;
+import co.aikar.util.MRUMapCache;
+
+import java.util.ArrayDeque;
+import java.util.Map;
+
+/**
+ * <p>Used as a basis for fast HashMap key comparisons for the Timing Map.</p>
+ *
+ * This class uses interned strings giving us the ability to do an identity check instead of equals() on the strings
+ */
+final class TimingIdentifier {
+    /**
+     * Holds all groups. Autoloads on request for a group by name.
+     */
+    static final Map<String, TimingGroup> GROUP_MAP = MRUMapCache.of(
+        LoadingMap.newIdentityHashMap(new Function<String, TimingGroup>() {
+            @Override
+            public TimingGroup apply(String group) {
+                return new TimingGroup(group);
+            }
+        }, 64)
+    );
+    static final TimingGroup DEFAULT_GROUP = getGroup("Minecraft");
+    final String group;
+    final String name;
+    final TimingHandler groupHandler;
+    final boolean protect;
+    private final int hashCode;
+
+    TimingIdentifier(String group, String name, Timing groupHandler, boolean protect) {
+        this.group = group != null ? group.intern() : DEFAULT_GROUP.name;
+        this.name = name.intern();
+        this.groupHandler = groupHandler != null ? groupHandler.getTimingHandler() : null;
+        this.protect = protect;
+        this.hashCode = (31 * this.group.hashCode()) + this.name.hashCode();
+    }
+
+    static TimingGroup getGroup(String groupName) {
+        if (groupName == null) {
+            return DEFAULT_GROUP;
+        }
+
+        return GROUP_MAP.get(groupName.intern());
+    }
+
+    // We are using .intern() on the strings so it is guaranteed to be an identity comparison.
+    @SuppressWarnings("StringEquality")
+    @Override
+    public boolean equals(Object o) {
+        if (o == null) {
+            return false;
+        }
+
+        TimingIdentifier that = (TimingIdentifier) o;
+        return group == that.group && name == that.name;
+    }
+
+    @Override
+    public int hashCode() {
+        return hashCode;
+    }
+
+    static class TimingGroup {
+
+        private static int idPool = 1;
+        final int id = idPool++;
+
+        final String name;
+        ArrayDeque<TimingHandler> handlers = new ArrayDeque<TimingHandler>(64);
+
+        private TimingGroup(String name) {
+            this.name = name;
+        }
+    }
+}
diff --git a/src/main/java/co/aikar/timings/Timings.java b/src/main/java/co/aikar/timings/Timings.java
new file mode 100644
index 0000000..0f7be03
--- /dev/null
+++ b/src/main/java/co/aikar/timings/Timings.java
@@ -0,0 +1,273 @@
+/*
+ * This file is licensed under the MIT License (MIT).
+ *
+ * Copyright (c) 2014 Daniel Ennis <http://aikar.co>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package co.aikar.timings;
+
+import com.google.common.base.Preconditions;
+import com.google.common.collect.EvictingQueue;
+import org.bukkit.Bukkit;
+import org.bukkit.command.CommandSender;
+import org.bukkit.plugin.Plugin;
+
+import java.util.Queue;
+import java.util.logging.Level;
+
+@SuppressWarnings("UnusedDeclaration")
+public final class Timings {
+
+    private static final int MAX_HISTORY_FRAMES = 12;
+    public static final Timing NULL_HANDLER = new NullTimingHandler();
+    static boolean timingsEnabled = false;
+    static boolean verboseEnabled = false;
+    private static int historyInterval = -1;
+    private static int historyLength = -1;
+
+    private Timings() {}
+
+    /**
+     * Returns a Timing for a plugin corresponding to a name.
+     *
+     * @param plugin Plugin to own the Timing
+     * @param name   Name of Timing
+     * @return Handler
+     */
+    public static Timing of(Plugin plugin, String name) {
+        Timing pluginHandler = null;
+        if (plugin != null) {
+            pluginHandler = ofSafe(plugin.getName(), "Combined Total", TimingsManager.PLUGIN_GROUP_HANDLER);
+        }
+        return of(plugin, name, pluginHandler);
+    }
+
+    /**
+     * <p>Returns a handler that has a groupHandler timer handler. Parent timers should not have their
+     * start/stop methods called directly, as the children will call it for you.</p>
+     *
+     * Parent Timers are used to group multiple subsections together and get a summary of them combined
+     * Parent Handler can not be changed after first call
+     *
+     * @param plugin       Plugin to own the Timing
+     * @param name         Name of Timing
+     * @param groupHandler Parent handler to mirror .start/stop calls to
+     * @return Timing Handler
+     */
+    public static Timing of(Plugin plugin, String name, Timing groupHandler) {
+        Preconditions.checkNotNull(plugin, "Plugin can not be null");
+        return TimingsManager.getHandler(plugin.getName(), name, groupHandler, true);
+    }
+
+    /**
+     * Returns a Timing object after starting it, useful for Java7 try-with-resources.
+     *
+     * try (Timing ignored = Timings.ofStart(plugin, someName)) {
+     * // timed section
+     * }
+     *
+     * @param plugin Plugin to own the Timing
+     * @param name   Name of Timing
+     * @return Timing Handler
+     */
+    public static Timing ofStart(Plugin plugin, String name) {
+        return ofStart(plugin, name, null);
+    }
+
+    /**
+     * Returns a Timing object after starting it, useful for Java7 try-with-resources.
+     *
+     * try (Timing ignored = Timings.ofStart(plugin, someName, groupHandler)) {
+     * // timed section
+     * }
+     *
+     * @param plugin       Plugin to own the Timing
+     * @param name         Name of Timing
+     * @param groupHandler Parent handler to mirror .start/stop calls to
+     * @return Timing Handler
+     */
+    public static Timing ofStart(Plugin plugin, String name, Timing groupHandler) {
+        Timing timing = of(plugin, name, groupHandler);
+        timing.startTimingIfSync();
+        return timing;
+    }
+
+    /**
+     * Gets whether or not the Spigot Timings system is enabled
+     *
+     * @return Enabled or not
+     */
+    public static boolean isTimingsEnabled() {
+        return timingsEnabled;
+    }
+
+    /**
+     * <p>Sets whether or not the Spigot Timings system should be enabled</p>
+     *
+     * Calling this will reset timing data.
+     *
+     * @param enabled Should timings be reported
+     */
+    public static void setTimingsEnabled(boolean enabled) {
+        timingsEnabled = enabled;
+        reset();
+    }
+
+    /**
+     * <p>Sets whether or not the Timings should monitor at Verbose level.</p>
+     *
+     * <p>When Verbose is disabled, high-frequency timings will not be available.</p>
+     *
+     * @return Enabled or not
+     */
+    public static boolean isVerboseTimingsEnabled() {
+        return timingsEnabled;
+    }
+
+    /**
+     * Sets whether or not the Timings should monitor at Verbose level.
+     * <p/>
+     * When Verbose is disabled, high-frequency timings will not be available.
+     * Calling this will reset timing data.
+     *
+     * @param enabled Should high-frequency timings be reported
+     */
+    public static void setVerboseTimingsEnabled(boolean enabled) {
+        verboseEnabled = enabled;
+        TimingsManager.needsRecheckEnabled = true;
+    }
+
+    /**
+     * <p>Gets the interval between Timing History report generation.</p>
+     *
+     * Defaults to 5 minutes (6000 ticks)
+     *
+     * @return Interval in ticks
+     */
+    public static int getHistoryInterval() {
+        return historyInterval;
+    }
+
+    /**
+     * <p>Sets the interval between Timing History report generations.</p>
+     *
+     * <p>Defaults to 5 minutes (6000 ticks)</p>
+     *
+     * This will recheck your history length, so lowering this value will lower your
+     * history length if you need more than 60 history windows.
+     *
+     * @param interval Interval in ticks
+     */
+    public static void setHistoryInterval(int interval) {
+        historyInterval = Math.max(20*60, interval);
+        // Recheck the history length with the new Interval
+        if (historyLength != -1) {
+            setHistoryLength(historyLength);
+        }
+    }
+
+    /**
+     * Gets how long in ticks Timings history is kept for the server.
+     *
+     * Defaults to 1 hour (72000 ticks)
+     *
+     * @return Duration in Ticks
+     */
+    public static int getHistoryLength() {
+        return historyLength;
+    }
+
+    /**
+     * Sets how long Timing History reports are kept for the server.
+     *
+     * Defaults to 1 hours(72000 ticks)
+     *
+     * This value is capped at a maximum of getHistoryInterval() * MAX_HISTORY_FRAMES (12)
+     *
+     * Will not reset Timing Data but may truncate old history if the new length is less than old length.
+     *
+     * @param length Duration in ticks
+     */
+    public static void setHistoryLength(int length) {
+        // Cap at 12 History Frames, 1 hour at 5 minute frames.
+        int maxLength = historyInterval * MAX_HISTORY_FRAMES;
+        // For special cases of servers with special permission to bypass the max.
+        // This max helps keep data file sizes reasonable for processing on Aikar's Timing parser side.
+        // Setting this will not help you bypass the max unless Aikar has added an exception on the API side.
+        if (System.getProperty("timings.bypassMax") != null) {
+            maxLength = Integer.MAX_VALUE;
+        }
+        historyLength = Math.max(Math.min(maxLength, length), historyInterval);
+        Queue<TimingHistory> oldQueue = TimingsManager.HISTORY;
+        int frames = (getHistoryLength() / getHistoryInterval());
+        if (length > maxLength) {
+            Bukkit.getLogger().log(Level.WARNING, "Timings Length too high. Requested " + length + ", max is " + maxLength + ". To get longer history, you must increase your interval. Set Interval to " + Math.ceil(length / MAX_HISTORY_FRAMES) + " to achieve this length.");
+        }
+        TimingsManager.HISTORY = EvictingQueue.create(frames);
+        TimingsManager.HISTORY.addAll(oldQueue);
+    }
+
+    /**
+     * Resets all Timing Data
+     */
+    public static void reset() {
+        TimingsManager.reset();
+    }
+
+    /**
+     * Generates a report and sends it to the specified command sender.
+     *
+     * If sender is null, ConsoleCommandSender will be used.
+     * @param sender The sender to send to, or null to use the ConsoleCommandSender
+     */
+    public static void generateReport(CommandSender sender) {
+        if (sender == null) {
+            sender = Bukkit.getConsoleSender();
+        }
+        TimingsExport.reportTimings(sender);
+    }
+
+    /*
+    =================
+    Protected API: These are for internal use only in Bukkit/CraftBukkit
+    These do not have isPrimaryThread() checks in the startTiming/stopTiming
+    =================
+    */
+
+    static TimingHandler ofSafe(String name) {
+        return ofSafe(null, name, null);
+    }
+
+    static Timing ofSafe(Plugin plugin, String name) {
+        Timing pluginHandler = null;
+        if (plugin != null) {
+            pluginHandler = ofSafe(plugin.getName(), "Combined Total", TimingsManager.PLUGIN_GROUP_HANDLER);
+        }
+        return ofSafe(plugin != null ? plugin.getName() : "Minecraft - Invalid Plugin", name, pluginHandler);
+    }
+
+    static TimingHandler ofSafe(String name, Timing groupHandler) {
+        return ofSafe(null, name, groupHandler);
+    }
+
+    static TimingHandler ofSafe(String groupName, String name, Timing groupHandler) {
+        return TimingsManager.getHandler(groupName, name, groupHandler, false);
+    }
+}
diff --git a/src/main/java/co/aikar/timings/TimingsCommand.java b/src/main/java/co/aikar/timings/TimingsCommand.java
new file mode 100644
index 0000000..10d866f
--- /dev/null
+++ b/src/main/java/co/aikar/timings/TimingsCommand.java
@@ -0,0 +1,110 @@
+/*
+ * This file is licensed under the MIT License (MIT).
+ *
+ * Copyright (c) 2014 Daniel Ennis <http://aikar.co>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package co.aikar.timings;
+
+import com.google.common.collect.ImmutableList;
+import org.apache.commons.lang3.Validate;
+import org.bukkit.ChatColor;
+import org.bukkit.command.CommandSender;
+import org.bukkit.command.defaults.BukkitCommand;
+import org.bukkit.util.StringUtil;
+
+import java.util.ArrayList;
+import java.util.List;
+
+
+public class TimingsCommand extends BukkitCommand {
+    public static final List<String> TIMINGS_SUBCOMMANDS = ImmutableList.of("report", "reset", "on", "off", "paste", "verbon", "verboff");
+
+    public TimingsCommand(String name) {
+        super(name);
+        this.description = "Manages Spigot Timings data to see performance of the server.";
+        this.usageMessage = "/timings <reset|report|on|off|verbon|verboff>";
+        this.setPermission("bukkit.command.timings");
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
+        if (!testPermission(sender)) {
+            return true;
+        }
+        if (args.length < 1) {
+            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
+            return true;
+        }
+        final String arg = args[0];
+        if ("on".equalsIgnoreCase(arg)) {
+            Timings.setTimingsEnabled(true);
+            sender.sendMessage("Enabled Timings & Reset");
+            return true;
+        } else if ("off".equalsIgnoreCase(arg)) {
+            Timings.setTimingsEnabled(false);
+            sender.sendMessage("Disabled Timings");
+            return true;
+        }
+
+        if (!Timings.isTimingsEnabled()) {
+            sender.sendMessage("Please enable timings by typing /timings on");
+            return true;
+        }
+        if ("verbon".equalsIgnoreCase(arg)) {
+            Timings.setVerboseTimingsEnabled(true);
+            sender.sendMessage("Enabled Verbose Timings");
+            return true;
+        } else if ("verboff".equalsIgnoreCase(arg)) {
+            Timings.setVerboseTimingsEnabled(false);
+            sender.sendMessage("Disabled Verbose Timings");
+            return true;
+        } else if ("reset".equalsIgnoreCase(arg)) {
+            TimingsManager.reset();
+            sender.sendMessage("Timings reset");
+        } else if ("cost".equals(arg)) {
+            sender.sendMessage("Timings cost: " + TimingsExport.getCost());
+        } else  if (
+            "paste".equalsIgnoreCase(arg) ||
+                "report".equalsIgnoreCase(arg) ||
+                "get".equalsIgnoreCase(arg) ||
+                "merged".equalsIgnoreCase(arg) ||
+                "separate".equalsIgnoreCase(arg)
+            ) {
+            TimingsExport.reportTimings(sender);
+        } else {
+            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
+        }
+        return true;
+    }
+
+    @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args) {
+        Validate.notNull(sender, "Sender cannot be null");
+        Validate.notNull(args, "Arguments cannot be null");
+        Validate.notNull(alias, "Alias cannot be null");
+
+        if (args.length == 1) {
+            return StringUtil.copyPartialMatches(args[0], TIMINGS_SUBCOMMANDS,
+                new ArrayList<String>(TIMINGS_SUBCOMMANDS.size()));
+        }
+        return ImmutableList.of();
+    }
+}
diff --git a/src/main/java/co/aikar/timings/TimingsExport.java b/src/main/java/co/aikar/timings/TimingsExport.java
new file mode 100644
index 0000000..6eb5f96
--- /dev/null
+++ b/src/main/java/co/aikar/timings/TimingsExport.java
@@ -0,0 +1,373 @@
+/*
+ * This file is licensed under the MIT License (MIT).
+ *
+ * Copyright (c) 2014 Daniel Ennis <http://aikar.co>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package co.aikar.timings;
+
+import com.google.common.base.Function;
+import com.google.common.collect.Sets;
+import org.apache.commons.lang3.StringUtils;
+import org.bukkit.Bukkit;
+import org.bukkit.ChatColor;
+import org.bukkit.Material;
+import org.bukkit.command.CommandSender;
+import org.bukkit.command.ConsoleCommandSender;
+import org.bukkit.command.RemoteConsoleCommandSender;
+import org.bukkit.configuration.ConfigurationSection;
+import org.bukkit.configuration.MemorySection;
+import org.bukkit.entity.EntityType;
+import org.bukkit.plugin.Plugin;
+import org.json.simple.JSONObject;
+import org.json.simple.JSONValue;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.lang.management.GarbageCollectorMXBean;
+import java.lang.management.ManagementFactory;
+import java.lang.management.OperatingSystemMXBean;
+import java.lang.management.RuntimeMXBean;
+import java.net.HttpURLConnection;
+import java.net.InetAddress;
+import java.net.URL;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.logging.Level;
+import java.util.zip.GZIPOutputStream;
+
+import static co.aikar.timings.TimingsManager.HISTORY;
+import static co.aikar.util.JSONUtil.*;
+
+@SuppressWarnings({"rawtypes", "SuppressionAnnotation"})
+class TimingsExport extends Thread {
+
+    private final CommandSender sender;
+    private final Map out;
+    private final TimingHistory[] history;
+
+    TimingsExport(CommandSender sender, Map out, TimingHistory[] history) {
+        super("Timings paste thread");
+        this.sender = sender;
+        this.out = out;
+        this.history = history;
+    }
+
+
+    /**
+     * Builds an XML report of the timings to be uploaded for parsing.
+     *
+     * @param sender Who to report to
+     */
+    static void reportTimings(CommandSender sender) {
+        Map parent = createObject(
+            // Get some basic system details about the server
+            pair("version", Bukkit.getVersion()),
+            pair("maxplayers", Bukkit.getMaxPlayers()),
+            pair("start", TimingsManager.timingStart / 1000),
+            pair("end", System.currentTimeMillis() / 1000),
+            pair("sampletime", (System.currentTimeMillis() - TimingsManager.timingStart) / 1000)
+        );
+        if (!TimingsManager.privacy) {
+            appendObjectData(parent,
+                pair("server", Bukkit.getServerName()),
+                pair("motd", Bukkit.getServer().getMotd()),
+                pair("online-mode", Bukkit.getServer().getOnlineMode()),
+                pair("icon", Bukkit.getServer().getServerIcon().getData())
+            );
+        }
+
+        final Runtime runtime = Runtime.getRuntime();
+        RuntimeMXBean runtimeBean = ManagementFactory.getRuntimeMXBean();
+
+        parent.put("system", createObject(
+                pair("timingcost", getCost()),
+                pair("name", System.getProperty("os.name")),
+                pair("version", System.getProperty("os.version")),
+                pair("jvmversion", System.getProperty("java.version")),
+                pair("arch", System.getProperty("os.arch")),
+                pair("maxmem", runtime.maxMemory()),
+                pair("cpu", runtime.availableProcessors()),
+                pair("runtime", ManagementFactory.getRuntimeMXBean().getUptime()),
+                pair("flags", StringUtils.join(runtimeBean.getInputArguments(), " ")),
+                pair("gc", toObjectMapper(ManagementFactory.getGarbageCollectorMXBeans(), new Function<GarbageCollectorMXBean, JSONPair>() {
+                    @Override
+                    public JSONPair apply(GarbageCollectorMXBean input) {
+                        return pair(input.getName(), toArray(input.getCollectionCount(), input.getCollectionTime()));
+                    }
+                }))
+            )
+        );
+
+        Set<Material> tileEntityTypeSet = Sets.newHashSet();
+        Set<EntityType> entityTypeSet = Sets.newHashSet();
+
+        int size = HISTORY.size();
+        TimingHistory[] history = new TimingHistory[size + 1];
+        int i = 0;
+        for (TimingHistory timingHistory : HISTORY) {
+            tileEntityTypeSet.addAll(timingHistory.tileEntityTypeSet);
+            entityTypeSet.addAll(timingHistory.entityTypeSet);
+            history[i++] = timingHistory;
+        }
+
+        history[i] = new TimingHistory(); // Current snapshot
+        tileEntityTypeSet.addAll(history[i].tileEntityTypeSet);
+        entityTypeSet.addAll(history[i].entityTypeSet);
+
+
+        Map handlers = createObject();
+        for (TimingIdentifier.TimingGroup group : TimingIdentifier.GROUP_MAP.values()) {
+            for (TimingHandler id : group.handlers) {
+                if (!id.timed && !id.isSpecial()) {
+                    continue;
+                }
+                handlers.put(id.id, toArray(
+                    group.id,
+                    id.name
+                ));
+            }
+        }
+
+        parent.put("idmap", createObject(
+            pair("groups", toObjectMapper(
+                TimingIdentifier.GROUP_MAP.values(), new Function<TimingIdentifier.TimingGroup, JSONPair>() {
+                @Override
+                public JSONPair apply(TimingIdentifier.TimingGroup group) {
+                    return pair(group.id, group.name);
+                }
+            })),
+            pair("handlers", handlers),
+            pair("worlds", toObjectMapper(TimingHistory.worldMap.entrySet(), new Function<Map.Entry<String, Integer>, JSONPair>() {
+                    @Override
+                    public JSONPair apply(Map.Entry<String, Integer> input) {
+                        return pair(input.getValue(), input.getKey());
+                    }
+                })),
+            pair("tileentity",
+                toObjectMapper(tileEntityTypeSet, new Function<Material, JSONPair>() {
+                    @Override
+                    public JSONPair apply(Material input) {
+                        return pair(input.getId(), input.name());
+                    }
+                })),
+            pair("entity",
+                toObjectMapper(entityTypeSet, new Function<EntityType, JSONPair>() {
+                    @Override
+                    public JSONPair apply(EntityType input) {
+                        return pair(input.getTypeId(), input.name());
+                    }
+                }))
+        ));
+
+        // Information about loaded plugins
+
+        parent.put("plugins", toObjectMapper(Bukkit.getPluginManager().getPlugins(),
+            new Function<Plugin, JSONPair>() {
+                @Override
+                public JSONPair apply(Plugin plugin) {
+                    return pair(plugin.getName(), createObject(
+                        pair("version", plugin.getDescription().getVersion()),
+                        pair("description", String.valueOf(plugin.getDescription().getDescription()).trim()),
+                        pair("website", plugin.getDescription().getWebsite()),
+                        pair("authors", StringUtils.join(plugin.getDescription().getAuthors(), ", "))
+                    ));
+                }
+            }));
+
+
+
+        // Information on the users Config
+
+        parent.put("config", createObject(
+            pair("spigot", mapAsJSON(Bukkit.spigot().getSpigotConfig(), null)),
+            pair("bukkit", mapAsJSON(Bukkit.spigot().getBukkitConfig(), null)),
+            pair("paper", mapAsJSON(Bukkit.spigot().getPaperConfig(), null))
+        ));
+
+        new TimingsExport(sender, parent, history).start();
+    }
+
+    static long getCost() {
+        // Benchmark the users System.nanotime() for cost basis
+        int passes = 100;
+        TimingHandler SAMPLER1 = Timings.ofSafe("Timings Sampler 1");
+        TimingHandler SAMPLER2 = Timings.ofSafe("Timings Sampler 2");
+        TimingHandler SAMPLER3 = Timings.ofSafe("Timings Sampler 3");
+        TimingHandler SAMPLER4 = Timings.ofSafe("Timings Sampler 4");
+        TimingHandler SAMPLER5 = Timings.ofSafe("Timings Sampler 5");
+        TimingHandler SAMPLER6 = Timings.ofSafe("Timings Sampler 6");
+
+        long start = System.nanoTime();
+        for (int i = 0; i < passes; i++) {
+            SAMPLER1.startTiming();
+            SAMPLER2.startTiming();
+            SAMPLER3.startTiming();
+            SAMPLER3.stopTiming();
+            SAMPLER4.startTiming();
+            SAMPLER5.startTiming();
+            SAMPLER6.startTiming();
+            SAMPLER6.stopTiming();
+            SAMPLER5.stopTiming();
+            SAMPLER4.stopTiming();
+            SAMPLER2.stopTiming();
+            SAMPLER1.stopTiming();
+        }
+        long timingsCost = (System.nanoTime() - start) / passes / 6;
+        SAMPLER1.reset(true);
+        SAMPLER2.reset(true);
+        SAMPLER3.reset(true);
+        SAMPLER4.reset(true);
+        SAMPLER5.reset(true);
+        SAMPLER6.reset(true);
+        return timingsCost;
+    }
+
+    private static JSONObject mapAsJSON(ConfigurationSection config, String parentKey) {
+
+        JSONObject object = new JSONObject();
+        for (String key : config.getKeys(false)) {
+            String fullKey = (parentKey != null ? parentKey + "." + key : key);
+            if (fullKey.equals("database") || fullKey.equals("settings.bungeecord-addresses") || TimingsManager.hiddenConfigs.contains(fullKey)) {
+                continue;
+            }
+            final Object val = config.get(key);
+
+            object.put(key, valAsJSON(val, fullKey));
+        }
+        return object;
+    }
+
+    private static Object valAsJSON(Object val, final String parentKey) {
+        if (!(val instanceof MemorySection)) {
+            if (val instanceof List) {
+                Iterable<Object> v = (Iterable<Object>) val;
+                return toArrayMapper(v, new Function<Object, Object>() {
+                    @Override
+                    public Object apply(Object input) {
+                        return valAsJSON(input, parentKey);
+                    }
+                });
+            } else {
+                return val.toString();
+            }
+        } else {
+            return mapAsJSON((ConfigurationSection) val, parentKey);
+        }
+    }
+
+    @SuppressWarnings("CallToThreadRun")
+    @Override
+    public synchronized void start() {
+        if (sender instanceof RemoteConsoleCommandSender) {
+            sender.sendMessage(ChatColor.RED + "Warning: Timings report done over RCON will cause lag spikes.");
+            sender.sendMessage(ChatColor.RED + "You should use " + ChatColor.YELLOW +
+                "/timings report" + ChatColor.RED + " in game or console.");
+            run();
+        } else {
+            super.start();
+        }
+    }
+
+    @Override
+    public void run() {
+        sender.sendMessage(ChatColor.GREEN + "Preparing Timings Report...");
+
+
+        out.put("data", toArrayMapper(history, new Function<TimingHistory, Object>() {
+            @Override
+            public Object apply(TimingHistory input) {
+                return input.export();
+            }
+        }));
+
+
+        String response = null;
+        try {
+            HttpURLConnection con = (HttpURLConnection) new URL("http://timings.aikar.co/post").openConnection();
+            con.setDoOutput(true);
+            con.setRequestProperty("User-Agent", "Spigot/" + Bukkit.getServerName() + "/" + InetAddress.getLocalHost().getHostName());
+            con.setRequestMethod("POST");
+            con.setInstanceFollowRedirects(false);
+
+            OutputStream request = new GZIPOutputStream(con.getOutputStream()) {{
+                this.def.setLevel(7);
+            }};
+
+            request.write(JSONValue.toJSONString(out).getBytes("UTF-8"));
+            request.close();
+
+            response = getResponse(con);
+
+            if (con.getResponseCode() != 302) {
+                sender.sendMessage(
+                    ChatColor.RED + "Upload Error: " + con.getResponseCode() + ": " + con.getResponseMessage());
+                sender.sendMessage(ChatColor.RED + "Check your logs for more information");
+                if (response != null) {
+                    Bukkit.getLogger().log(Level.SEVERE, response);
+                }
+                return;
+            }
+
+            String location = con.getHeaderField("Location");
+            sender.sendMessage(ChatColor.GREEN + "View Timings Report: " + location);
+            if (!(sender instanceof ConsoleCommandSender)) {
+                Bukkit.getLogger().log(Level.INFO, "View Timings Report: " + location);
+            }
+
+            if (response != null && !response.isEmpty()) {
+                Bukkit.getLogger().log(Level.INFO, "Timing Response: " + response);
+            }
+        } catch (IOException ex) {
+            sender.sendMessage(ChatColor.RED + "Error uploading timings, check your logs for more information");
+            if (response != null) {
+                Bukkit.getLogger().log(Level.SEVERE, response);
+            }
+            Bukkit.getLogger().log(Level.SEVERE, "Could not paste timings", ex);
+        }
+    }
+
+    private String getResponse(HttpURLConnection con) throws IOException {
+        InputStream is = null;
+        try {
+            is = con.getInputStream();
+            ByteArrayOutputStream bos = new ByteArrayOutputStream();
+
+            byte[] b = new byte[1024];
+            int bytesRead;
+            while ((bytesRead = is.read(b)) != -1) {
+                bos.write(b, 0, bytesRead);
+            }
+            return bos.toString();
+
+        } catch (IOException ex) {
+            sender.sendMessage(ChatColor.RED + "Error uploading timings, check your logs for more information");
+            Bukkit.getLogger().log(Level.WARNING, con.getResponseMessage(), ex);
+            return null;
+        } finally {
+            if (is != null) {
+                is.close();
+            }
+        }
+    }
+}
diff --git a/src/main/java/co/aikar/timings/TimingsManager.java b/src/main/java/co/aikar/timings/TimingsManager.java
new file mode 100644
index 0000000..58ed35e
--- /dev/null
+++ b/src/main/java/co/aikar/timings/TimingsManager.java
@@ -0,0 +1,196 @@
+/*
+ * This file is licensed under the MIT License (MIT).
+ *
+ * Copyright (c) 2014 Daniel Ennis <http://aikar.co>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package co.aikar.timings;
+
+import com.google.common.base.Function;
+import com.google.common.collect.EvictingQueue;
+import org.bukkit.Bukkit;
+import org.bukkit.Server;
+import org.bukkit.command.Command;
+import org.bukkit.plugin.Plugin;
+import org.bukkit.plugin.java.PluginClassLoader;
+import co.aikar.util.LoadingMap;
+
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import java.util.logging.Level;
+
+public final class TimingsManager {
+    static final Map<TimingIdentifier, TimingHandler> TIMING_MAP =
+        Collections.synchronizedMap(LoadingMap.newHashMap(
+            new Function<TimingIdentifier, TimingHandler>() {
+                @Override
+                public TimingHandler apply(TimingIdentifier id) {
+                    return (id.protect ?
+                        new UnsafeTimingHandler(id) :
+                        new TimingHandler(id)
+                    );
+                }
+            },
+            256, .5F
+        ));
+    public static final FullServerTickHandler FULL_SERVER_TICK = new FullServerTickHandler();
+    public static final TimingHandler TIMINGS_TICK = Timings.ofSafe("Timings Tick", FULL_SERVER_TICK);
+    public static final Timing PLUGIN_GROUP_HANDLER = Timings.ofSafe("Plugins");
+    public static List<String> hiddenConfigs = new ArrayList<String>();
+    public static boolean privacy = false;
+
+    static final Collection<TimingHandler> HANDLERS = new ArrayDeque<TimingHandler>();
+    static final ArrayDeque<TimingHistory.MinuteReport> MINUTE_REPORTS = new ArrayDeque<TimingHistory.MinuteReport>();
+
+    static EvictingQueue<TimingHistory> HISTORY = EvictingQueue.create(12);
+    static TimingHandler CURRENT;
+    static long timingStart = 0;
+    static long historyStart = 0;
+    static boolean needsFullReset = false;
+    static boolean needsRecheckEnabled = false;
+
+    private TimingsManager() {}
+
+    /**
+     * Resets all timing data on the next tick
+     */
+    static void reset() {
+        needsFullReset = true;
+    }
+
+    /**
+     * Ticked every tick by CraftBukkit to count the number of times a timer
+     * caused TPS loss.
+     */
+    static void tick() {
+        if (Timings.timingsEnabled) {
+            boolean violated = FULL_SERVER_TICK.isViolated();
+
+            for (TimingHandler handler : HANDLERS) {
+                if (handler.isSpecial()) {
+                    // We manually call this
+                    continue;
+                }
+                handler.processTick(violated);
+            }
+
+            TimingHistory.playerTicks += Bukkit.getOnlinePlayers().size();
+            TimingHistory.timedTicks++;
+            // Generate TPS/Ping/Tick reports every minute
+        }
+    }
+    static void stopServer() {
+        Timings.timingsEnabled = false;
+        recheckEnabled();
+    }
+    static void recheckEnabled() {
+        synchronized (TIMING_MAP) {
+            for (TimingHandler timings : TIMING_MAP.values()) {
+                timings.checkEnabled();
+            }
+        }
+        needsRecheckEnabled = false;
+    }
+    static void resetTimings() {
+        if (needsFullReset) {
+            // Full resets need to re-check every handlers enabled state
+            // Timing map can be modified from async so we must sync on it.
+            synchronized (TIMING_MAP) {
+                for (TimingHandler timings : TIMING_MAP.values()) {
+                    timings.reset(true);
+                }
+            }
+            Bukkit.getLogger().log(Level.INFO, "Timings Reset");
+            HISTORY.clear();
+            needsFullReset = false;
+            needsRecheckEnabled = false;
+            timingStart = System.currentTimeMillis();
+        } else {
+            // Soft resets only need to act on timings that have done something
+            // Handlers can only be modified on main thread.
+            for (TimingHandler timings : HANDLERS) {
+                timings.reset(false);
+            }
+        }
+
+        HANDLERS.clear();
+        MINUTE_REPORTS.clear();
+
+        TimingHistory.resetTicks(true);
+        historyStart = System.currentTimeMillis();
+    }
+
+    static TimingHandler getHandler(String group, String name, Timing parent, boolean protect) {
+        return TIMING_MAP.get(new TimingIdentifier(group, name, parent, protect));
+    }
+
+
+    /**
+     * <p>Due to access restrictions, we need a helper method to get a Command TimingHandler with String group</p>
+     *
+     * Plugins should never call this
+     *
+     * @param pluginName Plugin this command is associated with
+     * @param command    Command to get timings for
+     * @return TimingHandler
+     */
+    public static Timing getCommandTiming(String pluginName, Command command) {
+        Plugin plugin = null;
+        final Server server = Bukkit.getServer();
+        if (!(  server == null || pluginName == null ||
+                "minecraft".equals(pluginName) || "bukkit".equals(pluginName) ||
+                "spigot".equalsIgnoreCase(pluginName) || "paper".equals(pluginName)
+        )) {
+            plugin = server.getPluginManager().getPlugin(pluginName);
+        }
+        if (plugin == null) {
+            // Plugin is passing custom fallback prefix, try to look up by class loader
+            plugin = getPluginByClassloader(command.getClass());
+        }
+        if (plugin == null) {
+            return Timings.ofSafe("Command: " + pluginName + ":" + command.getTimingName());
+        }
+
+        return Timings.ofSafe(plugin, "Command: " + pluginName + ":" + command.getTimingName());
+    }
+
+    /**
+     * Looks up the class loader for the specified class, and if it is a PluginClassLoader, return the
+     * Plugin that created this class.
+     *
+     * @param clazz Class to check
+     * @return Plugin if created by a plugin
+     */
+    public static Plugin getPluginByClassloader(Class<?> clazz) {
+        if (clazz == null) {
+            return null;
+        }
+        final ClassLoader classLoader = clazz.getClassLoader();
+        if (classLoader instanceof PluginClassLoader) {
+            PluginClassLoader pluginClassLoader = (PluginClassLoader) classLoader;
+            return pluginClassLoader.getPlugin();
+        }
+        return null;
+    }
+}
diff --git a/src/main/java/co/aikar/timings/UnsafeTimingHandler.java b/src/main/java/co/aikar/timings/UnsafeTimingHandler.java
new file mode 100644
index 0000000..5edaba1
--- /dev/null
+++ b/src/main/java/co/aikar/timings/UnsafeTimingHandler.java
@@ -0,0 +1,51 @@
+/*
+ * This file is licensed under the MIT License (MIT).
+ *
+ * Copyright (c) 2014 Daniel Ennis <http://aikar.co>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package co.aikar.timings;
+
+import org.bukkit.Bukkit;
+
+class UnsafeTimingHandler extends TimingHandler {
+
+    UnsafeTimingHandler(TimingIdentifier id) {
+        super(id);
+    }
+
+    private static void checkThread() {
+        if (!Bukkit.isPrimaryThread()) {
+            throw new IllegalStateException("Calling Timings from Async Operation");
+        }
+    }
+
+    @Override
+    public Timing startTiming() {
+        checkThread();
+        return super.startTiming();
+    }
+
+    @Override
+    public void stopTiming() {
+        checkThread();
+        super.stopTiming();
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/event/player/PlayerHandshakeEvent.java b/src/main/java/com/destroystokyo/paper/event/player/PlayerHandshakeEvent.java
new file mode 100644
index 0000000..dcd0747
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/event/player/PlayerHandshakeEvent.java
@@ -0,0 +1,211 @@
+package com.destroystokyo.paper.event.player;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.event.Cancellable;
+import org.bukkit.event.Event;
+import org.bukkit.event.HandlerList;
+
+import java.util.UUID;
+
+/**
+ * This event is fired during a player handshake.
+ *
+ * <p>If there are no listeners listening to this event, the logic default
+ * to your server platform will be ran.</p>
+ *
+ * <p>WARNING: TAMPERING WITH THIS EVENT CAN BE DANGEROUS</p>
+ */
+public class PlayerHandshakeEvent extends Event implements Cancellable {
+
+    private static final HandlerList HANDLERS = new HandlerList();
+    private final String originalHandshake;
+    private boolean cancelled;
+    private String serverHostname;
+    private String socketAddressHostname;
+    private UUID uniqueId;
+    private String propertiesJson;
+    private boolean failed;
+    private String failMessage = "If you wish to use IP forwarding, please enable it in your BungeeCord config as well!";
+
+    /**
+     * Creates a new {@link PlayerHandshakeEvent}.
+     *
+     * @param originalHandshake the original handshake string
+     * @param cancelled if this event is enabled
+     */
+    public PlayerHandshakeEvent(String originalHandshake, boolean cancelled) {
+        this.originalHandshake = originalHandshake;
+        this.cancelled = cancelled;
+    }
+
+    /**
+     * Determines if this event is cancelled.
+     *
+     * <p>When this event is cancelled, custom handshake logic will not
+     * be processed.</p>
+     *
+     * @return {@code true} if this event is cancelled, {@code false} otherwise
+     */
+    @Override
+    public boolean isCancelled() {
+        return this.cancelled;
+    }
+
+    /**
+     * Sets if this event is cancelled.
+     *
+     * <p>When this event is cancelled, custom handshake logic will not
+     * be processed.</p>
+     *
+     * @param cancelled {@code true} if this event is cancelled, {@code false} otherwise
+     */
+    @Override
+    public void setCancelled(boolean cancelled) {
+        this.cancelled = cancelled;
+    }
+
+    /**
+     * Gets the original handshake string.
+     *
+     * @return the original handshake string
+     */
+    public String getOriginalHandshake() {
+        return this.originalHandshake;
+    }
+
+    /**
+     * Gets the server hostname string.
+     *
+     * <p>This should not include the port.</p>
+     *
+     * @return the server hostname string
+     */
+    public String getServerHostname() {
+        return this.serverHostname;
+    }
+
+    /**
+     * Sets the server hostname string.
+     *
+     * <p>This should not include the port.</p>
+     *
+     * @param serverHostname the server hostname string
+     */
+    public void setServerHostname(String serverHostname) {
+        this.serverHostname = serverHostname;
+    }
+
+    /**
+     * Gets the socket address hostname string.
+     *
+     * <p>This should not include the port.</p>
+     *
+     * @return the socket address hostname string
+     */
+    public String getSocketAddressHostname() {
+        return this.socketAddressHostname;
+    }
+
+    /**
+     * Sets the socket address hostname string.
+     *
+     * <p>This should not include the port.</p>
+     *
+     * @param socketAddressHostname the socket address hostname string
+     */
+    public void setSocketAddressHostname(String socketAddressHostname) {
+        this.socketAddressHostname = socketAddressHostname;
+    }
+
+    /**
+     * Gets the unique id.
+     *
+     * @return the unique id
+     */
+    public UUID getUniqueId() {
+        return this.uniqueId;
+    }
+
+    /**
+     * Sets the unique id.
+     *
+     * @param uniqueId the unique id
+     */
+    public void setUniqueId(UUID uniqueId) {
+        this.uniqueId = uniqueId;
+    }
+
+    /**
+     * Gets the profile properties.
+     *
+     * <p>This should be a valid JSON string.</p>
+     *
+     * @return the profile properties, as JSON
+     */
+    public String getPropertiesJson() {
+        return this.propertiesJson;
+    }
+
+    /**
+     * Determines if authentication failed.
+     *
+     * <p>When {@code true}, the client connecting will be disconnected
+     * with the {@link #getFailMessage() fail message}.</p>
+     *
+     * @return {@code true} if authentication failed, {@code false} otherwise
+     */
+    public boolean isFailed() {
+        return this.failed;
+    }
+
+    /**
+     * Sets if authentication failed and the client should be disconnected.
+     *
+     * <p>When {@code true}, the client connecting will be disconnected
+     * with the {@link #getFailMessage() fail message}.</p>
+     *
+     * @param failed {@code true} if authentication failed, {@code false} otherwise
+     */
+    public void setFailed(boolean failed) {
+        this.failed = failed;
+    }
+
+    /**
+     * Sets the profile properties.
+     *
+     * <p>This should be a valid JSON string.</p>
+     *
+     * @param propertiesJson the profile properties, as JSON
+     */
+    public void setPropertiesJson(String propertiesJson) {
+        this.propertiesJson = propertiesJson;
+    }
+
+    /**
+     * Gets the message to display to the client when authentication fails.
+     *
+     * @return the message to display to the client
+     */
+    public String getFailMessage() {
+        return this.failMessage;
+    }
+
+    /**
+     * Sets the message to display to the client when authentication fails.
+     *
+     * @param failMessage the message to display to the client
+     */
+    public void setFailMessage(String failMessage) {
+        Validate.notEmpty(failMessage, "fail message cannot be null or empty");
+        this.failMessage = failMessage;
+    }
+
+    @Override
+    public HandlerList getHandlers() {
+        return HANDLERS;
+    }
+
+    public static HandlerList getHandlerList() {
+        return HANDLERS;
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/event/server/ServerExceptionEvent.java b/src/main/java/com/destroystokyo/paper/event/server/ServerExceptionEvent.java
new file mode 100644
index 0000000..28e2d0c
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/event/server/ServerExceptionEvent.java
@@ -0,0 +1,37 @@
+package com.destroystokyo.paper.event.server;
+
+import com.google.common.base.Preconditions;
+import org.apache.commons.lang3.Validate;
+import org.bukkit.event.Event;
+import org.bukkit.event.HandlerList;
+import com.destroystokyo.paper.exception.ServerException;
+
+/**
+ * Called whenever an exception is thrown in a recoverable section of the server.
+ */
+public class ServerExceptionEvent extends Event {
+    private static final HandlerList handlers = new HandlerList();
+    private ServerException exception;
+
+    public ServerExceptionEvent(ServerException exception) {
+        this.exception = Preconditions.checkNotNull(exception, "exception");
+    }
+
+    /**
+     * Gets the wrapped exception that was thrown.
+     *
+     * @return Exception thrown
+     */
+    public ServerException getException() {
+        return exception;
+    }
+
+    @Override
+    public HandlerList getHandlers() {
+        return handlers;
+    }
+
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/exception/ServerPluginException.java b/src/main/java/com/destroystokyo/paper/exception/ServerPluginException.java
new file mode 100644
index 0000000..79f3ca4
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/exception/ServerPluginException.java
@@ -0,0 +1,38 @@
+package com.destroystokyo.paper.exception;
+
+import com.google.common.base.Preconditions;
+import org.apache.commons.lang3.Validate;
+import org.bukkit.plugin.Plugin;
+
+import static com.google.common.base.Preconditions.*;
+
+/**
+ * Wrapper exception for all cases to which a plugin can be immediately blamed for
+ */
+public class ServerPluginException extends ServerException {
+    public ServerPluginException(String message, Throwable cause, Plugin responsiblePlugin) {
+        super(message, cause);
+        this.responsiblePlugin = checkNotNull(responsiblePlugin, "responsiblePlugin");
+    }
+
+    public ServerPluginException(Throwable cause, Plugin responsiblePlugin) {
+        super(cause);
+        this.responsiblePlugin = checkNotNull(responsiblePlugin, "responsiblePlugin");
+    }
+
+    protected ServerPluginException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace, Plugin responsiblePlugin) {
+        super(message, cause, enableSuppression, writableStackTrace);
+        this.responsiblePlugin = checkNotNull(responsiblePlugin, "responsiblePlugin");
+    }
+
+    private final Plugin responsiblePlugin;
+
+    /**
+     * Gets the plugin which is directly responsible for the exception being thrown
+     *
+     * @return plugin which is responsible for the exception throw
+     */
+    public Plugin getResponsiblePlugin() {
+        return responsiblePlugin;
+    }
+}
diff --git a/src/main/java/org/bukkit/Art.java b/src/main/java/org/bukkit/Art.java
new file mode 100644
index 0000000..679cc8a
--- /dev/null
+++ b/src/main/java/org/bukkit/Art.java
@@ -0,0 +1,111 @@
+package org.bukkit;
+
+import java.util.HashMap;
+
+import org.apache.commons.lang3.Validate;
+
+import com.google.common.collect.Maps;
+
+/**
+ * Represents the art on a painting
+ */
+public enum Art {
+    KEBAB(0, 1, 1),
+    AZTEC(1, 1, 1),
+    ALBAN(2, 1, 1),
+    AZTEC2(3, 1, 1),
+    BOMB(4, 1, 1),
+    PLANT(5, 1, 1),
+    WASTELAND(6, 1, 1),
+    POOL(7, 2, 1),
+    COURBET(8, 2, 1),
+    SEA(9, 2, 1),
+    SUNSET(10, 2, 1),
+    CREEBET(11, 2, 1),
+    WANDERER(12, 1, 2),
+    GRAHAM(13, 1, 2),
+    MATCH(14, 2, 2),
+    BUST(15, 2, 2),
+    STAGE(16, 2, 2),
+    VOID(17, 2, 2),
+    SKULL_AND_ROSES(18, 2, 2),
+    WITHER(19, 2, 2),
+    FIGHTERS(20, 4, 2),
+    POINTER(21, 4, 4),
+    PIGSCENE(22, 4, 4),
+    BURNINGSKULL(23, 4, 4),
+    SKELETON(24, 4, 3),
+    DONKEYKONG(25, 4, 3);
+
+    private int id, width, height;
+    private static final HashMap<String, Art> BY_NAME = Maps.newHashMap();
+    private static final HashMap<Integer, Art> BY_ID = Maps.newHashMap();
+
+    private Art(int id, int width, int height) {
+        this.id = id;
+        this.width = width;
+        this.height = height;
+    }
+
+    /**
+     * Gets the width of the painting, in blocks
+     *
+     * @return The width of the painting, in blocks
+     */
+    public int getBlockWidth() {
+        return width;
+    }
+
+    /**
+     * Gets the height of the painting, in blocks
+     *
+     * @return The height of the painting, in blocks
+     */
+    public int getBlockHeight() {
+        return height;
+    }
+
+    /**
+     * Get the ID of this painting.
+     *
+     * @return The ID of this painting
+     * @deprecated Magic value
+     */
+    @Deprecated
+    public int getId() {
+        return id;
+    }
+
+    /**
+     * Get a painting by its numeric ID
+     *
+     * @param id The ID
+     * @return The painting
+     * @deprecated Magic value
+     */
+    @Deprecated
+    public static Art getById(int id) {
+        return BY_ID.get(id);
+    }
+
+    /**
+     * Get a painting by its unique name
+     * <p>
+     * This ignores underscores and capitalization
+     *
+     * @param name The name
+     * @return The painting
+     */
+    public static Art getByName(String name) {
+        Validate.notNull(name, "Name cannot be null");
+
+        return BY_NAME.get(name.toLowerCase().replaceAll("_", ""));
+    }
+
+    static {
+        for (Art art : values()) {
+            BY_ID.put(art.id, art);
+            BY_NAME.put(art.toString().toLowerCase().replaceAll("_", ""), art);
+        }
+    }
+}
diff --git a/src/main/java/org/bukkit/ChatColor.java b/src/main/java/org/bukkit/ChatColor.java
new file mode 100644
index 0000000..6a44c8c
--- /dev/null
+++ b/src/main/java/org/bukkit/ChatColor.java
@@ -0,0 +1,371 @@
+package org.bukkit;
+
+import java.util.Map;
+import java.util.regex.Pattern;
+
+import org.apache.commons.lang3.Validate;
+
+import com.google.common.collect.Maps;
+
+/**
+ * All supported color values for chat
+ */
+public enum ChatColor{
+    /**
+     * Represents black
+     */
+    BLACK('0', 0x00) {
+        @Override
+        public net.md_5.bungee.api.ChatColor asBungee() {
+            return net.md_5.bungee.api.ChatColor.BLACK;
+        }
+    },
+    /**
+     * Represents dark blue
+     */
+    DARK_BLUE('1', 0x1){
+        @Override
+        public net.md_5.bungee.api.ChatColor asBungee() {
+            return net.md_5.bungee.api.ChatColor.DARK_BLUE;
+        }
+    },
+    /**
+     * Represents dark green
+     */
+    DARK_GREEN('2', 0x2){
+        @Override
+        public net.md_5.bungee.api.ChatColor asBungee() {
+            return net.md_5.bungee.api.ChatColor.DARK_GREEN;
+        }
+    },
+    /**
+     * Represents dark blue (aqua)
+     */
+    DARK_AQUA('3', 0x3){
+        @Override
+        public net.md_5.bungee.api.ChatColor asBungee() {
+            return net.md_5.bungee.api.ChatColor.DARK_AQUA;
+        }
+    },
+    /**
+     * Represents dark red
+     */
+    DARK_RED('4', 0x4){
+        @Override
+        public net.md_5.bungee.api.ChatColor asBungee() {
+            return net.md_5.bungee.api.ChatColor.DARK_RED;
+        }
+    },
+    /**
+     * Represents dark purple
+     */
+    DARK_PURPLE('5', 0x5){
+        @Override
+        public net.md_5.bungee.api.ChatColor asBungee() {
+            return net.md_5.bungee.api.ChatColor.DARK_PURPLE;
+        }
+    },
+    /**
+     * Represents gold
+     */
+    GOLD('6', 0x6){
+        @Override
+        public net.md_5.bungee.api.ChatColor asBungee() {
+            return net.md_5.bungee.api.ChatColor.GOLD;
+        }
+    },
+    /**
+     * Represents gray
+     */
+    GRAY('7', 0x7){
+        @Override
+        public net.md_5.bungee.api.ChatColor asBungee() {
+            return net.md_5.bungee.api.ChatColor.GRAY;
+        }
+    },
+    /**
+     * Represents dark gray
+     */
+    DARK_GRAY('8', 0x8){
+        @Override
+        public net.md_5.bungee.api.ChatColor asBungee() {
+            return net.md_5.bungee.api.ChatColor.DARK_GRAY;
+        }
+    },
+    /**
+     * Represents blue
+     */
+    BLUE('9', 0x9){
+        @Override
+        public net.md_5.bungee.api.ChatColor asBungee() {
+            return net.md_5.bungee.api.ChatColor.BLUE;
+        }
+    },
+    /**
+     * Represents green
+     */
+    GREEN('a', 0xA){
+        @Override
+        public net.md_5.bungee.api.ChatColor asBungee() {
+            return net.md_5.bungee.api.ChatColor.GREEN;
+        }
+    },
+    /**
+     * Represents aqua
+     */
+    AQUA('b', 0xB){
+        @Override
+        public net.md_5.bungee.api.ChatColor asBungee() {
+            return net.md_5.bungee.api.ChatColor.AQUA;
+        }
+    },
+    /**
+     * Represents red
+     */
+    RED('c', 0xC){
+        @Override
+        public net.md_5.bungee.api.ChatColor asBungee() {
+            return net.md_5.bungee.api.ChatColor.RED;
+        }
+    },
+    /**
+     * Represents light purple
+     */
+    LIGHT_PURPLE('d', 0xD){
+        @Override
+        public net.md_5.bungee.api.ChatColor asBungee() {
+            return net.md_5.bungee.api.ChatColor.LIGHT_PURPLE;
+        }
+    },
+    /**
+     * Represents yellow
+     */
+    YELLOW('e', 0xE){
+        @Override
+        public net.md_5.bungee.api.ChatColor asBungee() {
+            return net.md_5.bungee.api.ChatColor.YELLOW;
+        }
+    },
+    /**
+     * Represents white
+     */
+    WHITE('f', 0xF){
+        @Override
+        public net.md_5.bungee.api.ChatColor asBungee() {
+            return net.md_5.bungee.api.ChatColor.WHITE;
+        }
+    },
+    /**
+     * Represents magical characters that change around randomly
+     */
+    MAGIC('k', 0x10, true){
+        @Override
+        public net.md_5.bungee.api.ChatColor asBungee() {
+            return net.md_5.bungee.api.ChatColor.MAGIC;
+        }
+    },
+    /**
+     * Makes the text bold.
+     */
+    BOLD('l', 0x11, true){
+        @Override
+        public net.md_5.bungee.api.ChatColor asBungee() {
+            return net.md_5.bungee.api.ChatColor.BOLD;
+        }
+    },
+    /**
+     * Makes a line appear through the text.
+     */
+    STRIKETHROUGH('m', 0x12, true){
+        @Override
+        public net.md_5.bungee.api.ChatColor asBungee() {
+            return net.md_5.bungee.api.ChatColor.STRIKETHROUGH;
+        }
+    },
+    /**
+     * Makes the text appear underlined.
+     */
+    UNDERLINE('n', 0x13, true){
+        @Override
+        public net.md_5.bungee.api.ChatColor asBungee() {
+            return net.md_5.bungee.api.ChatColor.UNDERLINE;
+        }
+    },
+    /**
+     * Makes the text italic.
+     */
+    ITALIC('o', 0x14, true){
+        @Override
+        public net.md_5.bungee.api.ChatColor asBungee() {
+            return net.md_5.bungee.api.ChatColor.ITALIC;
+        }
+    },
+    /**
+     * Resets all previous chat colors or formats.
+     */
+    RESET('r', 0x15){
+        @Override
+        public net.md_5.bungee.api.ChatColor asBungee() {
+            return net.md_5.bungee.api.ChatColor.RESET;
+        }
+    };
+
+    /**
+     * The special character which prefixes all chat colour codes. Use this if
+     * you need to dynamically convert colour codes from your custom format.
+     */
+    public static final char COLOR_CHAR = '\u00A7';
+    private static final Pattern STRIP_COLOR_PATTERN = Pattern.compile("(?i)" + String.valueOf(COLOR_CHAR) + "[0-9A-FK-OR]");
+
+    private final int intCode;
+    private final char code;
+    private final boolean isFormat;
+    private final String toString;
+    private final static Map<Integer, ChatColor> BY_ID = Maps.newHashMap();
+    private final static Map<Character, ChatColor> BY_CHAR = Maps.newHashMap();
+
+    private ChatColor(char code, int intCode) {
+        this(code, intCode, false);
+    }
+
+    private ChatColor(char code, int intCode, boolean isFormat) {
+        this.code = code;
+        this.intCode = intCode;
+        this.isFormat = isFormat;
+        this.toString = new String(new char[] {COLOR_CHAR, code});
+    }
+
+    public net.md_5.bungee.api.ChatColor asBungee() {
+        return net.md_5.bungee.api.ChatColor.RESET;
+    };
+
+    /**
+     * Gets the char value associated with this color
+     *
+     * @return A char value of this color code
+     */
+    public char getChar() {
+        return code;
+    }
+
+    @Override
+    public String toString() {
+        return toString;
+    }
+
+    /**
+     * Checks if this code is a format code as opposed to a color code.
+     * 
+     * @return whether this ChatColor is a format code
+     */
+    public boolean isFormat() {
+        return isFormat;
+    }
+
+    /**
+     * Checks if this code is a color code as opposed to a format code.
+     * 
+     * @return whether this ChatColor is a color code
+     */
+    public boolean isColor() {
+        return !isFormat && this != RESET;
+    }
+
+    /**
+     * Gets the color represented by the specified color code
+     *
+     * @param code Code to check
+     * @return Associative {@link org.bukkit.ChatColor} with the given code,
+     *     or null if it doesn't exist
+     */
+    public static ChatColor getByChar(char code) {
+        return BY_CHAR.get(code);
+    }
+
+    /**
+     * Gets the color represented by the specified color code
+     *
+     * @param code Code to check
+     * @return Associative {@link org.bukkit.ChatColor} with the given code,
+     *     or null if it doesn't exist
+     */
+    public static ChatColor getByChar(String code) {
+        Validate.notNull(code, "Code cannot be null");
+        Validate.isTrue(code.length() > 0, "Code must have at least one char");
+
+        return BY_CHAR.get(code.charAt(0));
+    }
+
+    /**
+     * Strips the given message of all color codes
+     *
+     * @param input String to strip of color
+     * @return A copy of the input string, without any coloring
+     */
+    public static String stripColor(final String input) {
+        if (input == null) {
+            return null;
+        }
+
+        return STRIP_COLOR_PATTERN.matcher(input).replaceAll("");
+    }
+
+    /**
+     * Translates a string using an alternate color code character into a
+     * string that uses the internal ChatColor.COLOR_CODE color code
+     * character. The alternate color code character will only be replaced if
+     * it is immediately followed by 0-9, A-F, a-f, K-O, k-o, R or r.
+     *
+     * @param altColorChar The alternate color code character to replace. Ex: {@literal &}
+     * @param textToTranslate Text containing the alternate color code character.
+     * @return Text containing the ChatColor.COLOR_CODE color code character.
+     */
+    public static String translateAlternateColorCodes(char altColorChar, String textToTranslate) {
+        char[] b = textToTranslate.toCharArray();
+        for (int i = 0; i < b.length - 1; i++) {
+            if (b[i] == altColorChar && "0123456789AaBbCcDdEeFfKkLlMmNnOoRr".indexOf(b[i+1]) > -1) {
+                b[i] = ChatColor.COLOR_CHAR;
+                b[i+1] = Character.toLowerCase(b[i+1]);
+            }
+        }
+        return new String(b);
+    }
+
+    /**
+     * Gets the ChatColors used at the end of the given input string.
+     *
+     * @param input Input string to retrieve the colors from.
+     * @return Any remaining ChatColors to pass onto the next line.
+     */
+    public static String getLastColors(String input) {
+        String result = "";
+        int length = input.length();
+
+        // Search backwards from the end as it is faster
+        for (int index = length - 1; index > -1; index--) {
+            char section = input.charAt(index);
+            if (section == COLOR_CHAR && index < length - 1) {
+                char c = input.charAt(index + 1);
+                ChatColor color = getByChar(c);
+
+                if (color != null) {
+                    result = color.toString() + result;
+
+                    // Once we find a color or reset we can stop searching
+                    if (color.isColor() || color.equals(RESET)) {
+                        break;
+                    }
+                }
+            }
+        }
+
+        return result;
+    }
+
+    static {
+        for (ChatColor color : values()) {
+            BY_ID.put(color.intCode, color);
+            BY_CHAR.put(color.code, color);
+        }
+    }
+}
diff --git a/src/main/java/org/bukkit/Color.java b/src/main/java/org/bukkit/Color.java
new file mode 100644
index 0000000..052a2c7
--- /dev/null
+++ b/src/main/java/org/bukkit/Color.java
@@ -0,0 +1,344 @@
+package org.bukkit;
+
+import java.util.Map;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.configuration.serialization.ConfigurationSerializable;
+import org.bukkit.configuration.serialization.SerializableAs;
+
+import com.google.common.collect.ImmutableMap;
+
+/**
+ * A container for a color palette. This class is immutable; the set methods
+ * return a new color. The color names listed as fields are HTML4 standards,
+ * but subject to change.
+ */
+@SerializableAs("Color")
+public final class Color implements ConfigurationSerializable {
+    private static final int BIT_MASK = 0xff;
+
+    /**
+     * White, or (0xFF,0xFF,0xFF) in (R,G,B)
+     */
+    public static final Color WHITE = fromRGB(0xFFFFFF);
+
+    /**
+     * Silver, or (0xC0,0xC0,0xC0) in (R,G,B)
+     */
+    public static final Color SILVER = fromRGB(0xC0C0C0);
+
+    /**
+     * Gray, or (0x80,0x80,0x80) in (R,G,B)
+     */
+    public static final Color GRAY = fromRGB(0x808080);
+
+    /**
+     * Black, or (0x00,0x00,0x00) in (R,G,B)
+     */
+    public static final Color BLACK = fromRGB(0x000000);
+
+    /**
+     * Red, or (0xFF,0x00,0x00) in (R,G,B)
+     */
+    public static final Color RED = fromRGB(0xFF0000);
+
+    /**
+     * Maroon, or (0x80,0x00,0x00) in (R,G,B)
+     */
+    public static final Color MAROON = fromRGB(0x800000);
+
+    /**
+     * Yellow, or (0xFF,0xFF,0x00) in (R,G,B)
+     */
+    public static final Color YELLOW = fromRGB(0xFFFF00);
+
+    /**
+     * Olive, or (0x80,0x80,0x00) in (R,G,B)
+     */
+    public static final Color OLIVE = fromRGB(0x808000);
+
+    /**
+     * Lime, or (0x00,0xFF,0x00) in (R,G,B)
+     */
+    public static final Color LIME = fromRGB(0x00FF00);
+
+    /**
+     * Green, or (0x00,0x80,0x00) in (R,G,B)
+     */
+    public static final Color GREEN = fromRGB(0x008000);
+
+    /**
+     * Aqua, or (0x00,0xFF,0xFF) in (R,G,B)
+     */
+    public static final Color AQUA = fromRGB(0x00FFFF);
+
+    /**
+     * Teal, or (0x00,0x80,0x80) in (R,G,B)
+     */
+    public static final Color TEAL = fromRGB(0x008080);
+
+    /**
+     * Blue, or (0x00,0x00,0xFF) in (R,G,B)
+     */
+    public static final Color BLUE = fromRGB(0x0000FF);
+
+    /**
+     * Navy, or (0x00,0x00,0x80) in (R,G,B)
+     */
+    public static final Color NAVY = fromRGB(0x000080);
+
+    /**
+     * Fuchsia, or (0xFF,0x00,0xFF) in (R,G,B)
+     */
+    public static final Color FUCHSIA = fromRGB(0xFF00FF);
+
+    /**
+     * Purple, or (0x80,0x00,0x80) in (R,G,B)
+     */
+    public static final Color PURPLE = fromRGB(0x800080);
+
+    /**
+     * Orange, or (0xFF,0xA5,0x00) in (R,G,B)
+     */
+    public static final Color ORANGE = fromRGB(0xFFA500);
+
+    private final byte red;
+    private final byte green;
+    private final byte blue;
+
+    /**
+     * Creates a new Color object from a red, green, and blue
+     *
+     * @param red integer from 0-255
+     * @param green integer from 0-255
+     * @param blue integer from 0-255
+     * @return a new Color object for the red, green, blue
+     * @throws IllegalArgumentException if any value is strictly {@literal >255 or <0}
+     */
+    public static Color fromRGB(int red, int green, int blue) throws IllegalArgumentException {
+        return new Color(red, green, blue);
+    }
+
+    /**
+     * Creates a new Color object from a blue, green, and red
+     *
+     * @param blue integer from 0-255
+     * @param green integer from 0-255
+     * @param red integer from 0-255
+     * @return a new Color object for the red, green, blue
+     * @throws IllegalArgumentException if any value is strictly {@literal >255 or <0}
+     */
+    public static Color fromBGR(int blue, int green, int red) throws IllegalArgumentException {
+        return new Color(red, green, blue);
+    }
+
+    /**
+     * Creates a new color object from an integer that contains the red,
+     * green, and blue bytes in the lowest order 24 bits.
+     *
+     * @param rgb the integer storing the red, green, and blue values
+     * @return a new color object for specified values
+     * @throws IllegalArgumentException if any data is in the highest order 8
+     *     bits
+     */
+    public static Color fromRGB(int rgb) throws IllegalArgumentException {
+        Validate.isTrue((rgb >> 24) == 0, "Extrenuous data in: ", rgb);
+        return fromRGB(rgb >> 16 & BIT_MASK, rgb >> 8 & BIT_MASK, rgb >> 0 & BIT_MASK);
+    }
+
+    /**
+     * Creates a new color object from an integer that contains the blue,
+     * green, and red bytes in the lowest order 24 bits.
+     *
+     * @param bgr the integer storing the blue, green, and red values
+     * @return a new color object for specified values
+     * @throws IllegalArgumentException if any data is in the highest order 8
+     *     bits
+     */
+    public static Color fromBGR(int bgr) throws IllegalArgumentException {
+        Validate.isTrue((bgr >> 24) == 0, "Extrenuous data in: ", bgr);
+        return fromBGR(bgr >> 16 & BIT_MASK, bgr >> 8 & BIT_MASK, bgr >> 0 & BIT_MASK);
+    }
+
+    private Color(int red, int green, int blue) {
+        Validate.isTrue(red >= 0 && red <= BIT_MASK, "Red is not between 0-255: ", red);
+        Validate.isTrue(green >= 0 && green <= BIT_MASK, "Green is not between 0-255: ", green);
+        Validate.isTrue(blue >= 0 && blue <= BIT_MASK, "Blue is not between 0-255: ", blue);
+
+        this.red = (byte) red;
+        this.green = (byte) green;
+        this.blue = (byte) blue;
+    }
+
+    /**
+     * Gets the red component
+     *
+     * @return red component, from 0 to 255
+     */
+    public int getRed() {
+        return BIT_MASK & red;
+    }
+
+    /**
+     * Creates a new Color object with specified component
+     *
+     * @param red the red component, from 0 to 255
+     * @return a new color object with the red component
+     */
+    public Color setRed(int red) {
+        return fromRGB(red, getGreen(), getBlue());
+    }
+
+    /**
+     * Gets the green component
+     *
+     * @return green component, from 0 to 255
+     */
+    public int getGreen() {
+        return BIT_MASK & green;
+    }
+
+    /**
+     * Creates a new Color object with specified component
+     *
+     * @param green the red component, from 0 to 255
+     * @return a new color object with the red component
+     */
+    public Color setGreen(int green) {
+        return fromRGB(getRed(), green, getBlue());
+    }
+
+    /**
+     * Gets the blue component
+     *
+     * @return blue component, from 0 to 255
+     */
+    public int getBlue() {
+        return BIT_MASK & blue;
+    }
+
+    /**
+     * Creates a new Color object with specified component
+     *
+     * @param blue the red component, from 0 to 255
+     * @return a new color object with the red component
+     */
+    public Color setBlue(int blue) {
+        return fromRGB(getRed(), getGreen(), blue);
+    }
+
+    /**
+     *
+     * @return An integer representation of this color, as 0xRRGGBB
+     */
+    public int asRGB() {
+        return getRed() << 16 | getGreen() << 8 | getBlue() << 0;
+    }
+
+    /**
+     *
+     * @return An integer representation of this color, as 0xBBGGRR
+     */
+    public int asBGR() {
+        return getBlue() << 16 | getGreen() << 8 | getRed() << 0;
+    }
+
+    /**
+     * Creates a new color with its RGB components changed as if it was dyed
+     * with the colors passed in, replicating vanilla workbench dyeing
+     *
+     * @param colors The DyeColors to dye with
+     * @return A new color with the changed rgb components
+     */
+    // TODO: Javadoc what this method does, not what it mimics. API != Implementation
+    public Color mixDyes(DyeColor... colors) {
+        Validate.noNullElements(colors, "Colors cannot be null");
+
+        Color[] toPass = new Color[colors.length];
+        for (int i = 0; i < colors.length; i++) {
+            toPass[i] = colors[i].getColor();
+        }
+
+        return mixColors(toPass);
+    }
+
+    /**
+     * Creates a new color with its RGB components changed as if it was dyed
+     * with the colors passed in, replicating vanilla workbench dyeing
+     *
+     * @param colors The colors to dye with
+     * @return A new color with the changed rgb components
+     */
+    // TODO: Javadoc what this method does, not what it mimics. API != Implementation
+    public Color mixColors(Color... colors) {
+        Validate.noNullElements(colors, "Colors cannot be null");
+
+        int totalRed = this.getRed();
+        int totalGreen = this.getGreen();
+        int totalBlue = this.getBlue();
+        int totalMax = Math.max(Math.max(totalRed, totalGreen), totalBlue);
+        for (Color color : colors) {
+            totalRed += color.getRed();
+            totalGreen += color.getGreen();
+            totalBlue += color.getBlue();
+            totalMax += Math.max(Math.max(color.getRed(), color.getGreen()), color.getBlue());
+        }
+
+        float averageRed = totalRed / (colors.length + 1);
+        float averageGreen = totalGreen / (colors.length + 1);
+        float averageBlue = totalBlue / (colors.length + 1);
+        float averageMax = totalMax / (colors.length + 1);
+
+        float maximumOfAverages = Math.max(Math.max(averageRed, averageGreen), averageBlue);
+        float gainFactor = averageMax / maximumOfAverages;
+
+        return Color.fromRGB((int) (averageRed * gainFactor), (int) (averageGreen * gainFactor), (int) (averageBlue * gainFactor));
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (!(o instanceof Color)) {
+            return false;
+        }
+        final Color that = (Color) o;
+        return this.blue == that.blue && this.green == that.green && this.red == that.red;
+    }
+
+    @Override
+    public int hashCode() {
+        return asRGB() ^ Color.class.hashCode();
+    }
+
+    public Map<String, Object> serialize() {
+        return ImmutableMap.<String, Object>of(
+            "RED", getRed(),
+            "BLUE", getBlue(),
+            "GREEN", getGreen()
+        );
+    }
+
+    @SuppressWarnings("javadoc")
+    public static Color deserialize(Map<String, Object> map) {
+        return fromRGB(
+            asInt("RED", map),
+            asInt("GREEN", map),
+            asInt("BLUE", map)
+        );
+    }
+
+    private static int asInt(String string, Map<String, Object> map) {
+        Object value = map.get(string);
+        if (value == null) {
+            throw new IllegalArgumentException(string + " not in map " + map);
+        }
+        if (!(value instanceof Number)) {
+            throw new IllegalArgumentException(string + '(' + value + ") is not a number");
+        }
+        return ((Number) value).intValue();
+    }
+
+    @Override
+    public String toString() {
+        return "Color:[rgb0x" + Integer.toHexString(getRed()).toUpperCase() + Integer.toHexString(getGreen()).toUpperCase() + Integer.toHexString(getBlue()).toUpperCase() + "]";
+    }
+}
diff --git a/src/main/java/org/bukkit/FireworkEffect.java b/src/main/java/org/bukkit/FireworkEffect.java
new file mode 100644
index 0000000..f55ecdc
--- /dev/null
+++ b/src/main/java/org/bukkit/FireworkEffect.java
@@ -0,0 +1,424 @@
+package org.bukkit;
+
+import java.util.List;
+import java.util.Map;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.configuration.serialization.ConfigurationSerializable;
+import org.bukkit.configuration.serialization.SerializableAs;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
+
+/**
+ * Represents a single firework effect.
+ */
+@SerializableAs("Firework")
+public final class FireworkEffect implements ConfigurationSerializable {
+
+    /**
+     * The type or shape of the effect.
+     */
+    public enum Type {
+        /**
+         * A small ball effect.
+         */
+        BALL,
+        /**
+         * A large ball effect.
+         */
+        BALL_LARGE,
+        /**
+         * A star-shaped effect.
+         */
+        STAR,
+        /**
+         * A burst effect.
+         */
+        BURST,
+        /**
+         * A creeper-face effect.
+         */
+        CREEPER,
+        ;
+    }
+
+    /**
+     * Construct a firework effect.
+     *
+     * @return A utility object for building a firework effect
+     */
+    public static Builder builder() {
+        return new Builder();
+    }
+
+    /**
+     * This is a builder for FireworkEffects.
+     *
+     * @see FireworkEffect#builder()
+     */
+    public static final class Builder {
+        boolean flicker = false;
+        boolean trail = false;
+        final ImmutableList.Builder<Color> colors = ImmutableList.builder();
+        ImmutableList.Builder<Color> fadeColors = null;
+        Type type = Type.BALL;
+
+        Builder() {}
+
+        /**
+         * Specify the type of the firework effect.
+         *
+         * @param type The effect type
+         * @return This object, for chaining
+         * @throws IllegalArgumentException If type is null
+         */
+        public Builder with(Type type) throws IllegalArgumentException {
+            Validate.notNull(type, "Cannot have null type");
+            this.type = type;
+            return this;
+        }
+
+        /**
+         * Add a flicker to the firework effect.
+         *
+         * @return This object, for chaining
+         */
+        public Builder withFlicker() {
+            flicker = true;
+            return this;
+        }
+
+        /**
+         * Set whether the firework effect should flicker.
+         *
+         * @param flicker true if it should flicker, false if not
+         * @return This object, for chaining
+         */
+        public Builder flicker(boolean flicker) {
+            this.flicker = flicker;
+            return this;
+        }
+
+        /**
+         * Add a trail to the firework effect.
+         *
+         * @return This object, for chaining
+         */
+        public Builder withTrail() {
+            trail = true;
+            return this;
+        }
+
+        /**
+         * Set whether the firework effect should have a trail.
+         *
+         * @param trail true if it should have a trail, false for no trail
+         * @return This object, for chaining
+         */
+        public Builder trail(boolean trail) {
+            this.trail = trail;
+            return this;
+        }
+
+        /**
+         * Add a primary color to the firework effect.
+         *
+         * @param color The color to add
+         * @return This object, for chaining
+         * @throws IllegalArgumentException If color is null
+         */
+        public Builder withColor(Color color) throws IllegalArgumentException {
+            Validate.notNull(color, "Cannot have null color");
+
+            colors.add(color);
+
+            return this;
+        }
+
+        /**
+         * Add several primary colors to the firework effect.
+         *
+         * @param colors The colors to add
+         * @return This object, for chaining
+         * @throws IllegalArgumentException If colors is null
+         * @throws IllegalArgumentException If any color is null (may be
+         *     thrown after changes have occurred)
+         */
+        public Builder withColor(Color...colors) throws IllegalArgumentException {
+            Validate.notNull(colors, "Cannot have null colors");
+            if (colors.length == 0) {
+                return this;
+            }
+
+            ImmutableList.Builder<Color> list = this.colors;
+            for (Color color : colors) {
+                Validate.notNull(color, "Color cannot be null");
+                list.add(color);
+            }
+
+            return this;
+        }
+
+        /**
+         * Add several primary colors to the firework effect.
+         *
+         * @param colors An iterable object whose iterator yields the desired
+         *     colors
+         * @return This object, for chaining
+         * @throws IllegalArgumentException If colors is null
+         * @throws IllegalArgumentException If any color is null (may be
+         *     thrown after changes have occurred)
+         */
+        public Builder withColor(Iterable<?> colors) throws IllegalArgumentException {
+            Validate.notNull(colors, "Cannot have null colors");
+
+            ImmutableList.Builder<Color> list = this.colors;
+            for (Object color : colors) {
+                if (!(color instanceof Color)) {
+                    throw new IllegalArgumentException(color + " is not a Color in " + colors);
+                }
+                list.add((Color) color);
+            }
+
+            return this;
+        }
+
+        /**
+         * Add a fade color to the firework effect.
+         *
+         * @param color The color to add
+         * @return This object, for chaining
+         * @throws IllegalArgumentException If colors is null
+         * @throws IllegalArgumentException If any color is null (may be
+         *     thrown after changes have occurred)
+         */
+        public Builder withFade(Color color) throws IllegalArgumentException {
+            Validate.notNull(color, "Cannot have null color");
+
+            if (fadeColors == null) {
+                fadeColors = ImmutableList.builder();
+            }
+
+            fadeColors.add(color);
+
+            return this;
+        }
+
+        /**
+         * Add several fade colors to the firework effect.
+         *
+         * @param colors The colors to add
+         * @return This object, for chaining
+         * @throws IllegalArgumentException If colors is null
+         * @throws IllegalArgumentException If any color is null (may be
+         *     thrown after changes have occurred)
+         */
+        public Builder withFade(Color...colors) throws IllegalArgumentException {
+            Validate.notNull(colors, "Cannot have null colors");
+            if (colors.length == 0) {
+                return this;
+            }
+
+            ImmutableList.Builder<Color> list = this.fadeColors;
+            if (list == null) {
+                list = this.fadeColors = ImmutableList.builder();
+            }
+
+            for (Color color : colors) {
+                Validate.notNull(color, "Color cannot be null");
+                list.add(color);
+            }
+
+            return this;
+        }
+
+        /**
+         * Add several fade colors to the firework effect.
+         *
+         * @param colors An iterable object whose iterator yields the desired
+         *     colors
+         * @return This object, for chaining
+         * @throws IllegalArgumentException If colors is null
+         * @throws IllegalArgumentException If any color is null (may be
+         *     thrown after changes have occurred)
+         */
+        public Builder withFade(Iterable<?> colors) throws IllegalArgumentException {
+            Validate.notNull(colors, "Cannot have null colors");
+
+            ImmutableList.Builder<Color> list = this.fadeColors;
+            if (list == null) {
+                list = this.fadeColors = ImmutableList.builder();
+            }
+
+            for (Object color : colors) {
+                if (!(color instanceof Color)) {
+                    throw new IllegalArgumentException(color + " is not a Color in " + colors);
+                }
+                list.add((Color) color);
+            }
+
+            return this;
+        }
+
+        /**
+         * Create a {@link FireworkEffect} from the current contents of this
+         * builder.
+         * <p>
+         * To successfully build, you must have specified at least one color.
+         *
+         * @return The representative firework effect
+         */
+        public FireworkEffect build() {
+            return new FireworkEffect(
+                flicker,
+                trail,
+                colors.build(),
+                fadeColors == null ? ImmutableList.<Color>of() : fadeColors.build(),
+                type
+            );
+        }
+    }
+
+    private static final String FLICKER = "flicker";
+    private static final String TRAIL = "trail";
+    private static final String COLORS = "colors";
+    private static final String FADE_COLORS = "fade-colors";
+    private static final String TYPE = "type";
+
+    private final boolean flicker;
+    private final boolean trail;
+    private final ImmutableList<Color> colors;
+    private final ImmutableList<Color> fadeColors;
+    private final Type type;
+    private String string = null;
+
+    FireworkEffect(boolean flicker, boolean trail, ImmutableList<Color> colors, ImmutableList<Color> fadeColors, Type type) {
+        if (colors.isEmpty()) {
+            throw new IllegalStateException("Cannot make FireworkEffect without any color");
+        }
+        this.flicker = flicker;
+        this.trail = trail;
+        this.colors = colors;
+        this.fadeColors = fadeColors;
+        this.type = type;
+    }
+
+    /**
+     * Get whether the firework effect flickers.
+     *
+     * @return true if it flickers, false if not
+     */
+    public boolean hasFlicker() {
+        return flicker;
+    }
+
+    /**
+     * Get whether the firework effect has a trail.
+     *
+     * @return true if it has a trail, false if not
+     */
+    public boolean hasTrail() {
+        return trail;
+    }
+
+    /**
+     * Get the primary colors of the firework effect.
+     *
+     * @return An immutable list of the primary colors
+     */
+    public List<Color> getColors() {
+        return colors;
+    }
+
+    /**
+     * Get the fade colors of the firework effect.
+     *
+     * @return An immutable list of the fade colors
+     */
+    public List<Color> getFadeColors() {
+        return fadeColors;
+    }
+
+    /**
+     * Get the type of the firework effect.
+     *
+     * @return The effect type
+     */
+    public Type getType() {
+        return type;
+    }
+
+    /**
+     * @see ConfigurationSerializable
+     * @param map the map to deserialize
+     * @return the resulting serializable
+     */
+    public static ConfigurationSerializable deserialize(Map<String, Object> map) {
+        Type type = Type.valueOf((String) map.get(TYPE));
+        if (type == null) {
+            throw new IllegalArgumentException(map.get(TYPE) + " is not a valid Type");
+        }
+
+        return builder()
+            .flicker((Boolean) map.get(FLICKER))
+            .trail((Boolean) map.get(TRAIL))
+            .withColor((Iterable<?>) map.get(COLORS))
+            .withFade((Iterable<?>) map.get(FADE_COLORS))
+            .with(type)
+            .build();
+    }
+
+    @Override
+    public Map<String, Object> serialize() {
+        return ImmutableMap.<String, Object>of(
+            FLICKER, flicker,
+            TRAIL, trail,
+            COLORS, colors,
+            FADE_COLORS, fadeColors,
+            TYPE, type.name()
+        );
+    }
+
+    @Override
+    public String toString() {
+        final String string = this.string;
+        if (string == null) {
+            return this.string = "FireworkEffect:" + serialize();
+        }
+        return string;
+    }
+
+    @Override
+    public int hashCode() {
+        /**
+         * TRUE and FALSE as per boolean.hashCode()
+         */
+        final int PRIME = 31, TRUE = 1231, FALSE = 1237;
+        int hash = 1;
+        hash = hash * PRIME + (flicker ? TRUE : FALSE);
+        hash = hash * PRIME + (trail ? TRUE : FALSE);
+        hash = hash * PRIME + type.hashCode();
+        hash = hash * PRIME + colors.hashCode();
+        hash = hash * PRIME + fadeColors.hashCode();
+        return hash;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj) {
+            return true;
+        }
+
+        if (!(obj instanceof FireworkEffect)) {
+            return false;
+        }
+
+        FireworkEffect that = (FireworkEffect) obj;
+        return this.flicker == that.flicker
+                && this.trail == that.trail
+                && this.type == that.type
+                && this.colors.equals(that.colors)
+                && this.fadeColors.equals(that.fadeColors);
+    }
+}
diff --git a/src/main/java/org/bukkit/Material.java b/src/main/java/org/bukkit/Material.java
new file mode 100644
index 0000000..3f016ca
--- /dev/null
+++ b/src/main/java/org/bukkit/Material.java
@@ -0,0 +1,1207 @@
+package org.bukkit;
+
+import java.lang.reflect.Constructor;
+import java.util.Map;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.map.MapView;
+import org.bukkit.material.Bed;
+import org.bukkit.material.Button;
+import org.bukkit.material.Cake;
+import org.bukkit.material.Cauldron;
+import org.bukkit.material.Chest;
+import org.bukkit.material.Coal;
+import org.bukkit.material.CocoaPlant;
+import org.bukkit.material.Command;
+import org.bukkit.material.Comparator;
+import org.bukkit.material.Crops;
+import org.bukkit.material.DetectorRail;
+import org.bukkit.material.Diode;
+import org.bukkit.material.Dispenser;
+import org.bukkit.material.Door;
+import org.bukkit.material.Dye;
+import org.bukkit.material.EnderChest;
+import org.bukkit.material.FlowerPot;
+import org.bukkit.material.Furnace;
+import org.bukkit.material.Gate;
+import org.bukkit.material.Hopper;
+import org.bukkit.material.Ladder;
+import org.bukkit.material.Leaves;
+import org.bukkit.material.Lever;
+import org.bukkit.material.LongGrass;
+import org.bukkit.material.MaterialData;
+import org.bukkit.material.MonsterEggs;
+import org.bukkit.material.Mushroom;
+import org.bukkit.material.NetherWarts;
+import org.bukkit.material.PistonBaseMaterial;
+import org.bukkit.material.PistonExtensionMaterial;
+import org.bukkit.material.PoweredRail;
+import org.bukkit.material.PressurePlate;
+import org.bukkit.material.Pumpkin;
+import org.bukkit.material.Rails;
+import org.bukkit.material.RedstoneTorch;
+import org.bukkit.material.RedstoneWire;
+import org.bukkit.material.Sandstone;
+import org.bukkit.material.Sapling;
+import org.bukkit.material.Sign;
+import org.bukkit.material.Skull;
+import org.bukkit.material.SmoothBrick;
+import org.bukkit.material.SpawnEgg;
+import org.bukkit.material.Stairs;
+import org.bukkit.material.Step;
+import org.bukkit.material.Torch;
+import org.bukkit.material.TrapDoor;
+import org.bukkit.material.Tree;
+import org.bukkit.material.Tripwire;
+import org.bukkit.material.TripwireHook;
+import org.bukkit.material.Vine;
+import org.bukkit.material.Wood;
+import org.bukkit.material.WoodenStep;
+import org.bukkit.material.Wool;
+import org.bukkit.potion.Potion;
+import org.bukkit.util.Java15Compat;
+
+import com.google.common.collect.Maps;
+
+import org.bukkit.material.Banner;
+
+/**
+ * An enum of all material IDs accepted by the official server and client
+ */
+public enum Material {
+    AIR(0, 0),
+    STONE(1),
+    GRASS(2),
+    DIRT(3),
+    COBBLESTONE(4),
+    WOOD(5, Wood.class),
+    SAPLING(6, Sapling.class),
+    BEDROCK(7),
+    WATER(8, MaterialData.class),
+    STATIONARY_WATER(9, MaterialData.class),
+    LAVA(10, MaterialData.class),
+    STATIONARY_LAVA(11, MaterialData.class),
+    SAND(12),
+    GRAVEL(13),
+    GOLD_ORE(14),
+    IRON_ORE(15),
+    COAL_ORE(16),
+    LOG(17, Tree.class),
+    LEAVES(18, Leaves.class),
+    SPONGE(19),
+    GLASS(20),
+    LAPIS_ORE(21),
+    LAPIS_BLOCK(22),
+    DISPENSER(23, Dispenser.class),
+    SANDSTONE(24, Sandstone.class),
+    NOTE_BLOCK(25),
+    BED_BLOCK(26, Bed.class),
+    POWERED_RAIL(27, PoweredRail.class),
+    DETECTOR_RAIL(28, DetectorRail.class),
+    PISTON_STICKY_BASE(29, PistonBaseMaterial.class),
+    WEB(30),
+    LONG_GRASS(31, LongGrass.class),
+    DEAD_BUSH(32),
+    PISTON_BASE(33, PistonBaseMaterial.class),
+    PISTON_EXTENSION(34, PistonExtensionMaterial.class),
+    WOOL(35, Wool.class),
+    PISTON_MOVING_PIECE(36),
+    YELLOW_FLOWER(37),
+    RED_ROSE(38),
+    BROWN_MUSHROOM(39),
+    RED_MUSHROOM(40),
+    GOLD_BLOCK(41),
+    IRON_BLOCK(42),
+    DOUBLE_STEP(43, Step.class),
+    STEP(44, Step.class),
+    BRICK(45),
+    TNT(46),
+    BOOKSHELF(47),
+    MOSSY_COBBLESTONE(48),
+    OBSIDIAN(49),
+    TORCH(50, Torch.class),
+    FIRE(51),
+    MOB_SPAWNER(52),
+    WOOD_STAIRS(53, Stairs.class),
+    CHEST(54, Chest.class),
+    REDSTONE_WIRE(55, RedstoneWire.class),
+    DIAMOND_ORE(56),
+    DIAMOND_BLOCK(57),
+    WORKBENCH(58),
+    CROPS(59, Crops.class),
+    SOIL(60, MaterialData.class),
+    FURNACE(61, Furnace.class),
+    BURNING_FURNACE(62, Furnace.class),
+    SIGN_POST(63, 64, Sign.class),
+    WOODEN_DOOR(64, Door.class),
+    LADDER(65, Ladder.class),
+    RAILS(66, Rails.class),
+    COBBLESTONE_STAIRS(67, Stairs.class),
+    WALL_SIGN(68, 64, Sign.class),
+    LEVER(69, Lever.class),
+    STONE_PLATE(70, PressurePlate.class),
+    IRON_DOOR_BLOCK(71, Door.class),
+    WOOD_PLATE(72, PressurePlate.class),
+    REDSTONE_ORE(73),
+    GLOWING_REDSTONE_ORE(74),
+    REDSTONE_TORCH_OFF(75, RedstoneTorch.class),
+    REDSTONE_TORCH_ON(76, RedstoneTorch.class),
+    STONE_BUTTON(77, Button.class),
+    SNOW(78),
+    ICE(79),
+    SNOW_BLOCK(80),
+    CACTUS(81, MaterialData.class),
+    CLAY(82),
+    SUGAR_CANE_BLOCK(83, MaterialData.class),
+    JUKEBOX(84),
+    FENCE(85),
+    PUMPKIN(86, Pumpkin.class),
+    NETHERRACK(87),
+    SOUL_SAND(88),
+    GLOWSTONE(89),
+    PORTAL(90),
+    JACK_O_LANTERN(91, Pumpkin.class),
+    CAKE_BLOCK(92, 64, Cake.class),
+    DIODE_BLOCK_OFF(93, Diode.class),
+    DIODE_BLOCK_ON(94, Diode.class),
+    STAINED_GLASS(95),
+    TRAP_DOOR(96, TrapDoor.class),
+    MONSTER_EGGS(97, MonsterEggs.class),
+    SMOOTH_BRICK(98, SmoothBrick.class),
+    HUGE_MUSHROOM_1(99, Mushroom.class),
+    HUGE_MUSHROOM_2(100, Mushroom.class),
+    IRON_FENCE(101),
+    THIN_GLASS(102),
+    MELON_BLOCK(103),
+    PUMPKIN_STEM(104, MaterialData.class),
+    MELON_STEM(105, MaterialData.class),
+    VINE(106, Vine.class),
+    FENCE_GATE(107, Gate.class),
+    BRICK_STAIRS(108, Stairs.class),
+    SMOOTH_STAIRS(109, Stairs.class),
+    MYCEL(110),
+    WATER_LILY(111),
+    NETHER_BRICK(112),
+    NETHER_FENCE(113),
+    NETHER_BRICK_STAIRS(114, Stairs.class),
+    NETHER_WARTS(115, NetherWarts.class),
+    ENCHANTMENT_TABLE(116),
+    BREWING_STAND(117, MaterialData.class),
+    CAULDRON(118, Cauldron.class),
+    ENDER_PORTAL(119),
+    ENDER_PORTAL_FRAME(120),
+    ENDER_STONE(121),
+    DRAGON_EGG(122),
+    REDSTONE_LAMP_OFF(123),
+    REDSTONE_LAMP_ON(124),
+    WOOD_DOUBLE_STEP(125, Wood.class),
+    WOOD_STEP(126, WoodenStep.class),
+    COCOA(127, CocoaPlant.class),
+    SANDSTONE_STAIRS(128, Stairs.class),
+    EMERALD_ORE(129),
+    ENDER_CHEST(130, EnderChest.class),
+    TRIPWIRE_HOOK(131, TripwireHook.class),
+    TRIPWIRE(132, Tripwire.class),
+    EMERALD_BLOCK(133),
+    SPRUCE_WOOD_STAIRS(134, Stairs.class),
+    BIRCH_WOOD_STAIRS(135, Stairs.class),
+    JUNGLE_WOOD_STAIRS(136, Stairs.class),
+    COMMAND(137, Command.class),
+    BEACON(138),
+    COBBLE_WALL(139),
+    FLOWER_POT(140, FlowerPot.class),
+    CARROT(141, Crops.class),
+    POTATO(142, Crops.class),
+    WOOD_BUTTON(143, Button.class),
+    SKULL(144, Skull.class),
+    ANVIL(145),
+    TRAPPED_CHEST(146, Chest.class),
+    GOLD_PLATE(147),
+    IRON_PLATE(148),
+    REDSTONE_COMPARATOR_OFF(149, Comparator.class),
+    REDSTONE_COMPARATOR_ON(150, Comparator.class),
+    DAYLIGHT_DETECTOR(151),
+    REDSTONE_BLOCK(152),
+    QUARTZ_ORE(153),
+    HOPPER(154, Hopper.class),
+    QUARTZ_BLOCK(155),
+    QUARTZ_STAIRS(156, Stairs.class),
+    ACTIVATOR_RAIL(157, PoweredRail.class),
+    DROPPER(158, Dispenser.class),
+    STAINED_CLAY(159),
+    STAINED_GLASS_PANE(160),
+    LEAVES_2(161, Leaves.class),
+    LOG_2(162, Tree.class),
+    ACACIA_STAIRS(163, Stairs.class),
+    DARK_OAK_STAIRS(164, Stairs.class),
+    SLIME_BLOCK(165),
+    BARRIER(166),
+    IRON_TRAPDOOR(167, TrapDoor.class),
+    PRISMARINE(168),
+    SEA_LANTERN(169),
+    HAY_BLOCK(170),
+    CARPET(171),
+    HARD_CLAY(172),
+    COAL_BLOCK(173),
+    PACKED_ICE(174),
+    DOUBLE_PLANT(175),
+    STANDING_BANNER(176, Banner.class),
+    WALL_BANNER(177, Banner.class),
+    DAYLIGHT_DETECTOR_INVERTED(178),
+    RED_SANDSTONE(179),
+    RED_SANDSTONE_STAIRS(180, Stairs.class),
+    DOUBLE_STONE_SLAB2(181),
+    STONE_SLAB2(182),
+    SPRUCE_FENCE_GATE(183, Gate.class),
+    BIRCH_FENCE_GATE(184, Gate.class),
+    JUNGLE_FENCE_GATE(185, Gate.class),
+    DARK_OAK_FENCE_GATE(186, Gate.class),
+    ACACIA_FENCE_GATE(187, Gate.class),
+    SPRUCE_FENCE(188),
+    BIRCH_FENCE(189),
+    JUNGLE_FENCE(190),
+    DARK_OAK_FENCE(191),
+    ACACIA_FENCE(192),
+    SPRUCE_DOOR(193, Door.class),
+    BIRCH_DOOR(194, Door.class),
+    JUNGLE_DOOR(195, Door.class),
+    ACACIA_DOOR(196, Door.class),
+    DARK_OAK_DOOR(197, Door.class),
+    END_ROD(198),
+    CHORUS_PLANT(199),
+    CHORUS_FLOWER(200),
+    PURPUR_BLOCK(201),
+    PURPUR_PILLAR(202),
+    PURPUR_STAIRS(203, Stairs.class),
+    PURPUR_DOUBLE_SLAB(204),
+    PURPUR_SLAB(205),
+    END_BRICKS(206),
+    BEETROOT_BLOCK(207, Crops.class),
+    GRASS_PATH(208),
+    END_GATEWAY(209),
+    COMMAND_REPEATING(210, Command.class),
+    COMMAND_CHAIN(211, Command.class),
+    FROSTED_ICE(212),
+    STRUCTURE_BLOCK(255),
+    // ----- Item Separator -----
+    IRON_SPADE(256, 1, 250),
+    IRON_PICKAXE(257, 1, 250),
+    IRON_AXE(258, 1, 250),
+    FLINT_AND_STEEL(259, 1, 64),
+    APPLE(260),
+    BOW(261, 1, 384),
+    ARROW(262),
+    COAL(263, Coal.class),
+    DIAMOND(264),
+    IRON_INGOT(265),
+    GOLD_INGOT(266),
+    IRON_SWORD(267, 1, 250),
+    WOOD_SWORD(268, 1, 59),
+    WOOD_SPADE(269, 1, 59),
+    WOOD_PICKAXE(270, 1, 59),
+    WOOD_AXE(271, 1, 59),
+    STONE_SWORD(272, 1, 131),
+    STONE_SPADE(273, 1, 131),
+    STONE_PICKAXE(274, 1, 131),
+    STONE_AXE(275, 1, 131),
+    DIAMOND_SWORD(276, 1, 1561),
+    DIAMOND_SPADE(277, 1, 1561),
+    DIAMOND_PICKAXE(278, 1, 1561),
+    DIAMOND_AXE(279, 1, 1561),
+    STICK(280),
+    BOWL(281),
+    MUSHROOM_SOUP(282, 1),
+    GOLD_SWORD(283, 1, 32),
+    GOLD_SPADE(284, 1, 32),
+    GOLD_PICKAXE(285, 1, 32),
+    GOLD_AXE(286, 1, 32),
+    STRING(287),
+    FEATHER(288),
+    SULPHUR(289),
+    WOOD_HOE(290, 1, 59),
+    STONE_HOE(291, 1, 131),
+    IRON_HOE(292, 1, 250),
+    DIAMOND_HOE(293, 1, 1561),
+    GOLD_HOE(294, 1, 32),
+    SEEDS(295),
+    WHEAT(296),
+    BREAD(297),
+    LEATHER_HELMET(298, 1, 55),
+    LEATHER_CHESTPLATE(299, 1, 80),
+    LEATHER_LEGGINGS(300, 1, 75),
+    LEATHER_BOOTS(301, 1, 65),
+    CHAINMAIL_HELMET(302, 1, 165),
+    CHAINMAIL_CHESTPLATE(303, 1, 240),
+    CHAINMAIL_LEGGINGS(304, 1, 225),
+    CHAINMAIL_BOOTS(305, 1, 195),
+    IRON_HELMET(306, 1, 165),
+    IRON_CHESTPLATE(307, 1, 240),
+    IRON_LEGGINGS(308, 1, 225),
+    IRON_BOOTS(309, 1, 195),
+    DIAMOND_HELMET(310, 1, 363),
+    DIAMOND_CHESTPLATE(311, 1, 528),
+    DIAMOND_LEGGINGS(312, 1, 495),
+    DIAMOND_BOOTS(313, 1, 429),
+    GOLD_HELMET(314, 1, 77),
+    GOLD_CHESTPLATE(315, 1, 112),
+    GOLD_LEGGINGS(316, 1, 105),
+    GOLD_BOOTS(317, 1, 91),
+    FLINT(318),
+    PORK(319),
+    GRILLED_PORK(320),
+    PAINTING(321),
+    GOLDEN_APPLE(322),
+    SIGN(323, 16),
+    WOOD_DOOR(324, 64),
+    BUCKET(325, 16),
+    WATER_BUCKET(326, 1),
+    LAVA_BUCKET(327, 1),
+    MINECART(328, 1),
+    SADDLE(329, 1),
+    IRON_DOOR(330, 64),
+    REDSTONE(331),
+    SNOW_BALL(332, 16),
+    BOAT(333, 1),
+    LEATHER(334),
+    MILK_BUCKET(335, 1),
+    CLAY_BRICK(336),
+    CLAY_BALL(337),
+    SUGAR_CANE(338),
+    PAPER(339),
+    BOOK(340),
+    SLIME_BALL(341),
+    STORAGE_MINECART(342, 1),
+    POWERED_MINECART(343, 1),
+    EGG(344, 16),
+    COMPASS(345),
+    FISHING_ROD(346, 1, 64),
+    WATCH(347),
+    GLOWSTONE_DUST(348),
+    RAW_FISH(349),
+    COOKED_FISH(350),
+    INK_SACK(351, Dye.class),
+    BONE(352),
+    SUGAR(353),
+    CAKE(354, 1),
+    BED(355, 1),
+    DIODE(356),
+    COOKIE(357),
+    /**
+     * @see MapView
+     */
+    MAP(358, MaterialData.class),
+    SHEARS(359, 1, 238),
+    MELON(360),
+    PUMPKIN_SEEDS(361),
+    MELON_SEEDS(362),
+    RAW_BEEF(363),
+    COOKED_BEEF(364),
+    RAW_CHICKEN(365),
+    COOKED_CHICKEN(366),
+    ROTTEN_FLESH(367),
+    ENDER_PEARL(368, 16),
+    BLAZE_ROD(369),
+    GHAST_TEAR(370),
+    GOLD_NUGGET(371),
+    NETHER_STALK(372),
+    POTION(373, 1, MaterialData.class),
+    GLASS_BOTTLE(374),
+    SPIDER_EYE(375),
+    FERMENTED_SPIDER_EYE(376),
+    BLAZE_POWDER(377),
+    MAGMA_CREAM(378),
+    BREWING_STAND_ITEM(379),
+    CAULDRON_ITEM(380),
+    EYE_OF_ENDER(381),
+    SPECKLED_MELON(382),
+    MONSTER_EGG(383, 64, SpawnEgg.class),
+    EXP_BOTTLE(384, 64),
+    FIREBALL(385, 64),
+    BOOK_AND_QUILL(386, 1),
+    WRITTEN_BOOK(387, 16),
+    EMERALD(388, 64),
+    ITEM_FRAME(389),
+    FLOWER_POT_ITEM(390),
+    CARROT_ITEM(391),
+    POTATO_ITEM(392),
+    BAKED_POTATO(393),
+    POISONOUS_POTATO(394),
+    EMPTY_MAP(395),
+    GOLDEN_CARROT(396),
+    SKULL_ITEM(397),
+    CARROT_STICK(398, 1, 25),
+    NETHER_STAR(399),
+    PUMPKIN_PIE(400),
+    FIREWORK(401),
+    FIREWORK_CHARGE(402),
+    ENCHANTED_BOOK(403, 1),
+    REDSTONE_COMPARATOR(404),
+    NETHER_BRICK_ITEM(405),
+    QUARTZ(406),
+    EXPLOSIVE_MINECART(407, 1),
+    HOPPER_MINECART(408, 1),
+    PRISMARINE_SHARD(409),
+    PRISMARINE_CRYSTALS(410),
+    RABBIT(411),
+    COOKED_RABBIT(412),
+    RABBIT_STEW(413, 1),
+    RABBIT_FOOT(414),
+    RABBIT_HIDE(415),
+    ARMOR_STAND(416, 16),
+    IRON_BARDING(417, 1),
+    GOLD_BARDING(418, 1),
+    DIAMOND_BARDING(419, 1),
+    LEASH(420),
+    NAME_TAG(421),
+    COMMAND_MINECART(422, 1),
+    MUTTON(423),
+    COOKED_MUTTON(424),
+    BANNER(425, 16),
+    END_CRYSTAL(426),
+    SPRUCE_DOOR_ITEM(427),
+    BIRCH_DOOR_ITEM(428),
+    JUNGLE_DOOR_ITEM(429),
+    ACACIA_DOOR_ITEM(430),
+    DARK_OAK_DOOR_ITEM(431),
+    CHORUS_FRUIT(432),
+    CHORUS_FRUIT_POPPED(433),
+    BEETROOT(434),
+    BEETROOT_SEEDS(435),
+    BEETROOT_SOUP(436, 1),
+    DRAGONS_BREATH(437),
+    SPLASH_POTION(438, 1),
+    SPECTRAL_ARROW(439),
+    TIPPED_ARROW(440),
+    LINGERING_POTION(441, 1),
+    SHIELD(442, 1, 336),
+    ELYTRA(443, 1, 431),
+    BOAT_SPRUCE(444, 1),
+    BOAT_BIRCH(445, 1),
+    BOAT_JUNGLE(446, 1),
+    BOAT_ACACIA(447, 1),
+    BOAT_DARK_OAK(448, 1),
+    GOLD_RECORD(2256, 1),
+    GREEN_RECORD(2257, 1),
+    RECORD_3(2258, 1),
+    RECORD_4(2259, 1),
+    RECORD_5(2260, 1),
+    RECORD_6(2261, 1),
+    RECORD_7(2262, 1),
+    RECORD_8(2263, 1),
+    RECORD_9(2264, 1),
+    RECORD_10(2265, 1),
+    RECORD_11(2266, 1),
+    RECORD_12(2267, 1),
+    ;
+
+    private final int id;
+    private final Constructor<? extends MaterialData> ctor;
+    private static Material[] byId = new Material[383];
+    private final static Map<String, Material> BY_NAME = Maps.newHashMap();
+    private final int maxStack;
+    private final short durability;
+
+    private Material(final int id) {
+        this(id, 64);
+    }
+
+    private Material(final int id, final int stack) {
+        this(id, stack, MaterialData.class);
+    }
+
+    private Material(final int id, final int stack, final int durability) {
+        this(id, stack, durability, MaterialData.class);
+    }
+
+    private Material(final int id, final Class<? extends MaterialData> data) {
+        this(id, 64, data);
+    }
+
+    private Material(final int id, final int stack, final Class<? extends MaterialData> data) {
+        this(id, stack, 0, data);
+    }
+
+    private Material(final int id, final int stack, final int durability, final Class<? extends MaterialData> data) {
+        this.id = id;
+        this.durability = (short) durability;
+        this.maxStack = stack;
+        // try to cache the constructor for this material
+        try {
+            this.ctor = data.getConstructor(int.class, byte.class);
+        } catch (NoSuchMethodException ex) {
+            throw new AssertionError(ex);
+        } catch (SecurityException ex) {
+            throw new AssertionError(ex);
+        }
+    }
+
+    /**
+     * Gets the item ID or block ID of this Material
+     *
+     * @return ID of this material
+     * @deprecated Magic value
+     */
+    @Deprecated
+    public int getId() {
+        return id;
+    }
+
+    /**
+     * Gets the maximum amount of this material that can be held in a stack
+     *
+     * @return Maximum stack size for this material
+     */
+    public int getMaxStackSize() {
+        return maxStack;
+    }
+
+    /**
+     * Gets the maximum durability of this material
+     *
+     * @return Maximum durability for this material
+     */
+    public short getMaxDurability() {
+        return durability;
+    }
+
+    /**
+     * Gets the MaterialData class associated with this Material
+     *
+     * @return MaterialData associated with this Material
+     */
+    public Class<? extends MaterialData> getData() {
+        return ctor.getDeclaringClass();
+    }
+
+    /**
+     * Constructs a new MaterialData relevant for this Material, with the
+     * given initial data
+     *
+     * @param raw Initial data to construct the MaterialData with
+     * @return New MaterialData with the given data
+     * @deprecated Magic value
+     */
+    @Deprecated
+    public MaterialData getNewData(final byte raw) {
+        try {
+            return ctor.newInstance(id, raw);
+        } catch (InstantiationException ex) {
+            final Throwable t = ex.getCause();
+            if (t instanceof RuntimeException) {
+                throw (RuntimeException) t;
+            }
+            if (t instanceof Error) {
+                throw (Error) t;
+            }
+            throw new AssertionError(t);
+        } catch (Throwable t) {
+            throw new AssertionError(t);
+        }
+    }
+
+    /**
+     * Checks if this Material is a placable block
+     *
+     * @return true if this material is a block
+     */
+    public boolean isBlock() {
+        return id < 256;
+    }
+
+    /**
+     * Checks if this Material is edible.
+     *
+     * @return true if this Material is edible.
+     */
+    public boolean isEdible() {
+        switch (this) {
+            case BREAD:
+            case CARROT_ITEM:
+            case BAKED_POTATO:
+            case POTATO_ITEM:
+            case POISONOUS_POTATO:
+            case GOLDEN_CARROT:
+            case PUMPKIN_PIE:
+            case COOKIE:
+            case MELON:
+            case MUSHROOM_SOUP:
+            case RAW_CHICKEN:
+            case COOKED_CHICKEN:
+            case RAW_BEEF:
+            case COOKED_BEEF:
+            case RAW_FISH:
+            case COOKED_FISH:
+            case PORK:
+            case GRILLED_PORK:
+            case APPLE:
+            case GOLDEN_APPLE:
+            case ROTTEN_FLESH:
+            case SPIDER_EYE:
+            case RABBIT:
+            case COOKED_RABBIT:
+            case RABBIT_STEW:
+            case MUTTON:
+            case COOKED_MUTTON:
+            case BEETROOT:
+            case CHORUS_FRUIT:
+            case BEETROOT_SOUP:
+                return true;
+            default:
+                return false;
+        }
+    }
+
+    /**
+     * Attempts to get the Material with the given ID
+     *
+     * @param id ID of the material to get
+     * @return Material if found, or null
+     * @deprecated Magic value
+     */
+    @Deprecated
+    public static Material getMaterial(final int id) {
+        if (byId.length > id && id >= 0) {
+            return byId[id];
+        } else {
+            return null;
+        }
+    }
+
+    /**
+     * Attempts to get the Material with the given name.
+     * <p>
+     * This is a normal lookup, names must be the precise name they are given
+     * in the enum.
+     *
+     * @param name Name of the material to get
+     * @return Material if found, or null
+     */
+    public static Material getMaterial(final String name) {
+        return BY_NAME.get(name);
+    }
+
+    /**
+     * Attempts to match the Material with the given name.
+     * <p>
+     * This is a match lookup; names will be converted to uppercase, then
+     * stripped of special characters in an attempt to format it like the
+     * enum.
+     * <p>
+     * Using this for match by ID is deprecated.
+     *
+     * @param name Name of the material to get
+     * @return Material if found, or null
+     */
+    public static Material matchMaterial(final String name) {
+        Validate.notNull(name, "Name cannot be null");
+
+        Material result = null;
+
+        try {
+            result = getMaterial(Integer.parseInt(name));
+        } catch (NumberFormatException ex) {}
+
+        if (result == null) {
+            String filtered = name.toUpperCase();
+
+            filtered = filtered.replaceAll("\\s+", "_").replaceAll("\\W", "");
+            result = BY_NAME.get(filtered);
+        }
+
+        return result;
+    }
+
+    static {
+        for (Material material : values()) {
+            if (byId.length > material.id) {
+                byId[material.id] = material;
+            } else {
+                byId = Java15Compat.Arrays_copyOfRange(byId, 0, material.id + 2);
+                byId[material.id] = material;
+            }
+            BY_NAME.put(material.name(), material);
+        }
+    }
+
+    /**
+     * @return True if this material represents a playable music disk.
+     */
+    public boolean isRecord() {
+        return id >= GOLD_RECORD.id && id <= RECORD_12.id;
+    }
+
+    /**
+     * Check if the material is a block and solid (cannot be passed through by
+     * a player)
+     *
+     * @return True if this material is a block and solid
+     */
+    public boolean isSolid() {
+        if (!isBlock() || id == 0) {
+            return false;
+        }
+        switch (this) {
+            case STONE:
+            case GRASS:
+            case DIRT:
+            case COBBLESTONE:
+            case WOOD:
+            case BEDROCK:
+            case SAND:
+            case GRAVEL:
+            case GOLD_ORE:
+            case IRON_ORE:
+            case COAL_ORE:
+            case LOG:
+            case LEAVES:
+            case SPONGE:
+            case GLASS:
+            case LAPIS_ORE:
+            case LAPIS_BLOCK:
+            case DISPENSER:
+            case SANDSTONE:
+            case NOTE_BLOCK:
+            case BED_BLOCK:
+            case PISTON_STICKY_BASE:
+            case PISTON_BASE:
+            case PISTON_EXTENSION:
+            case WOOL:
+            case PISTON_MOVING_PIECE:
+            case GOLD_BLOCK:
+            case IRON_BLOCK:
+            case DOUBLE_STEP:
+            case STEP:
+            case BRICK:
+            case TNT:
+            case BOOKSHELF:
+            case MOSSY_COBBLESTONE:
+            case OBSIDIAN:
+            case MOB_SPAWNER:
+            case WOOD_STAIRS:
+            case CHEST:
+            case DIAMOND_ORE:
+            case DIAMOND_BLOCK:
+            case WORKBENCH:
+            case SOIL:
+            case FURNACE:
+            case BURNING_FURNACE:
+            case SIGN_POST:
+            case WOODEN_DOOR:
+            case COBBLESTONE_STAIRS:
+            case WALL_SIGN:
+            case STONE_PLATE:
+            case IRON_DOOR_BLOCK:
+            case WOOD_PLATE:
+            case REDSTONE_ORE:
+            case GLOWING_REDSTONE_ORE:
+            case ICE:
+            case SNOW_BLOCK:
+            case CACTUS:
+            case CLAY:
+            case JUKEBOX:
+            case FENCE:
+            case PUMPKIN:
+            case NETHERRACK:
+            case SOUL_SAND:
+            case GLOWSTONE:
+            case JACK_O_LANTERN:
+            case CAKE_BLOCK:
+            case STAINED_GLASS:
+            case TRAP_DOOR:
+            case MONSTER_EGGS:
+            case SMOOTH_BRICK:
+            case HUGE_MUSHROOM_1:
+            case HUGE_MUSHROOM_2:
+            case IRON_FENCE:
+            case THIN_GLASS:
+            case MELON_BLOCK:
+            case FENCE_GATE:
+            case BRICK_STAIRS:
+            case SMOOTH_STAIRS:
+            case MYCEL:
+            case NETHER_BRICK:
+            case NETHER_FENCE:
+            case NETHER_BRICK_STAIRS:
+            case ENCHANTMENT_TABLE:
+            case BREWING_STAND:
+            case CAULDRON:
+            case ENDER_PORTAL_FRAME:
+            case ENDER_STONE:
+            case DRAGON_EGG:
+            case REDSTONE_LAMP_OFF:
+            case REDSTONE_LAMP_ON:
+            case WOOD_DOUBLE_STEP:
+            case WOOD_STEP:
+            case SANDSTONE_STAIRS:
+            case EMERALD_ORE:
+            case ENDER_CHEST:
+            case EMERALD_BLOCK:
+            case SPRUCE_WOOD_STAIRS:
+            case BIRCH_WOOD_STAIRS:
+            case JUNGLE_WOOD_STAIRS:
+            case COMMAND:
+            case BEACON:
+            case COBBLE_WALL:
+            case ANVIL:
+            case TRAPPED_CHEST:
+            case GOLD_PLATE:
+            case IRON_PLATE:
+            case DAYLIGHT_DETECTOR:
+            case REDSTONE_BLOCK:
+            case QUARTZ_ORE:
+            case HOPPER:
+            case QUARTZ_BLOCK:
+            case QUARTZ_STAIRS:
+            case DROPPER:
+            case STAINED_CLAY:
+            case HAY_BLOCK:
+            case HARD_CLAY:
+            case COAL_BLOCK:
+            case STAINED_GLASS_PANE:
+            case LEAVES_2:
+            case LOG_2:
+            case ACACIA_STAIRS:
+            case DARK_OAK_STAIRS:
+            case PACKED_ICE:
+            case RED_SANDSTONE:
+            case SLIME_BLOCK:
+            case BARRIER:
+            case IRON_TRAPDOOR:
+            case PRISMARINE:
+            case SEA_LANTERN:
+            case DOUBLE_STONE_SLAB2:
+            case RED_SANDSTONE_STAIRS:
+            case STONE_SLAB2:
+            case SPRUCE_FENCE_GATE:
+            case BIRCH_FENCE_GATE:
+            case JUNGLE_FENCE_GATE:
+            case DARK_OAK_FENCE_GATE:
+            case ACACIA_FENCE_GATE:
+            case SPRUCE_FENCE:
+            case BIRCH_FENCE:
+            case JUNGLE_FENCE:
+            case DARK_OAK_FENCE:
+            case ACACIA_FENCE:
+            case STANDING_BANNER:
+            case WALL_BANNER:
+            case DAYLIGHT_DETECTOR_INVERTED:
+            case SPRUCE_DOOR:
+            case BIRCH_DOOR:
+            case JUNGLE_DOOR:
+            case ACACIA_DOOR:
+            case DARK_OAK_DOOR:
+            case PURPUR_BLOCK:
+            case PURPUR_PILLAR:
+            case PURPUR_STAIRS:
+            case PURPUR_DOUBLE_SLAB:
+            case PURPUR_SLAB:
+            case END_BRICKS:
+            case GRASS_PATH:
+            case STRUCTURE_BLOCK:
+            case COMMAND_REPEATING:
+            case COMMAND_CHAIN:
+            case FROSTED_ICE:
+                return true;
+            default:
+                return false;
+        }
+    }
+
+    /**
+     * Check if the material is a block and does not block any light
+     *
+     * @return True if this material is a block and does not block any light
+     */
+    public boolean isTransparent() {
+        if (!isBlock()) {
+            return false;
+        }
+        switch (this) {
+            case AIR:
+            case SAPLING:
+            case POWERED_RAIL:
+            case DETECTOR_RAIL:
+            case LONG_GRASS:
+            case DEAD_BUSH:
+            case YELLOW_FLOWER:
+            case RED_ROSE:
+            case BROWN_MUSHROOM:
+            case RED_MUSHROOM:
+            case TORCH:
+            case FIRE:
+            case REDSTONE_WIRE:
+            case CROPS:
+            case LADDER:
+            case RAILS:
+            case LEVER:
+            case REDSTONE_TORCH_OFF:
+            case REDSTONE_TORCH_ON:
+            case STONE_BUTTON:
+            case SNOW:
+            case SUGAR_CANE_BLOCK:
+            case PORTAL:
+            case DIODE_BLOCK_OFF:
+            case DIODE_BLOCK_ON:
+            case PUMPKIN_STEM:
+            case MELON_STEM:
+            case VINE:
+            case WATER_LILY:
+            case NETHER_WARTS:
+            case ENDER_PORTAL:
+            case COCOA:
+            case TRIPWIRE_HOOK:
+            case TRIPWIRE:
+            case FLOWER_POT:
+            case CARROT:
+            case POTATO:
+            case WOOD_BUTTON:
+            case SKULL:
+            case REDSTONE_COMPARATOR_OFF:
+            case REDSTONE_COMPARATOR_ON:
+            case ACTIVATOR_RAIL:
+            case CARPET:
+            case DOUBLE_PLANT:
+            case END_ROD:
+            case CHORUS_PLANT:
+            case CHORUS_FLOWER:
+            case BEETROOT_BLOCK:
+            case END_GATEWAY:
+                return true;
+            default:
+                return false;
+        }
+    }
+
+    /**
+     * Check if the material is a block and can catch fire
+     *
+     * @return True if this material is a block and can catch fire
+     */
+    public boolean isFlammable() {
+        if (!isBlock()) {
+            return false;
+        }
+        switch (this) {
+            case WOOD:
+            case LOG:
+            case LEAVES:
+            case NOTE_BLOCK:
+            case BED_BLOCK:
+            case LONG_GRASS:
+            case DEAD_BUSH:
+            case WOOL:
+            case TNT:
+            case BOOKSHELF:
+            case WOOD_STAIRS:
+            case CHEST:
+            case WORKBENCH:
+            case SIGN_POST:
+            case WOODEN_DOOR:
+            case WALL_SIGN:
+            case WOOD_PLATE:
+            case JUKEBOX:
+            case FENCE:
+            case TRAP_DOOR:
+            case HUGE_MUSHROOM_1:
+            case HUGE_MUSHROOM_2:
+            case VINE:
+            case FENCE_GATE:
+            case WOOD_DOUBLE_STEP:
+            case WOOD_STEP:
+            case SPRUCE_WOOD_STAIRS:
+            case BIRCH_WOOD_STAIRS:
+            case JUNGLE_WOOD_STAIRS:
+            case TRAPPED_CHEST:
+            case DAYLIGHT_DETECTOR:
+            case CARPET:
+            case LEAVES_2:
+            case LOG_2:
+            case ACACIA_STAIRS:
+            case DARK_OAK_STAIRS:
+            case DOUBLE_PLANT:
+            case SPRUCE_FENCE_GATE:
+            case BIRCH_FENCE_GATE:
+            case JUNGLE_FENCE_GATE:
+            case DARK_OAK_FENCE_GATE:
+            case ACACIA_FENCE_GATE:
+            case SPRUCE_FENCE:
+            case BIRCH_FENCE:
+            case JUNGLE_FENCE:
+            case DARK_OAK_FENCE:
+            case ACACIA_FENCE:
+            case STANDING_BANNER:
+            case WALL_BANNER:
+            case DAYLIGHT_DETECTOR_INVERTED:
+            case SPRUCE_DOOR:
+            case BIRCH_DOOR:
+            case JUNGLE_DOOR:
+            case ACACIA_DOOR:
+            case DARK_OAK_DOOR:
+                return true;
+            default:
+                return false;
+        }
+    }
+
+    /**
+     * Check if the material is a block and can burn away
+     *
+     * @return True if this material is a block and can burn away
+     */
+    public boolean isBurnable() {
+        if (!isBlock()) {
+            return false;
+        }
+        switch (this) {
+            case WOOD:
+            case LOG:
+            case LEAVES:
+            case LONG_GRASS:
+            case WOOL:
+            case YELLOW_FLOWER:
+            case RED_ROSE:
+            case TNT:
+            case BOOKSHELF:
+            case WOOD_STAIRS:
+            case FENCE:
+            case VINE:
+            case WOOD_DOUBLE_STEP:
+            case WOOD_STEP:
+            case SPRUCE_WOOD_STAIRS:
+            case BIRCH_WOOD_STAIRS:
+            case JUNGLE_WOOD_STAIRS:
+            case HAY_BLOCK:
+            case COAL_BLOCK:
+            case LEAVES_2:
+            case LOG_2:
+            case CARPET:
+            case DOUBLE_PLANT:
+            case DEAD_BUSH:
+            case FENCE_GATE:
+            case SPRUCE_FENCE_GATE:
+            case BIRCH_FENCE_GATE:
+            case JUNGLE_FENCE_GATE:
+            case DARK_OAK_FENCE_GATE:
+            case ACACIA_FENCE_GATE:
+            case SPRUCE_FENCE:
+            case BIRCH_FENCE:
+            case JUNGLE_FENCE:
+            case DARK_OAK_FENCE:
+            case ACACIA_FENCE:
+            case ACACIA_STAIRS:
+            case DARK_OAK_STAIRS:
+                return true;
+            default:
+                return false;
+        }
+    }
+
+    /**
+     * Check if the material is a block and completely blocks vision
+     *
+     * @return True if this material is a block and completely blocks vision
+     */
+    public boolean isOccluding() {
+        if (!isBlock()) {
+            return false;
+        }
+        switch (this) {
+            case STONE:
+            case GRASS:
+            case DIRT:
+            case COBBLESTONE:
+            case WOOD:
+            case BEDROCK:
+            case SAND:
+            case GRAVEL:
+            case GOLD_ORE:
+            case IRON_ORE:
+            case COAL_ORE:
+            case LOG:
+            case SPONGE:
+            case LAPIS_ORE:
+            case LAPIS_BLOCK:
+            case DISPENSER:
+            case SANDSTONE:
+            case NOTE_BLOCK:
+            case WOOL:
+            case GOLD_BLOCK:
+            case IRON_BLOCK:
+            case DOUBLE_STEP:
+            case BRICK:
+            case BOOKSHELF:
+            case MOSSY_COBBLESTONE:
+            case OBSIDIAN:
+            case MOB_SPAWNER:
+            case DIAMOND_ORE:
+            case DIAMOND_BLOCK:
+            case WORKBENCH:
+            case FURNACE:
+            case BURNING_FURNACE:
+            case REDSTONE_ORE:
+            case GLOWING_REDSTONE_ORE:
+            case SNOW_BLOCK:
+            case CLAY:
+            case JUKEBOX:
+            case PUMPKIN:
+            case NETHERRACK:
+            case SOUL_SAND:
+            case JACK_O_LANTERN:
+            case MONSTER_EGGS:
+            case SMOOTH_BRICK:
+            case HUGE_MUSHROOM_1:
+            case HUGE_MUSHROOM_2:
+            case MELON_BLOCK:
+            case MYCEL:
+            case NETHER_BRICK:
+            case ENDER_STONE:
+            case REDSTONE_LAMP_OFF:
+            case REDSTONE_LAMP_ON:
+            case WOOD_DOUBLE_STEP:
+            case EMERALD_ORE:
+            case EMERALD_BLOCK:
+            case COMMAND:
+            case QUARTZ_ORE:
+            case QUARTZ_BLOCK:
+            case DROPPER:
+            case STAINED_CLAY:
+            case HAY_BLOCK:
+            case HARD_CLAY:
+            case COAL_BLOCK:
+            case LOG_2:
+            case PACKED_ICE:
+            case SLIME_BLOCK:
+            case BARRIER:
+            case PRISMARINE:
+            case RED_SANDSTONE:
+            case DOUBLE_STONE_SLAB2:
+            case PURPUR_BLOCK:
+            case PURPUR_PILLAR:
+            case PURPUR_DOUBLE_SLAB:
+            case END_BRICKS:
+            case STRUCTURE_BLOCK:
+            case COMMAND_REPEATING:
+            case COMMAND_CHAIN:
+                return true;
+            default:
+                return false;
+        }
+    }
+
+    /**
+     * @return True if this material is affected by gravity.
+     */
+    public boolean hasGravity() {
+        if (!isBlock()) {
+            return false;
+        }
+        switch (this) {
+            case SAND:
+            case GRAVEL:
+            case ANVIL:
+                return true;
+            default:
+                return false;
+        }
+    }
+}
diff --git a/src/main/java/org/bukkit/Note.java b/src/main/java/org/bukkit/Note.java
new file mode 100644
index 0000000..0884156
--- /dev/null
+++ b/src/main/java/org/bukkit/Note.java
@@ -0,0 +1,276 @@
+package org.bukkit;
+
+import java.util.Map;
+
+import org.apache.commons.lang3.Validate;
+
+import com.google.common.collect.Maps;
+
+/**
+ * A note class to store a specific note.
+ */
+public class Note {
+
+    /**
+     * An enum holding tones.
+     */
+    public enum Tone {
+        G(0x1, true),
+        A(0x3, true),
+        B(0x5, false),
+        C(0x6, true),
+        D(0x8, true),
+        E(0xA, false),
+        F(0xB, true);
+
+        private final boolean sharpable;
+        private final byte id;
+
+        private static final Map<Byte, Note.Tone> BY_DATA = Maps.newHashMap();
+        /** The number of tones including sharped tones. */
+        public static final byte TONES_COUNT = 12;
+
+        private Tone(int id, boolean sharpable) {
+            this.id = (byte) (id % TONES_COUNT);
+            this.sharpable = sharpable;
+        }
+
+        /**
+         * Returns the not sharped id of this tone.
+         *
+         * @return the not sharped id of this tone.
+         * @deprecated Magic value
+         */
+        @Deprecated
+        public byte getId() {
+            return getId(false);
+        }
+
+        /**
+         * Returns the id of this tone. These method allows to return the
+         * sharped id of the tone. If the tone couldn't be sharped it always
+         * return the not sharped id of this tone.
+         *
+         * @param sharped Set to true to return the sharped id.
+         * @return the id of this tone.
+         * @deprecated Magic value
+         */
+        @Deprecated
+        public byte getId(boolean sharped) {
+            byte id = (byte) (sharped && sharpable ? this.id + 1 : this.id);
+
+            return (byte) (id % TONES_COUNT);
+        }
+
+        /**
+         * Returns if this tone could be sharped.
+         *
+         * @return if this tone could be sharped.
+         */
+        public boolean isSharpable() {
+            return sharpable;
+        }
+
+        /**
+         * Returns if this tone id is the sharped id of the tone.
+         *
+         * @param id the id of the tone.
+         * @return if the tone id is the sharped id of the tone.
+         * @throws IllegalArgumentException if neither the tone nor the
+         *     semitone have the id.
+         * @deprecated Magic value
+         */
+        @Deprecated
+        public boolean isSharped(byte id) {
+            if (id == getId(false)) {
+                return false;
+            } else if (id == getId(true)) {
+                return true;
+            } else {
+                // The id isn't matching to the tone!
+                throw new IllegalArgumentException("The id isn't matching to the tone.");
+            }
+        }
+
+        /**
+         * Returns the tone to id. Also returning the semitones.
+         *
+         * @param id the id of the tone.
+         * @return the tone to id.
+         * @deprecated Magic value
+         */
+        @Deprecated
+        public static Tone getById(byte id) {
+            return BY_DATA.get(id);
+        }
+
+        static {
+            for (Tone tone : values()) {
+                int id = tone.id % TONES_COUNT;
+                BY_DATA.put((byte) id, tone);
+
+                if (tone.isSharpable()) {
+                    id = (id + 1) % TONES_COUNT;
+                    BY_DATA.put((byte) id, tone);
+                }
+            }
+        }
+    }
+
+    private final byte note;
+
+    /**
+     * Creates a new note.
+     *
+     * @param note Internal note id. {@link #getId()} always return this
+     *     value. The value has to be in the interval [0;&nbsp;24].
+     */
+    public Note(int note) {
+        Validate.isTrue(note >= 0 && note <= 24, "The note value has to be between 0 and 24.");
+
+        this.note = (byte) note;
+    }
+
+    /**
+     * Creates a new note.
+     *
+     * @param octave The octave where the note is in. Has to be 0 - 2.
+     * @param tone The tone within the octave. If the octave is 2 the note has
+     *     to be F#.
+     * @param sharped Set if the tone is sharped (e.g. for F#).
+     */
+    public Note(int octave, Tone tone, boolean sharped) {
+        if (sharped && !tone.isSharpable()) {
+            tone = Tone.values()[tone.ordinal() + 1];
+            sharped = false;
+        }
+        if (octave < 0 || octave > 2 || (octave == 2 && !(tone == Tone.F && sharped))) {
+            throw new IllegalArgumentException("Tone and octave have to be between F#0 and F#2");
+        }
+
+        this.note = (byte) (octave * Tone.TONES_COUNT + tone.getId(sharped));
+    }
+
+    /**
+     * Creates a new note for a flat tone, such as A-flat.
+     *
+     * @param octave The octave where the note is in. Has to be 0 - 1.
+     * @param tone The tone within the octave.
+     * @return The new note.
+     */
+    public static Note flat(int octave, Tone tone) {
+        Validate.isTrue(octave != 2, "Octave cannot be 2 for flats");
+        tone = tone == Tone.G ? Tone.F : Tone.values()[tone.ordinal() - 1];
+        return new Note(octave, tone, tone.isSharpable());
+    }
+
+    /**
+     * Creates a new note for a sharp tone, such as A-sharp.
+     *
+     * @param octave The octave where the note is in. Has to be 0 - 2.
+     * @param tone The tone within the octave. If the octave is 2 the note has
+     *     to be F#.
+     * @return The new note.
+     */
+    public static Note sharp(int octave, Tone tone) {
+        return new Note(octave, tone, true);
+    }
+
+    /**
+     * Creates a new note for a natural tone, such as A-natural.
+     *
+     * @param octave The octave where the note is in. Has to be 0 - 1.
+     * @param tone The tone within the octave.
+     * @return The new note.
+     */
+    public static Note natural(int octave, Tone tone) {
+        Validate.isTrue(octave != 2, "Octave cannot be 2 for naturals");
+        return new Note(octave, tone, false);
+    }
+
+    /**
+     * @return The note a semitone above this one.
+     */
+    public Note sharped() {
+        Validate.isTrue(note < 24, "This note cannot be sharped because it is the highest known note!");
+        return new Note(note + 1);
+    }
+
+    /**
+     * @return The note a semitone below this one.
+     */
+    public Note flattened() {
+        Validate.isTrue(note > 0, "This note cannot be flattened because it is the lowest known note!");
+        return new Note(note - 1);
+    }
+
+    /**
+     * Returns the internal id of this note.
+     *
+     * @return the internal id of this note.
+     * @deprecated Magic value
+     */
+    @Deprecated
+    public byte getId() {
+        return note;
+    }
+
+    /**
+     * Returns the octave of this note.
+     *
+     * @return the octave of this note.
+     */
+    public int getOctave() {
+        return note / Tone.TONES_COUNT;
+    }
+
+    private byte getToneByte() {
+        return (byte) (note % Tone.TONES_COUNT);
+    }
+
+    /**
+     * Returns the tone of this note.
+     *
+     * @return the tone of this note.
+     */
+    public Tone getTone() {
+        return Tone.getById(getToneByte());
+    }
+
+    /**
+     * Returns if this note is sharped.
+     *
+     * @return if this note is sharped.
+     */
+    public boolean isSharped() {
+        byte note = getToneByte();
+        return Tone.getById(note).isSharped(note);
+    }
+
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int result = 1;
+        result = prime * result + note;
+        return result;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj)
+            return true;
+        if (obj == null)
+            return false;
+        if (getClass() != obj.getClass())
+            return false;
+        Note other = (Note) obj;
+        if (note != other.note)
+            return false;
+        return true;
+    }
+
+    @Override
+    public String toString() {
+        return "Note{" + getTone().toString() + (isSharped() ? "#" : "") + "}";
+    }
+}
diff --git a/src/main/java/org/bukkit/Particle.java b/src/main/java/org/bukkit/Particle.java
deleted file mode 100644
index af491f3..0000000
--- a/src/main/java/org/bukkit/Particle.java
+++ /dev/null
@@ -1,71 +0,0 @@
-package org.bukkit;
-
-import org.bukkit.inventory.ItemStack;
-import org.bukkit.material.MaterialData;
-
-public enum Particle {
-    EXPLOSION_NORMAL,
-    EXPLOSION_LARGE,
-    EXPLOSION_HUGE,
-    FIREWORKS_SPARK,
-    WATER_BUBBLE,
-    WATER_SPLASH,
-    WATER_WAKE,
-    SUSPENDED,
-    SUSPENDED_DEPTH,
-    CRIT,
-    CRIT_MAGIC,
-    SMOKE_NORMAL,
-    SMOKE_LARGE,
-    SPELL,
-    SPELL_INSTANT,
-    SPELL_MOB,
-    SPELL_MOB_AMBIENT,
-    SPELL_WITCH,
-    DRIP_WATER,
-    DRIP_LAVA,
-    VILLAGER_ANGRY,
-    VILLAGER_HAPPY,
-    TOWN_AURA,
-    NOTE,
-    PORTAL,
-    ENCHANTMENT_TABLE,
-    FLAME,
-    LAVA,
-    FOOTSTEP,
-    CLOUD,
-    REDSTONE,
-    SNOWBALL,
-    SNOW_SHOVEL,
-    SLIME,
-    HEART,
-    BARRIER,
-    ITEM_CRACK(ItemStack.class),
-    BLOCK_CRACK(MaterialData.class),
-    BLOCK_DUST(MaterialData.class),
-    WATER_DROP,
-    ITEM_TAKE,
-    MOB_APPEARANCE,
-    DRAGON_BREATH,
-    END_ROD,
-    DAMAGE_INDICATOR,
-    SWEEP_ATTACK;
-
-    private final Class<?> dataType;
-
-    Particle() {
-        dataType = Void.class;
-    }
-
-    Particle(Class<?> data) {
-        dataType = data;
-    }
-
-    /**
-     * Returns the required data type for the particle
-     * @return the required data type
-     */
-    public Class<?> getDataType() {
-        return dataType;
-    }
-}
diff --git a/src/main/java/org/bukkit/attribute/AttributeModifier.java b/src/main/java/org/bukkit/attribute/AttributeModifier.java
new file mode 100644
index 0000000..3631459
--- /dev/null
+++ b/src/main/java/org/bukkit/attribute/AttributeModifier.java
@@ -0,0 +1,103 @@
+package org.bukkit.attribute;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.UUID;
+import org.apache.commons.lang3.Validate;
+import org.bukkit.configuration.serialization.ConfigurationSerializable;
+import org.bukkit.util.NumberConversions;
+
+/**
+ * Concrete implementation of an attribute modifier.
+ */
+public class AttributeModifier implements ConfigurationSerializable {
+
+    private final UUID uuid;
+    private final String name;
+    private final double amount;
+    private final Operation operation;
+
+    public AttributeModifier(String name, double amount, Operation operation) {
+        this(UUID.randomUUID(), name, amount, operation);
+    }
+
+    public AttributeModifier(UUID uuid, String name, double amount, Operation operation) {
+        Validate.notNull(uuid, "uuid");
+        Validate.notEmpty(name, "Name cannot be empty");
+        Validate.notNull(operation, "operation");
+
+        this.uuid = uuid;
+        this.name = name;
+        this.amount = amount;
+        this.operation = operation;
+    }
+
+    /**
+     * Get the unique ID for this modifier.
+     *
+     * @return unique id
+     */
+    public UUID getUniqueId() {
+        return uuid;
+    }
+
+    /**
+     * Get the name of this modifier.
+     *
+     * @return name
+     */
+    public String getName() {
+        return name;
+    }
+
+    /**
+     * Get the amount by which this modifier will apply its {@link Operation}.
+     *
+     * @return modification amount
+     */
+    public double getAmount() {
+        return amount;
+    }
+
+    /**
+     * Get the operation this modifier will apply.
+     *
+     * @return operation
+     */
+    public Operation getOperation() {
+        return operation;
+    }
+
+    @Override
+    public Map<String, Object> serialize() {
+        Map<String, Object> data = new HashMap<String, Object>();
+        data.put("uuid", uuid);
+        data.put("name", name);
+        data.put("operation", operation.ordinal());
+        data.put("amount", amount);
+        return data;
+    }
+
+    public static AttributeModifier deserialize(Map<String, Object> args) {
+        return new AttributeModifier((UUID) args.get("uuid"), (String) args.get("name"), NumberConversions.toDouble(args.get("amount")), Operation.values()[NumberConversions.toInt(args.get("operation"))]);
+    }
+
+    /**
+     * Enumerable operation to be applied.
+     */
+    public enum Operation {
+
+        /**
+         * Adds (or subtracts) the specified amount to the base value.
+         */
+        ADD_NUMBER,
+        /**
+         * Adds this scalar of amount to the base value.
+         */
+        ADD_SCALAR,
+        /**
+         * Multiply amount by this value, after adding 1 to it.
+         */
+        MULTIPLY_SCALAR_1;
+    }
+}
diff --git a/src/main/java/org/bukkit/command/Command.java b/src/main/java/org/bukkit/command/Command.java
new file mode 100644
index 0000000..966d4f3
--- /dev/null
+++ b/src/main/java/org/bukkit/command/Command.java
@@ -0,0 +1,451 @@
+package org.bukkit.command;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Set;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.Bukkit;
+import org.bukkit.ChatColor;
+import org.bukkit.Location;
+import org.bukkit.Server;
+import org.bukkit.entity.Player;
+import org.bukkit.entity.minecart.CommandMinecart;
+import org.bukkit.permissions.Permissible;
+import org.bukkit.plugin.PluginDescriptionFile;
+import org.bukkit.util.StringUtil;
+
+import com.google.common.collect.ImmutableList;
+
+/**
+ * Represents a Command, which executes various tasks upon user input
+ */
+public abstract class Command {
+    private String name;
+    private String nextLabel;
+    private String label;
+    private List<String> aliases;
+    private List<String> activeAliases;
+    private CommandMap commandMap = null;
+    protected String description = "";
+    protected String usageMessage;
+    private String permission;
+    private String permissionMessage;
+    public co.aikar.timings.Timing timings; // Spigot
+    public String getTimingName() {return getName();} // Spigot
+
+    protected Command(String name) {
+        this(name, "", "/" + name, new ArrayList<String>());
+    }
+
+    protected Command(String name, String description, String usageMessage, List<String> aliases) {
+        this.name = name;
+        this.nextLabel = name;
+        this.label = name;
+        this.description = description;
+        this.usageMessage = usageMessage;
+        this.aliases = aliases;
+        this.activeAliases = new ArrayList<String>(aliases);
+    }
+
+    /**
+     * Executes the command, returning its success
+     *
+     * @param sender Source object which is executing this command
+     * @param commandLabel The alias of the command used
+     * @param args All arguments passed to the command, split via ' '
+     * @return true if the command was successful, otherwise false
+     */
+    public abstract boolean execute(CommandSender sender, String commandLabel, String[] args);
+
+    /**
+     * Executed on tab completion for this command, returning a list of
+     * options the player can tab through.
+     *
+     * @deprecated This method is not supported and returns null
+     * @param sender Source object which is executing this command
+     * @param args All arguments passed to the command, split via ' '
+     * @return a list of tab-completions for the specified arguments. This
+     *     will never be null. List may be immutable.
+     */
+    @Deprecated
+    public List<String> tabComplete(CommandSender sender, String[] args) {
+        return null;
+    }
+
+    /**
+     * Executed on tab completion for this command, returning a list of
+     * options the player can tab through.
+     *
+     * @param sender Source object which is executing this command
+     * @param alias the alias being used
+     * @param args All arguments passed to the command, split via ' '
+     * @return a list of tab-completions for the specified arguments. This
+     *     will never be null. List may be immutable.
+     * @throws IllegalArgumentException if sender, alias, or args is null
+     */
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {
+        Validate.notNull(sender, "Sender cannot be null");
+        Validate.notNull(args, "Arguments cannot be null");
+        Validate.notNull(alias, "Alias cannot be null");
+
+        if (args.length == 0) {
+            return ImmutableList.of();
+        }
+
+        String lastWord = args[args.length - 1];
+
+        Player senderPlayer = sender instanceof Player ? (Player) sender : null;
+
+        ArrayList<String> matchedPlayers = new ArrayList<String>();
+        for (Player player : sender.getServer().getOnlinePlayers()) {
+            String name = player.getName();
+            if ((senderPlayer == null || senderPlayer.canSee(player)) && StringUtil.startsWithIgnoreCase(name, lastWord)) {
+                matchedPlayers.add(name);
+            }
+        }
+
+        Collections.sort(matchedPlayers, String.CASE_INSENSITIVE_ORDER);
+        return matchedPlayers;
+    }
+
+    // Paper start - location tab-completes
+
+    /**
+     * Executed on tab completion for this command, returning a list of options the player can tab through. This method
+     * returns the {@link Location} of the block the player is looking at at the time of the tab complete.
+     * <p>
+     * Commands that want to use the Location information in their tab-complete implementations need to override this
+     * method. The Location provided by this method is the block that the player is currently looking at when the player
+     * attempts the tab complete. For this to be valid, the block must be highlighted by the player (i.e. the player is
+     * close enough to interact with the block).
+     *
+     * @param sender   Source object which is executing this command
+     * @param alias    the alias being used
+     * @param args     All arguments passed to the command, split via ' '
+     * @param location the location of the block the player is looking at
+     * @return a list of tab-completions for the specified arguments. This
+     * will never be null. List may be immutable.
+     * @throws IllegalArgumentException if sender, alias, or args is null
+     */
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args, Location location) throws IllegalArgumentException {
+        // Simply default to the standard tab-complete, subclasses can override this if needed
+        return tabComplete(sender, alias, args);
+    }
+    // Paper end
+
+    /**
+     * Returns the name of this command
+     *
+     * @return Name of this command
+     */
+    public String getName() {
+        return name;
+    }
+
+    /**
+     * Sets the name of this command.
+     * <p>
+     * May only be used before registering the command.
+     * Will return true if the new name is set, and false
+     * if the command has already been registered.
+     *
+     * @param name New command name
+     * @return returns true if the name change happened instantly or false if
+     *     the command was already registered
+     */
+    public boolean setName(String name) {
+        if (!isRegistered()) {
+            this.name = name;
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * Gets the permission required by users to be able to perform this
+     * command
+     *
+     * @return Permission name, or null if none
+     */
+    public String getPermission() {
+        return permission;
+    }
+
+    /**
+     * Sets the permission required by users to be able to perform this
+     * command
+     *
+     * @param permission Permission name or null
+     */
+    public void setPermission(String permission) {
+        this.permission = permission;
+    }
+
+    /**
+     * Tests the given {@link CommandSender} to see if they can perform this
+     * command.
+     * <p>
+     * If they do not have permission, they will be informed that they cannot
+     * do this.
+     *
+     * @param target User to test
+     * @return true if they can use it, otherwise false
+     */
+    public boolean testPermission(CommandSender target) {
+        if (testPermissionSilent(target)) {
+            return true;
+        }
+
+        if (permissionMessage == null) {
+            target.sendMessage(ChatColor.RED + "I'm sorry, but you do not have permission to perform this command. Please contact the server administrators if you believe that this is in error.");
+        } else if (permissionMessage.length() != 0) {
+            for (String line : permissionMessage.replace("<permission>", permission).split("\n")) {
+                target.sendMessage(line);
+            }
+        }
+
+        return false;
+    }
+
+    /**
+     * Tests the given {@link CommandSender} to see if they can perform this
+     * command.
+     * <p>
+     * No error is sent to the sender.
+     *
+     * @param target User to test
+     * @return true if they can use it, otherwise false
+     */
+    public boolean testPermissionSilent(CommandSender target) {
+        if ((permission == null) || (permission.length() == 0)) {
+            return true;
+        }
+
+        for (String p : permission.split(";")) {
+            if (target.hasPermission(p)) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    /**
+     * Returns the label for this command
+     *
+     * @return Label of this command
+     */
+    public String getLabel() {
+        return label;
+    }
+
+    /**
+     * Sets the label of this command.
+     * <p>
+     * May only be used before registering the command.
+     * Will return true if the new name is set, and false
+     * if the command has already been registered.
+     *
+     * @param name The command's name
+     * @return returns true if the name change happened instantly or false if
+     *     the command was already registered
+     */
+    public boolean setLabel(String name) {
+        this.nextLabel = name;
+        if (!isRegistered()) {
+            this.label = name;
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * Registers this command to a CommandMap.
+     * Once called it only allows changes the registered CommandMap
+     *
+     * @param commandMap the CommandMap to register this command to
+     * @return true if the registration was successful (the current registered
+     *     CommandMap was the passed CommandMap or null) false otherwise
+     */
+    public boolean register(CommandMap commandMap) {
+        if (allowChangesFrom(commandMap)) {
+            this.commandMap = commandMap;
+            return true;
+        }
+
+        return false;
+    }
+
+    /**
+     * Unregisters this command from the passed CommandMap applying any
+     * outstanding changes
+     *
+     * @param commandMap the CommandMap to unregister
+     * @return true if the unregistration was successfull (the current
+     *     registered CommandMap was the passed CommandMap or null) false
+     *     otherwise
+     */
+    public boolean unregister(CommandMap commandMap) {
+        if (allowChangesFrom(commandMap)) {
+            this.commandMap = null;
+            this.activeAliases = new ArrayList<String>(this.aliases);
+            this.label = this.nextLabel;
+            return true;
+        }
+
+        return false;
+    }
+
+    private boolean allowChangesFrom(CommandMap commandMap) {
+        return (null == this.commandMap || this.commandMap == commandMap);
+    }
+
+    /**
+     * Returns the current registered state of this command
+     *
+     * @return true if this command is currently registered false otherwise
+     */
+    public boolean isRegistered() {
+        return (null != this.commandMap);
+    }
+
+    /**
+     * Returns a list of active aliases of this command
+     *
+     * @return List of aliases
+     */
+    public List<String> getAliases() {
+        return activeAliases;
+    }
+
+    /**
+     * Returns a message to be displayed on a failed permission check for this
+     * command
+     *
+     * @return Permission check failed message
+     */
+    public String getPermissionMessage() {
+        return permissionMessage;
+    }
+
+    /**
+     * Gets a brief description of this command
+     *
+     * @return Description of this command
+     */
+    public String getDescription() {
+        return description;
+    }
+
+    /**
+     * Gets an example usage of this command
+     *
+     * @return One or more example usages
+     */
+    public String getUsage() {
+        return usageMessage;
+    }
+
+    /**
+     * Sets the list of aliases to request on registration for this command.
+     * This is not effective outside of defining aliases in the {@link
+     * PluginDescriptionFile#getCommands()} (under the
+     * `<code>aliases</code>' node) is equivalent to this method.
+     *
+     * @param aliases aliases to register to this command
+     * @return this command object, for chaining
+     */
+    public Command setAliases(List<String> aliases) {
+        this.aliases = aliases;
+        if (!isRegistered()) {
+            this.activeAliases = new ArrayList<String>(aliases);
+        }
+        return this;
+    }
+
+    /**
+     * Sets a brief description of this command. Defining a description in the
+     * {@link PluginDescriptionFile#getCommands()} (under the
+     * `<code>description</code>' node) is equivalent to this method.
+     *
+     * @param description new command description
+     * @return this command object, for chaining
+     */
+    public Command setDescription(String description) {
+        this.description = description;
+        return this;
+    }
+
+    /**
+     * Sets the message sent when a permission check fails
+     *
+     * @param permissionMessage new permission message, null to indicate
+     *     default message, or an empty string to indicate no message
+     * @return this command object, for chaining
+     */
+    public Command setPermissionMessage(String permissionMessage) {
+        this.permissionMessage = permissionMessage;
+        return this;
+    }
+
+    /**
+     * Sets the example usage of this command
+     *
+     * @param usage new example usage
+     * @return this command object, for chaining
+     */
+    public Command setUsage(String usage) {
+        this.usageMessage = usage;
+        return this;
+    }
+
+    public static void broadcastCommandMessage(CommandSender source, String message) {
+        broadcastCommandMessage(source, message, true);
+    }
+
+    public static void broadcastCommandMessage(CommandSender source, String message, boolean sendToSource) {
+        String result = source.getName() + ": " + message;
+
+        if (source instanceof BlockCommandSender) {
+            BlockCommandSender blockCommandSender = (BlockCommandSender) source;
+
+            if (blockCommandSender.getBlock().getWorld().getGameRuleValue("commandBlockOutput").equalsIgnoreCase("false")) {
+                Bukkit.getConsoleSender().sendMessage(result);
+                return;
+            }
+        } else if (source instanceof CommandMinecart) {
+            CommandMinecart commandMinecart = (CommandMinecart) source;
+
+            if (commandMinecart.getWorld().getGameRuleValue("commandBlockOutput").equalsIgnoreCase("false")) {
+                Bukkit.getConsoleSender().sendMessage(result);
+                return;
+            }
+        }
+
+        Set<Permissible> users = Bukkit.getPluginManager().getPermissionSubscriptions(Server.BROADCAST_CHANNEL_ADMINISTRATIVE);
+        String colored = ChatColor.GRAY + "" + ChatColor.ITALIC + "[" + result + ChatColor.GRAY + ChatColor.ITALIC + "]";
+
+        if (sendToSource && !(source instanceof ConsoleCommandSender)) {
+            source.sendMessage(message);
+        }
+
+        for (Permissible user : users) {
+            if (user instanceof CommandSender) {
+                CommandSender target = (CommandSender) user;
+
+                if (target instanceof ConsoleCommandSender) {
+                    target.sendMessage(result);
+                } else if (target != source) {
+                    target.sendMessage(colored);
+                }
+            }
+        }
+    }
+
+    @Override
+    public String toString() {
+        return getClass().getName() + '(' + name + ')';
+    }
+}
diff --git a/src/main/java/org/bukkit/command/PluginCommand.java b/src/main/java/org/bukkit/command/PluginCommand.java
new file mode 100644
index 0000000..04d1f99
--- /dev/null
+++ b/src/main/java/org/bukkit/command/PluginCommand.java
@@ -0,0 +1,171 @@
+package org.bukkit.command;
+
+import java.util.List;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.Location;
+import org.bukkit.plugin.Plugin;
+
+/**
+ * Represents a {@link Command} belonging to a plugin
+ */
+public final class PluginCommand extends Command implements PluginIdentifiableCommand {
+    private final Plugin owningPlugin;
+    private CommandExecutor executor;
+    private TabCompleter completer;
+
+    protected PluginCommand(String name, Plugin owner) {
+        super(name);
+        this.executor = owner;
+        this.owningPlugin = owner;
+        this.usageMessage = "";
+    }
+
+    /**
+     * Executes the command, returning its success
+     *
+     * @param sender Source object which is executing this command
+     * @param commandLabel The alias of the command used
+     * @param args All arguments passed to the command, split via ' '
+     * @return true if the command was successful, otherwise false
+     */
+    @Override
+    public boolean execute(CommandSender sender, String commandLabel, String[] args) {
+        boolean success = false;
+
+        if (!owningPlugin.isEnabled()) {
+            return false;
+        }
+
+        if (!testPermission(sender)) {
+            return true;
+        }
+
+        try {
+            success = executor.onCommand(sender, this, commandLabel, args);
+        } catch (Throwable ex) {
+            throw new CommandException("Unhandled exception executing command '" + commandLabel + "' in plugin " + owningPlugin.getDescription().getFullName(), ex);
+        }
+
+        if (!success && usageMessage.length() > 0) {
+            for (String line : usageMessage.replace("<command>", commandLabel).split("\n")) {
+                sender.sendMessage(line);
+            }
+        }
+
+        return success;
+    }
+
+    /**
+     * Sets the {@link CommandExecutor} to run when parsing this command
+     *
+     * @param executor New executor to run
+     */
+    public void setExecutor(CommandExecutor executor) {
+        this.executor = executor == null ? owningPlugin : executor;
+    }
+
+    /**
+     * Gets the {@link CommandExecutor} associated with this command
+     *
+     * @return CommandExecutor object linked to this command
+     */
+    public CommandExecutor getExecutor() {
+        return executor;
+    }
+
+    /**
+     * Sets the {@link TabCompleter} to run when tab-completing this command.
+     * <p>
+     * If no TabCompleter is specified, and the command's executor implements
+     * TabCompleter, then the executor will be used for tab completion.
+     *
+     * @param completer New tab completer
+     */
+    public void setTabCompleter(TabCompleter completer) {
+        this.completer = completer;
+    }
+
+    /**
+     * Gets the {@link TabCompleter} associated with this command.
+     *
+     * @return TabCompleter object linked to this command
+     */
+    public TabCompleter getTabCompleter() {
+        return completer;
+    }
+
+    /**
+     * Gets the owner of this PluginCommand
+     *
+     * @return Plugin that owns this command
+     */
+    public Plugin getPlugin() {
+        return owningPlugin;
+    }
+
+    /**
+     * {@inheritDoc}
+     * <p>
+     * Delegates to the tab completer if present.
+     * <p>
+     * If it is not present or returns null, will delegate to the current
+     * command executor if it implements {@link TabCompleter}. If a non-null
+     * list has not been found, will default to standard player name
+     * completion in {@link
+     * Command#tabComplete(CommandSender, String, String[])}.
+     * <p>
+     * This method does not consider permissions.
+     *
+     * @throws CommandException if the completer or executor throw an
+     *     exception during the process of tab-completing.
+     * @throws IllegalArgumentException if sender, alias, or args is null
+     */
+    @Override
+    public java.util.List<String> tabComplete(CommandSender sender, String alias, String[] args) throws CommandException, IllegalArgumentException {
+        return tabComplete(sender, alias, args, null); // Paper - The code from this method has been (slightly modified) moved to the Location method.
+    }
+
+    // PaperSpigot start - location tab-completes
+    /**
+     * This code was copied from tabComplete(CommandSender sender, String alias, String[] args)
+     */
+    @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args, Location location) throws CommandException, IllegalArgumentException {
+        Validate.notNull(sender, "Sender cannot be null");
+        Validate.notNull(args, "Arguments cannot be null");
+        Validate.notNull(alias, "Alias cannot be null");
+
+        List<String> completions = null;
+        try {
+            if (completer != null) {
+                completions = completer.onTabComplete(sender, this, alias, args, location); // Paper - add location argument
+            }
+            if (completions == null && executor instanceof TabCompleter) {
+                completions = ((TabCompleter) executor).onTabComplete(sender, this, alias, args, location); // Paper - add location argument
+            }
+        } catch (Throwable ex) {
+            StringBuilder message = new StringBuilder();
+            message.append("Unhandled exception during tab completion for command '/").append(alias).append(' ');
+            for (String arg : args) {
+                message.append(arg).append(' ');
+            }
+            message.deleteCharAt(message.length() - 1).append("' in plugin ").append(owningPlugin.getDescription().getFullName());
+            throw new CommandException(message.toString(), ex);
+        }
+
+        if (completions == null) {
+            return super.tabComplete(sender, alias, args);
+        }
+        return completions;
+    }
+    // Paper end
+
+    @Override
+    public String toString() {
+        StringBuilder stringBuilder = new StringBuilder(super.toString());
+        stringBuilder.deleteCharAt(stringBuilder.length() - 1);
+        stringBuilder.append(", ").append(owningPlugin.getDescription().getFullName()).append(')');
+        return stringBuilder.toString();
+    }
+}
diff --git a/src/main/java/org/bukkit/command/SimpleCommandMap.java b/src/main/java/org/bukkit/command/SimpleCommandMap.java
index 649f9f7..0af67d2 100644
--- a/src/main/java/org/bukkit/command/SimpleCommandMap.java
+++ b/src/main/java/org/bukkit/command/SimpleCommandMap.java
@@ -16,7 +16,7 @@ import com.destroystokyo.paper.exception.ServerCommandException;
 import com.destroystokyo.paper.exception.ServerTabCompleteException;
 
 import org.bukkit.Location;
-import org.apache.commons.lang.Validate;
+import org.apache.commons.lang3.Validate;
 import org.bukkit.Server;
 import org.bukkit.command.defaults.*;
 import org.bukkit.entity.Player;
diff --git a/src/main/java/org/bukkit/command/defaults/AchievementCommand.java b/src/main/java/org/bukkit/command/defaults/AchievementCommand.java
new file mode 100644
index 0000000..e090053
--- /dev/null
+++ b/src/main/java/org/bukkit/command/defaults/AchievementCommand.java
@@ -0,0 +1,188 @@
+package org.bukkit.command.defaults;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.Achievement;
+import org.bukkit.Bukkit;
+import org.bukkit.ChatColor;
+import org.bukkit.Statistic;
+import org.bukkit.Material;
+import org.bukkit.Statistic.Type;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.entity.EntityType;
+import org.bukkit.entity.Player;
+import org.bukkit.event.player.PlayerAchievementAwardedEvent;
+import org.bukkit.event.player.PlayerStatisticIncrementEvent;
+
+import com.google.common.collect.ImmutableList;
+
+@Deprecated
+public class AchievementCommand extends VanillaCommand {
+    public AchievementCommand() {
+        super("achievement");
+        this.description = "Gives the specified player an achievement or changes a statistic value. Use '*' to give all achievements.";
+        this.usageMessage = "/achievement give <stat_name> [player]";
+        this.setPermission("bukkit.command.achievement");
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
+        if (!testPermission(sender)) return true;
+
+        if (args.length < 2) {
+            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
+            return false;
+        }
+
+        if (!args[0].equalsIgnoreCase("give")) {
+            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
+            return false;
+        }
+
+        String statisticString = args[1];
+        Player player = null;
+
+        if (args.length > 2) {
+            player = Bukkit.getPlayer(args[1]);
+        } else if (sender instanceof Player) {
+            player = (Player) sender;
+        }
+
+        if (player == null) {
+            sender.sendMessage("You must specify which player you wish to perform this action on.");
+            return true;
+        }
+
+        if (statisticString.equals("*")) {
+            for (Achievement achievement : Achievement.values()) {
+                if (player.hasAchievement(achievement)) {
+                    continue;
+                }
+                PlayerAchievementAwardedEvent event = new PlayerAchievementAwardedEvent(player, achievement);
+                Bukkit.getServer().getPluginManager().callEvent(event);
+                if (!event.isCancelled()) {
+                    player.awardAchievement(achievement);
+                }
+            }
+            Command.broadcastCommandMessage(sender, String.format("Successfully given all achievements to %s", player.getName()));
+            return true;
+        }
+
+        Achievement achievement = Bukkit.getUnsafe().getAchievementFromInternalName(statisticString);
+        Statistic statistic = Bukkit.getUnsafe().getStatisticFromInternalName(statisticString);
+
+        if (achievement != null) {
+            if (player.hasAchievement(achievement)) {
+                sender.sendMessage(String.format("%s already has achievement %s", player.getName(), statisticString));
+                return true;
+            }
+
+            PlayerAchievementAwardedEvent event = new PlayerAchievementAwardedEvent(player, achievement);
+            Bukkit.getServer().getPluginManager().callEvent(event);
+            if (event.isCancelled()) {
+                sender.sendMessage(String.format("Unable to award %s the achievement %s", player.getName(), statisticString));
+                return true;
+            }
+            player.awardAchievement(achievement);
+                
+            Command.broadcastCommandMessage(sender, String.format("Successfully given %s the stat %s", player.getName(), statisticString));
+            return true;
+        }
+
+        if (statistic == null) {
+            sender.sendMessage(String.format("Unknown achievement or statistic '%s'", statisticString));
+            return true;
+        }
+
+        if (statistic.getType() == Type.UNTYPED) {
+            PlayerStatisticIncrementEvent event = new PlayerStatisticIncrementEvent(player, statistic, player.getStatistic(statistic), player.getStatistic(statistic) + 1);
+            Bukkit.getServer().getPluginManager().callEvent(event);
+            if (event.isCancelled()) {
+                sender.sendMessage(String.format("Unable to increment %s for %s", statisticString, player.getName()));
+                return true;
+            }
+            player.incrementStatistic(statistic);
+            Command.broadcastCommandMessage(sender, String.format("Successfully given %s the stat %s", player.getName(), statisticString));
+            return true;
+        }
+
+        if (statistic.getType() == Type.ENTITY) {
+            EntityType entityType = EntityType.fromName(statisticString.substring(statisticString.lastIndexOf(".") + 1));
+
+            if (entityType == null) {
+                sender.sendMessage(String.format("Unknown achievement or statistic '%s'", statisticString));
+                return true;
+            }
+
+            PlayerStatisticIncrementEvent event = new PlayerStatisticIncrementEvent(player, statistic, player.getStatistic(statistic), player.getStatistic(statistic) + 1, entityType);
+            Bukkit.getServer().getPluginManager().callEvent(event);
+            if (event.isCancelled()) {
+                sender.sendMessage(String.format("Unable to increment %s for %s", statisticString, player.getName()));
+                return true;
+            }
+
+            try {
+                player.incrementStatistic(statistic, entityType);
+            } catch (IllegalArgumentException e) {
+                sender.sendMessage(String.format("Unknown achievement or statistic '%s'", statisticString));
+                return true;
+            }
+        } else {
+            int id;
+            try {
+                id = getInteger(sender, statisticString.substring(statisticString.lastIndexOf(".") + 1), 0, Integer.MAX_VALUE, true);
+            } catch (NumberFormatException e) {
+                sender.sendMessage(e.getMessage());
+                return true;
+            }
+
+            Material material = Material.getMaterial(id);
+
+            if (material == null) {
+                sender.sendMessage(String.format("Unknown achievement or statistic '%s'", statisticString));
+                return true;
+            }
+
+            PlayerStatisticIncrementEvent event = new PlayerStatisticIncrementEvent(player, statistic, player.getStatistic(statistic), player.getStatistic(statistic) + 1, material);
+            Bukkit.getServer().getPluginManager().callEvent(event);
+            if (event.isCancelled()) {
+                sender.sendMessage(String.format("Unable to increment %s for %s", statisticString, player.getName()));
+                return true;
+            }
+
+            try {
+                player.incrementStatistic(statistic, material);
+            } catch (IllegalArgumentException e) {
+                sender.sendMessage(String.format("Unknown achievement or statistic '%s'", statisticString));
+                return true;
+            }
+        }
+
+        Command.broadcastCommandMessage(sender, String.format("Successfully given %s the stat %s", player.getName(), statisticString));
+        return true;
+    }
+
+    @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {
+        Validate.notNull(sender, "Sender cannot be null");
+        Validate.notNull(args, "Arguments cannot be null");
+        Validate.notNull(alias, "Alias cannot be null");
+
+        if (args.length == 1) {
+            return Arrays.asList("give");
+        }
+
+        if (args.length == 2) {
+            return Bukkit.getUnsafe().tabCompleteInternalStatisticOrAchievementName(args[1], new ArrayList<String>());
+        }
+
+        if (args.length == 3) {
+            return super.tabComplete(sender, alias, args);
+        }
+        return ImmutableList.of();
+    }
+}
diff --git a/src/main/java/org/bukkit/command/defaults/BanCommand.java b/src/main/java/org/bukkit/command/defaults/BanCommand.java
new file mode 100644
index 0000000..be82d1c
--- /dev/null
+++ b/src/main/java/org/bukkit/command/defaults/BanCommand.java
@@ -0,0 +1,56 @@
+package org.bukkit.command.defaults;
+
+import java.util.List;
+
+import org.apache.commons.lang3.StringUtils;
+import org.apache.commons.lang3.Validate;
+import org.bukkit.BanList;
+import org.bukkit.Bukkit;
+import org.bukkit.ChatColor;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.entity.Player;
+
+import com.google.common.collect.ImmutableList;
+
+@Deprecated
+public class BanCommand extends VanillaCommand {
+    public BanCommand() {
+        super("ban");
+        this.description = "Prevents the specified player from using this server";
+        this.usageMessage = "/ban <player> [reason ...]";
+        this.setPermission("bukkit.command.ban.player");
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
+        if (!testPermission(sender)) return true;
+        if (args.length == 0)  {
+            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
+            return false;
+        }
+
+        String reason = args.length > 0 ? StringUtils.join(args, ' ', 1, args.length) : null;
+        Bukkit.getBanList(BanList.Type.NAME).addBan(args[0], reason, null, sender.getName());
+
+        Player player = Bukkit.getPlayer(args[0]);
+        if (player != null) {
+            player.kickPlayer("Banned by admin.");
+        }
+
+        Command.broadcastCommandMessage(sender, "Banned player " + args[0]);
+        return true;
+    }
+
+    @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {
+        Validate.notNull(sender, "Sender cannot be null");
+        Validate.notNull(args, "Arguments cannot be null");
+        Validate.notNull(alias, "Alias cannot be null");
+
+        if (args.length >= 1) {
+            return super.tabComplete(sender, alias, args);
+        }
+        return ImmutableList.of();
+    }
+}
diff --git a/src/main/java/org/bukkit/command/defaults/BanIpCommand.java b/src/main/java/org/bukkit/command/defaults/BanIpCommand.java
new file mode 100644
index 0000000..c0be3f3
--- /dev/null
+++ b/src/main/java/org/bukkit/command/defaults/BanIpCommand.java
@@ -0,0 +1,78 @@
+package org.bukkit.command.defaults;
+
+import java.util.List;
+import java.util.regex.Pattern;
+
+import org.apache.commons.lang3.StringUtils;
+import org.apache.commons.lang3.Validate;
+import org.bukkit.BanList;
+import org.bukkit.Bukkit;
+import org.bukkit.ChatColor;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.entity.Player;
+
+import com.google.common.collect.ImmutableList;
+
+@Deprecated
+public class BanIpCommand extends VanillaCommand {
+    public static final Pattern ipValidity = Pattern.compile("^([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])$");
+
+    public BanIpCommand() {
+        super("ban-ip");
+        this.description = "Prevents the specified IP address from using this server";
+        this.usageMessage = "/ban-ip <address|player> [reason ...]";
+        this.setPermission("bukkit.command.ban.ip");
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
+        if (!testPermission(sender)) return true;
+        if (args.length < 1)  {
+            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
+            return false;
+        }
+
+        String reason = args.length > 0 ? StringUtils.join(args, ' ', 1, args.length) : null;
+
+        if (ipValidity.matcher(args[0]).matches()) {
+            processIPBan(args[0], sender, reason);
+        } else {
+            Player player = Bukkit.getPlayer(args[0]);
+
+            if (player == null) {
+                sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
+                return false;
+            }
+
+            processIPBan(player.getAddress().getAddress().getHostAddress(), sender, reason);
+        }
+
+        return true;
+    }
+
+    private void processIPBan(String ip, CommandSender sender, String reason) {
+        Bukkit.getBanList(BanList.Type.IP).addBan(ip, reason, null, sender.getName());
+
+        // Find all matching players and kick
+        for (Player player : Bukkit.getOnlinePlayers()) {
+            if (player.getAddress().getAddress().getHostAddress().equals(ip)) {
+                player.kickPlayer("You have been IP banned.");
+            }
+        }
+
+        Command.broadcastCommandMessage(sender, "Banned IP Address " + ip);
+    }
+
+    @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {
+        Validate.notNull(sender, "Sender cannot be null");
+        Validate.notNull(args, "Arguments cannot be null");
+        Validate.notNull(alias, "Alias cannot be null");
+
+        if (args.length == 1) {
+            return super.tabComplete(sender, alias, args);
+        }
+        return ImmutableList.of();
+    }
+}
diff --git a/src/main/java/org/bukkit/command/defaults/BanListCommand.java b/src/main/java/org/bukkit/command/defaults/BanListCommand.java
new file mode 100644
index 0000000..b45fcc0
--- /dev/null
+++ b/src/main/java/org/bukkit/command/defaults/BanListCommand.java
@@ -0,0 +1,74 @@
+package org.bukkit.command.defaults;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.UUID;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.BanEntry;
+import org.bukkit.BanList;
+import org.bukkit.Bukkit;
+import org.bukkit.ChatColor;
+import org.bukkit.OfflinePlayer;
+import org.bukkit.command.CommandSender;
+import org.bukkit.util.StringUtil;
+
+import com.google.common.collect.ImmutableList;
+
+@Deprecated
+public class BanListCommand extends VanillaCommand {
+    private static final List<String> BANLIST_TYPES = ImmutableList.of("ips", "players");
+
+    public BanListCommand() {
+        super("banlist");
+        this.description = "View all players banned from this server";
+        this.usageMessage = "/banlist [ips|players]";
+        this.setPermission("bukkit.command.ban.list");
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
+        if (!testPermission(sender)) return true;
+
+        BanList.Type banType = BanList.Type.NAME;
+        if (args.length > 0) {
+            if (args[0].equalsIgnoreCase("ips")) {
+                banType = BanList.Type.IP;
+            } else if (!args[0].equalsIgnoreCase("players")) {
+                sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
+                return false;
+            }
+        }
+
+        StringBuilder message = new StringBuilder();
+        BanEntry[] banlist = Bukkit.getBanList(banType).getBanEntries().toArray(new BanEntry[0]);
+
+        for (int x = 0; x < banlist.length; x++) {
+            if (x != 0) {
+                if (x == banlist.length - 1) {
+                    message.append(" and ");
+                } else {
+                    message.append(", ");
+                }
+            }
+
+            message.append(banlist[x].getTarget());
+        }
+
+        sender.sendMessage("There are " + banlist.length + " total banned players:");
+        sender.sendMessage(message.toString());
+        return true;
+    }
+
+    @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args) {
+        Validate.notNull(sender, "Sender cannot be null");
+        Validate.notNull(args, "Arguments cannot be null");
+        Validate.notNull(alias, "Alias cannot be null");
+
+        if (args.length == 1) {
+            return StringUtil.copyPartialMatches(args[0], BANLIST_TYPES, new ArrayList<String>(BANLIST_TYPES.size()));
+        }
+        return ImmutableList.of();
+    }
+}
diff --git a/src/main/java/org/bukkit/command/defaults/ClearCommand.java b/src/main/java/org/bukkit/command/defaults/ClearCommand.java
new file mode 100644
index 0000000..46301fa
--- /dev/null
+++ b/src/main/java/org/bukkit/command/defaults/ClearCommand.java
@@ -0,0 +1,115 @@
+package org.bukkit.command.defaults;
+
+import com.google.common.collect.ImmutableList;
+import org.apache.commons.lang3.Validate;
+import org.bukkit.Bukkit;
+import org.bukkit.ChatColor;
+import org.bukkit.Material;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.entity.Player;
+import org.bukkit.util.StringUtil;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+@Deprecated
+public class ClearCommand extends VanillaCommand {
+    private static List<String> materials;
+    static {
+        ArrayList<String> materialList = new ArrayList<String>();
+        for (Material material : Material.values()) {
+            materialList.add(material.name());
+        }
+        Collections.sort(materialList);
+        materials = ImmutableList.copyOf(materialList);
+    }
+
+    public ClearCommand() {
+        super("clear");
+        this.description = "Clears the player's inventory. Can specify item and data filters too.";
+        this.usageMessage = "/clear <player> [item] [data]";
+        this.setPermission("bukkit.command.clear");
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
+        if (!testPermission(sender)) return true;
+
+        Player player = null;
+        if (args.length > 0) {
+            player = Bukkit.getPlayer(args[0]);
+        } else if (sender instanceof Player) {
+            player = (Player) sender;
+        }
+
+        if (player != null) {
+            int id;
+
+            if (args.length > 1 && !(args[1].equals("-1"))) {
+                Material material = Material.matchMaterial(args[1]);
+                if (material == null) {
+                    sender.sendMessage(ChatColor.RED + "There's no item called " + args[1]);
+                    return false;
+                }
+
+                id = material.getId();
+            } else {
+                id = -1;
+            }
+
+            int data = args.length >= 3 ? getInteger(sender, args[2], 0) : -1;
+            int count = player.getInventory().clear(id, data);
+
+            Command.broadcastCommandMessage(sender, "Cleared the inventory of " + player.getDisplayName() + ", removing " + count + " items");
+        } else if (args.length == 0) {
+            sender.sendMessage(ChatColor.RED + "Please provide a player!");
+        } else {
+            sender.sendMessage(ChatColor.RED + "Can't find player " + args[0]);
+        }
+
+        return true;
+    }
+
+    @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {
+        Validate.notNull(sender, "Sender cannot be null");
+        Validate.notNull(args, "Arguments cannot be null");
+        Validate.notNull(alias, "Alias cannot be null");
+
+        if (args.length == 1) {
+            return super.tabComplete(sender, alias, args);
+        }
+        if (args.length == 2) {
+            final String arg = args[1];
+            final List<String> materials = ClearCommand.materials;
+            List<String> completion = null;
+
+            final int size = materials.size();
+            int i = Collections.binarySearch(materials, arg, String.CASE_INSENSITIVE_ORDER);
+
+            if (i < 0) {
+                // Insertion (start) index
+                i = -1 - i;
+            }
+
+            for ( ; i < size; i++) {
+                String material = materials.get(i);
+                if (StringUtil.startsWithIgnoreCase(material, arg)) {
+                    if (completion == null) {
+                        completion = new ArrayList<String>();
+                    }
+                    completion.add(material);
+                } else {
+                    break;
+                }
+            }
+
+            if (completion != null) {
+                return completion;
+            }
+        }
+        return ImmutableList.of();
+    }
+}
diff --git a/src/main/java/org/bukkit/command/defaults/DefaultGameModeCommand.java b/src/main/java/org/bukkit/command/defaults/DefaultGameModeCommand.java
new file mode 100644
index 0000000..9a5c4d4
--- /dev/null
+++ b/src/main/java/org/bukkit/command/defaults/DefaultGameModeCommand.java
@@ -0,0 +1,71 @@
+package org.bukkit.command.defaults;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.Bukkit;
+import org.bukkit.GameMode;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.util.StringUtil;
+
+import com.google.common.collect.ImmutableList;
+
+@Deprecated
+public class DefaultGameModeCommand extends VanillaCommand {
+    private static final List<String> GAMEMODE_NAMES = ImmutableList.of("adventure", "creative", "survival");
+
+    public DefaultGameModeCommand() {
+        super("defaultgamemode");
+        this.description = "Set the default gamemode";
+        this.usageMessage = "/defaultgamemode <mode>";
+        this.setPermission("bukkit.command.defaultgamemode");
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String commandLabel, String[] args) {
+        if (!testPermission(sender)) return true;
+        if (args.length == 0) {
+            sender.sendMessage("Usage: " + usageMessage);
+            return false;
+        }
+
+        String modeArg = args[0];
+        int value = -1;
+
+        try {
+            value = Integer.parseInt(modeArg);
+        } catch (NumberFormatException ex) {}
+
+        GameMode mode = GameMode.getByValue(value);
+
+        if (mode == null) {
+            if (modeArg.equalsIgnoreCase("creative") || modeArg.equalsIgnoreCase("c")) {
+                mode = GameMode.CREATIVE;
+            } else if (modeArg.equalsIgnoreCase("adventure") || modeArg.equalsIgnoreCase("a")) {
+                mode = GameMode.ADVENTURE;
+            } else {
+                mode = GameMode.SURVIVAL;
+            }
+        }
+
+        Bukkit.getServer().setDefaultGameMode(mode);
+        Command.broadcastCommandMessage(sender, "Default game mode set to " + mode.toString().toLowerCase());
+
+        return true;
+    }
+
+    @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args) {
+        Validate.notNull(sender, "Sender cannot be null");
+        Validate.notNull(args, "Arguments cannot be null");
+        Validate.notNull(alias, "Alias cannot be null");
+
+        if (args.length == 1) {
+            return StringUtil.copyPartialMatches(args[0], GAMEMODE_NAMES, new ArrayList<String>(GAMEMODE_NAMES.size()));
+        }
+
+        return ImmutableList.of();
+    }
+}
diff --git a/src/main/java/org/bukkit/command/defaults/DeopCommand.java b/src/main/java/org/bukkit/command/defaults/DeopCommand.java
new file mode 100644
index 0000000..4a15f47
--- /dev/null
+++ b/src/main/java/org/bukkit/command/defaults/DeopCommand.java
@@ -0,0 +1,63 @@
+package org.bukkit.command.defaults;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.Bukkit;
+import org.bukkit.ChatColor;
+import org.bukkit.OfflinePlayer;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.entity.Player;
+import org.bukkit.util.StringUtil;
+
+import com.google.common.collect.ImmutableList;
+
+@Deprecated
+public class DeopCommand extends VanillaCommand {
+    public DeopCommand() {
+        super("deop");
+        this.description = "Takes the specified player's operator status";
+        this.usageMessage = "/deop <player>";
+        this.setPermission("bukkit.command.op.take");
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
+        if (!testPermission(sender)) return true;
+        if (args.length != 1 || args[0].length() == 0) {
+            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
+            return false;
+        }
+
+        OfflinePlayer player = Bukkit.getOfflinePlayer(args[0]);
+        player.setOp(false);
+
+        if (player instanceof Player) {
+            ((Player) player).sendMessage(ChatColor.YELLOW + "You are no longer op!");
+        }
+
+        Command.broadcastCommandMessage(sender, "De-opped " + args[0]);
+        return true;
+    }
+
+    @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {
+        Validate.notNull(sender, "Sender cannot be null");
+        Validate.notNull(args, "Arguments cannot be null");
+        Validate.notNull(alias, "Alias cannot be null");
+
+        if (args.length == 1) {
+            List<String> completions = new ArrayList<String>();
+            for (OfflinePlayer player : Bukkit.getOperators()) {
+                String playerName = player.getName();
+                if (StringUtil.startsWithIgnoreCase(playerName, args[0])) {
+                    completions.add(playerName);
+                }
+            }
+            return completions;
+        }
+        return ImmutableList.of();
+    }
+}
diff --git a/src/main/java/org/bukkit/command/defaults/DifficultyCommand.java b/src/main/java/org/bukkit/command/defaults/DifficultyCommand.java
new file mode 100644
index 0000000..aaa79ba
--- /dev/null
+++ b/src/main/java/org/bukkit/command/defaults/DifficultyCommand.java
@@ -0,0 +1,82 @@
+package org.bukkit.command.defaults;
+
+import com.google.common.collect.ImmutableList;
+import org.apache.commons.lang3.Validate;
+import org.bukkit.Bukkit;
+import org.bukkit.ChatColor;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.util.StringUtil;
+import org.bukkit.Difficulty;
+
+import java.util.ArrayList;
+import java.util.List;
+
+@Deprecated
+public class DifficultyCommand extends VanillaCommand {
+    private static final List<String> DIFFICULTY_NAMES = ImmutableList.of("peaceful", "easy", "normal", "hard");
+
+    public DifficultyCommand() {
+        super("difficulty");
+        this.description = "Sets the game difficulty";
+        this.usageMessage = "/difficulty <new difficulty> ";
+        this.setPermission("bukkit.command.difficulty");
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
+        if (!testPermission(sender)) return true;
+        if (args.length != 1 || args[0].length() == 0) {
+            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
+            return false;
+        }
+
+        Difficulty difficulty = Difficulty.getByValue(getDifficultyForString(sender, args[0]));
+
+        if (Bukkit.isHardcore()) {
+            difficulty = Difficulty.HARD;
+        }
+
+        Bukkit.getWorlds().get(0).setDifficulty(difficulty);
+
+        int levelCount = 1;
+        if (Bukkit.getAllowNether()) {
+            Bukkit.getWorlds().get(levelCount).setDifficulty(difficulty);
+            levelCount++;
+        }
+
+        if (Bukkit.getAllowEnd()) {
+            Bukkit.getWorlds().get(levelCount).setDifficulty(difficulty);
+        }
+
+        Command.broadcastCommandMessage(sender, "Set difficulty to " + difficulty.toString());
+        return true;
+    }
+
+    protected int getDifficultyForString(CommandSender sender, String name) {
+        if (name.equalsIgnoreCase("peaceful") || name.equalsIgnoreCase("p")) {
+            return 0;
+        } else if (name.equalsIgnoreCase("easy") || name.equalsIgnoreCase("e")) {
+            return 1;
+        } else if (name.equalsIgnoreCase("normal") || name.equalsIgnoreCase("n")) {
+            return 2;
+        } else if (name.equalsIgnoreCase("hard") || name.equalsIgnoreCase("h")) {
+            return 3;
+        } else {
+            return getInteger(sender, name, 0, 3);
+        }
+    }
+
+    @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args) {
+        Validate.notNull(sender, "Sender cannot be null");
+        Validate.notNull(args, "Arguments cannot be null");
+        Validate.notNull(alias, "Alias cannot be null");
+
+        if (args.length == 1) {
+            return StringUtil.copyPartialMatches(args[0], DIFFICULTY_NAMES, new ArrayList<String>(DIFFICULTY_NAMES.size()));
+        }
+
+        return ImmutableList.of();
+    }
+}
diff --git a/src/main/java/org/bukkit/command/defaults/EnchantCommand.java b/src/main/java/org/bukkit/command/defaults/EnchantCommand.java
new file mode 100644
index 0000000..32d9822
--- /dev/null
+++ b/src/main/java/org/bukkit/command/defaults/EnchantCommand.java
@@ -0,0 +1,170 @@
+package org.bukkit.command.defaults;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+
+import org.apache.commons.lang3.Validate;
+import org.apache.commons.lang.WordUtils;
+import com.google.common.collect.ImmutableList;
+
+import org.bukkit.Bukkit;
+import org.bukkit.ChatColor;
+import org.bukkit.Material;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.enchantments.Enchantment;
+import org.bukkit.entity.Player;
+import org.bukkit.inventory.ItemStack;
+import org.bukkit.util.StringUtil;
+
+@Deprecated
+public class EnchantCommand extends VanillaCommand {
+    private static final List<String> ENCHANTMENT_NAMES = new ArrayList<String>();
+
+    public EnchantCommand() {
+        super("enchant");
+        this.description = "Adds enchantments to the item the player is currently holding. Specify 0 for the level to remove an enchantment. Specify force to ignore normal enchantment restrictions";
+        this.usageMessage = "/enchant <player> <enchantment> [level|max|0] [force]";
+        this.setPermission("bukkit.command.enchant");
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String commandLabel, String[] args) {
+        if (!testPermission(sender)) return true;
+        if (args.length < 2) {
+            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
+            return false;
+        }
+
+        boolean force = false;
+        if (args.length > 2) {
+            force = args[args.length > 3 ? 3 : 2].equalsIgnoreCase("force");
+        }
+
+        Player player = Bukkit.getPlayerExact(args[0]);
+        if (player == null) {
+            sender.sendMessage("Can't find player " + args[0]);
+        } else {
+            ItemStack item = player.getItemInHand();
+            if (item.getType() == Material.AIR) {
+                sender.sendMessage("The player isn't holding an item");
+            } else {
+                String itemName = item.getType().toString().replaceAll("_", " ");
+                itemName = WordUtils.capitalizeFully(itemName);
+
+                Enchantment enchantment = getEnchantment(args[1].toUpperCase());
+                if (enchantment == null) {
+                    sender.sendMessage(String.format("Enchantment does not exist: %s", args[1]));
+                }  else {
+                    String enchantmentName = enchantment.getName().replaceAll("_", " ");
+                    enchantmentName = WordUtils.capitalizeFully(enchantmentName);
+
+                    if (!force && !enchantment.canEnchantItem(item)) {
+                        sender.sendMessage(String.format("%s cannot be applied to %s", enchantmentName, itemName));
+                    } else {
+                        int level = 1;
+                        if (args.length > 2) {
+                            Integer integer = getInteger(args[2]);
+                            int minLevel = enchantment.getStartLevel();
+                            int maxLevel = force ? Short.MAX_VALUE : enchantment.getMaxLevel();
+
+                            if (integer != null) {
+                                if (integer == 0) {
+                                    item.removeEnchantment(enchantment);
+                                    Command.broadcastCommandMessage(sender, String.format("Removed %s on %s's %s", enchantmentName, player.getName(), itemName));
+                                    return true;
+                                }
+
+                                if (integer < minLevel || integer > maxLevel) {
+                                    sender.sendMessage(String.format("Level for enchantment %s must be between %d and %d", enchantmentName, minLevel, maxLevel));
+                                    sender.sendMessage("Specify 0 for level to remove an enchantment");
+                                    return true;
+                                }
+
+                                level = integer;
+                            }
+
+                            if ("max".equals(args[2])) {
+                                level = maxLevel;
+                            }
+                        }
+
+                        Map<Enchantment, Integer> enchantments = item.getEnchantments();
+                        boolean conflicts = false;
+
+                        if (!force && !enchantments.isEmpty()) { // TODO: Improve this to use a "hasEnchantments" call
+                            for (Map.Entry<Enchantment, Integer> entry : enchantments.entrySet()) {
+                                Enchantment enchant = entry.getKey();
+
+                                if (enchant.equals(enchantment)) continue;
+                                if (enchant.conflictsWith(enchantment)) {
+                                    sender.sendMessage(String.format("Can't apply the enchantment %s on an item with the enchantment %s", enchantmentName, WordUtils.capitalizeFully(enchant.getName().replaceAll("_", " "))));
+                                    conflicts = true;
+                                    break;
+                                }
+                            }
+                        }
+
+                        if (!conflicts) {
+                            item.addUnsafeEnchantment(enchantment, level);
+
+                            Command.broadcastCommandMessage(sender, String.format("Applied %s (Lvl %d) on %s's %s", enchantmentName, level, player.getName(), itemName), false);
+                            sender.sendMessage(String.format("Enchanting succeeded, applied %s (Lvl %d) onto your %s", enchantmentName, level, itemName));
+                        }
+                    }
+                }
+            }
+        }
+        return true;
+    }
+
+     @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {
+        Validate.notNull(sender, "Sender cannot be null");
+        Validate.notNull(args, "Arguments cannot be null");
+        Validate.notNull(alias, "Alias cannot be null");
+
+        if (args.length == 1) {
+            return super.tabComplete(sender, alias, args);
+        }
+
+        if (args.length == 2) {
+            return StringUtil.copyPartialMatches(args[1], ENCHANTMENT_NAMES, new ArrayList<String>(ENCHANTMENT_NAMES.size()));
+        }
+
+        if (args.length == 3 || args.length == 4) {
+            if (!args[args.length - 2].equalsIgnoreCase("force")) {
+                return ImmutableList.of("force");
+            }
+        }
+
+        return ImmutableList.of();
+     }
+
+    private Enchantment getEnchantment(String lookup) {
+        Enchantment enchantment = Enchantment.getByName(lookup);
+
+        if (enchantment == null) {
+            Integer id = getInteger(lookup);
+            if (id != null) {
+                enchantment = Enchantment.getById(id);
+            }
+        }
+
+        return enchantment;
+    }
+
+    public static void buildEnchantments() {
+        if (!ENCHANTMENT_NAMES.isEmpty()) {
+            throw new IllegalStateException("Enchantments have already been built!");
+        }
+
+        for (Enchantment enchantment : Enchantment.values()) {
+            ENCHANTMENT_NAMES.add(enchantment.getName());
+        }
+
+        Collections.sort(ENCHANTMENT_NAMES);
+    }
+}
diff --git a/src/main/java/org/bukkit/command/defaults/ExpCommand.java b/src/main/java/org/bukkit/command/defaults/ExpCommand.java
new file mode 100644
index 0000000..16f5bd3
--- /dev/null
+++ b/src/main/java/org/bukkit/command/defaults/ExpCommand.java
@@ -0,0 +1,90 @@
+package org.bukkit.command.defaults;
+
+import java.util.List;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.Bukkit;
+import org.bukkit.ChatColor;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.entity.Player;
+
+import com.google.common.collect.ImmutableList;
+
+@Deprecated
+public class ExpCommand extends VanillaCommand {
+    public ExpCommand() {
+        super("xp");
+        this.description = "Gives the specified player a certain amount of experience. Specify <amount>L to give levels instead, with a negative amount resulting in taking levels.";
+        this.usageMessage = "/xp <amount> [player] OR /xp <amount>L [player]";
+        this.setPermission("bukkit.command.xp");
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
+        if (!testPermission(sender)) return true;
+
+        if (args.length > 0) {
+            String inputAmount = args[0];
+            Player player = null;
+
+            boolean isLevel = inputAmount.endsWith("l") || inputAmount.endsWith("L");
+            if (isLevel && inputAmount.length() > 1) {
+                inputAmount = inputAmount.substring(0, inputAmount.length() - 1);
+            }
+
+            int amount = getInteger(sender, inputAmount, Integer.MIN_VALUE, Integer.MAX_VALUE);
+            boolean isTaking = amount < 0;
+
+            if (isTaking) {
+                amount *= -1;
+            }
+
+            if (args.length > 1) {
+                player = Bukkit.getPlayer(args[1]);
+            } else if (sender instanceof Player) {
+                player = (Player) sender;
+            }
+
+            if (player != null) {
+                if (isLevel) {
+                    if (isTaking) {
+                        player.giveExpLevels(-amount);
+                        Command.broadcastCommandMessage(sender, "Taken " + amount + " level(s) from " + player.getName());
+                    } else {
+                        player.giveExpLevels(amount);
+                        Command.broadcastCommandMessage(sender, "Given " + amount + " level(s) to " + player.getName());
+                    }
+                } else {
+                    if (isTaking) {
+                        sender.sendMessage(ChatColor.RED + "Taking experience can only be done by levels, cannot give players negative experience points");
+                        return false;
+                    } else {
+                        player.giveExp(amount);
+                        Command.broadcastCommandMessage(sender, "Given " + amount + " experience to " + player.getName());
+                    }
+                }
+            } else {
+                sender.sendMessage("Can't find player, was one provided?\n" + ChatColor.RED + "Usage: " + usageMessage);
+                return false;
+            }
+
+            return true;
+        }
+
+        sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
+        return false;
+    }
+
+    @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {
+        Validate.notNull(sender, "Sender cannot be null");
+        Validate.notNull(args, "Arguments cannot be null");
+        Validate.notNull(alias, "Alias cannot be null");
+
+        if (args.length == 2) {
+            return super.tabComplete(sender, alias, args);
+        }
+        return ImmutableList.of();
+    }
+}
diff --git a/src/main/java/org/bukkit/command/defaults/GameModeCommand.java b/src/main/java/org/bukkit/command/defaults/GameModeCommand.java
new file mode 100644
index 0000000..f39fa45
--- /dev/null
+++ b/src/main/java/org/bukkit/command/defaults/GameModeCommand.java
@@ -0,0 +1,101 @@
+package org.bukkit.command.defaults;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.Bukkit;
+import org.bukkit.ChatColor;
+import org.bukkit.GameMode;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.entity.Player;
+import org.bukkit.util.StringUtil;
+
+import com.google.common.collect.ImmutableList;
+
+@Deprecated
+public class GameModeCommand extends VanillaCommand {
+    private static final List<String> GAMEMODE_NAMES = ImmutableList.of("adventure", "creative", "survival", "spectator");
+
+    public GameModeCommand() {
+        super("gamemode");
+        this.description = "Changes the player to a specific game mode";
+        this.usageMessage = "/gamemode <mode> [player]";
+        this.setPermission("bukkit.command.gamemode");
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
+        if (!testPermission(sender)) return true;
+        if (args.length == 0) {
+            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
+            return false;
+        }
+
+        String modeArg = args[0];
+        String playerArg = sender.getName();
+
+        if (args.length == 2) {
+            playerArg = args[1];
+        }
+
+        Player player = Bukkit.getPlayerExact(playerArg);
+
+        if (player != null) {
+            int value = -1;
+
+            try {
+                value = Integer.parseInt(modeArg);
+            } catch (NumberFormatException ex) {}
+
+            GameMode mode = GameMode.getByValue(value);
+
+            if (mode == null) {
+                if (modeArg.equalsIgnoreCase("creative") || modeArg.equalsIgnoreCase("c")) {
+                    mode = GameMode.CREATIVE;
+                } else if (modeArg.equalsIgnoreCase("adventure") || modeArg.equalsIgnoreCase("a")) {
+                    mode = GameMode.ADVENTURE;
+                } else if (modeArg.equalsIgnoreCase("spectator") || modeArg.equalsIgnoreCase("sp")) {
+                    mode = GameMode.SPECTATOR;
+                } else {
+                    mode = GameMode.SURVIVAL;
+                }
+            }
+
+            if (mode != player.getGameMode()) {
+                player.setGameMode(mode);
+
+                if (mode != player.getGameMode()) {
+                    sender.sendMessage("Game mode change for " + player.getName() + " failed!");
+                } else {
+                    if (player == sender) {
+                        Command.broadcastCommandMessage(sender, "Set own game mode to " + mode.toString() + " mode");
+                    } else {
+                        Command.broadcastCommandMessage(sender, "Set " + player.getName() + "'s game mode to " + mode.toString() + " mode");
+                    }
+                }
+            } else {
+                sender.sendMessage(player.getName() + " already has game mode " + mode.getValue());
+            }
+        } else {
+            sender.sendMessage("Can't find player " + playerArg);
+        }
+
+        return true;
+    }
+
+    @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args) {
+        Validate.notNull(sender, "Sender cannot be null");
+        Validate.notNull(args, "Arguments cannot be null");
+        Validate.notNull(alias, "Alias cannot be null");
+
+        if (args.length == 1) {
+            return StringUtil.copyPartialMatches(args[0], GAMEMODE_NAMES, new ArrayList<String>(GAMEMODE_NAMES.size()));
+        } else if (args.length == 2) {
+            return super.tabComplete(sender, alias, args);
+        }
+        return ImmutableList.of();
+    }
+}
diff --git a/src/main/java/org/bukkit/command/defaults/GameRuleCommand.java b/src/main/java/org/bukkit/command/defaults/GameRuleCommand.java
new file mode 100644
index 0000000..c2cd405
--- /dev/null
+++ b/src/main/java/org/bukkit/command/defaults/GameRuleCommand.java
@@ -0,0 +1,89 @@
+package org.bukkit.command.defaults;
+
+import com.google.common.collect.ImmutableList;
+import org.apache.commons.lang3.Validate;
+import org.bukkit.ChatColor;
+import org.bukkit.command.BlockCommandSender;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.util.StringUtil;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import org.bukkit.Bukkit;
+import org.bukkit.World;
+import org.bukkit.entity.HumanEntity;
+
+@Deprecated
+public class GameRuleCommand extends VanillaCommand {
+    private static final List<String> GAMERULE_STATES = ImmutableList.of("true", "false");
+
+    public GameRuleCommand() {
+        super("gamerule");
+        this.description = "Sets a server's game rules";
+        this.usageMessage = "/gamerule <rule name> <value> OR /gamerule <rule name>";
+        this.setPermission("bukkit.command.gamerule");
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
+        if (!testPermission(sender)) return true;
+
+        if (args.length > 0) {
+            String rule = args[0];
+            World world = getGameWorld(sender);
+
+            if (world.isGameRule(rule)) {
+                if (args.length > 1) {
+                    String value = args[1];
+
+                    world.setGameRuleValue(rule, value);
+                    Command.broadcastCommandMessage(sender, "Game rule " + rule + " has been set to: " + value);
+                } else {
+                    String value = world.getGameRuleValue(rule);
+                    sender.sendMessage(rule + " = " + value);
+                }
+            } else {
+                sender.sendMessage(ChatColor.RED + "No game rule called " + rule + " is available");
+            }
+
+            return true;
+        } else {
+            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
+            sender.sendMessage("Rules: " + this.createString(getGameWorld(sender).getGameRules(), 0, ", "));
+
+            return true;
+        }
+    }
+
+    private World getGameWorld(CommandSender sender) {
+        if (sender instanceof HumanEntity) {
+            World world = ((HumanEntity) sender).getWorld();
+            if (world != null) {
+                return world;
+            }
+        } else if (sender instanceof BlockCommandSender) {
+            return ((BlockCommandSender) sender).getBlock().getWorld();
+        }
+
+        return Bukkit.getWorlds().get(0);
+    }
+
+    @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {
+        Validate.notNull(sender, "Sender cannot be null");
+        Validate.notNull(args, "Arguments cannot be null");
+        Validate.notNull(alias, "Alias cannot be null");
+
+        if (args.length == 1) {
+            return StringUtil.copyPartialMatches(args[0], Arrays.asList(getGameWorld(sender).getGameRules()), new ArrayList<String>());
+        }
+
+        if (args.length == 2) {
+            return StringUtil.copyPartialMatches(args[1], GAMERULE_STATES, new ArrayList<String>(GAMERULE_STATES.size()));
+        }
+
+        return ImmutableList.of();
+    }
+}
diff --git a/src/main/java/org/bukkit/command/defaults/GiveCommand.java b/src/main/java/org/bukkit/command/defaults/GiveCommand.java
new file mode 100644
index 0000000..43fb371
--- /dev/null
+++ b/src/main/java/org/bukkit/command/defaults/GiveCommand.java
@@ -0,0 +1,130 @@
+package org.bukkit.command.defaults;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.Bukkit;
+import org.bukkit.ChatColor;
+import org.bukkit.Material;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.entity.Player;
+import org.bukkit.inventory.ItemStack;
+import org.bukkit.util.StringUtil;
+
+import com.google.common.base.Joiner;
+import com.google.common.collect.ImmutableList;
+
+@Deprecated
+public class GiveCommand extends VanillaCommand {
+    private static List<String> materials;
+    static {
+        ArrayList<String> materialList = new ArrayList<String>();
+        for (Material material : Material.values()) {
+            materialList.add(material.name());
+        }
+        Collections.sort(materialList);
+        materials = ImmutableList.copyOf(materialList);
+    }
+
+    public GiveCommand() {
+        super("give");
+        this.description = "Gives the specified player a certain amount of items";
+        this.usageMessage = "/give <player> <item> [amount [data]]";
+        this.setPermission("bukkit.command.give");
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
+        if (!testPermission(sender)) return true;
+        if ((args.length < 2)) {
+            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
+            return false;
+        }
+
+        Player player = Bukkit.getPlayerExact(args[0]);
+
+        if (player != null) {
+            Material material = Material.matchMaterial(args[1]);
+
+            if (material == null) {
+                material = Bukkit.getUnsafe().getMaterialFromInternalName(args[1]);
+            }
+
+            if (material != null) {
+                int amount = 1;
+                short data = 0;
+
+                if (args.length >= 3) {
+                    amount = this.getInteger(sender, args[2], 1, 64);
+
+                    if (args.length >= 4) {
+                        try {
+                            data = Short.parseShort(args[3]);
+                        } catch (NumberFormatException ex) {}
+                    }
+                }
+
+                ItemStack stack = new ItemStack(material, amount, data);
+
+                if (args.length >= 5) {
+                    try {
+                        stack = Bukkit.getUnsafe().modifyItemStack(stack, Joiner.on(' ').join(Arrays.asList(args).subList(4, args.length)));
+                    } catch (Throwable t) {
+                        player.sendMessage("Not a valid tag");
+                        return true;
+                    }
+                }
+
+                player.getInventory().addItem(stack);
+
+                Command.broadcastCommandMessage(sender, "Gave " + player.getName() + " some " + material.getId() + " (" + material + ")");
+            } else {
+                sender.sendMessage("There's no item called " + args[1]);
+            }
+        } else {
+            sender.sendMessage("Can't find player " + args[0]);
+        }
+
+        return true;
+    }
+
+    @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {
+        Validate.notNull(sender, "Sender cannot be null");
+        Validate.notNull(args, "Arguments cannot be null");
+        Validate.notNull(alias, "Alias cannot be null");
+
+        if (args.length == 1) {
+            return super.tabComplete(sender, alias, args);
+        }
+        if (args.length == 2) {
+            final String arg = args[1];
+            final List<String> materials = GiveCommand.materials;
+            List<String> completion = new ArrayList<String>();
+
+            final int size = materials.size();
+            int i = Collections.binarySearch(materials, arg, String.CASE_INSENSITIVE_ORDER);
+
+            if (i < 0) {
+                // Insertion (start) index
+                i = -1 - i;
+            }
+
+            for ( ; i < size; i++) {
+                String material = materials.get(i);
+                if (StringUtil.startsWithIgnoreCase(material, arg)) {
+                    completion.add(material);
+                } else {
+                    break;
+                }
+            }
+
+            return Bukkit.getUnsafe().tabCompleteInternalMaterialName(arg, completion);
+        }
+        return ImmutableList.of();
+    }
+}
diff --git a/src/main/java/org/bukkit/command/defaults/HelpCommand.java b/src/main/java/org/bukkit/command/defaults/HelpCommand.java
new file mode 100644
index 0000000..0531167
--- /dev/null
+++ b/src/main/java/org/bukkit/command/defaults/HelpCommand.java
@@ -0,0 +1,228 @@
+package org.bukkit.command.defaults;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.TreeSet;
+
+import org.apache.commons.lang3.ArrayUtils;
+import org.apache.commons.lang3.StringUtils;
+import org.apache.commons.lang3.Validate;
+import org.apache.commons.lang3.math.NumberUtils;
+import org.bukkit.Bukkit;
+import org.bukkit.ChatColor;
+import org.bukkit.command.CommandSender;
+import org.bukkit.command.ConsoleCommandSender;
+import org.bukkit.help.HelpMap;
+import org.bukkit.help.HelpTopic;
+import org.bukkit.help.HelpTopicComparator;
+import org.bukkit.help.IndexHelpTopic;
+import org.bukkit.util.ChatPaginator;
+
+import com.google.common.collect.ImmutableList;
+
+public class HelpCommand extends VanillaCommand {
+    public HelpCommand() {
+        super("help");
+        this.description = "Shows the help menu";
+        this.usageMessage = "/help <pageNumber>\n/help <topic>\n/help <topic> <pageNumber>";
+        this.setAliases(Arrays.asList(new String[] { "?" }));
+        this.setPermission("bukkit.command.help");
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
+        if (!testPermission(sender)) return true;
+
+        String command;
+        int pageNumber;
+        int pageHeight;
+        int pageWidth;
+
+        if (args.length == 0) {
+            command = "";
+            pageNumber = 1;
+        } else if (NumberUtils.isDigits(args[args.length - 1])) {
+            command = StringUtils.join(ArrayUtils.subarray(args, 0, args.length - 1), " ");
+            try {
+                pageNumber = NumberUtils.createInteger(args[args.length - 1]);
+            } catch (NumberFormatException exception) {
+                pageNumber = 1;
+            }
+            if (pageNumber <= 0) {
+                pageNumber = 1;
+            }
+        } else {
+            command = StringUtils.join(args, " ");
+            pageNumber = 1;
+        }
+
+        if (sender instanceof ConsoleCommandSender) {
+            pageHeight = ChatPaginator.UNBOUNDED_PAGE_HEIGHT;
+            pageWidth = ChatPaginator.UNBOUNDED_PAGE_WIDTH;
+        } else {
+            pageHeight = ChatPaginator.CLOSED_CHAT_PAGE_HEIGHT - 1;
+            pageWidth = ChatPaginator.GUARANTEED_NO_WRAP_CHAT_PAGE_WIDTH;
+        }
+
+        HelpMap helpMap = Bukkit.getServer().getHelpMap();
+        HelpTopic topic = helpMap.getHelpTopic(command);
+
+        if (topic == null) {
+            topic = helpMap.getHelpTopic("/" + command);
+        }
+
+        if (topic == null) {
+            topic = findPossibleMatches(command);
+        }
+
+        if (topic == null || !topic.canSee(sender)) {
+            sender.sendMessage(ChatColor.RED + "No help for " + command);
+            return true;
+        }
+
+        ChatPaginator.ChatPage page = ChatPaginator.paginate(topic.getFullText(sender), pageNumber, pageWidth, pageHeight);
+
+        StringBuilder header = new StringBuilder();
+        header.append(ChatColor.YELLOW);
+        header.append("--------- ");
+        header.append(ChatColor.WHITE);
+        header.append("Help: ");
+        header.append(topic.getName());
+        header.append(" ");
+        if (page.getTotalPages() > 1) {
+            header.append("(");
+            header.append(page.getPageNumber());
+            header.append("/");
+            header.append(page.getTotalPages());
+            header.append(") ");
+        }
+        header.append(ChatColor.YELLOW);
+        for (int i = header.length(); i < ChatPaginator.GUARANTEED_NO_WRAP_CHAT_PAGE_WIDTH; i++) {
+            header.append("-");
+        }
+        sender.sendMessage(header.toString());
+
+        sender.sendMessage(page.getLines());
+
+        return true;
+    }
+
+    @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args) {
+        Validate.notNull(sender, "Sender cannot be null");
+        Validate.notNull(args, "Arguments cannot be null");
+        Validate.notNull(alias, "Alias cannot be null");
+
+        if (args.length == 1) {
+            List<String> matchedTopics = new ArrayList<String>();
+            String searchString = args[0];
+            for (HelpTopic topic : Bukkit.getServer().getHelpMap().getHelpTopics()) {
+                String trimmedTopic = topic.getName().startsWith("/") ? topic.getName().substring(1) : topic.getName();
+
+                if (trimmedTopic.startsWith(searchString)) {
+                    matchedTopics.add(trimmedTopic);
+                }
+            }
+            return matchedTopics;
+        }
+        return ImmutableList.of();
+    }
+
+    protected HelpTopic findPossibleMatches(String searchString) {
+        int maxDistance = (searchString.length() / 5) + 3;
+        Set<HelpTopic> possibleMatches = new TreeSet<HelpTopic>(HelpTopicComparator.helpTopicComparatorInstance());
+
+        if (searchString.startsWith("/")) {
+            searchString = searchString.substring(1);
+        }
+
+        for (HelpTopic topic : Bukkit.getServer().getHelpMap().getHelpTopics()) {
+            String trimmedTopic = topic.getName().startsWith("/") ? topic.getName().substring(1) : topic.getName();
+
+            if (trimmedTopic.length() < searchString.length()) {
+                continue;
+            }
+
+            if (Character.toLowerCase(trimmedTopic.charAt(0)) != Character.toLowerCase(searchString.charAt(0))) {
+                continue;
+            }
+
+            if (damerauLevenshteinDistance(searchString, trimmedTopic.substring(0, searchString.length())) < maxDistance) {
+                possibleMatches.add(topic);
+            }
+        }
+
+        if (possibleMatches.size() > 0) {
+            return new IndexHelpTopic("Search", null, null, possibleMatches, "Search for: " + searchString);
+        } else {
+            return null;
+        }
+    }
+
+    /**
+     * Computes the Dameraur-Levenshtein Distance between two strings. Adapted
+     * from the algorithm at <a href="http://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance">Wikipedia: Damerau–Levenshtein distance</a>
+     *
+     * @param s1 The first string being compared.
+     * @param s2 The second string being compared.
+     * @return The number of substitutions, deletions, insertions, and
+     * transpositions required to get from s1 to s2.
+     */
+    protected static int damerauLevenshteinDistance(String s1, String s2) {
+        if (s1 == null && s2 == null) {
+            return 0;
+        }
+        if (s1 != null && s2 == null) {
+            return s1.length();
+        }
+        if (s1 == null && s2 != null) {
+            return s2.length();
+        }
+
+        int s1Len = s1.length();
+        int s2Len = s2.length();
+        int[][] H = new int[s1Len + 2][s2Len + 2];
+
+        int INF = s1Len + s2Len;
+        H[0][0] = INF;
+        for (int i = 0; i <= s1Len; i++) {
+            H[i + 1][1] = i;
+            H[i + 1][0] = INF;
+        }
+        for (int j = 0; j <= s2Len; j++) {
+            H[1][j + 1] = j;
+            H[0][j + 1] = INF;
+        }
+
+        Map<Character, Integer> sd = new HashMap<Character, Integer>();
+        for (char Letter : (s1 + s2).toCharArray()) {
+            if (!sd.containsKey(Letter)) {
+                sd.put(Letter, 0);
+            }
+        }
+
+        for (int i = 1; i <= s1Len; i++) {
+            int DB = 0;
+            for (int j = 1; j <= s2Len; j++) {
+                int i1 = sd.get(s2.charAt(j - 1));
+                int j1 = DB;
+
+                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {
+                    H[i + 1][j + 1] = H[i][j];
+                    DB = j;
+                } else {
+                    H[i + 1][j + 1] = Math.min(H[i][j], Math.min(H[i + 1][j], H[i][j + 1])) + 1;
+                }
+
+                H[i + 1][j + 1] = Math.min(H[i + 1][j + 1], H[i1][j1] + (i - i1 - 1) + 1 + (j - j1 - 1));
+            }
+            sd.put(s1.charAt(i - 1), i);
+        }
+
+        return H[s1Len + 1][s2Len + 1];
+    }
+}
diff --git a/src/main/java/org/bukkit/command/defaults/KickCommand.java b/src/main/java/org/bukkit/command/defaults/KickCommand.java
new file mode 100644
index 0000000..2798d51
--- /dev/null
+++ b/src/main/java/org/bukkit/command/defaults/KickCommand.java
@@ -0,0 +1,60 @@
+package org.bukkit.command.defaults;
+
+import java.util.List;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.Bukkit;
+import org.bukkit.ChatColor;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.entity.Player;
+
+import com.google.common.collect.ImmutableList;
+
+@Deprecated
+public class KickCommand extends VanillaCommand {
+    public KickCommand() {
+        super("kick");
+        this.description = "Removes the specified player from the server";
+        this.usageMessage = "/kick <player> [reason ...]";
+        this.setPermission("bukkit.command.kick");
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
+        if (!testPermission(sender)) return true;
+        if (args.length < 1 || args[0].length() == 0) {
+            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
+            return false;
+        }
+
+        Player player = Bukkit.getPlayerExact(args[0]);
+
+        if (player != null) {
+            String reason = "Kicked by an operator.";
+
+            if (args.length > 1) {
+                reason = createString(args, 1);
+            }
+
+            player.kickPlayer(reason);
+            Command.broadcastCommandMessage(sender, "Kicked player " + player.getName() + ". With reason:\n" + reason);
+        } else {
+            sender.sendMessage( args[0] + " not found.");
+        }
+
+        return true;
+    }
+
+    @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {
+        Validate.notNull(sender, "Sender cannot be null");
+        Validate.notNull(args, "Arguments cannot be null");
+        Validate.notNull(alias, "Alias cannot be null");
+
+        if (args.length >= 1) {
+            return super.tabComplete(sender, alias, args);
+        }
+        return ImmutableList.of();
+    }
+}
diff --git a/src/main/java/org/bukkit/command/defaults/KillCommand.java b/src/main/java/org/bukkit/command/defaults/KillCommand.java
new file mode 100644
index 0000000..908e2b1
--- /dev/null
+++ b/src/main/java/org/bukkit/command/defaults/KillCommand.java
@@ -0,0 +1,51 @@
+package org.bukkit.command.defaults;
+
+import java.util.List;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.Bukkit;
+import org.bukkit.command.CommandSender;
+import org.bukkit.entity.Player;
+import org.bukkit.event.entity.EntityDamageEvent;
+
+import com.google.common.collect.ImmutableList;
+
+@Deprecated
+public class KillCommand extends VanillaCommand {
+    public KillCommand() {
+        super("kill");
+        this.description = "Commits suicide, only usable as a player";
+        this.usageMessage = "/kill";
+        this.setPermission("bukkit.command.kill");
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
+        if (!testPermission(sender)) return true;
+
+        if (sender instanceof Player) {
+            Player player = (Player) sender;
+
+            EntityDamageEvent ede = new EntityDamageEvent(player, EntityDamageEvent.DamageCause.SUICIDE, 1000);
+            Bukkit.getPluginManager().callEvent(ede);
+            if (ede.isCancelled()) return true;
+
+            ede.getEntity().setLastDamageCause(ede);
+            player.setHealth(0);
+            sender.sendMessage("Ouch. That look like it hurt.");
+        } else {
+            sender.sendMessage("You can only perform this command as a player");
+        }
+
+        return true;
+    }
+
+    @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {
+        Validate.notNull(sender, "Sender cannot be null");
+        Validate.notNull(args, "Arguments cannot be null");
+        Validate.notNull(alias, "Alias cannot be null");
+
+        return ImmutableList.of();
+    }
+}
diff --git a/src/main/java/org/bukkit/command/defaults/ListCommand.java b/src/main/java/org/bukkit/command/defaults/ListCommand.java
new file mode 100644
index 0000000..bea5e81
--- /dev/null
+++ b/src/main/java/org/bukkit/command/defaults/ListCommand.java
@@ -0,0 +1,55 @@
+package org.bukkit.command.defaults;
+
+import java.util.Collection;
+import java.util.List;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.Bukkit;
+import org.bukkit.command.CommandSender;
+import org.bukkit.entity.Player;
+
+import com.google.common.collect.ImmutableList;
+
+@Deprecated
+public class ListCommand extends VanillaCommand {
+    public ListCommand() {
+        super("list");
+        this.description = "Lists all online players";
+        this.usageMessage = "/list";
+        this.setPermission("bukkit.command.list");
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
+        if (!testPermission(sender)) return true;
+
+        StringBuilder online = new StringBuilder();
+
+        final Collection<? extends Player> players = Bukkit.getOnlinePlayers();
+
+        for (Player player : players) {
+            // If a player is hidden from the sender don't show them in the list
+            if (sender instanceof Player && !((Player) sender).canSee(player))
+                continue;
+
+            if (online.length() > 0) {
+                online.append(", ");
+            }
+
+            online.append(player.getDisplayName());
+        }
+
+        sender.sendMessage("There are " + players.size() + "/" + Bukkit.getMaxPlayers() + " players online:\n" + online.toString());
+
+        return true;
+    }
+
+    @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {
+        Validate.notNull(sender, "Sender cannot be null");
+        Validate.notNull(args, "Arguments cannot be null");
+        Validate.notNull(alias, "Alias cannot be null");
+
+        return ImmutableList.of();
+    }
+}
diff --git a/src/main/java/org/bukkit/command/defaults/OpCommand.java b/src/main/java/org/bukkit/command/defaults/OpCommand.java
new file mode 100644
index 0000000..5b8f1cf
--- /dev/null
+++ b/src/main/java/org/bukkit/command/defaults/OpCommand.java
@@ -0,0 +1,76 @@
+package org.bukkit.command.defaults;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.Bukkit;
+import org.bukkit.ChatColor;
+import org.bukkit.OfflinePlayer;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.entity.Player;
+import org.bukkit.util.StringUtil;
+
+import com.google.common.collect.ImmutableList;
+
+@Deprecated
+public class OpCommand extends VanillaCommand {
+    public OpCommand() {
+        super("op");
+        this.description = "Gives the specified player operator status";
+        this.usageMessage = "/op <player>";
+        this.setPermission("bukkit.command.op.give");
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
+        if (!testPermission(sender)) return true;
+        if (args.length != 1 || args[0].length() == 0)  {
+            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
+            return false;
+        }
+
+        OfflinePlayer player = Bukkit.getOfflinePlayer(args[0]);
+        player.setOp(true);
+
+        Command.broadcastCommandMessage(sender, "Opped " + args[0]);
+        return true;
+    }
+
+    @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {
+        Validate.notNull(sender, "Sender cannot be null");
+        Validate.notNull(args, "Arguments cannot be null");
+        Validate.notNull(alias, "Alias cannot be null");
+
+        if (args.length == 1) {
+            if (!(sender instanceof Player)) {
+                return ImmutableList.of();
+            }
+
+            String lastWord = args[0];
+            if (lastWord.length() == 0) {
+                return ImmutableList.of();
+            }
+
+            Player senderPlayer = (Player) sender;
+
+            ArrayList<String> matchedPlayers = new ArrayList<String>();
+            for (Player player : sender.getServer().getOnlinePlayers()) {
+                String name = player.getName();
+                if (!senderPlayer.canSee(player) || player.isOp()) {
+                    continue;
+                }
+                if (StringUtil.startsWithIgnoreCase(name, lastWord)) {
+                    matchedPlayers.add(name);
+                }
+            }
+
+            Collections.sort(matchedPlayers, String.CASE_INSENSITIVE_ORDER);
+            return matchedPlayers;
+        }
+        return ImmutableList.of();
+    }
+}
diff --git a/src/main/java/org/bukkit/command/defaults/PardonCommand.java b/src/main/java/org/bukkit/command/defaults/PardonCommand.java
new file mode 100644
index 0000000..027d707
--- /dev/null
+++ b/src/main/java/org/bukkit/command/defaults/PardonCommand.java
@@ -0,0 +1,57 @@
+package org.bukkit.command.defaults;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.BanList;
+import org.bukkit.Bukkit;
+import org.bukkit.ChatColor;
+import org.bukkit.OfflinePlayer;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.util.StringUtil;
+
+import com.google.common.collect.ImmutableList;
+
+@Deprecated
+public class PardonCommand extends VanillaCommand {
+    public PardonCommand() {
+        super("pardon");
+        this.description = "Allows the specified player to use this server";
+        this.usageMessage = "/pardon <player>";
+        this.setPermission("bukkit.command.unban.player");
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
+        if (!testPermission(sender)) return true;
+        if (args.length != 1)  {
+            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
+            return false;
+        }
+
+        Bukkit.getBanList(BanList.Type.NAME).pardon(args[0]);
+        Command.broadcastCommandMessage(sender, "Pardoned " + args[0]);
+        return true;
+    }
+
+    @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {
+        Validate.notNull(sender, "Sender cannot be null");
+        Validate.notNull(args, "Arguments cannot be null");
+        Validate.notNull(alias, "Alias cannot be null");
+
+        if (args.length == 1) {
+            List<String> completions = new ArrayList<String>();
+            for (OfflinePlayer player : Bukkit.getBannedPlayers()) {
+                String name = player.getName();
+                if (StringUtil.startsWithIgnoreCase(name, args[0])) {
+                    completions.add(name);
+                }
+            }
+            return completions;
+        }
+        return ImmutableList.of();
+    }
+}
diff --git a/src/main/java/org/bukkit/command/defaults/PardonIpCommand.java b/src/main/java/org/bukkit/command/defaults/PardonIpCommand.java
new file mode 100644
index 0000000..1d91340
--- /dev/null
+++ b/src/main/java/org/bukkit/command/defaults/PardonIpCommand.java
@@ -0,0 +1,53 @@
+package org.bukkit.command.defaults;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.Bukkit;
+import org.bukkit.ChatColor;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.util.StringUtil;
+
+import com.google.common.collect.ImmutableList;
+
+@Deprecated
+public class PardonIpCommand extends VanillaCommand {
+    public PardonIpCommand() {
+        super("pardon-ip");
+        this.description = "Allows the specified IP address to use this server";
+        this.usageMessage = "/pardon-ip <address>";
+        this.setPermission("bukkit.command.unban.ip");
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
+        if (!testPermission(sender)) return true;
+        if (args.length != 1)  {
+            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
+            return false;
+        }
+
+        if (BanIpCommand.ipValidity.matcher(args[0]).matches()) {
+            Bukkit.unbanIP(args[0]);
+            Command.broadcastCommandMessage(sender, "Pardoned ip " + args[0]);
+        } else {
+            sender.sendMessage("Invalid ip");
+        }
+
+        return true;
+    }
+
+    @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {
+        Validate.notNull(sender, "Sender cannot be null");
+        Validate.notNull(args, "Arguments cannot be null");
+        Validate.notNull(alias, "Alias cannot be null");
+
+        if (args.length == 1) {
+            return StringUtil.copyPartialMatches(args[0], Bukkit.getIPBans(), new ArrayList<String>());
+        }
+        return ImmutableList.of();
+    }
+}
diff --git a/src/main/java/org/bukkit/command/defaults/SaveCommand.java b/src/main/java/org/bukkit/command/defaults/SaveCommand.java
new file mode 100644
index 0000000..5d902ab
--- /dev/null
+++ b/src/main/java/org/bukkit/command/defaults/SaveCommand.java
@@ -0,0 +1,47 @@
+package org.bukkit.command.defaults;
+
+import java.util.List;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.Bukkit;
+import org.bukkit.World;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+
+import com.google.common.collect.ImmutableList;
+
+@Deprecated
+public class SaveCommand extends VanillaCommand {
+    public SaveCommand() {
+        super("save-all");
+        this.description = "Saves the server to disk";
+        this.usageMessage = "/save-all";
+        this.setPermission("bukkit.command.save.perform");
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
+        if (!testPermission(sender)) return true;
+
+        Command.broadcastCommandMessage(sender, "Forcing save..");
+
+        Bukkit.savePlayers();
+
+        for (World world : Bukkit.getWorlds()) {
+            world.save();
+        }
+
+        Command.broadcastCommandMessage(sender, "Save complete.");
+
+        return true;
+    }
+
+    @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {
+        Validate.notNull(sender, "Sender cannot be null");
+        Validate.notNull(args, "Arguments cannot be null");
+        Validate.notNull(alias, "Alias cannot be null");
+
+        return ImmutableList.of();
+    }
+}
diff --git a/src/main/java/org/bukkit/command/defaults/SaveOffCommand.java b/src/main/java/org/bukkit/command/defaults/SaveOffCommand.java
new file mode 100644
index 0000000..627e2c3
--- /dev/null
+++ b/src/main/java/org/bukkit/command/defaults/SaveOffCommand.java
@@ -0,0 +1,42 @@
+package org.bukkit.command.defaults;
+
+import java.util.List;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.Bukkit;
+import org.bukkit.World;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+
+import com.google.common.collect.ImmutableList;
+
+@Deprecated
+public class SaveOffCommand extends VanillaCommand {
+    public SaveOffCommand() {
+        super("save-off");
+        this.description = "Disables server autosaving";
+        this.usageMessage = "/save-off";
+        this.setPermission("bukkit.command.save.disable");
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
+        if (!testPermission(sender)) return true;
+
+        for (World world : Bukkit.getWorlds()) {
+            world.setAutoSave(false);
+        }
+
+        Command.broadcastCommandMessage(sender, "Disabled level saving..");
+        return true;
+    }
+
+    @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {
+        Validate.notNull(sender, "Sender cannot be null");
+        Validate.notNull(args, "Arguments cannot be null");
+        Validate.notNull(alias, "Alias cannot be null");
+
+        return ImmutableList.of();
+    }
+}
diff --git a/src/main/java/org/bukkit/command/defaults/SaveOnCommand.java b/src/main/java/org/bukkit/command/defaults/SaveOnCommand.java
new file mode 100644
index 0000000..10188ee
--- /dev/null
+++ b/src/main/java/org/bukkit/command/defaults/SaveOnCommand.java
@@ -0,0 +1,42 @@
+package org.bukkit.command.defaults;
+
+import java.util.List;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.Bukkit;
+import org.bukkit.World;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+
+import com.google.common.collect.ImmutableList;
+
+@Deprecated
+public class SaveOnCommand extends VanillaCommand {
+    public SaveOnCommand() {
+        super("save-on");
+        this.description = "Enables server autosaving";
+        this.usageMessage = "/save-on";
+        this.setPermission("bukkit.command.save.enable");
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
+        if (!testPermission(sender)) return true;
+
+        for (World world : Bukkit.getWorlds()) {
+            world.setAutoSave(true);
+        }
+
+        Command.broadcastCommandMessage(sender, "Enabled level saving..");
+        return true;
+    }
+
+    @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {
+        Validate.notNull(sender, "Sender cannot be null");
+        Validate.notNull(args, "Arguments cannot be null");
+        Validate.notNull(alias, "Alias cannot be null");
+
+        return ImmutableList.of();
+    }
+}
diff --git a/src/main/java/org/bukkit/command/defaults/SayCommand.java b/src/main/java/org/bukkit/command/defaults/SayCommand.java
new file mode 100644
index 0000000..57c3501
--- /dev/null
+++ b/src/main/java/org/bukkit/command/defaults/SayCommand.java
@@ -0,0 +1,63 @@
+package org.bukkit.command.defaults;
+
+import java.util.List;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.Bukkit;
+import org.bukkit.ChatColor;
+import org.bukkit.command.CommandSender;
+import org.bukkit.command.ConsoleCommandSender;
+import org.bukkit.entity.Player;
+
+import com.google.common.collect.ImmutableList;
+
+@Deprecated
+public class SayCommand extends VanillaCommand {
+    public SayCommand() {
+        super("say");
+        this.description = "Broadcasts the given message as the sender";
+        this.usageMessage = "/say <message ...>";
+        this.setPermission("bukkit.command.say");
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
+        if (!testPermission(sender)) return true;
+        if (args.length == 0)  {
+            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
+            return false;
+        }
+
+        StringBuilder message = new StringBuilder();
+        message.append(ChatColor.LIGHT_PURPLE).append("[");
+        if (sender instanceof ConsoleCommandSender) {
+            message.append("Server");
+        } else if (sender instanceof Player) {
+            message.append(((Player) sender).getDisplayName());
+        } else {
+            message.append(sender.getName());
+        }
+        message.append(ChatColor.LIGHT_PURPLE).append("] ");
+
+        if (args.length > 0) {
+            message.append(args[0]);
+            for (int i = 1; i < args.length; i++) {
+                message.append(" ").append(args[i]);
+            }
+        }
+
+        Bukkit.broadcastMessage(message.toString());
+        return true;
+    }
+
+    @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {
+        Validate.notNull(sender, "Sender cannot be null");
+        Validate.notNull(args, "Arguments cannot be null");
+
+        if (args.length >= 1) {
+            return super.tabComplete(sender, alias, args);
+        }
+        return ImmutableList.of();
+    }
+}
diff --git a/src/main/java/org/bukkit/command/defaults/ScoreboardCommand.java b/src/main/java/org/bukkit/command/defaults/ScoreboardCommand.java
new file mode 100644
index 0000000..5256c42
--- /dev/null
+++ b/src/main/java/org/bukkit/command/defaults/ScoreboardCommand.java
@@ -0,0 +1,618 @@
+package org.bukkit.command.defaults;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import org.apache.commons.lang3.ArrayUtils;
+import org.apache.commons.lang3.StringUtils;
+import org.apache.commons.lang3.Validate;
+import org.bukkit.Bukkit;
+import org.bukkit.ChatColor;
+import org.bukkit.OfflinePlayer;
+import org.bukkit.command.CommandSender;
+import org.bukkit.entity.Player;
+import org.bukkit.scoreboard.DisplaySlot;
+import org.bukkit.scoreboard.Objective;
+import org.bukkit.scoreboard.Score;
+import org.bukkit.scoreboard.Scoreboard;
+import org.bukkit.scoreboard.Team;
+import org.bukkit.util.StringUtil;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
+
+@Deprecated
+public class ScoreboardCommand extends VanillaCommand {
+
+    private static final List<String> MAIN_CHOICES = ImmutableList.of("objectives", "players", "teams");
+    private static final List<String> OBJECTIVES_CHOICES = ImmutableList.of("list", "add", "remove", "setdisplay");
+    private static final List<String> OBJECTIVES_CRITERIA = ImmutableList.of("health", "playerKillCount", "totalKillCount", "deathCount", "dummy");
+    private static final List<String> PLAYERS_CHOICES = ImmutableList.of("set", "add", "remove", "reset", "list");
+    private static final List<String> TEAMS_CHOICES = ImmutableList.of("add", "remove", "join", "leave", "empty", "list", "option");
+    private static final List<String> TEAMS_OPTION_CHOICES = ImmutableList.of("color", "friendlyfire", "seeFriendlyInvisibles");
+    private static final Map<String, DisplaySlot> OBJECTIVES_DISPLAYSLOT = ImmutableMap.of("belowName", DisplaySlot.BELOW_NAME, "list", DisplaySlot.PLAYER_LIST, "sidebar", DisplaySlot.SIDEBAR);
+    private static final Map<String, ChatColor> TEAMS_OPTION_COLOR = ImmutableMap.<String, ChatColor>builder()
+            .put("aqua", ChatColor.AQUA)
+            .put("black", ChatColor.BLACK)
+            .put("blue", ChatColor.BLUE)
+            .put("bold", ChatColor.BOLD)
+            .put("dark_aqua", ChatColor.DARK_AQUA)
+            .put("dark_blue", ChatColor.DARK_BLUE)
+            .put("dark_gray",  ChatColor.DARK_GRAY)
+            .put("dark_green", ChatColor.DARK_GREEN)
+            .put("dark_purple", ChatColor.DARK_PURPLE)
+            .put("dark_red", ChatColor.DARK_RED)
+            .put("gold", ChatColor.GOLD)
+            .put("gray", ChatColor.GRAY)
+            .put("green", ChatColor.GREEN)
+            .put("italic", ChatColor.ITALIC)
+            .put("light_purple", ChatColor.LIGHT_PURPLE)
+            .put("obfuscated", ChatColor.MAGIC) // This is the important line
+            .put("red", ChatColor.RED)
+            .put("reset", ChatColor.RESET)
+            .put("strikethrough", ChatColor.STRIKETHROUGH)
+            .put("underline", ChatColor.UNDERLINE)
+            .put("white", ChatColor.WHITE)
+            .put("yellow", ChatColor.YELLOW)
+            .build();
+    private static final List<String> BOOLEAN = ImmutableList.of("true", "false");
+
+    public ScoreboardCommand() {
+        super("scoreboard");
+        this.description = "Scoreboard control";
+        this.usageMessage = "/scoreboard";
+        this.setPermission("bukkit.command.scoreboard");
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
+        if (!testPermission(sender))
+            return true;
+        if (args.length < 1 || args[0].length() == 0) {
+            sender.sendMessage(ChatColor.RED + "Usage: /scoreboard <objectives|players|teams>");
+            return false;
+        }
+
+        final Scoreboard mainScoreboard = Bukkit.getScoreboardManager().getMainScoreboard();
+
+        if (args[0].equalsIgnoreCase("objectives")) {
+            if (args.length == 1) {
+                sender.sendMessage(ChatColor.RED + "Usage: /scoreboard objectives <list|add|remove|setdisplay>");
+                return false;
+            }
+            if (args[1].equalsIgnoreCase("list")) {
+                Set<Objective> objectives = mainScoreboard.getObjectives();
+                if (objectives.isEmpty()) {
+                    sender.sendMessage(ChatColor.RED + "There are no objectives on the scoreboard");
+                    return false;
+                }
+                sender.sendMessage(ChatColor.DARK_GREEN + "Showing " + objectives.size() + " objective(s) on scoreboard");
+                for (Objective objective : objectives) {
+                    sender.sendMessage("- " + objective.getName() + ": displays as '" + objective.getDisplayName() + "' and is type '" + objective.getCriteria() + "'");
+                }
+            } else if (args[1].equalsIgnoreCase("add")) {
+                if (args.length < 4) {
+                    sender.sendMessage(ChatColor.RED + "/scoreboard objectives add <name> <criteriaType> [display name ...]");
+                    return false;
+                }
+                String name = args[2];
+                String criteria = args[3];
+
+                if (criteria == null) {
+                    sender.sendMessage(ChatColor.RED + "Invalid objective criteria type. Valid types are: " + stringCollectionToString(OBJECTIVES_CRITERIA));
+                } else if (name.length() > 16) {
+                    sender.sendMessage(ChatColor.RED + "The name '" + name + "' is too long for an objective, it can be at most 16 characters long");
+                } else if (mainScoreboard.getObjective(name) != null) {
+                    sender.sendMessage(ChatColor.RED + "An objective with the name '" + name + "' already exists");
+                } else {
+                    String displayName = null;
+                    if (args.length > 4) {
+                        displayName = StringUtils.join(ArrayUtils.subarray(args, 4, args.length), ' ');
+                        if (displayName.length() > 32) {
+                            sender.sendMessage(ChatColor.RED + "The name '" + displayName + "' is too long for an objective, it can be at most 32 characters long");
+                            return false;
+                        }
+                    }
+                    Objective objective = mainScoreboard.registerNewObjective(name, criteria);
+                    if (displayName != null && displayName.length() > 0) {
+                        objective.setDisplayName(displayName);
+                    }
+                    sender.sendMessage("Added new objective '" + name + "' successfully");
+                }
+            } else if (args[1].equalsIgnoreCase("remove")) {
+                if (args.length != 3) {
+                    sender.sendMessage(ChatColor.RED + "/scoreboard objectives remove <name>");
+                    return false;
+                }
+                String name = args[2];
+                Objective objective = mainScoreboard.getObjective(name);
+                if (objective == null) {
+                    sender.sendMessage(ChatColor.RED + "No objective was found by the name '" + name + "'");
+                } else {
+                    objective.unregister();
+                    sender.sendMessage("Removed objective '" + name + "' successfully");
+                }
+            } else if (args[1].equalsIgnoreCase("setdisplay")) {
+                if (args.length != 3 && args.length != 4) {
+                    sender.sendMessage(ChatColor.RED + "/scoreboard objectives setdisplay <slot> [objective]");
+                    return false;
+                }
+                String slotName = args[2];
+                DisplaySlot slot = OBJECTIVES_DISPLAYSLOT.get(slotName);
+                if (slot == null) {
+                    sender.sendMessage(ChatColor.RED + "No such display slot '" + slotName + "'");
+                } else {
+                    if (args.length == 4) {
+                        String objectiveName = args[3];
+                        Objective objective = mainScoreboard.getObjective(objectiveName);
+                        if (objective == null) {
+                            sender.sendMessage(ChatColor.RED + "No objective was found by the name '" + objectiveName + "'");
+                            return false;
+                        }
+
+                        objective.setDisplaySlot(slot);
+                        sender.sendMessage("Set the display objective in slot '" + slotName + "' to '" + objective.getName() + "'");
+                    } else {
+                        Objective objective = mainScoreboard.getObjective(slot);
+                        if (objective != null) {
+                            objective.setDisplaySlot(null);
+                        }
+                        sender.sendMessage("Cleared objective display slot '" + slotName + "'");
+                    }
+                }
+            }
+        } else if (args[0].equalsIgnoreCase("players")) {
+            if (args.length == 1) {
+                sender.sendMessage(ChatColor.RED + "/scoreboard players <set|add|remove|reset|list>");
+                return false;
+            }
+            if (args[1].equalsIgnoreCase("set") || args[1].equalsIgnoreCase("add") || args[1].equalsIgnoreCase("remove")) {
+                if (args.length != 5) {
+                    if (args[1].equalsIgnoreCase("set")) {
+                        sender.sendMessage(ChatColor.RED + "/scoreboard players set <player> <objective> <score>");
+                    } else if (args[1].equalsIgnoreCase("add")) {
+                        sender.sendMessage(ChatColor.RED + "/scoreboard players add <player> <objective> <count>");
+                    } else {
+                        sender.sendMessage(ChatColor.RED + "/scoreboard players remove <player> <objective> <count>");
+                    }
+                    return false;
+                }
+                String objectiveName = args[3];
+                Objective objective = mainScoreboard.getObjective(objectiveName);
+                if (objective == null) {
+                    sender.sendMessage(ChatColor.RED + "No objective was found by the name '" + objectiveName + "'");
+                    return false;
+                } else if (!objective.isModifiable()) {
+                    sender.sendMessage(ChatColor.RED + "The objective '" + objectiveName + "' is read-only and cannot be set");
+                    return false;
+                }
+
+                String valueString = args[4];
+                int value;
+                try {
+                    value = Integer.parseInt(valueString);
+                } catch (NumberFormatException e) {
+                    sender.sendMessage(ChatColor.RED + "'" + valueString + "' is not a valid number");
+                    return false;
+                }
+                if (value < 1 && !args[1].equalsIgnoreCase("set")) {
+                    sender.sendMessage(ChatColor.RED + "The number you have entered (" + value + ") is too small, it must be at least 1");
+                    return false;
+                }
+
+                String playerName = args[2];
+                if (playerName.length() > 16) {
+                    sender.sendMessage(ChatColor.RED + "'" + playerName + "' is too long for a player name");
+                    return false;
+                }
+                Score score = objective.getScore(playerName);
+                int newScore;
+                if (args[1].equalsIgnoreCase("set")) {
+                    newScore = value;
+                } else if (args[1].equalsIgnoreCase("add")) {
+                    newScore = score.getScore() + value;
+                } else {
+                    newScore = score.getScore() - value;
+                }
+                score.setScore(newScore);
+                sender.sendMessage("Set score of " + objectiveName + " for player " + playerName + " to " + newScore);
+            } else if (args[1].equalsIgnoreCase("reset")) {
+                if (args.length != 3) {
+                    sender.sendMessage(ChatColor.RED + "/scoreboard players reset <player>");
+                    return false;
+                }
+                String playerName = args[2];
+                if (playerName.length() > 16) {
+                    sender.sendMessage(ChatColor.RED + "'" + playerName + "' is too long for a player name");
+                    return false;
+                }
+                mainScoreboard.resetScores(playerName);
+                sender.sendMessage("Reset all scores of player " + playerName);
+            } else if (args[1].equalsIgnoreCase("list")) {
+                if (args.length > 3) {
+                    sender.sendMessage(ChatColor.RED + "/scoreboard players list <player>");
+                    return false;
+                }
+                if (args.length == 2) {
+                    Set<String> entries = mainScoreboard.getEntries();
+                    if (entries.isEmpty()) {
+                        sender.sendMessage(ChatColor.RED + "There are no tracked players on the scoreboard");
+                    } else {
+                        sender.sendMessage(ChatColor.DARK_GREEN + "Showing " + entries.size() + " tracked players on the scoreboard");
+                        sender.sendMessage(stringCollectionToString(entries));
+                    }
+                } else {
+                    String playerName = args[2];
+                    if (playerName.length() > 16) {
+                        sender.sendMessage(ChatColor.RED + "'" + playerName + "' is too long for a player name");
+                        return false;
+                    }
+                    Set<Score> scores = mainScoreboard.getScores(playerName);
+                    if (scores.isEmpty()) {
+                        sender.sendMessage(ChatColor.RED + "Player " + playerName + " has no scores recorded");
+                    } else {
+                        sender.sendMessage(ChatColor.DARK_GREEN + "Showing " + scores.size() + " tracked objective(s) for " + playerName);
+                        for (Score score : scores) {
+                            sender.sendMessage("- " + score.getObjective().getDisplayName() + ": " + score.getScore() + " (" + score.getObjective().getName() + ")");
+                        }
+                    }
+                }
+            }
+        } else if (args[0].equalsIgnoreCase("teams")) {
+            if (args.length == 1) {
+                sender.sendMessage(ChatColor.RED + "/scoreboard teams <list|add|remove|empty|join|leave|option>");
+                return false;
+            }
+            if (args[1].equalsIgnoreCase("list")) {
+                if (args.length == 2) {
+                    Set<Team> teams = mainScoreboard.getTeams();
+                    if (teams.isEmpty()) {
+                        sender.sendMessage(ChatColor.RED + "There are no teams registered on the scoreboard");
+                    } else {
+                        sender.sendMessage(ChatColor.DARK_GREEN + "Showing " + teams.size() + " teams on the scoreboard");
+                        for (Team team : teams) {
+                            sender.sendMessage("- " + team.getName() + ": '" + team.getDisplayName() + "' has " + team.getSize() + " players");
+                        }
+                    }
+                } else if (args.length == 3) {
+                    String teamName = args[2];
+                    Team team = mainScoreboard.getTeam(teamName);
+                    if (team == null) {
+                        sender.sendMessage(ChatColor.RED + "No team was found by the name '" + teamName + "'");
+                    } else {
+                        Set<OfflinePlayer> players = team.getPlayers();
+                        if (players.isEmpty()) {
+                            sender.sendMessage(ChatColor.RED + "Team " + team.getName() + " has no players");
+                        } else {
+                            sender.sendMessage(ChatColor.DARK_GREEN + "Showing " + players.size() + " player(s) in team " + team.getName());
+                            sender.sendMessage(offlinePlayerSetToString(players));
+                        }
+                    }
+                } else {
+                    sender.sendMessage(ChatColor.RED + "/scoreboard teams list [name]");
+                    return false;
+                }
+            } else if (args[1].equalsIgnoreCase("add")) {
+                if (args.length < 3) {
+                    sender.sendMessage(ChatColor.RED + "/scoreboard teams add <name> [display name ...]");
+                    return false;
+                }
+                String name = args[2];
+                if (name.length() > 16) {
+                    sender.sendMessage(ChatColor.RED + "The name '" + name + "' is too long for a team, it can be at most 16 characters long");
+                } else if (mainScoreboard.getTeam(name) != null) {
+                    sender.sendMessage(ChatColor.RED + "A team with the name '" + name + "' already exists");
+                } else {
+                    String displayName = null;
+                    if (args.length > 3) {
+                        displayName = StringUtils.join(ArrayUtils.subarray(args, 3, args.length), ' ');
+                        if (displayName.length() > 32) {
+                            sender.sendMessage(ChatColor.RED + "The display name '" + displayName + "' is too long for a team, it can be at most 32 characters long");
+                            return false;
+                        }
+                    }
+                    Team team = mainScoreboard.registerNewTeam(name);
+                    if (displayName != null && displayName.length() > 0) {
+                        team.setDisplayName(displayName);
+                    }
+                    sender.sendMessage("Added new team '" + team.getName() + "' successfully");
+                }
+            } else if (args[1].equalsIgnoreCase("remove")) {
+                if (args.length != 3) {
+                    sender.sendMessage(ChatColor.RED + "/scoreboard teams remove <name>");
+                    return false;
+                }
+                String name = args[2];
+                Team team = mainScoreboard.getTeam(name);
+                if (team == null) {
+                    sender.sendMessage(ChatColor.RED + "No team was found by the name '" + name + "'");
+                } else {
+                    team.unregister();
+                    sender.sendMessage("Removed team " + name);
+                }
+            } else if (args[1].equalsIgnoreCase("empty")) {
+                if (args.length != 3) {
+                    sender.sendMessage(ChatColor.RED + "/scoreboard teams clear <name>");
+                    return false;
+                }
+                String name = args[2];
+                Team team = mainScoreboard.getTeam(name);
+                if (team == null) {
+                    sender.sendMessage(ChatColor.RED + "No team was found by the name '" + name + "'");
+                } else {
+                    Set<OfflinePlayer> players = team.getPlayers();
+                    if (players.isEmpty()) {
+                        sender.sendMessage(ChatColor.RED + "Team " + team.getName() + " is already empty, cannot remove nonexistant players");
+                    } else {
+                        for (OfflinePlayer player : players) {
+                            team.removePlayer(player);
+                        }
+                        sender.sendMessage("Removed all " + players.size() + " player(s) from team " + team.getName());
+                    }
+                }
+            } else if (args[1].equalsIgnoreCase("join")) {
+                if ((sender instanceof Player) ? args.length < 3 : args.length < 4) {
+                    sender.sendMessage(ChatColor.RED + "/scoreboard teams join <team> [player...]");
+                    return false;
+                }
+                String teamName = args[2];
+                Team team = mainScoreboard.getTeam(teamName);
+                if (team == null) {
+                    sender.sendMessage(ChatColor.RED + "No team was found by the name '" + teamName + "'");
+                } else {
+                    Set<String> addedPlayers = new HashSet<String>();
+                    if ((sender instanceof Player) && args.length == 3) {
+                        team.addPlayer((Player) sender);
+                        addedPlayers.add(sender.getName());
+                    } else {
+                        for (int i = 3; i < args.length; i++) {
+                            String playerName = args[i];
+                            OfflinePlayer offlinePlayer;
+                            Player player = Bukkit.getPlayerExact(playerName);
+                            if (player != null) {
+                                offlinePlayer = player;
+                            } else {
+                                offlinePlayer = Bukkit.getOfflinePlayer(playerName);
+                            }
+                            team.addPlayer(offlinePlayer);
+                            addedPlayers.add(offlinePlayer.getName());
+                        }
+                    }
+                    sender.sendMessage("Added " + addedPlayers.size() + " player(s) to team " + team.getName() + ": " + stringCollectionToString(addedPlayers));
+                }
+            } else if (args[1].equalsIgnoreCase("leave")) {
+                if (!(sender instanceof Player) && args.length < 3) {
+                    sender.sendMessage(ChatColor.RED + "/scoreboard teams leave [player...]");
+                    return false;
+                }
+                Set<String> left = new HashSet<String>();
+                Set<String> noTeam = new HashSet<String>();
+                if ((sender instanceof Player) && args.length == 2) {
+                    Team team = mainScoreboard.getPlayerTeam((Player) sender);
+                    if (team != null) {
+                        team.removePlayer((Player) sender);
+                        left.add(sender.getName());
+                    } else {
+                        noTeam.add(sender.getName());
+                    }
+                } else {
+                    for (int i = 2; i < args.length; i++) {
+                        String playerName = args[i];
+                        OfflinePlayer offlinePlayer;
+                        Player player = Bukkit.getPlayerExact(playerName);
+                        if (player != null) {
+                            offlinePlayer = player;
+                        } else {
+                            offlinePlayer = Bukkit.getOfflinePlayer(playerName);
+                        }
+                        Team team = mainScoreboard.getPlayerTeam(offlinePlayer);
+                        if (team != null) {
+                            team.removePlayer(offlinePlayer);
+                            left.add(offlinePlayer.getName());
+                        } else {
+                            noTeam.add(offlinePlayer.getName());
+                        }
+                    }
+                }
+                if (!left.isEmpty()) {
+                    sender.sendMessage("Removed " + left.size() + " player(s) from their teams: " + stringCollectionToString(left));
+                }
+                if (!noTeam.isEmpty()) {
+                    sender.sendMessage("Could not remove " + noTeam.size() + " player(s) from their teams: " + stringCollectionToString(noTeam));
+                }
+            } else if (args[1].equalsIgnoreCase("option")) {
+                if (args.length != 4 && args.length != 5) {
+                    sender.sendMessage(ChatColor.RED + "/scoreboard teams option <team> <friendlyfire|color|seefriendlyinvisibles> <value>");
+                    return false;
+                }
+                String teamName = args[2];
+                Team team = mainScoreboard.getTeam(teamName);
+                if (team == null) {
+                    sender.sendMessage(ChatColor.RED + "No team was found by the name '" + teamName + "'");
+                    return false;
+                }
+                String option = args[3].toLowerCase();
+                if (!option.equals("friendlyfire") && !option.equals("color") && !option.equals("seefriendlyinvisibles")) {
+                    sender.sendMessage(ChatColor.RED + "/scoreboard teams option <team> <friendlyfire|color|seefriendlyinvisibles> <value>");
+                    return false;
+                }
+                if (args.length == 4) {
+                    if (option.equals("color")) {
+                        sender.sendMessage(ChatColor.RED + "Valid values for option color are: " + stringCollectionToString(TEAMS_OPTION_COLOR.keySet()));
+                    } else {
+                        sender.sendMessage(ChatColor.RED + "Valid values for option " + option + " are: true and false");
+                    }
+                } else {
+                    String value = args[4].toLowerCase();
+                    if (option.equals("color")) {
+                        ChatColor color = TEAMS_OPTION_COLOR.get(value);
+                        if (color == null) {
+                            sender.sendMessage(ChatColor.RED + "Valid values for option color are: " + stringCollectionToString(TEAMS_OPTION_COLOR.keySet()));
+                            return false;
+                        }
+                        team.setPrefix(color.toString());
+                        team.setSuffix(ChatColor.RESET.toString());
+                    } else {
+                        if (!value.equals("true") && !value.equals("false")) {
+                            sender.sendMessage(ChatColor.RED + "Valid values for option " + option + " are: true and false");
+                            return false;
+                        }
+                        if (option.equals("friendlyfire")) {
+                            team.setAllowFriendlyFire(value.equals("true"));
+                        } else {
+                            team.setCanSeeFriendlyInvisibles(value.equals("true"));
+                        }
+                    }
+                    sender.sendMessage("Set option " + option + " for team " + team.getName() + " to " + value);
+                }
+            }
+        } else {
+            sender.sendMessage(ChatColor.RED + "Usage: /scoreboard <objectives|players|teams>");
+            return false;
+        }
+        return true;
+    }
+
+    @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {
+        Validate.notNull(sender, "Sender cannot be null");
+        Validate.notNull(args, "Arguments cannot be null");
+        Validate.notNull(alias, "Alias cannot be null");
+
+        if (args.length == 1) {
+            return StringUtil.copyPartialMatches(args[0], MAIN_CHOICES, new ArrayList<String>());
+        }
+        if (args.length > 1) {
+            if (args[0].equalsIgnoreCase("objectives")) {
+                if (args.length == 2) {
+                    return StringUtil.copyPartialMatches(args[1], OBJECTIVES_CHOICES, new ArrayList<String>());
+                }
+                if (args[1].equalsIgnoreCase("add")) {
+                    if (args.length == 4) {
+                        return StringUtil.copyPartialMatches(args[3], OBJECTIVES_CRITERIA, new ArrayList<String>());
+                    }
+                } else if (args[1].equalsIgnoreCase("remove")) {
+                    if (args.length == 3) {
+                        return StringUtil.copyPartialMatches(args[2], this.getCurrentObjectives(), new ArrayList<String>());
+                    }
+                } else if (args[1].equalsIgnoreCase("setdisplay")) {
+                    if (args.length == 3) {
+                        return StringUtil.copyPartialMatches(args[2], OBJECTIVES_DISPLAYSLOT.keySet(), new ArrayList<String>());
+                    }
+                    if (args.length == 4) {
+                        return StringUtil.copyPartialMatches(args[3], this.getCurrentObjectives(), new ArrayList<String>());
+                    }
+                }
+            } else if (args[0].equalsIgnoreCase("players")) {
+                if (args.length == 2) {
+                    return StringUtil.copyPartialMatches(args[1], PLAYERS_CHOICES, new ArrayList<String>());
+                }
+                if (args[1].equalsIgnoreCase("set") || args[1].equalsIgnoreCase("add") || args[1].equalsIgnoreCase("remove")) {
+                    if (args.length == 3) {
+                        return super.tabComplete(sender, alias, args);
+                    }
+                    if (args.length == 4) {
+                        return StringUtil.copyPartialMatches(args[3], this.getCurrentObjectives(), new ArrayList<String>());
+                    }
+                } else {
+                    if (args.length == 3) {
+                        return StringUtil.copyPartialMatches(args[2], this.getCurrentEntries(), new ArrayList<String>());
+                    }
+                }
+            } else if (args[0].equalsIgnoreCase("teams")) {
+                if (args.length == 2) {
+                    return StringUtil.copyPartialMatches(args[1], TEAMS_CHOICES, new ArrayList<String>());
+                }
+                if (args[1].equalsIgnoreCase("join")) {
+                    if (args.length == 3) {
+                        return StringUtil.copyPartialMatches(args[2], this.getCurrentTeams(), new ArrayList<String>());
+                    }
+                    if (args.length >= 4) {
+                        return super.tabComplete(sender, alias, args);
+                    }
+                } else if (args[1].equalsIgnoreCase("leave")) {
+                    return super.tabComplete(sender, alias, args);
+                } else if (args[1].equalsIgnoreCase("option")) {
+                    if (args.length == 3) {
+                        return StringUtil.copyPartialMatches(args[2], this.getCurrentTeams(), new ArrayList<String>());
+                    }
+                    if (args.length == 4) {
+                        return StringUtil.copyPartialMatches(args[3], TEAMS_OPTION_CHOICES, new ArrayList<String>());
+                    }
+                    if (args.length == 5) {
+                        if (args[3].equalsIgnoreCase("color")) {
+                            return StringUtil.copyPartialMatches(args[4], TEAMS_OPTION_COLOR.keySet(), new ArrayList<String>());
+                        } else {
+                            return StringUtil.copyPartialMatches(args[4], BOOLEAN, new ArrayList<String>());
+                        }
+                    }
+                } else {
+                    if (args.length == 3) {
+                        return StringUtil.copyPartialMatches(args[2], this.getCurrentTeams(), new ArrayList<String>());
+                    }
+                }
+            }
+        }
+
+        return ImmutableList.of();
+    }
+
+    private static String offlinePlayerSetToString(Set<OfflinePlayer> set) {
+        StringBuilder string = new StringBuilder();
+        String lastValue = null;
+        for (OfflinePlayer value : set) {
+            string.append(lastValue = value.getName()).append(", ");
+        }
+        string.delete(string.length() - 2, Integer.MAX_VALUE);
+        if (string.length() != lastValue.length()) {
+            string.insert(string.length() - lastValue.length(), "and ");
+        }
+        return string.toString();
+
+    }
+
+    private static String stringCollectionToString(Collection<String> set) {
+        StringBuilder string = new StringBuilder();
+        String lastValue = null;
+        for (String value : set) {
+            string.append(lastValue = value).append(", ");
+        }
+        string.delete(string.length() - 2, Integer.MAX_VALUE);
+        if (string.length() != lastValue.length()) {
+            string.insert(string.length() - lastValue.length(), "and ");
+        }
+        return string.toString();
+    }
+
+    private List<String> getCurrentObjectives() {
+        List<String> list = new ArrayList<String>();
+        for (Objective objective : Bukkit.getScoreboardManager().getMainScoreboard().getObjectives()) {
+            list.add(objective.getName());
+        }
+        Collections.sort(list, String.CASE_INSENSITIVE_ORDER);
+        return list;
+    }
+
+    private List<String> getCurrentEntries() {
+        List<String> list = new ArrayList<String>();
+        for (String entry : Bukkit.getScoreboardManager().getMainScoreboard().getEntries()) {
+            list.add(entry);
+        }
+        Collections.sort(list, String.CASE_INSENSITIVE_ORDER);
+        return list;
+    }
+
+    private List<String> getCurrentTeams() {
+        List<String> list = new ArrayList<String>();
+        for (Team team : Bukkit.getScoreboardManager().getMainScoreboard().getTeams()) {
+            list.add(team.getName());
+        }
+        Collections.sort(list, String.CASE_INSENSITIVE_ORDER);
+        return list;
+    }
+}
diff --git a/src/main/java/org/bukkit/command/defaults/SeedCommand.java b/src/main/java/org/bukkit/command/defaults/SeedCommand.java
new file mode 100644
index 0000000..442cd21
--- /dev/null
+++ b/src/main/java/org/bukkit/command/defaults/SeedCommand.java
@@ -0,0 +1,42 @@
+package org.bukkit.command.defaults;
+
+import java.util.List;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.Bukkit;
+import org.bukkit.command.CommandSender;
+import org.bukkit.entity.Player;
+
+import com.google.common.collect.ImmutableList;
+
+@Deprecated
+public class SeedCommand extends VanillaCommand {
+    public SeedCommand() {
+        super("seed");
+        this.description = "Shows the world seed";
+        this.usageMessage = "/seed";
+        this.setPermission("bukkit.command.seed");
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String commandLabel, String[] args) {
+        if (!testPermission(sender)) return true;
+        long seed;
+        if (sender instanceof Player) {
+            seed = ((Player) sender).getWorld().getSeed();
+        } else {
+            seed = Bukkit.getWorlds().get(0).getSeed();
+        }
+        sender.sendMessage("Seed: " + seed);
+        return true;
+    }
+
+    @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {
+        Validate.notNull(sender, "Sender cannot be null");
+        Validate.notNull(args, "Arguments cannot be null");
+        Validate.notNull(alias, "Alias cannot be null");
+
+        return ImmutableList.of();
+    }
+}
diff --git a/src/main/java/org/bukkit/command/defaults/SetIdleTimeoutCommand.java b/src/main/java/org/bukkit/command/defaults/SetIdleTimeoutCommand.java
new file mode 100644
index 0000000..bd7c853
--- /dev/null
+++ b/src/main/java/org/bukkit/command/defaults/SetIdleTimeoutCommand.java
@@ -0,0 +1,54 @@
+package org.bukkit.command.defaults;
+
+import com.google.common.collect.ImmutableList;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.Bukkit;
+import org.bukkit.ChatColor;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+
+import java.util.List;
+
+@Deprecated
+public class SetIdleTimeoutCommand extends VanillaCommand {
+
+    public SetIdleTimeoutCommand() {
+        super("setidletimeout");
+        this.description = "Sets the server's idle timeout";
+        this.usageMessage = "/setidletimeout <Minutes until kick>";
+        this.setPermission("bukkit.command.setidletimeout");
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
+        if (!testPermission(sender)) return true;
+
+        if (args.length == 1) {
+            int minutes;
+
+            try {
+                minutes = getInteger(sender, args[0], 0, Integer.MAX_VALUE, true);
+            } catch (NumberFormatException ex) {
+                sender.sendMessage(ex.getMessage());
+                return true;
+            }
+
+            Bukkit.getServer().setIdleTimeout(minutes);
+
+            Command.broadcastCommandMessage(sender, "Successfully set the idle timeout to " + minutes + " minutes.");
+            return true;
+        }
+        sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
+        return false;
+    }
+
+    @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args) {
+        Validate.notNull(sender, "Sender cannot be null");
+        Validate.notNull(args, "Arguments cannot be null");
+        Validate.notNull(alias, "Alias cannot be null");
+
+        return ImmutableList.of();
+    }
+}
diff --git a/src/main/java/org/bukkit/command/defaults/SetWorldSpawnCommand.java b/src/main/java/org/bukkit/command/defaults/SetWorldSpawnCommand.java
new file mode 100644
index 0000000..32bb8e4
--- /dev/null
+++ b/src/main/java/org/bukkit/command/defaults/SetWorldSpawnCommand.java
@@ -0,0 +1,80 @@
+package org.bukkit.command.defaults;
+
+import com.google.common.collect.ImmutableList;
+import org.apache.commons.lang3.Validate;
+import org.bukkit.Bukkit;
+import org.bukkit.ChatColor;
+import org.bukkit.Location;
+import org.bukkit.World;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.entity.Player;
+
+import java.util.List;
+
+@Deprecated
+public class SetWorldSpawnCommand extends VanillaCommand {
+
+    public SetWorldSpawnCommand() {
+        super("setworldspawn");
+        this.description = "Sets a worlds's spawn point. If no coordinates are specified, the player's coordinates will be used.";
+        this.usageMessage = "/setworldspawn OR /setworldspawn <x> <y> <z>";
+        this.setPermission("bukkit.command.setworldspawn");
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
+        if (!testPermission(sender)) return true;
+
+        Player player = null;
+        World world;
+        if (sender instanceof Player) {
+            player = (Player) sender;
+            world = player.getWorld();
+        } else {
+            world = Bukkit.getWorlds().get(0);
+        }
+
+        final int x, y, z;
+
+        if (args.length == 0) {
+            if (player == null) {
+                sender.sendMessage("You can only perform this command as a player");
+                return true;
+            }
+
+            Location location = player.getLocation();
+
+            x = location.getBlockX();
+            y = location.getBlockY();
+            z = location.getBlockZ();
+        } else if (args.length == 3) {
+            try {
+                x = getInteger(sender, args[0], MIN_COORD, MAX_COORD, true);
+                y = getInteger(sender, args[1], 0, world.getMaxHeight(), true);
+                z = getInteger(sender, args[2], MIN_COORD, MAX_COORD, true);
+            } catch (NumberFormatException ex) {
+                sender.sendMessage(ex.getMessage());
+                return true;
+            }
+        } else {
+            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
+            return false;
+        }
+
+        world.setSpawnLocation(x, y, z);
+
+        Command.broadcastCommandMessage(sender, "Set world " + world.getName() + "'s spawnpoint to (" + x + ", " + y + ", " + z + ")");
+        return true;
+
+    }
+
+    @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args) {
+        Validate.notNull(sender, "Sender cannot be null");
+        Validate.notNull(args, "Arguments cannot be null");
+        Validate.notNull(alias, "Alias cannot be null");
+
+        return ImmutableList.of();
+    }
+}
diff --git a/src/main/java/org/bukkit/command/defaults/SpawnpointCommand.java b/src/main/java/org/bukkit/command/defaults/SpawnpointCommand.java
new file mode 100644
index 0000000..8124148
--- /dev/null
+++ b/src/main/java/org/bukkit/command/defaults/SpawnpointCommand.java
@@ -0,0 +1,88 @@
+package org.bukkit.command.defaults;
+
+import com.google.common.collect.ImmutableList;
+import org.apache.commons.lang3.Validate;
+import org.bukkit.Bukkit;
+import org.bukkit.ChatColor;
+import org.bukkit.Location;
+import org.bukkit.World;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.entity.Player;
+
+import java.util.List;
+
+@Deprecated
+public class SpawnpointCommand extends VanillaCommand {
+
+    public SpawnpointCommand() {
+        super("spawnpoint");
+        this.description = "Sets a player's spawn point";
+        this.usageMessage = "/spawnpoint OR /spawnpoint <player> OR /spawnpoint <player> <x> <y> <z>";
+        this.setPermission("bukkit.command.spawnpoint");
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
+        if (!testPermission(sender)) return true;
+
+        Player player;
+
+        if (args.length == 0) {
+            if (sender instanceof Player) {
+                player = (Player) sender;
+            } else {
+                sender.sendMessage("Please provide a player!");
+                return true;
+            }
+        } else {
+            player = Bukkit.getPlayerExact(args[0]);
+            if (player == null) {
+                sender.sendMessage("Can't find player " + args[0]);
+                return true;
+            }
+        }
+
+        World world = player.getWorld();
+
+        if (args.length == 4) {
+            if (world != null) {
+                int pos = 1;
+                final int x, y, z;
+                try {
+                    x = getInteger(sender, args[pos++], MIN_COORD, MAX_COORD, true);
+                    y = getInteger(sender, args[pos++], 0, world.getMaxHeight());
+                    z = getInteger(sender, args[pos], MIN_COORD, MAX_COORD, true);
+                } catch(NumberFormatException ex) {
+                    sender.sendMessage(ex.getMessage());
+                    return true;
+                }
+
+                player.setBedSpawnLocation(new Location(world, x, y, z), true);
+                Command.broadcastCommandMessage(sender, "Set " + player.getDisplayName() + "'s spawnpoint to " + x + ", " + y + ", " + z);
+            }
+        } else if (args.length <= 1) {
+            Location location = player.getLocation();
+            player.setBedSpawnLocation(location, true);
+            Command.broadcastCommandMessage(sender, "Set " + player.getDisplayName() + "'s spawnpoint to " + location.getX() + ", " + location.getY() + ", " + location.getZ());
+        } else {
+            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
+            return false;
+        }
+
+        return true;
+    }
+
+    @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args) {
+        Validate.notNull(sender, "Sender cannot be null");
+        Validate.notNull(args, "Arguments cannot be null");
+        Validate.notNull(alias, "Alias cannot be null");
+
+        if (args.length == 1) {
+            return super.tabComplete(sender, alias, args);
+        }
+
+        return ImmutableList.of();
+    }
+}
diff --git a/src/main/java/org/bukkit/command/defaults/StopCommand.java b/src/main/java/org/bukkit/command/defaults/StopCommand.java
new file mode 100644
index 0000000..a81a9c9
--- /dev/null
+++ b/src/main/java/org/bukkit/command/defaults/StopCommand.java
@@ -0,0 +1,49 @@
+package org.bukkit.command.defaults;
+
+import java.util.List;
+
+import org.apache.commons.lang3.StringUtils;
+import org.apache.commons.lang3.Validate;
+
+import org.bukkit.Bukkit;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.entity.Player;
+
+import com.google.common.collect.ImmutableList;
+
+@Deprecated
+public class StopCommand extends VanillaCommand {
+    public StopCommand() {
+        super("stop");
+        this.description = "Stops the server with optional reason";
+        this.usageMessage = "/stop [reason]";
+        this.setPermission("bukkit.command.stop");
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
+        if (!testPermission(sender)) return true;
+
+        Command.broadcastCommandMessage(sender, "Stopping the server..");
+        Bukkit.shutdown();
+
+        String reason = this.createString(args, 0);
+        if (StringUtils.isNotEmpty(reason)) {
+            for (Player player : Bukkit.getOnlinePlayers()) {
+                player.kickPlayer(reason);
+            }
+        }
+
+        return true;
+    }
+
+    @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {
+        Validate.notNull(sender, "Sender cannot be null");
+        Validate.notNull(args, "Arguments cannot be null");
+        Validate.notNull(alias, "Alias cannot be null");
+
+        return ImmutableList.of();
+    }
+}
diff --git a/src/main/java/org/bukkit/command/defaults/TeleportCommand.java b/src/main/java/org/bukkit/command/defaults/TeleportCommand.java
new file mode 100644
index 0000000..ec0ef90
--- /dev/null
+++ b/src/main/java/org/bukkit/command/defaults/TeleportCommand.java
@@ -0,0 +1,125 @@
+package org.bukkit.command.defaults;
+
+import java.util.List;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.Bukkit;
+import org.bukkit.ChatColor;
+import org.bukkit.Location;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.entity.Player;
+import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;
+
+import com.google.common.collect.ImmutableList;
+
+@Deprecated
+public class TeleportCommand extends VanillaCommand {
+
+    public TeleportCommand() {
+        super("tp");
+        this.description = "Teleports the given player (or yourself) to another player or coordinates";
+        this.usageMessage = "/tp [player] <target> and/or <x> <y> <z>";
+        this.setPermission("bukkit.command.teleport");
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
+        if (!testPermission(sender)) return true;
+        if (args.length < 1 || args.length > 4) {
+            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
+            return false;
+        }
+
+        Player player;
+
+        if (args.length == 1 || args.length == 3) {
+            if (sender instanceof Player) {
+                player = (Player) sender;
+            } else {
+                sender.sendMessage("Please provide a player!");
+                return true;
+            }
+        } else {
+            player = Bukkit.getPlayerExact(args[0]);
+        }
+
+        if (player == null) {
+            sender.sendMessage("Player not found: " + args[0]);
+            return true;
+        }
+
+        if (args.length < 3) {
+            Player target = Bukkit.getPlayerExact(args[args.length - 1]);
+            if (target == null) {
+                sender.sendMessage("Can't find player " + args[args.length - 1] + ". No tp.");
+                return true;
+            }
+            player.teleport(target, TeleportCause.COMMAND);
+            Command.broadcastCommandMessage(sender, "Teleported " + player.getDisplayName() + " to " + target.getDisplayName());
+        } else if (player.getWorld() != null) {
+            Location playerLocation = player.getLocation();
+            double x = getCoordinate(sender, playerLocation.getX(), args[args.length - 3]);
+            double y = getCoordinate(sender, playerLocation.getY(), args[args.length - 2], 0, 0);
+            double z = getCoordinate(sender, playerLocation.getZ(), args[args.length - 1]);
+
+            if (x == MIN_COORD_MINUS_ONE || y == MIN_COORD_MINUS_ONE || z == MIN_COORD_MINUS_ONE) {
+                sender.sendMessage("Please provide a valid location!");
+                return true;
+            }
+
+            playerLocation.setX(x);
+            playerLocation.setY(y);
+            playerLocation.setZ(z);
+
+            player.teleport(playerLocation, TeleportCause.COMMAND);
+            Command.broadcastCommandMessage(sender, String.format("Teleported %s to %.2f, %.2f, %.2f", player.getDisplayName(), x, y, z));
+        }
+        return true;
+    }
+
+    private double getCoordinate(CommandSender sender, double current, String input) {
+        return getCoordinate(sender, current, input, MIN_COORD, MAX_COORD);
+    }
+
+    private double getCoordinate(CommandSender sender, double current, String input, int min, int max) {
+        boolean relative = input.startsWith("~");
+        double result = relative ? current : 0;
+
+        if (!relative || input.length() > 1) {
+            boolean exact = input.contains(".");
+            if (relative) input = input.substring(1);
+
+            double testResult = getDouble(sender, input);
+            if (testResult == MIN_COORD_MINUS_ONE) {
+                return MIN_COORD_MINUS_ONE;
+            }
+            result += testResult;
+
+            if (!exact && !relative) result += 0.5f;
+        }
+        if (min != 0 || max != 0) {
+            if (result < min) {
+                result = MIN_COORD_MINUS_ONE;
+            }
+
+            if (result > max) {
+                result = MIN_COORD_MINUS_ONE;
+            }
+        }
+
+        return result;
+    }
+
+    @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {
+        Validate.notNull(sender, "Sender cannot be null");
+        Validate.notNull(args, "Arguments cannot be null");
+        Validate.notNull(alias, "Alias cannot be null");
+
+        if (args.length == 1 || args.length == 2) {
+            return super.tabComplete(sender, alias, args);
+        }
+        return ImmutableList.of();
+    }
+}
diff --git a/src/main/java/org/bukkit/command/defaults/TimeCommand.java b/src/main/java/org/bukkit/command/defaults/TimeCommand.java
new file mode 100644
index 0000000..87e5010
--- /dev/null
+++ b/src/main/java/org/bukkit/command/defaults/TimeCommand.java
@@ -0,0 +1,89 @@
+package org.bukkit.command.defaults;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.Bukkit;
+import org.bukkit.ChatColor;
+import org.bukkit.World;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.util.StringUtil;
+
+import com.google.common.collect.ImmutableList;
+
+@Deprecated
+public class TimeCommand extends VanillaCommand {
+    private static final List<String> TABCOMPLETE_ADD_SET = ImmutableList.of("add", "set");
+    private static final List<String> TABCOMPLETE_DAY_NIGHT = ImmutableList.of("day", "night");
+
+    public TimeCommand() {
+        super("time");
+        this.description = "Changes the time on each world";
+        this.usageMessage = "/time set <value>\n/time add <value>";
+        this.setPermission("bukkit.command.time.add;bukkit.command.time.set");
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
+        if (args.length < 2) {
+            sender.sendMessage(ChatColor.RED + "Incorrect usage. Correct usage:\n" + usageMessage);
+            return false;
+        }
+
+        int value;
+
+        if (args[0].equals("set")) {
+            if (!sender.hasPermission("bukkit.command.time.set")) {
+                sender.sendMessage(ChatColor.RED + "You don't have permission to set the time");
+                return true;
+            }
+
+            if (args[1].equals("day")) {
+                value = 0;
+            } else if (args[1].equals("night")) {
+                value = 12500;
+            } else {
+                value = getInteger(sender, args[1], 0);
+            }
+
+            for (World world : Bukkit.getWorlds()) {
+                world.setTime(value);
+            }
+
+            Command.broadcastCommandMessage(sender, "Set time to " + value);
+        } else if (args[0].equals("add")) {
+            if (!sender.hasPermission("bukkit.command.time.add")) {
+                sender.sendMessage(ChatColor.RED + "You don't have permission to set the time");
+                return true;
+            }
+
+            value = getInteger(sender, args[1], 0);
+
+            for (World world : Bukkit.getWorlds()) {
+                world.setFullTime(world.getFullTime() + value);
+            }
+
+            Command.broadcastCommandMessage(sender, "Added " + value + " to time");
+        } else {
+            sender.sendMessage("Unknown method. Usage: " + usageMessage);
+        }
+
+        return true;
+    }
+
+    @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args) {
+        Validate.notNull(sender, "Sender cannot be null");
+        Validate.notNull(args, "Arguments cannot be null");
+        Validate.notNull(alias, "Alias cannot be null");
+
+        if (args.length == 1) {
+            return StringUtil.copyPartialMatches(args[0], TABCOMPLETE_ADD_SET, new ArrayList<String>(TABCOMPLETE_ADD_SET.size()));
+        } else if (args.length == 2 && args[0].equalsIgnoreCase("set")) {
+            return StringUtil.copyPartialMatches(args[1], TABCOMPLETE_DAY_NIGHT, new ArrayList<String>(TABCOMPLETE_DAY_NIGHT.size()));
+        }
+        return ImmutableList.of();
+    }
+}
diff --git a/src/main/java/org/bukkit/command/defaults/ToggleDownfallCommand.java b/src/main/java/org/bukkit/command/defaults/ToggleDownfallCommand.java
new file mode 100644
index 0000000..1ce2b0c
--- /dev/null
+++ b/src/main/java/org/bukkit/command/defaults/ToggleDownfallCommand.java
@@ -0,0 +1,57 @@
+package org.bukkit.command.defaults;
+
+import java.util.List;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.Bukkit;
+import org.bukkit.ChatColor;
+import org.bukkit.World;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.entity.Player;
+
+import com.google.common.collect.ImmutableList;
+
+@Deprecated
+public class ToggleDownfallCommand extends VanillaCommand {
+    public ToggleDownfallCommand() {
+        super("toggledownfall");
+        this.description = "Toggles rain on/off on a given world";
+        this.usageMessage = "/toggledownfall";
+        this.setPermission("bukkit.command.toggledownfall");
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
+        if (!testPermission(sender)) return true;
+
+        World world = null;
+
+        if (args.length == 1) {
+            world = Bukkit.getWorld(args[0]);
+
+            if (world == null) {
+                sender.sendMessage(ChatColor.RED + "No world exists with the name '" + args[0] + "'");
+                return true;
+            }
+        } else if (sender instanceof Player) {
+            world = ((Player) sender).getWorld();
+        } else {
+            world = Bukkit.getWorlds().get(0);
+        }
+
+        Command.broadcastCommandMessage(sender, "Toggling downfall " + (world.hasStorm() ? "off" : "on") + " for world '" + world.getName() + "'");
+        world.setStorm(!world.hasStorm());
+
+        return true;
+    }
+
+    @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args) throws IllegalArgumentException {
+        Validate.notNull(sender, "Sender cannot be null");
+        Validate.notNull(args, "Arguments cannot be null");
+        Validate.notNull(alias, "Alias cannot be null");
+
+        return ImmutableList.of();
+    }
+}
diff --git a/src/main/java/org/bukkit/command/defaults/VersionCommand.java b/src/main/java/org/bukkit/command/defaults/VersionCommand.java
new file mode 100644
index 0000000..c8ff3a8
--- /dev/null
+++ b/src/main/java/org/bukkit/command/defaults/VersionCommand.java
@@ -0,0 +1,331 @@
+package org.bukkit.command.defaults;
+
+import com.google.common.base.Charsets;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.Bukkit;
+import org.bukkit.ChatColor;
+import org.bukkit.command.CommandSender;
+import org.bukkit.plugin.Plugin;
+import org.bukkit.plugin.PluginDescriptionFile;
+import org.bukkit.util.StringUtil;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.io.Resources;
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.net.URL;
+import java.net.URLEncoder;
+import java.util.HashSet;
+import java.util.Set;
+import java.util.concurrent.locks.ReentrantLock;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import org.json.simple.JSONObject;
+import org.json.simple.parser.JSONParser;
+import org.json.simple.parser.ParseException;
+
+// Paper start
+import java.io.InputStreamReader;
+import java.net.HttpURLConnection;
+// Paper end
+
+public class VersionCommand extends BukkitCommand {
+    public VersionCommand(String name) {
+        super(name);
+
+        this.description = "Gets the version of this server including any plugins in use";
+        this.usageMessage = "/version [plugin name]";
+        this.setPermission("bukkit.command.version");
+        this.setAliases(Arrays.asList("ver", "about"));
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
+        if (!testPermission(sender)) return true;
+
+        if (args.length == 0) {
+            sender.sendMessage("This server is running " + Bukkit.getName() + " version " + Bukkit.getVersion() + " (Implementing API version " + Bukkit.getBukkitVersion() + ")");
+            sendVersion(sender);
+        } else {
+            StringBuilder name = new StringBuilder();
+
+            for (String arg : args) {
+                if (name.length() > 0) {
+                    name.append(' ');
+                }
+
+                name.append(arg);
+            }
+
+            String pluginName = name.toString();
+            Plugin exactPlugin = Bukkit.getPluginManager().getPlugin(pluginName);
+            if (exactPlugin != null) {
+                describeToSender(exactPlugin, sender);
+                return true;
+            }
+
+            boolean found = false;
+            pluginName = pluginName.toLowerCase();
+            for (Plugin plugin : Bukkit.getPluginManager().getPlugins()) {
+                if (plugin.getName().toLowerCase().contains(pluginName)) {
+                    describeToSender(plugin, sender);
+                    found = true;
+                }
+            }
+
+            if (!found) {
+                sender.sendMessage("This server is not running any plugin by that name.");
+                sender.sendMessage("Use /plugins to get a list of plugins.");
+            }
+        }
+        return true;
+    }
+
+    private void describeToSender(Plugin plugin, CommandSender sender) {
+        PluginDescriptionFile desc = plugin.getDescription();
+        sender.sendMessage(ChatColor.GREEN + desc.getName() + ChatColor.WHITE + " version " + ChatColor.GREEN + desc.getVersion());
+
+        if (desc.getDescription() != null) {
+            sender.sendMessage(desc.getDescription());
+        }
+
+        if (desc.getWebsite() != null) {
+            sender.sendMessage("Website: " + ChatColor.GREEN + desc.getWebsite());
+        }
+
+        if (!desc.getAuthors().isEmpty()) {
+            if (desc.getAuthors().size() == 1) {
+                sender.sendMessage("Author: " + getAuthors(desc));
+            } else {
+                sender.sendMessage("Authors: " + getAuthors(desc));
+            }
+        }
+    }
+
+    private String getAuthors(final PluginDescriptionFile desc) {
+        StringBuilder result = new StringBuilder();
+        List<String> authors = desc.getAuthors();
+
+        for (int i = 0; i < authors.size(); i++) {
+            if (result.length() > 0) {
+                result.append(ChatColor.WHITE);
+
+                if (i < authors.size() - 1) {
+                    result.append(", ");
+                } else {
+                    result.append(" and ");
+                }
+            }
+
+            result.append(ChatColor.GREEN);
+            result.append(authors.get(i));
+        }
+
+        return result.toString();
+    }
+
+    @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args) {
+        Validate.notNull(sender, "Sender cannot be null");
+        Validate.notNull(args, "Arguments cannot be null");
+        Validate.notNull(alias, "Alias cannot be null");
+
+        if (args.length == 1) {
+            List<String> completions = new ArrayList<String>();
+            String toComplete = args[0].toLowerCase();
+            for (Plugin plugin : Bukkit.getPluginManager().getPlugins()) {
+                if (StringUtil.startsWithIgnoreCase(plugin.getName(), toComplete)) {
+                    completions.add(plugin.getName());
+                }
+            }
+            return completions;
+        }
+        return ImmutableList.of();
+    }
+
+    private final ReentrantLock versionLock = new ReentrantLock();
+    private boolean hasVersion = false;
+    private String versionMessage = null;
+    private final Set<CommandSender> versionWaiters = new HashSet<CommandSender>();
+    private boolean versionTaskStarted = false;
+    private long lastCheck = 0;
+
+    private void sendVersion(CommandSender sender) {
+        if (hasVersion) {
+            if (System.currentTimeMillis() - lastCheck > 21600000) {
+                lastCheck = System.currentTimeMillis();
+                hasVersion = false;
+            } else {
+                sender.sendMessage(versionMessage);
+                return;
+            }
+        }
+        versionLock.lock();
+        try {
+            if (hasVersion) {
+                sender.sendMessage(versionMessage);
+                return;
+            }
+            versionWaiters.add(sender);
+            sender.sendMessage("Checking version, please wait...");
+            if (!versionTaskStarted) {
+                versionTaskStarted = true;
+                new Thread(new Runnable() {
+
+                    @Override
+                    public void run() {
+                        obtainVersion();
+                    }
+                }).start();
+            }
+        } finally {
+            versionLock.unlock();
+        }
+    }
+
+    // Paper start
+    private void obtainVersion() {
+        String version = Bukkit.getVersion();
+        if (version == null) version = "Custom";
+        // TacoSpigot start
+        if (version.startsWith("git-Torch-")) {
+            String[] parts = version.substring("git-Torch-".length()).split("[-\\s]");
+            // TacoSpigot end
+            int distance = getDistance(null, parts[0]);
+            switch (distance) {
+                case -1:
+                    setVersionMessage("Error obtaining version information");
+                    break;
+                case 0:
+                    setVersionMessage("You are running the latest version");
+                    break;
+                case -2:
+                    setVersionMessage("Unknown version");
+                    break;
+                default:
+                    setVersionMessage("You are " + distance + " commit(s) behind"); // TacoSpigot - version -> commit
+            }
+        } else if (version.startsWith("git-Bukkit-")) {
+            // Paper end
+            version = version.substring("git-Bukkit-".length());
+            int cbVersions = getDistance("craftbukkit", version.substring(0, version.indexOf(' ')));
+            if (cbVersions == -1) {
+                setVersionMessage("Error obtaining version information");
+            } else {
+                if (cbVersions == 0) {
+                    setVersionMessage("You are running the latest version");
+                } else {
+                    setVersionMessage("You are " + cbVersions + " version(s) behind");
+                }
+            }
+        } else {
+            setVersionMessage("Unknown version, custom build?");
+        }
+    }
+
+    private void setVersionMessage(String msg) {
+        lastCheck = System.currentTimeMillis();
+        versionMessage = msg;
+        versionLock.lock();
+        try {
+            hasVersion = true;
+            versionTaskStarted = false;
+            for (CommandSender sender : versionWaiters) {
+                sender.sendMessage(versionMessage);
+            }
+            versionWaiters.clear();
+        } finally {
+            versionLock.unlock();
+        }
+    }
+
+    // Paper start
+    private static int getDistance(String repo, String verInfo) {
+        // TacoSpigot start - remove jenkins check
+        /*
+        try {
+            int currentVer = Integer.decode(verInfo);
+            return getFromJenkins(currentVer);
+        } catch (NumberFormatException ex) {
+            */
+            verInfo = verInfo.replace("\"", "");
+            return getFromRepo("TorchSpigot/Torch", verInfo); // 'PaperMC/Paper' -> 'TacoSpigot/TacoSpigot'
+        //}
+        // TacoSpigot end
+            /*
+            BufferedReader reader = Resources.asCharSource(
+                    new URL("https://hub.spigotmc.org/stash/rest/api/1.0/projects/SPIGOT/repos/" + repo + "/commits?since=" + URLEncoder.encode(hash, "UTF-8") + "&withCounts=true"),
+                    Charsets.UTF_8
+            ).openBufferedStream();
+            try {
+                JSONObject obj = (JSONObject) new JSONParser().parse(reader);
+                return ((Number) obj.get("totalCount")).intValue();
+            } catch (ParseException ex) {
+                ex.printStackTrace();
+                return -1;
+            } finally {
+                reader.close();
+            }
+            */
+    }
+
+    // TacoSpigot start - remove jenkins check
+    /*
+    private static int getFromJenkins(int currentVer) {
+        try {
+            BufferedReader reader = Resources.asCharSource(
+                    new URL("https://ci.destroystokyo.com/job/PaperSpigot/lastSuccessfulBuild/buildNumber"), // Paper
+                    Charsets.UTF_8
+            ).openBufferedStream();
+            try {
+                int newVer = Integer.decode(reader.readLine());
+                return newVer - currentVer;
+            } catch (NumberFormatException ex) {
+                ex.printStackTrace();
+                return -2;
+            } finally {
+                reader.close();
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+            return -1;
+        }
+    }
+    */
+    // TacoSpigot end
+
+    // Contributed by Techcable <Techcable@outlook.com> in GH PR #65
+    private static final String BRANCH = "master";
+    private static int getFromRepo(String repo, String hash) {
+        try {
+            HttpURLConnection connection = (HttpURLConnection) new URL("https://api.github.com/repos/" + repo + "/compare/" + BRANCH + "..." + hash).openConnection();
+            connection.connect();
+            if (connection.getResponseCode() == HttpURLConnection.HTTP_NOT_FOUND) return -2; // Unknown commit
+            try (
+                    BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), Charsets.UTF_8))
+            ) {
+                JSONObject obj = (JSONObject) new JSONParser().parse(reader);
+                String status = (String) obj.get("status");
+                switch (status) {
+                    case "identical":
+                        return 0;
+                    case "behind":
+                        return ((Number) obj.get("behind_by")).intValue();
+                    default:
+                        return -2;
+                }
+            } catch (ParseException | NumberFormatException e) {
+                e.printStackTrace();
+                return -1;
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+            return -1;
+        }
+    }
+    // Paper end
+}
diff --git a/src/main/java/org/bukkit/command/defaults/WeatherCommand.java b/src/main/java/org/bukkit/command/defaults/WeatherCommand.java
new file mode 100644
index 0000000..a349881
--- /dev/null
+++ b/src/main/java/org/bukkit/command/defaults/WeatherCommand.java
@@ -0,0 +1,74 @@
+package org.bukkit.command.defaults;
+
+import com.google.common.collect.ImmutableList;
+import org.apache.commons.lang3.Validate;
+import org.bukkit.Bukkit;
+import org.bukkit.ChatColor;
+import org.bukkit.World;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.util.StringUtil;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Random;
+
+@Deprecated
+public class WeatherCommand extends VanillaCommand {
+    private static final List<String> WEATHER_TYPES = ImmutableList.of("clear", "rain", "thunder");
+
+    public WeatherCommand() {
+        super("weather");
+        this.description = "Changes the weather";
+        this.usageMessage = "/weather <clear/rain/thunder> [duration in seconds]";
+        this.setPermission("bukkit.command.weather");
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
+        if (!testPermission(sender)) return true;
+        if (args.length == 0) {
+            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
+            return false;
+        }
+
+        int duration = (300 + new Random().nextInt(600)) * 20;
+        if (args.length >= 2) {
+            duration = getInteger(sender, args[1], 1, 1000000) * 20;
+        }
+
+        World world = Bukkit.getWorlds().get(0);
+
+        world.setWeatherDuration(duration);
+        world.setThunderDuration(duration);
+
+        if ("clear".equalsIgnoreCase(args[0])) {
+            world.setStorm(false);
+            world.setThundering(false);
+            Command.broadcastCommandMessage(sender, "Changed weather to clear for " + (duration / 20) + " seconds.");
+        } else if ("rain".equalsIgnoreCase(args[0])) {
+            world.setStorm(true);
+            world.setThundering(false);
+            Command.broadcastCommandMessage(sender, "Changed weather to rainy for " + (duration / 20) + " seconds.");
+        } else if ("thunder".equalsIgnoreCase(args[0])) {
+            world.setStorm(true);
+            world.setThundering(true);
+            Command.broadcastCommandMessage(sender, "Changed weather to thundering " + (duration / 20) + " seconds.");
+        }
+
+        return true;
+    }
+
+    @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args) {
+        Validate.notNull(sender, "Sender cannot be null");
+        Validate.notNull(args, "Arguments cannot be null");
+        Validate.notNull(alias, "Alias cannot be null");
+
+        if (args.length == 1) {
+            return StringUtil.copyPartialMatches(args[0], WEATHER_TYPES, new ArrayList<String>(WEATHER_TYPES.size()));
+        }
+
+        return ImmutableList.of();
+    }
+}
diff --git a/src/main/java/org/bukkit/command/defaults/WhitelistCommand.java b/src/main/java/org/bukkit/command/defaults/WhitelistCommand.java
new file mode 100644
index 0000000..d249875
--- /dev/null
+++ b/src/main/java/org/bukkit/command/defaults/WhitelistCommand.java
@@ -0,0 +1,128 @@
+package org.bukkit.command.defaults;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.Bukkit;
+import org.bukkit.ChatColor;
+import org.bukkit.OfflinePlayer;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.util.StringUtil;
+
+import com.google.common.collect.ImmutableList;
+
+@Deprecated
+public class WhitelistCommand extends VanillaCommand {
+    private static final List<String> WHITELIST_SUBCOMMANDS = ImmutableList.of("add", "remove", "on", "off", "list", "reload");
+
+    public WhitelistCommand() {
+        super("whitelist");
+        this.description = "Manages the list of players allowed to use this server";
+        this.usageMessage = "/whitelist (add|remove) <player>\n/whitelist (on|off|list|reload)";
+        this.setPermission("bukkit.command.whitelist.reload;bukkit.command.whitelist.enable;bukkit.command.whitelist.disable;bukkit.command.whitelist.list;bukkit.command.whitelist.add;bukkit.command.whitelist.remove");
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
+        if (!testPermission(sender)) return true;
+
+        if (args.length == 1) {
+            if (args[0].equalsIgnoreCase("reload")) {
+                if (badPerm(sender, "reload")) return true;
+
+                Bukkit.reloadWhitelist();
+                Command.broadcastCommandMessage(sender, "Reloaded white-list from file");
+                return true;
+            } else if (args[0].equalsIgnoreCase("on")) {
+                if (badPerm(sender, "enable")) return true;
+
+                Bukkit.setWhitelist(true);
+                Command.broadcastCommandMessage(sender, "Turned on white-listing");
+                return true;
+            } else if (args[0].equalsIgnoreCase("off")) {
+                if (badPerm(sender, "disable")) return true;
+
+                Bukkit.setWhitelist(false);
+                Command.broadcastCommandMessage(sender, "Turned off white-listing");
+                return true;
+            } else if (args[0].equalsIgnoreCase("list")) {
+                if (badPerm(sender, "list")) return true;
+
+                StringBuilder result = new StringBuilder();
+
+                for (OfflinePlayer player : Bukkit.getWhitelistedPlayers()) {
+                    if (result.length() > 0) {
+                        result.append(", ");
+                    }
+
+                    result.append(player.getName());
+                }
+
+                sender.sendMessage("White-listed players: " + result.toString());
+                return true;
+            }
+        } else if (args.length == 2) {
+            if (args[0].equalsIgnoreCase("add")) {
+                if (badPerm(sender, "add")) return true;
+
+                Bukkit.getOfflinePlayer(args[1]).setWhitelisted(true);
+
+                Command.broadcastCommandMessage(sender, "Added " + args[1] + " to white-list");
+                return true;
+            } else if (args[0].equalsIgnoreCase("remove")) {
+                if (badPerm(sender, "remove")) return true;
+
+                Bukkit.getOfflinePlayer(args[1]).setWhitelisted(false);
+
+                Command.broadcastCommandMessage(sender, "Removed " + args[1] + " from white-list");
+                return true;
+            }
+        }
+
+        sender.sendMessage(ChatColor.RED + "Correct command usage:\n" + usageMessage);
+        return false;
+    }
+
+    private boolean badPerm(CommandSender sender, String perm) {
+        if (!sender.hasPermission("bukkit.command.whitelist." + perm)) {
+            sender.sendMessage(ChatColor.RED + "You do not have permission to perform this action.");
+            return true;
+        }
+
+        return false;
+    }
+
+    @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args) {
+        Validate.notNull(sender, "Sender cannot be null");
+        Validate.notNull(args, "Arguments cannot be null");
+        Validate.notNull(alias, "Alias cannot be null");
+
+        if (args.length == 1) {
+            return StringUtil.copyPartialMatches(args[0], WHITELIST_SUBCOMMANDS, new ArrayList<String>(WHITELIST_SUBCOMMANDS.size()));
+        } else if (args.length == 2) {
+            if (args[0].equalsIgnoreCase("add")) {
+                List<String> completions = new ArrayList<String>();
+                for (OfflinePlayer player : Bukkit.getOnlinePlayers()) { // Spigot - well maybe sometimes you haven't turned the whitelist on just yet.
+                    String name = player.getName();
+                    if (StringUtil.startsWithIgnoreCase(name, args[1]) && !player.isWhitelisted()) {
+                        completions.add(name);
+                    }
+                }
+                return completions;
+            } else if (args[0].equalsIgnoreCase("remove")) {
+                List<String> completions = new ArrayList<String>();
+                for (OfflinePlayer player : Bukkit.getWhitelistedPlayers()) {
+                    String name = player.getName();
+                    if (StringUtil.startsWithIgnoreCase(name, args[1])) {
+                        completions.add(name);
+                    }
+                }
+                return completions;
+            }
+        }
+        return ImmutableList.of();
+    }
+}
diff --git a/src/main/java/org/bukkit/configuration/MemoryConfiguration.java b/src/main/java/org/bukkit/configuration/MemoryConfiguration.java
new file mode 100644
index 0000000..670e4cd
--- /dev/null
+++ b/src/main/java/org/bukkit/configuration/MemoryConfiguration.java
@@ -0,0 +1,79 @@
+package org.bukkit.configuration;
+
+import java.util.Map;
+
+import org.apache.commons.lang3.Validate;
+
+/**
+ * This is a {@link Configuration} implementation that does not save or load
+ * from any source, and stores all values in memory only.
+ * This is useful for temporary Configurations for providing defaults.
+ */
+public class MemoryConfiguration extends MemorySection implements Configuration {
+    protected Configuration defaults;
+    protected MemoryConfigurationOptions options;
+
+    /**
+     * Creates an empty {@link MemoryConfiguration} with no default values.
+     */
+    public MemoryConfiguration() {}
+
+    /**
+     * Creates an empty {@link MemoryConfiguration} using the specified {@link
+     * Configuration} as a source for all default values.
+     *
+     * @param defaults Default value provider
+     * @throws IllegalArgumentException Thrown if defaults is null
+     */
+    public MemoryConfiguration(Configuration defaults) {
+        this.defaults = defaults;
+    }
+
+    @Override
+    public void addDefault(String path, Object value) {
+        Validate.notNull(path, "Path may not be null");
+
+        if (defaults == null) {
+            defaults = new MemoryConfiguration();
+        }
+
+        defaults.set(path, value);
+    }
+
+    public void addDefaults(Map<String, Object> defaults) {
+        Validate.notNull(defaults, "Defaults may not be null");
+
+        for (Map.Entry<String, Object> entry : defaults.entrySet()) {
+            addDefault(entry.getKey(), entry.getValue());
+        }
+    }
+
+    public void addDefaults(Configuration defaults) {
+        Validate.notNull(defaults, "Defaults may not be null");
+
+        addDefaults(defaults.getValues(true));
+    }
+
+    public void setDefaults(Configuration defaults) {
+        Validate.notNull(defaults, "Defaults may not be null");
+
+        this.defaults = defaults;
+    }
+
+    public Configuration getDefaults() {
+        return defaults;
+    }
+
+    @Override
+    public ConfigurationSection getParent() {
+        return null;
+    }
+
+    public MemoryConfigurationOptions options() {
+        if (options == null) {
+            options = new MemoryConfigurationOptions(this);
+        }
+
+        return options;
+    }
+}
diff --git a/src/main/java/org/bukkit/configuration/MemorySection.java b/src/main/java/org/bukkit/configuration/MemorySection.java
new file mode 100644
index 0000000..008190e
--- /dev/null
+++ b/src/main/java/org/bukkit/configuration/MemorySection.java
@@ -0,0 +1,828 @@
+package org.bukkit.configuration;
+
+import static org.bukkit.util.NumberConversions.*;
+
+import java.util.ArrayList;
+import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.Color;
+import org.bukkit.OfflinePlayer;
+import org.bukkit.inventory.ItemStack;
+import org.bukkit.util.Vector;
+
+/**
+ * A type of {@link ConfigurationSection} that is stored in memory.
+ */
+public class MemorySection implements ConfigurationSection {
+    protected final Map<String, Object> map = new LinkedHashMap<String, Object>();
+    private final Configuration root;
+    private final ConfigurationSection parent;
+    private final String path;
+    private final String fullPath;
+
+    /**
+     * Creates an empty MemorySection for use as a root {@link Configuration}
+     * section.
+     * <p>
+     * Note that calling this without being yourself a {@link Configuration}
+     * will throw an exception!
+     *
+     * @throws IllegalStateException Thrown if this is not a {@link
+     *     Configuration} root.
+     */
+    protected MemorySection() {
+        if (!(this instanceof Configuration)) {
+            throw new IllegalStateException("Cannot construct a root MemorySection when not a Configuration");
+        }
+
+        this.path = "";
+        this.fullPath = "";
+        this.parent = null;
+        this.root = (Configuration) this;
+    }
+
+    /**
+     * Creates an empty MemorySection with the specified parent and path.
+     *
+     * @param parent Parent section that contains this own section.
+     * @param path Path that you may access this section from via the root
+     *     {@link Configuration}.
+     * @throws IllegalArgumentException Thrown is parent or path is null, or
+     *     if parent contains no root Configuration.
+     */
+    protected MemorySection(ConfigurationSection parent, String path) {
+        Validate.notNull(parent, "Parent cannot be null");
+        Validate.notNull(path, "Path cannot be null");
+
+        this.path = path;
+        this.parent = parent;
+        this.root = parent.getRoot();
+
+        Validate.notNull(root, "Path cannot be orphaned");
+
+        this.fullPath = createPath(parent, path);
+    }
+
+    public Set<String> getKeys(boolean deep) {
+        Set<String> result = new LinkedHashSet<String>();
+
+        Configuration root = getRoot();
+        if (root != null && root.options().copyDefaults()) {
+            ConfigurationSection defaults = getDefaultSection();
+
+            if (defaults != null) {
+                result.addAll(defaults.getKeys(deep));
+            }
+        }
+
+        mapChildrenKeys(result, this, deep);
+
+        return result;
+    }
+
+    public Map<String, Object> getValues(boolean deep) {
+        Map<String, Object> result = new LinkedHashMap<String, Object>();
+
+        Configuration root = getRoot();
+        if (root != null && root.options().copyDefaults()) {
+            ConfigurationSection defaults = getDefaultSection();
+
+            if (defaults != null) {
+                result.putAll(defaults.getValues(deep));
+            }
+        }
+
+        mapChildrenValues(result, this, deep);
+
+        return result;
+    }
+
+    public boolean contains(String path) {
+        return contains(path, false);
+    }
+
+    public boolean contains(String path, boolean ignoreDefault) {
+        return ((ignoreDefault) ? get(path, null) : get(path)) != null;
+    }
+
+    public boolean isSet(String path) {
+        Configuration root = getRoot();
+        if (root == null) {
+            return false;
+        }
+        if (root.options().copyDefaults()) {
+            return contains(path);
+        }
+        return get(path, null) != null;
+    }
+
+    public String getCurrentPath() {
+        return fullPath;
+    }
+
+    public String getName() {
+        return path;
+    }
+
+    public Configuration getRoot() {
+        return root;
+    }
+
+    public ConfigurationSection getParent() {
+        return parent;
+    }
+
+    public void addDefault(String path, Object value) {
+        Validate.notNull(path, "Path cannot be null");
+
+        Configuration root = getRoot();
+        if (root == null) {
+            throw new IllegalStateException("Cannot add default without root");
+        }
+        if (root == this) {
+            throw new UnsupportedOperationException("Unsupported addDefault(String, Object) implementation");
+        }
+        root.addDefault(createPath(this, path), value);
+    }
+
+    public ConfigurationSection getDefaultSection() {
+        Configuration root = getRoot();
+        Configuration defaults = root == null ? null : root.getDefaults();
+
+        if (defaults != null) {
+            if (defaults.isConfigurationSection(getCurrentPath())) {
+                return defaults.getConfigurationSection(getCurrentPath());
+            }
+        }
+
+        return null;
+    }
+
+    public void set(String path, Object value) {
+        Validate.notEmpty(path, "Cannot set to an empty path");
+
+        Configuration root = getRoot();
+        if (root == null) {
+            throw new IllegalStateException("Cannot use section without a root");
+        }
+
+        final char separator = root.options().pathSeparator();
+        // i1 is the leading (higher) index
+        // i2 is the trailing (lower) index
+        int i1 = -1, i2;
+        ConfigurationSection section = this;
+        while ((i1 = path.indexOf(separator, i2 = i1 + 1)) != -1) {
+            String node = path.substring(i2, i1);
+            ConfigurationSection subSection = section.getConfigurationSection(node);
+            if (subSection == null) {
+                if (value == null) {
+                	// no need to create missing sub-sections if we want to remove the value:
+                    return;
+                }
+                section = section.createSection(node);
+            } else {
+                section = subSection;
+            }
+        }
+
+        String key = path.substring(i2);
+        if (section == this) {
+            if (value == null) {
+                map.remove(key);
+            } else {
+                map.put(key, value);
+            }
+        } else {
+            section.set(key, value);
+        }
+    }
+
+    public Object get(String path) {
+        return get(path, getDefault(path));
+    }
+
+    public Object get(String path, Object def) {
+        Validate.notNull(path, "Path cannot be null");
+
+        if (path.length() == 0) {
+            return this;
+        }
+
+        Configuration root = getRoot();
+        if (root == null) {
+            throw new IllegalStateException("Cannot access section without a root");
+        }
+
+        final char separator = root.options().pathSeparator();
+        // i1 is the leading (higher) index
+        // i2 is the trailing (lower) index
+        int i1 = -1, i2;
+        ConfigurationSection section = this;
+        while ((i1 = path.indexOf(separator, i2 = i1 + 1)) != -1) {
+            section = section.getConfigurationSection(path.substring(i2, i1));
+            if (section == null) {
+                return def;
+            }
+        }
+
+        String key = path.substring(i2);
+        if (section == this) {
+            Object result = map.get(key);
+            return (result == null) ? def : result;
+        }
+        return section.get(key, def);
+    }
+
+    public ConfigurationSection createSection(String path) {
+        Validate.notEmpty(path, "Cannot create section at empty path");
+        Configuration root = getRoot();
+        if (root == null) {
+            throw new IllegalStateException("Cannot create section without a root");
+        }
+
+        final char separator = root.options().pathSeparator();
+        // i1 is the leading (higher) index
+        // i2 is the trailing (lower) index
+        int i1 = -1, i2;
+        ConfigurationSection section = this;
+        while ((i1 = path.indexOf(separator, i2 = i1 + 1)) != -1) {
+            String node = path.substring(i2, i1);
+            ConfigurationSection subSection = section.getConfigurationSection(node);
+            if (subSection == null) {
+                section = section.createSection(node);
+            } else {
+                section = subSection;
+            }
+        }
+
+        String key = path.substring(i2);
+        if (section == this) {
+            ConfigurationSection result = new MemorySection(this, key);
+            map.put(key, result);
+            return result;
+        }
+        return section.createSection(key);
+    }
+
+    public ConfigurationSection createSection(String path, Map<?, ?> map) {
+        ConfigurationSection section = createSection(path);
+
+        for (Map.Entry<?, ?> entry : map.entrySet()) {
+            if (entry.getValue() instanceof Map) {
+                section.createSection(entry.getKey().toString(), (Map<?, ?>) entry.getValue());
+            } else {
+                section.set(entry.getKey().toString(), entry.getValue());
+            }
+        }
+
+        return section;
+    }
+
+    // Primitives
+    public String getString(String path) {
+        Object def = getDefault(path);
+        return getString(path, def != null ? def.toString() : null);
+    }
+
+    public String getString(String path, String def) {
+        Object val = get(path, def);
+        return (val != null) ? val.toString() : def;
+    }
+
+    public boolean isString(String path) {
+        Object val = get(path);
+        return val instanceof String;
+    }
+
+    public int getInt(String path) {
+        Object def = getDefault(path);
+        return getInt(path, (def instanceof Number) ? toInt(def) : 0);
+    }
+
+    public int getInt(String path, int def) {
+        Object val = get(path, def);
+        return (val instanceof Number) ? toInt(val) : def;
+    }
+
+    public boolean isInt(String path) {
+        Object val = get(path);
+        return val instanceof Integer;
+    }
+
+    public boolean getBoolean(String path) {
+        Object def = getDefault(path);
+        return getBoolean(path, (def instanceof Boolean) ? (Boolean) def : false);
+    }
+
+    public boolean getBoolean(String path, boolean def) {
+        Object val = get(path, def);
+        return (val instanceof Boolean) ? (Boolean) val : def;
+    }
+
+    public boolean isBoolean(String path) {
+        Object val = get(path);
+        return val instanceof Boolean;
+    }
+
+    public double getDouble(String path) {
+        Object def = getDefault(path);
+        return getDouble(path, (def instanceof Number) ? toDouble(def) : 0);
+    }
+
+    public double getDouble(String path, double def) {
+        Object val = get(path, def);
+        return (val instanceof Number) ? toDouble(val) : def;
+    }
+
+    public boolean isDouble(String path) {
+        Object val = get(path);
+        return val instanceof Double;
+    }
+
+    public long getLong(String path) {
+        Object def = getDefault(path);
+        return getLong(path, (def instanceof Number) ? toLong(def) : 0);
+    }
+
+    public long getLong(String path, long def) {
+        Object val = get(path, def);
+        return (val instanceof Number) ? toLong(val) : def;
+    }
+
+    public boolean isLong(String path) {
+        Object val = get(path);
+        return val instanceof Long;
+    }
+
+    // Java
+    public List<?> getList(String path) {
+        Object def = getDefault(path);
+        return getList(path, (def instanceof List) ? (List<?>) def : null);
+    }
+
+    public List<?> getList(String path, List<?> def) {
+        Object val = get(path, def);
+        return (List<?>) ((val instanceof List) ? val : def);
+    }
+
+    public boolean isList(String path) {
+        Object val = get(path);
+        return val instanceof List;
+    }
+
+    public List<String> getStringList(String path) {
+        List<?> list = getList(path);
+
+        if (list == null) {
+            return new ArrayList<String>(0);
+        }
+
+        List<String> result = new ArrayList<String>();
+
+        for (Object object : list) {
+            if ((object instanceof String) || (isPrimitiveWrapper(object))) {
+                result.add(String.valueOf(object));
+            }
+        }
+
+        return result;
+    }
+
+    public List<Integer> getIntegerList(String path) {
+        List<?> list = getList(path);
+
+        if (list == null) {
+            return new ArrayList<Integer>(0);
+        }
+
+        List<Integer> result = new ArrayList<Integer>();
+
+        for (Object object : list) {
+            if (object instanceof Integer) {
+                result.add((Integer) object);
+            } else if (object instanceof String) {
+                try {
+                    result.add(Integer.valueOf((String) object));
+                } catch (Exception ex) {
+                }
+            } else if (object instanceof Character) {
+                result.add((int) ((Character) object).charValue());
+            } else if (object instanceof Number) {
+                result.add(((Number) object).intValue());
+            }
+        }
+
+        return result;
+    }
+
+    public List<Boolean> getBooleanList(String path) {
+        List<?> list = getList(path);
+
+        if (list == null) {
+            return new ArrayList<Boolean>(0);
+        }
+
+        List<Boolean> result = new ArrayList<Boolean>();
+
+        for (Object object : list) {
+            if (object instanceof Boolean) {
+                result.add((Boolean) object);
+            } else if (object instanceof String) {
+                if (Boolean.TRUE.toString().equals(object)) {
+                    result.add(true);
+                } else if (Boolean.FALSE.toString().equals(object)) {
+                    result.add(false);
+                }
+            }
+        }
+
+        return result;
+    }
+
+    public List<Double> getDoubleList(String path) {
+        List<?> list = getList(path);
+
+        if (list == null) {
+            return new ArrayList<Double>(0);
+        }
+
+        List<Double> result = new ArrayList<Double>();
+
+        for (Object object : list) {
+            if (object instanceof Double) {
+                result.add((Double) object);
+            } else if (object instanceof String) {
+                try {
+                    result.add(Double.valueOf((String) object));
+                } catch (Exception ex) {
+                }
+            } else if (object instanceof Character) {
+                result.add((double) ((Character) object).charValue());
+            } else if (object instanceof Number) {
+                result.add(((Number) object).doubleValue());
+            }
+        }
+
+        return result;
+    }
+
+    public List<Float> getFloatList(String path) {
+        List<?> list = getList(path);
+
+        if (list == null) {
+            return new ArrayList<Float>(0);
+        }
+
+        List<Float> result = new ArrayList<Float>();
+
+        for (Object object : list) {
+            if (object instanceof Float) {
+                result.add((Float) object);
+            } else if (object instanceof String) {
+                try {
+                    result.add(Float.valueOf((String) object));
+                } catch (Exception ex) {
+                }
+            } else if (object instanceof Character) {
+                result.add((float) ((Character) object).charValue());
+            } else if (object instanceof Number) {
+                result.add(((Number) object).floatValue());
+            }
+        }
+
+        return result;
+    }
+
+    public List<Long> getLongList(String path) {
+        List<?> list = getList(path);
+
+        if (list == null) {
+            return new ArrayList<Long>(0);
+        }
+
+        List<Long> result = new ArrayList<Long>();
+
+        for (Object object : list) {
+            if (object instanceof Long) {
+                result.add((Long) object);
+            } else if (object instanceof String) {
+                try {
+                    result.add(Long.valueOf((String) object));
+                } catch (Exception ex) {
+                }
+            } else if (object instanceof Character) {
+                result.add((long) ((Character) object).charValue());
+            } else if (object instanceof Number) {
+                result.add(((Number) object).longValue());
+            }
+        }
+
+        return result;
+    }
+
+    public List<Byte> getByteList(String path) {
+        List<?> list = getList(path);
+
+        if (list == null) {
+            return new ArrayList<Byte>(0);
+        }
+
+        List<Byte> result = new ArrayList<Byte>();
+
+        for (Object object : list) {
+            if (object instanceof Byte) {
+                result.add((Byte) object);
+            } else if (object instanceof String) {
+                try {
+                    result.add(Byte.valueOf((String) object));
+                } catch (Exception ex) {
+                }
+            } else if (object instanceof Character) {
+                result.add((byte) ((Character) object).charValue());
+            } else if (object instanceof Number) {
+                result.add(((Number) object).byteValue());
+            }
+        }
+
+        return result;
+    }
+
+    public List<Character> getCharacterList(String path) {
+        List<?> list = getList(path);
+
+        if (list == null) {
+            return new ArrayList<Character>(0);
+        }
+
+        List<Character> result = new ArrayList<Character>();
+
+        for (Object object : list) {
+            if (object instanceof Character) {
+                result.add((Character) object);
+            } else if (object instanceof String) {
+                String str = (String) object;
+
+                if (str.length() == 1) {
+                    result.add(str.charAt(0));
+                }
+            } else if (object instanceof Number) {
+                result.add((char) ((Number) object).intValue());
+            }
+        }
+
+        return result;
+    }
+
+    public List<Short> getShortList(String path) {
+        List<?> list = getList(path);
+
+        if (list == null) {
+            return new ArrayList<Short>(0);
+        }
+
+        List<Short> result = new ArrayList<Short>();
+
+        for (Object object : list) {
+            if (object instanceof Short) {
+                result.add((Short) object);
+            } else if (object instanceof String) {
+                try {
+                    result.add(Short.valueOf((String) object));
+                } catch (Exception ex) {
+                }
+            } else if (object instanceof Character) {
+                result.add((short) ((Character) object).charValue());
+            } else if (object instanceof Number) {
+                result.add(((Number) object).shortValue());
+            }
+        }
+
+        return result;
+    }
+
+    public List<Map<?, ?>> getMapList(String path) {
+        List<?> list = getList(path);
+        List<Map<?, ?>> result = new ArrayList<Map<?, ?>>();
+
+        if (list == null) {
+            return result;
+        }
+
+        for (Object object : list) {
+            if (object instanceof Map) {
+                result.add((Map<?, ?>) object);
+            }
+        }
+
+        return result;
+    }
+
+    // Bukkit
+    public Vector getVector(String path) {
+        Object def = getDefault(path);
+        return getVector(path, (def instanceof Vector) ? (Vector) def : null);
+    }
+
+    public Vector getVector(String path, Vector def) {
+        Object val = get(path, def);
+        return (val instanceof Vector) ? (Vector) val : def;
+    }
+
+    public boolean isVector(String path) {
+        Object val = get(path);
+        return val instanceof Vector;
+    }
+
+    public OfflinePlayer getOfflinePlayer(String path) {
+        Object def = getDefault(path);
+        return getOfflinePlayer(path, (def instanceof OfflinePlayer) ? (OfflinePlayer) def : null);
+    }
+
+    public OfflinePlayer getOfflinePlayer(String path, OfflinePlayer def) {
+        Object val = get(path, def);
+        return (val instanceof OfflinePlayer) ? (OfflinePlayer) val : def;
+    }
+
+    public boolean isOfflinePlayer(String path) {
+        Object val = get(path);
+        return val instanceof OfflinePlayer;
+    }
+
+    public ItemStack getItemStack(String path) {
+        Object def = getDefault(path);
+        return getItemStack(path, (def instanceof ItemStack) ? (ItemStack) def : null);
+    }
+
+    public ItemStack getItemStack(String path, ItemStack def) {
+        Object val = get(path, def);
+        return (val instanceof ItemStack) ? (ItemStack) val : def;
+    }
+
+    public boolean isItemStack(String path) {
+        Object val = get(path);
+        return val instanceof ItemStack;
+    }
+
+    public Color getColor(String path) {
+        Object def = getDefault(path);
+        return getColor(path, (def instanceof Color) ? (Color) def : null);
+    }
+
+    public Color getColor(String path, Color def) {
+        Object val = get(path, def);
+        return (val instanceof Color) ? (Color) val : def;
+    }
+
+    public boolean isColor(String path) {
+        Object val = get(path);
+        return val instanceof Color;
+    }
+
+    public ConfigurationSection getConfigurationSection(String path) {
+        Object val = get(path, null);
+        if (val != null) {
+            return (val instanceof ConfigurationSection) ? (ConfigurationSection) val : null;
+        }
+
+        val = get(path, getDefault(path));
+        return (val instanceof ConfigurationSection) ? createSection(path) : null;
+    }
+
+    public boolean isConfigurationSection(String path) {
+        Object val = get(path);
+        return val instanceof ConfigurationSection;
+    }
+
+    protected boolean isPrimitiveWrapper(Object input) {
+        return input instanceof Integer || input instanceof Boolean ||
+                input instanceof Character || input instanceof Byte ||
+                input instanceof Short || input instanceof Double ||
+                input instanceof Long || input instanceof Float;
+    }
+
+    protected Object getDefault(String path) {
+        Validate.notNull(path, "Path cannot be null");
+
+        Configuration root = getRoot();
+        Configuration defaults = root == null ? null : root.getDefaults();
+        return (defaults == null) ? null : defaults.get(createPath(this, path));
+    }
+
+    protected void mapChildrenKeys(Set<String> output, ConfigurationSection section, boolean deep) {
+        if (section instanceof MemorySection) {
+            MemorySection sec = (MemorySection) section;
+
+            for (Map.Entry<String, Object> entry : sec.map.entrySet()) {
+                output.add(createPath(section, entry.getKey(), this));
+
+                if ((deep) && (entry.getValue() instanceof ConfigurationSection)) {
+                    ConfigurationSection subsection = (ConfigurationSection) entry.getValue();
+                    mapChildrenKeys(output, subsection, deep);
+                }
+            }
+        } else {
+            Set<String> keys = section.getKeys(deep);
+
+            for (String key : keys) {
+                output.add(createPath(section, key, this));
+            }
+        }
+    }
+
+    protected void mapChildrenValues(Map<String, Object> output, ConfigurationSection section, boolean deep) {
+        if (section instanceof MemorySection) {
+            MemorySection sec = (MemorySection) section;
+
+            for (Map.Entry<String, Object> entry : sec.map.entrySet()) {
+                output.put(createPath(section, entry.getKey(), this), entry.getValue());
+
+                if (entry.getValue() instanceof ConfigurationSection) {
+                    if (deep) {
+                        mapChildrenValues(output, (ConfigurationSection) entry.getValue(), deep);
+                    }
+                }
+            }
+        } else {
+            Map<String, Object> values = section.getValues(deep);
+
+            for (Map.Entry<String, Object> entry : values.entrySet()) {
+                output.put(createPath(section, entry.getKey(), this), entry.getValue());
+            }
+        }
+    }
+
+    /**
+     * Creates a full path to the given {@link ConfigurationSection} from its
+     * root {@link Configuration}.
+     * <p>
+     * You may use this method for any given {@link ConfigurationSection}, not
+     * only {@link MemorySection}.
+     *
+     * @param section Section to create a path for.
+     * @param key Name of the specified section.
+     * @return Full path of the section from its root.
+     */
+    public static String createPath(ConfigurationSection section, String key) {
+        return createPath(section, key, (section == null) ? null : section.getRoot());
+    }
+
+    /**
+     * Creates a relative path to the given {@link ConfigurationSection} from
+     * the given relative section.
+     * <p>
+     * You may use this method for any given {@link ConfigurationSection}, not
+     * only {@link MemorySection}.
+     *
+     * @param section Section to create a path for.
+     * @param key Name of the specified section.
+     * @param relativeTo Section to create the path relative to.
+     * @return Full path of the section from its root.
+     */
+    public static String createPath(ConfigurationSection section, String key, ConfigurationSection relativeTo) {
+        Validate.notNull(section, "Cannot create path without a section");
+        Configuration root = section.getRoot();
+        if (root == null) {
+            throw new IllegalStateException("Cannot create path without a root");
+        }
+        char separator = root.options().pathSeparator();
+
+        StringBuilder builder = new StringBuilder();
+        if (section != null) {
+            for (ConfigurationSection parent = section; (parent != null) && (parent != relativeTo); parent = parent.getParent()) {
+                if (builder.length() > 0) {
+                    builder.insert(0, separator);
+                }
+
+                builder.insert(0, parent.getName());
+            }
+        }
+
+        if ((key != null) && (key.length() > 0)) {
+            if (builder.length() > 0) {
+                builder.append(separator);
+            }
+
+            builder.append(key);
+        }
+
+        return builder.toString();
+    }
+
+    @Override
+    public String toString() {
+        Configuration root = getRoot();
+        return new StringBuilder()
+            .append(getClass().getSimpleName())
+            .append("[path='")
+            .append(getCurrentPath())
+            .append("', root='")
+            .append(root == null ? null : root.getClass().getSimpleName())
+            .append("']")
+            .toString();
+    }
+}
diff --git a/src/main/java/org/bukkit/configuration/file/FileConfiguration.java b/src/main/java/org/bukkit/configuration/file/FileConfiguration.java
new file mode 100644
index 0000000..2c8e1cd
--- /dev/null
+++ b/src/main/java/org/bukkit/configuration/file/FileConfiguration.java
@@ -0,0 +1,248 @@
+package org.bukkit.configuration.file;
+
+import com.google.common.base.Charsets;
+import com.google.common.io.Files;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.configuration.InvalidConfigurationException;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStreamWriter;
+import java.io.Reader;
+import java.io.Writer;
+import java.nio.charset.Charset;
+
+import org.bukkit.configuration.Configuration;
+import org.bukkit.configuration.MemoryConfiguration;
+
+/**
+ * This is a base class for all File based implementations of {@link
+ * Configuration}
+ */
+public abstract class FileConfiguration extends MemoryConfiguration {
+
+    /**
+     * Creates an empty {@link FileConfiguration} with no default values.
+     */
+    public FileConfiguration() {
+        super();
+    }
+
+    /**
+     * Creates an empty {@link FileConfiguration} using the specified {@link
+     * Configuration} as a source for all default values.
+     *
+     * @param defaults Default value provider
+     */
+    public FileConfiguration(Configuration defaults) {
+        super(defaults);
+    }
+
+    /**
+     * Saves this {@link FileConfiguration} to the specified location.
+     * <p>
+     * If the file does not exist, it will be created. If already exists, it
+     * will be overwritten. If it cannot be overwritten or created, an
+     * exception will be thrown.
+     * <p>
+     * This method will save using the system default encoding, or possibly
+     * using UTF8.
+     *
+     * @param file File to save to.
+     * @throws IOException Thrown when the given file cannot be written to for
+     *     any reason.
+     * @throws IllegalArgumentException Thrown when file is null.
+     */
+    public void save(File file) throws IOException {
+        Validate.notNull(file, "File cannot be null");
+
+        Files.createParentDirs(file);
+
+        String data = saveToString();
+
+        Writer writer = new OutputStreamWriter(new FileOutputStream(file), Charsets.UTF_8);
+
+        try {
+            writer.write(data);
+        } finally {
+            writer.close();
+        }
+    }
+
+    /**
+     * Saves this {@link FileConfiguration} to the specified location.
+     * <p>
+     * If the file does not exist, it will be created. If already exists, it
+     * will be overwritten. If it cannot be overwritten or created, an
+     * exception will be thrown.
+     * <p>
+     * This method will save using the system default encoding, or possibly
+     * using UTF8.
+     *
+     * @param file File to save to.
+     * @throws IOException Thrown when the given file cannot be written to for
+     *     any reason.
+     * @throws IllegalArgumentException Thrown when file is null.
+     */
+    public void save(String file) throws IOException {
+        Validate.notNull(file, "File cannot be null");
+
+        save(new File(file));
+    }
+
+    /**
+     * Saves this {@link FileConfiguration} to a string, and returns it.
+     *
+     * @return String containing this configuration.
+     */
+    public abstract String saveToString();
+
+    /**
+     * Loads this {@link FileConfiguration} from the specified location.
+     * <p>
+     * All the values contained within this configuration will be removed,
+     * leaving only settings and defaults, and the new values will be loaded
+     * from the given file.
+     * <p>
+     * If the file cannot be loaded for any reason, an exception will be
+     * thrown.
+     *
+     * @param file File to load from.
+     * @throws FileNotFoundException Thrown when the given file cannot be
+     *     opened.
+     * @throws IOException Thrown when the given file cannot be read.
+     * @throws InvalidConfigurationException Thrown when the given file is not
+     *     a valid Configuration.
+     * @throws IllegalArgumentException Thrown when file is null.
+     */
+    public void load(File file) throws FileNotFoundException, IOException, InvalidConfigurationException {
+        Validate.notNull(file, "File cannot be null");
+
+        final FileInputStream stream = new FileInputStream(file);
+
+        load(new InputStreamReader(stream, Charsets.UTF_8));
+    }
+
+    /**
+     * Loads this {@link FileConfiguration} from the specified stream.
+     * <p>
+     * All the values contained within this configuration will be removed,
+     * leaving only settings and defaults, and the new values will be loaded
+     * from the given stream.
+     *
+     * @param stream Stream to load from
+     * @throws IOException Thrown when the given file cannot be read.
+     * @throws InvalidConfigurationException Thrown when the given file is not
+     *     a valid Configuration.
+     * @throws IllegalArgumentException Thrown when stream is null.
+     * @deprecated This does not consider encoding
+     * @see #load(Reader)
+     */
+    @Deprecated
+    public void load(InputStream stream) throws IOException, InvalidConfigurationException {
+        Validate.notNull(stream, "Stream cannot be null");
+
+        load(new InputStreamReader(stream, Charsets.UTF_8));
+    }
+
+    /**
+     * Loads this {@link FileConfiguration} from the specified reader.
+     * <p>
+     * All the values contained within this configuration will be removed,
+     * leaving only settings and defaults, and the new values will be loaded
+     * from the given stream.
+     *
+     * @param reader the reader to load from
+     * @throws IOException thrown when underlying reader throws an IOException
+     * @throws InvalidConfigurationException thrown when the reader does not
+     *      represent a valid Configuration
+     * @throws IllegalArgumentException thrown when reader is null
+     */
+    public void load(Reader reader) throws IOException, InvalidConfigurationException {
+        BufferedReader input = reader instanceof BufferedReader ? (BufferedReader) reader : new BufferedReader(reader);
+
+        StringBuilder builder = new StringBuilder();
+
+        try {
+            String line;
+
+            while ((line = input.readLine()) != null) {
+                builder.append(line);
+                builder.append('\n');
+            }
+        } finally {
+            input.close();
+        }
+
+        loadFromString(builder.toString());
+    }
+
+    /**
+     * Loads this {@link FileConfiguration} from the specified location.
+     * <p>
+     * All the values contained within this configuration will be removed,
+     * leaving only settings and defaults, and the new values will be loaded
+     * from the given file.
+     * <p>
+     * If the file cannot be loaded for any reason, an exception will be
+     * thrown.
+     *
+     * @param file File to load from.
+     * @throws FileNotFoundException Thrown when the given file cannot be
+     *     opened.
+     * @throws IOException Thrown when the given file cannot be read.
+     * @throws InvalidConfigurationException Thrown when the given file is not
+     *     a valid Configuration.
+     * @throws IllegalArgumentException Thrown when file is null.
+     */
+    public void load(String file) throws FileNotFoundException, IOException, InvalidConfigurationException {
+        Validate.notNull(file, "File cannot be null");
+
+        load(new File(file));
+    }
+
+    /**
+     * Loads this {@link FileConfiguration} from the specified string, as
+     * opposed to from file.
+     * <p>
+     * All the values contained within this configuration will be removed,
+     * leaving only settings and defaults, and the new values will be loaded
+     * from the given string.
+     * <p>
+     * If the string is invalid in any way, an exception will be thrown.
+     *
+     * @param contents Contents of a Configuration to load.
+     * @throws InvalidConfigurationException Thrown if the specified string is
+     *     invalid.
+     * @throws IllegalArgumentException Thrown if contents is null.
+     */
+    public abstract void loadFromString(String contents) throws InvalidConfigurationException;
+
+    /**
+     * Compiles the header for this {@link FileConfiguration} and returns the
+     * result.
+     * <p>
+     * This will use the header from {@link #options()} -&gt; {@link
+     * FileConfigurationOptions#header()}, respecting the rules of {@link
+     * FileConfigurationOptions#copyHeader()} if set.
+     *
+     * @return Compiled header
+     */
+    protected abstract String buildHeader();
+
+    @Override
+    public FileConfigurationOptions options() {
+        if (options == null) {
+            options = new FileConfigurationOptions(this);
+        }
+
+        return (FileConfigurationOptions) options;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/org/bukkit/configuration/file/YamlConfiguration.java b/src/main/java/org/bukkit/configuration/file/YamlConfiguration.java
new file mode 100644
index 0000000..a5d127b
--- /dev/null
+++ b/src/main/java/org/bukkit/configuration/file/YamlConfiguration.java
@@ -0,0 +1,248 @@
+package org.bukkit.configuration.file;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.Reader;
+import java.util.Map;
+import java.util.logging.Level;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.Bukkit;
+import org.bukkit.configuration.Configuration;
+import org.bukkit.configuration.ConfigurationSection;
+import org.bukkit.configuration.InvalidConfigurationException;
+import org.yaml.snakeyaml.DumperOptions;
+import org.yaml.snakeyaml.Yaml;
+import org.yaml.snakeyaml.error.YAMLException;
+import org.yaml.snakeyaml.representer.Representer;
+
+/**
+ * An implementation of {@link Configuration} which saves all files in Yaml.
+ * Note that this implementation is not synchronized.
+ */
+public class YamlConfiguration extends FileConfiguration {
+    protected static final String COMMENT_PREFIX = "# ";
+    protected static final String BLANK_CONFIG = "{}\n";
+    private final DumperOptions yamlOptions = new DumperOptions();
+    private final Representer yamlRepresenter = new YamlRepresenter();
+    private final Yaml yaml = new Yaml(new YamlConstructor(), yamlRepresenter, yamlOptions);
+
+    @Override
+    public String saveToString() {
+        yamlOptions.setIndent(options().indent());
+        yamlOptions.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);
+        yamlRepresenter.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);
+
+        String header = buildHeader();
+        String dump = yaml.dump(getValues(false));
+
+        if (dump.equals(BLANK_CONFIG)) {
+            dump = "";
+        }
+
+        return header + dump;
+    }
+
+    @Override
+    public void loadFromString(String contents) throws InvalidConfigurationException {
+        Validate.notNull(contents, "Contents cannot be null");
+
+        Map<?, ?> input;
+        try {
+            input = (Map<?, ?>) yaml.load(contents);
+        } catch (YAMLException e) {
+            throw new InvalidConfigurationException(e);
+        } catch (ClassCastException e) {
+            throw new InvalidConfigurationException("Top level is not a Map.");
+        }
+
+        String header = parseHeader(contents);
+        if (header.length() > 0) {
+            options().header(header);
+        }
+
+        if (input != null) {
+            convertMapsToSections(input, this);
+        }
+    }
+
+    protected void convertMapsToSections(Map<?, ?> input, ConfigurationSection section) {
+        for (Map.Entry<?, ?> entry : input.entrySet()) {
+            String key = entry.getKey().toString();
+            Object value = entry.getValue();
+
+            if (value instanceof Map) {
+                convertMapsToSections((Map<?, ?>) value, section.createSection(key));
+            } else {
+                section.set(key, value);
+            }
+        }
+    }
+
+    protected String parseHeader(String input) {
+        String[] lines = input.split("\r?\n", -1);
+        StringBuilder result = new StringBuilder();
+        boolean readingHeader = true;
+        boolean foundHeader = false;
+
+        for (int i = 0; (i < lines.length) && (readingHeader); i++) {
+            String line = lines[i];
+
+            if (line.startsWith(COMMENT_PREFIX)) {
+                if (i > 0) {
+                    result.append("\n");
+                }
+
+                if (line.length() > COMMENT_PREFIX.length()) {
+                    result.append(line.substring(COMMENT_PREFIX.length()));
+                }
+
+                foundHeader = true;
+            } else if ((foundHeader) && (line.length() == 0)) {
+                result.append("\n");
+            } else if (foundHeader) {
+                readingHeader = false;
+            }
+        }
+
+        return result.toString();
+    }
+
+    @Override
+    protected String buildHeader() {
+        String header = options().header();
+
+        if (options().copyHeader()) {
+            Configuration def = getDefaults();
+
+            if ((def != null) && (def instanceof FileConfiguration)) {
+                FileConfiguration filedefaults = (FileConfiguration) def;
+                String defaultsHeader = filedefaults.buildHeader();
+
+                if ((defaultsHeader != null) && (defaultsHeader.length() > 0)) {
+                    return defaultsHeader;
+                }
+            }
+        }
+
+        if (header == null) {
+            return "";
+        }
+
+        StringBuilder builder = new StringBuilder();
+        String[] lines = header.split("\r?\n", -1);
+        boolean startedHeader = false;
+
+        for (int i = lines.length - 1; i >= 0; i--) {
+            builder.insert(0, "\n");
+
+            if ((startedHeader) || (lines[i].length() != 0)) {
+                builder.insert(0, lines[i]);
+                builder.insert(0, COMMENT_PREFIX);
+                startedHeader = true;
+            }
+        }
+
+        return builder.toString();
+    }
+
+    @Override
+    public YamlConfigurationOptions options() {
+        if (options == null) {
+            options = new YamlConfigurationOptions(this);
+        }
+
+        return (YamlConfigurationOptions) options;
+    }
+
+    /**
+     * Creates a new {@link YamlConfiguration}, loading from the given file.
+     * <p>
+     * Any errors loading the Configuration will be logged and then ignored.
+     * If the specified input is not a valid config, a blank config will be
+     * returned.
+     * <p>
+     * The encoding used may follow the system dependent default.
+     *
+     * @param file Input file
+     * @return Resulting configuration
+     * @throws IllegalArgumentException Thrown if file is null
+     */
+    public static YamlConfiguration loadConfiguration(File file) {
+        Validate.notNull(file, "File cannot be null");
+
+        YamlConfiguration config = new YamlConfiguration();
+
+        try {
+            config.load(file);
+        } catch (FileNotFoundException ex) {
+        } catch (IOException ex) {
+            Bukkit.getLogger().log(Level.SEVERE, "Cannot load " + file, ex);
+        } catch (InvalidConfigurationException ex) {
+            Bukkit.getLogger().log(Level.SEVERE, "Cannot load " + file , ex);
+        }
+
+        return config;
+    }
+
+    /**
+     * Creates a new {@link YamlConfiguration}, loading from the given stream.
+     * <p>
+     * Any errors loading the Configuration will be logged and then ignored.
+     * If the specified input is not a valid config, a blank config will be
+     * returned.
+     *
+     * @param stream Input stream
+     * @return Resulting configuration
+     * @throws IllegalArgumentException Thrown if stream is null
+     * @deprecated does not properly consider encoding
+     * @see #load(InputStream)
+     * @see #loadConfiguration(Reader)
+     */
+    @Deprecated
+    public static YamlConfiguration loadConfiguration(InputStream stream) {
+        Validate.notNull(stream, "Stream cannot be null");
+
+        YamlConfiguration config = new YamlConfiguration();
+
+        try {
+            config.load(stream);
+        } catch (IOException ex) {
+            Bukkit.getLogger().log(Level.SEVERE, "Cannot load configuration from stream", ex);
+        } catch (InvalidConfigurationException ex) {
+            Bukkit.getLogger().log(Level.SEVERE, "Cannot load configuration from stream", ex);
+        }
+
+        return config;
+    }
+
+
+    /**
+     * Creates a new {@link YamlConfiguration}, loading from the given reader.
+     * <p>
+     * Any errors loading the Configuration will be logged and then ignored.
+     * If the specified input is not a valid config, a blank config will be
+     * returned.
+     *
+     * @param reader input
+     * @return resulting configuration
+     * @throws IllegalArgumentException Thrown if stream is null
+     */
+    public static YamlConfiguration loadConfiguration(Reader reader) {
+        Validate.notNull(reader, "Stream cannot be null");
+
+        YamlConfiguration config = new YamlConfiguration();
+
+        try {
+            config.load(reader);
+        } catch (IOException ex) {
+            Bukkit.getLogger().log(Level.SEVERE, "Cannot load configuration from stream", ex);
+        } catch (InvalidConfigurationException ex) {
+            Bukkit.getLogger().log(Level.SEVERE, "Cannot load configuration from stream", ex);
+        }
+
+        return config;
+    }
+}
diff --git a/src/main/java/org/bukkit/configuration/file/YamlConfigurationOptions.java b/src/main/java/org/bukkit/configuration/file/YamlConfigurationOptions.java
new file mode 100644
index 0000000..2a6c1f8
--- /dev/null
+++ b/src/main/java/org/bukkit/configuration/file/YamlConfigurationOptions.java
@@ -0,0 +1,71 @@
+package org.bukkit.configuration.file;
+
+import org.apache.commons.lang3.Validate;
+
+/**
+ * Various settings for controlling the input and output of a {@link
+ * YamlConfiguration}
+ */
+public class YamlConfigurationOptions extends FileConfigurationOptions {
+    private int indent = 2;
+
+    protected YamlConfigurationOptions(YamlConfiguration configuration) {
+        super(configuration);
+    }
+
+    @Override
+    public YamlConfiguration configuration() {
+        return (YamlConfiguration) super.configuration();
+    }
+
+    @Override
+    public YamlConfigurationOptions copyDefaults(boolean value) {
+        super.copyDefaults(value);
+        return this;
+    }
+
+    @Override
+    public YamlConfigurationOptions pathSeparator(char value) {
+        super.pathSeparator(value);
+        return this;
+    }
+
+    @Override
+    public YamlConfigurationOptions header(String value) {
+        super.header(value);
+        return this;
+    }
+
+    @Override
+    public YamlConfigurationOptions copyHeader(boolean value) {
+        super.copyHeader(value);
+        return this;
+    }
+
+    /**
+     * Gets how much spaces should be used to indent each line.
+     * <p>
+     * The minimum value this may be is 2, and the maximum is 9.
+     *
+     * @return How much to indent by
+     */
+    public int indent() {
+        return indent;
+    }
+
+    /**
+     * Sets how much spaces should be used to indent each line.
+     * <p>
+     * The minimum value this may be is 2, and the maximum is 9.
+     *
+     * @param value New indent
+     * @return This object, for chaining
+     */
+    public YamlConfigurationOptions indent(int value) {
+        Validate.isTrue(value >= 2, "Indent must be at least 2 characters");
+        Validate.isTrue(value <= 9, "Indent cannot be greater than 9 characters");
+
+        this.indent = value;
+        return this;
+    }
+}
diff --git a/src/main/java/org/bukkit/configuration/serialization/ConfigurationSerialization.java b/src/main/java/org/bukkit/configuration/serialization/ConfigurationSerialization.java
new file mode 100644
index 0000000..01d69f2
--- /dev/null
+++ b/src/main/java/org/bukkit/configuration/serialization/ConfigurationSerialization.java
@@ -0,0 +1,285 @@
+package org.bukkit.configuration.serialization;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.Color;
+import org.bukkit.FireworkEffect;
+import org.bukkit.Location;
+import org.bukkit.block.banner.Pattern;
+import org.bukkit.configuration.Configuration;
+import org.bukkit.inventory.ItemStack;
+import org.bukkit.potion.PotionEffect;
+import org.bukkit.util.BlockVector;
+import org.bukkit.util.Vector;
+
+/**
+ * Utility class for storing and retrieving classes for {@link Configuration}.
+ */
+public class ConfigurationSerialization {
+    public static final String SERIALIZED_TYPE_KEY = "==";
+    private final Class<? extends ConfigurationSerializable> clazz;
+    private static Map<String, Class<? extends ConfigurationSerializable>> aliases = new HashMap<String, Class<? extends ConfigurationSerializable>>();
+
+    static {
+        registerClass(Vector.class);
+        registerClass(BlockVector.class);
+        registerClass(ItemStack.class);
+        registerClass(Color.class);
+        registerClass(PotionEffect.class);
+        registerClass(FireworkEffect.class);
+        registerClass(Pattern.class);
+        registerClass(Location.class);
+    }
+
+    protected ConfigurationSerialization(Class<? extends ConfigurationSerializable> clazz) {
+        this.clazz = clazz;
+    }
+
+    protected Method getMethod(String name, boolean isStatic) {
+        try {
+            Method method = clazz.getDeclaredMethod(name, Map.class);
+
+            if (!ConfigurationSerializable.class.isAssignableFrom(method.getReturnType())) {
+                return null;
+            }
+            if (Modifier.isStatic(method.getModifiers()) != isStatic) {
+                return null;
+            }
+
+            return method;
+        } catch (NoSuchMethodException ex) {
+            return null;
+        } catch (SecurityException ex) {
+            return null;
+        }
+    }
+
+    protected Constructor<? extends ConfigurationSerializable> getConstructor() {
+        try {
+            return clazz.getConstructor(Map.class);
+        } catch (NoSuchMethodException ex) {
+            return null;
+        } catch (SecurityException ex) {
+            return null;
+        }
+    }
+
+    protected ConfigurationSerializable deserializeViaMethod(Method method, Map<String, ?> args) {
+        try {
+            ConfigurationSerializable result = (ConfigurationSerializable) method.invoke(null, args);
+
+            if (result == null) {
+                Logger.getLogger(ConfigurationSerialization.class.getName()).log(Level.SEVERE, "Could not call method '" + method.toString() + "' of " + clazz + " for deserialization: method returned null");
+            } else {
+                return result;
+            }
+        } catch (Throwable ex) {
+            Logger.getLogger(ConfigurationSerialization.class.getName()).log(
+                    Level.SEVERE,
+                    "Could not call method '" + method.toString() + "' of " + clazz + " for deserialization",
+                    ex instanceof InvocationTargetException ? ex.getCause() : ex);
+        }
+
+        return null;
+    }
+
+    protected ConfigurationSerializable deserializeViaCtor(Constructor<? extends ConfigurationSerializable> ctor, Map<String, ?> args) {
+        try {
+            return ctor.newInstance(args);
+        } catch (Throwable ex) {
+            Logger.getLogger(ConfigurationSerialization.class.getName()).log(
+                    Level.SEVERE,
+                    "Could not call constructor '" + ctor.toString() + "' of " + clazz + " for deserialization",
+                    ex instanceof InvocationTargetException ? ex.getCause() : ex);
+        }
+
+        return null;
+    }
+
+    public ConfigurationSerializable deserialize(Map<String, ?> args) {
+        Validate.notNull(args, "Args must not be null");
+
+        ConfigurationSerializable result = null;
+        Method method = null;
+
+        if (result == null) {
+            method = getMethod("deserialize", true);
+
+            if (method != null) {
+                result = deserializeViaMethod(method, args);
+            }
+        }
+
+        if (result == null) {
+            method = getMethod("valueOf", true);
+
+            if (method != null) {
+                result = deserializeViaMethod(method, args);
+            }
+        }
+
+        if (result == null) {
+            Constructor<? extends ConfigurationSerializable> constructor = getConstructor();
+
+            if (constructor != null) {
+                result = deserializeViaCtor(constructor, args);
+            }
+        }
+
+        return result;
+    }
+
+    /**
+     * Attempts to deserialize the given arguments into a new instance of the
+     * given class.
+     * <p>
+     * The class must implement {@link ConfigurationSerializable}, including
+     * the extra methods as specified in the javadoc of
+     * ConfigurationSerializable.
+     * <p>
+     * If a new instance could not be made, an example being the class not
+     * fully implementing the interface, null will be returned.
+     *
+     * @param args Arguments for deserialization
+     * @param clazz Class to deserialize into
+     * @return New instance of the specified class
+     */
+    public static ConfigurationSerializable deserializeObject(Map<String, ?> args, Class<? extends ConfigurationSerializable> clazz) {
+        return new ConfigurationSerialization(clazz).deserialize(args);
+    }
+
+    /**
+     * Attempts to deserialize the given arguments into a new instance of the
+     * given class.
+     * <p>
+     * The class must implement {@link ConfigurationSerializable}, including
+     * the extra methods as specified in the javadoc of
+     * ConfigurationSerializable.
+     * <p>
+     * If a new instance could not be made, an example being the class not
+     * fully implementing the interface, null will be returned.
+     *
+     * @param args Arguments for deserialization
+     * @return New instance of the specified class
+     */
+    public static ConfigurationSerializable deserializeObject(Map<String, ?> args) {
+        Class<? extends ConfigurationSerializable> clazz = null;
+
+        if (args.containsKey(SERIALIZED_TYPE_KEY)) {
+            try {
+                String alias = (String) args.get(SERIALIZED_TYPE_KEY);
+
+                if (alias == null) {
+                    throw new IllegalArgumentException("Cannot have null alias");
+                }
+                clazz = getClassByAlias(alias);
+                if (clazz == null) {
+                    throw new IllegalArgumentException("Specified class does not exist ('" + alias + "')");
+                }
+            } catch (ClassCastException ex) {
+                ex.fillInStackTrace();
+                throw ex;
+            }
+        } else {
+            throw new IllegalArgumentException("Args doesn't contain type key ('" + SERIALIZED_TYPE_KEY + "')");
+        }
+
+        return new ConfigurationSerialization(clazz).deserialize(args);
+    }
+
+    /**
+     * Registers the given {@link ConfigurationSerializable} class by its
+     * alias
+     *
+     * @param clazz Class to register
+     */
+    public static void registerClass(Class<? extends ConfigurationSerializable> clazz) {
+        DelegateDeserialization delegate = clazz.getAnnotation(DelegateDeserialization.class);
+
+        if (delegate == null) {
+            registerClass(clazz, getAlias(clazz));
+            registerClass(clazz, clazz.getName());
+        }
+    }
+
+    /**
+     * Registers the given alias to the specified {@link
+     * ConfigurationSerializable} class
+     *
+     * @param clazz Class to register
+     * @param alias Alias to register as
+     * @see SerializableAs
+     */
+    public static void registerClass(Class<? extends ConfigurationSerializable> clazz, String alias) {
+        aliases.put(alias, clazz);
+    }
+
+    /**
+     * Unregisters the specified alias to a {@link ConfigurationSerializable}
+     *
+     * @param alias Alias to unregister
+     */
+    public static void unregisterClass(String alias) {
+        aliases.remove(alias);
+    }
+
+    /**
+     * Unregisters any aliases for the specified {@link
+     * ConfigurationSerializable} class
+     *
+     * @param clazz Class to unregister
+     */
+    public static void unregisterClass(Class<? extends ConfigurationSerializable> clazz) {
+        while (aliases.values().remove(clazz)) {
+            ;
+        }
+    }
+
+    /**
+     * Attempts to get a registered {@link ConfigurationSerializable} class by
+     * its alias
+     *
+     * @param alias Alias of the serializable
+     * @return Registered class, or null if not found
+     */
+    public static Class<? extends ConfigurationSerializable> getClassByAlias(String alias) {
+        return aliases.get(alias);
+    }
+
+    /**
+     * Gets the correct alias for the given {@link ConfigurationSerializable}
+     * class
+     *
+     * @param clazz Class to get alias for
+     * @return Alias to use for the class
+     */
+    public static String getAlias(Class<? extends ConfigurationSerializable> clazz) {
+        DelegateDeserialization delegate = clazz.getAnnotation(DelegateDeserialization.class);
+
+        if (delegate != null) {
+            if ((delegate.value() == null) || (delegate.value() == clazz)) {
+                delegate = null;
+            } else {
+                return getAlias(delegate.value());
+            }
+        }
+
+        if (delegate == null) {
+            SerializableAs alias = clazz.getAnnotation(SerializableAs.class);
+
+            if ((alias != null) && (alias.value() != null)) {
+                return alias.value();
+            }
+        }
+
+        return clazz.getName();
+    }
+}
diff --git a/src/main/java/org/bukkit/conversations/BooleanPrompt.java b/src/main/java/org/bukkit/conversations/BooleanPrompt.java
new file mode 100644
index 0000000..ed8e102
--- /dev/null
+++ b/src/main/java/org/bukkit/conversations/BooleanPrompt.java
@@ -0,0 +1,37 @@
+package org.bukkit.conversations;
+
+import org.apache.commons.lang3.ArrayUtils;
+import org.apache.commons.lang3.BooleanUtils;
+
+/**
+ * BooleanPrompt is the base class for any prompt that requires a boolean
+ * response from the user.
+ */
+public abstract class BooleanPrompt extends ValidatingPrompt{
+
+    public BooleanPrompt() {
+        super();
+    }
+
+    @Override
+    protected boolean isInputValid(ConversationContext context, String input) {
+        String[] accepted = {"true", "false", "on", "off", "yes", "no" /* Spigot: */, "y", "n", "1", "0", "right", "wrong", "correct", "incorrect", "valid", "invalid"}; // Spigot
+        return ArrayUtils.contains(accepted, input.toLowerCase());
+    }
+
+    @Override
+    protected Prompt acceptValidatedInput(ConversationContext context, String input) {
+        if (input.equalsIgnoreCase("y") || input.equals("1") || input.equalsIgnoreCase("right") || input.equalsIgnoreCase("correct") || input.equalsIgnoreCase("valid")) input = "true"; // Spigot
+        return acceptValidatedInput(context, BooleanUtils.toBoolean(input));
+    }
+
+    /**
+     * Override this method to perform some action with the user's boolean
+     * response.
+     *
+     * @param context Context information about the conversation.
+     * @param input The user's boolean response.
+     * @return The next {@link Prompt} in the prompt graph.
+     */
+    protected abstract Prompt acceptValidatedInput(ConversationContext context, boolean input);
+}
diff --git a/src/main/java/org/bukkit/conversations/FixedSetPrompt.java b/src/main/java/org/bukkit/conversations/FixedSetPrompt.java
new file mode 100644
index 0000000..bf55447
--- /dev/null
+++ b/src/main/java/org/bukkit/conversations/FixedSetPrompt.java
@@ -0,0 +1,46 @@
+package org.bukkit.conversations;
+
+import org.apache.commons.lang3.StringUtils;
+
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * FixedSetPrompt is the base class for any prompt that requires a fixed set
+ * response from the user.
+ */
+public abstract class FixedSetPrompt extends ValidatingPrompt {
+    
+    protected List<String> fixedSet;
+
+    /**
+     * Creates a FixedSetPrompt from a set of strings.
+     * <p>
+     * foo = new FixedSetPrompt("bar", "cheese", "panda");
+     *
+     * @param fixedSet A fixed set of strings, one of which the user must
+     *     type.
+     */
+    public FixedSetPrompt(String... fixedSet) {
+        super();
+        this.fixedSet = Arrays.asList(fixedSet);
+    }
+
+    private FixedSetPrompt() {}
+
+    @Override
+    protected boolean isInputValid(ConversationContext context, String input) {
+        return fixedSet.contains(input);
+    }
+
+    /**
+     * Utility function to create a formatted string containing all the
+     * options declared in the constructor.
+     *
+     * @return the options formatted like "[bar, cheese, panda]" if bar,
+     *     cheese, and panda were the options used
+     */
+    protected String formatFixedSet() {
+        return "[" + StringUtils.join(fixedSet, ", ") + "]";
+    }
+}
diff --git a/src/main/java/org/bukkit/conversations/NumericPrompt.java b/src/main/java/org/bukkit/conversations/NumericPrompt.java
new file mode 100644
index 0000000..f645b63
--- /dev/null
+++ b/src/main/java/org/bukkit/conversations/NumericPrompt.java
@@ -0,0 +1,83 @@
+package org.bukkit.conversations;
+
+import org.apache.commons.lang3.math.NumberUtils;
+
+/**
+ * NumericPrompt is the base class for any prompt that requires a {@link
+ * Number} response from the user.
+ */
+public abstract class NumericPrompt extends ValidatingPrompt{
+    public NumericPrompt() {
+        super();
+    }
+
+    @Override
+    protected boolean isInputValid(ConversationContext context, String input) {
+        return NumberUtils.isNumber(input) && isNumberValid(context, NumberUtils.createNumber(input));
+    }
+
+    /**
+     * Override this method to do further validation on the numeric player
+     * input after the input has been determined to actually be a number.
+     *
+     * @param context Context information about the conversation.
+     * @param input The number the player provided.
+     * @return The validity of the player's input.
+     */
+    protected boolean isNumberValid(ConversationContext context, Number input) {
+        return true;
+    }
+
+    @Override
+    protected Prompt acceptValidatedInput(ConversationContext context, String input) {
+        try
+        {
+            return acceptValidatedInput(context, NumberUtils.createNumber(input));
+        } catch (NumberFormatException e) {
+            return acceptValidatedInput(context, NumberUtils.INTEGER_ZERO);
+        }
+    }
+
+    /**
+     * Override this method to perform some action with the user's integer
+     * response.
+     *
+     * @param context Context information about the conversation.
+     * @param input The user's response as a {@link Number}.
+     * @return The next {@link Prompt} in the prompt graph.
+     */
+    protected abstract Prompt acceptValidatedInput(ConversationContext context, Number input);
+
+    @Override
+    protected String getFailedValidationText(ConversationContext context, String invalidInput) {
+        if (NumberUtils.isNumber(invalidInput)) {
+            return getFailedValidationText(context, NumberUtils.createNumber(invalidInput));
+        } else {
+            return getInputNotNumericText(context, invalidInput);
+        }
+    }
+
+    /**
+     * Optionally override this method to display an additional message if the
+     * user enters an invalid number.
+     *
+     * @param context Context information about the conversation.
+     * @param invalidInput The invalid input provided by the user.
+     * @return A message explaining how to correct the input.
+     */
+    protected String getInputNotNumericText(ConversationContext context, String invalidInput) {
+        return null;
+    }
+
+    /**
+     * Optionally override this method to display an additional message if the
+     * user enters an invalid numeric input.
+     *
+     * @param context Context information about the conversation.
+     * @param invalidInput The invalid input provided by the user.
+     * @return A message explaining how to correct the input.
+     */
+    protected String getFailedValidationText(ConversationContext context, Number invalidInput) {
+        return null;
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index f332a33..a707f14 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -505,7 +505,7 @@ public final class CraftServer implements Server {
 
     @Override
     public String getServerName() {
-        return this.getConfigString("server-name", "Unknown Server");
+        return this.getConfigString("server-name", "Torch Server");
     }
 
     @Override
diff --git a/src/main/java/org/bukkit/craftbukkit/Main.java b/src/main/java/org/bukkit/craftbukkit/Main.java
index 2bc89d6..daab9f4 100644
--- a/src/main/java/org/bukkit/craftbukkit/Main.java
+++ b/src/main/java/org/bukkit/craftbukkit/Main.java
@@ -135,7 +135,7 @@ public class Main {
                 acceptsAll(asList("server-name"), "Name of the server")
                         .withRequiredArg()
                         .ofType(String.class)
-                        .defaultsTo("Unknown Server")
+                        .defaultsTo("Torch Server")
                         .describedAs("Name");
                 // Paper end
 
diff --git a/src/main/java/org/bukkit/event/entity/AreaEffectCloudApplyEvent.java b/src/main/java/org/bukkit/event/entity/AreaEffectCloudApplyEvent.java
new file mode 100644
index 0000000..b10f9a5
--- /dev/null
+++ b/src/main/java/org/bukkit/event/entity/AreaEffectCloudApplyEvent.java
@@ -0,0 +1,55 @@
+package org.bukkit.event.entity;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.entity.AreaEffectCloud;
+import org.bukkit.entity.LivingEntity;
+import org.bukkit.entity.ThrownPotion;
+import org.bukkit.event.Cancellable;
+import org.bukkit.event.HandlerList;
+
+/**
+ * Called when a lingering potion applies it's effects. Happens
+ * once every 5 ticks
+ */
+public class AreaEffectCloudApplyEvent extends EntityEvent {
+    private static final HandlerList handlers = new HandlerList();
+    private final List<LivingEntity> affectedEntities;
+
+    public AreaEffectCloudApplyEvent(final AreaEffectCloud entity, final List<LivingEntity> affectedEntities) {
+        super(entity);
+        this.affectedEntities = affectedEntities;
+    }
+
+    @Override
+    public AreaEffectCloud getEntity() {
+        return (AreaEffectCloud) entity;
+    }
+
+    /**
+     * Retrieves a mutable list of the effected entities
+     * <p>
+     * It is important to note that not every entity in this list
+     * is guaranteed to be effected.  The cloud may die during the
+     * application of its effects due to the depletion of {@link AreaEffectCloud#getDurationOnUse()}
+     * or {@link AreaEffectCloud#getRadiusOnUse()}
+     *
+     * @return the affected entity list
+     */
+    public List<LivingEntity> getAffectedEntities() {
+        return affectedEntities;
+    }
+
+    @Override
+    public HandlerList getHandlers() {
+        return handlers;
+    }
+
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+}
diff --git a/src/main/java/org/bukkit/event/entity/EnderDragonChangePhaseEvent.java b/src/main/java/org/bukkit/event/entity/EnderDragonChangePhaseEvent.java
new file mode 100644
index 0000000..5edd94d
--- /dev/null
+++ b/src/main/java/org/bukkit/event/entity/EnderDragonChangePhaseEvent.java
@@ -0,0 +1,76 @@
+package org.bukkit.event.entity;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.entity.EnderDragon;
+import org.bukkit.event.Cancellable;
+import org.bukkit.event.HandlerList;
+
+/**
+ * Called when an EnderDragon switches controller phase.
+ */
+public class EnderDragonChangePhaseEvent extends EntityEvent implements Cancellable {
+
+    private static final HandlerList handlers = new HandlerList();
+    private boolean cancel;
+    private final EnderDragon.Phase currentPhase;
+    private EnderDragon.Phase newPhase;
+
+    public EnderDragonChangePhaseEvent(EnderDragon enderDragon, EnderDragon.Phase currentPhase, EnderDragon.Phase newPhase) {
+        super(enderDragon);
+        this.currentPhase = currentPhase;
+        this.setNewPhase(newPhase);
+    }
+
+    @Override
+    public EnderDragon getEntity() {
+        return (EnderDragon) entity;
+    }
+
+    /**
+     * Gets the current phase that the dragon is in. This method will return null 
+     * when a dragon is first spawned and hasn't yet been assigned a phase.
+     * 
+     * @return the current dragon phase
+     */
+    public EnderDragon.Phase getCurrentPhase() {
+        return currentPhase;
+    }
+
+    /**
+     * Gets the new phase that the dragon will switch to.
+     * 
+     * @return the new dragon phase
+     */
+    public EnderDragon.Phase getNewPhase() {
+        return newPhase;
+    }
+
+    /**
+     * Sets the new phase for the ender dragon.
+     * 
+     * @param newPhase the new dragon phase
+     */
+    public void setNewPhase(EnderDragon.Phase newPhase) {
+        Validate.notNull(newPhase, "New dragon phase cannot be null");
+        this.newPhase = newPhase;
+    }
+
+    @Override
+    public boolean isCancelled() {
+        return cancel;
+    }
+
+    @Override
+    public void setCancelled(boolean cancel) {
+        this.cancel = cancel;
+    }
+
+    @Override
+    public HandlerList getHandlers() {
+        return handlers;
+    }
+
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+}
diff --git a/src/main/java/org/bukkit/event/entity/EntityBreedEvent.java b/src/main/java/org/bukkit/event/entity/EntityBreedEvent.java
index ce0973b..e45fb53 100644
--- a/src/main/java/org/bukkit/event/entity/EntityBreedEvent.java
+++ b/src/main/java/org/bukkit/event/entity/EntityBreedEvent.java
@@ -1,6 +1,6 @@
 package org.bukkit.event.entity;
 
-import org.apache.commons.lang.Validate;
+import org.apache.commons.lang3.Validate;
 import org.bukkit.entity.LivingEntity;
 import org.bukkit.event.Cancellable;
 import org.bukkit.event.HandlerList;
diff --git a/src/main/java/org/bukkit/event/entity/EntityDamageEvent.java b/src/main/java/org/bukkit/event/entity/EntityDamageEvent.java
index 09ce0ae..88f1789 100644
--- a/src/main/java/org/bukkit/event/entity/EntityDamageEvent.java
+++ b/src/main/java/org/bukkit/event/entity/EntityDamageEvent.java
@@ -4,7 +4,7 @@ import java.util.EnumMap;
 import java.util.Map;
 import org.bukkit.Material;
 
-import org.apache.commons.lang.Validate;
+import org.apache.commons.lang3.Validate;
 import org.bukkit.entity.Entity;
 import org.bukkit.entity.Player;
 import org.bukkit.event.Cancellable;
diff --git a/src/main/java/org/bukkit/event/entity/LingeringPotionSplashEvent.java b/src/main/java/org/bukkit/event/entity/LingeringPotionSplashEvent.java
new file mode 100644
index 0000000..3c179cd
--- /dev/null
+++ b/src/main/java/org/bukkit/event/entity/LingeringPotionSplashEvent.java
@@ -0,0 +1,58 @@
+package org.bukkit.event.entity;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Map;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.entity.AreaEffectCloud;
+import org.bukkit.entity.LingeringPotion;
+import org.bukkit.entity.LivingEntity;
+import org.bukkit.entity.ThrownPotion;
+import org.bukkit.event.Cancellable;
+import org.bukkit.event.HandlerList;
+
+/**
+ * Called when a splash potion hits an area
+ */
+public class LingeringPotionSplashEvent extends ProjectileHitEvent implements Cancellable {
+    private static final HandlerList handlers = new HandlerList();
+    private boolean cancelled;
+    private final AreaEffectCloud entity;
+
+    public LingeringPotionSplashEvent(final ThrownPotion potion, final AreaEffectCloud entity) {
+        super(potion);
+        this.entity = entity;
+    }
+
+    @Override
+    public LingeringPotion getEntity() {
+        return (LingeringPotion) super.getEntity();
+    }
+
+    /**
+     * Gets the AreaEffectCloud spawned
+     *
+     * @return The spawned AreaEffectCloud
+     */
+    public AreaEffectCloud getAreaEffectCloud() {
+        return entity;
+    }
+
+    public boolean isCancelled() {
+        return cancelled;
+    }
+
+    public void setCancelled(boolean cancel) {
+        cancelled = cancel;
+    }
+
+    @Override
+    public HandlerList getHandlers() {
+        return handlers;
+    }
+
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+}
diff --git a/src/main/java/org/bukkit/event/entity/PotionSplashEvent.java b/src/main/java/org/bukkit/event/entity/PotionSplashEvent.java
new file mode 100644
index 0000000..568a928
--- /dev/null
+++ b/src/main/java/org/bukkit/event/entity/PotionSplashEvent.java
@@ -0,0 +1,94 @@
+package org.bukkit.event.entity;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Map;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.entity.LivingEntity;
+import org.bukkit.entity.ThrownPotion;
+import org.bukkit.event.Cancellable;
+import org.bukkit.event.HandlerList;
+
+/**
+ * Called when a splash potion hits an area
+ */
+public class PotionSplashEvent extends ProjectileHitEvent implements Cancellable {
+    private static final HandlerList handlers = new HandlerList();
+    private boolean cancelled;
+    private final Map<LivingEntity, Double> affectedEntities;
+
+    public PotionSplashEvent(final ThrownPotion potion, final Map<LivingEntity, Double> affectedEntities) {
+        super(potion);
+
+        this.affectedEntities = affectedEntities;
+    }
+
+    @Override
+    public ThrownPotion getEntity() {
+        return (ThrownPotion) entity;
+    }
+
+    /**
+     * Gets the potion which caused this event
+     *
+     * @return The thrown potion entity
+     */
+    public ThrownPotion getPotion() {
+        return (ThrownPotion) getEntity();
+    }
+
+    /**
+     * Retrieves a list of all effected entities
+     *
+     * @return A fresh copy of the affected entity list
+     */
+    public Collection<LivingEntity> getAffectedEntities() {
+        return new ArrayList<LivingEntity>(affectedEntities.keySet());
+    }
+
+    /**
+     * Gets the intensity of the potion's effects for given entity; This
+     * depends on the distance to the impact center
+     *
+     * @param entity Which entity to get intensity for
+     * @return intensity relative to maximum effect; 0.0: not affected; 1.0:
+     *     fully hit by potion effects
+     */
+    public double getIntensity(LivingEntity entity) {
+        Double intensity = affectedEntities.get(entity);
+        return intensity != null ? intensity : 0.0;
+    }
+
+    /**
+     * Overwrites the intensity for a given entity
+     *
+     * @param entity For which entity to define a new intensity
+     * @param intensity relative to maximum effect
+     */
+    public void setIntensity(LivingEntity entity, double intensity) {
+        Validate.notNull(entity, "You must specify a valid entity.");
+        if (intensity <= 0.0) {
+            affectedEntities.remove(entity);
+        } else {
+            affectedEntities.put(entity, Math.min(intensity, 1.0));
+        }
+    }
+
+    public boolean isCancelled() {
+        return cancelled;
+    }
+
+    public void setCancelled(boolean cancel) {
+        cancelled = cancel;
+    }
+
+    @Override
+    public HandlerList getHandlers() {
+        return handlers;
+    }
+
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+}
diff --git a/src/main/java/org/bukkit/event/inventory/InventoryDragEvent.java b/src/main/java/org/bukkit/event/inventory/InventoryDragEvent.java
new file mode 100644
index 0000000..a9e09ff
--- /dev/null
+++ b/src/main/java/org/bukkit/event/inventory/InventoryDragEvent.java
@@ -0,0 +1,164 @@
+package org.bukkit.event.inventory;
+
+import java.util.Collections;
+import java.util.Map;
+import java.util.Set;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.Location;
+import org.bukkit.entity.HumanEntity;
+import org.bukkit.entity.Player;
+import org.bukkit.event.HandlerList;
+import org.bukkit.inventory.Inventory;
+import org.bukkit.inventory.InventoryView;
+import org.bukkit.inventory.ItemStack;
+import org.bukkit.plugin.Plugin;
+import org.bukkit.scheduler.BukkitScheduler;
+
+import com.google.common.collect.ImmutableSet;
+
+/**
+ * This event is called when the player drags an item in their cursor across
+ * the inventory. The ItemStack is distributed across the slots the
+ * HumanEntity dragged over. The method of distribution is described by the 
+ * DragType returned by {@link #getType()}.
+ * <p>
+ * Canceling this event will result in none of the changes described in
+ * {@link #getNewItems()} being applied to the Inventory.
+ * <p>
+ * Because InventoryDragEvent occurs within a modification of the Inventory,
+ * not all Inventory related methods are safe to use.
+ * <p>
+ * The following should never be invoked by an EventHandler for
+ * InventoryDragEvent using the HumanEntity or InventoryView associated with
+ * this event.
+ * <ul>
+ * <li>{@link HumanEntity#closeInventory()}
+ * <li>{@link HumanEntity#openInventory(Inventory)}
+ * <li>{@link HumanEntity#openWorkbench(Location, boolean)}
+ * <li>{@link HumanEntity#openEnchanting(Location, boolean)}
+ * <li>{@link InventoryView#close()}
+ * </ul>
+ * To invoke one of these methods, schedule a task using 
+ * {@link BukkitScheduler#runTask(Plugin, Runnable)}, which will run the task
+ * on the next tick.  Also be aware that this is not an exhaustive list, and
+ * other methods could potentially create issues as well.
+ * <p>
+ * Assuming the EntityHuman associated with this event is an instance of a
+ * Player, manipulating the MaxStackSize or contents of an Inventory will
+ * require an Invocation of {@link Player#updateInventory()}.
+ * <p>
+ * Any modifications to slots that are modified by the results of this
+ * InventoryDragEvent will be overwritten. To change these slots, this event
+ * should be cancelled and the changes applied. Alternatively, scheduling a
+ * task using {@link BukkitScheduler#runTask(Plugin, Runnable)}, which would
+ * execute the task on the next tick, would work as well.
+ */
+public class InventoryDragEvent extends InventoryInteractEvent {
+    private static final HandlerList handlers = new HandlerList();
+    private final DragType type;
+    private final Map<Integer, ItemStack> addedItems;
+    private final Set<Integer> containerSlots;
+    private final ItemStack oldCursor;
+    private ItemStack newCursor;
+
+    public InventoryDragEvent(InventoryView what, ItemStack newCursor, ItemStack oldCursor, boolean right, Map<Integer, ItemStack> slots) {
+        super(what);
+
+        Validate.notNull(oldCursor);
+        Validate.notNull(slots);
+
+        type = right ? DragType.SINGLE : DragType.EVEN;
+        this.newCursor = newCursor;
+        this.oldCursor = oldCursor;
+        this.addedItems = slots;
+        ImmutableSet.Builder<Integer> b = ImmutableSet.builder();
+        for (Integer slot : slots.keySet()) {
+            b.add(what.convertSlot(slot));
+        }
+        this.containerSlots = b.build();
+    }
+
+    /**
+     * Gets all items to be added to the inventory in this drag.
+     *
+     * @return map from raw slot id to new ItemStack
+     */
+    public Map<Integer, ItemStack> getNewItems() {
+        return Collections.unmodifiableMap(addedItems);
+    }
+
+    /**
+     * Gets the raw slot ids to be changed in this drag.
+     *
+     * @return list of raw slot ids, suitable for getView().getItem(int)
+     */
+    public Set<Integer> getRawSlots() {
+        return addedItems.keySet();
+    }
+
+    /**
+     * Gets the slots to be changed in this drag.
+     *
+     * @return list of converted slot ids, suitable for {@link
+     *     org.bukkit.inventory.Inventory#getItem(int)}.
+     */
+    public Set<Integer> getInventorySlots() {
+        return containerSlots;
+    }
+
+    /**
+     * Gets the result cursor after the drag is done. The returned value is
+     * mutable.
+     *
+     * @return the result cursor
+     */
+    public ItemStack getCursor() {
+        return newCursor;
+    }
+
+    /**
+     * Sets the result cursor after the drag is done.
+     * <p>
+     * Changing this item stack changes the cursor item. Note that changing
+     * the affected "dragged" slots does not change this ItemStack, nor does
+     * changing this ItemStack affect the "dragged" slots.
+     *
+     * @param newCursor the new cursor ItemStack
+     */
+    public void setCursor(ItemStack newCursor) {
+        this.newCursor = newCursor;
+    }
+
+    /**
+     * Gets an ItemStack representing the cursor prior to any modifications
+     * as a result of this drag.
+     *
+     * @return the original cursor
+     */
+    public ItemStack getOldCursor() {
+        return oldCursor.clone();
+    }
+
+    /**
+     * Gets the DragType that describes the behavior of ItemStacks placed
+     * after this InventoryDragEvent.
+     * <p>
+     * The ItemStacks and the raw slots that they're being applied to can be
+     * found using {@link #getNewItems()}.
+     *
+     * @return the DragType of this InventoryDragEvent
+     */
+    public DragType getType() {
+        return type;
+    }
+
+    @Override
+    public HandlerList getHandlers() {
+        return handlers;
+    }
+
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+}
diff --git a/src/main/java/org/bukkit/event/inventory/InventoryMoveItemEvent.java b/src/main/java/org/bukkit/event/inventory/InventoryMoveItemEvent.java
new file mode 100644
index 0000000..8afd028
--- /dev/null
+++ b/src/main/java/org/bukkit/event/inventory/InventoryMoveItemEvent.java
@@ -0,0 +1,108 @@
+package org.bukkit.event.inventory;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.event.Cancellable;
+import org.bukkit.event.Event;
+import org.bukkit.event.HandlerList;
+import org.bukkit.inventory.Inventory;
+import org.bukkit.inventory.ItemStack;
+
+/**
+ * Called when some entity or block (e.g. hopper) tries to move items directly
+ * from one inventory to another.
+ * <p>
+ * When this event is called, the initiator may already have removed the item
+ * from the source inventory and is ready to move it into the destination
+ * inventory.
+ * <p>
+ * If this event is cancelled, the items will be returned to the source
+ * inventory, if needed.
+ * <p>
+ * If this event is not cancelled, the initiator will try to put the ItemStack
+ * into the destination inventory. If this is not possible and the ItemStack
+ * has not been modified, the source inventory slot will be restored to its
+ * former state. Otherwise any additional items will be discarded.
+ */
+public class InventoryMoveItemEvent extends Event implements Cancellable {
+    private static final HandlerList handlers = new HandlerList();
+    private boolean cancelled;
+    private final Inventory sourceInventory;
+    private final Inventory destinationInventory;
+    private ItemStack itemStack;
+    private final boolean didSourceInitiate;
+
+    public InventoryMoveItemEvent(final Inventory sourceInventory, final ItemStack itemStack, final Inventory destinationInventory, final boolean didSourceInitiate) {
+        Validate.notNull(itemStack, "ItemStack cannot be null");
+        this.sourceInventory = sourceInventory;
+        this.itemStack = itemStack;
+        this.destinationInventory = destinationInventory;
+        this.didSourceInitiate = didSourceInitiate;
+    }
+
+    /**
+     * Gets the Inventory that the ItemStack is being taken from
+     *
+     * @return Inventory that the ItemStack is being taken from
+     */
+    public Inventory getSource() {
+        return sourceInventory;
+    }
+
+    /**
+     * Gets the ItemStack being moved; if modified, the original item will not
+     * be removed from the source inventory.
+     *
+     * @return ItemStack
+     */
+    public ItemStack getItem() {
+        return itemStack.clone();
+    }
+
+    /**
+     * Sets the ItemStack being moved; if this is different from the original
+     * ItemStack, the original item will not be removed from the source
+     * inventory.
+     *
+     * @param itemStack The ItemStack
+     */
+    public void setItem(ItemStack itemStack) {
+        Validate.notNull(itemStack, "ItemStack cannot be null.  Cancel the event if you want nothing to be transferred.");
+        this.itemStack = itemStack.clone();
+    }
+
+    /**
+     * Gets the Inventory that the ItemStack is being put into
+     *
+     * @return Inventory that the ItemStack is being put into
+     */
+    public Inventory getDestination() {
+        return destinationInventory;
+    }
+
+    /**
+     * Gets the Inventory that initiated the transfer. This will always be
+     * either the destination or source Inventory.
+     *
+     * @return Inventory that initiated the transfer
+     */
+    public Inventory getInitiator() {
+        return didSourceInitiate ? sourceInventory : destinationInventory;
+    }
+
+    public boolean isCancelled() {
+        return cancelled;
+    }
+
+    public void setCancelled(boolean cancel) {
+        this.cancelled = cancel;
+    }
+
+    @Override
+    public HandlerList getHandlers() {
+        return handlers;
+    }
+
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+}
diff --git a/src/main/java/org/bukkit/event/player/PlayerChatEvent.java b/src/main/java/org/bukkit/event/player/PlayerChatEvent.java
new file mode 100644
index 0000000..f363144
--- /dev/null
+++ b/src/main/java/org/bukkit/event/player/PlayerChatEvent.java
@@ -0,0 +1,125 @@
+package org.bukkit.event.player;
+
+import java.util.HashSet;
+import java.util.Set;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.Warning;
+import org.bukkit.entity.Player;
+import org.bukkit.event.Cancellable;
+import org.bukkit.event.HandlerList;
+
+/**
+ * Holds information for player chat and commands
+ *
+ * @deprecated This event will fire from the main thread and allows the use of
+ *     all of the Bukkit API, unlike the {@link AsyncPlayerChatEvent}.
+ *     <p>
+ *     Listening to this event forces chat to wait for the main thread which
+ *     causes delays for chat. {@link AsyncPlayerChatEvent} is the encouraged
+ *     alternative for thread safe implementations.
+ */
+@Deprecated
+@Warning(reason="Listening to this event forces chat to wait for the main thread, delaying chat messages.")
+public class PlayerChatEvent extends PlayerEvent implements Cancellable {
+    private static final HandlerList handlers = new HandlerList();
+    private boolean cancel = false;
+    private String message;
+    private String format;
+    private final Set<Player> recipients;
+
+    public PlayerChatEvent(final Player player, final String message) {
+        super(player);
+        this.message = message;
+        this.format = "<%1$s> %2$s";
+        this.recipients = new HashSet<Player>(player.getServer().getOnlinePlayers());
+    }
+
+    public PlayerChatEvent(final Player player, final String message, final String format, final Set<Player> recipients) {
+        super(player);
+        this.message = message;
+        this.format = format;
+        this.recipients = recipients;
+    }
+
+    public boolean isCancelled() {
+        return cancel;
+    }
+
+    public void setCancelled(boolean cancel) {
+        this.cancel = cancel;
+    }
+
+    /**
+     * Gets the message that the player is attempting to send
+     *
+     * @return Message the player is attempting to send
+     */
+    public String getMessage() {
+        return message;
+    }
+
+    /**
+     * Sets the message that the player will send
+     *
+     * @param message New message that the player will send
+     */
+    public void setMessage(String message) {
+        this.message = message;
+    }
+
+    /**
+     * Sets the player that this message will display as, or command will be
+     * executed as
+     *
+     * @param player New player which this event will execute as
+     */
+    public void setPlayer(final Player player) {
+        Validate.notNull(player, "Player cannot be null");
+        this.player = player;
+    }
+
+    /**
+     * Gets the format to use to display this chat message
+     *
+     * @return String.Format compatible format string
+     */
+    public String getFormat() {
+        return format;
+    }
+
+    /**
+     * Sets the format to use to display this chat message
+     *
+     * @param format String.Format compatible format string
+     */
+    public void setFormat(final String format) {
+        // Oh for a better way to do this!
+        try {
+            String.format(format, player, message);
+        } catch (RuntimeException ex) {
+            ex.fillInStackTrace();
+            throw ex;
+        }
+
+        this.format = format;
+    }
+
+    /**
+     * Gets a set of recipients that this chat message will be displayed to
+     *
+     * @return All Players who will see this chat message
+     */
+    public Set<Player> getRecipients() {
+        return recipients;
+    }
+
+    @Override
+    public HandlerList getHandlers() {
+        return handlers;
+    }
+
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+}
diff --git a/src/main/java/org/bukkit/event/player/PlayerChatTabCompleteEvent.java b/src/main/java/org/bukkit/event/player/PlayerChatTabCompleteEvent.java
new file mode 100644
index 0000000..53eb6dc
--- /dev/null
+++ b/src/main/java/org/bukkit/event/player/PlayerChatTabCompleteEvent.java
@@ -0,0 +1,70 @@
+package org.bukkit.event.player;
+
+import java.util.Collection;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.entity.Player;
+import org.bukkit.event.HandlerList;
+
+/**
+ * Called when a player attempts to tab-complete a chat message.
+ */
+public class PlayerChatTabCompleteEvent extends PlayerEvent {
+    private static final HandlerList handlers = new HandlerList();
+    private final String message;
+    private final String lastToken;
+    private final Collection<String> completions;
+
+    public PlayerChatTabCompleteEvent(final Player who, final String message, final Collection<String> completions) {
+        super(who);
+        Validate.notNull(message, "Message cannot be null");
+        Validate.notNull(completions, "Completions cannot be null");
+        this.message = message;
+        int i = message.lastIndexOf(' ');
+        if (i < 0) {
+            this.lastToken = message;
+        } else {
+            this.lastToken = message.substring(i + 1);
+        }
+        this.completions = completions;
+    }
+
+    /**
+     * Gets the chat message being tab-completed.
+     *
+     * @return the chat message
+     */
+    public String getChatMessage() {
+        return message;
+    }
+
+    /**
+     * Gets the last 'token' of the message being tab-completed.
+     * <p>
+     * The token is the substring starting with the character after the last
+     * space in the message.
+     *
+     * @return The last token for the chat message
+     */
+    public String getLastToken() {
+        return lastToken;
+    }
+
+    /**
+     * This is the collection of completions for this event.
+     *
+     * @return the current completions
+     */
+    public Collection<String> getTabCompletions() {
+        return completions;
+    }
+
+    @Override
+    public HandlerList getHandlers() {
+        return handlers;
+    }
+
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+}
diff --git a/src/main/java/org/bukkit/event/player/PlayerCommandPreprocessEvent.java b/src/main/java/org/bukkit/event/player/PlayerCommandPreprocessEvent.java
new file mode 100644
index 0000000..eabef00
--- /dev/null
+++ b/src/main/java/org/bukkit/event/player/PlayerCommandPreprocessEvent.java
@@ -0,0 +1,172 @@
+package org.bukkit.event.player;
+
+import java.util.HashSet;
+import java.util.Set;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.entity.Player;
+import org.bukkit.event.Cancellable;
+import org.bukkit.event.HandlerList;
+
+/**
+ * This event is called whenever a player runs a command (by placing a slash
+ * at the start of their message). It is called early in the command handling
+ * process, and modifications in this event (via {@link #setMessage(String)})
+ * will be shown in the behavior.
+ * <p>
+ * Many plugins will have <b>no use for this event</b>, and you should
+ * attempt to avoid using it if it is not necessary.
+ * <p>
+ * Some examples of valid uses for this event are:
+ * <ul>
+ * <li>Logging executed commands to a separate file
+ * <li>Variable substitution. For example, replacing
+ *     <code>${nearbyPlayer}</code> with the name of the nearest other
+ *     player, or simulating the <code>@a</code> and <code>@p</code>
+ *     decorators used by Command Blocks in plugins that do not handle it.
+ * <li>Conditionally blocking commands belonging to other plugins. For
+ *     example, blocking the use of the <code>/home</code> command in a
+ *     combat arena.
+ * <li>Per-sender command aliases. For example, after a player runs the
+ *     command <code>/calias cr gamemode creative</code>, the next time they
+ *     run <code>/cr</code>, it gets replaced into
+ *     <code>/gamemode creative</code>. (Global command aliases should be
+ *     done by registering the alias.)
+ * </ul>
+ * <p>
+ * Examples of incorrect uses are:
+ * <ul>
+ * <li>Using this event to run command logic
+ * </ul>
+ * <p>
+ * If the event is cancelled, processing of the command will halt.
+ * <p>
+ * The state of whether or not there is a slash (<code>/</code>) at the
+ * beginning of the message should be preserved. If a slash is added or
+ * removed, unexpected behavior may result.
+ */
+public class PlayerCommandPreprocessEvent extends PlayerEvent implements Cancellable {
+    private static final HandlerList handlers = new HandlerList();
+    private boolean cancel = false;
+    private String message;
+    private String format = "<%1$s> %2$s";
+    private final Set<Player> recipients;
+
+    public PlayerCommandPreprocessEvent(final Player player, final String message) {
+        super(player);
+        this.recipients = new HashSet<Player>(player.getServer().getOnlinePlayers());
+        this.message = message;
+    }
+
+    public PlayerCommandPreprocessEvent(final Player player, final String message, final Set<Player> recipients) {
+        super(player);
+        this.recipients = recipients;
+        this.message = message;
+    }
+
+    public boolean isCancelled() {
+        return cancel;
+    }
+
+    public void setCancelled(boolean cancel) {
+        this.cancel = cancel;
+    }
+
+    /**
+     * Gets the command that the player is attempting to send.
+     * <p>
+     * All commands begin with a special character; implementations do not
+     * consider the first character when executing the content.
+     *
+     * @return Message the player is attempting to send
+     */
+    public String getMessage() {
+        return message;
+    }
+
+    /**
+     * Sets the command that the player will send.
+     * <p>
+     * All commands begin with a special character; implementations do not
+     * consider the first character when executing the content.
+     *
+     * @param command New message that the player will send
+     * @throws IllegalArgumentException if command is null or empty
+     */
+    public void setMessage(String command) throws IllegalArgumentException {
+        Validate.notNull(command, "Command cannot be null");
+        Validate.notEmpty(command, "Command cannot be empty");
+        this.message = command;
+    }
+
+    /**
+     * Sets the player that this command will be executed as.
+     *
+     * @param player New player which this event will execute as
+     * @throws IllegalArgumentException if the player provided is null
+     */
+    public void setPlayer(final Player player) throws IllegalArgumentException {
+        Validate.notNull(player, "Player cannot be null");
+        this.player = player;
+    }
+
+    /**
+     * Gets the format to use to display this chat message
+     *
+     * @deprecated This method is provided for backward compatibility with no
+     *     guarantee to the use of the format.
+     * @return String.Format compatible format string
+     */
+    @Deprecated
+    public String getFormat() {
+        return format;
+    }
+
+    /**
+     * Sets the format to use to display this chat message
+     *
+     * @deprecated This method is provided for backward compatibility with no
+     *     guarantee to the effect of modifying the format.
+     * @param format String.Format compatible format string
+     */
+    @Deprecated
+    public void setFormat(final String format) {
+        // Oh for a better way to do this!
+        try {
+            String.format(format, player, message);
+        } catch (RuntimeException ex) {
+            ex.fillInStackTrace();
+            throw ex;
+        }
+
+        this.format = format;
+    }
+
+    /**
+     * Gets a set of recipients that this chat message will be displayed to.
+     * <p>
+     * The set returned is not guaranteed to be mutable and may auto-populate
+     * on access. Any listener accessing the returned set should be aware that
+     * it may reduce performance for a lazy set implementation. Listeners
+     * should be aware that modifying the list may throw {@link
+     * UnsupportedOperationException} if the event caller provides an
+     * unmodifiable set.
+     *
+     * @deprecated This method is provided for backward compatibility with no
+     *     guarantee to the effect of viewing or modifying the set.
+     * @return All Players who will see this chat message
+     */
+    @Deprecated
+    public Set<Player> getRecipients() {
+        return recipients;
+    }
+
+    @Override
+    public HandlerList getHandlers() {
+        return handlers;
+    }
+
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+}
diff --git a/src/main/java/org/bukkit/event/player/PlayerEditBookEvent.java b/src/main/java/org/bukkit/event/player/PlayerEditBookEvent.java
new file mode 100644
index 0000000..3ffe42c
--- /dev/null
+++ b/src/main/java/org/bukkit/event/player/PlayerEditBookEvent.java
@@ -0,0 +1,124 @@
+package org.bukkit.event.player;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.Bukkit;
+import org.bukkit.entity.Player;
+import org.bukkit.event.Cancellable;
+import org.bukkit.event.HandlerList;
+import org.bukkit.inventory.meta.BookMeta;
+
+/**
+ * Called when a player edits or signs a book and quill item. If the event is
+ * cancelled, no changes are made to the BookMeta
+ */
+public class PlayerEditBookEvent extends PlayerEvent implements Cancellable {
+    private static final HandlerList handlers = new HandlerList();
+
+    private final BookMeta previousBookMeta;
+    private final int slot;
+    private BookMeta newBookMeta;
+    private boolean isSigning;
+    private boolean cancel;
+
+    public PlayerEditBookEvent(Player who, int slot, BookMeta previousBookMeta, BookMeta newBookMeta, boolean isSigning) {
+        super(who);
+
+        Validate.isTrue(slot >= 0 && slot <=8, "Slot must be in range 0-8 inclusive");
+        Validate.notNull(previousBookMeta, "Previous book meta must not be null");
+        Validate.notNull(newBookMeta, "New book meta must not be null");
+
+        Bukkit.getItemFactory().equals(previousBookMeta, newBookMeta);
+
+        this.previousBookMeta = previousBookMeta;
+        this.newBookMeta = newBookMeta;
+        this.slot = slot;
+        this.isSigning = isSigning;
+        this.cancel = false;
+    }
+
+    /**
+     * Gets the book meta currently on the book.
+     * <p>
+     * Note: this is a copy of the book meta. You cannot use this object to
+     * change the existing book meta.
+     *
+     * @return the book meta currently on the book
+     */
+    public BookMeta getPreviousBookMeta() {
+        return previousBookMeta.clone();
+    }
+
+    /**
+     * Gets the book meta that the player is attempting to add to the book.
+     * <p>
+     * Note: this is a copy of the proposed new book meta. Use {@link
+     * #setNewBookMeta(BookMeta)} to change what will actually be added to the
+     * book.
+     *
+     * @return the book meta that the player is attempting to add
+     */
+    public BookMeta getNewBookMeta() {
+        return newBookMeta.clone();
+    }
+
+    /**
+     * Gets the inventory slot number for the book item that triggered this
+     * event.
+     * <p>
+     * This is a slot number on the player's hotbar in the range 0-8.
+     *
+     * @return the inventory slot number that the book item occupies
+     */
+    public int getSlot() {
+        return slot;
+    }
+
+    /**
+     * Sets the book meta that will actually be added to the book.
+     *
+     * @param newBookMeta new book meta
+     * @throws IllegalArgumentException if the new book meta is null
+     */
+    public void setNewBookMeta(BookMeta newBookMeta) throws IllegalArgumentException {
+        Validate.notNull(newBookMeta, "New book meta must not be null");
+        Bukkit.getItemFactory().equals(newBookMeta, null);
+        this.newBookMeta = newBookMeta.clone();
+    }
+
+    /**
+     * Gets whether or not the book is being signed. If a book is signed the
+     * Material changes from BOOK_AND_QUILL to WRITTEN_BOOK.
+     *
+     * @return true if the book is being signed
+     */
+    public boolean isSigning() {
+        return isSigning;
+    }
+
+    /**
+     * Sets whether or not the book is being signed. If a book is signed the
+     * Material changes from BOOK_AND_QUILL to WRITTEN_BOOK.
+     *
+     * @param signing whether or not the book is being signed.
+     */
+    public void setSigning(boolean signing) {
+        isSigning = signing;
+    }
+
+    @Override
+    public HandlerList getHandlers() {
+        return handlers;
+    }
+
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+
+    public boolean isCancelled() {
+        return cancel;
+    }
+
+    public void setCancelled(boolean cancel) {
+        this.cancel = cancel;
+    }
+}
diff --git a/src/main/java/org/bukkit/event/player/PlayerRespawnEvent.java b/src/main/java/org/bukkit/event/player/PlayerRespawnEvent.java
new file mode 100644
index 0000000..24bbb70
--- /dev/null
+++ b/src/main/java/org/bukkit/event/player/PlayerRespawnEvent.java
@@ -0,0 +1,60 @@
+package org.bukkit.event.player;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.Location;
+import org.bukkit.entity.Player;
+import org.bukkit.event.HandlerList;
+
+/**
+ * Called when a player respawns.
+ */
+public class PlayerRespawnEvent extends PlayerEvent {
+    private static final HandlerList handlers = new HandlerList();
+    private Location respawnLocation;
+    private final boolean isBedSpawn;
+
+    public PlayerRespawnEvent(final Player respawnPlayer, final Location respawnLocation, final boolean isBedSpawn) {
+        super(respawnPlayer);
+        this.respawnLocation = respawnLocation;
+        this.isBedSpawn = isBedSpawn;
+    }
+
+    /**
+     * Gets the current respawn location
+     *
+     * @return Location current respawn location
+     */
+    public Location getRespawnLocation() {
+        return this.respawnLocation;
+    }
+
+    /**
+     * Sets the new respawn location
+     *
+     * @param respawnLocation new location for the respawn
+     */
+    public void setRespawnLocation(Location respawnLocation) {
+        Validate.notNull(respawnLocation, "Respawn location can not be null");
+        Validate.notNull(respawnLocation.getWorld(), "Respawn world can not be null");
+
+        this.respawnLocation = respawnLocation;
+    }
+
+    /**
+     * Gets whether the respawn location is the player's bed.
+     *
+     * @return true if the respawn location is the player's bed.
+     */
+    public boolean isBedSpawn() {
+        return this.isBedSpawn;
+    }
+
+    @Override
+    public HandlerList getHandlers() {
+        return handlers;
+    }
+
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+}
diff --git a/src/main/java/org/bukkit/event/server/ServerListPingEvent.java b/src/main/java/org/bukkit/event/server/ServerListPingEvent.java
new file mode 100644
index 0000000..a99bc78
--- /dev/null
+++ b/src/main/java/org/bukkit/event/server/ServerListPingEvent.java
@@ -0,0 +1,148 @@
+package org.bukkit.event.server;
+
+import java.net.InetAddress;
+import java.util.Iterator;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.entity.Player;
+import org.bukkit.event.HandlerList;
+import org.bukkit.util.CachedServerIcon;
+
+/**
+ * Called when a server list ping is coming in. Displayed players can be
+ * checked and removed by {@link #iterator() iterating} over this event.
+ */
+public class ServerListPingEvent extends ServerEvent implements Iterable<Player> {
+    private static final int MAGIC_PLAYER_COUNT = Integer.MIN_VALUE;
+    private static final HandlerList handlers = new HandlerList();
+    private final InetAddress address;
+    private String motd;
+    private final int numPlayers;
+    private int maxPlayers;
+
+    public ServerListPingEvent(final InetAddress address, final String motd, final int numPlayers, final int maxPlayers) {
+        super(); // Paper - Is this event being fired async?
+        Validate.isTrue(numPlayers >= 0, "Cannot have negative number of players online", numPlayers);
+        this.address = address;
+        this.motd = motd;
+        this.numPlayers = numPlayers;
+        this.maxPlayers = maxPlayers;
+    }
+
+    /**
+     * This constructor is intended for implementations that provide the
+     * {@link #iterator()} method, thus provided the {@link #getNumPlayers()}
+     * count.
+     * 
+     * @param address the address of the pinger
+     * @param motd the message of the day
+     * @param maxPlayers the max number of players
+     */
+    protected ServerListPingEvent(final InetAddress address, final String motd, final int maxPlayers) {
+        super(); // Paper - Is this event being fired async?
+        this.numPlayers = MAGIC_PLAYER_COUNT;
+        this.address = address;
+        this.motd = motd;
+        this.maxPlayers = maxPlayers;
+    }
+
+    /**
+     * Get the address the ping is coming from.
+     *
+     * @return the address
+     */
+    public InetAddress getAddress() {
+        return address;
+    }
+
+    /**
+     * Get the message of the day message.
+     *
+     * @return the message of the day
+     */
+    public String getMotd() {
+        return motd;
+    }
+
+    /**
+     * Change the message of the day message.
+     *
+     * @param motd the message of the day
+     */
+    public void setMotd(String motd) {
+        this.motd = motd;
+    }
+
+    /**
+     * Get the number of players sent.
+     *
+     * @return the number of players
+     */
+    public int getNumPlayers() {
+        int numPlayers = this.numPlayers;
+        if (numPlayers == MAGIC_PLAYER_COUNT) {
+            numPlayers = 0;
+            for (@SuppressWarnings("unused") final Player player : this) {
+                numPlayers++;
+            }
+        }
+        return numPlayers;
+    }
+
+    /**
+     * Get the maximum number of players sent.
+     *
+     * @return the maximum number of players
+     */
+    public int getMaxPlayers() {
+        return maxPlayers;
+    }
+
+    /**
+     * Set the maximum number of players sent.
+     *
+     * @param maxPlayers the maximum number of player
+     */
+    public void setMaxPlayers(int maxPlayers) {
+        this.maxPlayers = maxPlayers;
+    }
+
+    /**
+     * Sets the server-icon sent to the client.
+     *
+     * @param icon the icon to send to the client
+     * @throws IllegalArgumentException if the {@link CachedServerIcon} is not
+     *     created by the caller of this event; null may be accepted for some
+     *     implementations
+     * @throws UnsupportedOperationException if the caller of this event does
+     *     not support setting the server icon
+     */
+    public void setServerIcon(CachedServerIcon icon) throws IllegalArgumentException, UnsupportedOperationException {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public HandlerList getHandlers() {
+        return handlers;
+    }
+
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+
+    /**
+     * {@inheritDoc}
+     * <p>
+     * Calling the {@link Iterator#remove()} method will force that particular
+     * player to not be displayed on the player list, decrease the size
+     * returned by {@link #getNumPlayers()}, and will not be returned again by
+     * any new iterator.
+     *
+     * @throws UnsupportedOperationException if the caller of this event does
+     *     not support removing players
+     */
+    @Override
+    public Iterator<Player> iterator() throws UnsupportedOperationException {
+        throw new UnsupportedOperationException();
+    }
+}
diff --git a/src/main/java/org/bukkit/event/server/TabCompleteEvent.java b/src/main/java/org/bukkit/event/server/TabCompleteEvent.java
new file mode 100644
index 0000000..d4bdb9c
--- /dev/null
+++ b/src/main/java/org/bukkit/event/server/TabCompleteEvent.java
@@ -0,0 +1,89 @@
+package org.bukkit.event.server;
+
+import java.util.List;
+import org.apache.commons.lang3.Validate;
+import org.bukkit.command.CommandSender;
+import org.bukkit.event.Cancellable;
+import org.bukkit.event.Event;
+import org.bukkit.event.HandlerList;
+
+/**
+ * Called when a {@link CommandSender} of any description (ie: player or
+ * console) attempts to tab complete.
+ */
+public class TabCompleteEvent extends Event implements Cancellable {
+
+    private static final HandlerList handlers = new HandlerList();
+    //
+    private final CommandSender sender;
+    private final String buffer;
+    private List<String> completions;
+    private boolean cancelled;
+
+    public TabCompleteEvent(CommandSender sender, String buffer, List<String> completions) {
+        Validate.notNull(sender, "sender");
+        Validate.notNull(buffer, "buffer");
+        Validate.notNull(completions, "completions");
+
+        this.sender = sender;
+        this.buffer = buffer;
+        this.completions = completions;
+    }
+
+    /**
+     * Get the sender completing this command.
+     *
+     * @return the {@link CommandSender} instance
+     */
+    public CommandSender getSender() {
+        return sender;
+    }
+
+    /**
+     * Return the entire buffer which formed the basis of this completion.
+     *
+     * @return command buffer, as entered
+     */
+    public String getBuffer() {
+        return buffer;
+    }
+
+    /**
+     * The list of completions which will be offered to the sender, in order.
+     * This list is mutable and reflects what will be offered.
+     *
+     * @return a list of offered completions
+     */
+    public List<String> getCompletions() {
+        return completions;
+    }
+
+    /**
+     * Set the completions offered, overriding any already set.
+     *
+     * @param completions the new completions
+     */
+    public void setCompletions(List<String> completions) {
+        Validate.notNull(completions);
+        this.completions = completions;
+    }
+
+    @Override
+    public boolean isCancelled() {
+        return cancelled;
+    }
+
+    @Override
+    public void setCancelled(boolean cancelled) {
+        this.cancelled = cancelled;
+    }
+
+    @Override
+    public HandlerList getHandlers() {
+        return handlers;
+    }
+
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+}
diff --git a/src/main/java/org/bukkit/help/GenericCommandHelpTopic.java b/src/main/java/org/bukkit/help/GenericCommandHelpTopic.java
new file mode 100644
index 0000000..0f897de
--- /dev/null
+++ b/src/main/java/org/bukkit/help/GenericCommandHelpTopic.java
@@ -0,0 +1,80 @@
+package org.bukkit.help;
+
+import org.bukkit.ChatColor;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.apache.commons.lang3.StringUtils;
+import org.bukkit.command.ConsoleCommandSender;
+import org.bukkit.command.PluginCommand;
+import org.bukkit.command.defaults.VanillaCommand;
+import org.bukkit.help.HelpTopic;
+
+/**
+ * Lacking an alternative, the help system will create instances of
+ * GenericCommandHelpTopic for each command in the server's CommandMap. You
+ * can use this class as a base class for custom help topics, or as an example
+ * for how to write your own.
+ */
+public class GenericCommandHelpTopic extends HelpTopic {
+
+    protected Command command;
+
+    public GenericCommandHelpTopic(Command command) {
+        this.command = command;
+
+        if (command.getLabel().startsWith("/")) {
+            name = command.getLabel();
+        } else {
+            name = "/" + command.getLabel();
+        }
+
+        // The short text is the first line of the description
+        int i = command.getDescription().indexOf("\n");
+        if (i > 1) {
+            shortText = command.getDescription().substring(0, i - 1);
+        } else {
+            shortText = command.getDescription();
+        }
+
+        // Build full text
+        StringBuffer sb = new StringBuffer();
+
+        sb.append(ChatColor.GOLD);
+        sb.append("Description: ");
+        sb.append(ChatColor.WHITE);
+        sb.append(command.getDescription());
+
+        sb.append("\n");
+
+        sb.append(ChatColor.GOLD);
+        sb.append("Usage: ");
+        sb.append(ChatColor.WHITE);
+        sb.append(command.getUsage().replace("<command>", name.substring(1)));
+
+        if (command.getAliases().size() > 0) {
+            sb.append("\n");
+            sb.append(ChatColor.GOLD);
+            sb.append("Aliases: ");
+            sb.append(ChatColor.WHITE);
+            sb.append(ChatColor.WHITE + StringUtils.join(command.getAliases(), ", "));
+        }
+        fullText = sb.toString();
+    }
+
+    public boolean canSee(CommandSender sender) {
+        if (!command.isRegistered() && !(command instanceof VanillaCommand)) {
+            // Unregistered commands should not show up in the help (ignore VanillaCommands)
+            return false;
+        }
+
+        if (sender instanceof ConsoleCommandSender) {
+            return true;
+        }
+
+        if (amendedPermission != null) {
+            return sender.hasPermission(amendedPermission);
+        } else {
+            return command.testPermissionSilent(sender);
+        }
+    }
+}
diff --git a/src/main/java/org/bukkit/inventory/ItemStack.java b/src/main/java/org/bukkit/inventory/ItemStack.java
index c412224..a2f00c9 100644
--- a/src/main/java/org/bukkit/inventory/ItemStack.java
+++ b/src/main/java/org/bukkit/inventory/ItemStack.java
@@ -4,7 +4,7 @@ import com.google.common.collect.ImmutableMap;
 import java.util.LinkedHashMap;
 import java.util.Map;
 
-import org.apache.commons.lang.Validate;
+import org.apache.commons.lang3.Validate;
 import org.bukkit.Bukkit;
 import org.bukkit.Material;
 import org.bukkit.Utility;
diff --git a/src/main/java/org/bukkit/inventory/ShapedRecipe.java b/src/main/java/org/bukkit/inventory/ShapedRecipe.java
new file mode 100644
index 0000000..aadcef6
--- /dev/null
+++ b/src/main/java/org/bukkit/inventory/ShapedRecipe.java
@@ -0,0 +1,148 @@
+package org.bukkit.inventory;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import org.apache.commons.lang3.Validate;
+
+import org.bukkit.Material;
+import org.bukkit.material.MaterialData;
+
+/**
+ * Represents a shaped (ie normal) crafting recipe.
+ */
+public class ShapedRecipe implements Recipe {
+    private ItemStack output;
+    private String[] rows;
+    private Map<Character, ItemStack> ingredients = new HashMap<Character, ItemStack>();
+
+    /**
+     * Create a shaped recipe to craft the specified ItemStack. The
+     * constructor merely determines the result and type; to set the actual
+     * recipe, you'll need to call the appropriate methods.
+     *
+     * @param result The item you want the recipe to create.
+     * @see ShapedRecipe#shape(String...)
+     * @see ShapedRecipe#setIngredient(char, Material)
+     * @see ShapedRecipe#setIngredient(char, Material, int)
+     * @see ShapedRecipe#setIngredient(char, MaterialData)
+     */
+    public ShapedRecipe(ItemStack result) {
+        this.output = new ItemStack(result);
+    }
+
+    /**
+     * Set the shape of this recipe to the specified rows. Each character
+     * represents a different ingredient; exactly what each character
+     * represents is set separately. The first row supplied corresponds with
+     * the upper most part of the recipe on the workbench e.g. if all three
+     * rows are supplies the first string represents the top row on the
+     * workbench.
+     *
+     * @param shape The rows of the recipe (up to 3 rows).
+     * @return The changed recipe, so you can chain calls.
+     */
+    public ShapedRecipe shape(final String... shape) {
+        Validate.notNull(shape, "Must provide a shape");
+        Validate.isTrue(shape.length > 0 && shape.length < 4, "Crafting recipes should be 1, 2, 3 rows, not ", shape.length);
+
+        for (String row : shape) {
+            Validate.notNull(row, "Shape cannot have null rows");
+            Validate.isTrue(row.length() > 0 && row.length() < 4, "Crafting rows should be 1, 2, or 3 characters, not ", row.length());
+        }
+        this.rows = new String[shape.length];
+        for (int i = 0; i < shape.length; i++) {
+            this.rows[i] = shape[i];
+        }
+
+        // Remove character mappings for characters that no longer exist in the shape
+        HashMap<Character, ItemStack> newIngredients = new HashMap<Character, ItemStack>();
+        for (String row : shape) {
+            for (Character c : row.toCharArray()) {
+                newIngredients.put(c, ingredients.get(c));
+            }
+        }
+        this.ingredients = newIngredients;
+
+        return this;
+    }
+
+    /**
+     * Sets the material that a character in the recipe shape refers to.
+     *
+     * @param key The character that represents the ingredient in the shape.
+     * @param ingredient The ingredient.
+     * @return The changed recipe, so you can chain calls.
+     */
+    public ShapedRecipe setIngredient(char key, MaterialData ingredient) {
+        return setIngredient(key, ingredient.getItemType(), ingredient.getData());
+    }
+
+    /**
+     * Sets the material that a character in the recipe shape refers to.
+     *
+     * @param key The character that represents the ingredient in the shape.
+     * @param ingredient The ingredient.
+     * @return The changed recipe, so you can chain calls.
+     */
+    public ShapedRecipe setIngredient(char key, Material ingredient) {
+        return setIngredient(key, ingredient, 0);
+    }
+
+    /**
+     * Sets the material that a character in the recipe shape refers to.
+     *
+     * @param key The character that represents the ingredient in the shape.
+     * @param ingredient The ingredient.
+     * @param raw The raw material data as an integer.
+     * @return The changed recipe, so you can chain calls.
+     * @deprecated Magic value
+     */
+    @Deprecated
+    public ShapedRecipe setIngredient(char key, Material ingredient, int raw) {
+        Validate.isTrue(ingredients.containsKey(key), "Symbol does not appear in the shape:", key);
+
+        // -1 is the old wildcard, map to Short.MAX_VALUE as the new one
+        if (raw == -1) {
+            raw = Short.MAX_VALUE;
+        }
+
+        ingredients.put(key, new ItemStack(ingredient, 1, (short) raw));
+        return this;
+    }
+
+    /**
+     * Get a copy of the ingredients map.
+     *
+     * @return The mapping of character to ingredients.
+     */
+    public Map<Character, ItemStack> getIngredientMap() {
+        HashMap<Character, ItemStack> result = new HashMap<Character, ItemStack>();
+        for (Map.Entry<Character, ItemStack> ingredient : ingredients.entrySet()) {
+            if (ingredient.getValue() == null) {
+                result.put(ingredient.getKey(), null);
+            } else {
+                result.put(ingredient.getKey(), ingredient.getValue().clone());
+            }
+        }
+        return result;
+    }
+
+    /**
+     * Get the shape.
+     *
+     * @return The recipe's shape.
+     */
+    public String[] getShape() {
+        return rows.clone();
+    }
+
+    /**
+     * Get the result.
+     *
+     * @return The result stack.
+     */
+    public ItemStack getResult() {
+        return output.clone();
+    }
+}
diff --git a/src/main/java/org/bukkit/inventory/ShapelessRecipe.java b/src/main/java/org/bukkit/inventory/ShapelessRecipe.java
new file mode 100644
index 0000000..1da6538
--- /dev/null
+++ b/src/main/java/org/bukkit/inventory/ShapelessRecipe.java
@@ -0,0 +1,226 @@
+package org.bukkit.inventory;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+import org.apache.commons.lang3.Validate;
+
+import org.bukkit.Material;
+import org.bukkit.material.MaterialData;
+
+/**
+ * Represents a shapeless recipe, where the arrangement of the ingredients on
+ * the crafting grid does not matter.
+ */
+public class ShapelessRecipe implements Recipe {
+    private ItemStack output;
+    private List<ItemStack> ingredients = new ArrayList<ItemStack>();
+
+    /**
+     * Create a shapeless recipe to craft the specified ItemStack. The
+     * constructor merely determines the result and type; to set the actual
+     * recipe, you'll need to call the appropriate methods.
+     *
+     * @param result The item you want the recipe to create.
+     * @see ShapelessRecipe#addIngredient(Material)
+     * @see ShapelessRecipe#addIngredient(MaterialData)
+     * @see ShapelessRecipe#addIngredient(Material,int)
+     * @see ShapelessRecipe#addIngredient(int,Material)
+     * @see ShapelessRecipe#addIngredient(int,MaterialData)
+     * @see ShapelessRecipe#addIngredient(int,Material,int)
+     */
+    public ShapelessRecipe(ItemStack result) {
+        this.output = new ItemStack(result);
+    }
+
+    /**
+     * Adds the specified ingredient.
+     *
+     * @param ingredient The ingredient to add.
+     * @return The changed recipe, so you can chain calls.
+     */
+    public ShapelessRecipe addIngredient(MaterialData ingredient) {
+        return addIngredient(1, ingredient);
+    }
+
+    /**
+     * Adds the specified ingredient.
+     *
+     * @param ingredient The ingredient to add.
+     * @return The changed recipe, so you can chain calls.
+     */
+    public ShapelessRecipe addIngredient(Material ingredient) {
+        return addIngredient(1, ingredient, 0);
+    }
+
+    /**
+     * Adds the specified ingredient.
+     *
+     * @param ingredient The ingredient to add.
+     * @param rawdata The data value, or -1 to allow any data value.
+     * @return The changed recipe, so you can chain calls.
+     * @deprecated Magic value
+     */
+    @Deprecated
+    public ShapelessRecipe addIngredient(Material ingredient, int rawdata) {
+        return addIngredient(1, ingredient, rawdata);
+    }
+
+    /**
+     * Adds multiples of the specified ingredient.
+     *
+     * @param count How many to add (can't be more than 9!)
+     * @param ingredient The ingredient to add.
+     * @return The changed recipe, so you can chain calls.
+     */
+    public ShapelessRecipe addIngredient(int count, MaterialData ingredient) {
+        return addIngredient(count, ingredient.getItemType(), ingredient.getData());
+    }
+
+    /**
+     * Adds multiples of the specified ingredient.
+     *
+     * @param count How many to add (can't be more than 9!)
+     * @param ingredient The ingredient to add.
+     * @return The changed recipe, so you can chain calls.
+     */
+    public ShapelessRecipe addIngredient(int count, Material ingredient) {
+        return addIngredient(count, ingredient, 0);
+    }
+
+    /**
+     * Adds multiples of the specified ingredient.
+     *
+     * @param count How many to add (can't be more than 9!)
+     * @param ingredient The ingredient to add.
+     * @param rawdata The data value, or -1 to allow any data value.
+     * @return The changed recipe, so you can chain calls.
+     * @deprecated Magic value
+     */
+    @Deprecated
+    public ShapelessRecipe addIngredient(int count, Material ingredient, int rawdata) {
+        Validate.isTrue(ingredients.size() + count <= 9, "Shapeless recipes cannot have more than 9 ingredients");
+
+        // -1 is the old wildcard, map to Short.MAX_VALUE as the new one
+        if (rawdata == -1) {
+            rawdata = Short.MAX_VALUE;
+        }
+
+        while (count-- > 0) {
+            ingredients.add(new ItemStack(ingredient, 1, (short) rawdata));
+        }
+        return this;
+    }
+
+    /**
+     * Removes an ingredient from the list. If the ingredient occurs multiple
+     * times, only one instance of it is removed. Only removes exact matches,
+     * with a data value of 0.
+     *
+     * @param ingredient The ingredient to remove
+     * @return The changed recipe.
+     */
+    public ShapelessRecipe removeIngredient(Material ingredient) {
+        return removeIngredient(ingredient, 0);
+    }
+
+    /**
+     * Removes an ingredient from the list. If the ingredient occurs multiple
+     * times, only one instance of it is removed. If the data value is -1,
+     * only ingredients with a -1 data value will be removed.
+     *
+     * @param ingredient The ingredient to remove
+     * @return The changed recipe.
+     */
+    public ShapelessRecipe removeIngredient(MaterialData ingredient) {
+        return removeIngredient(ingredient.getItemType(), ingredient.getData());
+    }
+
+    /**
+     * Removes multiple instances of an ingredient from the list. If there are
+     * less instances then specified, all will be removed. Only removes exact
+     * matches, with a data value of 0.
+     *
+     * @param count The number of copies to remove.
+     * @param ingredient The ingredient to remove
+     * @return The changed recipe.
+     */
+    public ShapelessRecipe removeIngredient(int count, Material ingredient) {
+        return removeIngredient(count, ingredient, 0);
+    }
+
+    /**
+     * Removes multiple instances of an ingredient from the list. If there are
+     * less instances then specified, all will be removed. If the data value
+     * is -1, only ingredients with a -1 data value will be removed.
+     *
+     * @param count The number of copies to remove.
+     * @param ingredient The ingredient to remove.
+     * @return The changed recipe.
+     */
+    public ShapelessRecipe removeIngredient(int count, MaterialData ingredient) {
+        return removeIngredient(count, ingredient.getItemType(), ingredient.getData());
+    }
+
+    /**
+     * Removes an ingredient from the list. If the ingredient occurs multiple
+     * times, only one instance of it is removed. If the data value is -1,
+     * only ingredients with a -1 data value will be removed.
+     *
+     * @param ingredient The ingredient to remove
+     * @param rawdata The data value;
+     * @return The changed recipe.
+     * @deprecated Magic value
+     */
+    @Deprecated
+    public ShapelessRecipe removeIngredient(Material ingredient, int rawdata) {
+        return removeIngredient(1, ingredient, rawdata);
+    }
+
+    /**
+     * Removes multiple instances of an ingredient from the list. If there are
+     * less instances then specified, all will be removed. If the data value
+     * is -1, only ingredients with a -1 data value will be removed.
+     *
+     * @param count The number of copies to remove.
+     * @param ingredient The ingredient to remove.
+     * @param rawdata The data value.
+     * @return The changed recipe.
+     * @deprecated Magic value
+     */
+    @Deprecated
+    public ShapelessRecipe removeIngredient(int count, Material ingredient, int rawdata) {
+        Iterator<ItemStack> iterator = ingredients.iterator();
+        while (count > 0 && iterator.hasNext()) {
+            ItemStack stack = iterator.next();
+            if (stack.getType() == ingredient && stack.getDurability() == rawdata) {
+                iterator.remove();
+                count--;
+            }
+        }
+        return this;
+    }
+
+    /**
+     * Get the result of this recipe.
+     *
+     * @return The result stack.
+     */
+    public ItemStack getResult() {
+        return output.clone();
+    }
+
+    /**
+     * Get the list of ingredients used for this recipe.
+     *
+     * @return The input list
+     */
+    public List<ItemStack> getIngredientList() {
+        ArrayList<ItemStack> result = new ArrayList<ItemStack>(ingredients.size());
+        for (ItemStack ingredient : ingredients) {
+            result.add(ingredient.clone());
+        }
+        return result;
+    }
+}
diff --git a/src/main/java/org/bukkit/material/Mushroom.java b/src/main/java/org/bukkit/material/Mushroom.java
new file mode 100644
index 0000000..7afbf28
--- /dev/null
+++ b/src/main/java/org/bukkit/material/Mushroom.java
@@ -0,0 +1,295 @@
+package org.bukkit.material;
+
+import java.util.EnumSet;
+import java.util.Set;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.Material;
+import org.bukkit.block.BlockFace;
+import org.bukkit.material.types.MushroomBlockTexture;
+
+/**
+ * Represents a huge mushroom block with certain combinations of faces set to
+ * cap, pores or stem.
+ *
+ * @see Material#HUGE_MUSHROOM_1
+ * @see Material#HUGE_MUSHROOM_2
+ */
+public class Mushroom extends MaterialData {
+    private static final byte NORTH_LIMIT = 4;
+    private static final byte SOUTH_LIMIT = 6;
+    private static final byte EAST_WEST_LIMIT = 3;
+    private static final byte EAST_REMAINDER = 0;
+    private static final byte WEST_REMAINDER = 1;
+    private static final byte NORTH_SOUTH_MOD = 3;
+    private static final byte EAST_WEST_MOD = 1;
+
+    /**
+     * Constructs a brown/red mushroom block with all sides set to pores.
+     *
+     * @param shroom A brown or red mushroom material type.
+     *
+     * @see Material#HUGE_MUSHROOM_1
+     * @see Material#HUGE_MUSHROOM_2
+     */
+    public Mushroom(Material shroom) {
+        super(shroom);
+        Validate.isTrue(shroom == Material.HUGE_MUSHROOM_1 || shroom == Material.HUGE_MUSHROOM_2, "Not a mushroom!");
+    }
+
+    /**
+     * Constructs a brown/red mushroom cap block with the specified face or
+     * faces set to cap texture.
+     *
+     * Setting any of the four sides will also set the top to cap.
+     *
+     * To set two side faces at once use e.g. north-west.
+     *
+     * Specify self to set all six faces at once.
+     *
+     * @param shroom A brown or red mushroom material type.
+     * @param capFace The face or faces to set to mushroom cap texture.
+     *
+     * @see Material#HUGE_MUSHROOM_1
+     * @see Material#HUGE_MUSHROOM_2
+     * @see BlockFace
+     */
+    public Mushroom(Material shroom, BlockFace capFace) {
+        this(shroom, MushroomBlockTexture.getCapByFace(capFace));
+    }
+
+    /**
+     * Constructs a brown/red mushroom block with the specified textures.
+     *
+     * @param shroom A brown or red mushroom material type.
+     * @param texture The textured mushroom faces.
+     *
+     * @see Material#HUGE_MUSHROOM_1
+     * @see Material#HUGE_MUSHROOM_2
+     */
+    public Mushroom(Material shroom, MushroomBlockTexture texture) {
+        this(shroom, texture.getData());
+    }
+
+    /**
+     * @param shroom the type
+     * @param data the raw data value
+     * @deprecated Magic value
+     */
+    @Deprecated
+    public Mushroom(Material shroom, byte data) {
+        super(shroom, data);
+        Validate.isTrue(shroom == Material.HUGE_MUSHROOM_1 || shroom == Material.HUGE_MUSHROOM_2, "Not a mushroom!");
+    }
+
+    /**
+     * @param type the raw type id
+     * @param data the raw data value
+     * @deprecated Magic value
+     */
+    @Deprecated
+    public Mushroom(int type, byte data){
+        super(type, data);
+        Validate.isTrue(type == Material.HUGE_MUSHROOM_1.getId() || type == Material.HUGE_MUSHROOM_2.getId(), "Not a mushroom!");
+    }
+
+    /**
+     * @return Whether this is a mushroom stem.
+     */
+    public boolean isStem() {
+        return getData() == MushroomBlockTexture.STEM_SIDES.getData() || getData() == MushroomBlockTexture.ALL_STEM.getData();
+    }
+
+    /**
+     * Sets this to be a mushroom stem.
+     *
+     * @see MushroomBlockTexture#STEM_SIDES
+     * @see MushroomBlockTexture#ALL_STEM
+     *
+     * @deprecated Use
+     * {@link #setBlockTexture(org.bukkit.material.types.MushroomBlockTexture)}
+     * with {@link MushroomBlockTexture#STEM_SIDES } or
+     * {@link MushroomBlockTexture#ALL_STEM}
+     */
+    @Deprecated
+    public void setStem() {
+        setData((byte) MushroomBlockTexture.STEM_SIDES.getData());
+    }
+
+    /**
+     * Gets the mushroom texture of this block.
+     *
+     * @return The mushroom texture of this block
+     */
+    public MushroomBlockTexture getBlockTexture() {
+        return MushroomBlockTexture.getByData(getData());
+    }
+
+    /**
+     * Sets the mushroom texture of this block.
+     *
+     * @param texture The mushroom texture to set
+     */
+    public void setBlockTexture(MushroomBlockTexture texture) {
+        setData(texture.getData());
+    }
+
+    /**
+     * Checks whether a face of the block is painted with cap texture.
+     *
+     * @param face The face to check.
+     * @return True if it is painted.
+     */
+    public boolean isFacePainted(BlockFace face) {
+        byte data = getData();
+
+        if (data == MushroomBlockTexture.ALL_PORES.getData() || data == MushroomBlockTexture.STEM_SIDES.getData()
+                || data == MushroomBlockTexture.ALL_STEM.getData()) {
+            return false;
+        }
+
+        switch (face) {
+            case WEST:
+                return data < NORTH_LIMIT;
+            case EAST:
+                return data > SOUTH_LIMIT;
+            case NORTH:
+                return data % EAST_WEST_LIMIT == EAST_REMAINDER;
+            case SOUTH:
+                return data % EAST_WEST_LIMIT == WEST_REMAINDER;
+            case UP:
+                return true;
+            case DOWN:
+            case SELF:
+                return data == MushroomBlockTexture.ALL_CAP.getData();
+            default:
+                return false;
+        }
+    }
+
+    /**
+     * Set a face of the block to be painted or not. Note that due to the
+     * nature of how the data is stored, setting a face painted or not is not
+     * guaranteed to leave the other faces unchanged.
+     *
+     * @param face The face to paint or unpaint.
+     * @param painted True if you want to paint it, false if you want the
+     *     pores to show.
+     *
+     * @deprecated Use MushroomBlockType cap options
+     */
+    @Deprecated
+    public void setFacePainted(BlockFace face, boolean painted) {
+        if (painted == isFacePainted(face)) {
+            return;
+        }
+
+        byte data = getData();
+
+        if (data == MushroomBlockTexture.ALL_PORES.getData() || isStem()) {
+            data = MushroomBlockTexture.CAP_TOP.getData();
+        }
+        if (data == MushroomBlockTexture.ALL_CAP.getData() && !painted) {
+            data = MushroomBlockTexture.CAP_TOP.getData();
+            face = face.getOppositeFace();
+            painted = true;
+        }
+
+        switch (face) {
+            case WEST:
+                if (painted) {
+                    data -= NORTH_SOUTH_MOD;
+                } else {
+                    data += NORTH_SOUTH_MOD;
+                }
+
+                break;
+            case EAST:
+                if (painted) {
+                    data += NORTH_SOUTH_MOD;
+                } else {
+                    data -= NORTH_SOUTH_MOD;
+                }
+
+                break;
+            case NORTH:
+                if (painted) {
+                    data += EAST_WEST_MOD;
+                } else {
+                    data -= EAST_WEST_MOD;
+                }
+
+                break;
+            case SOUTH:
+                if (painted) {
+                    data -= EAST_WEST_MOD;
+                } else {
+                    data += EAST_WEST_MOD;
+                }
+
+                break;
+            case UP:
+                if (!painted) {
+                    data = MushroomBlockTexture.ALL_PORES.getData();
+                }
+                break;
+            case SELF:
+            case DOWN:
+                if (painted) {
+                    data = MushroomBlockTexture.ALL_CAP.getData();
+                }
+                else {
+                    data = MushroomBlockTexture.ALL_PORES.getData();
+                }
+                break;
+            default:
+                throw new IllegalArgumentException("Can't paint that face of a mushroom!");
+        }
+
+        setData(data);
+    }
+
+    /**
+     * @return A set of all faces that are currently painted (an empty set if
+     *     it is a stem)
+     */
+    public Set<BlockFace> getPaintedFaces() {
+        EnumSet<BlockFace> faces = EnumSet.noneOf(BlockFace.class);
+
+        if (isFacePainted(BlockFace.WEST)) {
+            faces.add(BlockFace.WEST);
+        }
+
+        if (isFacePainted(BlockFace.NORTH)) {
+            faces.add(BlockFace.NORTH);
+        }
+
+        if (isFacePainted(BlockFace.SOUTH)) {
+            faces.add(BlockFace.SOUTH);
+        }
+
+        if (isFacePainted(BlockFace.EAST)) {
+            faces.add(BlockFace.EAST);
+        }
+
+        if (isFacePainted(BlockFace.UP)) {
+            faces.add(BlockFace.UP);
+        }
+
+        if (isFacePainted(BlockFace.DOWN)) {
+            faces.add(BlockFace.DOWN);
+        }
+
+        return faces;
+    }
+
+    @Override
+    public String toString() {
+        return Material.getMaterial(getItemTypeId()).toString() + (isStem() ? " STEM " : " CAP ") + getPaintedFaces();
+    }
+
+    @Override
+    public Mushroom clone() {
+        return (Mushroom) super.clone();
+    }
+}
diff --git a/src/main/java/org/bukkit/metadata/LazyMetadataValue.java b/src/main/java/org/bukkit/metadata/LazyMetadataValue.java
new file mode 100644
index 0000000..a957c5e
--- /dev/null
+++ b/src/main/java/org/bukkit/metadata/LazyMetadataValue.java
@@ -0,0 +1,122 @@
+package org.bukkit.metadata;
+
+import java.lang.ref.SoftReference;
+import java.util.concurrent.Callable;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.plugin.Plugin;
+
+/**
+ * The LazyMetadataValue class implements a type of metadata that is not
+ * computed until another plugin asks for it.
+ * <p>
+ * By making metadata values lazy, no computation is done by the providing
+ * plugin until absolutely necessary (if ever). Additionally,
+ * LazyMetadataValue objects cache their values internally unless overridden
+ * by a {@link CacheStrategy} or invalidated at the individual or plugin
+ * level. Once invalidated, the LazyMetadataValue will recompute its value
+ * when asked.
+ */
+public class LazyMetadataValue extends MetadataValueAdapter implements MetadataValue {
+    private Callable<Object> lazyValue;
+    private CacheStrategy cacheStrategy;
+    private SoftReference<Object> internalValue;
+    private static final Object ACTUALLY_NULL = new Object();
+
+    /**
+     * Initialized a LazyMetadataValue object with the default
+     * CACHE_AFTER_FIRST_EVAL cache strategy.
+     *
+     * @param owningPlugin the {@link Plugin} that created this metadata
+     *     value.
+     * @param lazyValue the lazy value assigned to this metadata value.
+     */
+    public LazyMetadataValue(Plugin owningPlugin, Callable<Object> lazyValue) {
+        this(owningPlugin, CacheStrategy.CACHE_AFTER_FIRST_EVAL, lazyValue);
+    }
+
+    /**
+     * Initializes a LazyMetadataValue object with a specific cache strategy.
+     *
+     * @param owningPlugin the {@link Plugin} that created this metadata
+     *     value.
+     * @param cacheStrategy determines the rules for caching this metadata
+     *     value.
+     * @param lazyValue the lazy value assigned to this metadata value.
+     */
+    public LazyMetadataValue(Plugin owningPlugin, CacheStrategy cacheStrategy, Callable<Object> lazyValue) {
+        super(owningPlugin);
+        Validate.notNull(cacheStrategy, "cacheStrategy cannot be null");
+        Validate.notNull(lazyValue, "lazyValue cannot be null");
+        this.internalValue = new SoftReference<Object>(null);
+        this.lazyValue = lazyValue;
+        this.cacheStrategy = cacheStrategy;
+    }
+
+    /**
+     * Protected special constructor used by FixedMetadataValue to bypass
+     * standard setup.
+     * 
+     * @param owningPlugin the owning plugin
+     */
+    protected LazyMetadataValue(Plugin owningPlugin) {
+        super(owningPlugin);
+    }
+
+    public Object value() {
+        eval();
+        Object value = internalValue.get();
+        if (value == ACTUALLY_NULL) {
+            return null;
+        }
+        return value;
+    }
+
+    /**
+     * Lazily evaluates the value of this metadata item.
+     *
+     * @throws MetadataEvaluationException if computing the metadata value
+     *     fails.
+     */
+    private synchronized void eval() throws MetadataEvaluationException {
+        if (cacheStrategy == CacheStrategy.NEVER_CACHE || internalValue.get() == null) {
+            try {
+                Object value = lazyValue.call();
+                if (value == null) {
+                    value = ACTUALLY_NULL;
+                }
+                internalValue = new SoftReference<Object>(value);
+            } catch (Exception e) {
+                throw new MetadataEvaluationException(e);
+            }
+        }
+    }
+
+    public synchronized void invalidate() {
+        if (cacheStrategy != CacheStrategy.CACHE_ETERNALLY) {
+            internalValue.clear();
+        }
+    }
+
+    /**
+     * Describes possible caching strategies for metadata.
+     */
+    public enum CacheStrategy {
+        /**
+         * Once the metadata value has been evaluated, do not re-evaluate the
+         * value until it is manually invalidated.
+         */
+        CACHE_AFTER_FIRST_EVAL,
+
+        /**
+         * Re-evaluate the metadata item every time it is requested
+         */
+        NEVER_CACHE,
+
+        /**
+         * Once the metadata value has been evaluated, do not re-evaluate the
+         * value in spite of manual invalidation.
+         */
+        CACHE_ETERNALLY
+    }
+}
diff --git a/src/main/java/org/bukkit/metadata/MetadataStoreBase.java b/src/main/java/org/bukkit/metadata/MetadataStoreBase.java
new file mode 100644
index 0000000..0f3c19a
--- /dev/null
+++ b/src/main/java/org/bukkit/metadata/MetadataStoreBase.java
@@ -0,0 +1,161 @@
+package org.bukkit.metadata;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.plugin.Plugin;
+
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+
+public abstract class MetadataStoreBase<T> {
+    private Map<String, Map<Plugin, MetadataValue>> metadataMap = new ConcurrentHashMap<String, Map<Plugin, MetadataValue>>();
+
+    /**
+     * Adds a metadata value to an object. Each metadata value is owned by a
+     * specific {@link Plugin}. If a plugin has already added a metadata value
+     * to an object, that value will be replaced with the value of {@code
+     * newMetadataValue}. Multiple plugins can set independent values for the
+     * same {@code metadataKey} without conflict.
+     * <p>
+     * Implementation note: I considered using a {@link
+     * java.util.concurrent.locks.ReadWriteLock} for controlling access to
+     * {@code metadataMap}, but decided that the added overhead wasn't worth
+     * the finer grained access control.
+     * <p>
+     * Bukkit is almost entirely single threaded so locking overhead shouldn't
+     * pose a problem.
+     *
+     * @param subject The object receiving the metadata.
+     * @param metadataKey A unique key to identify this metadata.
+     * @param newMetadataValue The metadata value to apply.
+     * @see MetadataStore#setMetadata(Object, String, MetadataValue)
+     * @throws IllegalArgumentException If value is null, or the owning plugin
+     *     is null
+     */
+    public void setMetadata(T subject, String metadataKey, MetadataValue newMetadataValue) {
+        Validate.notNull(newMetadataValue, "Value cannot be null");
+        Plugin owningPlugin = newMetadataValue.getOwningPlugin();
+        Validate.notNull(owningPlugin, "Plugin cannot be null");
+        String key = disambiguate(subject, metadataKey);
+        Map<Plugin, MetadataValue> entry = metadataMap.get(key);
+        if (entry == null) {
+            entry = new WeakHashMap<Plugin, MetadataValue>(1);
+            metadataMap.put(key, entry);
+        }
+        synchronized (entry) {
+            entry.put(owningPlugin, newMetadataValue);
+        }
+    }
+
+    /**
+     * Returns all metadata values attached to an object. If multiple
+     * have attached metadata, each will value will be included.
+     *
+     * @param subject the object being interrogated.
+     * @param metadataKey the unique metadata key being sought.
+     * @return A list of values, one for each plugin that has set the
+     *     requested value.
+     * @see MetadataStore#getMetadata(Object, String)
+     */
+    public List<MetadataValue> getMetadata(T subject, String metadataKey) {
+        String key = disambiguate(subject, metadataKey);
+        Map<Plugin, MetadataValue> entry = metadataMap.get(key);
+        if (entry != null) {
+            Collection<MetadataValue> values = entry.values();
+            return Collections.unmodifiableList(new ArrayList<MetadataValue>(values));
+        } else {
+            return Collections.emptyList();
+        }
+    }
+
+    /**
+     * Tests to see if a metadata attribute has been set on an object.
+     *
+     * @param subject the object upon which the has-metadata test is
+     *     performed.
+     * @param metadataKey the unique metadata key being queried.
+     * @return the existence of the metadataKey within subject.
+     */
+    public boolean hasMetadata(T subject, String metadataKey) {
+        String key = disambiguate(subject, metadataKey);
+        return metadataMap.containsKey(key);
+    }
+
+    /**
+     * Removes a metadata item owned by a plugin from a subject.
+     *
+     * @param subject the object to remove the metadata from.
+     * @param metadataKey the unique metadata key identifying the metadata to
+     *     remove.
+     * @param owningPlugin the plugin attempting to remove a metadata item.
+     * @see MetadataStore#removeMetadata(Object, String,
+     *     org.bukkit.plugin.Plugin)
+     * @throws IllegalArgumentException If plugin is null
+     */
+    public void removeMetadata(T subject, String metadataKey, Plugin owningPlugin) {
+        Validate.notNull(owningPlugin, "Plugin cannot be null");
+        String key = disambiguate(subject, metadataKey);
+        Map<Plugin, MetadataValue> entry = metadataMap.get(key);
+        if (entry == null) {
+            return;
+        }
+        synchronized (entry) {
+            entry.remove(owningPlugin);
+            if (entry.isEmpty()) {
+                metadataMap.remove(key);
+            }
+        }
+    }
+
+    /**
+     * Invalidates all metadata in the metadata store that originates from the
+     * given plugin. Doing this will force each invalidated metadata item to
+     * be recalculated the next time it is accessed.
+     *
+     * @param owningPlugin the plugin requesting the invalidation.
+     * @see MetadataStore#invalidateAll(org.bukkit.plugin.Plugin)
+     * @throws IllegalArgumentException If plugin is null
+     */
+    public void invalidateAll(Plugin owningPlugin) {
+        Validate.notNull(owningPlugin, "Plugin cannot be null");
+        for (Map<Plugin, MetadataValue> values : metadataMap.values()) {
+            if (values.containsKey(owningPlugin)) {
+                values.get(owningPlugin).invalidate();
+            }
+        }
+    }
+
+    /**
+     * Removes all metadata in the metadata store that originates from the
+     * given plugin.
+     *
+     * @param owningPlugin the plugin requesting the invalidation.
+     * @throws IllegalArgumentException If plugin is null
+     */
+    public void removeAll(Plugin owningPlugin) {
+        Validate.notNull(owningPlugin, "Plugin cannot be null");
+        for (Iterator<Map<Plugin, MetadataValue>> iterator = metadataMap.values().iterator(); iterator.hasNext(); ) {
+            Map<Plugin, MetadataValue> values = iterator.next();
+            if (values.containsKey(owningPlugin)) {
+                values.remove(owningPlugin);
+            }
+            if (values.isEmpty()) {
+                iterator.remove();
+            }
+        }
+    }
+
+    /**
+     * Creates a unique name for the object receiving metadata by combining
+     * unique data from the subject with a metadataKey.
+     * <p>
+     * The name created must be globally unique for the given object and any
+     * two equivalent objects must generate the same unique name. For example,
+     * two Player objects must generate the same string if they represent the
+     * same player, even if the objects would fail a reference equality test.
+     *
+     * @param subject The object for which this key is being generated.
+     * @param metadataKey The name identifying the metadata value.
+     * @return a unique metadata key for the given subject.
+     */
+    protected abstract String disambiguate(T subject, String metadataKey);
+}
diff --git a/src/main/java/org/bukkit/metadata/MetadataValueAdapter.java b/src/main/java/org/bukkit/metadata/MetadataValueAdapter.java
new file mode 100644
index 0000000..5e6df44
--- /dev/null
+++ b/src/main/java/org/bukkit/metadata/MetadataValueAdapter.java
@@ -0,0 +1,78 @@
+package org.bukkit.metadata;
+
+import java.lang.ref.WeakReference;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.plugin.Plugin;
+import org.bukkit.util.NumberConversions;
+
+/**
+ * Optional base class for facilitating MetadataValue implementations.
+ * <p>
+ * This provides all the conversion functions for MetadataValue so that
+ * writing an implementation of MetadataValue is as simple as implementing
+ * value() and invalidate().
+ */
+public abstract class MetadataValueAdapter implements MetadataValue {
+    protected final WeakReference<Plugin> owningPlugin;
+
+    protected MetadataValueAdapter(Plugin owningPlugin) {
+        Validate.notNull(owningPlugin, "owningPlugin cannot be null");
+        this.owningPlugin = new WeakReference<Plugin>(owningPlugin);
+    }
+
+    public Plugin getOwningPlugin() {
+        return owningPlugin.get();
+    }
+
+    public int asInt() {
+        return NumberConversions.toInt(value());
+    }
+
+    public float asFloat() {
+        return NumberConversions.toFloat(value());
+    }
+
+    public double asDouble() {
+        return NumberConversions.toDouble(value());
+    }
+
+    public long asLong() {
+        return NumberConversions.toLong(value());
+    }
+
+    public short asShort() {
+        return NumberConversions.toShort(value());
+    }
+
+    public byte asByte() {
+        return NumberConversions.toByte(value());
+    }
+
+    public boolean asBoolean() {
+        Object value = value();
+        if (value instanceof Boolean) {
+            return (Boolean) value;
+        }
+
+        if (value instanceof Number) {
+            return ((Number) value).intValue() != 0;
+        }
+
+        if (value instanceof String) {
+            return Boolean.parseBoolean((String) value);
+        }
+
+        return value != null;
+    }
+
+    public String asString() {
+        Object value = value();
+
+        if (value == null) {
+            return "";
+        }
+        return value.toString();
+    }
+
+}
diff --git a/src/main/java/org/bukkit/permissions/Permission.java b/src/main/java/org/bukkit/permissions/Permission.java
new file mode 100644
index 0000000..c70e8a4
--- /dev/null
+++ b/src/main/java/org/bukkit/permissions/Permission.java
@@ -0,0 +1,345 @@
+package org.bukkit.permissions;
+
+import java.util.ArrayList;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.logging.Level;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.Bukkit;
+import org.bukkit.plugin.PluginManager;
+
+/**
+ * Represents a unique permission that may be attached to a {@link
+ * Permissible}
+ */
+public class Permission {
+    public static final PermissionDefault DEFAULT_PERMISSION = PermissionDefault.OP;
+
+    private final String name;
+    private final Map<String, Boolean> children = new LinkedHashMap<String, Boolean>();
+    private PermissionDefault defaultValue = DEFAULT_PERMISSION;
+    private String description;
+
+    public Permission(String name) {
+        this(name, null, null, null);
+    }
+
+    public Permission(String name, String description) {
+        this(name, description, null, null);
+    }
+
+    public Permission(String name, PermissionDefault defaultValue) {
+        this(name, null, defaultValue, null);
+    }
+
+    public Permission(String name, String description, PermissionDefault defaultValue) {
+        this(name, description, defaultValue, null);
+    }
+
+    public Permission(String name, Map<String, Boolean> children) {
+        this(name, null, null, children);
+    }
+
+    public Permission(String name, String description, Map<String, Boolean> children) {
+        this(name, description, null, children);
+    }
+
+    public Permission(String name, PermissionDefault defaultValue, Map<String, Boolean> children) {
+        this(name, null, defaultValue, children);
+    }
+
+    public Permission(String name, String description, PermissionDefault defaultValue, Map<String, Boolean> children) {
+        Validate.notNull(name, "Name cannot be null");
+        this.name = name;
+        this.description = (description == null) ? "" : description;
+
+        if (defaultValue != null) {
+            this.defaultValue = defaultValue;
+        }
+
+        if (children != null) {
+            this.children.putAll(children);
+        }
+
+        recalculatePermissibles();
+    }
+
+    /**
+     * Returns the unique fully qualified name of this Permission
+     *
+     * @return Fully qualified name
+     */
+    public String getName() {
+        return name;
+    }
+
+    /**
+     * Gets the children of this permission.
+     * <p>
+     * If you change this map in any form, you must call {@link
+     * #recalculatePermissibles()} to recalculate all {@link Permissible}s
+     *
+     * @return Permission children
+     */
+    public Map<String, Boolean> getChildren() {
+        return children;
+    }
+
+    /**
+     * Gets the default value of this permission.
+     *
+     * @return Default value of this permission.
+     */
+    public PermissionDefault getDefault() {
+        return defaultValue;
+    }
+
+    /**
+     * Sets the default value of this permission.
+     * <p>
+     * This will not be saved to disk, and is a temporary operation until the
+     * server reloads permissions. Changing this default will cause all {@link
+     * Permissible}s that contain this permission to recalculate their
+     * permissions
+     *
+     * @param value The new default to set
+     */
+    public void setDefault(PermissionDefault value) {
+        if (defaultValue == null) {
+            throw new IllegalArgumentException("Default value cannot be null");
+        }
+
+        defaultValue = value;
+        recalculatePermissibles();
+    }
+
+    /**
+     * Gets a brief description of this permission, if set
+     *
+     * @return Brief description of this permission
+     */
+    public String getDescription() {
+        return description;
+    }
+
+    /**
+     * Sets the description of this permission.
+     * <p>
+     * This will not be saved to disk, and is a temporary operation until the
+     * server reloads permissions.
+     *
+     * @param value The new description to set
+     */
+    public void setDescription(String value) {
+        if (value == null) {
+            description = "";
+        } else {
+            description = value;
+        }
+    }
+
+    /**
+     * Gets a set containing every {@link Permissible} that has this
+     * permission.
+     * <p>
+     * This set cannot be modified.
+     *
+     * @return Set containing permissibles with this permission
+     */
+    public Set<Permissible> getPermissibles() {
+        return Bukkit.getServer().getPluginManager().getPermissionSubscriptions(name);
+    }
+
+    /**
+     * Recalculates all {@link Permissible}s that contain this permission.
+     * <p>
+     * This should be called after modifying the children, and is
+     * automatically called after modifying the default value
+     */
+    public void recalculatePermissibles() {
+        Set<Permissible> perms = getPermissibles();
+
+        Bukkit.getServer().getPluginManager().recalculatePermissionDefaults(this);
+
+        for (Permissible p : perms) {
+            p.recalculatePermissions();
+        }
+    }
+
+    /**
+     * Adds this permission to the specified parent permission.
+     * <p>
+     * If the parent permission does not exist, it will be created and
+     * registered.
+     *
+     * @param name Name of the parent permission
+     * @param value The value to set this permission to
+     * @return Parent permission it created or loaded
+     */
+    public Permission addParent(String name, boolean value) {
+        PluginManager pm = Bukkit.getServer().getPluginManager();
+        String lname = name.toLowerCase();
+
+        Permission perm = pm.getPermission(lname);
+
+        if (perm == null) {
+            perm = new Permission(lname);
+            pm.addPermission(perm);
+        }
+
+        addParent(perm, value);
+
+        return perm;
+    }
+
+    /**
+     * Adds this permission to the specified parent permission.
+     *
+     * @param perm Parent permission to register with
+     * @param value The value to set this permission to
+     */
+    public void addParent(Permission perm, boolean value) {
+        perm.getChildren().put(getName(), value);
+        perm.recalculatePermissibles();
+    }
+
+    /**
+     * Loads a list of Permissions from a map of data, usually used from
+     * retrieval from a yaml file.
+     * <p>
+     * The data may contain a list of name:data, where the data contains the
+     * following keys:
+     * <ul>
+     * <li>default: Boolean true or false. If not specified, false.
+     * <li>children: {@code Map<String, Boolean>} of child permissions. If not
+     *     specified, empty list.
+     * <li>description: Short string containing a very small description of
+     *     this description. If not specified, empty string.
+     * </ul>
+     *
+     * @param data Map of permissions
+     * @param error An error message to show if a permission is invalid.
+     * @param def Default permission value to use if missing
+     * @return Permission object
+     */
+    public static List<Permission> loadPermissions(Map<?, ?> data, String error, PermissionDefault def) {
+        List<Permission> result = new ArrayList<Permission>();
+
+        for (Map.Entry<?, ?> entry : data.entrySet()) {
+            try {
+                result.add(Permission.loadPermission(entry.getKey().toString(), (Map<?, ?>) entry.getValue(), def, result));
+            } catch (Throwable ex) {
+                Bukkit.getServer().getLogger().log(Level.SEVERE, String.format(error, entry.getKey()), ex);
+            }
+        }
+
+        return result;
+    }
+
+    /**
+     * Loads a Permission from a map of data, usually used from retrieval from
+     * a yaml file.
+     * <p>
+     * The data may contain the following keys:
+     * <ul>
+     * <li>default: Boolean true or false. If not specified, false.
+     * <li>children: {@code Map<String, Boolean>} of child permissions. If not
+     *     specified, empty list.
+     * <li>description: Short string containing a very small description of
+     *     this description. If not specified, empty string.
+     * </ul>
+     *
+     * @param name Name of the permission
+     * @param data Map of keys
+     * @return Permission object
+     */
+    public static Permission loadPermission(String name, Map<String, Object> data) {
+        return loadPermission(name, data, DEFAULT_PERMISSION, null);
+    }
+
+    /**
+     * Loads a Permission from a map of data, usually used from retrieval from
+     * a yaml file.
+     * <p>
+     * The data may contain the following keys:
+     * <ul>
+     * <li>default: Boolean true or false. If not specified, false.
+     * <li>children: {@code Map<String, Boolean>} of child permissions. If not
+     *     specified, empty list.
+     * <li>description: Short string containing a very small description of
+     *     this description. If not specified, empty string.
+     * </ul>
+     *
+     * @param name Name of the permission
+     * @param data Map of keys
+     * @param def Default permission value to use if not set
+     * @param output A list to append any created child-Permissions to, may be null
+     * @return Permission object
+     */
+    public static Permission loadPermission(String name, Map<?, ?> data, PermissionDefault def, List<Permission> output) {
+        Validate.notNull(name, "Name cannot be null");
+        Validate.notNull(data, "Data cannot be null");
+
+        String desc = null;
+        Map<String, Boolean> children = null;
+
+        if (data.get("default") != null) {
+            PermissionDefault value = PermissionDefault.getByName(data.get("default").toString());
+            if (value != null) {
+                def = value;
+            } else {
+                throw new IllegalArgumentException("'default' key contained unknown value");
+            }
+        }
+
+        if (data.get("children") != null) {
+            Object childrenNode = data.get("children");
+            if (childrenNode instanceof Iterable) {
+                children = new LinkedHashMap<String, Boolean>();
+                for (Object child : (Iterable<?>) childrenNode) {
+                    if (child != null) {
+                        children.put(child.toString(), Boolean.TRUE);
+                    }
+                }
+            } else if (childrenNode instanceof Map) {
+                children = extractChildren((Map<?,?>) childrenNode, name, def, output);
+            } else {
+                throw new IllegalArgumentException("'children' key is of wrong type");
+            }
+        }
+
+        if (data.get("description") != null) {
+            desc = data.get("description").toString();
+        }
+
+        return new Permission(name, desc, def, children);
+    }
+
+    private static Map<String, Boolean> extractChildren(Map<?, ?> input, String name, PermissionDefault def, List<Permission> output) {
+        Map<String, Boolean> children = new LinkedHashMap<String, Boolean>();
+
+        for (Map.Entry<?, ?> entry : input.entrySet()) {
+            if ((entry.getValue() instanceof Boolean)) {
+                children.put(entry.getKey().toString(), (Boolean) entry.getValue());
+            } else if ((entry.getValue() instanceof Map)) {
+                try {
+                    Permission perm = loadPermission(entry.getKey().toString(), (Map<?, ?>) entry.getValue(), def, output);
+                    children.put(perm.getName(), Boolean.TRUE);
+
+                    if (output != null) {
+                        output.add(perm);
+                    }
+                } catch (Throwable ex) {
+                    throw new IllegalArgumentException("Permission node '" + entry.getKey().toString() + "' in child of " + name + " is invalid", ex);
+                }
+            } else {
+                throw new IllegalArgumentException("Child '" + entry.getKey().toString() + "' contains invalid value");
+            }
+        }
+
+        return children;
+    }
+}
diff --git a/src/main/java/org/bukkit/plugin/SimplePluginManager.java b/src/main/java/org/bukkit/plugin/SimplePluginManager.java
new file mode 100644
index 0000000..b10e274
--- /dev/null
+++ b/src/main/java/org/bukkit/plugin/SimplePluginManager.java
@@ -0,0 +1,762 @@
+package org.bukkit.plugin;
+
+import java.io.File;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.WeakHashMap;
+import java.util.logging.Level;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import com.destroystokyo.paper.event.server.ServerExceptionEvent;
+import com.destroystokyo.paper.exception.ServerEventException;
+import com.destroystokyo.paper.exception.ServerPluginEnableDisableException;
+import org.apache.commons.lang3.Validate;
+import org.bukkit.Server;
+import org.bukkit.command.Command;
+import org.bukkit.command.PluginCommandYamlParser;
+import org.bukkit.command.SimpleCommandMap;
+import org.bukkit.event.Event;
+import org.bukkit.event.EventPriority;
+import org.bukkit.event.HandlerList;
+import org.bukkit.event.Listener;
+import org.bukkit.permissions.Permissible;
+import org.bukkit.permissions.Permission;
+import org.bukkit.permissions.PermissionDefault;
+import org.bukkit.util.FileUtil;
+
+import com.google.common.collect.ImmutableSet;
+
+/**
+ * Handles all plugin management from the Server
+ */
+public final class SimplePluginManager implements PluginManager {
+    private final Server server;
+    private final Map<Pattern, PluginLoader> fileAssociations = new HashMap<Pattern, PluginLoader>();
+    private final List<Plugin> plugins = new ArrayList<Plugin>();
+    private final Map<String, Plugin> lookupNames = new HashMap<String, Plugin>();
+    private static File updateDirectory = null;
+    private final SimpleCommandMap commandMap;
+    private final Map<String, Permission> permissions = new HashMap<String, Permission>();
+    private final Map<Boolean, Set<Permission>> defaultPerms = new LinkedHashMap<Boolean, Set<Permission>>();
+    private final Map<String, Map<Permissible, Boolean>> permSubs = new HashMap<String, Map<Permissible, Boolean>>();
+    private final Map<Boolean, Map<Permissible, Boolean>> defSubs = new HashMap<Boolean, Map<Permissible, Boolean>>();
+    private boolean useTimings = false;
+
+    public SimplePluginManager(Server instance, SimpleCommandMap commandMap) {
+        server = instance;
+        this.commandMap = commandMap;
+
+        defaultPerms.put(true, new HashSet<Permission>());
+        defaultPerms.put(false, new HashSet<Permission>());
+    }
+
+    /**
+     * Registers the specified plugin loader
+     *
+     * @param loader Class name of the PluginLoader to register
+     * @throws IllegalArgumentException Thrown when the given Class is not a
+     *     valid PluginLoader
+     */
+    public void registerInterface(Class<? extends PluginLoader> loader) throws IllegalArgumentException {
+        PluginLoader instance;
+
+        if (PluginLoader.class.isAssignableFrom(loader)) {
+            Constructor<? extends PluginLoader> constructor;
+
+            try {
+                constructor = loader.getConstructor(Server.class);
+                instance = constructor.newInstance(server);
+            } catch (NoSuchMethodException ex) {
+                String className = loader.getName();
+
+                throw new IllegalArgumentException(String.format("Class %s does not have a public %s(Server) constructor", className, className), ex);
+            } catch (Exception ex) {
+                throw new IllegalArgumentException(String.format("Unexpected exception %s while attempting to construct a new instance of %s", ex.getClass().getName(), loader.getName()), ex);
+            }
+        } else {
+            throw new IllegalArgumentException(String.format("Class %s does not implement interface PluginLoader", loader.getName()));
+        }
+
+        Pattern[] patterns = instance.getPluginFileFilters();
+
+        synchronized (this) {
+            for (Pattern pattern : patterns) {
+                fileAssociations.put(pattern, instance);
+            }
+        }
+    }
+
+    /**
+     * Loads the plugins contained within the specified directory
+     *
+     * @param directory Directory to check for plugins
+     * @return A list of all plugins loaded
+     */
+    public Plugin[] loadPlugins(File directory) {
+        Validate.notNull(directory, "Directory cannot be null");
+        Validate.isTrue(directory.isDirectory(), "Directory must be a directory");
+
+        List<Plugin> result = new ArrayList<Plugin>();
+        Set<Pattern> filters = fileAssociations.keySet();
+
+        if (!(server.getUpdateFolder().equals(""))) {
+            updateDirectory = new File(directory, server.getUpdateFolder());
+        }
+
+        Map<String, File> plugins = new HashMap<String, File>();
+        Set<String> loadedPlugins = new HashSet<String>();
+        Map<String, Collection<String>> dependencies = new HashMap<String, Collection<String>>();
+        Map<String, Collection<String>> softDependencies = new HashMap<String, Collection<String>>();
+
+        // This is where it figures out all possible plugins
+        for (File file : directory.listFiles()) {
+            PluginLoader loader = null;
+            for (Pattern filter : filters) {
+                Matcher match = filter.matcher(file.getName());
+                if (match.find()) {
+                    loader = fileAssociations.get(filter);
+                }
+            }
+
+            if (loader == null) continue;
+
+            PluginDescriptionFile description = null;
+            try {
+                description = loader.getPluginDescription(file);
+                String name = description.getName();
+                if (name.equalsIgnoreCase("bukkit") || name.equalsIgnoreCase("minecraft") || name.equalsIgnoreCase("mojang")) {
+                    server.getLogger().log(Level.SEVERE, "Could not load '" + file.getPath() + "' in folder '" + directory.getPath() + "': Restricted Name");
+                    continue;
+                } else if (description.rawName.indexOf(' ') != -1) {
+                    server.getLogger().warning(String.format(
+                        "Plugin `%s' uses the space-character (0x20) in its name `%s' - this is discouraged",
+                        description.getFullName(),
+                        description.rawName
+                        ));
+                }
+            } catch (InvalidDescriptionException ex) {
+                server.getLogger().log(Level.SEVERE, "Could not load '" + file.getPath() + "' in folder '" + directory.getPath() + "'", ex);
+                continue;
+            }
+
+            File replacedFile = plugins.put(description.getName(), file);
+            if (replacedFile != null) {
+                server.getLogger().severe(String.format(
+                    "Ambiguous plugin name `%s' for files `%s' and `%s' in `%s'",
+                    description.getName(),
+                    file.getPath(),
+                    replacedFile.getPath(),
+                    directory.getPath()
+                    ));
+            }
+
+            Collection<String> softDependencySet = description.getSoftDepend();
+            if (softDependencySet != null && !softDependencySet.isEmpty()) {
+                if (softDependencies.containsKey(description.getName())) {
+                    // Duplicates do not matter, they will be removed together if applicable
+                    softDependencies.get(description.getName()).addAll(softDependencySet);
+                } else {
+                    softDependencies.put(description.getName(), new LinkedList<String>(softDependencySet));
+                }
+            }
+
+            Collection<String> dependencySet = description.getDepend();
+            if (dependencySet != null && !dependencySet.isEmpty()) {
+                dependencies.put(description.getName(), new LinkedList<String>(dependencySet));
+            }
+
+            Collection<String> loadBeforeSet = description.getLoadBefore();
+            if (loadBeforeSet != null && !loadBeforeSet.isEmpty()) {
+                for (String loadBeforeTarget : loadBeforeSet) {
+                    if (softDependencies.containsKey(loadBeforeTarget)) {
+                        softDependencies.get(loadBeforeTarget).add(description.getName());
+                    } else {
+                        // softDependencies is never iterated, so 'ghost' plugins aren't an issue
+                        Collection<String> shortSoftDependency = new LinkedList<String>();
+                        shortSoftDependency.add(description.getName());
+                        softDependencies.put(loadBeforeTarget, shortSoftDependency);
+                    }
+                }
+            }
+        }
+
+        while (!plugins.isEmpty()) {
+            boolean missingDependency = true;
+            Iterator<String> pluginIterator = plugins.keySet().iterator();
+
+            while (pluginIterator.hasNext()) {
+                String plugin = pluginIterator.next();
+
+                if (dependencies.containsKey(plugin)) {
+                    Iterator<String> dependencyIterator = dependencies.get(plugin).iterator();
+
+                    while (dependencyIterator.hasNext()) {
+                        String dependency = dependencyIterator.next();
+
+                        // Dependency loaded
+                        if (loadedPlugins.contains(dependency)) {
+                            dependencyIterator.remove();
+
+                        // We have a dependency not found
+                        } else if (!plugins.containsKey(dependency)) {
+                            missingDependency = false;
+                            File file = plugins.get(plugin);
+                            pluginIterator.remove();
+                            softDependencies.remove(plugin);
+                            dependencies.remove(plugin);
+
+                            server.getLogger().log(
+                                Level.SEVERE,
+                                "Could not load '" + file.getPath() + "' in folder '" + directory.getPath() + "'",
+                                new UnknownDependencyException(dependency));
+                            break;
+                        }
+                    }
+
+                    if (dependencies.containsKey(plugin) && dependencies.get(plugin).isEmpty()) {
+                        dependencies.remove(plugin);
+                    }
+                }
+                if (softDependencies.containsKey(plugin)) {
+                    Iterator<String> softDependencyIterator = softDependencies.get(plugin).iterator();
+
+                    while (softDependencyIterator.hasNext()) {
+                        String softDependency = softDependencyIterator.next();
+
+                        // Soft depend is no longer around
+                        if (!plugins.containsKey(softDependency)) {
+                            softDependencyIterator.remove();
+                        }
+                    }
+
+                    if (softDependencies.get(plugin).isEmpty()) {
+                        softDependencies.remove(plugin);
+                    }
+                }
+                if (!(dependencies.containsKey(plugin) || softDependencies.containsKey(plugin)) && plugins.containsKey(plugin)) {
+                    // We're clear to load, no more soft or hard dependencies left
+                    File file = plugins.get(plugin);
+                    pluginIterator.remove();
+                    missingDependency = false;
+
+                    try {
+                        result.add(loadPlugin(file));
+                        loadedPlugins.add(plugin);
+                        continue;
+                    } catch (InvalidPluginException ex) {
+                        server.getLogger().log(Level.SEVERE, "Could not load '" + file.getPath() + "' in folder '" + directory.getPath() + "'", ex);
+                    }
+                }
+            }
+
+            if (missingDependency) {
+                // We now iterate over plugins until something loads
+                // This loop will ignore soft dependencies
+                pluginIterator = plugins.keySet().iterator();
+
+                while (pluginIterator.hasNext()) {
+                    String plugin = pluginIterator.next();
+
+                    if (!dependencies.containsKey(plugin)) {
+                        softDependencies.remove(plugin);
+                        missingDependency = false;
+                        File file = plugins.get(plugin);
+                        pluginIterator.remove();
+
+                        try {
+                            result.add(loadPlugin(file));
+                            loadedPlugins.add(plugin);
+                            break;
+                        } catch (InvalidPluginException ex) {
+                            server.getLogger().log(Level.SEVERE, "Could not load '" + file.getPath() + "' in folder '" + directory.getPath() + "'", ex);
+                        }
+                    }
+                }
+                // We have no plugins left without a depend
+                if (missingDependency) {
+                    softDependencies.clear();
+                    dependencies.clear();
+                    Iterator<File> failedPluginIterator = plugins.values().iterator();
+
+                    while (failedPluginIterator.hasNext()) {
+                        File file = failedPluginIterator.next();
+                        failedPluginIterator.remove();
+                        server.getLogger().log(Level.SEVERE, "Could not load '" + file.getPath() + "' in folder '" + directory.getPath() + "': circular dependency detected");
+                    }
+                }
+            }
+        }
+
+        return result.toArray(new Plugin[result.size()]);
+    }
+
+    /**
+     * Loads the plugin in the specified file
+     * <p>
+     * File must be valid according to the current enabled Plugin interfaces
+     *
+     * @param file File containing the plugin to load
+     * @return The Plugin loaded, or null if it was invalid
+     * @throws InvalidPluginException Thrown when the specified file is not a
+     *     valid plugin
+     * @throws UnknownDependencyException If a required dependency could not
+     *     be found
+     */
+    public synchronized Plugin loadPlugin(File file) throws InvalidPluginException, UnknownDependencyException {
+        Validate.notNull(file, "File cannot be null");
+
+        checkUpdate(file);
+
+        Set<Pattern> filters = fileAssociations.keySet();
+        Plugin result = null;
+
+        for (Pattern filter : filters) {
+            String name = file.getName();
+            Matcher match = filter.matcher(name);
+
+            if (match.find()) {
+                PluginLoader loader = fileAssociations.get(filter);
+
+                result = loader.loadPlugin(file);
+            }
+        }
+
+        if (result != null) {
+            plugins.add(result);
+            lookupNames.put(result.getDescription().getName().toLowerCase(), result); // Spigot
+        }
+
+        return result;
+    }
+
+    private void checkUpdate(File file) {
+        if (updateDirectory == null || !updateDirectory.isDirectory()) {
+            return;
+        }
+
+        File updateFile = new File(updateDirectory, file.getName());
+        if (updateFile.isFile() && FileUtil.copy(updateFile, file)) {
+            updateFile.delete();
+        }
+    }
+
+    /**
+     * Checks if the given plugin is loaded and returns it when applicable
+     * <p>
+     * Please note that the name of the plugin is case-sensitive
+     *
+     * @param name Name of the plugin to check
+     * @return Plugin if it exists, otherwise null
+     */
+    public synchronized Plugin getPlugin(String name) {
+        return lookupNames.get(name.replace(' ', '_').toLowerCase()); // Spigot
+    }
+
+    public synchronized Plugin[] getPlugins() {
+        return plugins.toArray(new Plugin[0]);
+    }
+
+    /**
+     * Checks if the given plugin is enabled or not
+     * <p>
+     * Please note that the name of the plugin is case-sensitive.
+     *
+     * @param name Name of the plugin to check
+     * @return true if the plugin is enabled, otherwise false
+     */
+    public boolean isPluginEnabled(String name) {
+        Plugin plugin = getPlugin(name);
+
+        return isPluginEnabled(plugin);
+    }
+
+    /**
+     * Checks if the given plugin is enabled or not
+     *
+     * @param plugin Plugin to check
+     * @return true if the plugin is enabled, otherwise false
+     */
+    public boolean isPluginEnabled(Plugin plugin) {
+        if ((plugin != null) && (plugins.contains(plugin))) {
+            return plugin.isEnabled();
+        } else {
+            return false;
+        }
+    }
+
+    public void enablePlugin(final Plugin plugin) {
+        if (!plugin.isEnabled()) {
+            List<Command> pluginCommands = PluginCommandYamlParser.parse(plugin);
+
+            if (!pluginCommands.isEmpty()) {
+                commandMap.registerAll(plugin.getDescription().getName(), pluginCommands);
+            }
+
+            try {
+                plugin.getPluginLoader().enablePlugin(plugin);
+            } catch (Throwable ex) {
+                handlePluginException("Error occurred (in the plugin loader) while enabling "
+                        + plugin.getDescription().getFullName() + " (Is it up to date?)", ex, plugin);
+            }
+
+            HandlerList.bakeAll();
+        }
+    }
+
+    public void disablePlugins() {
+        Plugin[] plugins = getPlugins();
+        for (int i = plugins.length - 1; i >= 0; i--) {
+            disablePlugin(plugins[i]);
+        }
+    }
+
+    public void disablePlugin(final Plugin plugin) {
+        if (plugin.isEnabled()) {
+            try {
+                plugin.getPluginLoader().disablePlugin(plugin);
+            } catch (Throwable ex) {
+                handlePluginException("Error occurred (in the plugin loader) while disabling "
+                        + plugin.getDescription().getFullName() + " (Is it up to date?)", ex, plugin); // Paper
+            }
+
+            try {
+                server.getScheduler().cancelTasks(plugin);
+            } catch (Throwable ex) {
+                handlePluginException("Error occurred (in the plugin loader) while cancelling tasks for "
+                        + plugin.getDescription().getFullName() + " (Is it up to date?)", ex, plugin); // Paper
+            }
+
+            try {
+                server.getServicesManager().unregisterAll(plugin);
+            } catch (Throwable ex) {
+                handlePluginException("Error occurred (in the plugin loader) while unregistering services for "
+                        + plugin.getDescription().getFullName() + " (Is it up to date?)", ex, plugin); // Paper
+            }
+
+            try {
+                HandlerList.unregisterAll(plugin);
+            } catch (Throwable ex) {
+                handlePluginException("Error occurred (in the plugin loader) while unregistering events for "
+                        + plugin.getDescription().getFullName() + " (Is it up to date?)", ex, plugin); // Paper
+            }
+
+            try {
+                server.getMessenger().unregisterIncomingPluginChannel(plugin);
+                server.getMessenger().unregisterOutgoingPluginChannel(plugin);
+            } catch(Throwable ex) {
+                handlePluginException("Error occurred (in the plugin loader) while unregistering plugin channels for "
+                        + plugin.getDescription().getFullName() + " (Is it up to date?)", ex, plugin); // Paper
+            }
+        }
+    }
+
+    // Paper start
+    private void handlePluginException(String msg, Throwable ex, Plugin plugin) {
+        server.getLogger().log(Level.SEVERE, msg, ex);
+        callEvent(new ServerExceptionEvent(new ServerPluginEnableDisableException(msg, ex, plugin)));
+    }
+    // Paper end
+
+    public void clearPlugins() {
+        synchronized (this) {
+            disablePlugins();
+            plugins.clear();
+            lookupNames.clear();
+            HandlerList.unregisterAll();
+            fileAssociations.clear();
+            permissions.clear();
+            defaultPerms.get(true).clear();
+            defaultPerms.get(false).clear();
+        }
+    }
+
+    /**
+     * Calls an event with the given details.
+     * <p>
+     * This method only synchronizes when the event is not asynchronous.
+     *
+     * @param event Event details
+     */
+    public void callEvent(Event event) {
+        if (event.isAsynchronous()) {
+            if (Thread.holdsLock(this)) {
+                throw new IllegalStateException(event.getEventName() + " cannot be triggered asynchronously from inside synchronized code.");
+            }
+            if (server.isPrimaryThread()) {
+                throw new IllegalStateException(event.getEventName() + " cannot be triggered asynchronously from primary server thread.");
+            }
+            fireEvent(event);
+        } else {
+            synchronized (this) {
+                fireEvent(event);
+            }
+        }
+    }
+
+    private void fireEvent(Event event) {
+        HandlerList handlers = event.getHandlers();
+        RegisteredListener[] listeners = handlers.getRegisteredListeners();
+
+        for (RegisteredListener registration : listeners) {
+            if (!registration.getPlugin().isEnabled()) {
+                continue;
+            }
+
+            try {
+                registration.callEvent(event);
+            } catch (AuthorNagException ex) {
+                Plugin plugin = registration.getPlugin();
+
+                if (plugin.isNaggable()) {
+                    plugin.setNaggable(false);
+
+                    server.getLogger().log(Level.SEVERE, String.format(
+                            "Nag author(s): '%s' of '%s' about the following: %s",
+                            plugin.getDescription().getAuthors(),
+                            plugin.getDescription().getFullName(),
+                            ex.getMessage()
+                            ));
+                }
+            } catch (Throwable ex) {
+                // Paper start - error reporting
+                String msg = "Could not pass event " + event.getEventName() + " to " + registration.getPlugin().getDescription().getFullName();
+                server.getLogger().log(Level.SEVERE, msg, ex);
+                if (!(event instanceof ServerExceptionEvent)) { // We don't want to cause an endless event loop
+                    callEvent(new ServerExceptionEvent(new ServerEventException(msg, ex, registration.getPlugin(), registration.getListener(), event)));
+                }
+                // Paper end
+            }
+        }
+    }
+
+    public void registerEvents(Listener listener, Plugin plugin) {
+        if (!plugin.isEnabled()) {
+            throw new IllegalPluginAccessException("Plugin attempted to register " + listener + " while not enabled");
+        }
+
+        for (Map.Entry<Class<? extends Event>, Set<RegisteredListener>> entry : plugin.getPluginLoader().createRegisteredListeners(listener, plugin).entrySet()) {
+            getEventListeners(getRegistrationClass(entry.getKey())).registerAll(entry.getValue());
+        }
+
+    }
+
+    public void registerEvent(Class<? extends Event> event, Listener listener, EventPriority priority, EventExecutor executor, Plugin plugin) {
+        registerEvent(event, listener, priority, executor, plugin, false);
+    }
+
+    /**
+     * Registers the given event to the specified listener using a directly
+     * passed EventExecutor
+     *
+     * @param event Event class to register
+     * @param listener PlayerListener to register
+     * @param priority Priority of this event
+     * @param executor EventExecutor to register
+     * @param plugin Plugin to register
+     * @param ignoreCancelled Do not call executor if event was already
+     *     cancelled
+     */
+    public void registerEvent(Class<? extends Event> event, Listener listener, EventPriority priority, EventExecutor executor, Plugin plugin, boolean ignoreCancelled) {
+        Validate.notNull(listener, "Listener cannot be null");
+        Validate.notNull(priority, "Priority cannot be null");
+        Validate.notNull(executor, "Executor cannot be null");
+        Validate.notNull(plugin, "Plugin cannot be null");
+
+        if (!plugin.isEnabled()) {
+            throw new IllegalPluginAccessException("Plugin attempted to register " + event + " while not enabled");
+        }
+
+        executor = new co.aikar.timings.TimedEventExecutor(executor, plugin, null, event); // Spigot
+        if (false) { // Spigot - RL handles useTimings check now
+            getEventListeners(event).register(new TimedRegisteredListener(listener, executor, priority, plugin, ignoreCancelled));
+        } else {
+            getEventListeners(event).register(new RegisteredListener(listener, executor, priority, plugin, ignoreCancelled));
+        }
+    }
+
+    private HandlerList getEventListeners(Class<? extends Event> type) {
+        try {
+            Method method = getRegistrationClass(type).getDeclaredMethod("getHandlerList");
+            method.setAccessible(true);
+            return (HandlerList) method.invoke(null);
+        } catch (Exception e) {
+            throw new IllegalPluginAccessException(e.toString());
+        }
+    }
+
+    private Class<? extends Event> getRegistrationClass(Class<? extends Event> clazz) {
+        try {
+            clazz.getDeclaredMethod("getHandlerList");
+            return clazz;
+        } catch (NoSuchMethodException e) {
+            if (clazz.getSuperclass() != null
+                    && !clazz.getSuperclass().equals(Event.class)
+                    && Event.class.isAssignableFrom(clazz.getSuperclass())) {
+                return getRegistrationClass(clazz.getSuperclass().asSubclass(Event.class));
+            } else {
+                throw new IllegalPluginAccessException("Unable to find handler list for event " + clazz.getName() + ". Static getHandlerList method required!");
+            }
+        }
+    }
+
+    public Permission getPermission(String name) {
+        return permissions.get(name.toLowerCase());
+    }
+
+    public void addPermission(Permission perm) {
+        String name = perm.getName().toLowerCase();
+
+        if (permissions.containsKey(name)) {
+            throw new IllegalArgumentException("The permission " + name + " is already defined!");
+        }
+
+        permissions.put(name, perm);
+        calculatePermissionDefault(perm);
+    }
+
+    public Set<Permission> getDefaultPermissions(boolean op) {
+        return ImmutableSet.copyOf(defaultPerms.get(op));
+    }
+
+    public void removePermission(Permission perm) {
+        removePermission(perm.getName());
+    }
+
+    public void removePermission(String name) {
+        permissions.remove(name.toLowerCase());
+    }
+
+    public void recalculatePermissionDefaults(Permission perm) {
+        if (perm != null && permissions.containsKey(perm.getName().toLowerCase())) {
+            defaultPerms.get(true).remove(perm);
+            defaultPerms.get(false).remove(perm);
+
+            calculatePermissionDefault(perm);
+        }
+    }
+
+    private void calculatePermissionDefault(Permission perm) {
+        if ((perm.getDefault() == PermissionDefault.OP) || (perm.getDefault() == PermissionDefault.TRUE)) {
+            defaultPerms.get(true).add(perm);
+            dirtyPermissibles(true);
+        }
+        if ((perm.getDefault() == PermissionDefault.NOT_OP) || (perm.getDefault() == PermissionDefault.TRUE)) {
+            defaultPerms.get(false).add(perm);
+            dirtyPermissibles(false);
+        }
+    }
+
+    private void dirtyPermissibles(boolean op) {
+        Set<Permissible> permissibles = getDefaultPermSubscriptions(op);
+
+        for (Permissible p : permissibles) {
+            p.recalculatePermissions();
+        }
+    }
+
+    public void subscribeToPermission(String permission, Permissible permissible) {
+        String name = permission.toLowerCase();
+        Map<Permissible, Boolean> map = permSubs.get(name);
+
+        if (map == null) {
+            map = new WeakHashMap<Permissible, Boolean>();
+            permSubs.put(name, map);
+        }
+
+        map.put(permissible, true);
+    }
+
+    public void unsubscribeFromPermission(String permission, Permissible permissible) {
+        String name = permission.toLowerCase();
+        Map<Permissible, Boolean> map = permSubs.get(name);
+
+        if (map != null) {
+            map.remove(permissible);
+
+            if (map.isEmpty()) {
+                permSubs.remove(name);
+            }
+        }
+    }
+
+    public Set<Permissible> getPermissionSubscriptions(String permission) {
+        String name = permission.toLowerCase();
+        Map<Permissible, Boolean> map = permSubs.get(name);
+
+        if (map == null) {
+            return ImmutableSet.of();
+        } else {
+            return ImmutableSet.copyOf(map.keySet());
+        }
+    }
+
+    public void subscribeToDefaultPerms(boolean op, Permissible permissible) {
+        Map<Permissible, Boolean> map = defSubs.get(op);
+
+        if (map == null) {
+            map = new WeakHashMap<Permissible, Boolean>();
+            defSubs.put(op, map);
+        }
+
+        map.put(permissible, true);
+    }
+
+    public void unsubscribeFromDefaultPerms(boolean op, Permissible permissible) {
+        Map<Permissible, Boolean> map = defSubs.get(op);
+
+        if (map != null) {
+            map.remove(permissible);
+
+            if (map.isEmpty()) {
+                defSubs.remove(op);
+            }
+        }
+    }
+
+    public Set<Permissible> getDefaultPermSubscriptions(boolean op) {
+        Map<Permissible, Boolean> map = defSubs.get(op);
+
+        if (map == null) {
+            return ImmutableSet.of();
+        } else {
+            return ImmutableSet.copyOf(map.keySet());
+        }
+    }
+
+    public Set<Permission> getPermissions() {
+        return new HashSet<Permission>(permissions.values());
+    }
+
+    public boolean useTimings() {
+        return co.aikar.timings.Timings.isTimingsEnabled(); // Spigot
+    }
+
+    /**
+     * Sets whether or not per event timing code should be used
+     *
+     * @param use True if per event timing code should be used
+     */
+    public void useTimings(boolean use) {
+        co.aikar.timings.Timings.setTimingsEnabled(use); // Spigot
+    }
+
+    // Paper start
+    public void clearPermissions() {
+        permissions.clear();
+        defaultPerms.get(true).clear();
+        defaultPerms.get(false).clear();
+    }
+    // Paper end
+
+}
diff --git a/src/main/java/org/bukkit/plugin/java/JavaPlugin.java b/src/main/java/org/bukkit/plugin/java/JavaPlugin.java
new file mode 100644
index 0000000..d3a6c92
--- /dev/null
+++ b/src/main/java/org/bukkit/plugin/java/JavaPlugin.java
@@ -0,0 +1,533 @@
+package org.bukkit.plugin.java;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.io.Reader;
+import java.net.URL;
+import java.net.URLConnection;
+import java.nio.charset.Charset;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.Server;
+import org.bukkit.Warning.WarningState;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.command.PluginCommand;
+import org.bukkit.configuration.InvalidConfigurationException;
+import org.bukkit.configuration.file.FileConfiguration;
+import org.bukkit.configuration.file.YamlConfiguration;
+import org.bukkit.generator.ChunkGenerator;
+import org.bukkit.plugin.AuthorNagException;
+import org.bukkit.plugin.PluginAwareness;
+import org.bukkit.plugin.PluginBase;
+import org.bukkit.plugin.PluginDescriptionFile;
+import org.bukkit.plugin.PluginLoader;
+import org.bukkit.plugin.PluginLogger;
+
+import com.avaje.ebean.EbeanServer;
+import com.avaje.ebean.EbeanServerFactory;
+import com.avaje.ebean.config.DataSourceConfig;
+import com.avaje.ebean.config.ServerConfig;
+import com.avaje.ebeaninternal.api.SpiEbeanServer;
+import com.avaje.ebeaninternal.server.ddl.DdlGenerator;
+import com.google.common.base.Charsets;
+import com.google.common.base.Preconditions;
+import com.google.common.io.ByteStreams;
+
+/**
+ * Represents a Java plugin
+ */
+public abstract class JavaPlugin extends PluginBase {
+    private boolean isEnabled = false;
+    private PluginLoader loader = null;
+    private Server server = null;
+    private File file = null;
+    private PluginDescriptionFile description = null;
+    private File dataFolder = null;
+    private ClassLoader classLoader = null;
+    private boolean naggable = true;
+    private EbeanServer ebean = null;
+    private FileConfiguration newConfig = null;
+    private File configFile = null;
+    private PluginLogger logger = null;
+
+    public JavaPlugin() {
+        final ClassLoader classLoader = this.getClass().getClassLoader();
+        if (!(classLoader instanceof PluginClassLoader)) {
+            throw new IllegalStateException("JavaPlugin requires " + PluginClassLoader.class.getName());
+        }
+        ((PluginClassLoader) classLoader).initialize(this);
+    }
+
+    /**
+     * @deprecated This method is intended for unit testing purposes when the
+     *     other {@linkplain #JavaPlugin(JavaPluginLoader,
+     *     PluginDescriptionFile, File, File) constructor} cannot be used.
+     *     <p>
+     *     Its existence may be temporary.
+     * @param loader the plugin loader
+     * @param server the server instance
+     * @param description the plugin's description
+     * @param dataFolder the plugin's data folder
+     * @param file the location of the plugin
+     */
+    @Deprecated
+    protected JavaPlugin(final PluginLoader loader, final Server server, final PluginDescriptionFile description, final File dataFolder, final File file) {
+        final ClassLoader classLoader = this.getClass().getClassLoader();
+        if (classLoader instanceof PluginClassLoader) {
+            throw new IllegalStateException("Cannot use initialization constructor at runtime");
+        }
+        init(loader, server, description, dataFolder, file, classLoader);
+    }
+
+    protected JavaPlugin(final JavaPluginLoader loader, final PluginDescriptionFile description, final File dataFolder, final File file) {
+        final ClassLoader classLoader = this.getClass().getClassLoader();
+        if (classLoader instanceof PluginClassLoader) {
+            throw new IllegalStateException("Cannot use initialization constructor at runtime");
+        }
+        init(loader, loader.server, description, dataFolder, file, classLoader);
+    }
+
+    /**
+     * Returns the folder that the plugin data's files are located in. The
+     * folder may not yet exist.
+     *
+     * @return The folder.
+     */
+    @Override
+    public final File getDataFolder() {
+        return dataFolder;
+    }
+
+    /**
+     * Gets the associated PluginLoader responsible for this plugin
+     *
+     * @return PluginLoader that controls this plugin
+     */
+    @Override
+    public final PluginLoader getPluginLoader() {
+        return loader;
+    }
+
+    /**
+     * Returns the Server instance currently running this plugin
+     *
+     * @return Server running this plugin
+     */
+    @Override
+    public final Server getServer() {
+        return server;
+    }
+
+    /**
+     * Returns a value indicating whether or not this plugin is currently
+     * enabled
+     *
+     * @return true if this plugin is enabled, otherwise false
+     */
+    @Override
+    public final boolean isEnabled() {
+        return isEnabled;
+    }
+
+    /**
+     * Returns the file which contains this plugin
+     *
+     * @return File containing this plugin
+     */
+    protected File getFile() {
+        return file;
+    }
+
+    /**
+     * Returns the plugin.yaml file containing the details for this plugin
+     *
+     * @return Contents of the plugin.yaml file
+     */
+    @Override
+    public final PluginDescriptionFile getDescription() {
+        return description;
+    }
+
+    @Override
+    public FileConfiguration getConfig() {
+        if (newConfig == null) {
+            reloadConfig();
+        }
+        return newConfig;
+    }
+
+    /**
+     * Provides a reader for a text file located inside the jar.
+     * <p>
+     * The returned reader will read text with the UTF-8 charset.
+     *
+     * @param file the filename of the resource to load
+     * @return null if {@link #getResource(String)} returns null
+     * @throws IllegalArgumentException if file is null
+     * @see ClassLoader#getResourceAsStream(String)
+     */
+    @SuppressWarnings("deprecation")
+    protected final Reader getTextResource(String file) {
+        final InputStream in = getResource(file);
+
+        return in == null ? null : new InputStreamReader(in, Charsets.UTF_8);
+    }
+
+    @SuppressWarnings("deprecation")
+    @Override
+    public void reloadConfig() {
+        newConfig = YamlConfiguration.loadConfiguration(configFile);
+
+        final InputStream defConfigStream = getResource("config.yml");
+        if (defConfigStream == null) {
+            return;
+        }
+
+        newConfig.setDefaults(YamlConfiguration.loadConfiguration(new InputStreamReader(defConfigStream, Charsets.UTF_8)));
+    }
+
+    @Override
+    public void saveConfig() {
+        try {
+            getConfig().save(configFile);
+        } catch (IOException ex) {
+            logger.log(Level.SEVERE, "Could not save config to " + configFile, ex);
+        }
+    }
+
+    @Override
+    public void saveDefaultConfig() {
+        if (!configFile.exists()) {
+            saveResource("config.yml", false);
+        }
+    }
+
+    @Override
+    public void saveResource(String resourcePath, boolean replace) {
+        if (resourcePath == null || resourcePath.equals("")) {
+            throw new IllegalArgumentException("ResourcePath cannot be null or empty");
+        }
+
+        resourcePath = resourcePath.replace('\\', '/');
+        InputStream in = getResource(resourcePath);
+        if (in == null) {
+            throw new IllegalArgumentException("The embedded resource '" + resourcePath + "' cannot be found in " + file);
+        }
+
+        File outFile = new File(dataFolder, resourcePath);
+        int lastIndex = resourcePath.lastIndexOf('/');
+        File outDir = new File(dataFolder, resourcePath.substring(0, lastIndex >= 0 ? lastIndex : 0));
+
+        if (!outDir.exists()) {
+            outDir.mkdirs();
+        }
+
+        try {
+            if (!outFile.exists() || replace) {
+                OutputStream out = new FileOutputStream(outFile);
+                byte[] buf = new byte[1024];
+                int len;
+                while ((len = in.read(buf)) > 0) {
+                    out.write(buf, 0, len);
+                }
+                out.close();
+                in.close();
+            } else {
+                logger.log(Level.WARNING, "Could not save " + outFile.getName() + " to " + outFile + " because " + outFile.getName() + " already exists.");
+            }
+        } catch (IOException ex) {
+            logger.log(Level.SEVERE, "Could not save " + outFile.getName() + " to " + outFile, ex);
+        }
+    }
+
+    @Override
+    public InputStream getResource(String filename) {
+        if (filename == null) {
+            throw new IllegalArgumentException("Filename cannot be null");
+        }
+
+        try {
+            URL url = getClassLoader().getResource(filename);
+
+            if (url == null) {
+                return null;
+            }
+
+            URLConnection connection = url.openConnection();
+            connection.setUseCaches(false);
+            return connection.getInputStream();
+        } catch (IOException ex) {
+            return null;
+        }
+    }
+
+    /**
+     * Returns the ClassLoader which holds this plugin
+     *
+     * @return ClassLoader holding this plugin
+     */
+    protected final ClassLoader getClassLoader() {
+        return classLoader;
+    }
+
+    /**
+     * Sets the enabled state of this plugin
+     *
+     * @param enabled true if enabled, otherwise false
+     */
+    protected final void setEnabled(final boolean enabled) {
+        if (isEnabled != enabled) {
+            isEnabled = enabled;
+
+            if (isEnabled) {
+                onEnable();
+            } else {
+                onDisable();
+            }
+        }
+    }
+
+    /**
+     * @param loader the plugin loader
+     * @param server the server instance
+     * @param description the plugin's description
+     * @param dataFolder the plugin's data folder
+     * @param file the location of the plugin
+     * @param classLoader the class loader
+     * @deprecated This method is legacy and will be removed - it must be
+     *     replaced by the specially provided constructor(s).
+     */
+    @Deprecated
+    protected final void initialize(PluginLoader loader, Server server, PluginDescriptionFile description, File dataFolder, File file, ClassLoader classLoader) {
+        if (server.getWarningState() == WarningState.OFF) {
+            return;
+        }
+        getLogger().log(Level.WARNING, getClass().getName() + " is already initialized", server.getWarningState() == WarningState.DEFAULT ? null : new AuthorNagException("Explicit initialization"));
+    }
+
+    final void init(PluginLoader loader, Server server, PluginDescriptionFile description, File dataFolder, File file, ClassLoader classLoader) {
+        this.loader = loader;
+        this.server = server;
+        this.file = file;
+        this.description = description;
+        this.dataFolder = dataFolder;
+        this.classLoader = classLoader;
+        this.configFile = new File(dataFolder, "config.yml");
+        this.logger = new PluginLogger(this);
+
+        if (description.isDatabaseEnabled()) {
+            ServerConfig db = new ServerConfig();
+
+            db.setDefaultServer(false);
+            db.setRegister(false);
+            db.setClasses(getDatabaseClasses());
+            db.setName(description.getName());
+            server.configureDbConfig(db);
+
+            DataSourceConfig ds = db.getDataSourceConfig();
+
+            ds.setUrl(replaceDatabaseString(ds.getUrl()));
+            dataFolder.mkdirs();
+
+            ClassLoader previous = Thread.currentThread().getContextClassLoader();
+
+            Thread.currentThread().setContextClassLoader(classLoader);
+            ebean = EbeanServerFactory.create(db);
+            Thread.currentThread().setContextClassLoader(previous);
+        }
+    }
+
+    /**
+     * Provides a list of all classes that should be persisted in the database
+     *
+     * @return List of Classes that are Ebeans
+     */
+    public List<Class<?>> getDatabaseClasses() {
+        return new ArrayList<Class<?>>();
+    }
+
+    private String replaceDatabaseString(String input) {
+        input = input.replaceAll("\\{DIR\\}", dataFolder.getPath().replaceAll("\\\\", "/") + "/");
+        input = input.replaceAll("\\{NAME\\}", description.getName().replaceAll("[^\\w_-]", ""));
+        return input;
+    }
+
+    /**
+     * Gets the initialization status of this plugin
+     *
+     * @return true if this plugin is initialized, otherwise false
+     * @deprecated This method cannot return false, as {@link
+     *     JavaPlugin} is now initialized in the constructor.
+     */
+    @Deprecated
+    public final boolean isInitialized() {
+        return true;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
+        return false;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public List<String> onTabComplete(CommandSender sender, Command command, String alias, String[] args) {
+        return null;
+    }
+
+    /**
+     * Gets the command with the given name, specific to this plugin. Commands
+     * need to be registered in the {@link PluginDescriptionFile#getCommands()
+     * PluginDescriptionFile} to exist at runtime.
+     *
+     * @param name name or alias of the command
+     * @return the plugin command if found, otherwise null
+     */
+    public PluginCommand getCommand(String name) {
+        String alias = name.toLowerCase();
+        PluginCommand command = getServer().getPluginCommand(alias);
+
+        if (command == null || command.getPlugin() != this) {
+            command = getServer().getPluginCommand(description.getName().toLowerCase() + ":" + alias);
+        }
+
+        if (command != null && command.getPlugin() == this) {
+            return command;
+        } else {
+            return null;
+        }
+    }
+
+    @Override
+    public void onLoad() {}
+
+    @Override
+    public void onDisable() {}
+
+    @Override
+    public void onEnable() {}
+
+    @Override
+    public ChunkGenerator getDefaultWorldGenerator(String worldName, String id) {
+        return null;
+    }
+
+    @Override
+    public final boolean isNaggable() {
+        return naggable;
+    }
+
+    @Override
+    public final void setNaggable(boolean canNag) {
+        this.naggable = canNag;
+    }
+
+    @Override
+    public EbeanServer getDatabase() {
+        Preconditions.checkState(description.isDatabaseEnabled(), "Plugin does not have database: true in plugin.yml");
+
+        return ebean;
+    }
+
+    protected void installDDL() {
+        SpiEbeanServer serv = (SpiEbeanServer) getDatabase();
+        DdlGenerator gen = serv.getDdlGenerator();
+
+        gen.runScript(false, gen.generateCreateDdl());
+    }
+
+    protected void removeDDL() {
+        SpiEbeanServer serv = (SpiEbeanServer) getDatabase();
+        DdlGenerator gen = serv.getDdlGenerator();
+
+        gen.runScript(true, gen.generateDropDdl());
+    }
+
+    @Override
+    public final Logger getLogger() {
+        return logger;
+    }
+
+    @Override
+    public String toString() {
+        return description.getFullName();
+    }
+
+    /**
+     * This method provides fast access to the plugin that has {@link
+     * #getProvidingPlugin(Class) provided} the given plugin class, which is
+     * usually the plugin that implemented it.
+     * <p>
+     * An exception to this would be if plugin's jar that contained the class
+     * does not extend the class, where the intended plugin would have
+     * resided in a different jar / classloader.
+     *
+     * @param <T> a class that extends JavaPlugin
+     * @param clazz the class desired
+     * @return the plugin that provides and implements said class
+     * @throws IllegalArgumentException if clazz is null
+     * @throws IllegalArgumentException if clazz does not extend {@link
+     *     JavaPlugin}
+     * @throws IllegalStateException if clazz was not provided by a plugin,
+     *     for example, if called with
+     *     <code>JavaPlugin.getPlugin(JavaPlugin.class)</code>
+     * @throws IllegalStateException if called from the static initializer for
+     *     given JavaPlugin
+     * @throws ClassCastException if plugin that provided the class does not
+     *     extend the class
+     */
+    public static <T extends JavaPlugin> T getPlugin(Class<T> clazz) {
+        Validate.notNull(clazz, "Null class cannot have a plugin");
+        if (!JavaPlugin.class.isAssignableFrom(clazz)) {
+            throw new IllegalArgumentException(clazz + " does not extend " + JavaPlugin.class);
+        }
+        final ClassLoader cl = clazz.getClassLoader();
+        if (!(cl instanceof PluginClassLoader)) {
+            throw new IllegalArgumentException(clazz + " is not initialized by " + PluginClassLoader.class);
+        }
+        JavaPlugin plugin = ((PluginClassLoader) cl).plugin;
+        if (plugin == null) {
+            throw new IllegalStateException("Cannot get plugin for " + clazz + " from a static initializer");
+        }
+        return clazz.cast(plugin);
+    }
+
+    /**
+     * This method provides fast access to the plugin that has provided the
+     * given class.
+     *
+     * @param clazz a class belonging to a plugin
+     * @return the plugin that provided the class
+     * @throws IllegalArgumentException if the class is not provided by a
+     *     JavaPlugin
+     * @throws IllegalArgumentException if class is null
+     * @throws IllegalStateException if called from the static initializer for
+     *     given JavaPlugin
+     */
+    public static JavaPlugin getProvidingPlugin(Class<?> clazz) {
+        Validate.notNull(clazz, "Null class cannot have a plugin");
+        final ClassLoader cl = clazz.getClassLoader();
+        if (!(cl instanceof PluginClassLoader)) {
+            throw new IllegalArgumentException(clazz + " is not provided by " + PluginClassLoader.class);
+        }
+        JavaPlugin plugin = ((PluginClassLoader) cl).plugin;
+        if (plugin == null) {
+            throw new IllegalStateException("Cannot get plugin for " + clazz + " from a static initializer");
+        }
+        return plugin;
+    }
+}
diff --git a/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java b/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java
new file mode 100644
index 0000000..bbd0ade
--- /dev/null
+++ b/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java
@@ -0,0 +1,364 @@
+package org.bukkit.plugin.java;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.Set;
+import java.util.jar.JarEntry;
+import java.util.jar.JarFile;
+import java.util.logging.Level;
+import java.util.regex.Pattern;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.Server;
+import org.bukkit.Warning;
+import org.bukkit.Warning.WarningState;
+import org.bukkit.configuration.serialization.ConfigurationSerializable;
+import org.bukkit.configuration.serialization.ConfigurationSerialization;
+import org.bukkit.event.Event;
+import org.bukkit.event.EventException;
+import org.bukkit.event.EventHandler;
+import org.bukkit.event.Listener;
+import org.bukkit.event.server.PluginDisableEvent;
+import org.bukkit.event.server.PluginEnableEvent;
+import org.bukkit.plugin.AuthorNagException;
+import org.bukkit.plugin.EventExecutor;
+import org.bukkit.plugin.InvalidDescriptionException;
+import org.bukkit.plugin.InvalidPluginException;
+import org.bukkit.plugin.Plugin;
+import org.bukkit.plugin.PluginDescriptionFile;
+import org.bukkit.plugin.PluginLoader;
+import org.bukkit.plugin.RegisteredListener;
+import org.bukkit.plugin.TimedRegisteredListener;
+import org.bukkit.plugin.UnknownDependencyException;
+import org.yaml.snakeyaml.error.YAMLException;
+
+/**
+ * Represents a Java plugin loader, allowing plugins in the form of .jar
+ */
+public final class JavaPluginLoader implements PluginLoader {
+    final Server server;
+    private final Pattern[] fileFilters = new Pattern[] { Pattern.compile("\\.jar$"), };
+    private final Map<String, Class<?>> classes = new java.util.concurrent.ConcurrentHashMap<String, Class<?>>(); // Spigot
+    private final Map<String, PluginClassLoader> loaders = new LinkedHashMap<String, PluginClassLoader>();
+
+    /**
+     * This class was not meant to be constructed explicitly
+     * 
+     * @param instance the server instance
+     */
+    @Deprecated
+    public JavaPluginLoader(Server instance) {
+        Validate.notNull(instance, "Server cannot be null");
+        server = instance;
+    }
+
+    public Plugin loadPlugin(final File file) throws InvalidPluginException {
+        Validate.notNull(file, "File cannot be null");
+
+        if (!file.exists()) {
+            throw new InvalidPluginException(new FileNotFoundException(file.getPath() + " does not exist"));
+        }
+
+        final PluginDescriptionFile description;
+        try {
+            description = getPluginDescription(file);
+        } catch (InvalidDescriptionException ex) {
+            throw new InvalidPluginException(ex);
+        }
+
+        final File parentFile = file.getParentFile();
+        final File dataFolder = new File(parentFile, description.getName());
+        @SuppressWarnings("deprecation")
+        final File oldDataFolder = new File(parentFile, description.getRawName());
+
+        // Found old data folder
+        if (dataFolder.equals(oldDataFolder)) {
+            // They are equal -- nothing needs to be done!
+        } else if (dataFolder.isDirectory() && oldDataFolder.isDirectory()) {
+            server.getLogger().warning(String.format(
+                "While loading %s (%s) found old-data folder: `%s' next to the new one `%s'",
+                description.getFullName(),
+                file,
+                oldDataFolder,
+                dataFolder
+            ));
+        } else if (oldDataFolder.isDirectory() && !dataFolder.exists()) {
+            if (!oldDataFolder.renameTo(dataFolder)) {
+                throw new InvalidPluginException("Unable to rename old data folder: `" + oldDataFolder + "' to: `" + dataFolder + "'");
+            }
+            server.getLogger().log(Level.INFO, String.format(
+                "While loading %s (%s) renamed data folder: `%s' to `%s'",
+                description.getFullName(),
+                file,
+                oldDataFolder,
+                dataFolder
+            ));
+        }
+
+        if (dataFolder.exists() && !dataFolder.isDirectory()) {
+            throw new InvalidPluginException(String.format(
+                "Projected datafolder: `%s' for %s (%s) exists and is not a directory",
+                dataFolder,
+                description.getFullName(),
+                file
+            ));
+        }
+
+        for (final String pluginName : description.getDepend()) {
+            if (loaders == null) {
+                throw new UnknownDependencyException(pluginName);
+            }
+            PluginClassLoader current = loaders.get(pluginName);
+
+            if (current == null) {
+                throw new UnknownDependencyException(pluginName);
+            }
+        }
+
+        final PluginClassLoader loader;
+        try {
+            loader = new PluginClassLoader(this, getClass().getClassLoader(), description, dataFolder, file);
+        } catch (InvalidPluginException ex) {
+            throw ex;
+        } catch (Throwable ex) {
+            throw new InvalidPluginException(ex);
+        }
+
+        loaders.put(description.getName(), loader);
+
+        return loader.plugin;
+    }
+
+    public PluginDescriptionFile getPluginDescription(File file) throws InvalidDescriptionException {
+        Validate.notNull(file, "File cannot be null");
+
+        JarFile jar = null;
+        InputStream stream = null;
+
+        try {
+            jar = new JarFile(file);
+            JarEntry entry = jar.getJarEntry("plugin.yml");
+
+            if (entry == null) {
+                throw new InvalidDescriptionException(new FileNotFoundException("Jar does not contain plugin.yml"));
+            }
+
+            stream = jar.getInputStream(entry);
+
+            return new PluginDescriptionFile(stream);
+
+        } catch (IOException ex) {
+            throw new InvalidDescriptionException(ex);
+        } catch (YAMLException ex) {
+            throw new InvalidDescriptionException(ex);
+        } finally {
+            if (jar != null) {
+                try {
+                    jar.close();
+                } catch (IOException e) {
+                }
+            }
+            if (stream != null) {
+                try {
+                    stream.close();
+                } catch (IOException e) {
+                }
+            }
+        }
+    }
+
+    public Pattern[] getPluginFileFilters() {
+        return fileFilters.clone();
+    }
+
+    Class<?> getClassByName(final String name) {
+        Class<?> cachedClass = classes.get(name);
+
+        if (cachedClass != null) {
+            return cachedClass;
+        } else {
+            for (String current : loaders.keySet()) {
+                PluginClassLoader loader = loaders.get(current);
+
+                try {
+                    cachedClass = loader.findClass(name, false);
+                } catch (ClassNotFoundException cnfe) {}
+                if (cachedClass != null) {
+                    return cachedClass;
+                }
+            }
+        }
+        return null;
+    }
+
+    void setClass(final String name, final Class<?> clazz) {
+        if (!classes.containsKey(name)) {
+            classes.put(name, clazz);
+
+            if (ConfigurationSerializable.class.isAssignableFrom(clazz)) {
+                Class<? extends ConfigurationSerializable> serializable = clazz.asSubclass(ConfigurationSerializable.class);
+                ConfigurationSerialization.registerClass(serializable);
+            }
+        }
+    }
+
+    private void removeClass(String name) {
+        Class<?> clazz = classes.remove(name);
+
+        try {
+            if ((clazz != null) && (ConfigurationSerializable.class.isAssignableFrom(clazz))) {
+                Class<? extends ConfigurationSerializable> serializable = clazz.asSubclass(ConfigurationSerializable.class);
+                ConfigurationSerialization.unregisterClass(serializable);
+            }
+        } catch (NullPointerException ex) {
+            // Boggle!
+            // (Native methods throwing NPEs is not fun when you can't stop it before-hand)
+        }
+    }
+
+    public Map<Class<? extends Event>, Set<RegisteredListener>> createRegisteredListeners(Listener listener, final Plugin plugin) {
+        Validate.notNull(plugin, "Plugin can not be null");
+        Validate.notNull(listener, "Listener can not be null");
+
+        boolean useTimings = server.getPluginManager().useTimings();
+        Map<Class<? extends Event>, Set<RegisteredListener>> ret = new HashMap<Class<? extends Event>, Set<RegisteredListener>>();
+        Set<Method> methods;
+        try {
+            Method[] publicMethods = listener.getClass().getMethods();
+            Method[] privateMethods = listener.getClass().getDeclaredMethods();
+            methods = new HashSet<Method>(publicMethods.length + privateMethods.length, 1.0f);
+            for (Method method : publicMethods) {
+                methods.add(method);
+            }
+            for (Method method : privateMethods) {
+                methods.add(method);
+            }
+        } catch (NoClassDefFoundError e) {
+            plugin.getLogger().severe("Plugin " + plugin.getDescription().getFullName() + " has failed to register events for " + listener.getClass() + " because " + e.getMessage() + " does not exist.");
+            return ret;
+        }
+
+        for (final Method method : methods) {
+            final EventHandler eh = method.getAnnotation(EventHandler.class);
+            if (eh == null) continue;
+            // Do not register bridge or synthetic methods to avoid event duplication
+            // Fixes SPIGOT-893
+            if (method.isBridge() || method.isSynthetic()) {
+                continue;
+            }
+            final Class<?> checkClass;
+            if (method.getParameterTypes().length != 1 || !Event.class.isAssignableFrom(checkClass = method.getParameterTypes()[0])) {
+                plugin.getLogger().severe(plugin.getDescription().getFullName() + " attempted to register an invalid EventHandler method signature \"" + method.toGenericString() + "\" in " + listener.getClass());
+                continue;
+            }
+            final Class<? extends Event> eventClass = checkClass.asSubclass(Event.class);
+            method.setAccessible(true);
+            Set<RegisteredListener> eventSet = ret.get(eventClass);
+            if (eventSet == null) {
+                eventSet = new HashSet<RegisteredListener>();
+                ret.put(eventClass, eventSet);
+            }
+
+            for (Class<?> clazz = eventClass; Event.class.isAssignableFrom(clazz); clazz = clazz.getSuperclass()) {
+                // This loop checks for extending deprecated events
+                if (clazz.getAnnotation(Deprecated.class) != null) {
+                    Warning warning = clazz.getAnnotation(Warning.class);
+                    WarningState warningState = server.getWarningState();
+                    if (!warningState.printFor(warning)) {
+                        break;
+                    }
+                    plugin.getLogger().log(
+                            Level.WARNING,
+                            String.format(
+                                    "\"%s\" has registered a listener for %s on method \"%s\", but the event is Deprecated." +
+                                    " \"%s\"; please notify the authors %s.",
+                                    plugin.getDescription().getFullName(),
+                                    clazz.getName(),
+                                    method.toGenericString(),
+                                    (warning != null && warning.reason().length() != 0) ? warning.reason() : "Server performance will be affected",
+                                    Arrays.toString(plugin.getDescription().getAuthors().toArray())),
+                            warningState == WarningState.ON ? new AuthorNagException(null) : null);
+                    break;
+                }
+            }
+
+            EventExecutor executor = new co.aikar.timings.TimedEventExecutor(EventExecutor.create(method, eventClass), plugin, method, eventClass); // Spigot // Paper - Use factory method `EventExecutor.create()`
+            if (false) { // Spigot - RL handles useTimings check now
+                eventSet.add(new TimedRegisteredListener(listener, executor, eh.priority(), plugin, eh.ignoreCancelled()));
+            } else {
+                eventSet.add(new RegisteredListener(listener, executor, eh.priority(), plugin, eh.ignoreCancelled()));
+            }
+        }
+        return ret;
+    }
+
+    public void enablePlugin(final Plugin plugin) {
+        Validate.isTrue(plugin instanceof JavaPlugin, "Plugin is not associated with this PluginLoader");
+
+        if (!plugin.isEnabled()) {
+            plugin.getLogger().info("Enabling " + plugin.getDescription().getFullName());
+
+            JavaPlugin jPlugin = (JavaPlugin) plugin;
+
+            String pluginName = jPlugin.getDescription().getName();
+
+            if (!loaders.containsKey(pluginName)) {
+                loaders.put(pluginName, (PluginClassLoader) jPlugin.getClassLoader());
+            }
+
+            try {
+                jPlugin.setEnabled(true);
+            } catch (Throwable ex) {
+                server.getLogger().log(Level.SEVERE, "Error occurred while enabling " + plugin.getDescription().getFullName() + " (Is it up to date?)", ex);
+                // Paper start - Disable plugins that fail to load
+                disablePlugin(jPlugin);
+                return;
+                // Paper end
+            }
+
+            // Perhaps abort here, rather than continue going, but as it stands,
+            // an abort is not possible the way it's currently written
+            server.getPluginManager().callEvent(new PluginEnableEvent(plugin));
+        }
+    }
+
+    public void disablePlugin(Plugin plugin) {
+        Validate.isTrue(plugin instanceof JavaPlugin, "Plugin is not associated with this PluginLoader");
+
+        if (plugin.isEnabled()) {
+            String message = String.format("Disabling %s", plugin.getDescription().getFullName());
+            plugin.getLogger().info(message);
+
+            server.getPluginManager().callEvent(new PluginDisableEvent(plugin));
+
+            JavaPlugin jPlugin = (JavaPlugin) plugin;
+            ClassLoader cloader = jPlugin.getClassLoader();
+
+            try {
+                jPlugin.setEnabled(false);
+            } catch (Throwable ex) {
+                server.getLogger().log(Level.SEVERE, "Error occurred while disabling " + plugin.getDescription().getFullName() + " (Is it up to date?)", ex);
+            }
+
+            loaders.remove(jPlugin.getDescription().getName());
+
+            if (cloader instanceof PluginClassLoader) {
+                PluginClassLoader loader = (PluginClassLoader) cloader;
+                Set<String> names = loader.getClasses();
+
+                for (String name : names) {
+                    removeClass(name);
+                }
+            }
+        }
+    }
+}
diff --git a/src/main/java/org/bukkit/plugin/java/PluginClassLoader.java b/src/main/java/org/bukkit/plugin/java/PluginClassLoader.java
new file mode 100644
index 0000000..99b5cc4e
--- /dev/null
+++ b/src/main/java/org/bukkit/plugin/java/PluginClassLoader.java
@@ -0,0 +1,131 @@
+package org.bukkit.plugin.java;
+
+import java.io.File;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.net.URLClassLoader;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.plugin.InvalidPluginException;
+import org.bukkit.plugin.PluginDescriptionFile;
+
+/**
+ * A ClassLoader for plugins, to allow shared classes across multiple plugins
+ */
+public final class PluginClassLoader extends URLClassLoader { // Spigot
+    public JavaPlugin getPlugin() { return plugin; } // Spigot
+    private final JavaPluginLoader loader;
+    private final Map<String, Class<?>> classes = new java.util.concurrent.ConcurrentHashMap<String, Class<?>>(); // Spigot
+    private final PluginDescriptionFile description;
+    private final File dataFolder;
+    private final File file;
+    final JavaPlugin plugin;
+    private JavaPlugin pluginInit;
+    private IllegalStateException pluginState;
+
+    // Spigot Start
+    static
+    {
+        try
+        {
+            java.lang.reflect.Method method = ClassLoader.class.getDeclaredMethod( "registerAsParallelCapable" );
+            if ( method != null )
+            {
+                boolean oldAccessible = method.isAccessible();
+                method.setAccessible( true );
+                method.invoke( null );
+                method.setAccessible( oldAccessible );
+                org.bukkit.Bukkit.getLogger().log( java.util.logging.Level.INFO, "Set PluginClassLoader as parallel capable" );
+            }
+        } catch ( NoSuchMethodException ex )
+        {
+            // Ignore
+        } catch ( Exception ex )
+        {
+            org.bukkit.Bukkit.getLogger().log( java.util.logging.Level.WARNING, "Error setting PluginClassLoader as parallel capable", ex );
+        }
+    }
+    // Spigot End
+    
+    PluginClassLoader(final JavaPluginLoader loader, final ClassLoader parent, final PluginDescriptionFile description, final File dataFolder, final File file) throws InvalidPluginException, MalformedURLException {
+        super(new URL[] {file.toURI().toURL()}, parent);
+        Validate.notNull(loader, "Loader cannot be null");
+
+        this.loader = loader;
+        this.description = description;
+        this.dataFolder = dataFolder;
+        this.file = file;
+
+        try {
+            Class<?> jarClass;
+            try {
+                jarClass = Class.forName(description.getMain(), true, this);
+            } catch (ClassNotFoundException ex) {
+                throw new InvalidPluginException("Cannot find main class `" + description.getMain() + "'", ex);
+            }
+
+            Class<? extends JavaPlugin> pluginClass;
+            try {
+                pluginClass = jarClass.asSubclass(JavaPlugin.class);
+            } catch (ClassCastException ex) {
+                throw new InvalidPluginException("main class `" + description.getMain() + "' does not extend JavaPlugin", ex);
+            }
+
+            plugin = pluginClass.newInstance();
+        } catch (IllegalAccessException ex) {
+            throw new InvalidPluginException("No public constructor", ex);
+        } catch (InstantiationException ex) {
+            throw new InvalidPluginException("Abnormal plugin type", ex);
+        }
+    }
+
+    @Override
+    protected Class<?> findClass(String name) throws ClassNotFoundException {
+        return findClass(name, true);
+    }
+
+    Class<?> findClass(String name, boolean checkGlobal) throws ClassNotFoundException {
+        if (name.startsWith("org.bukkit.") || name.startsWith("net.minecraft.")) {
+            throw new ClassNotFoundException(name);
+        }
+        Class<?> result = classes.get(name);
+
+        if (result == null) {
+            if (checkGlobal) {
+                result = loader.getClassByName(name);
+            }
+
+            if (result == null) {
+                result = super.findClass(name);
+
+                if (result != null) {
+                    loader.setClass(name, result);
+                }
+            }
+
+            classes.put(name, result);
+        }
+
+        return result;
+    }
+
+    Set<String> getClasses() {
+        return classes.keySet();
+    }
+
+    synchronized void initialize(JavaPlugin javaPlugin) {
+        Validate.notNull(javaPlugin, "Initializing plugin cannot be null");
+        Validate.isTrue(javaPlugin.getClass().getClassLoader() == this, "Cannot initialize plugin outside of this class loader");
+        if (this.plugin != null || this.pluginInit != null) {
+            throw new IllegalArgumentException("Plugin already initialized!", pluginState);
+        }
+
+        pluginState = new IllegalStateException("Initial initialization");
+        this.pluginInit = javaPlugin;
+
+        javaPlugin.init(loader, loader.server, description, dataFolder, file, this);
+    }
+}
diff --git a/src/main/java/org/bukkit/potion/Potion.java b/src/main/java/org/bukkit/potion/Potion.java
new file mode 100644
index 0000000..e9676d6
--- /dev/null
+++ b/src/main/java/org/bukkit/potion/Potion.java
@@ -0,0 +1,468 @@
+package org.bukkit.potion;
+
+import java.util.Collection;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.Material;
+import org.bukkit.entity.LivingEntity;
+import org.bukkit.inventory.ItemStack;
+import org.bukkit.inventory.meta.PotionMeta;
+
+/**
+ * Potion Adapter for pre-1.9 data values
+ * see @PotionMeta for 1.9+
+ */
+@Deprecated
+public class Potion {
+    private boolean extended = false;
+    private boolean splash = false;
+    private int level = 1;
+    private PotionType type;
+
+    /**
+     * Construct a new potion of the given type. Unless the type is {@link
+     * PotionType#WATER}, it will be level one, without extended duration.
+     * Don't use this constructor to create a no-effect potion other than
+     * water bottle.
+     *
+     * @param type The potion type
+     * @see #Potion(int)
+     */
+    public Potion(PotionType type) {
+        Validate.notNull(type, "Null PotionType");
+        this.type = type;
+    }
+
+    /**
+     * @deprecated In favour of {@link #Potion(PotionType, int)}
+     */
+    @Deprecated
+    public Potion(PotionType type, Tier tier) {
+        this(type, tier == Tier.TWO ? 2 : 1);
+        Validate.notNull(type, "Type cannot be null");
+    }
+
+    /**
+     * @deprecated In favour of {@link #Potion(PotionType, int, boolean)}
+     */
+    @Deprecated
+    public Potion(PotionType type, Tier tier, boolean splash) {
+        this(type, tier == Tier.TWO ? 2 : 1, splash);
+    }
+
+    /**
+     * @deprecated In favour of {@link #Potion(PotionType, int, boolean,
+     *     boolean)}
+     */
+    @Deprecated
+    public Potion(PotionType type, Tier tier, boolean splash, boolean extended) {
+        this(type, tier, splash);
+        this.extended = extended;
+    }
+
+    /**
+     * Create a new potion of the given type and level.
+     *
+     * @param type The type of potion.
+     * @param level The potion's level.
+     */
+    public Potion(PotionType type, int level) {
+        this(type);
+        Validate.notNull(type, "Type cannot be null");
+        Validate.isTrue(level > 0 && level < 3, "Level must be 1 or 2");
+        this.level = level;
+    }
+
+    /**
+     * Create a new potion of the given type and level.
+     *
+     * @param type The type of potion.
+     * @param level The potion's level.
+     * @param splash Whether it is a splash potion.
+     * @deprecated In favour of using {@link #Potion(PotionType)} with {@link
+     *     #splash()}.
+     */
+    @Deprecated
+    public Potion(PotionType type, int level, boolean splash) {
+        this(type, level);
+        this.splash = splash;
+    }
+
+    /**
+     * Create a new potion of the given type and level.
+     *
+     * @param type The type of potion.
+     * @param level The potion's level.
+     * @param splash Whether it is a splash potion.
+     * @param extended Whether it has an extended duration.
+     * @deprecated In favour of using {@link #Potion(PotionType)} with {@link
+     *     #extend()} and possibly {@link #splash()}.
+     */
+    @Deprecated
+    public Potion(PotionType type, int level, boolean splash, boolean extended) {
+        this(type, level, splash);
+        this.extended = extended;
+    }
+
+    /**
+     * @deprecated
+     */
+    @Deprecated
+    public Potion(int name) {
+        this(PotionType.WATER);
+    }
+
+    /**
+     * Chain this to the constructor to make the potion a splash potion.
+     *
+     * @return The potion.
+     */
+    public Potion splash() {
+        setSplash(true);
+        return this;
+    }
+
+    /**
+     * Chain this to the constructor to extend the potion's duration.
+     *
+     * @return The potion.
+     */
+    public Potion extend() {
+        setHasExtendedDuration(true);
+        return this;
+    }
+
+    /**
+     * Applies the effects of this potion to the given {@link ItemStack}. The
+     * ItemStack must be a potion.
+     *
+     * @param to The itemstack to apply to
+     */
+    public void apply(ItemStack to) {
+        Validate.notNull(to, "itemstack cannot be null");
+        Validate.isTrue(to.hasItemMeta(), "given itemstack is not a potion");
+        Validate.isTrue(to.getItemMeta() instanceof PotionMeta, "given itemstack is not a potion");
+        PotionMeta meta = (PotionMeta) to.getItemMeta();
+        meta.setBasePotionData(new PotionData(type, extended, level == 2));
+        to.setItemMeta(meta);
+    }
+
+    /**
+     * Applies the effects that would be applied by this potion to the given
+     * {@link LivingEntity}.
+     *
+     * @see LivingEntity#addPotionEffects(Collection)
+     * @param to The entity to apply the effects to
+     */
+    public void apply(LivingEntity to) {
+        Validate.notNull(to, "entity cannot be null");
+        to.addPotionEffects(getEffects());
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj) {
+            return true;
+        }
+        if (obj == null || getClass() != obj.getClass()) {
+            return false;
+        }
+        Potion other = (Potion) obj;
+        return extended == other.extended && splash == other.splash && level == other.level && type == other.type;
+    }
+
+    /**
+     * Returns a collection of {@link PotionEffect}s that this {@link Potion}
+     * would confer upon a {@link LivingEntity}.
+     *
+     * @see PotionBrewer#getEffectsFromDamage(int)
+     * @see Potion#toDamageValue()
+     * @return The effects that this potion applies
+     */
+    public Collection<PotionEffect> getEffects() {
+        return getBrewer().getEffects(type, level == 2, extended);
+    }
+
+    /**
+     * Returns the level of this potion.
+     *
+     * @return The level of this potion
+     */
+    public int getLevel() {
+        return level;
+    }
+
+    /**
+     * Returns the {@link Tier} of this potion.
+     *
+     * @return The tier of this potion
+     * @deprecated
+     */
+    @Deprecated
+    public Tier getTier() {
+        return level == 2 ? Tier.TWO : Tier.ONE;
+    }
+
+    /**
+     * Returns the {@link PotionType} of this potion.
+     *
+     * @return The type of this potion
+     */
+    public PotionType getType() {
+        return type;
+    }
+
+    /**
+     * Returns whether this potion has an extended duration.
+     *
+     * @return Whether this potion has extended duration
+     */
+    public boolean hasExtendedDuration() {
+        return extended;
+    }
+
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int result = prime + level;
+        result = prime * result + (extended ? 1231 : 1237);
+        result = prime * result + (splash ? 1231 : 1237);
+        result = prime * result + ((type == null) ? 0 : type.hashCode());
+        return result;
+    }
+
+    /**
+     * Returns whether this potion is a splash potion.
+     *
+     * @return Whether this is a splash potion
+     */
+    public boolean isSplash() {
+        return splash;
+    }
+
+    /**
+     * Set whether this potion has extended duration. This will cause the
+     * potion to have roughly 8/3 more duration than a regular potion.
+     *
+     * @param isExtended Whether the potion should have extended duration
+     */
+    public void setHasExtendedDuration(boolean isExtended) {
+        Validate.isTrue(type == null || !type.isInstant(), "Instant potions cannot be extended");
+        extended = isExtended;
+    }
+
+    /**
+     * Sets whether this potion is a splash potion. Splash potions can be
+     * thrown for a radius effect.
+     *
+     * @param isSplash Whether this is a splash potion
+     */
+    public void setSplash(boolean isSplash) {
+        splash = isSplash;
+    }
+
+    /**
+     * Sets the {@link Tier} of this potion.
+     *
+     * @param tier The new tier of this potion
+     * @deprecated In favour of {@link #setLevel(int)}
+     */
+    @Deprecated
+    public void setTier(Tier tier) {
+        Validate.notNull(tier, "tier cannot be null");
+        this.level = (tier == Tier.TWO ? 2 : 1);
+    }
+
+    /**
+     * Sets the {@link PotionType} of this potion.
+     *
+     * @param type The new type of this potion
+     */
+    public void setType(PotionType type) {
+        this.type = type;
+    }
+
+    /**
+     * Sets the level of this potion.
+     *
+     * @param level The new level of this potion
+     */
+    public void setLevel(int level) {
+        Validate.notNull(this.type, "No-effect potions don't have a level.");
+        Validate.isTrue(level > 0 && level <= 2, "Level must be between 1 and 2 for this potion");
+        this.level = level;
+    }
+
+    /**
+     * Converts this potion to a valid potion damage short, usable for potion
+     * item stacks.
+     *
+     * @return The damage value of this potion
+     * @deprecated Non-functional
+     */
+    @Deprecated
+    public short toDamageValue() {
+        return 0;
+    }
+
+    /**
+     * Converts this potion to an {@link ItemStack} with the specified amount
+     * and a correct damage value.
+     *
+     * @param amount The amount of the ItemStack
+     * @return The created ItemStack
+     */
+    public ItemStack toItemStack(int amount) {
+        Material material;
+        if (isSplash()) {
+            material = Material.SPLASH_POTION;
+        } else {
+            material = Material.POTION;
+        }
+        ItemStack itemStack = new ItemStack(material, amount);
+        PotionMeta meta = (PotionMeta) itemStack.getItemMeta();
+        meta.setBasePotionData(new PotionData(type, level == 2, extended));
+        itemStack.setItemMeta(meta);
+        return itemStack;
+    }
+
+    @Deprecated
+    public enum Tier {
+        ONE(0),
+        TWO(0x20);
+
+        private int damageBit;
+
+        Tier(int bit) {
+            damageBit = bit;
+        }
+
+        public int getDamageBit() {
+            return damageBit;
+        }
+
+        public static Tier getByDamageBit(int damageBit) {
+            for (Tier tier : Tier.values()) {
+                if (tier.damageBit == damageBit)
+                    return tier;
+            }
+            return null;
+        }
+    }
+
+    private static PotionBrewer brewer;
+
+    private static final int EXTENDED_BIT = 0x40;
+    private static final int POTION_BIT = 0xF;
+    private static final int SPLASH_BIT = 0x4000;
+    private static final int TIER_BIT = 0x20;
+    private static final int TIER_SHIFT = 5;
+
+    /**
+     *
+     * @param damage the damage value
+     * @return the produced potion
+     */
+    public static Potion fromDamage(int damage) {
+        PotionType type;
+        switch (damage & POTION_BIT) {
+            case 0:
+                type = PotionType.WATER;
+                break;
+            case 1:
+                type = PotionType.REGEN;
+                break;
+            case 2:
+                type = PotionType.SPEED;
+                break;
+            case 3:
+                type = PotionType.FIRE_RESISTANCE;
+                break;
+            case 4:
+                type = PotionType.POISON;
+                break;
+            case 5:
+                type = PotionType.INSTANT_HEAL;
+                break;
+            case 6:
+                type = PotionType.NIGHT_VISION;
+                break;
+            case 8:
+                type = PotionType.WEAKNESS;
+                break;
+            case 9:
+                type = PotionType.STRENGTH;
+                break;
+            case 10:
+                type = PotionType.SLOWNESS;
+                break;
+            case 11:
+                type = PotionType.JUMP;
+                break;
+            case 12:
+                type = PotionType.INSTANT_DAMAGE;
+                break;
+            case 13:
+                type = PotionType.WATER_BREATHING;
+                break;
+            case 14:
+                type = PotionType.INVISIBILITY;
+                break;
+            default:
+                type = PotionType.WATER;
+        }
+        Potion potion;
+        if (type == null || type == PotionType.WATER) {
+            potion = new Potion(PotionType.WATER);
+        } else {
+            int level = (damage & TIER_BIT) >> TIER_SHIFT;
+            level++;
+            potion = new Potion(type, level);
+        }
+        if ((damage & SPLASH_BIT) > 0) {
+            potion = potion.splash();
+        }
+        if ((damage & EXTENDED_BIT) > 0) {
+            potion = potion.extend();
+        }
+        return potion;
+    }
+
+    public static Potion fromItemStack(ItemStack item) {
+        Validate.notNull(item, "item cannot be null");
+        if (item.getType() != Material.POTION)
+            throw new IllegalArgumentException("item is not a potion");
+        return fromDamage(item.getDurability());
+    }
+
+    /**
+     * Returns an instance of {@link PotionBrewer}.
+     *
+     * @return An instance of PotionBrewer
+     */
+    public static PotionBrewer getBrewer() {
+        return brewer;
+    }
+
+    /**
+     * Sets the current instance of {@link PotionBrewer}. Generally not to be
+     * used from within a plugin.
+     *
+     * @param other The new PotionBrewer
+     */
+    public static void setPotionBrewer(PotionBrewer other) {
+        if (brewer != null)
+            throw new IllegalArgumentException("brewer can only be set internally");
+        brewer = other;
+    }
+
+    /**
+     *
+     * @return the name id
+     * @deprecated Non-functional
+     */
+    @Deprecated
+    public int getNameId() {
+        return 0;
+    }
+}
diff --git a/src/main/java/org/bukkit/potion/PotionData.java b/src/main/java/org/bukkit/potion/PotionData.java
new file mode 100644
index 0000000..24ea497
--- /dev/null
+++ b/src/main/java/org/bukkit/potion/PotionData.java
@@ -0,0 +1,85 @@
+package org.bukkit.potion;
+
+import org.apache.commons.lang3.Validate;
+
+public final class PotionData {
+
+    private final PotionType type;
+    private final boolean extended;
+    private final boolean upgraded;
+
+    /**
+     * Instantiates a final PotionData object to contain information about a
+     * Potion
+     *
+     * @param type the type of the Potion
+     * @param extended whether the potion is extended PotionType#isExtendable()
+     * must be true
+     * @param upgraded whether the potion is upgraded PotionType#isUpgradable()
+     * must be true
+     */
+    public PotionData(PotionType type, boolean extended, boolean upgraded) {
+        Validate.notNull(type, "Potion Type must not be null");
+        Validate.isTrue(!upgraded || type.isUpgradeable(), "Potion Type is not upgradable");
+        Validate.isTrue(!extended || type.isExtendable(), "Potion Type is not extendable");
+        Validate.isTrue(!upgraded || !extended, "Potion cannot be both extended and upgraded");
+        this.type = type;
+        this.extended = extended;
+        this.upgraded = upgraded;
+    }
+
+    public PotionData(PotionType type) {
+        this(type, false, false);
+    }
+
+    /**
+     * Gets the type of the potion, Type matches up with each kind of craftable
+     * potion
+     *
+     * @return the potion type
+     */
+    public PotionType getType() {
+        return type;
+    }
+
+    /**
+     * Checks if the potion is in an upgraded state. This refers to whether or
+     * not the potion is Tier 2, such as Potion of Fire Resistance II.
+     *
+     * @return true if the potion is upgraded;
+     */
+    public boolean isUpgraded() {
+        return upgraded;
+    }
+
+    /**
+     * Checks if the potion is in an extended state. This refers to the extended
+     * duration potions
+     *
+     * @return true if the potion is extended
+     */
+    public boolean isExtended() {
+        return extended;
+    }
+
+    @Override
+    public int hashCode() {
+        int hash = 7;
+        hash = 23 * hash + (this.type != null ? this.type.hashCode() : 0);
+        hash = 23 * hash + (this.extended ? 1 : 0);
+        hash = 23 * hash + (this.upgraded ? 1 : 0);
+        return hash;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj) {
+            return true;
+        }
+        if (obj == null || getClass() != obj.getClass()) {
+            return false;
+        }
+        PotionData other = (PotionData) obj;
+        return (this.upgraded == other.upgraded) && (this.extended == other.extended) && (this.type == other.type);
+    }
+}
diff --git a/src/main/java/org/bukkit/potion/PotionEffect.java b/src/main/java/org/bukkit/potion/PotionEffect.java
new file mode 100644
index 0000000..549d3f1
--- /dev/null
+++ b/src/main/java/org/bukkit/potion/PotionEffect.java
@@ -0,0 +1,229 @@
+package org.bukkit.potion;
+
+import java.util.Map;
+import java.util.NoSuchElementException;
+
+import org.apache.commons.lang3.Validate;
+import org.bukkit.Color;
+import org.bukkit.configuration.serialization.ConfigurationSerializable;
+import org.bukkit.configuration.serialization.SerializableAs;
+import org.bukkit.entity.LivingEntity;
+
+import com.google.common.collect.ImmutableMap;
+
+/**
+ * Represents a potion effect, that can be added to a {@link LivingEntity}. A
+ * potion effect has a duration that it will last for, an amplifier that will
+ * enhance its effects, and a {@link PotionEffectType}, that represents its
+ * effect on an entity.
+ */
+@SerializableAs("PotionEffect")
+public class PotionEffect implements ConfigurationSerializable {
+    private static final String AMPLIFIER = "amplifier";
+    private static final String DURATION = "duration";
+    private static final String TYPE = "effect";
+    private static final String AMBIENT = "ambient";
+    private static final String PARTICLES = "has-particles";
+    private final int amplifier;
+    private final int duration;
+    private final PotionEffectType type;
+    private final boolean ambient;
+    private final boolean particles;
+    private final Color color;
+
+    /**
+     * Creates a potion effect.
+     * @param type effect type
+     * @param duration measured in ticks, see {@link
+     *     PotionEffect#getDuration()}
+     * @param amplifier the amplifier, see {@link PotionEffect#getAmplifier()}
+     * @param ambient the ambient status, see {@link PotionEffect#isAmbient()}
+     * @param particles the particle status, see {@link PotionEffect#hasParticles()}
+     * @param color the particle color, see {@link PotionEffect#getColor()}
+     */
+    public PotionEffect(PotionEffectType type, int duration, int amplifier, boolean ambient, boolean particles, Color color){
+        Validate.notNull(type, "effect type cannot be null");
+        this.type = type;
+        this.duration = duration;
+        this.amplifier = amplifier;
+        this.ambient = ambient;
+        this.particles = particles;
+        this.color = color;
+    }
+
+    /**
+     * Creates a potion effect with no defined color.
+     *
+     * @param type effect type
+     * @param duration measured in ticks, see {@link
+     *     PotionEffect#getDuration()}
+     * @param amplifier the amplifier, see {@link PotionEffect#getAmplifier()}
+     * @param ambient the ambient status, see {@link PotionEffect#isAmbient()}
+     * @param particles the particle status, see {@link PotionEffect#hasParticles()}
+     */
+    public PotionEffect(PotionEffectType type, int duration, int amplifier, boolean ambient, boolean particles) {
+        this(type, duration, amplifier, ambient, particles, null);
+    }
+
+    /**
+     * Creates a potion effect. Assumes that particles are visible
+     *
+     * @param type effect type
+     * @param duration measured in ticks, see {@link
+     *     PotionEffect#getDuration()}
+     * @param amplifier the amplifier, see {@link PotionEffect#getAmplifier()}
+     * @param ambient the ambient status, see {@link PotionEffect#isAmbient()}
+     */
+    public PotionEffect(PotionEffectType type, int duration, int amplifier, boolean ambient) {
+        this(type, duration, amplifier, ambient, true);
+    }
+
+    /**
+     * Creates a potion effect. Assumes ambient is true.
+     *
+     * @param type Effect type
+     * @param duration measured in ticks
+     * @param amplifier the amplifier for the effect
+     * @see PotionEffect#PotionEffect(PotionEffectType, int, int, boolean)
+     */
+    public PotionEffect(PotionEffectType type, int duration, int amplifier) {
+        this(type, duration, amplifier, true);
+    }
+
+    /**
+     * Constructor for deserialization.
+     *
+     * @param map the map to deserialize from
+     */
+    public PotionEffect(Map<String, Object> map) {
+        this(getEffectType(map), getInt(map, DURATION), getInt(map, AMPLIFIER), getBool(map, AMBIENT, false), getBool(map, PARTICLES, true));
+    }
+
+    private static PotionEffectType getEffectType(Map<?,?> map) {
+        int type = getInt(map, TYPE);
+        PotionEffectType effect = PotionEffectType.getById(type);
+        if (effect != null) {
+            return effect;
+        }
+        throw new NoSuchElementException(map + " does not contain " + TYPE);
+    }
+
+    private static int getInt(Map<?,?> map, Object key) {
+        Object num = map.get(key);
+        if (num instanceof Integer) {
+            return (Integer) num;
+        }
+        throw new NoSuchElementException(map + " does not contain " + key);
+    }
+
+    private static boolean getBool(Map<?,?> map, Object key, boolean def) {
+        Object bool = map.get(key);
+        if (bool instanceof Boolean) {
+            return (Boolean) bool;
+        }
+        return def;
+    }
+
+    public Map<String, Object> serialize() {
+        return ImmutableMap.<String, Object>of(
+            TYPE, type.getId(),
+            DURATION, duration,
+            AMPLIFIER, amplifier,
+            AMBIENT, ambient,
+            PARTICLES, particles
+        );
+    }
+
+    /**
+     * Attempts to add the effect represented by this object to the given
+     * {@link LivingEntity}.
+     *
+     * @see LivingEntity#addPotionEffect(PotionEffect)
+     * @param entity The entity to add this effect to
+     * @return Whether the effect could be added
+     */
+    public boolean apply(LivingEntity entity) {
+        return entity.addPotionEffect(this);
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj) {
+            return true;
+        }
+        if (!(obj instanceof PotionEffect)) {
+            return false;
+        }
+        PotionEffect that = (PotionEffect) obj;
+        return this.type.equals(that.type) && this.ambient == that.ambient && this.amplifier == that.amplifier && this.duration == that.duration && this.particles == that.particles;
+    }
+
+    /**
+     * Returns the amplifier of this effect. A higher amplifier means the
+     * potion effect happens more often over its duration and in some cases
+     * has more effect on its target.
+     *
+     * @return The effect amplifier
+     */
+    public int getAmplifier() {
+        return amplifier;
+    }
+
+    /**
+     * Returns the duration (in ticks) that this effect will run for when
+     * applied to a {@link LivingEntity}.
+     *
+     * @return The duration of the effect
+     */
+    public int getDuration() {
+        return duration;
+    }
+
+    /**
+     * Returns the {@link PotionEffectType} of this effect.
+     *
+     * @return The potion type of this effect
+     */
+    public PotionEffectType getType() {
+        return type;
+    }
+
+    /**
+     * Makes potion effect produce more, translucent, particles.
+     *
+     * @return if this effect is ambient
+     */
+    public boolean isAmbient() {
+        return ambient;
+    }
+
+    /**
+     * @return whether this effect has particles or not
+     */
+    public boolean hasParticles(){
+        return particles;
+    }
+
+    /**
+     * @return color of this potion's particles. May be null if the potion has no particles or defined color.
+     */
+    public Color getColor() {
+        return color;
+    }
+
+    @Override
+    public int hashCode() {
+        int hash = 1;
+        hash = hash * 31 + type.hashCode();
+        hash = hash * 31 + amplifier;
+        hash = hash * 31 + duration;
+        hash ^= 0x22222222 >> (ambient ? 1 : -1);
+        hash ^= 0x22222222 >> (particles ? 1 : -1);
+        return hash;
+    }
+
+    @Override
+    public String toString() {
+        return type.getName() + (ambient ? ":(" : ":") + duration + "t-x" + amplifier + (ambient ? ")" : "");
+    }
+}
diff --git a/src/main/java/org/bukkit/potion/PotionEffectType.java b/src/main/java/org/bukkit/potion/PotionEffectType.java
new file mode 100644
index 0000000..0696f93
--- /dev/null
+++ b/src/main/java/org/bukkit/potion/PotionEffectType.java
@@ -0,0 +1,290 @@
+package org.bukkit.potion;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import org.apache.commons.lang3.Validate;
+
+/**
+ * Represents a type of potion and its effect on an entity.
+ */
+public abstract class PotionEffectType {
+    /**
+     * Increases movement speed.
+     */
+    public static final PotionEffectType SPEED = new PotionEffectTypeWrapper(1);
+
+    /**
+     * Decreases movement speed.
+     */
+    public static final PotionEffectType SLOW = new PotionEffectTypeWrapper(2);
+
+    /**
+     * Increases dig speed.
+     */
+    public static final PotionEffectType FAST_DIGGING = new PotionEffectTypeWrapper(3);
+
+    /**
+     * Decreases dig speed.
+     */
+    public static final PotionEffectType SLOW_DIGGING = new PotionEffectTypeWrapper(4);
+
+    /**
+     * Increases damage dealt.
+     */
+    public static final PotionEffectType INCREASE_DAMAGE = new PotionEffectTypeWrapper(5);
+
+    /**
+     * Heals an entity.
+     */
+    public static final PotionEffectType HEAL = new PotionEffectTypeWrapper(6);
+
+    /**
+     * Hurts an entity.
+     */
+    public static final PotionEffectType HARM = new PotionEffectTypeWrapper(7);
+
+    /**
+     * Increases jump height.
+     */
+    public static final PotionEffectType JUMP = new PotionEffectTypeWrapper(8);
+
+    /**
+     * Warps vision on the client.
+     */
+    public static final PotionEffectType CONFUSION = new PotionEffectTypeWrapper(9);
+
+    /**
+     * Regenerates health.
+     */
+    public static final PotionEffectType REGENERATION = new PotionEffectTypeWrapper(10);
+
+    /**
+     * Decreases damage dealt to an entity.
+     */
+    public static final PotionEffectType DAMAGE_RESISTANCE = new PotionEffectTypeWrapper(11);
+
+    /**
+     * Stops fire damage.
+     */
+    public static final PotionEffectType FIRE_RESISTANCE = new PotionEffectTypeWrapper(12);
+
+    /**
+     * Allows breathing underwater.
+     */
+    public static final PotionEffectType WATER_BREATHING = new PotionEffectTypeWrapper(13);
+
+    /**
+     * Grants invisibility.
+     */
+    public static final PotionEffectType INVISIBILITY = new PotionEffectTypeWrapper(14);
+
+    /**
+     * Blinds an entity.
+     */
+    public static final PotionEffectType BLINDNESS = new PotionEffectTypeWrapper(15);
+
+    /**
+     * Allows an entity to see in the dark.
+     */
+    public static final PotionEffectType NIGHT_VISION = new PotionEffectTypeWrapper(16);
+
+    /**
+     * Increases hunger.
+     */
+    public static final PotionEffectType HUNGER = new PotionEffectTypeWrapper(17);
+
+    /**
+     * Decreases damage dealt by an entity.
+     */
+    public static final PotionEffectType WEAKNESS = new PotionEffectTypeWrapper(18);
+
+    /**
+     * Deals damage to an entity over time.
+     */
+    public static final PotionEffectType POISON = new PotionEffectTypeWrapper(19);
+
+    /**
+     * Deals damage to an entity over time and gives the health to the
+     * shooter.
+     */
+    public static final PotionEffectType WITHER = new PotionEffectTypeWrapper(20);
+
+    /**
+     * Increases the maximum health of an entity.
+     */
+    public static final PotionEffectType HEALTH_BOOST = new PotionEffectTypeWrapper(21);
+
+    /**
+     * Increases the maximum health of an entity with health that cannot be
+     * regenerated, but is refilled every 30 seconds.
+     */
+    public static final PotionEffectType ABSORPTION = new PotionEffectTypeWrapper(22);
+
+    /**
+     * Increases the food level of an entity each tick.
+     */
+    public static final PotionEffectType SATURATION = new PotionEffectTypeWrapper(23);
+
+    /**
+     * Outlines the entity so that it can be seen from afar.
+     */
+    public static final PotionEffectType GLOWING = new PotionEffectTypeWrapper(24);
+
+    /**
+     * Causes the entity to float into the air.
+     */
+    public static final PotionEffectType LEVITATION = new PotionEffectTypeWrapper(25);
+
+    /**
+     * Loot table luck.
+     */
+    public static final PotionEffectType LUCK = new PotionEffectTypeWrapper(26);
+
+    /**
+     * Loot table unluck.
+     */
+    public static final PotionEffectType UNLUCK = new PotionEffectTypeWrapper(27);
+
+    private final int id;
+
+    protected PotionEffectType(int id) {
+        this.id = id;
+    }
+
+    /**
+     * Creates a PotionEffect from this PotionEffectType, applying duration
+     * modifiers and checks.
+     *
+     * @see PotionBrewer#createEffect(PotionEffectType, int, int)
+     * @param duration time in ticks
+     * @param amplifier the effect's amplifier
+     * @return a resulting potion effect
+     */
+    public PotionEffect createEffect(int duration, int amplifier) {
+        return new PotionEffect(this, isInstant() ? 1 : (int) (duration * getDurationModifier()), amplifier);
+    }
+
+    /**
+     * Returns the duration modifier applied to effects of this type.
+     *
+     * @return duration modifier
+     */
+    public abstract double getDurationModifier();
+
+    /**
+     * Returns the unique ID of this type.
+     *
+     * @return Unique ID
+     * @deprecated Magic value
+     */
+    @Deprecated
+    public int getId() {
+        return id;
+    }
+
+    /**
+     * Returns the name of this effect type.
+     *
+     * @return The name of this effect type
+     */
+    public abstract String getName();
+
+    /**
+     * Returns whether the effect of this type happens once, immediately.
+     *
+     * @return whether this type is normally instant
+     */
+    public abstract boolean isInstant();
+
+    @Override
+    public boolean equals(Object obj) {
+        if (obj == null) {
+            return false;
+        }
+        if (!(obj instanceof PotionEffectType)) {
+            return false;
+        }
+        final PotionEffectType other = (PotionEffectType) obj;
+        if (this.id != other.id) {
+            return false;
+        }
+        return true;
+    }
+
+    @Override
+    public int hashCode() {
+        return id;
+    }
+
+    @Override
+    public String toString() {
+        return "PotionEffectType[" + id + ", " + getName() + "]";
+    }
+
+    private static final PotionEffectType[] byId = new PotionEffectType[28];
+    private static final Map<String, PotionEffectType> byName = new HashMap<String, PotionEffectType>();
+    // will break on updates.
+    private static boolean acceptingNew = true;
+
+    /**
+     * Gets the effect type specified by the unique id.
+     *
+     * @param id Unique ID to fetch
+     * @return Resulting type, or null if not found.
+     * @deprecated Magic value
+     */
+    @Deprecated
+    public static PotionEffectType getById(int id) {
+        if (id >= byId.length || id < 0)
+            return null;
+        return byId[id];
+    }
+
+    /**
+     * Gets the effect type specified by the given name.
+     *
+     * @param name Name of PotionEffectType to fetch
+     * @return Resulting PotionEffectType, or null if not found.
+     */
+    public static PotionEffectType getByName(String name) {
+        Validate.notNull(name, "name cannot be null");
+        return byName.get(name.toLowerCase());
+    }
+
+    /**
+     * Registers an effect type with the given object.
+     * <p>
+     * Generally not to be used from within a plugin.
+     *
+     * @param type PotionType to register
+     */
+    public static void registerPotionEffectType(PotionEffectType type) {
+        if (byId[type.id] != null || byName.containsKey(type.getName().toLowerCase())) {
+            throw new IllegalArgumentException("Cannot set already-set type");
+        } else if (!acceptingNew) {
+            throw new IllegalStateException(
+                    "No longer accepting new potion effect types (can only be done by the server implementation)");
+        }
+
+        byId[type.id] = type;
+        byName.put(type.getName().toLowerCase(), type);
+    }
+
+    /**
+     * Stops accepting any effect type registrations.
+     */
+    public static void stopAcceptingRegistrations() {
+        acceptingNew = false;
+    }
+
+    /**
+     * Returns an array of all the registered {@link PotionEffectType}s.
+     * This array is not necessarily in any particular order and may contain null.
+     *
+     * @return Array of types.
+     */
+    public static PotionEffectType[] values() {
+        return byId.clone();
+    }
+}
diff --git a/src/main/java/org/bukkit/util/StringUtil.java b/src/main/java/org/bukkit/util/StringUtil.java
new file mode 100644
index 0000000..7ab84f5
--- /dev/null
+++ b/src/main/java/org/bukkit/util/StringUtil.java
@@ -0,0 +1,58 @@
+package org.bukkit.util;
+
+import java.util.Collection;
+import org.apache.commons.lang3.Validate;
+
+public class StringUtil {
+
+    /**
+     * Copies all elements from the iterable collection of originals to the
+     * collection provided.
+     *
+     * @param <T> the collection of strings
+     * @param token String to search for
+     * @param originals An iterable collection of strings to filter.
+     * @param collection The collection to add matches to
+     * @return the collection provided that would have the elements copied
+     *     into
+     * @throws UnsupportedOperationException if the collection is immutable
+     *     and originals contains a string which starts with the specified
+     *     search string.
+     * @throws IllegalArgumentException if any parameter is is null
+     * @throws IllegalArgumentException if originals contains a null element.
+     *     <b>Note: the collection may be modified before this is thrown</b>
+     */
+    public static <T extends Collection<? super String>> T copyPartialMatches(final String token, final Iterable<String> originals, final T collection) throws UnsupportedOperationException, IllegalArgumentException {
+        Validate.notNull(token, "Search token cannot be null");
+        Validate.notNull(collection, "Collection cannot be null");
+        Validate.notNull(originals, "Originals cannot be null");
+
+        for (String string : originals) {
+            if (startsWithIgnoreCase(string, token)) {
+                collection.add(string);
+            }
+        }
+
+        return collection;
+    }
+
+    /**
+     * This method uses a region to check case-insensitive equality. This
+     * means the internal array does not need to be copied like a
+     * toLowerCase() call would.
+     *
+     * @param string String to check
+     * @param prefix Prefix of string to compare
+     * @return true if provided string starts with, ignoring case, the prefix
+     *     provided
+     * @throws NullPointerException if prefix is null
+     * @throws IllegalArgumentException if string is null
+     */
+    public static boolean startsWithIgnoreCase(final String string, final String prefix) throws IllegalArgumentException, NullPointerException {
+        Validate.notNull(string, "Cannot check a null string for a match");
+        if (string.length() < prefix.length()) {
+            return false;
+        }
+        return string.regionMatches(true, 0, prefix, 0, prefix.length());
+    }
+}
-- 
2.8.2.windows.1

