From ba2561ab552df44601719e1646a73c47c2dc904e Mon Sep 17 00:00:00 2001
From: SotrForgotten <i@omc.hk>
Date: Sat, 6 Aug 2016 02:17:13 +0800
Subject: [PATCH] Concurrent linked hash map cache


diff --git a/pom.xml b/pom.xml
index 84f969a..5809176 100644
--- a/pom.xml
+++ b/pom.xml
@@ -91,6 +91,24 @@
             <artifactId>trove4j</artifactId>
             <version>3.0.3</version>
         </dependency>
+		 <dependency>
+            <groupId>com.google.guava</groupId>
+            <artifactId>guava</artifactId>
+            <version>19.0-rc3</version>
+        </dependency>
+        <dependency>
+            <groupId>org.projectlombok</groupId>
+            <artifactId>lombok</artifactId>
+            <version>1.16.8</version>
+            <scope>provided</scope>
+            <!-- They aren't required to use lombok -->
+            <optional>true</optional>
+        </dependency>
+        <dependency>
+            <groupId>com.google.code.findbugs</groupId>
+            <artifactId>jsr305</artifactId>
+            <version>3.0.1</version>
+        </dependency>
         <!-- testing -->
         <dependency>
             <groupId>junit</groupId>
diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java
index 4ccd05f..ee5d956 100644
--- a/src/main/java/net/minecraft/server/Chunk.java
+++ b/src/main/java/net/minecraft/server/Chunk.java
@@ -26,6 +26,8 @@ import org.hose.ChunkPopulate_Pool;
 import org.spigotmc.SpigotWorldConfig;
 import java.util.Queue;
 
+import net.techcable.pineapple.collect.CopyOnWriteMap;
+
 public class Chunk {
 
 	public final Lock blocksLock = new Lock(); // Paper - Async-Anti-Xray - Locks blocks and sections and is applied before a packet of this chunk or a neighbor-chunk is added to the obfuscation-executor-service on the main-thread until the obfuscator-thread is finished to ensure "single-thread-behavior" and thread-safety
@@ -103,7 +105,7 @@ public class Chunk {
         this.g = new byte[256];
         this.h = new int[256];
         this.i = new boolean[256];
-		this.tileEntities = Maps.newConcurrentMap();
+		this.tileEntities = new CopyOnWriteMap();
         this.x = 4096;
         this.y = Queues.newConcurrentLinkedQueue();
 		this.entitySlices = (CopyOnWriteArrayList[]) (new CopyOnWriteArrayList[16]); // Spigot
diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java
index b429fd8..956b397 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java
@@ -23,7 +23,6 @@ import org.bukkit.event.world.ChunkUnloadEvent;
 
 import com.google.common.collect.Maps;
 import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.RecursiveTask;
 
diff --git a/src/main/java/net/minecraft/server/DataWatcher.java b/src/main/java/net/minecraft/server/DataWatcher.java
index 56a7749..47a2b3d 100644
--- a/src/main/java/net/minecraft/server/DataWatcher.java
+++ b/src/main/java/net/minecraft/server/DataWatcher.java
@@ -24,7 +24,7 @@ import com.google.common.base.Optional;
 
 public class DataWatcher {
 
-    private static final Map<Class<? extends Entity>, Integer> a = Maps.newConcurrentMap();
+    private static final Map<Class<? extends Entity>, Integer> a = new net.techcable.pineapple.collect.CopyOnWriteMap();
     private final Entity b;
     private final Int2ObjectMap<Item<?>> c = TacoSpigotConfig.useArraysForDatawatcher ? new ArrayMap<>() : new Int2ObjectOpenHashMap<>(); // Paper // TacoSpigot - use 'Int2ObjectMap' and use 'ArrayMap' if useArraysForDatawatcher
     private final ReadWriteLock d = TacoSpigotConfig.disableDataWatcherReadLocking && TacoSpigotConfig.useArraysForDatawatcher ? NoOpReadWriteLock.INSTANCE : new ReentrantReadWriteLock(); // TacoSpigot - don't lock if we're using ArrayMap
diff --git a/src/main/java/net/minecraft/server/Explosion.java b/src/main/java/net/minecraft/server/Explosion.java
index 143fcdb..58aeec5 100644
--- a/src/main/java/net/minecraft/server/Explosion.java
+++ b/src/main/java/net/minecraft/server/Explosion.java
@@ -34,7 +34,7 @@ public class Explosion {
     public final Entity source;
     private final float size;
     private final List<BlockPosition> blocks = new CopyOnWriteArrayList<BlockPosition>(); // Torch
-    private final ConcurrentHashMap<EntityHuman, Vec3D> k = new ConcurrentHashMap<EntityHuman, Vec3D>(); // Hose
+    private final net.techcable.pineapple.collect.CopyOnWriteMap<EntityHuman, Vec3D> k = new net.techcable.pineapple.collect.CopyOnWriteMap<EntityHuman, Vec3D>(); // Hose
     public boolean wasCanceled = false; // CraftBukkit - add field
 
     public Explosion(World world, Entity entity, double d0, double d1, double d2, float f, boolean flag, boolean flag1) {
diff --git a/src/main/java/net/minecraft/server/HandshakeListener.java b/src/main/java/net/minecraft/server/HandshakeListener.java
index a6712dc..d0c515d 100644
--- a/src/main/java/net/minecraft/server/HandshakeListener.java
+++ b/src/main/java/net/minecraft/server/HandshakeListener.java
@@ -9,7 +9,7 @@ public class HandshakeListener implements PacketHandshakingInListener {
 
     private static final com.google.gson.Gson gson = new com.google.gson.Gson(); // Spigot // Torch - Use FastJson but keeping legacy name
     // CraftBukkit start - add fields
-    private static final ConcurrentHashMap<InetAddress, Long> throttleTracker = new ConcurrentHashMap<InetAddress, Long>();
+    private static final net.techcable.pineapple.collect.CopyOnWriteMap<InetAddress, Long> throttleTracker = new net.techcable.pineapple.collect.CopyOnWriteMap<InetAddress, Long>();
     private static int throttleCounter = 0;
     // CraftBukkit end
 
diff --git a/src/main/java/net/minecraft/server/PersistentCollection.java b/src/main/java/net/minecraft/server/PersistentCollection.java
index fc9fde7..ff7d0e5 100644
--- a/src/main/java/net/minecraft/server/PersistentCollection.java
+++ b/src/main/java/net/minecraft/server/PersistentCollection.java
@@ -18,6 +18,7 @@ import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 import javax.annotation.Nullable;
 
+
 public class PersistentCollection {
 
     private IDataManager b;
diff --git a/src/main/java/net/minecraft/server/PlayerList.java b/src/main/java/net/minecraft/server/PlayerList.java
index 4c1bd59..9843ad1 100644
--- a/src/main/java/net/minecraft/server/PlayerList.java
+++ b/src/main/java/net/minecraft/server/PlayerList.java
@@ -83,7 +83,7 @@ public abstract class PlayerList {
         this.operators = new OpList(PlayerList.c);
         this.whitelist = new WhiteList(PlayerList.d);
         // this.o = Maps.newHashMap();
-		this.o = new ConcurrentHashMap();
+		this.o = new net.techcable.pineapple.collect.CopyOnWriteMap();
         this.server = minecraftserver;
         this.k.a(false);
         this.l.a(false);
diff --git a/src/main/java/net/minecraft/server/RegionFile.java b/src/main/java/net/minecraft/server/RegionFile.java
index 9fe8e9c..bf5f952 100644
--- a/src/main/java/net/minecraft/server/RegionFile.java
+++ b/src/main/java/net/minecraft/server/RegionFile.java
@@ -292,7 +292,7 @@ public class RegionFile {
 
             this.b(i, j, (int) (MinecraftServer.av() / 1000L));
         } catch (IOException ioexception) {
-            org.spigotmc.SneakyThrow.sneaky(ioexception); // Paper - we want the upper try/catch to retry this
+            net.techcable.pineapple.SneakyThrow.sneakyThrow(ioexception); // Paper - we want the upper try/catch to retry this // Torch
         }
 
     }
diff --git a/src/main/java/net/minecraft/server/StatisticManager.java b/src/main/java/net/minecraft/server/StatisticManager.java
index 5d6c3de..7b536ca 100644
--- a/src/main/java/net/minecraft/server/StatisticManager.java
+++ b/src/main/java/net/minecraft/server/StatisticManager.java
@@ -2,10 +2,11 @@ package net.minecraft.server;
 
 import com.google.common.collect.Maps;
 import java.util.Map;
+import net.techcable.pineapple.collect.CopyOnWriteMap;
 
 public class StatisticManager {
 
-    protected final Map<Statistic, StatisticWrapper> a = Maps.newConcurrentMap();
+    protected final Map<Statistic, StatisticWrapper> a = new CopyOnWriteMap();
 
     public StatisticManager() {}
 
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index 0a3e6e4..2e5c6b5 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -21,7 +21,6 @@ import com.google.common.collect.Sets;
 
 import com.destroystokyo.paper.IOStatCommand;
 import com.destroystokyo.paper.PaperConfig;
-import java.util.concurrent.ConcurrentHashMap;
 
 // CraftBukkit start
 import com.google.common.collect.Maps;
@@ -94,7 +93,7 @@ public abstract class World implements IBlockAccess {
     private final Set<TileEntity> tileEntityListUnload = Sets.newConcurrentHashSet(); // Paper
     public final List<EntityHuman> players = new CopyOnWriteArrayList<EntityHuman>();
     public final Queue<Entity> j = Queues.newConcurrentLinkedQueue();
-    protected final Map<Integer, Entity> entitiesById = new ConcurrentHashMap();
+    protected final Map<Integer, Entity> entitiesById = new net.techcable.pineapple.collect.CopyOnWriteMap();
     private long I = 16777215L;
     private int J;
     protected int l = (new Random()).nextInt();
@@ -165,7 +164,7 @@ public abstract class World implements IBlockAccess {
     private org.spigotmc.TickLimiter entityLimiter;
     private org.spigotmc.TickLimiter tileLimiter;
     private int tileTickPosition;
-    public final Map<Explosion.CacheKey, Float> explosionDensityCache = new ConcurrentHashMap<>(); // Paper - Optimize explosions
+    public final Map<Explosion.CacheKey, Float> explosionDensityCache = new net.techcable.pineapple.collect.CopyOnWriteMap<>(); // Paper - Optimize explosions
 	
 	// Paper - Start Peristence counters.
     private long nextPersistenceCountersTick = System.nanoTime();
diff --git a/src/main/java/net/minecraft/server/WorldMap.java b/src/main/java/net/minecraft/server/WorldMap.java
index 200d1c3..79ace38 100644
--- a/src/main/java/net/minecraft/server/WorldMap.java
+++ b/src/main/java/net/minecraft/server/WorldMap.java
@@ -17,6 +17,7 @@ import org.bukkit.craftbukkit.map.CraftMapView;
 // CraftBukkit end
 
 import java.util.concurrent.ConcurrentHashMap;
+import com.googlecode.concurrentlinkedhashmap.ConcurrentLinkedHashMap; // Torch
 
 public class WorldMap extends PersistentBase {
 
@@ -28,8 +29,9 @@ public class WorldMap extends PersistentBase {
     public byte[] colors = new byte[16384];
     public List<WorldMap.WorldMapHumanTracker> h = Lists.newArrayList();
     // public Map<EntityHuman, WorldMap.WorldMapHumanTracker> j = Maps.newHashMap(); // Spigot
-	public final Map<EntityHuman, WorldMap.WorldMapHumanTracker> j = new ConcurrentHashMap();
-    public Map<UUID, MapIcon> decorations = Maps.newLinkedHashMap(); // Spigot
+	public final Map<EntityHuman, WorldMap.WorldMapHumanTracker> j = new net.techcable.pineapple.collect.CopyOnWriteMap();
+    // public Map<UUID, MapIcon> decorations = Maps.newLinkedHashMap(); // Spigot
+	public ConcurrentLinkedHashMap<UUID, MapIcon> decorations = new ConcurrentLinkedHashMap.Builder<UUID, MapIcon>().maximumWeightedCapacity(128).build();
     private org.bukkit.craftbukkit.map.RenderData vanillaRender = new org.bukkit.craftbukkit.map.RenderData(); // Paper
 
     // CraftBukkit start
diff --git a/src/main/java/net/techcable/pineapple/SneakyThrow.java b/src/main/java/net/techcable/pineapple/SneakyThrow.java
new file mode 100644
index 0000000..2aeaedc
--- /dev/null
+++ b/src/main/java/net/techcable/pineapple/SneakyThrow.java
@@ -0,0 +1,34 @@
+/**
+ * The MIT License
+ * Copyright (c) 2016 Techcable
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package net.techcable.pineapple;
+
+public class SneakyThrow {
+    public static AssertionError sneakyThrow(Throwable t) {
+        return sneakyThrow0(t);
+    }
+
+    @SuppressWarnings("unchecked")
+    private static <T extends Throwable> AssertionError sneakyThrow0(Throwable t) throws T {
+        throw (T) t;
+    }
+}
diff --git a/src/main/java/net/techcable/pineapple/collect/CopyOnWriteMap.java b/src/main/java/net/techcable/pineapple/collect/CopyOnWriteMap.java
new file mode 100644
index 0000000..03ce049
--- /dev/null
+++ b/src/main/java/net/techcable/pineapple/collect/CopyOnWriteMap.java
@@ -0,0 +1,279 @@
+/**
+ * The MIT License
+ * Copyright (c) 2016 Techcable
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package net.techcable.pineapple.collect;
+
+import java.util.AbstractMap;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
+import java.util.function.BiConsumer;
+import java.util.function.BiFunction;
+import java.util.function.Function;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+import javax.annotation.ParametersAreNonnullByDefault;
+
+import com.google.common.collect.ImmutableCollection;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
+
+import static com.google.common.base.Preconditions.*;
+
+@ParametersAreNonnullByDefault
+public class CopyOnWriteMap<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V> {
+    @SuppressWarnings("AtomicFieldUpdaterIssues") // Generic.......
+    private static final AtomicReferenceFieldUpdater<CopyOnWriteMap, ImmutableMap> MAP_UPDATER = AtomicReferenceFieldUpdater.newUpdater(CopyOnWriteMap.class, ImmutableMap.class, "bakedMap");
+    private final Map<K, V> map = Collections.synchronizedMap(new HashMap<K, V>());
+    @Nullable
+    private volatile ImmutableMap<K, V> bakedMap = null;
+
+    @Nonnull
+    private ImmutableMap<K, V> bakedMap() {
+        ImmutableMap<K, V> bakedMap = this.bakedMap;
+        if (bakedMap == null) {
+            return bakeMap();
+        } else {
+            return bakedMap;
+        }
+    }
+
+    private ImmutableMap<K, V> bakeMap() {
+        synchronized (map) {
+            return this.bakedMap = ImmutableMap.copyOf(map);
+        }
+    }
+
+    @Override
+    public int size() {
+        return bakedMap().size();
+    }
+
+    @Override
+    public boolean containsKey(Object key) {
+        return bakedMap().containsKey(key);
+    }
+
+    @Override
+    public boolean containsValue(Object value) {
+        return bakedMap().containsValue(value);
+    }
+
+    @Override
+    @Nullable
+    public V get(Object key) {
+        return bakedMap().get(key);
+    }
+
+    @Override
+    @Nullable
+    public V put(K key, V value) {
+        checkNotNull(key, "Null key");
+        checkNotNull(value, "Null value");
+        synchronized (map) {
+            bakedMap = null;
+            return map.put(key, value);
+        }
+    }
+
+    @Override
+    @Nullable
+    public V remove(Object key) {
+        checkNotNull(key, "Null key");
+        synchronized (map) {
+            bakedMap = null;
+            return map.remove(key);
+        }
+    }
+
+    @Override
+    public void putAll(Map<? extends K, ? extends V> m) {
+        checkNotNull(m, "Null bakedMap");
+        synchronized (map) {
+            bakedMap = null;
+            map.putAll(m);
+        }
+    }
+
+    @Override
+    public void clear() {
+        synchronized (map) {
+            bakedMap = ImmutableMap.of();
+        }
+    }
+
+    @Override
+    @Nonnull
+    public ImmutableSet<K> keySet() {
+        return bakedMap().keySet();
+    }
+
+    @Override
+    @Nonnull
+    public ImmutableCollection<V> values() {
+        return bakedMap().values();
+    }
+
+    @Override
+    @Nonnull
+    public ImmutableSet<Entry<K, V>> entrySet() {
+        return bakedMap().entrySet();
+    }
+
+    @Override
+    @Nullable
+    public V getOrDefault(Object key, V defaultValue) {
+        return bakedMap().getOrDefault(checkNotNull(key, "Null key"), defaultValue);
+    }
+
+    @Override
+    public void forEach(BiConsumer<? super K, ? super V> action) {
+        checkNotNull(action, "Null action");
+        ImmutableMaps.forEach(bakedMap(), action);
+    }
+
+    @Override
+    public V putIfAbsent(K key, V value) {
+        checkNotNull(key, "Null key");
+        checkNotNull(value, "Null value");
+        Map<K, V> bakedMap = this.bakedMap;
+        V oldValue;
+        if (bakedMap == null || (oldValue = bakedMap.get(key)) == null) {
+            return putIfAbsent0(key, value);
+        } else {
+            return oldValue;
+        }
+    }
+
+    private V putIfAbsent0(K key, V value) {
+        synchronized (map) {
+            bakedMap = null;
+            return map.putIfAbsent(key, value);
+        }
+    }
+
+    @Override
+    public boolean remove(Object key, Object value) {
+        checkNotNull(key, "Null key");
+        checkNotNull(value, "Null value");
+        synchronized (map) {
+            bakedMap = null;
+            return map.remove(key, value);
+        }
+    }
+
+    @Override
+    public boolean replace(K key, V oldValue, V newValue) {
+        checkNotNull(key, "Null key");
+        checkNotNull(oldValue, "Null old value");
+        checkNotNull(newValue, "Null new value");
+        synchronized (map) {
+            bakedMap = null;
+            return map.replace(key, oldValue, newValue);
+        }
+    }
+
+    @Override
+    @Nullable
+    public V replace(K key, V value) {
+        checkNotNull(key, "Null key");
+        checkNotNull(value, "Null value");
+        synchronized (map) {
+            bakedMap = null;
+            return map.replace(key, value);
+        }
+    }
+
+    @Override
+    public void replaceAll(BiFunction<? super K, ? super V, ? extends V> function) {
+        checkNotNull(function, "Null function");
+        synchronized (map) {
+            bakedMap = null;
+            map.replaceAll(function);
+        }
+    }
+
+    @Override
+    @Nonnull
+    public V computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction) {
+        checkNotNull(key, "Null key");
+        checkNotNull(mappingFunction, "Null function");
+        Map<K, V> bakedMap = this.bakedMap;
+        V value;
+        if (bakedMap == null || (value = bakedMap.get(key)) == null) {
+            return computeIfAbsent0(key, mappingFunction);
+        } else {
+            return value;
+        }
+    }
+
+    @Nonnull
+    private V computeIfAbsent0(K key, Function<? super K, ? extends V> mappingFunction) {
+        synchronized (map) {
+            this.bakedMap = null;
+            V value = map.get(key);
+            if (value == null) {
+                value = mappingFunction.apply(key);
+                if (value == null) throw new IllegalArgumentException("Mapping function " + mappingFunction.getClass().getTypeName() + " returned null value for key " + key);
+            }
+            return value;
+        }
+    }
+
+    @Override
+    @Nullable
+    public V computeIfPresent(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction) {
+        checkNotNull(remappingFunction, "Null remapping function");
+        Map<K, V> bakedMap = this.bakedMap;
+        if (bakedMap == null || bakedMap.get(key) != null) {
+            synchronized (map) {
+                this.bakedMap = null;
+                return map.computeIfPresent(key, remappingFunction);
+            }
+        } else {
+            return null;
+        }
+    }
+
+    @Override
+    public V compute(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction) {
+        checkNotNull(key, "Null key");
+        checkNotNull(remappingFunction, "Null remapping function");
+        synchronized (map) {
+            bakedMap = null;
+            return map.compute(key, remappingFunction);
+        }
+    }
+
+    @Override
+    public V merge(K key, V value, BiFunction<? super V, ? super V, ? extends V> remappingFunction) {
+        checkNotNull(key, "Null key");
+        checkNotNull(value, "Null value");
+        checkNotNull(remappingFunction, "Null remapping function");
+        synchronized (map) {
+            bakedMap = null;
+            return map.merge(key, value, remappingFunction);
+        }
+    }
+}
diff --git a/src/main/java/net/techcable/pineapple/collect/ImmutableLists.java b/src/main/java/net/techcable/pineapple/collect/ImmutableLists.java
new file mode 100644
index 0000000..7aa7ec3
--- /dev/null
+++ b/src/main/java/net/techcable/pineapple/collect/ImmutableLists.java
@@ -0,0 +1,79 @@
+/**
+ * The MIT License
+ * Copyright (c) 2016 Techcable
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package net.techcable.pineapple.collect;
+
+import lombok.*;
+
+import java.lang.invoke.MethodHandle;
+import java.util.List;
+import java.util.function.Function;
+import javax.annotation.Nonnull;
+import javax.annotation.ParametersAreNonnullByDefault;
+
+import com.google.common.base.Preconditions;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
+
+import net.techcable.pineapple.reflection.Reflection;
+
+import static com.google.common.base.Preconditions.*;
+
+@ParametersAreNonnullByDefault
+public class ImmutableLists {
+    @Nonnull
+    public static <T, U> ImmutableList<U> transform(List<T> list, Function<T, U> transformer) {
+        ImmutableList.Builder<U> resultBuilder = builder(checkNotNull(list, "Null list").size());
+        list.forEach((oldElement) -> {
+            U newElement = checkNotNull(transformer, "Null transformer").apply(oldElement);
+            if (newElement == null) throw new NullPointerException("Transformer  " + transformer.getClass().getTypeName() + " returned null.");
+            resultBuilder.add(newElement);
+        });
+        return resultBuilder.build();
+    }
+
+    @Nonnull
+    public static <T, U> ImmutableList<U> transform(ImmutableList<T> list, Function<T, U> transformer) {
+        ImmutableList.Builder<U> resultBuilder = builder(checkNotNull(list, "Null list").size());
+        for (int i = 0; i < list.size(); i++) {
+            T oldElement = list.get(i);
+            U newElement = checkNotNull(transformer, "Null transformer").apply(oldElement);
+            if (newElement == null) throw new NullPointerException("Transformer  " + transformer.getClass().getTypeName() + " returned null.");
+            resultBuilder.add(newElement);
+        }
+        return resultBuilder.build();
+    }
+
+    //
+    // Reflection and dark magic
+    //
+
+    private static final MethodHandle BUILDER_CONSTRUCTOR = Reflection.getConstructor(ImmutableList.Builder.class, int.class);
+
+    @SneakyThrows
+    @SuppressWarnings("unchecked")
+    @Nonnull
+    public static <T> ImmutableList.Builder<T> builder(int size) {
+        checkArgument(size >= 0, "Negative size %s", size);
+        return BUILDER_CONSTRUCTOR != null ? (ImmutableList.Builder<T>) BUILDER_CONSTRUCTOR.invokeExact(size) : ImmutableList.builder();
+    }
+}
diff --git a/src/main/java/net/techcable/pineapple/collect/ImmutableMaps.java b/src/main/java/net/techcable/pineapple/collect/ImmutableMaps.java
new file mode 100644
index 0000000..fd0d998
--- /dev/null
+++ b/src/main/java/net/techcable/pineapple/collect/ImmutableMaps.java
@@ -0,0 +1,95 @@
+/**
+ * The MIT License
+ * Copyright (c) 2016 Techcable
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package net.techcable.pineapple.collect;
+
+import lombok.*;
+import lombok.experimental.*;
+
+import java.lang.invoke.MethodHandle;
+import java.util.Map;
+import java.util.function.BiConsumer;
+import java.util.function.Function;
+import javax.annotation.Nonnull;
+import javax.annotation.ParametersAreNonnullByDefault;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
+
+import net.techcable.pineapple.reflection.FastField;
+import net.techcable.pineapple.reflection.Reflection;
+
+import static com.google.common.base.Preconditions.*;
+
+@ParametersAreNonnullByDefault
+public class ImmutableMaps {
+
+    public static <K1, K2, V> ImmutableMap<K2, V> transformKeys(ImmutableMap<K1, V> original, Function<K1, K2> keyTransformer) {
+        return transform(original, keyTransformer, Function.identity());
+    }
+
+    @Nonnull
+    public static <K1, K2, V1, V2> ImmutableMap<K2, V2> transform(ImmutableMap<K1, V1> original, Function<K1, K2> keyTransformer, Function<V1, V2> valueTransformer) {
+        ImmutableMap.Builder<K2, V2> resultBuilder = builder(checkNotNull(original, "Null map").size());
+        forEach(original, (originalKey, originalValue) -> {
+            K2 newKey = checkNotNull(keyTransformer, "Null key transformer").apply(originalKey);
+            V2 newValue = checkNotNull(valueTransformer, "Null value transformer").apply(originalValue);
+            resultBuilder.put(newKey, newValue);
+        });
+        return resultBuilder.build();
+    }
+
+    //
+    // Dark Magic
+    //
+
+    private static final Class<? extends ImmutableMap> REGULAR_IMMUTABLE_MAP_CLASS = Reflection.getClass("com.google.common.collect.RegularImmutableMap", ImmutableMap.class);
+    private static final MethodHandle BUILDER_CONSTRUCTOR = Reflection.getConstructor(ImmutableMap.Builder.class, int.class);
+    @SuppressWarnings("unchecked")
+    private static final FastField<ImmutableMap, Map.Entry[]> ENTRIES_ARRAY_FIELD = REGULAR_IMMUTABLE_MAP_CLASS != null ? FastField.create("entries", (Class<ImmutableMap>) REGULAR_IMMUTABLE_MAP_CLASS, Map.Entry[].class) : null;
+
+    @SneakyThrows
+    @SuppressWarnings("unchecked") // Generics are a lie
+    @Nonnull
+    public static <K, V> ImmutableMap.Builder<K, V> builder(int initialCapacity) {
+        checkArgument(initialCapacity >= 0, "Negative initial capacity %s");
+        return BUILDER_CONSTRUCTOR != null ? (ImmutableMap.Builder<K, V>) BUILDER_CONSTRUCTOR.invokeExact(initialCapacity) : ImmutableMap.builder();
+    }
+
+    @SuppressWarnings("unchecked")
+    public static <K, V> void forEach(ImmutableMap<K, V> map, BiConsumer<? super K, ? super V> action) {
+        checkNotNull(map, "Null map");
+        if (ENTRIES_ARRAY_FIELD != null && ENTRIES_ARRAY_FIELD.getDeclaringType().isInstance(map)) {
+            for (Map.Entry<K, V> entry : ENTRIES_ARRAY_FIELD.get(map)) {
+                K key = entry.getKey();
+                V value = entry.getValue();
+                checkNotNull(action, "Null action").accept(key, value);
+            }
+        } else {
+            ImmutableList<Map.Entry<K, V>> entryList = map.entrySet().asList(); // Since they don't support forEach this is the fastest way to iterate
+            for (int i = 0; i < entryList.size(); i++) {
+                Map.Entry<K, V> entry = entryList.get(i);
+                action.accept(entry.getKey(), entry.getValue());
+            }
+        }
+    }
+}
diff --git a/src/main/java/net/techcable/pineapple/reflection/FastField.java b/src/main/java/net/techcable/pineapple/reflection/FastField.java
new file mode 100644
index 0000000..f5648d4
--- /dev/null
+++ b/src/main/java/net/techcable/pineapple/reflection/FastField.java
@@ -0,0 +1,111 @@
+/**
+ * The MIT License
+ * Copyright (c) 2016 Techcable
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package net.techcable.pineapple.reflection;
+
+import lombok.*;
+import sun.misc.Unsafe;
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Modifier;
+
+import com.google.common.base.Verify;
+import com.google.common.primitives.Primitives;
+
+import static com.google.common.base.Preconditions.*;
+
+@Getter
+public class FastField<T, V> {
+    private final Field field;
+    private final Class<T> declaringType;
+    private final Class<V> fieldType;
+
+    private FastField(Field field, Class<T> declaringType, Class<V> fieldType) {
+        this.field = checkNotNull(field, "Null field");
+        this.declaringType = checkNotNull(declaringType, "Null declaring type");
+        this.fieldType = checkNotNull(fieldType, "Null field type");
+        field.setAccessible(true);
+        checkArgument(fieldType.isAssignableFrom(Primitives.wrap(field.getType())));
+        checkArgument(declaringType == field.getDeclaringClass());
+    }
+
+    private static final Unsafe UNSAFE;
+    static {
+        Unsafe u;
+        try {
+            Class.forName("sun.misc.Unsafe");
+            Field field = Unsafe.class.getDeclaredField("theUnsafe");
+            field.setAccessible(true);
+            u = (Unsafe) field.get(null);
+        } catch (ClassNotFoundException | NoSuchFieldException | SecurityException | IllegalAccessException e) {
+            u = null;
+        }
+        UNSAFE = u;
+    }
+
+    public static <T> FastField<T, ?> create(String name, Class<T> declaringType) {
+        return create(name, declaringType, Object.class);
+    }
+
+    public static <T, V> FastField<T, V> create(String name, Class<T> declaringType, Class<V> fieldType) {
+        Field field;
+        try {
+            field = checkNotNull(declaringType, "Null declaring type").getDeclaredField(checkNotNull(name, "Null fieldName"));
+        } catch (NoSuchFieldException e) {
+            return null;
+        }
+        checkArgument(checkNotNull(fieldType, "Null field type").isAssignableFrom(Primitives.wrap(field.getType())), "Field type %s doesn't equal expected field type %s", fieldType);
+        if (!fieldType.isPrimitive() && UNSAFE != null) {
+            return new UnsafeFastField<>(field, declaringType, fieldType);
+        } else {
+            return new FastField<>(field, declaringType, fieldType);
+        }
+    }
+
+    @SuppressWarnings("unchecked") // The caller will check ;)
+    public V get(T instance) {
+        try {
+            return (V) field.get(instance);
+        } catch (IllegalAccessException e) {
+            throw new AssertionError("Field " + field + " should've been set accessible!");
+        }
+    }
+
+    public static class UnsafeFastField<T, V> extends FastField<T, V> {
+
+        private long fieldOffset;
+        private UnsafeFastField(Field field, Class<T> declaringType, Class<V> fieldType) {
+            super(field, declaringType, fieldType);
+            checkArgument(!field.getType().isPrimitive(), "Field is a primitive type %s", field.getType());
+            checkArgument(!Modifier.isStatic(field.getType().getModifiers()), "Static field %s", field);
+            fieldOffset = UNSAFE.objectFieldOffset(field);
+            Verify.verify(fieldOffset >= 0);
+        }
+
+        @Override
+        @SuppressWarnings("unchecked")
+        public V get(T instance) {
+            getDeclaringType().cast(checkNotNull(instance, "Null instance"));
+            return (V) UNSAFE.getObject(instance, fieldOffset);
+        }
+    }
+}
diff --git a/src/main/java/net/techcable/pineapple/reflection/Reflection.java b/src/main/java/net/techcable/pineapple/reflection/Reflection.java
new file mode 100644
index 0000000..b3eaa46
--- /dev/null
+++ b/src/main/java/net/techcable/pineapple/reflection/Reflection.java
@@ -0,0 +1,60 @@
+/**
+ * The MIT License
+ * Copyright (c) 2016 Techcable
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+package net.techcable.pineapple.reflection;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.reflect.Constructor;
+import javax.annotation.ParametersAreNonnullByDefault;
+
+import static com.google.common.base.Preconditions.*;
+
+@ParametersAreNonnullByDefault
+public class Reflection {
+    public static MethodHandle getConstructor(Class<?> declaringType, Class<?>... parameterTypes) {
+        try {
+            checkNotNull(parameterTypes, "Null parameters");
+            Constructor<?> constructor = checkNotNull(declaringType, "Null declaring type").getConstructor(parameterTypes);
+            constructor.setAccessible(true);
+            return MethodHandles.lookup().unreflectConstructor(constructor);
+        } catch (NoSuchMethodException e) {
+            return null;
+        } catch (IllegalAccessException e) {
+            throw new AssertionError(e);
+        }
+    }
+
+
+    public static <T> Class<? extends T> getClass(String name, Class<T> superclass) {
+        Class<?> raw = getClass(name);
+        return raw == null ? null : raw.asSubclass(checkNotNull(superclass, "Null superclass"));
+    }
+
+    public static Class<?> getClass(String name) {
+        try {
+            return Class.forName(checkNotNull(name, "Null name"));
+        } catch (ClassNotFoundException e) {
+            return null;
+        }
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/potion/CraftPotionBrewer.java b/src/main/java/org/bukkit/craftbukkit/potion/CraftPotionBrewer.java
index b7643bd..de318ab 100644
--- a/src/main/java/org/bukkit/craftbukkit/potion/CraftPotionBrewer.java
+++ b/src/main/java/org/bukkit/craftbukkit/potion/CraftPotionBrewer.java
@@ -18,10 +18,12 @@ import org.bukkit.potion.PotionEffect;
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Maps;
+import net.techcable.pineapple.collect.CopyOnWriteMap;
 
 public class CraftPotionBrewer implements PotionBrewer {
     // private static final Map<PotionType, Collection<PotionEffect>> cache = Maps.newHashMap();
-    private static final ConcurrentMap<PotionType, Collection<PotionEffect>> cache = new ConcurrentHashMap<PotionType, Collection<PotionEffect>>(); // Hose
+    // pivate static final ConcurrentMap<PotionType, Collection<PotionEffect>> cache = new ConcurrentHashMap<PotionType, Collection<PotionEffect>>(); // Hose
+	private static final CopyOnWriteMap<PotionType, Collection<PotionEffect>> cache = new CopyOnWriteMap<PotionType, Collection<PotionEffect>>(); // Torch
 
     public Collection<PotionEffect> getEffects(PotionType damage, boolean upgraded, boolean extended) {
         if (cache.containsKey(damage))
diff --git a/src/main/java/org/bukkit/craftbukkit/scheduler/CraftScheduler.java b/src/main/java/org/bukkit/craftbukkit/scheduler/CraftScheduler.java
index c679cac..6f0706b 100644
--- a/src/main/java/org/bukkit/craftbukkit/scheduler/CraftScheduler.java
+++ b/src/main/java/org/bukkit/craftbukkit/scheduler/CraftScheduler.java
@@ -73,7 +73,7 @@ public class CraftScheduler implements BukkitScheduler {
     /**
      * These are tasks that are currently active. It's provided for 'viewing' the current state.
      */
-    private final ConcurrentHashMap<Integer, CraftTask> runners = new ConcurrentHashMap<Integer, CraftTask>();
+    private final net.techcable.pineapple.collect.CopyOnWriteMap<Integer, CraftTask> runners = new net.techcable.pineapple.collect.CopyOnWriteMap<Integer, CraftTask>();
     private volatile int currentTick = -1;
     private final Executor executor = Executors.newCachedThreadPool(new com.google.common.util.concurrent.ThreadFactoryBuilder().setNameFormat("Craft Scheduler Thread - %1$d").build()); // Spigot
     private CraftAsyncDebugger debugHead = new CraftAsyncDebugger(-1, null, null) {@Override StringBuilder debugTo(StringBuilder string) {return string;}};
diff --git a/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java b/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java
index bbd0ade..0a321ef 100644
--- a/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java
+++ b/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java
@@ -47,7 +47,7 @@ import org.yaml.snakeyaml.error.YAMLException;
 public final class JavaPluginLoader implements PluginLoader {
     final Server server;
     private final Pattern[] fileFilters = new Pattern[] { Pattern.compile("\\.jar$"), };
-    private final Map<String, Class<?>> classes = new java.util.concurrent.ConcurrentHashMap<String, Class<?>>(); // Spigot
+    private final Map<String, Class<?>> classes = new net.techcable.pineapple.collect.CopyOnWriteMap<String, Class<?>>(); // Spigot
     private final Map<String, PluginClassLoader> loaders = new LinkedHashMap<String, PluginClassLoader>();
 
     /**
diff --git a/src/main/java/org/bukkit/plugin/java/PluginClassLoader.java b/src/main/java/org/bukkit/plugin/java/PluginClassLoader.java
index 9c7c5d7..dfb8800 100644
--- a/src/main/java/org/bukkit/plugin/java/PluginClassLoader.java
+++ b/src/main/java/org/bukkit/plugin/java/PluginClassLoader.java
@@ -18,7 +18,7 @@ import org.bukkit.plugin.PluginDescriptionFile;
 public final class PluginClassLoader extends URLClassLoader { // Spigot
     public JavaPlugin getPlugin() { return plugin; } // Spigot
     private final JavaPluginLoader loader;
-    private final Map<String, Class<?>> classes = new java.util.concurrent.ConcurrentHashMap<String, Class<?>>(); // Spigot
+    private final Map<String, Class<?>> classes = new net.techcable.pineapple.collect.CopyOnWriteMap<String, Class<?>>(); // Spigot
     private final PluginDescriptionFile description;
     private final File dataFolder;
     private final File file;
-- 
2.8.2.windows.1

