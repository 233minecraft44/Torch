From 09f9e8381b85f0763a76ad9756b276eafbc2bf97 Mon Sep 17 00:00:00 2001
From: SotrForgotten <i@omc.hk>
Date: Tue, 12 Jul 2016 19:23:28 +0800
Subject: [PATCH] Async Pathfinding


diff --git a/src/main/java/com/destroystokyo/paper/PaperConfig.java b/src/main/java/com/destroystokyo/paper/PaperConfig.java
index 3bc91a2..b4904ef 100644
--- a/src/main/java/com/destroystokyo/paper/PaperConfig.java
+++ b/src/main/java/com/destroystokyo/paper/PaperConfig.java
@@ -222,14 +222,14 @@ public class PaperConfig {
         regionFileCacheSize = getInt("settings.region-file-cache-size", 256);
     }
 	
-	public static boolean usePaperIO = false;
+	public static boolean usePaperIO = true;
     public static int paperIORegionFileCacheSize = 256;
     public static int paperIOAsyncChunkSaveQueueSize = -1;
     public static int paperIOAsyncChunkSaveQueueThreads = 2;
     public static boolean paperIODeleteCorruptChunks = true;
     public static boolean paperIOStats = true;
     private static void paperIO() {
-        usePaperIO = getBoolean("paper-io.enabled", false);
+        usePaperIO = getBoolean("paper-io.enabled", true);
         // Region file cache size (per world). 
         // TODO: Move to world settings.
         paperIORegionFileCacheSize = getInt("paper-io.region-file-cache-size", 256);
diff --git a/src/main/java/de/minetick/Migot.java b/src/main/java/de/minetick/Migot.java
index bfc5ff5..ddc3fe3 100644
--- a/src/main/java/de/minetick/Migot.java
+++ b/src/main/java/de/minetick/Migot.java
@@ -10,6 +10,8 @@ import java.util.concurrent.Executors;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.TimeUnit;
+import de.minetick.pathsearch.PathSearchJob;
+import de.minetick.pathsearch.PathSearchThrottlerThread;
 
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -41,6 +43,7 @@ public class Migot {
     private List<Integer> ticksPerSecond;
     private int ticksCounter = 0;
     private final Logger log = LogManager.getLogger();
+	private PathSearchThrottlerThread pathSearchThrottler;
 
     public Migot() {
         this.tickTimerObject = new TickTimer();
@@ -58,6 +61,7 @@ public class Migot {
             // Bukkit's logger is not yet initialized at this point and throws an NPE when trying to log an yaml load fail
             this.failedToLoadConfig = true;
         }
+		this.pathSearchThrottler = new PathSearchThrottlerThread(this.mainConfig.getPathSearchPoolSize());
     }
 
     public void init() {
@@ -78,6 +82,7 @@ public class Migot {
     public void shutdown() {
         this.timerService.shutdown();
 		this.nbtFileService.shutdown();
+		this.pathSearchThrottler.shutdown();
         while(!this.nbtFileService.isTerminated()) {
             try {
                 if(!this.nbtFileService.awaitTermination(3, TimeUnit.MINUTES)) {
@@ -173,4 +178,8 @@ public class Migot {
             return null;
         }
     }
+	
+	public static boolean queuePathSearch(PathSearchJob pathSearchJob) {
+        return instance.pathSearchThrottler.queuePathSearch(pathSearchJob);
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/de/minetick/MigotConfig.java b/src/main/java/de/minetick/MigotConfig.java
index ef2597a..1bbb22c 100644
--- a/src/main/java/de/minetick/MigotConfig.java
+++ b/src/main/java/de/minetick/MigotConfig.java
@@ -8,6 +8,13 @@ import java.io.InputStreamReader;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
+import java.util.HashSet;
+import java.util.List;
+import net.minecraft.server.EntityInsentient;
+import org.bukkit.entity.EntityType;
+import de.minetick.pathsearch.MigotNavigation;
+import de.minetick.pathsearch.PathSearchThrottlerThread;
+
 import org.bukkit.configuration.InvalidConfigurationException;
 import org.bukkit.configuration.file.FileConfiguration;
 import org.bukkit.configuration.file.YamlConfiguration;
@@ -19,6 +26,7 @@ public class MigotConfig {
     private final Logger logger = LogManager.getLogger();
     private File configFile;
     private FileConfiguration configuration;
+	private HashSet<EntityType> entitiesWithOffloadedPathSearches = new HashSet<EntityType>();
 
     public MigotConfig(File configFile) throws IOException, InvalidConfigurationException {
         this.configFile = configFile;
@@ -43,7 +51,9 @@ public class MigotConfig {
     }
 
     private void loadConfigContent() {
-
+		this.loadEntitiesWithOffloadedPathSearches(this.getEntitiesWithOffloadedPathSearches());
+        MigotNavigation.setMinimumDistanceForOffloading(this.getMinimumTargetDistanceForOffloading());
+        PathSearchThrottlerThread.adjustPoolSize(this.getPathSearchPoolSize());
     }
 
     private FileConfiguration loadConfig(File file) throws IOException, InvalidConfigurationException {
@@ -63,4 +73,37 @@ public class MigotConfig {
         }
         return config;
     }
+	
+	public List<String> getEntitiesWithOffloadedPathSearches() {
+        return configuration.getStringList("async-pathsearches.entities");
+    }
+
+    public double getMinimumTargetDistanceForOffloading() {
+        return configuration.getDouble("async-pathsearches.minimumDistanceToTarget", 0.0D);
+    }
+
+    private void loadEntitiesWithOffloadedPathSearches(List<String> entities) {
+        this.entitiesWithOffloadedPathSearches.clear();
+        for(String name: entities) {
+            try {
+                EntityType type = EntityType.valueOf(name.toUpperCase());
+                this.entitiesWithOffloadedPathSearches.add(type);
+            } catch (IllegalArgumentException e) {
+                logger.warn("[Migot] Settings: Skipping \"" + name + "\", as it is not a constant in org.bukkit.entity.EntityType!");
+            }
+        }
+    }
+
+    public boolean isPathSearchOffloadedFor(EntityInsentient entity) {
+        return this.getOffloadedPathSearchesEnabled() && this.entitiesWithOffloadedPathSearches.contains(entity.getBukkitEntity().getType());
+    }
+
+    public int getPathSearchPoolSize() {
+        int threadcount = configuration.getInt("async-pathsearches.threadPoolSize", 2);
+        return Math.max(1, Math.min(threadcount, 32));
+    }
+
+    public boolean getOffloadedPathSearchesEnabled() {
+        return configuration.getBoolean("async-pathsearches.enabled", true);
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/de/minetick/pathsearch/MigotNavigation.java b/src/main/java/de/minetick/pathsearch/MigotNavigation.java
new file mode 100644
index 0000000..c3b2257
--- /dev/null
+++ b/src/main/java/de/minetick/pathsearch/MigotNavigation.java
@@ -0,0 +1,222 @@
+package de.minetick.pathsearch;
+
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.UUID;
+import java.util.Map.Entry;
+
+import de.minetick.Migot;
+import de.minetick.pathsearch.cache.SearchCacheEntry;
+import de.minetick.pathsearch.cache.SearchCacheEntryEntity;
+import de.minetick.pathsearch.cache.SearchCacheEntryPosition;
+
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.Entity;
+import net.minecraft.server.EntityInsentient;
+import net.minecraft.server.MathHelper;
+import net.minecraft.server.Navigation;
+import net.minecraft.server.PathEntity;
+import net.minecraft.server.World;
+
+public class MigotNavigation extends Navigation {
+    
+    private HashMap<UUID, SearchCacheEntry> searchCache;
+    private HashMap<PositionPathSearchType, SearchCacheEntryPosition> positionSearchCache;
+    private static double minimumDistanceForOffloadingSquared = 0.0D;
+    private int cleanUpDelay = 0;
+    private Object jobLock = new Object();
+    private PathSearchJob lastQueuedJob;
+    
+    public MigotNavigation(EntityInsentient entityinsentient, World world) {
+        super(entityinsentient, world);
+        this.searchCache = new HashMap<UUID, SearchCacheEntry>();
+        this.positionSearchCache = new HashMap<PositionPathSearchType, SearchCacheEntryPosition>();
+    }
+
+    public static void setMinimumDistanceForOffloading(double distance) {
+        minimumDistanceForOffloadingSquared = distance * distance;
+    }
+
+    private boolean hasAsyncSearchIssued() {
+        synchronized(this.jobLock) {
+            return this.lastQueuedJob != null;
+        }
+    }
+
+    private void queueSearch(PathSearchJob job) {
+        synchronized(this.jobLock) {
+            PathSearchJob previous = this.lastQueuedJob;
+            if(Migot.queuePathSearch(job)) {
+                this.lastQueuedJob = job;
+            }
+        }
+    }
+
+    private void issueSearch(Entity target) {
+        this.queueSearch(new PathSearchJobEntity(this, target));
+    }
+
+    private void issueSearch(BlockPosition blockposition, PositionPathSearchType type) {
+        this.queueSearch(new PathSearchJobPosition(this, blockposition, type));
+    }
+
+    @Override
+    public void setSearchResult(PathSearchJobEntity pathSearch) {
+        synchronized (this.jobLock) {
+            if(this.lastQueuedJob == pathSearch) {
+                this.lastQueuedJob = null;
+            }
+        }
+        SearchCacheEntry entry = pathSearch.getCacheEntryValue();
+        if(entry != null && entry.didSearchSucceed()) {
+            synchronized(this.searchCache) {
+                UUID key = pathSearch.getCacheEntryKey();
+                this.searchCache.remove(key);
+                this.searchCache.put(key, entry);
+            }
+        }
+    }
+
+    @Override
+    public void setSearchResult(PathSearchJobPosition pathSearch) {
+        synchronized(this.jobLock) {
+            if(this.lastQueuedJob == pathSearch) {
+                this.lastQueuedJob = null;
+            }
+        }
+        SearchCacheEntryPosition entry = pathSearch.getCacheEntryValue();
+        if(entry != null && entry.didSearchSucceed()) {
+            synchronized(this.positionSearchCache) {
+                PositionPathSearchType key = pathSearch.getCacheEntryKey();
+                this.positionSearchCache.remove(key);
+                this.positionSearchCache.put(key, entry);
+            }
+        }
+    }
+
+    @Override
+    public PathEntity a(Entity entity) {
+        if(!this.offloadSearches() || this.a.h(entity) < minimumDistanceForOffloadingSquared) {
+            return super.a(entity);
+        }
+        if(!this.b()) {
+            return null;
+        }
+        SearchCacheEntry entry = null;
+        UUID id = entity.getUniqueID();
+        synchronized(this.searchCache) {
+            if(this.searchCache.containsKey(id)) {
+                entry = this.searchCache.get(id);
+            }
+        }
+        PathEntity resultPath = null;
+        if(entry != null) {
+            resultPath = entry.getAdjustedPathEntity();
+            if(!entry.isStillValid()) {
+                this.issueSearch(entity);
+            }
+        }
+        if(entry == null && !this.hasAsyncSearchIssued()) {
+            resultPath = super.a(entity);
+            if(resultPath != null) {
+                entry = new SearchCacheEntryEntity(this.a, entity, resultPath);
+                synchronized(this.searchCache) {
+                    SearchCacheEntry oldEntry = this.searchCache.put(id, entry);
+                    if(oldEntry != null) {
+                        oldEntry.cleanup();
+                    }
+                }
+            }
+        }
+        return resultPath;
+    }
+
+    @Override
+    public PathEntity a(BlockPosition blockposition) {
+        return this.a(blockposition, PositionPathSearchType.ANYOTHER);
+    }
+
+    public PathEntity a(BlockPosition blockposition, PositionPathSearchType type) {
+        if(!this.offloadSearches() || this.a.c(blockposition) < minimumDistanceForOffloadingSquared) {
+            return super.a(blockposition);
+        }
+        if(!this.b()) {
+            return null;
+        }
+
+        SearchCacheEntryPosition entry = null;
+        synchronized(this.positionSearchCache) {
+            if(this.positionSearchCache.containsKey(type)) {
+                entry = this.positionSearchCache.get(type);
+            }
+        }
+
+        PathEntity resultPath = null;
+        if(entry != null) {
+            resultPath = entry.getAdjustedPathEntity();
+            if(!entry.isStillValid()) {
+                this.issueSearch(blockposition, type);
+            }
+        }
+        if(entry == null && !this.hasAsyncSearchIssued()) {
+            resultPath = super.a(blockposition);
+            if(resultPath != null) {
+                entry = new SearchCacheEntryPosition(this.a, blockposition, resultPath);
+                synchronized(this.positionSearchCache) {
+                    SearchCacheEntry oldEntry = this.positionSearchCache.put(type, entry);
+                    if(oldEntry != null) {
+                        oldEntry.cleanup();
+                    }
+                }
+            }
+        }
+        return resultPath;
+    }
+
+    @Override
+    public PathEntity a(double d0, double d1, double d2, PositionPathSearchType type) {
+        return this.a(new BlockPosition(MathHelper.floor(d0), (int) d1, MathHelper.floor(d2)), type);
+    }
+
+    @Override
+    public boolean a(double d0, double d1, double d2, double d3, PositionPathSearchType type) {
+        PathEntity pathentity = this.a((double) MathHelper.floor(d0), (double) ((int) d1), (double) MathHelper.floor(d2), type);
+
+        return this.a(pathentity, d3);
+    }
+
+    public void cleanUpExpiredSearches() {
+        this.cleanUpDelay++;
+        if(this.cleanUpDelay > 100) {
+            this.cleanUpDelay = 0;
+            synchronized(this.searchCache) {
+                Iterator<Entry<UUID, SearchCacheEntry>> iterator = this.searchCache.entrySet().iterator();
+                while(iterator.hasNext()) {
+                    SearchCacheEntry entry = iterator.next().getValue();
+                    if(entry.hasExpired()) {
+                        iterator.remove();
+                        entry.cleanup();
+                    } else {
+                        break;
+                    }
+                }
+            }
+            synchronized(this.positionSearchCache) {
+                Iterator<Entry<PositionPathSearchType, SearchCacheEntryPosition>> iterator = this.positionSearchCache.entrySet().iterator();
+                while(iterator.hasNext()) {
+                    SearchCacheEntryPosition entry = iterator.next().getValue();
+                    if(entry.hasExpired()) {
+                        iterator.remove();
+                        entry.cleanup();
+                    } else {
+                        break;
+                    }
+                }
+            }
+        }
+    }
+
+    private boolean offloadSearches() {
+        return Migot.getConfig().isPathSearchOffloadedFor(this.a);
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/de/minetick/pathsearch/PathSearchJob.java b/src/main/java/de/minetick/pathsearch/PathSearchJob.java
new file mode 100644
index 0000000..bad5dff
--- /dev/null
+++ b/src/main/java/de/minetick/pathsearch/PathSearchJob.java
@@ -0,0 +1,52 @@
+package de.minetick.pathsearch;
+
+import java.util.concurrent.Callable;
+
+import net.minecraft.server.ChunkCache;
+import net.minecraft.server.EntityCreature;
+import net.minecraft.server.EntityInsentient;
+import net.minecraft.server.NavigationAbstract;
+import net.minecraft.server.PathEntity;
+
+public abstract class PathSearchJob implements Callable<PathSearchJob> {
+
+    public NavigationAbstract navigation;
+    protected ChunkCache chunkCache;
+    protected boolean issued;
+    private int hashCode;
+    protected PathEntity pathEntity;
+
+    public PathSearchJob(NavigationAbstract navigation) {
+        this.navigation = navigation;
+        this.hashCode = this.navigation.hashCode();
+        this.issued = false;
+        this.chunkCache = this.navigation.createChunkCache(this.isEntitySearch());
+    }
+
+    protected boolean isEntitySearch() {
+        return false;
+    }
+
+    public void cleanup() {
+        this.navigation = null;
+        this.chunkCache = null;
+        this.pathEntity = null;
+    }
+
+    @Override
+    public int hashCode() {
+        return this.hashCode;
+    }
+
+    public final int getSearchHash() {
+        return this.hashCode;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if(o == null || !(o instanceof PathSearchJob)) {
+            return false;
+        }
+        return this.hashCode() == ((PathSearchJob)o).hashCode();
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/de/minetick/pathsearch/PathSearchJobEntity.java b/src/main/java/de/minetick/pathsearch/PathSearchJobEntity.java
new file mode 100644
index 0000000..976c593
--- /dev/null
+++ b/src/main/java/de/minetick/pathsearch/PathSearchJobEntity.java
@@ -0,0 +1,56 @@
+package de.minetick.pathsearch;
+
+import java.util.UUID;
+
+import de.minetick.pathsearch.cache.SearchCacheEntry;
+import de.minetick.pathsearch.cache.SearchCacheEntryEntity;
+
+import net.minecraft.server.ChunkCache;
+import net.minecraft.server.Entity;
+import net.minecraft.server.EntityCreature;
+import net.minecraft.server.EntityInsentient;
+import net.minecraft.server.NavigationAbstract;
+import net.minecraft.server.PathEntity;
+
+public class PathSearchJobEntity extends PathSearchJob {
+
+    public Entity target;
+
+    public PathSearchJobEntity(NavigationAbstract navigation, Entity target) {
+        super(navigation);
+        this.target = target;
+    }
+
+    @Override
+    public PathSearchJob call() throws Exception {
+        if(!this.issued) {
+            this.issued = true;
+            this.pathEntity = this.navigation.doPathSearch(this.chunkCache, this.target);
+            this.navigation.setSearchResult(this);
+            this.cleanup();
+        }
+        return this;
+    }
+
+    @Override
+    protected boolean isEntitySearch() {
+        return true;
+    }
+    
+    @Override
+    public void cleanup() {
+        super.cleanup();
+        this.target = null;
+    }
+
+    public UUID getCacheEntryKey() {
+        return this.target.getUniqueID();
+    }
+
+    public SearchCacheEntry getCacheEntryValue() {
+        if(this.pathEntity != null) {
+            return new SearchCacheEntryEntity((EntityInsentient)this.navigation.getEntity(), (EntityInsentient)this.target, this.pathEntity);
+        }
+        return null;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/de/minetick/pathsearch/PathSearchJobPosition.java b/src/main/java/de/minetick/pathsearch/PathSearchJobPosition.java
new file mode 100644
index 0000000..d1ef2e2
--- /dev/null
+++ b/src/main/java/de/minetick/pathsearch/PathSearchJobPosition.java
@@ -0,0 +1,61 @@
+package de.minetick.pathsearch;
+
+import de.minetick.pathsearch.cache.SearchCacheEntryPosition;
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.EntityInsentient;
+import net.minecraft.server.NavigationAbstract;
+import net.minecraft.server.PathEntity;
+
+public class PathSearchJobPosition extends PathSearchJob {
+
+    private PositionPathSearchType type;
+    private BlockPosition blockposition;
+
+    public PathSearchJobPosition(NavigationAbstract navigation, BlockPosition blockposition, PositionPathSearchType type) {
+        super(navigation);
+        this.blockposition = blockposition;
+        this.type = type;
+    }
+
+    @Override
+    public PathSearchJob call() throws Exception {
+        if(!this.issued) {
+            this.issued = true;
+            this.pathEntity = this.navigation.doPathSearch(this.chunkCache, this.blockposition);
+            this.navigation.setSearchResult(this);
+            this.cleanup();
+        }
+        return this;
+    }
+
+    public PositionPathSearchType getCacheEntryKey() {
+        return this.type;
+    }
+
+    public SearchCacheEntryPosition getCacheEntryValue() {
+        if(this.pathEntity != null) {
+            return new SearchCacheEntryPosition((Entity)this.a, this.blockposition, this.pathEntity);
+        }
+        return null;
+    }
+
+    @Override
+    public int hashCode() {
+        return this.type.hashCode() ^ (super.hashCode() << 4);
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if(o == null || !(o instanceof PathSearchJobPosition)) {
+            return false;
+        }
+        PathSearchJobPosition other = (PathSearchJobPosition) o;
+        return this.type.equals(other.type) && this.hashCode() == other.hashCode();
+    }
+
+    @Override
+    public void cleanup() {
+        super.cleanup();
+        this.blockposition = null;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/de/minetick/pathsearch/PathSearchThrottlerThread.java b/src/main/java/de/minetick/pathsearch/PathSearchThrottlerThread.java
new file mode 100644
index 0000000..bc86ffb
--- /dev/null
+++ b/src/main/java/de/minetick/pathsearch/PathSearchThrottlerThread.java
@@ -0,0 +1,101 @@
+package de.minetick.pathsearch;
+
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.Map.Entry;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.FutureTask;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+
+import de.minetick.MigotThreadFactory;
+
+public class PathSearchThrottlerThread extends ThreadPoolExecutor {
+
+    private int queueLimit;
+    private LinkedHashMap<PathSearchJob, PathSearchJob> filter;
+    private HashSet<Integer> activeSearchHashes;
+    private static PathSearchThrottlerThread instance;
+
+    public PathSearchThrottlerThread(int poolSize) {
+        super(poolSize, poolSize, 1L, TimeUnit.MINUTES, new LinkedBlockingQueue<Runnable>(), new MigotThreadFactory(Thread.MIN_PRIORITY, "Migot_PathFinder"));
+        instance = this;
+        adjustPoolSize(poolSize);
+        this.filter = new LinkedHashMap<PathSearchJob, PathSearchJob>();
+        this.activeSearchHashes = new HashSet<Integer>();
+    }
+
+    public boolean queuePathSearch(PathSearchJob newJob) {
+        boolean jobHasBeenQueued = false;
+        if(newJob != null) {
+            synchronized(this.filter) {
+                if(this.filter.containsKey(newJob) || this.filter.size() < 1000) {
+                    jobHasBeenQueued = true;
+                    PathSearchJob previousJob = this.filter.put(newJob, newJob);
+                    if(previousJob != null) {
+                        previousJob.cleanup();
+                    }
+                }
+            }
+        }
+        PathSearchJob jobToExecute = null;
+        synchronized(this.filter) {
+            Iterator<Entry<PathSearchJob, PathSearchJob>> iter = this.filter.entrySet().iterator();
+            while(iter.hasNext() && this.getQueue().size() < this.queueLimit) {
+                jobToExecute = iter.next().getValue();
+                if(!this.activeSearchHashes.contains(jobToExecute.getSearchHash())) {
+                    iter.remove();
+                    if(jobToExecute != null) {
+                        this.activeSearchHashes.add(jobToExecute.getSearchHash());
+                        this.submit(jobToExecute);
+                    }
+                    if(newJob != null) {
+                        break;
+                    }
+                }
+            }
+        }
+        return jobHasBeenQueued;
+    }
+
+    @Override
+    public void shutdown() {
+        this.getQueue().clear();
+        super.shutdown();
+    }
+
+    @Override
+    protected void afterExecute(Runnable runnable, Throwable throwable) {
+        super.afterExecute(runnable, throwable);
+        if(runnable instanceof FutureTask) {
+            FutureTask<PathSearchJob> task = (FutureTask<PathSearchJob>) runnable;
+            PathSearchJob job = null;
+            try {
+                job = task.get();
+            } catch (InterruptedException e) {
+            } catch (ExecutionException e) {
+            }
+            if(job != null) {
+                synchronized(this.filter) {
+                    this.activeSearchHashes.remove(job.getSearchHash());
+                }
+            }
+        }
+        this.queuePathSearch(null);
+    }
+
+    public static void adjustPoolSize(int size) {
+        if(instance != null) {
+            if(size > instance.getMaximumPoolSize()) {
+                instance.setMaximumPoolSize(size);
+                instance.setCorePoolSize(size);
+            } else if(size < instance.getMaximumPoolSize()) {
+                instance.setCorePoolSize(size);
+                instance.setMaximumPoolSize(size);
+            }
+            instance.queueLimit = size * 8;
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/de/minetick/pathsearch/PositionPathSearchType.java b/src/main/java/de/minetick/pathsearch/PositionPathSearchType.java
new file mode 100644
index 0000000..a800268
--- /dev/null
+++ b/src/main/java/de/minetick/pathsearch/PositionPathSearchType.java
@@ -0,0 +1,16 @@
+package de.minetick.pathsearch;
+
+public enum PositionPathSearchType {
+    ANYOTHER,
+    AVOIDTARGET,
+    FLEESUN,
+    GOTOTARGET,
+    MOVEINDOORS,
+    MOVETHROUGHVILLAGE,
+    MOVETOWARDSRESTRICTION,
+    MOVETOWARDSTARGET,
+    PANIC,
+    PLAY,
+    RANDOMSTROLL,
+    TAME;
+}
\ No newline at end of file
diff --git a/src/main/java/de/minetick/pathsearch/cache/SearchCacheEntry.java b/src/main/java/de/minetick/pathsearch/cache/SearchCacheEntry.java
new file mode 100644
index 0000000..ffee901
--- /dev/null
+++ b/src/main/java/de/minetick/pathsearch/cache/SearchCacheEntry.java
@@ -0,0 +1,76 @@
+package de.minetick.pathsearch.cache;
+
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.Entity;
+import net.minecraft.server.EntityInsentient;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.PathEntity;
+import net.minecraft.server.PathPoint;
+
+public class SearchCacheEntry {
+    protected long tick;
+    protected BlockPosition positionStart;
+    protected BlockPosition positionTarget;
+    protected EntityInsentient entity;
+    private PathEntity path;
+
+    public SearchCacheEntry(EntityInsentient entity, PathEntity path) {
+        this.entity = entity;
+        this.positionStart = this.getBlockPosition(this.entity);
+        this.path = path;
+        this.tick = this.getCurrentTick();
+    }
+
+    protected int getCurrentTick() {
+        return MinecraftServer.currentTick;
+    }
+
+    protected BlockPosition getBlockPosition(Entity entity) {
+        return new BlockPosition(entity).up();
+    }
+
+    protected BlockPosition getBlockPosition(int x, int y, int z) {
+        return new BlockPosition(x, y, z);
+    }
+
+    public boolean isStillValid() {
+        return this.didSearchSucceed() && (this.getCurrentTick() - this.tick < 10);
+    }
+
+    public PathEntity getPathEntity() {
+        return this.path;
+    }
+
+    public boolean hasExpired() {
+        return !this.entity.isAlive() || !this.entity.valid  || (this.getCurrentTick() - this.tick) > 100;
+    }
+
+    public boolean didSearchSucceed() {
+        return this.path != null;
+    }
+
+    public PathEntity getAdjustedPathEntity() {
+        if(this.path != null && (this.path.e() < this.path.d() - 1)) {
+            PathPoint pathpoint = this.path.a(this.path.e());
+            double currentDist = this.entity.e(pathpoint.a, pathpoint.b, pathpoint.c);
+            while(this.path.e() < this.path.d() - 1) {
+                pathpoint = this.path.a(this.path.e() + 1);
+                double nextDist = this.entity.e(pathpoint.a, pathpoint.b, pathpoint.c);
+                if(nextDist < currentDist) {
+                    currentDist = nextDist;
+                    this.path.a();
+                } else {
+                    break;
+                }
+            }
+        }
+        return this.path;
+    }
+
+    public void cleanup() {
+        this.positionStart = null;
+        this.positionTarget = null;
+        this.entity = null;
+        this.path = null;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/de/minetick/pathsearch/cache/SearchCacheEntryEntity.java b/src/main/java/de/minetick/pathsearch/cache/SearchCacheEntryEntity.java
new file mode 100644
index 0000000..073e4fe
--- /dev/null
+++ b/src/main/java/de/minetick/pathsearch/cache/SearchCacheEntryEntity.java
@@ -0,0 +1,31 @@
+package de.minetick.pathsearch.cache;
+
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.Entity;
+import net.minecraft.server.EntityInsentient;
+import net.minecraft.server.PathEntity;
+
+public class SearchCacheEntryEntity extends SearchCacheEntry {
+
+    private Entity target;
+
+    public SearchCacheEntryEntity(EntityInsentient entity, Entity target, PathEntity path) {
+        super(entity, path);
+        this.target = target;
+        this.positionTarget = this.getBlockPosition(this.target);
+    }
+
+    @Override
+    public boolean isStillValid() {
+        if(super.isStillValid()) {
+            return this.getBlockPosition(this.target).equals(this.positionTarget);
+        }
+        return false;
+    }
+    
+    @Override
+    public void cleanup() {
+        super.cleanup();
+        this.target = null;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/de/minetick/pathsearch/cache/SearchCacheEntryPosition.java b/src/main/java/de/minetick/pathsearch/cache/SearchCacheEntryPosition.java
new file mode 100644
index 0000000..e1c0fba
--- /dev/null
+++ b/src/main/java/de/minetick/pathsearch/cache/SearchCacheEntryPosition.java
@@ -0,0 +1,21 @@
+package de.minetick.pathsearch.cache;
+
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.EntityInsentient;
+import net.minecraft.server.PathEntity;
+
+public class SearchCacheEntryPosition extends SearchCacheEntry {
+    
+    public SearchCacheEntryPosition(EntityInsentient entity, BlockPosition blockposition, PathEntity path) {
+        super(entity, path);
+        this.positionTarget = blockposition;
+    }
+
+    @Override
+    public boolean isStillValid() {
+        if(super.isStillValid()) {
+            return this.getBlockPosition(this.entity).equals(this.positionStart);
+        }
+        return false;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/net/minecraft/server/BlockDragonEgg.java b/src/main/java/net/minecraft/server/BlockDragonEgg.java
index 1c3a4be..1578988 100644
--- a/src/main/java/net/minecraft/server/BlockDragonEgg.java
+++ b/src/main/java/net/minecraft/server/BlockDragonEgg.java
@@ -33,7 +33,7 @@ public class BlockDragonEgg extends Block {
         if (BlockFalling.i(world.getType(blockposition.down())) && blockposition.getY() >= 0) {
             byte b0 = 32;
 
-            if (!world.instantBlockFall && world.areChunksLoadedBetween(blockposition.a(-b0, -b0, -b0), blockposition.a(b0, b0, b0))) { // Migot
+            if (!BlockFalling.instaFall && world.areChunksLoadedBetween(blockposition.a(-b0, -b0, -b0), blockposition.a(b0, b0, b0))) {
                 world.addEntity(new EntityFallingBlock(world, (double) ((float) blockposition.getX() + 0.5F), (double) blockposition.getY(), (double) ((float) blockposition.getZ() + 0.5F), this.getBlockData()));
             } else {
                 world.setAir(blockposition);
diff --git a/src/main/java/net/minecraft/server/BlockFalling.java b/src/main/java/net/minecraft/server/BlockFalling.java
index 2610aea..8df2976 100644
--- a/src/main/java/net/minecraft/server/BlockFalling.java
+++ b/src/main/java/net/minecraft/server/BlockFalling.java
@@ -4,7 +4,7 @@ import java.util.Random;
 
 public class BlockFalling extends Block {
 
-    // public static boolean instaFall;
+    public static boolean instaFall;
 
     public BlockFalling() {
         super(Material.SAND);
@@ -34,7 +34,7 @@ public class BlockFalling extends Block {
         if (i(world.getType(blockposition.down())) && blockposition.getY() >= 0) {
             byte b0 = 32;
 
-            if (!world.instantBlockFall && world.areChunksLoadedBetween(blockposition.a(-b0, -b0, -b0), blockposition.a(b0, b0, b0))) { // Migot
+            if (!BlockFalling.instaFall && world.areChunksLoadedBetween(blockposition.a(-b0, -b0, -b0), blockposition.a(b0, b0, b0))) { // Migot
                 if (!world.isClientSide) {
                     EntityFallingBlock entityfallingblock = new EntityFallingBlock(world, (double) blockposition.getX() + 0.5D, (double) blockposition.getY(), (double) blockposition.getZ() + 0.5D, world.getType(blockposition));
 
diff --git a/src/main/java/net/minecraft/server/BlockOre.java b/src/main/java/net/minecraft/server/BlockOre.java
index ceec8c8..58b5d36 100644
--- a/src/main/java/net/minecraft/server/BlockOre.java
+++ b/src/main/java/net/minecraft/server/BlockOre.java
@@ -89,10 +89,6 @@ public class BlockOre extends Block {
         return new ItemStack(this);
     }
 
-    public int getDropData(World world, BlockPosition blockposition) {
-        return 0;
-    }
-
     public int getDropData(IBlockData iblockdata) {
         return this == Blocks.LAPIS_ORE ? EnumColor.BLUE.getInvColorIndex() : 0;
     }
diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java
index b5e2555..c6bb08a 100644
--- a/src/main/java/net/minecraft/server/Chunk.java
+++ b/src/main/java/net/minecraft/server/Chunk.java
@@ -1096,7 +1096,7 @@ public class Chunk {
             chunkgenerator.recreateStructures(this.locX, this.locZ);
 
             // CraftBukkit start
-            BlockSand.instaFall = true;
+            // BlockSand.instaFall = true;
             Random random = new Random();
             random.setSeed(world.getSeed());
             long xRand = random.nextLong() / 2L * 2L + 1L;
@@ -1115,7 +1115,7 @@ public class Chunk {
                     this.world.populating = false;
                 }
             }
-            BlockSand.instaFall = false;
+            // BlockSand.instaFall = false;
             this.world.getServer().getPluginManager().callEvent(new org.bukkit.event.world.ChunkPopulateEvent(bukkitChunk));
             // CraftBukkit end
             this.e();
diff --git a/src/main/java/net/minecraft/server/ChunkProviderGenerate.java b/src/main/java/net/minecraft/server/ChunkProviderGenerate.java
index af8ecef..534fd9f 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderGenerate.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderGenerate.java
@@ -303,7 +303,7 @@ public class ChunkProviderGenerate implements ChunkGenerator {
     }
 
     public void recreateStructures(int i, int j) {
-        this.m.instantBlockFall = true; // Migot
+        BlockFalling.instaFall = true;
         int k = i * 16;
         int l = j * 16;
         BlockPosition blockposition = new BlockPosition(k, 0, l);
@@ -388,7 +388,7 @@ public class ChunkProviderGenerate implements ChunkGenerator {
             }
         }
 
-        this.m.instantBlockFall = false; // Migot
+        BlockFalling.instaFall = false;
     }
 
     public boolean a(Chunk chunk, int i, int j) {
diff --git a/src/main/java/net/minecraft/server/ChunkProviderHell.java b/src/main/java/net/minecraft/server/ChunkProviderHell.java
index c0cd59b..e523afa 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderHell.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderHell.java
@@ -297,7 +297,7 @@ public class ChunkProviderHell implements ChunkGenerator {
     }
 
     public void recreateStructures(int i, int j) {
-        this.h.instantBlockFall = true; // Migot
+        BlockFalling.instaFall = true;
         BlockPosition blockposition = new BlockPosition(i * 16, 0, j * 16);
         ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(i, j);
 
@@ -337,7 +337,7 @@ public class ChunkProviderHell implements ChunkGenerator {
             this.D.generate(this.n, this.p, blockposition.a(this.p.nextInt(16), this.p.nextInt(108) + 10, this.p.nextInt(16)));
         }
 
-        this.h.instantBlockFall = false; // Migot
+        BlockFalling.instaFall = false;
     }
 
     public boolean a(Chunk chunk, int i, int j) {
diff --git a/src/main/java/net/minecraft/server/ChunkProviderTheEnd.java b/src/main/java/net/minecraft/server/ChunkProviderTheEnd.java
index 65bc6e5..c08c743 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderTheEnd.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderTheEnd.java
@@ -267,7 +267,7 @@ public class ChunkProviderTheEnd implements ChunkGenerator {
     }
 
     public void recreateStructures(int i, int j) {
-        this.l.instantBlockFall = true; // Migot
+        BlockFalling.instaFall = true;
         BlockPosition blockposition = new BlockPosition(i * 16, 0, j * 16);
 
         if (this.m) {
@@ -306,7 +306,7 @@ public class ChunkProviderTheEnd implements ChunkGenerator {
             }
         }
 
-        this.l.instantBlockFall = false; // Migot
+        BlockFalling.instaFall = false;
     }
 
     public boolean a(Chunk chunk, int i, int j) {
diff --git a/src/main/java/net/minecraft/server/Entity.java b/src/main/java/net/minecraft/server/Entity.java
index f02ef88..237167e 100644
--- a/src/main/java/net/minecraft/server/Entity.java
+++ b/src/main/java/net/minecraft/server/Entity.java
@@ -1453,10 +1453,14 @@ public abstract class Entity implements ICommandListener {
     }
 
     public boolean an() {
-		int currentTick = MinecraftServer.currentTick;
+		return this.an(this.world);
+     }
+ 
+    public boolean an(IBlockAccess iblockaccess) {
+        int currentTick = MinecraftServer.currentTick;
         if (this.lastLavaCheck != currentTick) {
             this.lastLavaCheck = currentTick;
-            this.isInLava = this.world.a(this.getBoundingBox().grow(-0.10000000149011612D, -0.4000000059604645D, -0.10000000149011612D), Material.LAVA);
+            this.isInLava = this.world.a(iblockaccess, this.getBoundingBox().grow(-0.10000000149011612D, -0.4000000059604645D, -0.10000000149011612D), Material.LAVA);
         }
         return this.isInLava;
     }
@@ -2591,68 +2595,16 @@ public abstract class Entity implements ICommandListener {
             WorldServer worldserver = ((CraftWorld) getBukkitEntity().getLocation().getWorld()).getHandle();
             WorldServer worldserver1 = ((CraftWorld) exit.getWorld()).getHandle();
             int i = worldserver1.dimension;
-            // CraftBukkit end
-
             this.dimension = i;
-            /* CraftBukkit start - TODO: Check if we need this
-            if (j == 1 && i == 1) {
-                worldserver1 = minecraftserver.getWorldServer(0);
-                this.dimension = 0;
-            }
-            // CraftBukkit end */
-
             this.world.kill(this);
             this.dead = false;
             this.world.methodProfiler.a("reposition");
-            /* CraftBukkit start - Handled in calculateTarget
-            BlockPosition blockposition;
-
-            if (i == 1) {
-                blockposition = worldserver1.getDimensionSpawn();
-            } else {
-                double d0 = this.locX;
-                double d1 = this.locZ;
-                double d2 = 8.0D;
-
-                if (i == -1) {
-                    d0 = MathHelper.a(d0 / d2, worldserver1.getWorldBorder().b() + 16.0D, worldserver1.getWorldBorder().d() - 16.0D);
-                    d1 = MathHelper.a(d1 / d2, worldserver1.getWorldBorder().c() + 16.0D, worldserver1.getWorldBorder().e() - 16.0D);
-                } else if (i == 0) {
-                    d0 = MathHelper.a(d0 * d2, worldserver1.getWorldBorder().b() + 16.0D, worldserver1.getWorldBorder().d() - 16.0D);
-                    d1 = MathHelper.a(d1 * d2, worldserver1.getWorldBorder().c() + 16.0D, worldserver1.getWorldBorder().e() - 16.0D);
-                }
-
-                d0 = (double) MathHelper.clamp((int) d0, -29999872, 29999872);
-                d1 = (double) MathHelper.clamp((int) d1, -29999872, 29999872);
-                float f = this.yaw;
-
-                this.setPositionRotation(d0, this.locY, d1, 90.0F, 0.0F);
-                PortalTravelAgent portaltravelagent = worldserver1.getTravelAgent();
-
-                portaltravelagent.b(this, f);
-                blockposition = new BlockPosition(this);
-            }
-
-            // CraftBukkit end */
-            // CraftBukkit start - Ensure chunks are loaded in case TravelAgent is not used which would initially cause chunks to load during find/create
-            // minecraftserver.getPlayerList().changeWorld(this, j, worldserver, worldserver1);
             worldserver1.getMinecraftServer().getPlayerList().repositionEntity(this, exit, portal);
-            // worldserver.entityJoinedWorld(this, false); // Handled in repositionEntity
-            // CraftBukkit end
             this.world.methodProfiler.c("reloading");
             Entity entity = EntityTypes.createEntityByName(EntityTypes.b(this), worldserver1);
 
             if (entity != null) {
                 entity.a(this);
-                /* CraftBukkit start - We need to do this...
-                if (j == 1 && i == 1) {
-                    BlockPosition blockposition1 = worldserver1.q(worldserver1.getSpawn());
-
-                    entity.setPositionRotation(blockposition1, entity.yaw, entity.pitch);
-                } else {
-                    entity.setPositionRotation(blockposition, entity.yaw, entity.pitch);
-                }
-                // CraftBukkit end */
 
                 boolean flag = entity.attachedToPlayer;
 
diff --git a/src/main/java/net/minecraft/server/EntityInsentient.java b/src/main/java/net/minecraft/server/EntityInsentient.java
index 6085275..bb767b8 100644
--- a/src/main/java/net/minecraft/server/EntityInsentient.java
+++ b/src/main/java/net/minecraft/server/EntityInsentient.java
@@ -8,6 +8,7 @@ import java.util.Map;
 import java.util.Random;
 import java.util.UUID;
 import javax.annotation.Nullable;
+import de.minetick.pathsearch.MigotNavigation; // Migot
 
 import java.util.concurrent.RecursiveAction;
 import org.hose.Tick_Pool;
@@ -88,7 +89,7 @@ public abstract class EntityInsentient extends EntityLiving {
     }
 
     protected NavigationAbstract b(World world) {
-        return new Navigation(this, world);
+        return new MigotNavigation(this, world); // Migot
     }
 
     public float a(PathType pathtype) {
@@ -636,8 +637,9 @@ public abstract class EntityInsentient extends EntityLiving {
 
 	navigation nav_task;
     targetSelector tar_task;
-    protected final void doTick() {// Torch - Entityliving doTick
+    protected final void doTick() { // Torch - Entityliving do Tick
         ++this.ticksFarFromPlayer;
+		this.navigation.cleanUpExpiredSearches(); // Migot
         this.world.methodProfiler.a("checkDespawn");
         this.L();
         this.world.methodProfiler.b();
diff --git a/src/main/java/net/minecraft/server/ItemSkull.java b/src/main/java/net/minecraft/server/ItemSkull.java
index 75cd3f1..72c902a 100644
--- a/src/main/java/net/minecraft/server/ItemSkull.java
+++ b/src/main/java/net/minecraft/server/ItemSkull.java
@@ -131,6 +131,20 @@ public class ItemSkull extends Item {
             // Spigot end
             return true;
         } else {
+			// CraftBukkit start
+            boolean valid = true;
+
+            NBTTagList textures = nbttagcompound.getCompound("SkullOwner").getCompound("Properties").getList("textures", 10); // Safe due to method contracts
+            for (int i = 0; i < textures.size(); i++) {
+                if (textures.get(i) instanceof NBTTagCompound && !((NBTTagCompound) textures.get(i)).hasKeyOfType("Signature", 8)) {
+                    valid = false;
+                }
+            }
+
+            if (!valid) {
+                nbttagcompound.remove("SkullOwner");
+            }
+            // CraftBukkit end
             return false;
         }
     }
diff --git a/src/main/java/net/minecraft/server/NavigationAbstract.java b/src/main/java/net/minecraft/server/NavigationAbstract.java
index ea3cd66..02d10f9 100644
--- a/src/main/java/net/minecraft/server/NavigationAbstract.java
+++ b/src/main/java/net/minecraft/server/NavigationAbstract.java
@@ -1,11 +1,17 @@
 package net.minecraft.server;
 
 import javax.annotation.Nullable;
+// Migot start
+import de.minetick.pathsearch.PathSearchJobEntity;
+import de.minetick.pathsearch.PathSearchJobPosition;
+import de.minetick.pathsearch.PositionPathSearchType;
+// Migot end
 
 public abstract class NavigationAbstract {
 
     private static int f = 20;
-    protected EntityInsentient a;public Entity getEntity() { return a; } // Paper
+    protected EntityInsentient a;
+	public Entity getEntity() { return a; } // Paper
     protected World b;
     @Nullable
     protected PathEntity c;
@@ -82,8 +88,8 @@ public abstract class NavigationAbstract {
             float f = this.h();
 
             this.b.methodProfiler.a("pathfind");
-            BlockPosition blockposition1 = new BlockPosition(this.a);
-            int i = (int) (f + 8.0F);
+            BlockPosition blockposition1 = (new BlockPosition(this.a)).up();
+            int i = (int) (f + 16.0F);
             ChunkCache chunkcache = new ChunkCache(this.b, blockposition1.a(-i, -i, -i), blockposition1.a(i, i, i), 0);
             PathEntity pathentity = this.s.a(chunkcache, this.a, this.r, f);
 
@@ -107,10 +113,10 @@ public abstract class NavigationAbstract {
                 float f = this.h();
 
                 this.b.methodProfiler.a("pathfind");
-                BlockPosition blockposition1 = (new BlockPosition(this.a)).up();
-                int i = (int) (f + 16.0F);
+                BlockPosition blockposition1 = (new BlockPosition(this.a));
+                int i = (int) (f + 8.0F);
                 ChunkCache chunkcache = new ChunkCache(this.b, blockposition1.a(-i, -i, -i), blockposition1.a(i, i, i), 0);
-                PathEntity pathentity = this.s.a(chunkcache, this.a, entity, f);
+				PathEntity pathentity = this.s.a(chunkcache, this.a, entity, f);
 
                 this.b.methodProfiler.b();
                 return pathentity;
@@ -301,4 +307,59 @@ public abstract class NavigationAbstract {
     public PathfinderAbstract q() {
         return this.e;
     }
+	
+	// Torch start - Async pathfinding
+	/*
+	 Torch remapping fix;
+	 (Origin) -> (Current) (Type)
+	 this.b -> this.a (EntityInsentient)
+	 this.i -> this.o (float) (1.0F -> 0.5F)
+	 this.c -> this.b (World)
+	 this.j -> this.s (Pathfinder)
+	*/
+	/*public EntityInsentient getEntity() {
+        return this.a; // Torch - remapping fix
+    }*/
+
+    @Override
+    public int hashCode() {
+        return this.a.getUniqueID().hashCode(); // Torch - remapping fix
+    }
+
+    public void cleanUpExpiredSearches() {}
+
+    public void setSearchResult(PathSearchJobEntity pathSearch) { }
+
+    public void setSearchResult(PathSearchJobPosition pathSearch) { }
+
+    public boolean a(double d0, double d1, double d2, double d3, PositionPathSearchType type) { // Torch
+        return this.a(d0, d1, d2, d3); // Torch - hold method
+    }
+
+    public PathEntity a(double d0, double d1, double d2, PositionPathSearchType type) { // Torch
+        return this.a(d0, d1, d2); // Torch - hold method
+    }
+
+    public ChunkCache createChunkCache(boolean forEntitySearch) {
+        if (this.b()) { // Torch - hold method
+            float f = this.h(); // Torch - hold method
+            BlockPosition blockposition1 = new BlockPosition(this.a); // Torch - remapping fix
+            int i = (int) (f + (forEntitySearch ? 16.0F : 8.0F));
+            return new ChunkCache(this.b, blockposition1.a(-i, -i, -i), blockposition1.a(i, i, i), 0); // Torch - remapping fix
+        }
+        return null;
+    }
+
+    public PathEntity doPathSearch(ChunkCache chunkcache, BlockPosition blockposition) {
+        if (this.b()) { // Torch - hold method
+            float f = this.h(); // Torch - hold method
+            return this.s.a((IBlockAccess) chunkcache, (Entity) this.a, blockposition, f); // Torch - remapping fix
+        }
+        return null;
+    }
+	
+	public PathEntity doPathSearch(ChunkCache chunkcache, Entity entity) {
+        return this.doPathSearch(chunkcache, (new BlockPosition(entity)).up());
+    }
+    // Torch end
 }
diff --git a/src/main/java/net/minecraft/server/Pathfinder.java b/src/main/java/net/minecraft/server/Pathfinder.java
new file mode 100644
index 0000000..df2f4ed
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Pathfinder.java
@@ -0,0 +1,140 @@
+package net.minecraft.server;
+
+import java.util.HashSet;
+import java.util.Set;
+import javax.annotation.Nullable;
+
+public class Pathfinder {
+
+    private final Path a = new Path();
+    private final Set<PathPoint> b = new HashSet();
+    private final PathPoint[] c = new PathPoint[32];
+    private final PathfinderAbstract d;
+
+    public Pathfinder(PathfinderAbstract pathfinderabstract) {
+        this.d = pathfinderabstract;
+    }
+
+    @Nullable
+    public PathEntity a(IBlockAccess iblockaccess, EntityInsentient entityinsentient, Entity entity, float f) {
+        return this.a(iblockaccess, entityinsentient, entity.locX, entity.getBoundingBox().b, entity.locZ, f);
+    }
+	
+	@Nullable
+    public PathEntity a(IBlockAccess iblockaccess, Entity entity, BlockPosition blockposition, float f) {
+		return this.a(iblockaccess, entity, (double) ((float) blockposition.getX() + 0.5F), (double) ((float) blockposition.getY() + 0.5F), (double) ((float) blockposition.getZ() + 0.5F), f);
+    }
+
+    @Nullable
+    public PathEntity a(IBlockAccess iblockaccess, EntityInsentient entityinsentient, BlockPosition blockposition, float f) {
+        return this.a(iblockaccess, entityinsentient, (double) ((float) blockposition.getX() + 0.5F), (double) ((float) blockposition.getY() + 0.5F), (double) ((float) blockposition.getZ() + 0.5F), f);
+    }
+
+    @Nullable
+    private PathEntity a(IBlockAccess iblockaccess, EntityInsentient entityinsentient, double d0, double d1, double d2, float f) {
+        this.a.a();
+        this.d.a(iblockaccess, entityinsentient);
+        PathPoint pathpoint = this.d.b();
+        PathPoint pathpoint1 = this.d.a(d0, d1, d2);
+        PathEntity pathentity = this.a(pathpoint, pathpoint1, f);
+
+        this.d.a();
+        return pathentity;
+    }
+	
+	@Nullable
+    private PathEntity a(IBlockAccess iblockaccess, Entity entity, double d0, double d1, double d2, float f) {
+        this.a.a();
+        this.d.a(iblockaccess, entity);
+        PathPoint pathpoint = this.d.b();
+        PathPoint pathpoint1 = this.d.a(d0, d1, d2);
+        PathEntity pathentity = this.a(pathpoint, pathpoint1, f);
+
+        this.d.a();
+        return pathentity;
+    }
+
+    @Nullable
+    private PathEntity a(PathPoint pathpoint, PathPoint pathpoint1, float f) {
+        pathpoint.e = 0.0F;
+        pathpoint.f = pathpoint.c(pathpoint1);
+        pathpoint.g = pathpoint.f;
+        this.a.a();
+        this.b.clear();
+        this.a.a(pathpoint);
+        PathPoint pathpoint2 = pathpoint;
+        int i = 0;
+
+        while (!this.a.e()) {
+            ++i;
+            if (i >= 200) {
+                break;
+            }
+
+            PathPoint pathpoint3 = this.a.c();
+
+            if (pathpoint3.equals(pathpoint1)) {
+                pathpoint2 = pathpoint1;
+                break;
+            }
+
+            if (pathpoint3.c(pathpoint1) < pathpoint2.c(pathpoint1)) {
+                pathpoint2 = pathpoint3;
+            }
+
+            pathpoint3.i = true;
+            int j = this.d.a(this.c, pathpoint3, pathpoint1, f);
+
+            for (int k = 0; k < j; ++k) {
+                PathPoint pathpoint4 = this.c[k];
+                float f1 = pathpoint3.c(pathpoint4);
+
+                pathpoint4.j = pathpoint3.j + f1;
+                pathpoint4.k = f1 + pathpoint4.l;
+                float f2 = pathpoint3.e + pathpoint4.k;
+
+                if (pathpoint4.j < f && (!pathpoint4.a() || f2 < pathpoint4.e)) {
+                    pathpoint4.h = pathpoint3;
+                    pathpoint4.e = f2;
+                    pathpoint4.f = pathpoint4.c(pathpoint1) + pathpoint4.l;
+                    if (pathpoint4.a()) {
+                        this.a.a(pathpoint4, pathpoint4.e + pathpoint4.f);
+                    } else {
+                        pathpoint4.g = pathpoint4.e + pathpoint4.f;
+                        this.a.a(pathpoint4);
+                    }
+                }
+            }
+        }
+
+        if (pathpoint2 == pathpoint) {
+            return null;
+        } else {
+            PathEntity pathentity = this.a(pathpoint, pathpoint2);
+
+            return pathentity;
+        }
+    }
+
+    private PathEntity a(PathPoint pathpoint, PathPoint pathpoint1) {
+        int i = 1;
+
+        PathPoint pathpoint2;
+
+        for (pathpoint2 = pathpoint1; pathpoint2.h != null; pathpoint2 = pathpoint2.h) {
+            ++i;
+        }
+
+        PathPoint[] apathpoint = new PathPoint[i];
+
+        pathpoint2 = pathpoint1;
+        --i;
+
+        for (apathpoint[i] = pathpoint1; pathpoint2.h != null; apathpoint[i] = pathpoint2) {
+            pathpoint2 = pathpoint2.h;
+            --i;
+        }
+
+        return new PathEntity(apathpoint);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PathfinderGoalAvoidTarget.java b/src/main/java/net/minecraft/server/PathfinderGoalAvoidTarget.java
new file mode 100644
index 0000000..d8eb58a
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PathfinderGoalAvoidTarget.java
@@ -0,0 +1,85 @@
+package net.minecraft.server;
+
+import com.google.common.base.Predicate;
+import com.google.common.base.Predicates;
+import java.util.List;
+import javax.annotation.Nullable;
+
+public class PathfinderGoalAvoidTarget<T extends Entity> extends PathfinderGoal {
+
+    private final Predicate<Entity> c;
+    protected EntityCreature a;
+    private double d;
+    private double e;
+    protected T b;
+    private float f;
+    private PathEntity g;
+    private NavigationAbstract h;
+    private Class<T> i;
+    private Predicate<? super T> j;
+
+    public PathfinderGoalAvoidTarget(EntityCreature entitycreature, Class<T> oclass, float f, double d0, double d1) {
+        this(entitycreature, oclass, Predicates.alwaysTrue(), f, d0, d1);
+    }
+
+    public PathfinderGoalAvoidTarget(EntityCreature entitycreature, Class<T> oclass, Predicate<? super T> predicate, float f, double d0, double d1) {
+        this.c = new Predicate() {
+            public boolean a(@Nullable Entity entity) {
+                return entity.isAlive() && PathfinderGoalAvoidTarget.this.a.getEntitySenses().a(entity);
+            }
+
+            public boolean apply(Object object) {
+                return this.a((Entity) object);
+            }
+        };
+        this.a = entitycreature;
+        this.i = oclass;
+        this.j = predicate;
+        this.f = f;
+        this.d = d0;
+        this.e = d1;
+        this.h = entitycreature.getNavigation();
+        this.a(1);
+    }
+
+    public boolean a() {
+        List list = this.a.world.a(this.i, this.a.getBoundingBox().grow((double) this.f, 3.0D, (double) this.f), Predicates.and(new Predicate[] { IEntitySelector.d, this.c, this.j}));
+
+        if (list.isEmpty()) {
+            return false;
+        } else {
+            this.b = (T) list.get(0);
+            Vec3D vec3d = RandomPositionGenerator.b(this.a, 16, 7, new Vec3D(this.b.locX, this.b.locY, this.b.locZ));
+
+            if (vec3d == null) {
+                return false;
+            } else if (this.b.e(vec3d.x, vec3d.y, vec3d.z) < this.b.h(this.a)) {
+                return false;
+            } else {
+				this.g = this.h.a(vec3d.x, vec3d.y, vec3d.z, de.minetick.pathsearch.PositionPathSearchType.AVOIDTARGET); // Migot
+                return this.g == null ? false : this.g.b(vec3d);
+            }
+        }
+    }
+
+    public boolean b() {
+        return !this.h.n();
+    }
+
+    public void c() {
+        this.h.a(this.g, this.d);
+    }
+
+    public void d() {
+        this.b = null;
+    }
+
+    public void e() {
+        if (this.a.h(this.b) < 49.0D) {
+            this.a.getNavigation().a(this.e);
+        } else {
+            this.a.getNavigation().a(this.d);
+        }
+
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PathfinderGoalFleeSun.java b/src/main/java/net/minecraft/server/PathfinderGoalFleeSun.java
new file mode 100644
index 0000000..5eea7ef
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PathfinderGoalFleeSun.java
@@ -0,0 +1,71 @@
+package net.minecraft.server;
+
+import java.util.Random;
+import javax.annotation.Nullable;
+
+public class PathfinderGoalFleeSun extends PathfinderGoal {
+
+    private EntityCreature a;
+    private double b;
+    private double c;
+    private double d;
+    private double e;
+    private World f;
+
+    public PathfinderGoalFleeSun(EntityCreature entitycreature, double d0) {
+        this.a = entitycreature;
+        this.e = d0;
+        this.f = entitycreature.world;
+        this.a(1);
+    }
+
+    public boolean a() {
+        if (!this.f.B()) {
+            return false;
+        } else if (!this.a.isBurning()) {
+            return false;
+        } else if (!this.f.h(new BlockPosition(this.a.locX, this.a.getBoundingBox().b, this.a.locZ))) {
+            return false;
+        } else if (this.a.getEquipment(EnumItemSlot.HEAD) != null) {
+            return false;
+        } else {
+            Vec3D vec3d = this.f();
+
+            if (vec3d == null) {
+                return false;
+            } else {
+                this.b = vec3d.x;
+                this.c = vec3d.y;
+                this.d = vec3d.z;
+                return true;
+            }
+        }
+    }
+
+    public boolean b() {
+        return !this.a.getNavigation().n();
+    }
+
+    public void c() {
+		// Torch remapping fix - start
+		// Origin: this.a.getNavigation().a(this.b, this.c, this.d, this.e);
+		this.a.getNavigation().a(this.b, this.c, this.d, this.e, de.minetick.pathsearch.PositionPathSearchType.FLEESUN); // Torch - remapping fix
+		// Torch end
+    }
+
+    @Nullable
+    private Vec3D f() {
+        Random random = this.a.getRandom();
+        BlockPosition blockposition = new BlockPosition(this.a.locX, this.a.getBoundingBox().b, this.a.locZ);
+
+        for (int i = 0; i < 10; ++i) {
+            BlockPosition blockposition1 = blockposition.a(random.nextInt(20) - 10, random.nextInt(6) - 3, random.nextInt(20) - 10);
+
+            if (!this.f.h(blockposition1) && this.a.a(blockposition1) < 0.0F) {
+                return new Vec3D((double) blockposition1.getX(), (double) blockposition1.getY(), (double) blockposition1.getZ());
+            }
+        }
+
+        return null;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PathfinderGoalGotoTarget.java b/src/main/java/net/minecraft/server/PathfinderGoalGotoTarget.java
new file mode 100644
index 0000000..d5adafb
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PathfinderGoalGotoTarget.java
@@ -0,0 +1,94 @@
+package net.minecraft.server;
+
+public abstract class PathfinderGoalGotoTarget extends PathfinderGoal {
+
+    private final EntityCreature c;
+    private final double d;
+    protected int a;
+    private int e;
+    private int f;
+    protected BlockPosition b;
+    private boolean g;
+    private int h;
+
+    public PathfinderGoalGotoTarget(EntityCreature entitycreature, double d0, int i) {
+        this.b = BlockPosition.ZERO;
+        this.c = entitycreature;
+        this.d = d0;
+        this.h = i;
+        this.a(5);
+    }
+
+    public boolean a() {
+        if (this.a > 0) {
+            --this.a;
+            return false;
+        } else {
+            this.a = 200 + this.c.getRandom().nextInt(200);
+            return this.i();
+        }
+    }
+
+    public boolean b() {
+        return this.e >= -this.f && this.e <= 1200 && this.a(this.c.world, this.b);
+    }
+
+    public void c() {
+		// Torch start - remapping fix
+		// Origin: this.c.getNavigation().a((double) ((float) this.b.getX()) + 0.5D, (double) (this.b.getY() + 1), (double) ((float) this.b.getZ()) + 0.5D, this.d);
+		// Pre-Apply: this.c.getNavigation().a((double) ((float) this.b.getX()) + 0.5D, (double) (this.b.getY() + 1), (double) ((float) this.b.getZ()) + 0.5D, this.d, de.minetick.pathsearch.PositionPathSearchType.GOTOTARGET);
+		this.c.getNavigation().a((double) ((float) this.b.getX()) + 0.5D, (double) (this.b.getY() + 1), (double) ((float) this.b.getZ()) + 0.5D, this.d, de.minetick.pathsearch.PositionPathSearchType.GOTOTARGET); // Migot // Torch
+        // Torch end
+		this.e = 0;
+        this.f = this.c.getRandom().nextInt(this.c.getRandom().nextInt(1200) + 1200) + 1200;
+    }
+
+    public void d() {}
+
+    public void e() {
+        if (this.c.d(this.b.up()) > 1.0D) {
+            this.g = false;
+            ++this.e;
+            if (this.e % 40 == 0) {
+				// Torch start - remapping fix
+				// Origin: this.c.getNavigation().a((double) ((float) this.b.getX()) + 0.5D, (double) (this.b.getY() + 1), (double) ((float) this.b.getZ()) + 0.5D, this.d);
+				// Pre-Apply: this.c.getNavigation().a((double) ((float) this.b.getX()) + 0.5D, (double) (this.b.getY() + 1), (double) ((float) this.b.getZ()) + 0.5D, this.d, de.minetick.pathsearch.PositionPathSearchType.GOTOTARGET);
+				this.c.getNavigation().a((double) ((float) this.b.getX()) + 0.5D, (double) (this.b.getY() + 1), (double) ((float) this.b.getZ()) + 0.5D, this.d, de.minetick.pathsearch.PositionPathSearchType.GOTOTARGET); // Migot // Torch
+				// Torch end
+			}
+        } else {
+            this.g = true;
+            --this.e;
+        }
+
+    }
+
+    protected boolean f() {
+        return this.g;
+    }
+
+    private boolean i() {
+        int i = this.h;
+        boolean flag = true;
+        BlockPosition blockposition = new BlockPosition(this.c);
+
+        for (int j = 0; j <= 1; j = j > 0 ? -j : 1 - j) {
+            for (int k = 0; k < i; ++k) {
+                for (int l = 0; l <= k; l = l > 0 ? -l : 1 - l) {
+                    for (int i1 = l < k && l > -k ? k : 0; i1 <= k; i1 = i1 > 0 ? -i1 : 1 - i1) {
+                        BlockPosition blockposition1 = blockposition.a(l, j - 1, i1);
+
+                        if (this.c.f(blockposition1) && this.a(this.c.world, blockposition1)) {
+                            this.b = blockposition1;
+                            return true;
+                        }
+                    }
+                }
+            }
+        }
+
+        return false;
+    }
+
+    protected abstract boolean a(World world, BlockPosition blockposition);
+}
diff --git a/src/main/java/net/minecraft/server/PathfinderGoalMoveIndoors.java b/src/main/java/net/minecraft/server/PathfinderGoalMoveIndoors.java
new file mode 100644
index 0000000..3b37c9c
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PathfinderGoalMoveIndoors.java
@@ -0,0 +1,74 @@
+package net.minecraft.server;
+
+public class PathfinderGoalMoveIndoors extends PathfinderGoal {
+
+    private EntityCreature a;
+    private VillageDoor b;
+    private int c = -1;
+    private int d = -1;
+
+    public PathfinderGoalMoveIndoors(EntityCreature entitycreature) {
+        this.a = entitycreature;
+        this.a(1);
+    }
+
+    public boolean a() {
+        BlockPosition blockposition = new BlockPosition(this.a);
+
+        if ((!this.a.world.B() || this.a.world.W() && !this.a.world.getBiome(blockposition).d()) && !this.a.world.worldProvider.m()) {
+            if (this.a.getRandom().nextInt(50) != 0) {
+                return false;
+            } else if (this.c != -1 && this.a.e((double) this.c, this.a.locY, (double) this.d) < 4.0D) {
+                return false;
+            } else {
+                Village village = this.a.world.ai().getClosestVillage(blockposition, 14);
+
+                if (village == null) {
+                    return false;
+                } else {
+                    this.b = village.c(blockposition);
+                    return this.b != null;
+                }
+            }
+        } else {
+            return false;
+        }
+    }
+
+    public boolean b() {
+        return !this.a.getNavigation().n();
+    }
+
+    public void c() {
+        this.c = -1;
+        BlockPosition blockposition = this.b.e();
+        int i = blockposition.getX();
+        int j = blockposition.getY();
+        int k = blockposition.getZ();
+
+        if (this.a.c(blockposition) > 256.0D) {
+            Vec3D vec3d = RandomPositionGenerator.a(this.a, 14, 3, new Vec3D((double) i + 0.5D, (double) j, (double) k + 0.5D));
+
+			// Torch start - remapping fix
+            if (vec3d != null) {
+				// Origin: this.a.getNavigation().a(vec3d.x, vec3d.y, vec3d.z, 1.0D);
+				// Pre-Apply: this.a.getNavigation().a(vec3d.a, vec3d.b, vec3d.c, 1.0D, de.minetick.pathsearch.PositionPathSearchType.MOVEINDOORS);
+				// Remap: this.a.getNavigation().a(vec3d.x, vec3d.y, vec3d.z, 1.0D, de.minetick.pathsearch.PositionPathSearchType.MOVEINDOORS);
+				this.a.getNavigation().a(vec3d.x, vec3d.y, vec3d.z, 1.0D, de.minetick.pathsearch.PositionPathSearchType.MOVEINDOORS); // Migot // Torch
+            }
+        } else {
+			// Origin: this.a.getNavigation().a((double) i + 0.5D, (double) j, (double) k + 0.5D, 1.0D);
+			// Pre-Apply: this.a.getNavigation().a((double) i + 0.5D, (double) j, (double) k + 0.5D, 1.0D, de.minetick.pathsearch.PositionPathSearchType.MOVEINDOORS);
+			// Remap: this.a.getNavigation().a((double) i + 0.5D, (double) j, (double) k + 0.5D, 1.0D, de.minetick.pathsearch.PositionPathSearchType.MOVEINDOORS);
+			this.a.getNavigation().a((double) i + 0.5D, (double) j, (double) k + 0.5D, 1.0D, de.minetick.pathsearch.PositionPathSearchType.MOVEINDOORS); // Migot // Torch
+			// Torch end
+        }
+
+    }
+
+    public void d() {
+        this.c = this.b.e().getX();
+        this.d = this.b.e().getZ();
+        this.b = null;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PathfinderGoalMoveThroughVillage.java b/src/main/java/net/minecraft/server/PathfinderGoalMoveThroughVillage.java
new file mode 100644
index 0000000..9eee73e
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PathfinderGoalMoveThroughVillage.java
@@ -0,0 +1,132 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Lists;
+import java.util.Iterator;
+import java.util.List;
+
+public class PathfinderGoalMoveThroughVillage extends PathfinderGoal {
+
+    private EntityCreature a;
+    private double b;
+    private PathEntity c;
+    private VillageDoor d;
+    private boolean e;
+    private List<VillageDoor> f = Lists.newArrayList();
+
+    public PathfinderGoalMoveThroughVillage(EntityCreature entitycreature, double d0, boolean flag) {
+        this.a = entitycreature;
+        this.b = d0;
+        this.e = flag;
+        this.a(1);
+        if (!(entitycreature.getNavigation() instanceof Navigation)) {
+            throw new IllegalArgumentException("Unsupported mob for MoveThroughVillageGoal");
+        }
+    }
+
+    public boolean a() {
+        this.f();
+        if (this.e && this.a.world.B()) {
+            return false;
+        } else {
+            Village village = this.a.world.ai().getClosestVillage(new BlockPosition(this.a), 0);
+
+            if (village == null) {
+                return false;
+            } else {
+                this.d = this.a(village);
+                if (this.d == null) {
+                    return false;
+                } else {
+                    Navigation navigation = (Navigation) this.a.getNavigation();
+                    boolean flag = navigation.f();
+
+                    navigation.a(false);
+                    this.c = navigation.a(this.d.d());
+                    navigation.a(flag);
+                    if (this.c != null) {
+                        return true;
+                    } else {
+                        Vec3D vec3d = RandomPositionGenerator.a(this.a, 10, 7, new Vec3D((double) this.d.d().getX(), (double) this.d.d().getY(), (double) this.d.d().getZ()));
+
+                        if (vec3d == null) {
+                            return false;
+                        } else {
+                            navigation.a(false);
+							// Torch start - remapping fix
+							// Origin: this.c = this.a.getNavigation().a(vec3d.x, vec3d.y, vec3d.z);
+							// Pre-Apply: this.c = this.a.getNavigation().a(vec3d.a, vec3d.b, vec3d.c, de.minetick.pathsearch.PositionPathSearchType.MOVETHROUGHVILLAGE);
+							// Remap: this.c = this.a.getNavigation().a(vec3d.x, vec3d.y, vec3d.z, de.minetick.pathsearch.PositionPathSearchType.MOVETHROUGHVILLAGE);
+							this.c = this.a.getNavigation().a(vec3d.x, vec3d.y, vec3d.z, de.minetick.pathsearch.PositionPathSearchType.MOVETHROUGHVILLAGE); // Migot // Torch
+							// Torch end
+                            navigation.a(flag);
+                            return this.c != null;
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    public boolean b() {
+        if (this.a.getNavigation().n()) {
+            return false;
+        } else {
+            float f = this.a.width + 4.0F;
+
+            return this.a.c(this.d.d()) > (double) (f * f);
+        }
+    }
+
+    public void c() {
+        this.a.getNavigation().a(this.c, this.b);
+    }
+
+    public void d() {
+        if (this.a.getNavigation().n() || this.a.c(this.d.d()) < 16.0D) {
+            this.f.add(this.d);
+        }
+
+    }
+
+    private VillageDoor a(Village village) {
+        VillageDoor villagedoor = null;
+        int i = Integer.MAX_VALUE;
+        List list = village.f();
+        Iterator iterator = list.iterator();
+
+        while (iterator.hasNext()) {
+            VillageDoor villagedoor1 = (VillageDoor) iterator.next();
+            int j = villagedoor1.b(MathHelper.floor(this.a.locX), MathHelper.floor(this.a.locY), MathHelper.floor(this.a.locZ));
+
+            if (j < i && !this.a(villagedoor1)) {
+                villagedoor = villagedoor1;
+                i = j;
+            }
+        }
+
+        return villagedoor;
+    }
+
+    private boolean a(VillageDoor villagedoor) {
+        Iterator iterator = this.f.iterator();
+
+        VillageDoor villagedoor1;
+
+        do {
+            if (!iterator.hasNext()) {
+                return false;
+            }
+
+            villagedoor1 = (VillageDoor) iterator.next();
+        } while (!villagedoor.d().equals(villagedoor1.d()));
+
+        return true;
+    }
+
+    private void f() {
+        if (this.f.size() > 15) {
+            this.f.remove(0);
+        }
+
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PathfinderGoalMoveTowardsRestriction.java b/src/main/java/net/minecraft/server/PathfinderGoalMoveTowardsRestriction.java
new file mode 100644
index 0000000..6cf8b7b
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PathfinderGoalMoveTowardsRestriction.java
@@ -0,0 +1,42 @@
+package net.minecraft.server;
+
+public class PathfinderGoalMoveTowardsRestriction extends PathfinderGoal {
+
+    private EntityCreature a;
+    private double b;
+    private double c;
+    private double d;
+    private double e;
+
+    public PathfinderGoalMoveTowardsRestriction(EntityCreature entitycreature, double d0) {
+        this.a = entitycreature;
+        this.e = d0;
+        this.a(1);
+    }
+
+    public boolean a() {
+        if (this.a.cV()) {
+            return false;
+        } else {
+            BlockPosition blockposition = this.a.cW();
+            Vec3D vec3d = RandomPositionGenerator.a(this.a, 16, 7, new Vec3D((double) blockposition.getX(), (double) blockposition.getY(), (double) blockposition.getZ()));
+
+            if (vec3d == null) {
+                return false;
+            } else {
+                this.b = vec3d.x;
+                this.c = vec3d.y;
+                this.d = vec3d.z;
+                return true;
+            }
+        }
+    }
+
+    public boolean b() {
+        return !this.a.getNavigation().n();
+    }
+
+    public void c() {
+		this.a.getNavigation().a(this.b, this.c, this.d, this.e, de.minetick.pathsearch.PositionPathSearchType.MOVETOWARDSRESTRICTION); // Migot
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PathfinderGoalMoveTowardsTarget.java b/src/main/java/net/minecraft/server/PathfinderGoalMoveTowardsTarget.java
new file mode 100644
index 0000000..8353ec2
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PathfinderGoalMoveTowardsTarget.java
@@ -0,0 +1,51 @@
+package net.minecraft.server;
+
+public class PathfinderGoalMoveTowardsTarget extends PathfinderGoal {
+
+    private EntityCreature a;
+    private EntityLiving b;
+    private double c;
+    private double d;
+    private double e;
+    private double f;
+    private float g;
+
+    public PathfinderGoalMoveTowardsTarget(EntityCreature entitycreature, double d0, float f) {
+        this.a = entitycreature;
+        this.f = d0;
+        this.g = f;
+        this.a(1);
+    }
+
+    public boolean a() {
+        this.b = this.a.getGoalTarget();
+        if (this.b == null) {
+            return false;
+        } else if (this.b.h(this.a) > (double) (this.g * this.g)) {
+            return false;
+        } else {
+            Vec3D vec3d = RandomPositionGenerator.a(this.a, 16, 7, new Vec3D(this.b.locX, this.b.locY, this.b.locZ));
+
+            if (vec3d == null) {
+                return false;
+            } else {
+                this.c = vec3d.x;
+                this.d = vec3d.y;
+                this.e = vec3d.z;
+                return true;
+            }
+        }
+    }
+
+    public boolean b() {
+        return !this.a.getNavigation().n() && this.b.isAlive() && this.b.h(this.a) < (double) (this.g * this.g);
+    }
+
+    public void d() {
+        this.b = null;
+    }
+
+    public void c() {
+		this.a.getNavigation().a(this.c, this.d, this.e, this.f, de.minetick.pathsearch.PositionPathSearchType.MOVETOWARDSTARGET); // Migot
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PathfinderGoalPanic.java b/src/main/java/net/minecraft/server/PathfinderGoalPanic.java
index 0625949..409ac5c 100644
--- a/src/main/java/net/minecraft/server/PathfinderGoalPanic.java
+++ b/src/main/java/net/minecraft/server/PathfinderGoalPanic.java
@@ -42,7 +42,7 @@ public class PathfinderGoalPanic extends PathfinderGoal {
     }
 
     public void c() {
-        this.b.getNavigation().a(this.c, this.d, this.e, this.a);
+        this.b.getNavigation().a(this.c, this.d, this.e, this.a, de.minetick.pathsearch.PositionPathSearchType.PANIC); // Migot
     }
 
     public boolean b() {
diff --git a/src/main/java/net/minecraft/server/PathfinderGoalPlay.java b/src/main/java/net/minecraft/server/PathfinderGoalPlay.java
new file mode 100644
index 0000000..67dc046
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PathfinderGoalPlay.java
@@ -0,0 +1,88 @@
+package net.minecraft.server;
+
+import java.util.Iterator;
+import java.util.List;
+
+public class PathfinderGoalPlay extends PathfinderGoal {
+
+    private EntityVillager a;
+    private EntityLiving b;
+    private double c;
+    private int d;
+
+    public PathfinderGoalPlay(EntityVillager entityvillager, double d0) {
+        this.a = entityvillager;
+        this.c = d0;
+        this.a(1);
+    }
+
+    public boolean a() {
+        if (this.a.getAge() >= 0) {
+            return false;
+        } else if (this.a.getRandom().nextInt(400) != 0) {
+            return false;
+        } else {
+            List list = this.a.world.a(EntityVillager.class, this.a.getBoundingBox().grow(6.0D, 3.0D, 6.0D));
+            double d0 = Double.MAX_VALUE;
+            Iterator iterator = list.iterator();
+
+            while (iterator.hasNext()) {
+                EntityVillager entityvillager = (EntityVillager) iterator.next();
+
+                if (entityvillager != this.a && !entityvillager.dc() && entityvillager.getAge() < 0) {
+                    double d1 = entityvillager.h(this.a);
+
+                    if (d1 <= d0) {
+                        d0 = d1;
+                        this.b = entityvillager;
+                    }
+                }
+            }
+
+            if (this.b == null) {
+                Vec3D vec3d = RandomPositionGenerator.a(this.a, 16, 3);
+
+                if (vec3d == null) {
+                    return false;
+                }
+            }
+
+            return true;
+        }
+    }
+
+    public boolean b() {
+        return this.d > 0;
+    }
+
+    public void c() {
+        if (this.b != null) {
+            this.a.p(true);
+        }
+
+        this.d = 1000;
+    }
+
+    public void d() {
+        this.a.p(false);
+        this.b = null;
+    }
+
+    public void e() {
+        --this.d;
+        if (this.b != null) {
+            if (this.a.h(this.b) > 4.0D) {
+                this.a.getNavigation().a((Entity) this.b, this.c);
+            }
+        } else if (this.a.getNavigation().n()) {
+            Vec3D vec3d = RandomPositionGenerator.a(this.a, 16, 3);
+
+            if (vec3d == null) {
+                return;
+            }
+
+			this.a.getNavigation().a(vec3d.x, vec3d.y, vec3d.z, this.c, de.minetick.pathsearch.PositionPathSearchType.PLAY); // Migot
+        }
+
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PathfinderGoalRandomStroll.java b/src/main/java/net/minecraft/server/PathfinderGoalRandomStroll.java
new file mode 100644
index 0000000..23c48a1
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PathfinderGoalRandomStroll.java
@@ -0,0 +1,63 @@
+package net.minecraft.server;
+
+public class PathfinderGoalRandomStroll extends PathfinderGoal {
+
+    private EntityCreature a;
+    private double b;
+    private double c;
+    private double d;
+    private double e;
+    private int f;
+    private boolean g;
+
+    public PathfinderGoalRandomStroll(EntityCreature entitycreature, double d0) {
+        this(entitycreature, d0, 120);
+    }
+
+    public PathfinderGoalRandomStroll(EntityCreature entitycreature, double d0, int i) {
+        this.a = entitycreature;
+        this.e = d0;
+        this.f = i;
+        this.a(1);
+    }
+
+    public boolean a() {
+        if (!this.g) {
+            if (this.a.bL() >= 100) {
+                return false;
+            }
+
+            if (this.a.getRandom().nextInt(this.f) != 0) {
+                return false;
+            }
+        }
+
+        Vec3D vec3d = RandomPositionGenerator.a(this.a, 10, 7);
+
+        if (vec3d == null) {
+            return false;
+        } else {
+            this.b = vec3d.x;
+            this.c = vec3d.y;
+            this.d = vec3d.z;
+            this.g = false;
+            return true;
+        }
+    }
+
+    public boolean b() {
+        return !this.a.getNavigation().n();
+    }
+
+    public void c() {
+        this.a.getNavigation().a(this.b, this.c, this.d, this.e, de.minetick.pathsearch.PositionPathSearchType.RANDOMSTROLL); // Migot
+    }
+
+    public void f() {
+        this.g = true;
+    }
+
+    public void setTimeBetweenMovement(int i) {
+        this.f = i;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PathfinderGoalTame.java b/src/main/java/net/minecraft/server/PathfinderGoalTame.java
index 318cbb0..efa18b0 100644
--- a/src/main/java/net/minecraft/server/PathfinderGoalTame.java
+++ b/src/main/java/net/minecraft/server/PathfinderGoalTame.java
@@ -32,7 +32,7 @@ public class PathfinderGoalTame extends PathfinderGoal {
     }
 
     public void c() {
-        this.entity.getNavigation().a(this.c, this.d, this.e, this.b);
+        this.entity.getNavigation().a(this.c, this.d, this.e, this.b, de.minetick.pathsearch.PositionPathSearchType.TAME); // Migot
     }
 
     public boolean b() {
diff --git a/src/main/java/net/minecraft/server/PathfinderNormal.java b/src/main/java/net/minecraft/server/PathfinderNormal.java
new file mode 100644
index 0000000..87e9a7d
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PathfinderNormal.java
@@ -0,0 +1,336 @@
+package net.minecraft.server;
+
+import java.util.EnumSet;
+import java.util.HashSet;
+import java.util.Iterator;
+import javax.annotation.Nullable;
+
+public class PathfinderNormal extends PathfinderAbstract {
+
+    private float j;
+
+    public PathfinderNormal() {}
+
+    public void a(IBlockAccess iblockaccess, EntityInsentient entityinsentient) {
+        super.a(iblockaccess, entityinsentient);
+        this.j = entityinsentient.a(PathType.WATER);
+    }
+
+    public void a() {
+        this.b.a(PathType.WATER, this.j);
+        super.a();
+    }
+
+    public PathPoint b() {
+        int i;
+        BlockPosition blockposition;
+
+        if (this.e() && this.b.isInWater()) {
+            i = (int) this.b.getBoundingBox().b;
+            BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition(MathHelper.floor(this.b.locX), i, MathHelper.floor(this.b.locZ));
+
+            for (Block block = this.a.getType(blockposition_mutableblockposition).getBlock(); block == Blocks.FLOWING_WATER || block == Blocks.WATER; block = this.a.getType(blockposition_mutableblockposition).getBlock()) {
+                ++i;
+                blockposition_mutableblockposition.c(MathHelper.floor(this.b.locX), i, MathHelper.floor(this.b.locZ));
+            }
+        } else if (!this.b.onGround) {
+            for (blockposition = new BlockPosition(this.b); (this.a.getType(blockposition).getMaterial() == Material.AIR || this.a.getType(blockposition).getBlock().b(this.a, blockposition)) && blockposition.getY() > 0; blockposition = blockposition.down()) {
+                ;
+            }
+
+            i = blockposition.up().getY();
+        } else {
+            i = MathHelper.floor(this.b.getBoundingBox().b + 0.5D);
+        }
+
+        blockposition = new BlockPosition(this.b);
+        PathType pathtype = this.a(this.b, blockposition.getX(), i, blockposition.getZ());
+
+        if (this.b.a(pathtype) < 0.0F) {
+            HashSet hashset = new HashSet();
+
+            hashset.add(new BlockPosition(this.b.getBoundingBox().a, (double) i, this.b.getBoundingBox().c));
+            hashset.add(new BlockPosition(this.b.getBoundingBox().a, (double) i, this.b.getBoundingBox().f));
+            hashset.add(new BlockPosition(this.b.getBoundingBox().d, (double) i, this.b.getBoundingBox().c));
+            hashset.add(new BlockPosition(this.b.getBoundingBox().d, (double) i, this.b.getBoundingBox().f));
+            Iterator iterator = hashset.iterator();
+
+            while (iterator.hasNext()) {
+                BlockPosition blockposition1 = (BlockPosition) iterator.next();
+                PathType pathtype1 = this.a(this.b, blockposition1);
+
+                if (this.b.a(pathtype1) >= 0.0F) {
+                    return this.a(blockposition1.getX(), blockposition1.getY(), blockposition1.getZ());
+                }
+            }
+        }
+
+        return this.a(blockposition.getX(), i, blockposition.getZ());
+    }
+
+    public PathPoint a(double d0, double d1, double d2) {
+        return this.a(MathHelper.floor(d0 - (double) (this.b.width / 2.0F)), MathHelper.floor(d1), MathHelper.floor(d2 - (double) (this.b.width / 2.0F)));
+    }
+
+    public int a(PathPoint[] apathpoint, PathPoint pathpoint, PathPoint pathpoint1, float f) {
+        int i = 0;
+        int j = 0;
+        PathType pathtype = this.a(this.b, pathpoint.a, pathpoint.b + 1, pathpoint.c);
+
+        if (this.b.a(pathtype) >= 0.0F) {
+            j = MathHelper.d(Math.max(1.0F, this.b.P));
+        }
+
+        BlockPosition blockposition = (new BlockPosition(pathpoint.a, pathpoint.b, pathpoint.c)).down();
+        double d0 = (double) pathpoint.b - (1.0D - this.a.getType(blockposition).c(this.a, blockposition).e);
+        PathPoint pathpoint2 = this.a(pathpoint.a, pathpoint.b, pathpoint.c + 1, j, d0, EnumDirection.SOUTH);
+        PathPoint pathpoint3 = this.a(pathpoint.a - 1, pathpoint.b, pathpoint.c, j, d0, EnumDirection.WEST);
+        PathPoint pathpoint4 = this.a(pathpoint.a + 1, pathpoint.b, pathpoint.c, j, d0, EnumDirection.EAST);
+        PathPoint pathpoint5 = this.a(pathpoint.a, pathpoint.b, pathpoint.c - 1, j, d0, EnumDirection.NORTH);
+
+        if (pathpoint2 != null && !pathpoint2.i && pathpoint2.a(pathpoint1) < f) {
+            apathpoint[i++] = pathpoint2;
+        }
+
+        if (pathpoint3 != null && !pathpoint3.i && pathpoint3.a(pathpoint1) < f) {
+            apathpoint[i++] = pathpoint3;
+        }
+
+        if (pathpoint4 != null && !pathpoint4.i && pathpoint4.a(pathpoint1) < f) {
+            apathpoint[i++] = pathpoint4;
+        }
+
+        if (pathpoint5 != null && !pathpoint5.i && pathpoint5.a(pathpoint1) < f) {
+            apathpoint[i++] = pathpoint5;
+        }
+
+        boolean flag = pathpoint5 == null || pathpoint5.m == PathType.OPEN || pathpoint5.l != 0.0F;
+        boolean flag1 = pathpoint2 == null || pathpoint2.m == PathType.OPEN || pathpoint2.l != 0.0F;
+        boolean flag2 = pathpoint4 == null || pathpoint4.m == PathType.OPEN || pathpoint4.l != 0.0F;
+        boolean flag3 = pathpoint3 == null || pathpoint3.m == PathType.OPEN || pathpoint3.l != 0.0F;
+        PathPoint pathpoint6;
+
+        if (flag && flag3) {
+            pathpoint6 = this.a(pathpoint.a - 1, pathpoint.b, pathpoint.c - 1, j, d0, EnumDirection.NORTH);
+            if (pathpoint6 != null && !pathpoint6.i && pathpoint6.a(pathpoint1) < f) {
+                apathpoint[i++] = pathpoint6;
+            }
+        }
+
+        if (flag && flag2) {
+            pathpoint6 = this.a(pathpoint.a + 1, pathpoint.b, pathpoint.c - 1, j, d0, EnumDirection.NORTH);
+            if (pathpoint6 != null && !pathpoint6.i && pathpoint6.a(pathpoint1) < f) {
+                apathpoint[i++] = pathpoint6;
+            }
+        }
+
+        if (flag1 && flag3) {
+            pathpoint6 = this.a(pathpoint.a - 1, pathpoint.b, pathpoint.c + 1, j, d0, EnumDirection.SOUTH);
+            if (pathpoint6 != null && !pathpoint6.i && pathpoint6.a(pathpoint1) < f) {
+                apathpoint[i++] = pathpoint6;
+            }
+        }
+
+        if (flag1 && flag2) {
+            pathpoint6 = this.a(pathpoint.a + 1, pathpoint.b, pathpoint.c + 1, j, d0, EnumDirection.SOUTH);
+            if (pathpoint6 != null && !pathpoint6.i && pathpoint6.a(pathpoint1) < f) {
+                apathpoint[i++] = pathpoint6;
+            }
+        }
+
+        return i;
+    }
+
+    @Nullable
+    private PathPoint a(int i, int j, int k, int l, double d0, EnumDirection enumdirection) {
+        PathPoint pathpoint = null;
+        BlockPosition blockposition = new BlockPosition(i, j, k);
+        BlockPosition blockposition1 = blockposition.down();
+        double d1 = (double) j - (1.0D - this.a.getType(blockposition1).c(this.a, blockposition1).e);
+
+        if (d1 - d0 > 1.0D) {
+            return null;
+        } else {
+            PathType pathtype = this.a(this.b, i, j, k);
+            float f = this.b.a(pathtype);
+            double d2 = (double) this.b.width / 2.0D;
+
+            if (f >= 0.0F) {
+                pathpoint = this.a(i, j, k);
+                pathpoint.m = pathtype;
+                pathpoint.l = Math.max(pathpoint.l, f);
+            }
+
+            if (pathtype == PathType.WALKABLE) {
+                return pathpoint;
+            } else {
+                if (pathpoint == null && l > 0 && pathtype != PathType.FENCE && pathtype != PathType.TRAPDOOR) {
+                    pathpoint = this.a(i, j + 1, k, l - 1, d0, enumdirection);
+                    if (pathpoint != null && (pathpoint.m == PathType.OPEN || pathpoint.m == PathType.WALKABLE)) {
+                        double d3 = (double) (i - enumdirection.getAdjacentX()) + 0.5D;
+                        double d4 = (double) (k - enumdirection.getAdjacentZ()) + 0.5D;
+                        AxisAlignedBB axisalignedbb = new AxisAlignedBB(d3 - d2, (double) j + 0.001D, d4 - d2, d3 + d2, (double) ((float) j + this.b.length), d4 + d2);
+                        AxisAlignedBB axisalignedbb1 = this.a.getType(blockposition).c(this.a, blockposition);
+                        AxisAlignedBB axisalignedbb2 = axisalignedbb.a(0.0D, axisalignedbb1.e - 0.002D, 0.0D);
+
+                        if (this.b.world.b(axisalignedbb2)) {
+                            pathpoint = null;
+                        }
+                    }
+                }
+
+                if (pathtype == PathType.OPEN) {
+                    AxisAlignedBB axisalignedbb3 = new AxisAlignedBB((double) i - d2 + 0.5D, (double) j + 0.001D, (double) k - d2 + 0.5D, (double) i + d2 + 0.5D, (double) ((float) j + this.b.length), (double) k + d2 + 0.5D);
+
+                    if (this.b.world.b(axisalignedbb3)) {
+                        return null;
+                    }
+
+                    if (this.b.width >= 1.0F) {
+                        PathType pathtype1 = this.a(this.b, i, j - 1, k);
+
+                        if (pathtype1 == PathType.BLOCKED) {
+                            pathpoint = this.a(i, j, k);
+                            pathpoint.m = PathType.WALKABLE;
+                            pathpoint.l = Math.max(pathpoint.l, f);
+                            return pathpoint;
+                        }
+                    }
+
+                    int i1 = 0;
+
+                    while (j > 0 && pathtype == PathType.OPEN) {
+                        --j;
+                        if (i1++ >= this.b.aW()) {
+                            return null;
+                        }
+
+                        pathtype = this.a(this.b, i, j, k);
+                        f = this.b.a(pathtype);
+                        if (pathtype != PathType.OPEN && f >= 0.0F) {
+                            pathpoint = this.a(i, j, k);
+                            pathpoint.m = pathtype;
+                            pathpoint.l = Math.max(pathpoint.l, f);
+                            break;
+                        }
+
+                        if (f < 0.0F) {
+                            return null;
+                        }
+                    }
+                }
+
+                return pathpoint;
+            }
+        }
+    }
+
+    public PathType a(IBlockAccess iblockaccess, int i, int j, int k, EntityInsentient entityinsentient, int l, int i1, int j1, boolean flag, boolean flag1) {
+        EnumSet enumset = EnumSet.noneOf(PathType.class);
+        PathType pathtype = PathType.BLOCKED;
+        double d0 = (double) entityinsentient.width / 2.0D;
+        BlockPosition blockposition = new BlockPosition(entityinsentient);
+
+        for (int k1 = 0; k1 < l; ++k1) {
+            for (int l1 = 0; l1 < i1; ++l1) {
+                for (int i2 = 0; i2 < j1; ++i2) {
+                    int j2 = k1 + i;
+                    int k2 = l1 + j;
+                    int l2 = i2 + k;
+                    PathType pathtype1 = this.a(iblockaccess, j2, k2, l2);
+
+                    if (pathtype1 == PathType.DOOR_WOOD_CLOSED && flag && flag1) {
+                        pathtype1 = PathType.WALKABLE;
+                    }
+
+                    if (pathtype1 == PathType.DOOR_OPEN && !flag1) {
+                        pathtype1 = PathType.BLOCKED;
+                    }
+
+                    if (pathtype1 == PathType.RAIL && !(iblockaccess.getType(blockposition).getBlock() instanceof BlockMinecartTrackAbstract) && !(iblockaccess.getType(blockposition.down()).getBlock() instanceof BlockMinecartTrackAbstract)) {
+                        pathtype1 = PathType.FENCE;
+                    }
+
+                    if (k1 == 0 && l1 == 0 && i2 == 0) {
+                        pathtype = pathtype1;
+                    }
+
+                    enumset.add(pathtype1);
+                }
+            }
+        }
+
+        if (enumset.contains(PathType.FENCE)) {
+            return PathType.FENCE;
+        } else {
+            PathType pathtype2 = PathType.BLOCKED;
+            Iterator iterator = enumset.iterator();
+
+            while (iterator.hasNext()) {
+                PathType pathtype3 = (PathType) iterator.next();
+
+                if (entityinsentient.a(pathtype3) < 0.0F) {
+                    return pathtype3;
+                }
+
+                if (entityinsentient.a(pathtype3) >= entityinsentient.a(pathtype2)) {
+                    pathtype2 = pathtype3;
+                }
+            }
+
+            if (pathtype == PathType.OPEN && entityinsentient.a(pathtype2) == 0.0F) {
+                return PathType.OPEN;
+            } else {
+                return pathtype2;
+            }
+        }
+    }
+
+    private PathType a(EntityInsentient entityinsentient, BlockPosition blockposition) {
+        return this.a(entityinsentient, blockposition.getX(), blockposition.getY(), blockposition.getZ());
+    }
+
+    private PathType a(EntityInsentient entityinsentient, int i, int j, int k) {
+        return this.a(this.a, i, j, k, entityinsentient, this.d, this.e, this.f, this.d(), this.c());
+    }
+
+    public PathType a(IBlockAccess iblockaccess, int i, int j, int k) {
+        PathType pathtype = this.b(iblockaccess, i, j, k);
+
+        if (pathtype == PathType.OPEN && j >= 1) {
+            PathType pathtype1 = this.b(iblockaccess, i, j - 1, k);
+
+            pathtype = pathtype1 != PathType.WALKABLE && pathtype1 != PathType.OPEN && pathtype1 != PathType.WATER && pathtype1 != PathType.LAVA ? PathType.WALKABLE : PathType.OPEN;
+        }
+
+        BlockPosition.PooledBlockPosition blockposition_pooledblockposition = BlockPosition.PooledBlockPosition.s();
+
+        if (pathtype == PathType.WALKABLE) {
+            for (int l = -1; l <= 1; ++l) {
+                for (int i1 = -1; i1 <= 1; ++i1) {
+                    if (l != 0 || i1 != 0) {
+                        Block block = iblockaccess.getType(blockposition_pooledblockposition.f(l + i, j, i1 + k)).getBlock();
+
+                        if (block == Blocks.CACTUS) {
+                            pathtype = PathType.DANGER_CACTUS;
+                        } else if (block == Blocks.FIRE) {
+                            pathtype = PathType.DANGER_FIRE;
+                        }
+                    }
+                }
+            }
+        }
+
+        blockposition_pooledblockposition.t();
+        return pathtype;
+    }
+
+    private PathType b(IBlockAccess iblockaccess, int i, int j, int k) {
+        BlockPosition blockposition = new BlockPosition(i, j, k);
+        IBlockData iblockdata = iblockaccess.getType(blockposition);
+        Block block = iblockdata.getBlock();
+        Material material = iblockdata.getMaterial();
+
+        return material == Material.AIR ? PathType.OPEN : (block != Blocks.TRAPDOOR && block != Blocks.IRON_TRAPDOOR && block != Blocks.WATERLILY ? (block == Blocks.FIRE ? PathType.DAMAGE_FIRE : (block == Blocks.CACTUS ? PathType.DAMAGE_CACTUS : (block instanceof BlockDoor && material == Material.WOOD && !((Boolean) iblockdata.get(BlockDoor.OPEN)).booleanValue() ? PathType.DOOR_WOOD_CLOSED : (block instanceof BlockDoor && material == Material.ORE && !((Boolean) iblockdata.get(BlockDoor.OPEN)).booleanValue() ? PathType.DOOR_IRON_CLOSED : (block instanceof BlockDoor && ((Boolean) iblockdata.get(BlockDoor.OPEN)).booleanValue() ? PathType.DOOR_OPEN : (block instanceof BlockMinecartTrackAbstract ? PathType.RAIL : (!(block instanceof BlockFence) && !(block instanceof BlockCobbleWall) && (!(block instanceof BlockFenceGate) || ((Boolean) iblockdata.get(BlockFenceGate.OPEN)).booleanValue()) ? (material == Material.WATER ? PathType.WATER : (material == Material.LAVA ? PathType.LAVA : (block.b(iblockaccess, blockposition) ? PathType.OPEN : PathType.BLOCKED))) : PathType.FENCE))))))) : PathType.TRAPDOOR);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index 308d73e..9972005 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -52,7 +52,6 @@ public abstract class World implements IBlockAccess {
     protected boolean d;
     // Spigot start - guard entity list from removals
 	protected boolean cancelHeavyCalculations = false;
-	public boolean instantBlockFall;
 	public final List<Entity> entityList = Lists.newCopyOnWriteArrayList(); // Hose
 	/*
     public final List<Entity> entityList = new java.util.ArrayList<Entity>()
@@ -827,7 +826,17 @@ public abstract class World implements IBlockAccess {
 
     // Paper start - reduces need to do isLoaded before getType
     public IBlockData getTypeIfLoaded(BlockPosition blockposition) {
-        if (captureTreeGeneration) return findCaptured(blockposition); // use seperate findCaptured() method
+        // CraftBukkit start - tree generation
+        if (captureTreeGeneration) {
+            Iterator<BlockState> it = capturedBlockStates.iterator();
+            while (it.hasNext()) {
+                BlockState previous = it.next();
+                if (previous.getX() == blockposition.getX() && previous.getY() == blockposition.getY() && previous.getZ() == blockposition.getZ()) {
+                    return CraftMagicNumbers.getBlock(previous.getTypeId()).fromLegacyData(previous.getRawData());
+                }
+            }
+        }
+        // CraftBukkit end
         Chunk chunk = this.getChunkIfLoaded(blockposition);
         if (chunk != null) {
             return blockposition.isValidLocation() ? chunk.getBlockData(blockposition) : Blocks.AIR.getBlockData();
@@ -836,44 +845,30 @@ public abstract class World implements IBlockAccess {
     }
     // Paper end
 
-    // Paper start - optimize getType
-    // hoist tree generation into a seperate method to assist inlining
-    public IBlockData getType(BlockPosition pos) {
-        return getType(pos, this.captureTreeGeneration);
-    }
-
-    private IBlockData findCaptured(BlockPosition blockposition) {
+    public IBlockData getType(BlockPosition blockposition) {
         // CraftBukkit start - tree generation
 		// Paper start - optimize getType lookup to reduce instructions - getBlockData already enforces valid Y, move tree out
         final int x = blockposition.getX();
         final int y = blockposition.getY();
         final int z = blockposition.getZ();
-		Iterator<BlockState> it = capturedBlockStates.iterator();
-        while (it.hasNext()) {
-            final IBlockData previous = getCapturedBlockType(x, y, z);
-            if (previous != null) {
-                return previous;
+		if (captureTreeGeneration) {
+            Iterator<BlockState> it = capturedBlockStates.iterator();
+            while (it.hasNext()) {
+                BlockState previous = it.next();
+                if (previous.getX() == blockposition.getX() && previous.getY() == blockposition.getY() && previous.getZ() == blockposition.getZ()) {
+                    return CraftMagicNumbers.getBlock(previous.getTypeId()).fromLegacyData(previous.getRawData());
+                }
             }
 		}
         // CraftBukkit end
-        return getType(blockposition, captureTreeGeneration);
-    }
-	
-	public IBlockData getType(BlockPosition blockposition, boolean captureTreeGeneration) {
-        if (captureTreeGeneration) {
-            // CraftBukkit end
-            return findCaptured(blockposition); // Move into seperate method to assist inlining
-         }
-        if (blockposition.isValidLocation()) { // Paper
+        if (!blockposition.isValidLocation()) { // Paper
+            return Blocks.AIR.getBlockData();
+        } else {
             Chunk chunk = this.getChunkAtWorldCoords(blockposition);
-            ChunkSection chunksection = chunk.getSections()[blockposition.getY() >> 4];
-            if (chunksection != null) {
-                return chunksection.getType(blockposition.getX() & 15, blockposition.getY() & 15, blockposition.getZ() & 15);
-            }
-        }
-        return Blocks.AIR.getBlockData();
-     }
-    // Paper end
+			
+			return chunk.getBlockData(blockposition);
+		}
+    }
 	
 	// Paper start
     private IBlockData getCapturedBlockType(int x, int y, int z) {
@@ -2141,6 +2136,10 @@ public abstract class World implements IBlockAccess {
     }
 
     public boolean a(AxisAlignedBB axisalignedbb, Material material) {
+		return this.a(this, axisalignedbb, material);
+    }
+
+    public boolean a(IBlockAccess iblockaccess, AxisAlignedBB axisalignedbb, Material material) {
         int i = MathHelper.floor(axisalignedbb.a);
         int j = MathHelper.f(axisalignedbb.d);
         int k = MathHelper.floor(axisalignedbb.b);
@@ -2152,7 +2151,7 @@ public abstract class World implements IBlockAccess {
         for (int k1 = i; k1 < j; ++k1) {
             for (int l1 = k; l1 < l; ++l1) {
                 for (int i2 = i1; i2 < j1; ++i2) {
-                    if (this.getType(blockposition_pooledblockposition.f(k1, l1, i2)).getMaterial() == material) {
+					if (iblockaccess.getType(blockposition_pooledblockposition.f(k1, l1, i2)).getMaterial() == material) {
                         blockposition_pooledblockposition.t();
                         return true;
                     }
diff --git a/src/main/java/org/bukkit/inventory/InventoryView.java b/src/main/java/org/bukkit/inventory/InventoryView.java
index 8fae28b..e37cb9b 100644
--- a/src/main/java/org/bukkit/inventory/InventoryView.java
+++ b/src/main/java/org/bukkit/inventory/InventoryView.java
@@ -48,6 +48,27 @@ public abstract class InventoryView {
          * value.
          */
         ENCHANT_BUTTON2(1, InventoryType.ENCHANTING),
+		ENCHANT_ID1(4, InventoryType.ENCHANTING),
+        /**
+         * In an enchanting inventory, the middle button's enchantment's id
+         */
+        ENCHANT_ID2(5, InventoryType.ENCHANTING),
+        /**
+         * In an enchanting inventory, the bottom button's enchantment's id
+         */
+        ENCHANT_ID3(6, InventoryType.ENCHANTING),
+        /**
+         * In an enchanting inventory, the top button's level value.
+         */
+        ENCHANT_LEVEL1(7, InventoryType.ENCHANTING),
+        /**
+         * In an enchanting inventory, the middle button's level value.
+         */
+        ENCHANT_LEVEL2(8, InventoryType.ENCHANTING),
+        /**
+         * In an enchanting inventory, the bottom button's level value.
+         */
+        ENCHANT_LEVEL3(9, InventoryType.ENCHANTING),
         /**
          * In an enchanting inventory, the bottom button's experience level
          * value.
@@ -77,8 +98,11 @@ public abstract class InventoryView {
          */
         ENCHANT_ID_AND_LEVEL3(6, InventoryType.ENCHANTING),
         POWER_LEVEL(0, InventoryType.BEACON),
+		LEVELS(0, InventoryType.BEACON),
         POTION_EFFECT1(1, InventoryType.BEACON),
         POTION_EFFECT2(2, InventoryType.BEACON),
+		SECONDARY_EFFECT(2, InventoryType.BEACON),
+		PRIMARY_EFFECT(1, InventoryType.BEACON),
         /**
          * The repair's cost in xp levels
          */
diff --git a/src/main/resources/configurations/migot.yml b/src/main/resources/configurations/migot.yml
index 3134ddd..1954307 100644
--- a/src/main/resources/configurations/migot.yml
+++ b/src/main/resources/configurations/migot.yml
@@ -1 +1,27 @@
-general-settings:
\ No newline at end of file
+general-settings:
+async-pathsearches:
+    enabled: true
+    threadPoolSize: 1
+    minimumDistanceToTarget: 0.0
+    entities:
+    - BAT
+    - BLAZE
+    - CHICKEN
+    - COW
+    - CREEPER
+    - ENDERMAN
+    - HORSE
+    - IRON_GOLEM
+    - MAGMA_CUBE
+    - MUSHROOM_COW
+    - PIG
+    - PIG_ZOMBIE
+    - RABBIT
+    - SHEEP
+    - SKELETON
+    - SILVERFISH
+    - SLIME
+    - SNOWMAN
+    - SQUID
+    - WITCH
+    - ZOMBIE
\ No newline at end of file
-- 
2.8.2.windows.1

