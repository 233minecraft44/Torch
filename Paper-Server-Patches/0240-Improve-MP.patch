From 346ae5731c5d18e98ef7907ad2eb58179536af2e Mon Sep 17 00:00:00 2001
From: SotrForgotten <i@omc.hk>
Date: Fri, 2 Sep 2016 21:08:04 +0800
Subject: [PATCH] Improve MP


diff --git a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
index c9bc5ab..9882a8f 100644
--- a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
+++ b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
@@ -7,8 +7,6 @@ import org.bukkit.Bukkit;
 import org.bukkit.configuration.file.YamlConfiguration;
 import org.spigotmc.SpigotWorldConfig;
 
-import com.destroystokyo.paper.antixray.AntiXray;
-
 public class PaperWorldConfig {
 
 	private final String worldName;
diff --git a/src/main/java/com/destroystokyo/paper/antixray/AntiXray.java b/src/main/java/com/destroystokyo/paper/antixray/AntiXray.java
deleted file mode 100644
index 2b739dc..0000000
--- a/src/main/java/com/destroystokyo/paper/antixray/AntiXray.java
+++ /dev/null
@@ -1,323 +0,0 @@
-package com.destroystokyo.paper.antixray;
-
-import java.util.HashSet;
-import java.util.Set;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-
-import com.destroystokyo.paper.PaperWorldConfig;
-
-import net.minecraft.server.Block;
-import net.minecraft.server.BlockPosition;
-import net.minecraft.server.Blocks;
-import net.minecraft.server.Chunk;
-import net.minecraft.server.ChunkSection;
-import net.minecraft.server.DataBits;
-import net.minecraft.server.DataPaletteBlock;
-import net.minecraft.server.IBlockData;
-import net.minecraft.server.PacketDataSerializer;
-import net.minecraft.server.PacketPlayOutMapChunk;
-import net.minecraft.server.World;
-
-public class AntiXray {
-	private static final ExecutorService executorService = Executors.newSingleThreadExecutor();
-	private final boolean antiXray;
-	private final int engineMode;
-	private final int maxChunkY;
-	private final boolean asynchronous;
-	private final int neighborsMode;
-	// Used to keep track of which blocks to obfuscate
-	private final boolean[] obfuscateBlocks = new boolean[Short.MAX_VALUE];
-	// Used to select a random replacement ore
-	private final IBlockData[] replacementOres;
-
-	public AntiXray(PaperWorldConfig config) {
-		antiXray = config.antiXray;
-		engineMode = config.engineMode;
-		maxChunkY = config.maxChunkY;
-		asynchronous = config.asynchronous;
-		neighborsMode = config.neighborsMode;
-		// Set all listed blocks as true to be obfuscated
-		for (Object id : (engineMode == 1) ? config.hiddenBlocks : config.replaceBlocks) {
-			Block block = Block.getByName(String.valueOf(id));
-
-			if (block != null) {
-				int intId = Block.getId(block);
-				obfuscateBlocks[intId] = true;
-			}
-		}
-
-		Set<IBlockData> replacementOreList = new HashSet<IBlockData>();
-
-		for (Object id : config.hiddenBlocks) {
-			Block block = Block.getByName(String.valueOf(id));
-			// Check it exists and is not a tile entity
-			if (block != null && !block.isTileEntity()) {
-				// Add it to the list of replacement blocks
-				replacementOreList.add(block.getBlockData());
-			}
-		}
-
-		replacementOres = replacementOreList.toArray(new IBlockData[replacementOreList.size()]);
-	}
-
-	public IBlockData[] getPredefinedBlockData(Chunk chunk, int chunkY) {
-		if (antiXray && chunkY <= maxChunkY) {
-			switch (engineMode) {
-			case 1:
-				switch (chunk.world.getWorld().getEnvironment()) {
-				case NETHER:
-					return new IBlockData[] { Blocks.NETHERRACK.getBlockData() };
-				case THE_END:
-					return new IBlockData[] { Blocks.END_STONE.getBlockData() };
-				default:
-					return new IBlockData[] { Blocks.STONE.getBlockData() };
-				}
-			case 2:
-			case 3:
-				return replacementOres;
-			}
-		}
-
-		return null;
-	}
-
-	public boolean onPacketCreate(Chunk chunk, int chunkSectionSelector) {
-		if (antiXray) {
-			if (neighborsMode == 1) {
-				return true;
-			} else if (neighborsMode == 2) {
-				if (chunk.world.getChunkIfLoaded(chunk.locX - 1, chunk.locZ) == null
-						|| chunk.world.getChunkIfLoaded(chunk.locX + 1, chunk.locZ) == null
-						|| chunk.world.getChunkIfLoaded(chunk.locX, chunk.locZ - 1) == null
-						|| chunk.world.getChunkIfLoaded(chunk.locX, chunk.locZ + 1) == null) {
-					return false;
-				} else {
-					return true;
-				}
-			} else if (neighborsMode == 3) {
-				chunk.world.getChunkAt(chunk.locX - 1, chunk.locZ);
-				chunk.world.getChunkAt(chunk.locX + 1, chunk.locZ);
-				chunk.world.getChunkAt(chunk.locX, chunk.locZ - 1);
-				chunk.world.getChunkAt(chunk.locX, chunk.locZ + 1);
-				return true;
-			}
-		}
-
-		return true;
-	}
-
-	public void createPacket(PacketPlayOutMapChunk packetPlayOutMapChunk, PacketDataSerializer packetDataSerializer,
-			Chunk chunk, boolean writeSkyLightArray, int chunkSectionSelector) {
-		if (antiXray) {
-			Chunk[] nearbyChunks = { chunk.world.getChunkIfLoaded(chunk.locX - 1, chunk.locZ),
-					chunk.world.getChunkIfLoaded(chunk.locX + 1, chunk.locZ),
-					chunk.world.getChunkIfLoaded(chunk.locX, chunk.locZ - 1),
-					chunk.world.getChunkIfLoaded(chunk.locX, chunk.locZ + 1) };
-
-			if (asynchronous) {
-				executorService.execute(new ObfuscatorRunnable(packetPlayOutMapChunk, packetDataSerializer, chunk,
-						writeSkyLightArray, chunkSectionSelector, nearbyChunks));
-			} else {
-				packetPlayOutMapChunk.setWrittenChunkSections(packetPlayOutMapChunk.a(packetDataSerializer, chunk,
-						writeSkyLightArray, chunkSectionSelector, nearbyChunks));
-				packetPlayOutMapChunk.setReady(true);
-			}
-		} else {
-			packetPlayOutMapChunk.setWrittenChunkSections(packetPlayOutMapChunk.a(packetDataSerializer, chunk,
-					writeSkyLightArray, chunkSectionSelector, null));
-			packetPlayOutMapChunk.setReady(true);
-		}
-	}
-
-	public void serializeOrObfuscate(PacketDataSerializer packetDataSerializer, Chunk chunk, int chunkY,
-			DataPaletteBlock dataPaletteBlock, DataBits dataBits, Chunk[] nearbyChunks) {
-		long[] dataBitsArray = dataBits.a();
-
-		if (antiXray && chunkY <= maxChunkY && dataPaletteBlock.getCurrentPredefinedBlockData() != null
-				&& dataPaletteBlock.getCurrentPredefinedBlockData().length > 0 && nearbyChunks != null) {
-			// The iterator marking which random ore we should use next
-			int randomOre = 0;
-			// Boolean used to check if the engine mode is 3 (used for the
-			// initial value of x in the inner loop)
-			boolean engineMode3 = engineMode == 3;
-			// Increment the inner loop by 3 in engine mode 3 for more
-			// efficiency
-			int increment = engineMode3 ? 3 : 1;
-			// Stores the last dataBits-array-index which was obfuscated
-			int dataBitsIndex = 0;
-			// Stores the last data which was obfuscated but not written to the
-			// packet
-			long currentData = dataBitsArray[0];
-			// Write the length of the dataBits-array to the packet as it is in
-			// vanilla
-			packetDataSerializer.d(dataBitsArray.length);
-			// Optimization: Don't try to obfuscate edge blocks of this section
-			// if neighbor sections are not loaded or don't exist
-			// We can also add a check for ChunkSection#nonEmptyBlockCount == 0
-			// here
-			int xMin = nearbyChunks[0] == null || nearbyChunks[0].getSections()[chunkY] == Chunk.a ? 1 : 0;
-			int xMax = nearbyChunks[1] == null || nearbyChunks[1].getSections()[chunkY] == Chunk.a ? 15 : 16;
-			int zMin = nearbyChunks[2] == null || nearbyChunks[2].getSections()[chunkY] == Chunk.a ? 1 : 0;
-			int zMax = nearbyChunks[3] == null || nearbyChunks[3].getSections()[chunkY] == Chunk.a ? 15 : 16;
-			int yMin = chunkY == 0 || chunk.getSections()[chunkY - 1] == Chunk.a ? 1 : 0;
-			int yMax = chunkY == chunk.getSections().length - 1 || chunk.getSections()[chunkY + 1] == Chunk.a ? 15 : 16;
-			// Write the dataBits-array to the packet
-			// Work through all blocks in the chunkSection
-			for (int y = yMin; y < yMax; y++) {
-				for (int z = zMin; z < zMax; z++) {
-					// Shift the initial value of x and increment by 3 in engine
-					// mode 3
-					int x;
-
-					if (engineMode3) {
-						x = (y + z) % 3;
-
-						if (x < xMin) {
-							x += 3;
-						}
-					} else {
-						x = xMin;
-					}
-
-					for (; x < xMax; x += increment) {
-						// Calculate the blockIndex from y, z, x and get the
-						// blockData from dataPaletteBlock
-						// More efficient because we may use the blockIndex
-						// again later
-						int blockIndex = y << 8 | z << 4 | x;
-						IBlockData blockData = dataPaletteBlock.a(blockIndex);
-						// Check if the block should be obfuscated
-						if (obfuscateBlocks[Block.getId(blockData.getBlock())]) {
-							// Check if the nearby blocks are not transparent,
-							// we can obfuscate
-							if (isHiddenBlock(x, y, z, chunk, chunkY, nearbyChunks)) {
-								// Get one of the predefined blocks which can be
-								// used for obfuscation
-								if (randomOre >= dataPaletteBlock.getCurrentPredefinedBlockData().length) {
-									randomOre = 0;
-								}
-
-								int newBlockData = dataPaletteBlock.getCurrentPredefinedBlockData()[randomOre++];
-								// Get the current dataBits-array-index for the
-								// block index
-								int currentDataBitsIndex = dataBits.getArrayIndex(blockIndex);
-								// Check if it has been changed
-								if (currentDataBitsIndex != dataBitsIndex) {
-									// If so, we can write the last obfuscated
-									// data to the packet because it is finished
-									// with the obfuscation
-									packetDataSerializer.writeLong(currentData);
-									dataBitsIndex++;
-									// We can also write all further content of
-									// the dataBits-array to the packet (until
-									// currentDataBitsIndex is reached)
-									// because they didn't change
-									while (dataBitsIndex < currentDataBitsIndex) {
-										packetDataSerializer.writeLong(dataBitsArray[dataBitsIndex]);
-										dataBitsIndex++;
-									}
-									// Now we get the data which has to be
-									// obfuscated
-									currentData = dataBitsArray[dataBitsIndex];
-								}
-								// Obfuscate currentData
-								currentData = dataBits.obfuscate(blockIndex, newBlockData, currentData);
-								// Check if the data of the current block is
-								// spitted to the next dataBits-array-index
-								if (dataBits.isSplitted(blockIndex, dataBitsIndex)) {
-									// If so, we can write currentData to the
-									// packet because it is finished with the
-									// obfuscation
-									packetDataSerializer.writeLong(currentData);
-									dataBitsIndex++;
-									// Get the data at the next index
-									currentData = dataBitsArray[dataBitsIndex];
-									// And obfuscate it
-									currentData = dataBits.obfuscateSplittedPart(blockIndex, newBlockData, currentData);
-								}
-							}
-						}
-					}
-				}
-			}
-			// Write the rest of the dataBits-array to the packet
-			packetDataSerializer.writeLong(currentData);
-			dataBitsIndex++;
-
-			while (dataBitsIndex < dataBitsArray.length) {
-				packetDataSerializer.writeLong(dataBitsArray[dataBitsIndex]);
-				dataBitsIndex++;
-			}
-		} else {
-			packetDataSerializer.a(dataBitsArray);
-		}
-	}
-
-	public void updateNearbyBlocks(World world, BlockPosition position) {
-		if (antiXray) {
-			// 2 is the radius, we shouldn't change it as that would make it
-			// exponentially slower
-			updateNearbyBlocks(world, position, 2, false);
-		}
-	}
-
-	private void updateNearbyBlocks(World world, BlockPosition position, int radius, boolean updateSelf) {
-		// If the block in question is loaded
-		if (world.isLoaded(position)) {
-			// Get block id
-			Block block = world.getType(position).getBlock();
-			// See if it needs update
-			if (updateSelf && obfuscateBlocks[Block.getId(block)]) {
-				// Send the update
-				world.notify(position);
-			}
-			// Check other blocks for updates
-			if (radius > 0) {
-				updateNearbyBlocks(world, position.east(), radius - 1, true);
-				updateNearbyBlocks(world, position.west(), radius - 1, true);
-				updateNearbyBlocks(world, position.up(), radius - 1, true);
-				updateNearbyBlocks(world, position.down(), radius - 1, true);
-				updateNearbyBlocks(world, position.south(), radius - 1, true);
-				updateNearbyBlocks(world, position.north(), radius - 1, true);
-			}
-		}
-	}
-
-	private static boolean isHiddenBlock(int x, int y, int z, Chunk chunk, int chunkY, Chunk[] nearbyChunks) {
-		return isSolidBlock(getType(x, y + 1, z, chunk, chunkY, nearbyChunks).getBlock())
-				&& isSolidBlock(getType(x + 1, y, z, chunk, chunkY, nearbyChunks).getBlock())
-				&& isSolidBlock(getType(x - 1, y, z, chunk, chunkY, nearbyChunks).getBlock())
-				&& isSolidBlock(getType(x, y, z + 1, chunk, chunkY, nearbyChunks).getBlock())
-				&& isSolidBlock(getType(x, y, z - 1, chunk, chunkY, nearbyChunks).getBlock())
-				&& isSolidBlock(getType(x, y - 1, z, chunk, chunkY, nearbyChunks).getBlock());
-	}
-
-	private static IBlockData getType(int x, int y, int z, Chunk chunk, int chunkY, Chunk[] nearbyChunks) {
-		if (x < 0) {
-			chunk = nearbyChunks[0];
-		} else if (x > 15) {
-			chunk = nearbyChunks[1];
-		} else if (z < 0) {
-			chunk = nearbyChunks[2];
-		} else if (z > 15) {
-			chunk = nearbyChunks[3];
-		}
-
-		int blockY = (chunkY << 4) + y;
-
-		if (blockY >= 0 && blockY >> 4 < chunk.getSections().length) {
-			ChunkSection chunkSection = chunk.getSections()[blockY >> 4];
-
-			if (chunkSection != Chunk.a) {
-				return chunkSection.getType(x & 15, y & 15, z & 15);
-			}
-		}
-
-		return Blocks.AIR.getBlockData();
-	}
-
-	private static boolean isSolidBlock(Block block) {
-		return block.isOccluding(block.getBlockData()) && block != Blocks.MOB_SPAWNER && block != Blocks.BARRIER;
-	}
-}
\ No newline at end of file
diff --git a/src/main/java/com/destroystokyo/paper/antixray/BlockPacketController.java b/src/main/java/com/destroystokyo/paper/antixray/BlockPacketController.java
index 8a0f154..ee1d4a9 100644
--- a/src/main/java/com/destroystokyo/paper/antixray/BlockPacketController.java
+++ b/src/main/java/com/destroystokyo/paper/antixray/BlockPacketController.java
@@ -16,7 +16,7 @@ import net.minecraft.server.World;
 public class BlockPacketController implements IBlockPacketController {
 
     private static BlockPacketController instance = null;
-    private final Lock noOpLock;
+    protected final Lock noOpLock;
 
     /**
      * Protected constructor for invocation by subclass constructors.
diff --git a/src/main/java/com/destroystokyo/paper/antixray/BlockPacketControllerObfuscate.java b/src/main/java/com/destroystokyo/paper/antixray/BlockPacketControllerObfuscate.java
index 49a56c5..bb35ac6 100644
--- a/src/main/java/com/destroystokyo/paper/antixray/BlockPacketControllerObfuscate.java
+++ b/src/main/java/com/destroystokyo/paper/antixray/BlockPacketControllerObfuscate.java
@@ -19,29 +19,20 @@ import net.minecraft.server.PacketPlayOutMapChunk;
 import net.minecraft.server.PacketDataSerializer;
 import net.minecraft.server.World;
 
- /**
-  * BlockPacketControllerObfuscate is an implementation of the interface IBlockPacketController which aims to obfuscate blocks which are sent with chunk packets.
-  */
- public class BlockPacketControllerObfuscate implements IBlockPacketController {
- 
-    private static ExecutorService executorServiceInstance = null;
-    protected ExecutorService executorService = null;
-    protected Lock noOpLock = null;
-    protected boolean asynchronous = true;
-    protected int engineMode = 3;
-    protected int neighborsMode = 1;
-    protected int maxChunkY = 3;
-    protected final boolean[] obfuscateBlocks = new boolean[Short.MAX_VALUE];
-    protected IBlockData[] replacementOres = null;
+/**
+ * BlockPacketControllerObfuscate is an implementation of the interface IBlockPacketController which aims to obfuscate blocks which are sent with chunk packets.
+ */
+public class BlockPacketControllerObfuscate implements IBlockPacketController {
 
-    /**
-     * Protected constructor for invocation by subclass constructors.
-     * Use this constructor to prevent unnecessary intantiation of the Lock and ExecutorService singletons
-     * incase of overriding for example getChunkBlocksLock(Chunk chunk) and getChunkDataLock(Chunk chunk).
-     */
-    protected BlockPacketControllerObfuscate() {
-
-    }
+    private static ExecutorService executorServiceInstance = null;
+    protected final ExecutorService executorService;
+    protected final Lock noOpLock;
+    protected final boolean asynchronous;
+    protected final int engineMode;
+    protected final int neighborsMode;
+    protected final int maxChunkY;
+    protected final boolean[] obfuscateBlocks;
+    protected final IBlockData[] replacementOres;
 
     /**
      * Public (normal) constructor.
@@ -53,10 +44,13 @@ import net.minecraft.server.World;
         engineMode = config.engineMode;
         neighborsMode = config.neighborsMode;
         maxChunkY = config.maxChunkY;
+        obfuscateBlocks = new boolean[Short.MAX_VALUE];
 
         if (asynchronous) {
             executorService = getExecutorServiceInstance();
+            noOpLock = null;
         } else {
+            executorService = null;
             noOpLock = Lock.getNoOpInstance();
         }
 
@@ -83,6 +77,31 @@ import net.minecraft.server.World;
     }
 
     /**
+     * Protected constructor for invocation by subclass constructors.
+     * Use this constructor to prevent unnecessary intantiation of the Lock and ExecutorService singletons
+     * incase of overriding for example getChunkBlocksLock(Chunk chunk) and getChunkDataLock(Chunk chunk).
+     *
+     * @param executorService The executor service used by this class
+     * @param lock The lock instance used or returned by this class if asynchronous is false
+     * @param asynchronous Whether or not obfuscate asynchronous
+     * @param engineMode The engine mode (1 = replace ores, 2 = fake ores, 3 = fake ores every third block)
+     * @param neighborsMode The neighbors mode (1 = don't load, 2 = wait until loaded, 3 = load)
+     * @param maxChunkY The maximum chunk section coordinate for obfuscating (= (maxChunkY + 1) * 16 blocks)
+     * @param obfuscateBlocks The blocks which should be obfuscated
+     * @param replacementOres The blocks (ores) which are used in engine mode 2 and 3 to replace hidden blocks
+     */
+    protected BlockPacketControllerObfuscate(ExecutorService executorService, Lock lock, boolean asynchronous, int engineMode, int neighborsMode, int maxChunkY, boolean[] obfuscateBlocks, IBlockData[] replacementOres) {
+        this.executorService = executorService;
+        noOpLock = lock;
+        this.asynchronous = asynchronous;
+        this.engineMode = engineMode;
+        this.neighborsMode = neighborsMode;
+        this.maxChunkY = maxChunkY;
+        this.obfuscateBlocks = obfuscateBlocks;
+        this.replacementOres = replacementOres;
+    }
+
+    /**
      * Thread-safe (synchronized) singleton getter.
      *
      * @return The singleton instance of the executor service (Executors.newSingleThreadExecutor())
@@ -192,7 +211,7 @@ import net.minecraft.server.World;
         Chunk[] nearbyChunks = {chunk.world.getChunkIfLoaded(chunk.locX - 1, chunk.locZ), chunk.world.getChunkIfLoaded(chunk.locX + 1, chunk.locZ), chunk.world.getChunkIfLoaded(chunk.locX, chunk.locZ - 1), chunk.world.getChunkIfLoaded(chunk.locX, chunk.locZ + 1)};
 
         if (asynchronous) {
-            executorService.execute(new ObfuscatorRunnable(packetPlayOutMapChunk, packetDataSerializer, chunk, writeSkyLightArray, chunkSectionSelector, nearbyChunks));
+            executorService.execute(new ChunkPacketRunnable(packetPlayOutMapChunk, packetDataSerializer, chunk, writeSkyLightArray, chunkSectionSelector, nearbyChunks));
         } else {
             packetPlayOutMapChunk.setWrittenChunkSections(packetPlayOutMapChunk.a(packetDataSerializer, chunk, writeSkyLightArray, chunkSectionSelector, nearbyChunks));
             packetPlayOutMapChunk.setReady(true);
diff --git a/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketRunnable.java b/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketRunnable.java
new file mode 100644
index 0000000..61462e5
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketRunnable.java
@@ -0,0 +1,70 @@
+package com.destroystokyo.paper.antixray;
+
+import net.minecraft.server.Chunk;
+import net.minecraft.server.PacketDataSerializer;
+import net.minecraft.server.PacketPlayOutMapChunk;
+
+/**
+ * Runnable which runs the code for writing the blocks to the PacketDataSerializer of a PacketPlayOutMapChunk
+ */
+public class ChunkPacketRunnable implements Runnable {
+
+    private final PacketPlayOutMapChunk packetPlayOutMapChunk;
+    private final PacketDataSerializer packetDataSerializer;
+    private final Chunk chunk;
+    private final boolean writeSkyLightArray;
+    private final int chunkSectionSelector;
+    private final Chunk[] nearbyChunks;
+
+    /**
+     * The constructor applies the blocks lock and the data lock of the specified chunk and the blocks lock of the specified nearby chunks.
+     *
+     * @param packetPlayOutMapChunk The packet which is created
+     * @param packetDataSerializer The data serializer of the specified packet
+     * @param chunk The chunk which the packet is created for and should be written to the data serializer
+     * @param writeSkyLightArray Whether or not the sky light array should be written to the data serializer
+     * @param chunkSectionSelector The chunk sections which should be sent (each bit represents for one chunk section, the LSB represents the lowest chunk section, 0 = don't send, 1 = send)
+     * @param nearbyChunks An array with the length of 4 containing the chunks around the specified chunk or null if not loaded used for thread-safe chunk access (index 0 = x--, 1 = x++, 2 = z--, 3 = z++)
+     */
+    public ChunkPacketRunnable(PacketPlayOutMapChunk packetPlayOutMapChunk, PacketDataSerializer packetDataSerializer, Chunk chunk, boolean writeSkyLightArray, int chunkSectionSelector, Chunk[] nearbyChunks) {
+        chunk.blocksLock.lock();
+        chunk.dataLock.lock();
+
+        if (nearbyChunks != null) {
+            for (Chunk nearbyChunk : nearbyChunks) {
+                if (nearbyChunk != null) {
+                    nearbyChunk.blocksLock.lock();
+                }
+            }
+        }
+
+        this.packetPlayOutMapChunk = packetPlayOutMapChunk;
+        this.packetDataSerializer = packetDataSerializer;
+        this.chunk = chunk;
+        this.nearbyChunks = nearbyChunks;
+        this.writeSkyLightArray = writeSkyLightArray;
+        this.chunkSectionSelector = chunkSectionSelector;
+    }
+
+    /**
+     * The run method writes the chunk to the data serializer, sets the packet ready and unlocks the chunks.
+     */
+    @Override
+    public void run() {
+        try {
+            packetPlayOutMapChunk.setWrittenChunkSections(packetPlayOutMapChunk.a(packetDataSerializer, chunk, writeSkyLightArray, chunkSectionSelector, nearbyChunks));
+            packetPlayOutMapChunk.setReady(true);
+        } finally {
+            chunk.blocksLock.unlock();
+            chunk.dataLock.unlock();
+
+            if (nearbyChunks != null) {
+                for (Chunk nearbyChunk : nearbyChunks) {
+                    if (nearbyChunk != null) {
+                        nearbyChunk.blocksLock.unlock();
+                    }
+                }
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/com/destroystokyo/paper/antixray/ObfuscatorRunnable.java b/src/main/java/com/destroystokyo/paper/antixray/ObfuscatorRunnable.java
deleted file mode 100644
index 5d7f097..0000000
--- a/src/main/java/com/destroystokyo/paper/antixray/ObfuscatorRunnable.java
+++ /dev/null
@@ -1,55 +0,0 @@
-package com.destroystokyo.paper.antixray;
-
-import net.minecraft.server.Chunk;
-import net.minecraft.server.PacketDataSerializer;
-import net.minecraft.server.PacketPlayOutMapChunk;
-
-public class ObfuscatorRunnable implements Runnable {
-	private final PacketPlayOutMapChunk packetPlayOutMapChunk;
-	private final PacketDataSerializer packetDataSerializer;
-	private final Chunk chunk;
-	private final boolean writeSkyLightArray;
-	private final int chunkSectionSelector;
-	private final Chunk[] nearbyChunks;
-
-	public ObfuscatorRunnable(PacketPlayOutMapChunk packetPlayOutMapChunk, PacketDataSerializer packetDataSerializer,
-			Chunk chunk, boolean writeSkyLightArray, int chunkSectionSelector, Chunk[] nearbyChunks) {
-		chunk.blocksLock.lock();
-		chunk.dataLock.lock();
-
-		if (nearbyChunks != null) {
-			for (Chunk nearbyChunk : nearbyChunks) {
-				if (nearbyChunk != null) {
-					nearbyChunk.blocksLock.lock();
-				}
-			}
-		}
-
-		this.packetPlayOutMapChunk = packetPlayOutMapChunk;
-		this.packetDataSerializer = packetDataSerializer;
-		this.chunk = chunk;
-		this.nearbyChunks = nearbyChunks;
-		this.writeSkyLightArray = writeSkyLightArray;
-		this.chunkSectionSelector = chunkSectionSelector;
-	}
-
-	@Override
-	public void run() {
-		try {
-			packetPlayOutMapChunk.setWrittenChunkSections(packetPlayOutMapChunk.a(packetDataSerializer, chunk,
-					writeSkyLightArray, chunkSectionSelector, nearbyChunks));
-			packetPlayOutMapChunk.setReady(true);
-		} finally {
-			chunk.blocksLock.unlock();
-			chunk.dataLock.unlock();
-
-			if (nearbyChunks != null) {
-				for (Chunk nearbyChunk : nearbyChunks) {
-					if (nearbyChunk != null) {
-						nearbyChunk.blocksLock.unlock();
-					}
-				}
-			}
-		}
-	}
-}
\ No newline at end of file
diff --git a/src/main/java/com/mrpowergamerbr/parappatown/utils/LightStatic.java b/src/main/java/com/mrpowergamerbr/parappatown/utils/LightStatic.java
index 2a1856a..ec3e510 100644
--- a/src/main/java/com/mrpowergamerbr/parappatown/utils/LightStatic.java
+++ b/src/main/java/com/mrpowergamerbr/parappatown/utils/LightStatic.java
@@ -1,7 +1,6 @@
 package com.mrpowergamerbr.parappatown.utils;
 
 import java.util.Random;
-
 import com.mrpowergamerbr.utils.LightRandom;
 
 public class LightStatic {
diff --git a/src/main/java/net/minecraft/server/BlockRedstoneWire.java b/src/main/java/net/minecraft/server/BlockRedstoneWire.java
index 32adbc5..19dacba 100644
--- a/src/main/java/net/minecraft/server/BlockRedstoneWire.java
+++ b/src/main/java/net/minecraft/server/BlockRedstoneWire.java
@@ -1,9 +1,11 @@
 package net.minecraft.server;
 
 import java.util.Iterator;
+import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Random;
 import java.util.Set;
+import java.util.Collections;
 
 import javax.annotation.Nullable;
 
@@ -17,7 +19,7 @@ public class BlockRedstoneWire extends Block {
 
 	private List<BlockPosition> turnOff = Lists.newArrayList();
 	private List<BlockPosition> turnOn = Lists.newArrayList();
-	private final Set<BlockPosition> updatedRedstoneWire = Sets.newLinkedHashSet();
+	private final Set<BlockPosition> updatedRedstoneWire = Collections.synchronizedSet(new LinkedHashSet());
 	private static final EnumDirection[] facingsVertical = { EnumDirection.DOWN, EnumDirection.UP };
 	private static final EnumDirection[] facingsHorizontal = { EnumDirection.WEST, EnumDirection.EAST,
 			EnumDirection.NORTH, EnumDirection.SOUTH };
diff --git a/src/main/java/net/minecraft/server/BlockSnowBlock.java b/src/main/java/net/minecraft/server/BlockSnowBlock.java
new file mode 100644
index 0000000..dd05b68
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockSnowBlock.java
@@ -0,0 +1,35 @@
+package net.minecraft.server;
+
+import java.util.Random;
+import javax.annotation.Nullable;
+
+public class BlockSnowBlock extends Block {
+
+    protected BlockSnowBlock() {
+        super(Material.SNOW_BLOCK);
+        // this.a(true); // Paper - snow blocks don't need to tick
+        this.a(CreativeModeTab.b);
+    }
+
+    @Nullable
+    public Item getDropType(IBlockData iblockdata, Random random, int i) {
+        return Items.SNOWBALL;
+    }
+
+    public int a(Random random) {
+        return 4;
+    }
+
+    // Paper start - snow blocks don't need to tick
+    /*
+    public void b(World world, BlockPosition blockposition, IBlockData iblockdata, Random random) {
+        if (world.b(EnumSkyBlock.BLOCK, blockposition) > 11) {
+            this.b(world, blockposition, world.getType(blockposition), 0);
+            world.setAir(blockposition);
+        }
+
+    }
+    */
+    //Paper end
+    
+}
diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java
index c899cbb..63539cc 100644
--- a/src/main/java/net/minecraft/server/Chunk.java
+++ b/src/main/java/net/minecraft/server/Chunk.java
@@ -1,5 +1,6 @@
 package net.minecraft.server;
 
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.List;
@@ -16,6 +17,7 @@ import org.apache.logging.log4j.Logger;
 import org.bukkit.Server; // CraftBukkit
 import org.bukkit.craftbukkit.util.CraftMagicNumbers;
 import org.hose.ChunkPopulate_Pool;
+import org.spigotmc.SpigotWorldConfig;
 import org.torch.util.ConcurrentIterableArrayList;
 
 import com.destroystokyo.paper.antixray.Lock; // Paper - Async-Anti-Xray - Used to lock data which is used while creating chunk-packets asynchronously (those locks freeze the main thread but they occur very rare, worst case is "synchonous-anti-xray-behavior")
@@ -157,7 +159,7 @@ public class Chunk {
 
 						if (this.sections[j1] == Chunk.a) {
 							///
-                            this.sections[j1] = new ChunkSection(j1 << 4, flag, world.blockPacketController.getPredefinedBlockData(this, j1)); // Paper - Anti-Xray - Add blocks used for obfuscation to the DataPalette
+                            this.sections[j1] = new ChunkSection(this, j1 << 4, flag, world.blockPacketController.getPredefinedBlockData(this, j1)); // Paper - Anti-Xray - Add blocks used for obfuscation to the DataPalette
 							///
 						}
 
@@ -213,7 +215,8 @@ public class Chunk {
 	
 	public void initLighting() {
 		LightingTask task = new LightingTask();
-		task.fork();
+		SpigotWorldConfig.ChunkPool.execute(task);
+		// task.fork();
 	}
 
 	public void initLighting_task() {
@@ -257,7 +260,6 @@ public class Chunk {
 								ChunkSection chunksection = this.sections[i1 >> 4];
 
 								if (chunksection != Chunk.a) {
-									this.dataLock.waitUntilUnlock(); // Paper
 									chunksection.a(j, i1 & 15, k, l);
 									this.world.m(new BlockPosition((this.locX << 4) + j, i1, (this.locZ << 4) + k));
 								}
@@ -381,7 +383,6 @@ public class Chunk {
 					for (l1 = i1; l1 < l; ++l1) {
 						chunksection = this.sections[l1 >> 4];
 						if (chunksection != Chunk.a) {
-							this.dataLock.waitUntilUnlock(); // Paper
 							chunksection.a(i, l1 & 15, k, 15);
 							this.world.m(new BlockPosition((this.locX << 4) + i, l1, (this.locZ << 4) + k));
 						}
@@ -390,7 +391,6 @@ public class Chunk {
 					for (l1 = l; l1 < i1; ++l1) {
 						chunksection = this.sections[l1 >> 4];
 						if (chunksection != Chunk.a) {
-							this.dataLock.waitUntilUnlock(); // Paper
 							chunksection.a(i, l1 & 15, k, 0);
 							this.world.m(new BlockPosition((this.locX << 4) + i, l1, (this.locZ << 4) + k));
 						}
@@ -544,13 +544,12 @@ public class Chunk {
 				}
 
 				///
-				chunksection = this.sections[j >> 4] = new ChunkSection(j >> 4 << 4, !this.world.worldProvider.m(), this.world.blockPacketController.getPredefinedBlockData(this, j >> 4)); // Paper - Anti-Xray - Add blocks used for obfuscation to the DataPalette
+				chunksection = this.sections[j >> 4] = new ChunkSection(this, j >> 4 << 4, !this.world.worldProvider.m(), this.world.blockPacketController.getPredefinedBlockData(this, j >> 4)); // Paper - Anti-Xray - Add blocks used for obfuscation to the DataPalette
                 this.blocksLock.waitUntilUnlock();
 				///
 				flag = j >= i1;
 			}
 
-			this.dataLock.waitUntilUnlock(); // Paper
 			chunksection.setType(i, j & 15, k, iblockdata);
 			if (block1 != block) {
 				if (!this.world.isClientSide) {
@@ -639,7 +638,7 @@ public class Chunk {
 
 		if (chunksection == Chunk.a) {
 			///
-            chunksection = this.sections[k >> 4] = new ChunkSection(k >> 4 << 4, !this.world.worldProvider.m(), this.world.blockPacketController.getPredefinedBlockData(this, k >> 4)); // Paper - Anti-Xray - Add blocks used for obfuscation to the DataPalette
+            chunksection = this.sections[k >> 4] = new ChunkSection(this, k >> 4 << 4, !this.world.worldProvider.m(), this.world.blockPacketController.getPredefinedBlockData(this, k >> 4)); // Paper - Anti-Xray - Add blocks used for obfuscation to the DataPalette
 			this.blocksLock.waitUntilUnlock();
 			///
 			this.initLighting();
@@ -648,11 +647,9 @@ public class Chunk {
 		this.s = true;
 		if (enumskyblock == EnumSkyBlock.SKY) {
 			if (!this.world.worldProvider.m()) {
-				this.dataLock.waitUntilUnlock(); // Paper
 				chunksection.a(j, k & 15, l, i);
 			}
 		} else if (enumskyblock == EnumSkyBlock.BLOCK) {
-			this.dataLock.waitUntilUnlock(); // Paper
 			chunksection.b(j, k & 15, l, i);
 		}
 
@@ -1200,7 +1197,8 @@ public class Chunk {
 				try {
 					for (org.bukkit.generator.BlockPopulator populator : world.getPopulators()) {
 						ChunkPopulate_Pool task = new ChunkPopulate_Pool(world, random, bukkitChunk, populator);
-						task.fork();
+						SpigotWorldConfig.ChunkPool.execute(task);
+						// task.fork();
 					}
 				} finally {
 					this.world.populating = false;
diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java
index 4058fc5..cf3e83d 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java
@@ -5,7 +5,11 @@ import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.concurrent.Callable;
 import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ForkJoinTask;
+import java.util.concurrent.RecursiveAction;
+import java.util.concurrent.RecursiveTask;
 
 import javax.annotation.Nullable;
 
@@ -14,6 +18,7 @@ import org.apache.logging.log4j.Logger;
 import org.bukkit.craftbukkit.chunkio.ChunkIOExecutor;
 import org.bukkit.event.world.ChunkUnloadEvent;
 // CraftBukkit end
+import org.spigotmc.SpigotWorldConfig;
 
 import com.destroystokyo.paper.exception.ServerInternalException;
 
@@ -203,6 +208,21 @@ public class ChunkProviderServer implements IChunkProvider {
 
 		return chunk;
 	}
+	
+	class GetChunkAtTask extends RecursiveTask {
+		int i, j;
+        
+		GetChunkAtTask(int i, int j){
+            this.i = i;
+            this.j = j;
+        }
+
+		@Override
+		protected Object compute() {
+			return chunkGenerator.getOrCreateChunk(i, j);
+		}
+        
+	}
 
 	public Chunk originalGetChunkAt(int i, int j) {
 		Chunk chunk = this.originalGetOrLoadChunkAt(i, j);
@@ -211,7 +231,11 @@ public class ChunkProviderServer implements IChunkProvider {
 			long k = ChunkCoordIntPair.a(i, j);
 
 			try {
-				chunk = this.chunkGenerator.getOrCreateChunk(i, j);
+				// chunk = this.chunkGenerator.getOrCreateChunk(i, j);
+				// SpigotWorldConfig.ChunkTask = ForkJoinTask.adapt(new originalGetChunkAt(i, j));
+				GetChunkAtTask task = new GetChunkAtTask(i, j);
+				ForkJoinTask<Chunk> result = SpigotWorldConfig.ChunkPool.submit(task);
+				chunk = result.get();
 			} catch (Throwable throwable) {
 				CrashReport crashreport = CrashReport.a(throwable, "Exception generating new chunk");
 				CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Chunk to be generated");
@@ -223,7 +247,7 @@ public class ChunkProviderServer implements IChunkProvider {
 				throw new ReportedException(crashreport);
 			}
 
-			synchronized(this) { this.chunks.put(k, chunk); }
+			synchronized(chunks) { this.chunks.put(k, chunk); }
 			chunk.addEntities();
 
 			chunk.loadNearby(this, this.chunkGenerator, true); // CraftBukkit
diff --git a/src/main/java/net/minecraft/server/ChunkRegionLoader.java b/src/main/java/net/minecraft/server/ChunkRegionLoader.java
index 8eea856..8bb9759 100644
--- a/src/main/java/net/minecraft/server/ChunkRegionLoader.java
+++ b/src/main/java/net/minecraft/server/ChunkRegionLoader.java
@@ -417,9 +417,7 @@ public class ChunkRegionLoader implements IChunkLoader, IAsyncChunkSaver {
 		for (int k = 0; k < nbttaglist.size(); ++k) {
 			NBTTagCompound nbttagcompound1 = nbttaglist.get(k);
 			byte b1 = nbttagcompound1.getByte("Y");
-			///
-			ChunkSection chunksection = new ChunkSection(b1 << 4, flag, world.blockPacketController.getPredefinedBlockData(chunk, b1)); // Paper - Anti-Xray - Add blocks used for obfuscation to the DataPalette
-			///
+			ChunkSection chunksection = new ChunkSection(chunk, b1 << 4, flag, world.blockPacketController.getPredefinedBlockData(chunk, b1)); // Paper - Anti-Xray - Add blocks used for obfuscation to the DataPalette
 			byte[] abyte = nbttagcompound1.getByteArray("Blocks");
 			NibbleArray nibblearray = new NibbleArray(nbttagcompound1.getByteArray("Data"));
 			NibbleArray nibblearray1 = nbttagcompound1.hasKeyOfType("Add", 7)
diff --git a/src/main/java/net/minecraft/server/ChunkSection.java b/src/main/java/net/minecraft/server/ChunkSection.java
index 0f57ef6..e811c98 100644
--- a/src/main/java/net/minecraft/server/ChunkSection.java
+++ b/src/main/java/net/minecraft/server/ChunkSection.java
@@ -10,16 +10,18 @@ public class ChunkSection {
 	final DataPaletteBlock blockIds; // Paper - package
 	private NibbleArray emittedLight;
 	private NibbleArray skyLight;
+	private final Chunk chunk; // Paper - Async-Anti-Xray - Get access to Chunk#blocksLock and Chunk#dataLock
 
 	// Paper start - Anti-Xray - Support default constructor
 	public ChunkSection(int i, boolean flag) {
-		this(i, flag, (IBlockData[]) null);
+		this(null, i, flag, (IBlockData[]) null);
 	}
 	// Paper end
 
-	public ChunkSection(int i, boolean flag, @Nullable IBlockData[] predefinedBlockData) { // Paper
+	public ChunkSection(Chunk chunk, int i, boolean flag, @Nullable IBlockData[] predefinedBlockData) { // Paper - (Async-)Anti-Xray - Chunk object used to access the lock objects and blocks used for obfuscation
+		this.chunk = chunk; // Paper - Async-Anti-Xray
 		this.yPos = i;
-		this.blockIds = new DataPaletteBlock(predefinedBlockData); // Paper
+		this.blockIds = new DataPaletteBlock(predefinedBlockData); // Paper - Anti-Xray - Add blocks used for obfuscation to the DataPalette
 		this.emittedLight = new NibbleArray();
 		if (flag) {
 			this.skyLight = new NibbleArray();
@@ -29,14 +31,15 @@ public class ChunkSection {
 
 	// Paper start - Anti-Xray - Support default constructor
 	public ChunkSection(int y, boolean flag, char[] blockIds) {
-		this(y, flag, blockIds, null);
+		this(null, y, flag, blockIds, null);
 	}
 	// Paper end
 
 	// CraftBukkit start
-	public ChunkSection(int y, boolean flag, char[] blockIds, @Nullable IBlockData[] predefinedBlockData) { // Paper
+	public ChunkSection(Chunk chunk, int y, boolean flag, char[] blockIds, @Nullable IBlockData[] predefinedBlockData) { // Paper - (Async-)Anti-Xray - Chunk object used to access the lock objects and blocks used for obfuscation
+		this.chunk = chunk; // Paper - Async-Anti-Xray
 		this.yPos = y;
-		this.blockIds = new DataPaletteBlock(predefinedBlockData); // Paper
+		this.blockIds = new DataPaletteBlock(predefinedBlockData); // Paper - Anti-Xray - Add blocks used for obfuscation to the DataPalette
 		for (int i = 0; i < blockIds.length; i++) {
 			int xx = i & 15;
 			int yy = (i >> 8) & 15;
@@ -56,6 +59,12 @@ public class ChunkSection {
 	}
 
 	public void setType(int i, int j, int k, IBlockData iblockdata) {
+		// Paper start - Async-Anti-Xray - Note: Lock is applied on the same thread (main thread) -> no race condition
+		if (chunk != null) {
+			 chunk.blocksLock.waitUntilUnlock();
+		}
+		// Paper end
+		
 		IBlockData iblockdata1 = this.getType(i, j, k);
 		Block block = iblockdata1.getBlock();
 		Block block1 = iblockdata.getBlock();
@@ -93,6 +102,12 @@ public class ChunkSection {
 	}
 
 	public void a(int i, int j, int k, int l) {
+		// Paper start - Async-Anti-Xray - Note: Lock is applied on the same thread (main thread) -> no race condition
+		if (chunk != null) {
+			chunk.dataLock.waitUntilUnlock();
+		}
+		// Paper end
+		
 		this.skyLight.a(i, j, k, l);
 	}
 
@@ -101,6 +116,12 @@ public class ChunkSection {
 	}
 
 	public void b(int i, int j, int k, int l) {
+		// Paper start - Async-Anti-Xray - Note: Lock is applied on the same thread (main thread) -> no race condition
+		if (chunk != null) {
+			chunk.dataLock.waitUntilUnlock();
+		}
+		// Paper end
+		
 		this.emittedLight.a(i, j, k, l);
 	}
 
@@ -142,10 +163,22 @@ public class ChunkSection {
 	}
 
 	public void a(NibbleArray nibblearray) {
+		// Paper start - Async-Anti-Xray - Note: Lock is applied on the same thread (main thread) -> no race condition
+		if (chunk != null) {
+			chunk.dataLock.waitUntilUnlock();
+		}
+		// Paper end
+		
 		this.emittedLight = nibblearray;
 	}
 
 	public void b(NibbleArray nibblearray) {
+		// Paper start - Async-Anti-Xray - Note: Lock is applied on the same thread (main thread) -> no race condition
+		if (chunk != null) {
+			chunk.dataLock.waitUntilUnlock();
+		}
+		// Paper end
+		
 		this.skyLight = nibblearray;
 	}
 }
diff --git a/src/main/java/net/minecraft/server/ContainerEnchantTable.java b/src/main/java/net/minecraft/server/ContainerEnchantTable.java
index 677e753..35b4dff 100644
--- a/src/main/java/net/minecraft/server/ContainerEnchantTable.java
+++ b/src/main/java/net/minecraft/server/ContainerEnchantTable.java
@@ -4,6 +4,7 @@ import java.util.List;
 // CraftBukkit start
 import java.util.Map;
 import java.util.Random;
+import java.util.SplittableRandom;
 
 import javax.annotation.Nullable;
 
diff --git a/src/main/java/net/minecraft/server/DataPaletteBlock.java b/src/main/java/net/minecraft/server/DataPaletteBlock.java
index 3b113b2..bf2347d 100644
--- a/src/main/java/net/minecraft/server/DataPaletteBlock.java
+++ b/src/main/java/net/minecraft/server/DataPaletteBlock.java
@@ -9,8 +9,6 @@ public class DataPaletteBlock implements DataPaletteExpandable {
 	protected DataBits b; // Paper - nope
 	protected DataPalette c;
 	private int e = 0;
-	private final IBlockData[] predefinedBlockData; // Paper
-	private final int[] currentPredefinedBlockData; // Paper
 
 	// Paper start - Anti-Xray - Support default constructor
 	public DataPaletteBlock() {
@@ -19,6 +17,9 @@ public class DataPaletteBlock implements DataPaletteExpandable {
 	// Paper end
 
 	// Paper start - Anti-Xray - Modified constructor
+	private final IBlockData[] predefinedBlockData; // Paper - Anti-Xray - Blocks used for obfuscation (since 1.9 MC uses DataPalettes which have to be changed if more different blocks are used in a ChunkSection -> to avoid that while setting the fake-blocks we add them from the beginning)
+	private final int[] currentPredefinedBlockData; // Paper - Anti-Xray - Current used data bits of blocks used for obfuscation
+	
 	public DataPaletteBlock(@Nullable IBlockData[] predefinedBlockData) { // Paper
 		this.predefinedBlockData = predefinedBlockData;
 		if (predefinedBlockData == null) { // Paper - Anti-Xray - default constructor
diff --git a/src/main/java/net/minecraft/server/DedicatedServer.java b/src/main/java/net/minecraft/server/DedicatedServer.java
index cdd92f4..2c3bb97 100644
--- a/src/main/java/net/minecraft/server/DedicatedServer.java
+++ b/src/main/java/net/minecraft/server/DedicatedServer.java
@@ -19,6 +19,7 @@ import org.bukkit.craftbukkit.util.Waitable;
 import org.bukkit.event.server.RemoteServerCommandEvent;
 // CraftBukkit end
 import org.bukkit.event.server.ServerCommandEvent;
+import org.spigotmc.SpigotWorldConfig;
 
 import com.google.common.collect.Lists;
 import com.mojang.authlib.GameProfileRepository;
@@ -266,10 +267,6 @@ public class DedicatedServer extends MinecraftServer implements IMinecraftServer
 				worldtype = WorldType.NORMAL;
 			}
 
-			/*
-			 * this.ax(); // Torch start - fork this.getEnableCommandBlock();
-			 * this.q(); this.getSnooperEnabled(); this.aF();
-			 */ // Torch end
 			SubTask task_a = new SubTask();
 			task_a.fork();
 
@@ -339,8 +336,7 @@ public class DedicatedServer extends MinecraftServer implements IMinecraftServer
 	}
 
 	class SubTask extends RecursiveAction {
-		SubTask() {
-		}
+		SubTask() {}
 
 		@Override
 		protected void compute() {
diff --git a/src/main/java/net/minecraft/server/Entity.java b/src/main/java/net/minecraft/server/Entity.java
index 0a843fc..eb33765 100644
--- a/src/main/java/net/minecraft/server/Entity.java
+++ b/src/main/java/net/minecraft/server/Entity.java
@@ -36,6 +36,7 @@ import org.bukkit.event.vehicle.VehicleEnterEvent;
 import org.bukkit.event.vehicle.VehicleExitEvent;
 import org.bukkit.plugin.PluginManager;
 // CraftBukkit end
+import org.spigotmc.SpigotWorldConfig;
 
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
@@ -462,18 +463,8 @@ public abstract class Entity implements ICommandListener, org.spigotmc.Optimized
 		}
 
 		U_sub us_task = new U_sub(); // Torch - removed to the head
-		us_task.fork();
-		// Hose start
-		/*
-		 * this.al(); this.aj(); if (this.world.isClientSide) { this.fireTicks =
-		 * 0; } else if (this.fireTicks > 0) { if (this.fireProof) {
-		 * this.fireTicks -= 4; if (this.fireTicks < 0) { this.fireTicks = 0; }
-		 * } else { if (this.fireTicks % 20 == 0) {
-		 * this.damageEntity(DamageSource.BURN, 1.0F); }
-		 * 
-		 * --this.fireTicks; } }
-		 */
-		// Hose end
+		SpigotWorldConfig.EntityPool.execute(us_task);
+		// us_task.fork();
 
 		if (this.an()) {
 			this.burnFromLava();
@@ -500,7 +491,8 @@ public abstract class Entity implements ICommandListener, org.spigotmc.Optimized
 	// Hose start
 	public void U() {
 		U u_task = new U();
-		u_task.fork();
+		SpigotWorldConfig.EntityPool.execute(u_task);
+		// u_task.fork();
 	}
 	// Hose end
 
@@ -1716,9 +1708,10 @@ public abstract class Entity implements ICommandListener, org.spigotmc.Optimized
 		}
 	}
 
-	public void collide(Entity entity) { // Hose - fork it
+	public void collide(Entity entity) {
 		collide c_task = new collide(entity);
-		c_task.fork();
+		SpigotWorldConfig.EntityPool.execute(c_task);
+		// c_task.fork();
 	}
 
 	public void g(double d0, double d1, double d2) {
@@ -2132,14 +2125,16 @@ public abstract class Entity implements ICommandListener, org.spigotmc.Optimized
 					blockposition_pooledblockposition.f(k, j, l);
 					if (this.world.getType(blockposition_pooledblockposition).getBlock().j()) {
 						// blockposition_pooledblockposition.t();
-						bp_task.fork();
+						SpigotWorldConfig.EntityPool.execute(bp_task);
+						// bp_task.fork();
 						return true;
 					}
 				}
 			}
 
+			SpigotWorldConfig.EntityPool.execute(bp_task);
 			// blockposition_pooledblockposition.t();
-			bp_task.fork();
+			// bp_task.fork();
 			return false;
 		}
 	}
diff --git a/src/main/java/net/minecraft/server/EntityInsentient.java b/src/main/java/net/minecraft/server/EntityInsentient.java
index 49e93e7..4434e02 100644
--- a/src/main/java/net/minecraft/server/EntityInsentient.java
+++ b/src/main/java/net/minecraft/server/EntityInsentient.java
@@ -19,9 +19,12 @@ import org.bukkit.event.entity.EntityTargetLivingEntityEvent;
 import org.bukkit.event.entity.EntityUnleashEvent;
 import org.bukkit.event.entity.EntityUnleashEvent.UnleashReason;
 // CraftBukkit end
+import org.spigotmc.SpigotWorldConfig;
 
 import com.google.common.collect.Maps;
 
+import net.minecraft.server.Entity.U_sub;
+
 public abstract class EntityInsentient extends EntityLiving {
 
 	private static final DataWatcherObject<Byte> a = DataWatcher.a(EntityInsentient.class, DataWatcherRegistry.a);
@@ -685,9 +688,21 @@ public abstract class EntityInsentient extends EntityLiving {
 
 		}
 	}
-
+	
+	// Torch start
+	class InsentientTickTask extends RecursiveAction {
+		InsentientTickTask() {}
+		@Override protected void compute() { doTick_task(); }
+	}
+	
 	@Override
 	protected final void doTick() {
+		InsentientTickTask insentientTick_task = new InsentientTickTask();
+		SpigotWorldConfig.TickPool.invoke(insentientTick_task);
+	}
+
+	protected final void doTick_task() {
+		// Torch end
 		++this.ticksFarFromPlayer;
 
 		this.world.methodProfiler.a("checkDespawn");
diff --git a/src/main/java/net/minecraft/server/EntityLiving.java b/src/main/java/net/minecraft/server/EntityLiving.java
index 459eda8..1b6c9a3 100644
--- a/src/main/java/net/minecraft/server/EntityLiving.java
+++ b/src/main/java/net/minecraft/server/EntityLiving.java
@@ -23,6 +23,7 @@ import org.bukkit.event.entity.EntityRegainHealthEvent;
 import org.bukkit.event.entity.EntityTeleportEvent;
 import org.bukkit.event.player.PlayerItemConsumeEvent;
 // CraftBukkit end
+import org.spigotmc.SpigotWorldConfig;
 
 import com.google.common.base.Function;
 import com.google.common.base.Objects;
@@ -1310,9 +1311,12 @@ public abstract class EntityLiving extends Entity {
 			};
 			float absorptionModifier = absorption.apply((double) f).floatValue();
 
-			EntityDamageEvent event = CraftEventFactory.handleLivingEntityDamageEvent(this, damagesource,
-					originalDamage, hardHatModifier, blockingModifier, armorModifier, resistanceModifier, magicModifier,
-					absorptionModifier, hardHat, blocking, armor, resistance, magic, absorption);
+			synchronized(this) {
+				EntityDamageEvent event = CraftEventFactory.handleLivingEntityDamageEvent(this, damagesource,
+						originalDamage, hardHatModifier, blockingModifier, armorModifier, resistanceModifier, magicModifier,
+						absorptionModifier, hardHat, blocking, armor, resistance, magic, absorption);
+			}
+			
 			if (event.isCancelled()) {
 				return false;
 			}
@@ -2089,12 +2093,14 @@ public abstract class EntityLiving extends Entity {
 		// Hose start
 		// this.g(this.be, this.bf);
 		aim_task = new ai_move(this);
-		aim_task.fork();
+		SpigotWorldConfig.TickPool.execute(aim_task);
+		// aim_task.fork();
 		this.world.methodProfiler.b();
 		this.world.methodProfiler.a("push");
 		// this.co();
 		co_task = new Collide(this);
-		co_task.fork();
+		SpigotWorldConfig.TickPool.execute(co_task);
+		// co_task.fork();
 		// Hose end
 		this.world.methodProfiler.b();
 	}
@@ -2128,7 +2134,6 @@ public abstract class EntityLiving extends Entity {
 	protected void doTick() {
 	}
 
-	// GE_Pool ge_task; // Hose
 	protected void co() {
 		List list = this.world.getEntities(this, this.getBoundingBox(), IEntitySelector.a(this));
 
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index b260010..b26a2dd 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -1045,7 +1045,8 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
 		MinecraftTimings.playerListTimer.startTiming(); // Spigot
 		// this.v.tick();
 		PlayerListTickTask playerlist_ticktask = new PlayerListTickTask(this.v);
-		playerlist_ticktask.fork();
+		SpigotWorldConfig.TickPool.invoke(playerlist_ticktask);
+		// playerlist_ticktask.fork();
 		MinecraftTimings.playerListTimer.stopTiming(); // Spigot
 
 		this.methodProfiler.c("tickables");
diff --git a/src/main/java/net/minecraft/server/NetworkManager.java b/src/main/java/net/minecraft/server/NetworkManager.java
index 7762fb9..524de06 100644
--- a/src/main/java/net/minecraft/server/NetworkManager.java
+++ b/src/main/java/net/minecraft/server/NetworkManager.java
@@ -157,9 +157,8 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet<?>> {
 	}
 
 	public void sendPacket(Packet<?> packet) {
-		if (this.isConnected() && this.m()
-				&& !(packet instanceof PacketPlayOutMapChunk && !((PacketPlayOutMapChunk) packet).isReady())) { // Paper
-			// this.m(); // Paper - Async-Anti-Xray - Move to if-statement
+		if (this.isConnected() && this.trySendQueue() && !(packet instanceof PacketPlayOutMapChunk && !((PacketPlayOutMapChunk) packet).isReady())) { // Paper - Async-Anti-Xray - Add not ready chunk packets and all packets if the queue contains a not ready chunk packet to the queue to keep the packet-order
+			//this.m(); // Paper - Async-Anti-Xray - Move to if-statement (this.trySendQueue())
 			this.a(packet, (GenericFutureListener[]) null);
 		} else {
 			this.j.writeLock().lock();
@@ -176,9 +175,8 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet<?>> {
 	public void sendPacket(Packet<?> packet,
 			GenericFutureListener<? extends Future<? super Void>> genericfuturelistener,
 			GenericFutureListener<? extends Future<? super Void>>... agenericfuturelistener) {
-		if (this.isConnected() && this.m()
-				&& !(packet instanceof PacketPlayOutMapChunk && !((PacketPlayOutMapChunk) packet).isReady())) { // Paper
-			// this.m(); // Paper - Async-Anti-Xray - Move to if-statement
+		if (this.isConnected() && this.trySendQueue() && !(packet instanceof PacketPlayOutMapChunk && !((PacketPlayOutMapChunk) packet).isReady())) { // Paper - Async-Anti-Xray - Add not ready chunk packets and all packets if the queue contains a not ready chunk packet to the queue to keep the packet-order
+			//this.m(); // Paper - Async-Anti-Xray - Move to if-statement (this.trySendQueue())
 			this.a(packet, ArrayUtils.add(agenericfuturelistener, 0, genericfuturelistener));
 		} else {
 			this.j.writeLock().lock();
@@ -236,8 +234,8 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet<?>> {
 
 	}
 
-	private boolean m() { // Paper - Async-Anti-Xray - void -> boolean used in
-							// sendPacket
+	private boolean trySendQueue() { return this.m(); } // Paper - OBFHELPER
+	private boolean m() { // Paper - Async-Anti-Xray - void -> boolean used in sendPacket
 		if (this.channel != null && this.channel.isOpen()) {
 			this.j.readLock().lock();
 
diff --git a/src/main/java/net/minecraft/server/PacketStatusListener.java b/src/main/java/net/minecraft/server/PacketStatusListener.java
index c8f43cd..ab577a6 100644
--- a/src/main/java/net/minecraft/server/PacketStatusListener.java
+++ b/src/main/java/net/minecraft/server/PacketStatusListener.java
@@ -6,6 +6,7 @@ import java.util.concurrent.RecursiveAction;
 
 import org.bukkit.craftbukkit.util.CraftIconCache;
 import org.bukkit.entity.Player;
+import org.spigotmc.SpigotWorldConfig;
 
 // CraftBukkit start
 import com.mojang.authlib.GameProfile;
@@ -46,7 +47,8 @@ public class PacketStatusListener implements PacketStatusInListener {
 	public void a(PacketStatusInStart packetstatusinstart) {
 		if (de.minetick.MigotConfig.enabledForkPing) {
 			StatusTask a_task = new StatusTask(packetstatusinstart);
-			a_task.fork();
+			SpigotWorldConfig.TickPool.execute(a_task);
+			// a_task.fork();
 		} else {
 			a_task(packetstatusinstart);
 		}
diff --git a/src/main/java/net/minecraft/server/PlayerConnection.java b/src/main/java/net/minecraft/server/PlayerConnection.java
index 4d67ba9..2378c22 100644
--- a/src/main/java/net/minecraft/server/PlayerConnection.java
+++ b/src/main/java/net/minecraft/server/PlayerConnection.java
@@ -53,6 +53,7 @@ import org.bukkit.inventory.CraftingInventory;
 import org.bukkit.inventory.EquipmentSlot;
 import org.bukkit.inventory.InventoryView;
 import org.bukkit.util.NumberConversions;
+import org.spigotmc.SpigotWorldConfig;
 import org.torch.fml.PlayerStatus;
 
 import com.google.common.base.Charsets;
@@ -1256,7 +1257,8 @@ public class PlayerConnection implements PacketListenerPlayIn, ITickable {
 		}
 		
 		SendTask task = new SendTask(packet);
-		task.fork();
+		SpigotWorldConfig.TickPool.execute(task);
+		// task.fork();
 	}
 	
 	public void sendPacket_sub(final Packet<?> packet) {
diff --git a/src/main/java/net/minecraft/server/PlayerList.java b/src/main/java/net/minecraft/server/PlayerList.java
index ae8bf73..bcfe644 100644
--- a/src/main/java/net/minecraft/server/PlayerList.java
+++ b/src/main/java/net/minecraft/server/PlayerList.java
@@ -95,20 +95,6 @@ public abstract class PlayerList {
 		this.maxPlayers = 8;
 	}
 
-	/*
-	 * class ListTask extends RecursiveAction { NetworkManager networkmanager;
-	 * EntityPlayer entityplayer; ListTask(NetworkManager networkmanager,
-	 * EntityPlayer entityplayer) { this.networkmanager = networkmanager;
-	 * this.entityplayer = entityplayer; }
-	 * 
-	 * @Override protected void compute() { a_task(networkmanager,
-	 * entityplayer); } }
-	 * 
-	 * public void a(NetworkManager networkmanager, EntityPlayer entityplayer) {
-	 * ListTask task = new ListTask(networkmanager, entityplayer); task.fork();
-	 * }
-	 */
-
 	public void a(NetworkManager networkmanager, EntityPlayer entityplayer) {
 		GameProfile gameprofile = entityplayer.getProfile();
 		UserCache usercache = this.server.getUserCache();
@@ -318,17 +304,6 @@ public abstract class PlayerList {
 				List list = scoreboardserver.getScoreboardScorePacketsForObjective(scoreboardobjective);
 				Iterator iterator1 = list.iterator();
 
-				// Paper start - Send a fake team to the client to initialize
-				// collision rule if no others exist
-				if (!com.destroystokyo.paper.PaperConfig.enablePlayerCollisions && !iterator.hasNext()) {
-					String teamName = org.apache.commons.lang3.StringUtils
-							.left("collideRule_" + entityplayer.getWorld().random.nextInt(), 16);
-					entityplayer.playerConnection.sendPacket(
-							new PacketPlayOutScoreboardTeam(new ScoreboardTeam(scoreboardserver, teamName), 0));
-					return;
-				}
-				// Paper end
-
 				while (iterator1.hasNext()) {
 					Packet packet = (Packet) iterator1.next();
 
diff --git a/src/main/java/net/minecraft/server/StructureGenerator.java b/src/main/java/net/minecraft/server/StructureGenerator.java
index f517aed..b54b63e 100644
--- a/src/main/java/net/minecraft/server/StructureGenerator.java
+++ b/src/main/java/net/minecraft/server/StructureGenerator.java
@@ -5,6 +5,8 @@ import java.util.List;
 import java.util.Random;
 import java.util.concurrent.RecursiveAction;
 
+import org.spigotmc.SpigotWorldConfig;
+
 import co.aikar.timings.MinecraftTimings;
 import co.aikar.timings.Timing;
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
@@ -102,7 +104,8 @@ public abstract class StructureGenerator extends WorldGenBase {
 				// this.a(structurestart.e(), structurestart.f(),
 				// structurestart);
 				structure str_task = new structure(this, structurestart.e(), structurestart.f(), structurestart);
-				str_task.fork();
+				SpigotWorldConfig.ChunkPool.execute(str_task);
+				// str_task.fork();
 			}
 		}
 
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index b256286..3e772c8 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -14,6 +14,7 @@ import com.destroystokyo.paper.antixray.BlockPacketController; // Paper - Anti-X
 import com.destroystokyo.paper.antixray.BlockPacketControllerObfuscate; // Paper - Anti-Xray - Anti-Xray implementation
 import com.destroystokyo.paper.antixray.IBlockPacketController; // Paper - Anti-Xray - Interface with methods used to control which and how blocks are sent
 import java.util.UUID;
+import java.util.concurrent.Callable;
 // Paper end
 import java.util.concurrent.RecursiveAction;
 import java.util.concurrent.RecursiveTask;
@@ -31,6 +32,7 @@ import org.bukkit.event.block.BlockPhysicsEvent;
 import org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;
 import org.bukkit.generator.ChunkGenerator;
 // CraftBukkit end
+import org.spigotmc.SpigotWorldConfig;
 
 import com.destroystokyo.paper.IOStatCommand;
 import com.destroystokyo.paper.PaperConfig;
@@ -47,6 +49,11 @@ import com.google.common.collect.Queues;
 import com.google.common.collect.Sets;
 import com.mrpowergamerbr.utils.LightRandom;
 
+import net.minecraft.server.StructureGenerator.structure;
+import net.minecraft.server.WorldServer.SoundsTask;
+import net.minecraft.server.WorldServer.chunk_tick;
+import net.minecraft.server.WorldServer.light_tick;
+
 public abstract class World implements IBlockAccess {
 
 	private int a = 63;
@@ -363,16 +370,9 @@ public abstract class World implements IBlockAccess {
 
 	private boolean isAreaLoaded(int i, int j, int k, int l, int i1, int j1, boolean flag) {
 		area_load ar_task = new area_load(this, i, j, k, l, i1, j1, flag);
-		ar_task.fork();
+		SpigotWorldConfig.ChunkPool.execute(ar_task);
+		// ar_task.fork();
 		return ar_task.join();
-		/*
-		 * if (i1 >= 0 && j < 256) { i >>= 4; k >>= 4; l >>= 4; j1 >>= 4;
-		 * 
-		 * for (int k1 = i; k1 <= l; ++k1) { for (int l1 = k; l1 <= j1; ++l1) {
-		 * if (!this.isChunkLoaded(k1, l1, flag)) { return false; } } }
-		 * 
-		 * return true; } else { return false; }
-		 */
 	}
 
 	protected abstract boolean isChunkLoaded(int i, int j, boolean flag);
@@ -1127,7 +1127,8 @@ public abstract class World implements IBlockAccess {
 		// this.a(enumparticle.c(), enumparticle.e(), d0, d1, d2, d3, d4, d5,
 		// aint);
 		addparticle ap_task = new addparticle(enumparticle, d0, d1, d2, d3, d4, d5, aint);
-		ap_task.fork();
+		SpigotWorldConfig.EntityPool.execute(ap_task);
+		// ap_task.fork();
 	}
 
 	private void a(int i, boolean flag, double d0, double d1, double d2, double d3, double d4, double d5, int... aint) {
@@ -1142,17 +1143,49 @@ public abstract class World implements IBlockAccess {
 		this.j.add(entity);
 		return true;
 	}
+	
+	class entityAddTask extends RecursiveAction implements Callable {
+		Entity entity; SpawnReason spawnReason; boolean result;
+		
+		entityAddTask(Entity entity, SpawnReason spawnReason) {
+			this.entity = entity;
+			this.spawnReason = spawnReason;
+		}
+
+		@Override
+		protected void compute() {
+			addEntity_task(entity, spawnReason);
+		}
+
+		@Override
+		public Object call() throws Exception {
+			return result;
+		}
+
+	}
+	
+	public boolean addEntity(Entity entity, SpawnReason spawnReason) {
+		entityAddTask task = new entityAddTask(entity, spawnReason);
+		SpigotWorldConfig.EntityPool.invoke(task);
+		try {
+			return (boolean) task.call();
+		} catch (Exception e) {
+			MinecraftServer.LOGGER.error("Add entity error on " + entity, new Throwable());
+			e.printStackTrace();
+			return addEntity_task(entity, spawnReason);
+		}
+	}
 
 	public boolean addEntity(Entity entity) {
 		// CraftBukkit start - Used for entities other than creatures
 		return addEntity(entity, SpawnReason.DEFAULT);
 	}
 
-	public synchronized boolean addEntity(Entity entity, SpawnReason spawnReason) { // Changed
+	public boolean addEntity_task(Entity entity, SpawnReason spawnReason) { // Changed
 																					// signature,
 																					// added
 																					// SpawnReason
-		// org.spigotmc.AsyncCatcher.catchOp( "entity add"); // Spigot
+		org.spigotmc.AsyncCatcher.catchOp( "entity add"); // Spigot
 		if (entity == null) {
 			return false;
 		}
@@ -1595,8 +1628,58 @@ public abstract class World implements IBlockAccess {
 
 	public void b(BlockPosition blockposition, Block block, int i, int j) {
 	}
+	
+	public void tick_task(Entity entity) {
+        // CraftBukkit end
+        Entity entity1 = entity.bz();
+
+        if (entity1 != null) {
+            if (!entity1.dead && entity1.w(entity)) {
+            	return;
+            }
+
+            entity.stopRiding();
+        }
+
+        this.methodProfiler.a("tick");
+        if (!entity.dead && !(entity instanceof EntityPlayer)) {
+            try {
+                entity.tickTimer.startTiming(); // Paper
+                this.g(entity);
+                entity.tickTimer.stopTiming(); // Paper
+            } catch (Throwable throwable1) {
+                entity.tickTimer.stopTiming();
+                // Paper start - Prevent tile entity and entity crashes
+                String msg = "Entity threw exception at " + entity.world.getWorld().getName() + ":" + entity.locX + "," + entity.locY + "," + entity.locZ;
+                System.err.println(msg);
+                throwable1.printStackTrace();
+                getServer().getPluginManager().callEvent(new ServerExceptionEvent(new ServerInternalException(msg, throwable1)));
+                entity.dead = true;
+                return;
+                // Paper end
+            }
+        }
+
+        this.methodProfiler.b();
+        this.methodProfiler.a("remove");
+        if (entity.dead) {
+            int j = entity.ab;
+            int l = entity.ad;
+
+            if (entity.aa && this.isChunkLoaded(j, l, true)) {
+                this.getChunkAt(j, l).b(entity);
+            }
 
-	public void tickEntities() {
+            guardEntityList = false; // Spigot
+            this.entityList.remove(this.tickPosition--); // CraftBukkit - Use field for loop variable
+            guardEntityList = true; // Spigot
+            this.c(entity);
+        }
+
+        this.methodProfiler.b();
+	}
+	
+	public void tickEntities() { // Torch - moved fork staff to worldserver
 		this.methodProfiler.a("entities");
 		this.methodProfiler.a("global");
 
@@ -1675,55 +1758,14 @@ public abstract class World implements IBlockAccess {
 		// if (tickPosition < 0) tickPosition = 0;
 		for (tickPosition = 0; tickPosition < entityList.size(); tickPosition++) {
 			// Paper end
-            tickPosition = (tickPosition < entityList.size()) ? tickPosition : 0;
-            entity = (Entity) this.entityList.get(this.tickPosition);
-            // CraftBukkit end
-            Entity entity1 = entity.bz();
-
-            if (entity1 != null) {
-                if (!entity1.dead && entity1.w(entity)) {
-                    continue;
-                }
-
-                entity.stopRiding();
-            }
-
-            this.methodProfiler.a("tick");
-            if (!entity.dead && !(entity instanceof EntityPlayer)) {
-                try {
-                    entity.tickTimer.startTiming(); // Paper
-                    this.g(entity);
-                    entity.tickTimer.stopTiming(); // Paper
-                } catch (Throwable throwable1) {
-                    entity.tickTimer.stopTiming();
-                    // Paper start - Prevent tile entity and entity crashes
-                    String msg = "Entity threw exception at " + entity.world.getWorld().getName() + ":" + entity.locX + "," + entity.locY + "," + entity.locZ;
-                    System.err.println(msg);
-                    throwable1.printStackTrace();
-                    getServer().getPluginManager().callEvent(new ServerExceptionEvent(new ServerInternalException(msg, throwable1)));
-                    entity.dead = true;
-                    continue;
-                    // Paper end
-                }
-            }
-
-            this.methodProfiler.b();
-            this.methodProfiler.a("remove");
-            if (entity.dead) {
-                j = entity.ab;
-                int l = entity.ad;
-
-                if (entity.aa && this.isChunkLoaded(j, l, true)) {
-                    this.getChunkAt(j, l).b(entity);
-                }
-
-                guardEntityList = false; // Spigot
-                this.entityList.remove(this.tickPosition--); // CraftBukkit - Use field for loop variable
-                guardEntityList = true; // Spigot
-                this.c(entity);
-            }
-
-            this.methodProfiler.b();
+			tickPosition = (tickPosition < entityList.size()) ? tickPosition : 0;
+			// Torch start
+	        entity = (Entity) this.entityList.get(this.tickPosition);
+	        Tick_task task = new Tick_task(entity);
+	        SpigotWorldConfig.EntityPool.invoke(task);
+	        // tick_task(entity);
+	        // Torch end
+	        // CraftBukkit end
         }
 		guardEntityList = false; // Spigot
 
@@ -2206,11 +2248,13 @@ public abstract class World implements IBlockAccess {
 		// explosion.a(true);
 		if (explosion.getSize() < 0.1F) { // First checking size to speedup it
 			IExplosionTask eta_task = new IExplosionTask(explosion);
-			eta_task.fork();
+			SpigotWorldConfig.EntityPool.execute(eta_task);
+			// eta_task.fork();
 			return explosion;
 		} else {
 			ExplosionTask et_task = new ExplosionTask(explosion);
-			et_task.fork();
+			SpigotWorldConfig.EntityPool.execute(et_task);
+			// et_task.fork();
 			return explosion;
 		}
 
@@ -2451,9 +2495,19 @@ public abstract class World implements IBlockAccess {
 		this.allowMonsters = flag;
 		this.allowAnimals = flag1;
 	}
-
-	// WT_Pool wt_task; // Hose
+	
+	// Torch start
+	class WorldTickTask extends RecursiveAction {
+		WorldTickTask() {}
+		@Override protected void compute() { doTick_task(); }
+	}
+	
 	public void doTick() {
+		WorldTickTask worldTick_task = new WorldTickTask();
+		SpigotWorldConfig.TickPool.invoke(worldTick_task);
+	}
+
+	public void doTick_task() {
 		// Paper - Start PersistenceCounters
 		if (PaperConfig.paperIOStats && System.nanoTime() > nextPersistenceCountersTick) {
 			nextPersistenceCountersTick += IOStatCommand.SECOND;
@@ -2464,8 +2518,7 @@ public abstract class World implements IBlockAccess {
 		}
 		// Paper - End
 		this.t();
-		// wt_task = new WT_Pool();
-		// wt_task.fork();
+		// Torch end
 	}
 
 	protected void I() {
@@ -2846,8 +2899,9 @@ public abstract class World implements IBlockAccess {
 					// this.getChunkAt(i1, j1).a(entity, axisalignedbb,
 					// arraylist, predicate);
 					get_en en_task = new get_en(this, entity, axisalignedbb, predicate, i1, j1, arraylist);
-					en_task.fork();
-					en_task.join();
+					SpigotWorldConfig.EntityPool.invoke(en_task);
+					// en_task.fork();
+					// en_task.join();
 				}
 			}
 		}
@@ -2949,7 +3003,7 @@ public abstract class World implements IBlockAccess {
 
 	public int a(Class<?> oclass) {
 		int i = 0;
-		Iterator iterator = Queues.newConcurrentLinkedQueue(this.entityList).iterator();
+		Iterator iterator = this.entityList.iterator();
 
 		while (iterator.hasNext()) {
 			Entity entity = (Entity) iterator.next();
@@ -3585,6 +3639,20 @@ public abstract class World implements IBlockAccess {
 	public LootTableRegistry ak() {
 		return this.B;
 	}
+	
+	class Tick_task extends RecursiveAction {
+		Entity entity;
+		
+		Tick_task(Entity entity) {
+			this.entity = entity;
+		}
+
+		@Override
+		protected void compute() {
+			tick_task(entity);
+		}
+
+	}
 
 	class get_en extends RecursiveAction {
 		World world;
diff --git a/src/main/java/net/minecraft/server/WorldServer.java b/src/main/java/net/minecraft/server/WorldServer.java
index 220beb3..9a684b5 100644
--- a/src/main/java/net/minecraft/server/WorldServer.java
+++ b/src/main/java/net/minecraft/server/WorldServer.java
@@ -9,6 +9,7 @@ import java.util.Map;
 import java.util.Queue;
 import java.util.Random;
 import java.util.UUID;
+import java.util.concurrent.ForkJoinTask;
 import java.util.concurrent.RecursiveAction;
 // CraftBukkit start
 import java.util.logging.Level;
@@ -23,6 +24,7 @@ import org.bukkit.craftbukkit.util.HashTreeSet;
 import org.bukkit.event.block.BlockFormEvent;
 import org.bukkit.event.weather.LightningStrikeEvent;
 // CraftBukkit end
+import org.spigotmc.SpigotWorldConfig;
 
 import com.google.common.base.Predicate;
 import com.google.common.collect.Lists;
@@ -284,11 +286,15 @@ public class WorldServer extends World implements IAsyncTaskHandler {
 		timings.doChunkUnload.stopTiming(); // Spigot
 		this.methodProfiler.c("tickPending");
 		timings.scheduledBlocks.startTiming(); // Paper
-		this.a(false);
+		BlocksTask scheduledBlocks_task = new BlocksTask();
+		SpigotWorldConfig.TickPool.invoke(scheduledBlocks_task);
+		// this.a(false);
 		timings.scheduledBlocks.stopTiming(); // Paper
 		this.methodProfiler.c("tickBlocks");
 		timings.chunkTicks.startTiming(); // Paper
-		this.j();
+		ChunkTicksTask chunkTicks_task = new ChunkTicksTask();
+		SpigotWorldConfig.TickPool.invoke(chunkTicks_task);
+		// this.j();
 		timings.chunkTicks.stopTiming(); // Paper
 		this.methodProfiler.c("chunkMap");
 		timings.doChunkMap.startTiming(); // Spigot
@@ -305,13 +311,33 @@ public class WorldServer extends World implements IAsyncTaskHandler {
 		timings.doPortalForcer.stopTiming(); // Spigot
 		this.methodProfiler.b();
 		timings.doSounds.startTiming(); // Spigot
-		this.ao();
+		SoundsTask doSounds_task = new SoundsTask();
+		SpigotWorldConfig.TickPool.invoke(doSounds_task);
+		// this.ao();
+		// Torch end
 		timings.doSounds.stopTiming(); // Spigot
 
 		timings.doChunkGC.startTiming();// Spigot
 		this.getWorld().processChunkGC(); // CraftBukkit
 		timings.doChunkGC.stopTiming(); // Spigot
 	}
+	
+	// Torch start - ticking staff
+	class SoundsTask extends RecursiveAction {
+		SoundsTask() {}
+		@Override protected void compute() { ao(); }
+	}
+	
+	class ChunkTicksTask extends RecursiveAction {
+		ChunkTicksTask() {}
+		@Override protected void compute() { j(); }
+	}
+	
+	class BlocksTask extends RecursiveAction {
+		BlocksTask() {}
+		@Override protected void compute() { a(false); }
+	}
+	// Torch end
 
 	@Nullable
 	public BiomeBase.BiomeMeta a(EnumCreatureType enumcreaturetype, BlockPosition blockposition) {
@@ -442,11 +468,6 @@ public class WorldServer extends World implements IAsyncTaskHandler {
 		this.methodProfiler.b();
 	}
 
-	// Hose start
-	light_tick l_task;
-	chunk_tick c_tick;
-
-	// Hose end
 	@Override
 	protected void j() {
 		this.i();
@@ -472,12 +493,14 @@ public class WorldServer extends World implements IAsyncTaskHandler {
 
 				this.methodProfiler.c("checkNextLight");
 				// chunk.n();
-				l_task = new light_tick(chunk);
-				l_task.fork();
+				light_tick l_task = new light_tick(chunk);
+				SpigotWorldConfig.TickPool.invoke(l_task);
+				// l_task.fork();
 				this.methodProfiler.c("tickChunk");
 				// chunk.b(false);
-				c_tick = new chunk_tick(chunk);
-				c_tick.fork();
+				chunk_tick c_task = new chunk_tick(chunk);
+				SpigotWorldConfig.TickPool.invoke(c_task);
+				// c_tick.fork();
 				if (!chunk.areNeighborsLoaded(1)) {
 					continue; // Spigot
 				}
@@ -713,9 +736,21 @@ public class WorldServer extends World implements IAsyncTaskHandler {
 		}
 
 	}
-
+	
+	// Torch start
+	class entitiesTickTask extends RecursiveAction {
+		entitiesTickTask() {}
+		@Override protected void compute() { tickEntities_task(); }
+	}
+	
 	@Override
 	public void tickEntities() {
+		entitiesTickTask task = new entitiesTickTask();
+		SpigotWorldConfig.TickPool.invoke(task);
+	}
+
+	public void tickEntities_task() {
+		// Torch end
 		if (false && this.players.isEmpty()) { // CraftBukkit - this prevents
 												// entity cleanup, other issues
 												// on servers with no players
diff --git a/src/main/java/org/bukkit/command/defaults/GCCommand.java b/src/main/java/org/bukkit/command/defaults/GCCommand.java
index d2158d5..14bb853 100644
--- a/src/main/java/org/bukkit/command/defaults/GCCommand.java
+++ b/src/main/java/org/bukkit/command/defaults/GCCommand.java
@@ -4,6 +4,7 @@ import java.util.concurrent.RecursiveAction;
 
 import org.bukkit.ChatColor;
 import org.bukkit.command.CommandSender;
+import org.spigotmc.SpigotWorldConfig;
 
 @Deprecated
 public class GCCommand extends VanillaCommand {
@@ -22,7 +23,7 @@ public class GCCommand extends VanillaCommand {
 		}
 
 		GCTask task = new GCTask(sender);
-		task.fork();
+		SpigotWorldConfig.TickPool.execute(task);
 
 		return true;
 	}
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index 4fdfe36..84733b2 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -1322,6 +1322,9 @@ public class CraftWorld implements World {
 				entity = new EntityLeash(world, new BlockPosition((int) x, (int) y, (int) z));
 				entity.attachedToPlayer = true;
 			} else {
+				// No valid face found
+                Preconditions.checkArgument(face != BlockFace.SELF, "Cannot spawn hanging entity for %s at %s (no free face)", clazz.getName(), location);
+                
 				EnumDirection dir = CraftBlock.blockFaceToNotch(face).opposite();
 				if (Painting.class.isAssignableFrom(clazz)) {
 					entity = new EntityPainting(world, new BlockPosition((int) x, (int) y, (int) z), dir);
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftLivingEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftLivingEntity.java
index 89e92d0..bba1278 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftLivingEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftLivingEntity.java
@@ -92,6 +92,7 @@ public class CraftLivingEntity extends CraftEntity implements LivingEntity {
 
 	@Override
 	public void setHealth(double health) {
+		health = (float) health; // Paper - convert health to a float during set to avoid the below error
 		if ((health < 0) || (health > getMaxHealth())) {
 			// Paper - Be more informative
 			throw new IllegalArgumentException("Health must be between 0 and " + getMaxHealth() + ", but was " + health
diff --git a/src/main/java/org/bukkit/craftbukkit/generator/CustomChunkGenerator.java b/src/main/java/org/bukkit/craftbukkit/generator/CustomChunkGenerator.java
index c166991..d73d628 100644
--- a/src/main/java/org/bukkit/craftbukkit/generator/CustomChunkGenerator.java
+++ b/src/main/java/org/bukkit/craftbukkit/generator/CustomChunkGenerator.java
@@ -83,7 +83,7 @@ public class CustomChunkGenerator extends InternalChunkGenerator {
 				}
 				// Build chunk section
 				if (emptyTest != 0) {
-					csect[sec] = new ChunkSection(sec << 4, true, section,
+					csect[sec] = new ChunkSection(chunk, sec << 4, true, section,
 					this.world.blockPacketController.getPredefinedBlockData(chunk, sec)); // Paper
 				}
 			}
@@ -108,7 +108,7 @@ public class CustomChunkGenerator extends InternalChunkGenerator {
 						secBlkID[i] = (char) Block.REGISTRY_ID.getId(b.getBlockData());
 					}
 					// Build chunk section
-					csect[sec] = new ChunkSection(sec << 4, true, secBlkID,
+					csect[sec] = new ChunkSection(chunk, sec << 4, true, secBlkID,
 					this.world.blockPacketController.getPredefinedBlockData(chunk, sec)); // Paper
 				}
 			} else { // Else check for byte-per-block section data
@@ -131,7 +131,7 @@ public class CustomChunkGenerator extends InternalChunkGenerator {
 							Block b = Block.getById(btypes[sec][i] & 0xFF);
                             secBlkID[i] = (char) Block.REGISTRY_ID.getId(b.getBlockData());
 						}
-						csect[sec] = new ChunkSection(sec << 4, true, secBlkID, this.world.blockPacketController.getPredefinedBlockData(chunk, sec)); // Paper
+						csect[sec] = new ChunkSection(chunk, sec << 4, true, secBlkID, this.world.blockPacketController.getPredefinedBlockData(chunk, sec)); // Paper
 					}
 				} else { // Else, fall back to pre 1.2 method
 					@SuppressWarnings("deprecation")
@@ -172,7 +172,7 @@ public class CustomChunkGenerator extends InternalChunkGenerator {
 						}
 						// If section built, finish prepping its state
 						if (csbytes != null) {
-							ChunkSection cs = csect[sec] = new ChunkSection(sec << 4, true, csbytes,
+							ChunkSection cs = csect[sec] = new ChunkSection(chunk, sec << 4, true, csbytes,
 							this.world.blockPacketController.getPredefinedBlockData(chunk, sec)); // Paper
 							cs.recalcBlockCounts();
 						}
diff --git a/src/main/java/org/bukkit/map/MapFont.java b/src/main/java/org/bukkit/map/MapFont.java
new file mode 100644
index 0000000..b0057ab
--- /dev/null
+++ b/src/main/java/org/bukkit/map/MapFont.java
@@ -0,0 +1,147 @@
+package org.bukkit.map;
+
+import java.util.HashMap;
+import org.bukkit.ChatColor;
+
+/**
+ * Represents a bitmap font drawable to a map.
+ */
+public class MapFont {
+
+    private final HashMap<Character, CharacterSprite> chars = new HashMap<Character, CharacterSprite>();
+    private int height = 0;
+    protected boolean malleable = true;
+
+    /**
+     * Set the sprite for a given character.
+     *
+     * @param ch The character to set the sprite for.
+     * @param sprite The CharacterSprite to set.
+     * @throws IllegalStateException if this font is static.
+     */
+    public void setChar(char ch, CharacterSprite sprite) {
+        if (!malleable) {
+            throw new IllegalStateException("this font is not malleable");
+        }
+
+        chars.put(ch, sprite);
+        if (sprite.getHeight() > height) {
+            height = sprite.getHeight();
+        }
+    }
+
+    /**
+     * Get the sprite for a given character.
+     *
+     * @param ch The character to get the sprite for.
+     * @return The CharacterSprite associated with the character, or null if
+     *     there is none.
+     */
+    public CharacterSprite getChar(char ch) {
+        return chars.get(ch);
+    }
+
+    /**
+     * Get the width of the given text as it would be rendered using this
+     * font.
+     *
+     * @param text The text.
+     * @return The width in pixels.
+     */
+    public int getWidth(String text) {
+        if (!isValid(text)) {
+            throw new IllegalArgumentException("text contains invalid characters");
+        }
+
+        if (text.length() == 0){
+            return 0;
+        }
+
+        int result = 0;
+        for (int i = 0; i < text.length(); ++i) {
+        	char ch = text.charAt(i);
+            if (ch == ChatColor.COLOR_CHAR) continue;
+            result += chars.get(ch).getWidth();
+        }
+        result += text.length() - 1; // Account for 1px spacing between characters
+
+        return result;
+    }
+
+    /**
+     * Get the height of this font.
+     *
+     * @return The height of the font.
+     */
+    public int getHeight() {
+        return height;
+    }
+
+    /**
+     * Check whether the given text is valid.
+     *
+     * @param text The text.
+     * @return True if the string contains only defined characters, false
+     *     otherwise.
+     */
+    public boolean isValid(String text) {
+        for (int i = 0; i < text.length(); ++i) {
+            char ch = text.charAt(i);
+            if (ch == ChatColor.COLOR_CHAR || ch == '\n') continue;
+            if (chars.get(ch) == null) return false;
+        }
+        return true;
+    }
+
+    /**
+     * Represents the graphics for a single character in a MapFont.
+     */
+    public static class CharacterSprite {
+
+        private final int width;
+        private final int height;
+        private final boolean[] data;
+
+        public CharacterSprite(int width, int height, boolean[] data) {
+            this.width = width;
+            this.height = height;
+            this.data = data;
+
+            if (data.length != width * height) {
+                throw new IllegalArgumentException("size of data does not match dimensions");
+            }
+        }
+
+        /**
+         * Get the value of a pixel of the character.
+         *
+         * @param row The row, in the range [0,8).
+         * @param col The column, in the range [0,8).
+         * @return True if the pixel is solid, false if transparent.
+         */
+        public boolean get(int row, int col) {
+            if (row < 0 || col < 0 || row >= height || col >= width) return false;
+            return data[row * width + col];
+        }
+
+        /**
+         * Get the width of the character sprite.
+         *
+         * @return The width of the character.
+         */
+        public int getWidth() {
+            return width;
+        }
+
+        /**
+         * Get the height of the character sprite.
+         *
+         * @return The height of the character.
+         */
+        public int getHeight() {
+            return height;
+        }
+
+    }
+
+}
diff --git a/src/main/java/org/spigotmc/ActivationRange.java b/src/main/java/org/spigotmc/ActivationRange.java
index ba2556d..b0ce04b 100644
--- a/src/main/java/org/spigotmc/ActivationRange.java
+++ b/src/main/java/org/spigotmc/ActivationRange.java
@@ -122,7 +122,8 @@ public class ActivationRange {
 					{
 						// activateChunkEntities( chunk ); // Paper
 						active_en en_task = new active_en(chunk);
-						en_task.fork();
+						SpigotWorldConfig.TickPool.execute(en_task);
+						// en_task.fork();
 					}
 				}
 			}
diff --git a/src/main/java/org/spigotmc/AsyncCatcher.java b/src/main/java/org/spigotmc/AsyncCatcher.java
index c2d5def..f1a3a54 100644
--- a/src/main/java/org/spigotmc/AsyncCatcher.java
+++ b/src/main/java/org/spigotmc/AsyncCatcher.java
@@ -18,8 +18,8 @@ public class AsyncCatcher {
 
 	public static void catchOp(String reason) {
 		if (enabled && Thread.currentThread() != MinecraftServer.getServer().primaryThread) {
-			SpigotWorldConfig.TickTask = ForkJoinTask.adapt(Thread.currentThread());
-			SpigotWorldConfig.TickPool.submit(SpigotWorldConfig.TickTask);
+			// SpigotWorldConfig.TickTask = ForkJoinTask.adapt(Thread.currentThread());
+			// SpigotWorldConfig.TickPool.submit(SpigotWorldConfig.TickTask);
 		}
 	}
 
diff --git a/src/main/java/org/spigotmc/RestartCommand.java b/src/main/java/org/spigotmc/RestartCommand.java
index eecffcc..6a68750 100644
--- a/src/main/java/org/spigotmc/RestartCommand.java
+++ b/src/main/java/org/spigotmc/RestartCommand.java
@@ -90,6 +90,12 @@ public class RestartCommand extends Command {
 			} else {
 				System.out.println(
 						"Startup script '" + SpigotConfig.restartScript + "' does not exist! Stopping server.");
+				
+				// Actually shutdown
+				try
+				{
+					MinecraftServer.getServer().stop();
+				} catch ( Throwable t ) {}
 			}
 			System.exit(0);
 		} catch (Exception ex) {
diff --git a/src/main/java/org/spigotmc/SpigotWorldConfig.java b/src/main/java/org/spigotmc/SpigotWorldConfig.java
index 37d023a..4de93ce 100644
--- a/src/main/java/org/spigotmc/SpigotWorldConfig.java
+++ b/src/main/java/org/spigotmc/SpigotWorldConfig.java
@@ -13,6 +13,14 @@ import net.minecraft.server.Chunk;
 public class SpigotWorldConfig {
 
 	// Hose start
+	public static ForkJoinTask<?> TickTask;
+    public static ForkJoinTask<Chunk> ChunkTask;
+    public static ForkJoinTask<?> EntityTask;
+    public static ForkJoinPool TickPool;
+    public static ForkJoinPool ChunkPool;
+    public static ForkJoinPool EntityPool;
+    
+    public static int worldtickentitypool_core_multiple;
 	static public final int cpu_core = Runtime.getRuntime().availableProcessors();
     
     static final ForkJoinPool.ForkJoinWorkerThreadFactory ftp = new ForkJoinPool.ForkJoinWorkerThreadFactory() {
@@ -34,23 +42,25 @@ public class SpigotWorldConfig {
         }
     };
     
-    public static ForkJoinTask<?> TickTask;
-    public static ForkJoinTask<Chunk> ChunkTask;
-    public static ForkJoinPool TickPool;
-    public static ForkJoinPool ChunkPool;
-    
-    public static int worldtickentitypool_core_multiple;
+    static final ForkJoinPool.ForkJoinWorkerThreadFactory ecp = new ForkJoinPool.ForkJoinWorkerThreadFactory() {
+        @Override
+        public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
+            final ForkJoinWorkerThread thread = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
+            thread.setName("EntityPool-" + thread.getPoolIndex());
+            return thread;
+        }
+    };
     
-    public static int getthreadnumber(){
+    public static int getthreadnumber() {
         return cpu_core*worldtickentitypool_core_multiple;
     }
     
-    private void wetp_core_multiple()
-    {
+    private void wetp_core_multiple() {
         worldtickentitypool_core_multiple = getInt("wetp-core-multiple", 2);
         
         TickPool = new ForkJoinPool(getthreadnumber(), ftp, null, false);
         ChunkPool = new ForkJoinPool(getthreadnumber(), fcp, null, false);
+        EntityPool = new ForkJoinPool(getthreadnumber(), ecp, null, false);
         
         log("WETP Core Multiple: " + worldtickentitypool_core_multiple);
     }
@@ -118,7 +128,7 @@ public class SpigotWorldConfig {
 				config.getInt("world-settings.default." + path));
 	}
 
-	private <T> List getList(String path, T def) {
+	private <T> List<?> getList(String path, T def) {
 		config.addDefault("world-settings.default." + path, def);
 		return config.getList("world-settings." + worldName + "." + path,
 				config.getList("world-settings.default." + path));
diff --git a/src/main/java/org/torch/util/bytes/ByteArrays.java b/src/main/java/org/torch/util/bytes/ByteArrays.java
index 100a364..cef0682 100644
--- a/src/main/java/org/torch/util/bytes/ByteArrays.java
+++ b/src/main/java/org/torch/util/bytes/ByteArrays.java
@@ -430,7 +430,6 @@ public class ByteArrays {
 		}
 	}
 
-	@SuppressWarnings("unchecked")
 	private static void selectionSort(final byte[] a, final int from, final int to) {
 		for (int i = from; i < to - 1; i++) {
 			int m = i;
@@ -447,7 +446,6 @@ public class ByteArrays {
 		}
 	}
 
-	@SuppressWarnings("unchecked")
 	private static void insertionSort(final byte[] a, final int from, final int to) {
 		for (int i = from; ++i < to;) {
 			byte t = a[i];
@@ -568,7 +566,6 @@ public class ByteArrays {
 		quickSort(x, 0, x.length, comp);
 	}
 
-	@SuppressWarnings("unchecked")
 	private static int med3(final byte x[], final int a, final int b, final int c) {
 		int ab = ((x[a]) < (x[b]) ? -1 : ((x[a]) == (x[b]) ? 0 : 1));
 		int ac = ((x[a]) < (x[c]) ? -1 : ((x[a]) == (x[c]) ? 0 : 1));
@@ -597,7 +594,6 @@ public class ByteArrays {
 	 * @param to
 	 *            the index of the last element (exclusive) to be sorted.
 	 */
-	@SuppressWarnings("unchecked")
 	public static void quickSort(final byte[] x, final int from, final int to) {
 		final int len = to - from;
 		// Selection sort on smallest arrays
@@ -696,7 +692,6 @@ public class ByteArrays {
 	 *            and whose entries are identical to those of {@code a} in the
 	 *            specified range.
 	 */
-	@SuppressWarnings("unchecked")
 	public static void mergeSort(final byte a[], final int from, final int to, final byte supp[]) {
 		int len = to - from;
 		// Insertion sort on smallest arrays
@@ -782,7 +777,6 @@ public class ByteArrays {
 	 *            and whose entries are identical to those of {@code a} in the
 	 *            specified range.
 	 */
-	@SuppressWarnings("unchecked")
 	public static void mergeSort(final byte a[], final int from, final int to, ByteComparator comp, final byte supp[]) {
 		int len = to - from;
 		// Insertion sort on smallest arrays
@@ -875,7 +869,6 @@ public class ByteArrays {
 	 *         the key is found.
 	 * @see java.util.Arrays
 	 */
-	@SuppressWarnings({ "unchecked", "rawtypes" })
 	public static int binarySearch(final byte[] a, int from, int to, final byte key) {
 		byte midVal;
 		to--;
@@ -1223,6 +1216,7 @@ public class ByteArrays {
 	 * @param stable
 	 *            whether the sorting algorithm should be stable.
 	 */
+	@SuppressWarnings("deprecation")
 	public static void radixSortIndirect(final int[] perm, final byte[] a, final int from, final int to,
 			final boolean stable) {
 		final int maxLevel = DIGITS_PER_ELEMENT - 1;
@@ -1586,6 +1580,7 @@ public class ByteArrays {
 	 * @param stable
 	 *            whether the sorting algorithm should be stable.
 	 */
+	@SuppressWarnings("deprecation")
 	public static void radixSortIndirect(final int[] perm, final byte[] a, final byte[] b, final int from, final int to,
 			final boolean stable) {
 		final int layers = 2;
-- 
2.8.2.windows.1

