From 99b0232c61c437f34d0233d1ed72bfc53c7524ce Mon Sep 17 00:00:00 2001
From: SotrForgotten <i@omc.hk>
Date: Tue, 12 Jul 2016 04:44:10 +0800
Subject: [PATCH] Synchronize-ChunkIOExecutor-Access


diff --git a/src/main/java/de/minetick/AutoSaveJob.java b/src/main/java/de/minetick/AutoSaveJob.java
index 5531183..1368ea1 100644
--- a/src/main/java/de/minetick/AutoSaveJob.java
+++ b/src/main/java/de/minetick/AutoSaveJob.java
@@ -1,7 +1,6 @@
 package de.minetick;
 
 import org.bukkit.Bukkit;
-import org.bukkit.craftbukkit.SpigotTimings;
 import org.bukkit.event.world.WorldSaveEvent;
 
 import net.minecraft.server.ExceptionWorldConflict;
@@ -11,6 +10,8 @@ import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.RegionFileCache;
 import net.minecraft.server.WorldServer;
 
+import co.aikar.timings.MinecraftTimings; // Paper
+
 public class AutoSaveJob {
 
     public enum JobDetail {
@@ -34,18 +35,18 @@ public class AutoSaveJob {
 
     public boolean process() throws ExceptionWorldConflict {
         if(this.isJob(JobDetail.WORLD_SAVE) && this.worldserver != null) {
-            SpigotTimings.worldSaveTimer.startTiming();
+            MinecraftTimings.worldSaveTimer.startTiming();
             MinecraftServer.getServer().info("[AutoSave] Saving world " + this.worldserver.getWorld().getName());
             this.worldserver.save(true, (IProgressUpdate) null);
             FileIOThread.a().setNoDelay(true);
-            SpigotTimings.worldSaveTimer.stopTiming();
+            MinecraftTimings.worldSaveTimer.stopTiming();
         } else if(this.isJob(JobDetail.WORLD_SAVEEVENT) && this.worldserver != null) {
             if(FileIOThread.a().isDone()) {
-                SpigotTimings.worldSaveTimer.startTiming();
+                MinecraftTimings.worldSaveTimer.startTiming();
                 FileIOThread.a().setNoDelay(false);
                 RegionFileCache.a();
                 Bukkit.getPluginManager().callEvent(new WorldSaveEvent(this.worldserver.getWorld()));
-                SpigotTimings.worldSaveTimer.stopTiming();
+                MinecraftTimings.worldSaveTimer.stopTiming();
             } else {
                 return false;
             }
diff --git a/src/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOExecutor.java b/src/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOExecutor.java
index 2dc688c..085cabd 100644
--- a/src/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOExecutor.java
+++ b/src/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOExecutor.java
@@ -15,16 +15,22 @@ public class ChunkIOExecutor {
     private static final AsynchronousExecutor<QueuedChunk, Chunk, Runnable, RuntimeException> instance = new AsynchronousExecutor<QueuedChunk, Chunk, Runnable, RuntimeException>(new ChunkIOProvider(), BASE_THREADS);
 
     public static Chunk syncChunkLoad(World world, IChunkLoader loader, ChunkProviderServer provider, int x, int z) {
-        return instance.getSkipQueue(new QueuedChunk(x, z, loader, world, provider)); // Torch - permit async
+        synchronized(instance) { // Migot
+            return instance.getSkipQueue(new QueuedChunk(x, z, loader, world, provider));
+        }
     }
 
     public static void queueChunkLoad(World world, IChunkLoader loader, ChunkProviderServer provider, int x, int z, Runnable runnable) {
-        instance.add(new QueuedChunk(x, z, loader, world, provider), runnable);
+        synchronized(instance) { // Migot
+            instance.add(new QueuedChunk(x, z, loader, world, provider), runnable);
+        }
     }
 
     // Abuses the fact that hashCode and equals for QueuedChunk only use world and coords
     public static void dropQueuedChunkLoad(World world, int x, int z, Runnable runnable) {
-        instance.drop(new QueuedChunk(x, z, null, world, null), runnable);
+        synchronized(instance) { // Migot
+            instance.drop(new QueuedChunk(x, z, null, world, null), runnable);
+        }
     }
 
 	/*
-- 
2.8.2.windows.1

