From 37c97556951def1273319f23bfb2c17845adfb65 Mon Sep 17 00:00:00 2001
From: SotrForgotten <i@omc.hk>
Date: Sun, 26 Jun 2016 08:27:39 +0800
Subject: [PATCH] Optimize DataPalleteBlock and getType


diff --git a/src/main/java/com/destroystokyo/paper/profile/AsyncNamePreResolveEvent.java b/src/main/java/com/destroystokyo/paper/profile/AsyncNamePreResolveEvent.java
index e06f9be..c1b9810 100644
--- a/src/main/java/com/destroystokyo/paper/profile/AsyncNamePreResolveEvent.java
+++ b/src/main/java/com/destroystokyo/paper/profile/AsyncNamePreResolveEvent.java
@@ -1,62 +1,55 @@
 package com.destroystokyo.paper.profile.event;
 
+import com.destroystokyo.paper.profile.LookupCause;
 import com.destroystokyo.paper.profile.AccountProfile;
 import com.google.common.base.Preconditions;
 
-import org.bukkit.Bukkit;
-import org.bukkit.event.Event;
-import com.destroystokyo.paper.profile.LookupCause;
+import org.bukkit.event.HandlerList;
 
 /**
- * Called before a profile is looked up from mojang.
- * Plugins can set a profile, which will effectively 'cancel' the lookup from mojang.
- * <p>May be called from the main thread if the lookup is from the main thread.</p>
- */
-public abstract class AsyncProfilePreResolveEvent extends Event {
-    private final LookupCause cause;
-    private AccountProfile result;
-
-    public AsyncProfilePreResolveEvent(LookupCause cause) {
-        super(!Bukkit.isPrimaryThread());
-        this.cause = Preconditions.checkNotNull(cause, "Null cause");;
-    }
-
-    /**
-     * Get the reason this profile is being looked up
-     * @return the reason this profile is being looked up
-     */
-    public LookupCause getCause() {
-        return cause;
-    }
-
-    /**
-     * Set the profile that will be returned by the lookup
-     * <p>Overrides any existing profile, and prevents a lookup from mojang.
-     * Setting to null re-allows a mojang lookup.</p>
-     *
-     * @param result the profile that will be returned by the lookup
-     */
-    public void setResult(AccountProfile result) {
-        this.result = result;
-    }
-
-    /**
-     * Get if a plugin has set the profile to be returned, and prevented a lookup to mojang
-     * <p>If not, it must be looked up from mojang</p>
-     *
-     * @return if a plugin has overriden the profile to be returned
-     */
-    public boolean isResolved() {
-        return result != null;
-    }
-
-    /**
-     * Get the profile that will be returned by the lookup, if another plugin has set it
-     * <p>If this returns null, than no plugin has set the profile and it must be looked up from mojang</p>
-     *
-     * @return the profile that has been set, or null if not set
-     */
-    public AccountProfile getResult() {
-        return result;
-    }
+* Called before a uuid is requested from mojang.
+* <p>
+* <p>The event may be called synchronouslys if the uuid is resolved on the main thread</p>
+*/
+public class AsyncNamePreResolveEvent extends AsyncProfilePreResolveEvent {
+   private final String name;
+
+   public AsyncNamePreResolveEvent(String name) {
+       super(LookupCause.NAME_LOOKUP);
+       Preconditions.checkNotNull(name, "Null name");
+       this.name = name;
+   }
+
+   /**
+    * Return the name that was used to request the profile
+    *
+    * @return the name that was requested
+    */
+   public String getName() {
+       return name;
+   }
+
+   /**
+    * {@inheritDoc}
+    *
+    * @throws IllegalArgumentException if the profile's name doesn't match the looked up names
+    */
+   @Override
+   public void setResult(AccountProfile result) {
+       if (result != null) {
+           Preconditions.checkArgument(result.getName().equalsIgnoreCase(this.getName()), "Name %s doesn't match looked up name: %s", result.getName(), this.getName());
+       }
+       super.setResult(result);
+   }
+
+   private static final HandlerList handlerList = new HandlerList();
+
+   public static HandlerList getHandlerList() {
+       return handlerList;
+   }
+
+   @Override
+   public HandlerList getHandlers() {
+       return handlerList;
+   }
 }
\ No newline at end of file
diff --git a/src/main/java/net/minecraft/server/DataPaletteBlock.java b/src/main/java/net/minecraft/server/DataPaletteBlock.java
index b395221..ecef606 100644
--- a/src/main/java/net/minecraft/server/DataPaletteBlock.java
+++ b/src/main/java/net/minecraft/server/DataPaletteBlock.java
@@ -6,9 +6,10 @@ public class DataPaletteBlock implements DataPaletteExpandable {
 
     private static final DataPalette d = new DataPaletteGlobal();
     protected static final IBlockData a = Blocks.AIR.getBlockData();
-    protected DataBits b;
+    // protected DataBits b; // Paper - nope
     protected DataPalette c;
     private int e = 0;
+	private final short[] data = new short[4096]; // Paper
 
     public DataPaletteBlock() {
         this.b(4);
@@ -32,18 +33,20 @@ public class DataPaletteBlock implements DataPaletteExpandable {
             }
 
             this.c.a(DataPaletteBlock.a);
-            this.b = new DataBits(this.e, 4096);
+            //this.b = new DataBits(this.e, 4096);
         }
     }
 
     public int a(int i, IBlockData iblockdata) {
-        DataBits databits = this.b;
+        //DataBits databits = this.b;
         DataPalette datapalette = this.c;
 
         this.b(i);
 
-        for (int j = 0; j < databits.b(); ++j) {
-            IBlockData iblockdata1 = datapalette.a(databits.a(j));
+        // Paper start - DataBits -> data
+        for (int j = 0; j < 4096; ++j) {
+            IBlockData iblockdata1 = datapalette.a(data[j]);
+            // Paper end
 
             if (iblockdata1 != null) {
                 this.setBlockIndex(j, iblockdata1);
@@ -58,9 +61,9 @@ public class DataPaletteBlock implements DataPaletteExpandable {
     }
 
     protected void setBlockIndex(int i, IBlockData iblockdata) {
-        int j = this.c.a(iblockdata);
-
-        this.b.a(i, j);
+        //int j = this.c.a(iblockdata);
+		data[i] = (short) Block.REGISTRY_ID.getId(iblockdata);
+        //this.b.a(i, j);
     }
 
     public IBlockData a(int i, int j, int k) {
@@ -68,15 +71,25 @@ public class DataPaletteBlock implements DataPaletteExpandable {
     }
 
     protected IBlockData a(int i) {
-        IBlockData iblockdata = this.c.a(this.b.a(i));
+        IBlockData iblockdata = Block.REGISTRY_ID.fromId(data[i]); // Paper - performance sanity
 
         return iblockdata == null ? DataPaletteBlock.a : iblockdata;
     }
+	
+	// Paper start - serialization method
+   public DataBits toMojangBits() {
+       DataBits bits = new DataBits(this.e, 4096);
+       for (int i = 0; i < 4096; i++) {
+           bits.a(i, this.c.a(Block.REGISTRY_ID.fromId(data[i])));
+       }
+       return bits;
+   }
+   // Paper end
 
     public void b(PacketDataSerializer packetdataserializer) {
         packetdataserializer.writeByte(this.e);
         this.c.b(packetdataserializer);
-        packetdataserializer.a(this.b.a());
+        packetdataserializer.a(toMojangBits().a()); // Paper - serialize
     }
 
     @Nullable
@@ -132,6 +145,6 @@ public class DataPaletteBlock implements DataPaletteExpandable {
     }
 
     public int a() {
-        return 1 + this.c.a() + PacketDataSerializer.a(this.b.b()) + this.b.a().length * 8;
+        return 1 + this.c.a() + PacketDataSerializer.a(this.toMojangBits().b()) + this.toMojangBits().a().length * 8;
     }
 }
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index 3e47b47..82183dd 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -796,15 +796,7 @@ public abstract class World implements IBlockAccess {
 
     // Paper start - reduces need to do isLoaded before getType
     public IBlockData getTypeIfLoaded(BlockPosition blockposition) {
-        // CraftBukkit start - tree generation
-		final int x = blockposition.getX();
-        final int y = blockposition.getY();
-        final int z = blockposition.getZ();
-        final IBlockData previous = getCapturedBlockType(x, y, z);
-            if (previous != null) {
-                return previous;
-            }
-        // CraftBukkit end
+        if (captureTreeGeneration) return findCaptured(blockposition); // use seperate findCaptured() method
         Chunk chunk = ((ChunkProviderServer) this.chunkProvider).getChunkIfLoaded(x >> 4, z >> 4);
         if (chunk != null) {
             return chunk.getBlockData(x, y, z);
@@ -813,20 +805,22 @@ public abstract class World implements IBlockAccess {
     }
     // Paper end
 
-    public IBlockData getType(BlockPosition blockposition) {
-        // CraftBukkit start - tree generation
-		// Paper start - optimize getType lookup to reduce instructions - getBlockData already enforces valid Y, move tree out
-        final int x = blockposition.getX();
-        final int y = blockposition.getY();
-        final int z = blockposition.getZ();
-        if (captureTreeGeneration) {
-            final IBlockData previous = getCapturedBlockType(x, y, z);
-            if (previous != null) {
-                return previous;
+    // Paper start - optimize getType
+    // hoist tree generation into a seperate method to assist inlining
+    public IBlockData getType(BlockPosition pos) {
+        return getType(pos, this.captureTreeGeneration);
+    }
+	
+	private IBlockData findCaptured(BlockPosition blockposition) {
+        Iterator<BlockState> it = capturedBlockStates.iterator();
+       while (it.hasNext()) {
+           BlockState previous = it.next();
+           if (previous.getX() == blockposition.getX() && previous.getY() == blockposition.getY() && previous.getZ() == blockposition.getZ()) {
+               return CraftMagicNumbers.getBlock(previous.getTypeId()).fromLegacyData(previous.getRawData());
             }
         }
         // CraftBukkit end
-        return this.chunkProvider.getChunkAt(x >> 4, z >> 4).getBlockData(x, y, z);
+        return getType(blockposition, captureTreeGeneration);
         // Paper end
     }
 	
@@ -842,6 +836,22 @@ public abstract class World implements IBlockAccess {
        return null;
 	}
 	// Paper end
+	
+	public IBlockData getType(BlockPosition blockposition, boolean captureTreeGeneration) {
+      if (captureTreeGeneration) {
+          // CraftBukkit end
+          return findCaptured(blockposition); // Move into seperate method to assist inlining
+         }
+      if (blockposition.isValidLocation()) { // Paper
+          Chunk chunk = this.getChunkAtWorldCoords(blockposition);
+          ChunkSection chunksection = chunk.getSections()[blockposition.getY() >> 4];
+          if (chunksection != null) {
+              return chunksection.getType(blockposition.getX() & 15, blockposition.getY() & 15, blockposition.getZ() & 15);
+          }
+      }
+      return Blocks.AIR.getBlockData();
+     }
+  // Paper end
 
     public boolean B() {
         return this.J < 4;
-- 
2.8.2.windows.1

