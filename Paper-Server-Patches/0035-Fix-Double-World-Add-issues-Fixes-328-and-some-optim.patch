From dcb1980530849382d8bd86ac107cf92c5645d3af Mon Sep 17 00:00:00 2001
From: SotrForgotten <i@omc.hk>
Date: Sun, 26 Jun 2016 03:28:48 +0800
Subject: [PATCH] Fix Double World Add issues - Fixes #328 and some optimize


diff --git a/src/main/java/net/minecraft/server/BaseBlockPosition.java b/src/main/java/net/minecraft/server/BaseBlockPosition.java
index 5fe250a..e11f87d 100644
--- a/src/main/java/net/minecraft/server/BaseBlockPosition.java
+++ b/src/main/java/net/minecraft/server/BaseBlockPosition.java
@@ -11,12 +11,13 @@ public class BaseBlockPosition implements Comparable<BaseBlockPosition> {
      protected int a;
      protected int b;
      protected int c;
-    // TacoSpigot end
-	// Torch - backport
-    // Paper start
+   // Paper start
     public final boolean isValidLocation() { // TacoSpigot - final for no overrides
         return a >= -30000000 && c >= -30000000 && a < 30000000 && c < 30000000 && b >= 0 && b < 256;
     }
+    public final boolean isInvalidYLocation() { // Torch - final for no overrides
+        return b < 0 || b >= 256;
+    }
     // Paper end
 
     public BaseBlockPosition(int i, int j, int k) {
diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java
index 586c1e3..abede44 100644
--- a/src/main/java/net/minecraft/server/Chunk.java
+++ b/src/main/java/net/minecraft/server/Chunk.java
@@ -407,18 +407,28 @@ public class Chunk {
         return this.a(i, j, k).c();
     }
 
-    // Paper - Optimize getBlockData
-    public IBlockData getBlockData(BlockPosition blockposition) {
-        if (blockposition.getY() >= 0 && blockposition.getY() >> 4 < this.sections.length) {
-            ChunkSection chunksection = this.sections[blockposition.getY() >> 4];
-            if (chunksection != null) {
-                return chunksection.getType(blockposition.getX() & 15, blockposition.getY() & 15, blockposition.getZ() & 15);
-            }
-        }
-        return Blocks.AIR.getBlockData();
-    }
+	// Torch - backport
+    // Paper start - Optimize getBlockData to reduce instructions
+   public final IBlockData getBlockData(final BlockPosition pos) {
+       return getBlockData(pos.getX(), pos.getY(), pos.getZ());
+   }
+
+   public final IBlockData getBlockData(final int x, final int y, final int z) {
+       // Method body / logic copied from below
+       final int i = y >> 4;
+       if (y >= 0 && i < this.sections.length && this.sections[i] != null) {
+           // Inlined ChunkSection.getType() and DataPaletteBlock.a(int,int,int)
+           return this.sections[i].blockIds.a((y & 15) << 8 | (z & 15) << 4 | x & 15);
+       }
+       return Blocks.AIR.getBlockData();
+     }
+   }
 
     public IBlockData a(final int i, final int j, final int k) {
+		return getBlockData(i, j, k);
+    }
+    public IBlockData unused(final int i, final int j, final int k) {
+    // Paper end
         if (this.world.L() == WorldType.DEBUG_ALL_BLOCK_STATES) {
             IBlockData iblockdata = null;
 
diff --git a/src/main/java/net/minecraft/server/ChunkRegionLoader.java b/src/main/java/net/minecraft/server/ChunkRegionLoader.java
index 8205625..1250499 100644
--- a/src/main/java/net/minecraft/server/ChunkRegionLoader.java
+++ b/src/main/java/net/minecraft/server/ChunkRegionLoader.java
@@ -486,7 +486,7 @@ public class ChunkRegionLoader implements IChunkLoader, IAsyncChunkSaver {
     }
 
     public static void a(Entity entity, World world, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason reason) {
-        if (world.addEntity(entity, reason) && entity.isVehicle()) {
+        if (!entity.valid && world.addEntity(entity, reason) && entity.isVehicle()) { // Paper
             // CraftBukkit end
             Iterator iterator = entity.bv().iterator();
 
diff --git a/src/main/java/net/minecraft/server/ChunkSection.java b/src/main/java/net/minecraft/server/ChunkSection.java
index 55e5e33..2d92d5d 100644
--- a/src/main/java/net/minecraft/server/ChunkSection.java
+++ b/src/main/java/net/minecraft/server/ChunkSection.java
@@ -5,6 +5,7 @@ public class ChunkSection {
     private int yPos;
     private int nonEmptyBlockCount;
     private int tickingBlockCount;
+	final DataPaletteBlock blockIds; // Paper - package // Torch - backport
     private DataPaletteBlock blockIds;
     private NibbleArray emittedLight;
     private NibbleArray skyLight;
diff --git a/src/main/java/net/minecraft/server/MCUtil.java b/src/main/java/net/minecraft/server/MCUtil.java
index 1bfd820..1e7e298 100644
--- a/src/main/java/net/minecraft/server/MCUtil.java
+++ b/src/main/java/net/minecraft/server/MCUtil.java
@@ -1,5 +1,5 @@
 package net.minecraft.server;
-
++
 import com.google.common.util.concurrent.ThreadFactoryBuilder;
 import org.bukkit.Location;
 import org.bukkit.craftbukkit.util.Waitable;
@@ -10,191 +10,190 @@ import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Executor;
 import java.util.concurrent.Executors;
 import java.util.function.Supplier;
-import com.google.common.util.concurrent.ThreadFactoryBuilder;
 import java.util.regex.Pattern;
 
 public final class MCUtil {
-    private static final Pattern REPLACE_QUOTES = Pattern.compile("\"");
-    private static final Executor asyncExecutor = Executors.newSingleThreadExecutor(new ThreadFactoryBuilder().setNameFormat("Paper Async Task Handler Thread - %1$d").build());
-
-    private MCUtil() {}
-
-
-    /**
-     * Builds a chat componenent from a string.
-     * @param str
-     * @return
-     */
-    public static IChatBaseComponent cmpFromMessage(String str) {
-        return IChatBaseComponent.ChatSerializer.a("{\"text\":\"" + REPLACE_QUOTES.matcher(str).replaceAll("\\\"") + "\"}");
-    }
-
-    /**
-     * Ensures the target code is running on the main thread
-     * @param reason
-     * @param run
-     * @param <T>
-     * @return
-     */
-    public static <T> T ensureMain(String reason, Supplier<T> run) {
-        if (AsyncCatcher.enabled && Thread.currentThread() != MinecraftServer.getServer().primaryThread) {
-            new IllegalStateException( "Asynchronous " + reason + "! Blocking thread until it returns ").printStackTrace();
-            Waitable<T> wait = new Waitable<T>() {
-                @Override
-                protected T evaluate() {
-                    return run.get();
-                }
-            };
-            MinecraftServer.getServer().processQueue.add(wait);
-            try {
-                return wait.get();
-            } catch (InterruptedException | ExecutionException e) {
-                e.printStackTrace();
-            }
-            return null;
-        }
-        return run.get();
-    }
-
-    /**
-     * Calculates distance between 2 entities
-     * @param e1
-     * @param e2
-     * @return
-     */
-    public static double distance(Entity e1, Entity e2) {
-        return Math.sqrt(distanceSq(e1, e2));
-    }
-
-
-    /**
-     * Calculates distance between 2 block positions
-     * @param e1
-     * @param e2
-     * @return
-     */
-    public static double distance(BlockPosition e1, BlockPosition e2) {
-        return Math.sqrt(distanceSq(e1, e2));
-    }
-
-    /**
-     * Gets the distance between 2 positions
-     * @param x1
-     * @param y1
-     * @param z1
-     * @param x2
-     * @param y2
-     * @param z2
-     * @return
-     */
-    public static double distance(double x1, double y1, double z1, double x2, double y2, double z2) {
-        return Math.sqrt(distanceSq(x1, y1, z1, x2, y2, z2));
-    }
-
-    /**
-     * Get's the distance squared between 2 entities
-     * @param e1
-     * @param e2
-     * @return
-     */
-    public static double distanceSq(Entity e1, Entity e2) {
-        return distanceSq(e1.locX,e1.locY,e1.locZ, e2.locX,e2.locY,e2.locZ);
-    }
-
-    /**
-     * Gets the distance sqaured between 2 block positions
-     * @param pos1
-     * @param pos2
-     * @return
-     */
-    public static double distanceSq(BlockPosition pos1, BlockPosition pos2) {
-        return distanceSq(pos1.getX(), pos1.getY(), pos1.getZ(), pos2.getX(), pos2.getY(), pos2.getZ());
-    }
-
-    /**
-     * Gets the distance squared between 2 positions
-     * @param x1
-     * @param y1
-     * @param z1
-     * @param x2
-     * @param y2
-     * @param z2
-     * @return
-     */
-    public static double distanceSq(double x1, double y1, double z1, double x2, double y2, double z2) {
-        return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) + (z1 - z2) * (z1 - z2);
-    }
-
-    /**
-     * Converts a NMS World/BlockPosition to Bukkit Location
-     * @param world
-     * @param pos
-     * @return
-     */
-    public static Location toLocation(World world, BlockPosition pos) {
-        return new Location(world.getWorld(), pos.getX(), pos.getY(), pos.getZ());
-    }
-
-    /**
-     * Converts an NMS entity's current location to a Bukkit Location
-     * @param entity
-     * @return
-     */
-    public static Location toLocation(Entity entity) {
-        return new Location(entity.getWorld().getWorld(), entity.locX, entity.locY, entity.locZ);
-    }
-
-    public static BlockPosition toBlockPosition(Location loc) {
-        return new BlockPosition(loc.getBlockX(), loc.getBlockY(), loc.getBlockZ());
-    }
-
-    public static boolean isEdgeOfChunk(BlockPosition pos) {
-        final int modX = pos.getX() & 15;
-        final int modZ = pos.getZ() & 15;
-        return (modX == 0 || modX == 15 || modZ == 0 || modZ == 15);
-    }
-
-    /**
-     * Gets a chunk without changing its boolean for should unload
-     * @param world
-     * @param x
-     * @param z
-     * @return
-     */
-    @Nullable
-    public static Chunk getLoadedChunkWithoutMarkingActive(World world, int x, int z) {
-        return ((ChunkProviderServer) world.chunkProvider).chunks.get(ChunkCoordIntPair.a(x, z));
-    }
-
-    /**
-     * Gets a chunk without changing its boolean for should unload
-     * @param provider
-     * @param x
-     * @param z
-     * @return
-     */
-    @Nullable
-    public static Chunk getLoadedChunkWithoutMarkingActive(IChunkProvider provider, int x, int z) {x, int z) {
-        return ((ChunkProviderServer)provider).chunks.get(ChunkCoordIntPair.a(x, z));
-    }
-
-    /**
-     * Posts a task to be executed asynchronously
-     * @param run
-     */
-    public static void scheduleAsyncTask(Runnable run) {
-        asyncExecutor.execute(run);
-    }
-	
-	@Nullable
-   public static TileEntityHopper getHopper(World world, BlockPosition pos) {
-       Chunk chunk = world.getChunkIfLoaded(pos.getX() >> 4, pos.getZ() >> 4);
-       if (chunk != null && chunk.getBlockData(pos).getBlock() == Blocks.HOPPER) {
-           TileEntity tileEntity = chunk.getTileEntityImmediately(pos);
-           if (tileEntity instanceof TileEntityHopper) {
-               return (TileEntityHopper) tileEntity;
-           }
-       }
-       return null;
-   }
-}
+  private static final Pattern REPLACE_QUOTES = Pattern.compile("\"");
+  private static final Executor asyncExecutor = Executors.newSingleThreadExecutor(new ThreadFactoryBuilder().setNameFormat("Paper Async Task Handler Thread - %1$d").build());
+
+  private MCUtil() {}
+
+
+  /**
+   * Builds a chat componenent from a string.
+   * @param str
+   * @return
+   */
+  public static IChatBaseComponent cmpFromMessage(String str) {
+      return IChatBaseComponent.ChatSerializer.a("{\"text\":\"" + REPLACE_QUOTES.matcher(str).replaceAll("\\\"") + "\"}");
+  }
+
+  /**
+   * Ensures the target code is running on the main thread
+   * @param reason
+   * @param run
+   * @param <T>
+   * @return
+   */
+  public static <T> T ensureMain(String reason, Supplier<T> run) {
+      if (AsyncCatcher.enabled && Thread.currentThread() != MinecraftServer.getServer().primaryThread) {
+          new IllegalStateException( "Asynchronous " + reason + "! Blocking thread until it returns ").printStackTrace();
+          Waitable<T> wait = new Waitable<T>() {
+              @Override
+              protected T evaluate() {
+                  return run.get();
+              }
+          };
+          MinecraftServer.getServer().processQueue.add(wait);
+          try {
+              return wait.get();
+          } catch (InterruptedException | ExecutionException e) {
+              e.printStackTrace();
+          }
+          return null;
+      }
+      return run.get();
+  }
+
+  /**
+   * Calculates distance between 2 entities
+   * @param e1
+   * @param e2
+   * @return
+   */
+  public static double distance(Entity e1, Entity e2) {
+      return Math.sqrt(distanceSq(e1, e2));
+  }
+
+
+  /**
+   * Calculates distance between 2 block positions
+   * @param e1
+   * @param e2
+   * @return
+   */
+  public static double distance(BlockPosition e1, BlockPosition e2) {
+      return Math.sqrt(distanceSq(e1, e2));
+  }
+
+  /**
+   * Gets the distance between 2 positions
+   * @param x1
+   * @param y1
+   * @param z1
+   * @param x2
+   * @param y2
+   * @param z2
+   * @return
+   */
+  public static double distance(double x1, double y1, double z1, double x2, double y2, double z2) {
+      return Math.sqrt(distanceSq(x1, y1, z1, x2, y2, z2));
+  }
+
+  /**
+   * Get's the distance squared between 2 entities
+   * @param e1
+   * @param e2
+   * @return
+   */
+  public static double distanceSq(Entity e1, Entity e2) {
+      return distanceSq(e1.locX,e1.locY,e1.locZ, e2.locX,e2.locY,e2.locZ);
+  }
+
+  /**
+   * Gets the distance sqaured between 2 block positions
+   * @param pos1
+   * @param pos2
+   * @return
+   */
+  public static double distanceSq(BlockPosition pos1, BlockPosition pos2) {
+      return distanceSq(pos1.getX(), pos1.getY(), pos1.getZ(), pos2.getX(), pos2.getY(), pos2.getZ());
+  }
+
+  /**
+   * Gets the distance squared between 2 positions
+   * @param x1
+   * @param y1
+   * @param z1
+   * @param x2
+   * @param y2
+   * @param z2
+   * @return
+   */
+  public static double distanceSq(double x1, double y1, double z1, double x2, double y2, double z2) {
+      return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) + (z1 - z2) * (z1 - z2);
+  }
+
+  /**
+   * Converts a NMS World/BlockPosition to Bukkit Location
+   * @param world
+   * @param pos
+   * @return
+   */
+  public static Location toLocation(World world, BlockPosition pos) {
+      return new Location(world.getWorld(), pos.getX(), pos.getY(), pos.getZ());
+  }
+
+  /**
+   * Converts an NMS entity's current location to a Bukkit Location
+   * @param entity
+   * @return
+   */
+  public static Location toLocation(Entity entity) {
+      return new Location(entity.getWorld().getWorld(), entity.locX, entity.locY, entity.locZ);
+  }
+
+  public static BlockPosition toBlockPosition(Location loc) {
+      return new BlockPosition(loc.getBlockX(), loc.getBlockY(), loc.getBlockZ());
+  }
+
+  public static boolean isEdgeOfChunk(BlockPosition pos) {
+      final int modX = pos.getX() & 15;
+      final int modZ = pos.getZ() & 15;
+      return (modX == 0 || modX == 15 || modZ == 0 || modZ == 15);
+  }
+
+  /**
+   * Gets a chunk without changing its boolean for should unload
+   * @param world
+   * @param x
+   * @param z
+   * @return
+   */
+  @Nullable
+  public static Chunk getLoadedChunkWithoutMarkingActive(World world, int x, int z) {
+      return ((ChunkProviderServer) world.chunkProvider).chunks.get(ChunkCoordIntPair.a(x, z));
+  }
+
+  /**
+   * Gets a chunk without changing its boolean for should unload
+   * @param provider
+   * @param x
+   * @param z
+   * @return
+   */
+  @Nullable
+  public static Chunk getLoadedChunkWithoutMarkingActive(IChunkProvider provider, int x, int z) {
+      return ((ChunkProviderServer)provider).chunks.get(ChunkCoordIntPair.a(x, z));
+  }
+
+  /**
+   * Posts a task to be executed asynchronously
+   * @param run
+   */
+  public static void scheduleAsyncTask(Runnable run) {
+      asyncExecutor.execute(run);
+  }
+
+  @Nullable
+  public static TileEntityHopper getHopper(World world, BlockPosition pos) {
+      Chunk chunk = world.getChunkIfLoaded(pos.getX() >> 4, pos.getZ() >> 4);
+      if (chunk != null && chunk.getBlockData(pos).getBlock() == Blocks.HOPPER) {
+          TileEntity tileEntity = chunk.getTileEntityImmediately(pos);
+          if (tileEntity instanceof TileEntityHopper) {
+              return (TileEntityHopper) tileEntity;
+          }
+      }
+      return null;
+  }
+}
\ No newline at end of file
diff --git a/src/main/java/net/minecraft/server/PlayerChunk.java b/src/main/java/net/minecraft/server/PlayerChunk.java
index ad1c81e..0200bc2 100644
--- a/src/main/java/net/minecraft/server/PlayerChunk.java
+++ b/src/main/java/net/minecraft/server/PlayerChunk.java
@@ -177,7 +177,7 @@ public class PlayerChunk {
             if (this.dirtyCount < 64) {
                 short short0 = (short) (i << 12 | k << 8 | j);
 
-                for (int l = 0; l < this.dirtyCount;l) {
+                for (int l = 0; l < this.dirtyCount; ++l) { // Torch - fix sign
                     if (this.dirtyBlocks[l] == short0) {
                         return;
                     }
@@ -191,7 +191,7 @@ public class PlayerChunk {
 
     public void a(Packet<?> packet) {
         if (this.done) {
-            for (int i = 0; i < this.c.size();i) {
+            for (int i = 0; i < this.c.size(); ++i) {
                 ((EntityPlayer) this.c.get(i)).playerConnection.sendPacket(packet);
             }
 
@@ -220,7 +220,7 @@ public class PlayerChunk {
                 } else {
                     this.a((Packet) (new PacketPlayOutMultiBlockChange(this.dirtyCount, this.dirtyBlocks, this.chunk)));
 
-                    for (i = 0; i < this.dirtyCount;i) {
+                    for (i = 0; i < this.dirtyCount; ++i) {
                         j = (this.dirtyBlocks[i] >> 12 & 15) + this.location.x * 16;
                         k = this.dirtyBlocks[i] & 255;
                         int l = (this.dirtyBlocks[i] >> 8 & 15) + this.location.z * 16;
@@ -260,7 +260,7 @@ public class PlayerChunk {
     public boolean a(double d0, Predicate<EntityPlayer> predicate) {
         int i = 0;
 
-        for (int j = this.c.size(); i < j;i) {
+        for (int j = this.c.size(); i < j; ++i) {
             EntityPlayer entityplayer = (EntityPlayer) this.c.get(i);
 
             if (predicate.apply(entityplayer) && this.location.a(entityplayer) < d0 * d0) {
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index fdbd17a..2feb2de 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -280,8 +280,8 @@ public abstract class World implements IBlockAccess {
         return blockposition.isValidLocation(); // Paper
     }
 
-    private boolean E(BlockPosition blockposition) {
-        return blockposition.getY() < 0 || blockposition.getY() >= 256;
+    private static boolean E(BlockPosition blockposition) { // Paper - unused but incase reflection / future uses
+        return blockposition.isInvalidYLocation(); // Paper
     }
 
     public boolean isEmpty(BlockPosition blockposition) {
@@ -373,7 +373,7 @@ public abstract class World implements IBlockAccess {
             return true;
         }
         // CraftBukkit end
-        if (this.E(blockposition)) {
+        if (blockposition.isInvalidYLocation()) { // Paper
             return false;
         } else if (!this.isClientSide && this.worldData.getType() == WorldType.DEBUG_ALL_BLOCK_STATES) {
             return false;
@@ -793,19 +793,18 @@ public abstract class World implements IBlockAccess {
     // Paper start - reduces need to do isLoaded before getType
     public IBlockData getTypeIfLoaded(BlockPosition blockposition) {
         // CraftBukkit start - tree generation
-        if (captureTreeGeneration) {
-            Iterator<BlockState> it = capturedBlockStates.iterator();
-            while (it.hasNext()) {
-                BlockState previous = it.next();
-                if (previous.getX() == blockposition.getX() && previous.getY() == blockposition.getY() && previous.getZ() == blockposition.getZ()) {
-                    return CraftMagicNumbers.getBlock(previous.getTypeId()).fromLegacyData(previous.getRawData());
-                }
+		final int x = blockposition.getX();
+        final int y = blockposition.getY();
+        final int z = blockposition.getZ();
+        final IBlockData previous = getCapturedBlockType(x, y, z);
+            if (previous != null) {
+                return previous;
             }
         }
         // CraftBukkit end
-        Chunk chunk = this.getChunkIfLoaded(blockposition);
+        Chunk chunk = ((ChunkProviderServer) this.chunkProvider).getChunkIfLoaded(x >> 4, z >> 4);
         if (chunk != null) {
-            return blockposition.isValidLocation() ? chunk.getBlockData(blockposition) : Blocks.AIR.getBlockData();
+            return chunk.getBlockData(x, y, z);
         }
         return null;
     }
@@ -813,24 +812,34 @@ public abstract class World implements IBlockAccess {
 
     public IBlockData getType(BlockPosition blockposition) {
         // CraftBukkit start - tree generation
+		// Paper start - optimize getType lookup to reduce instructions - getBlockData already enforces valid Y, move tree out
+        final int x = blockposition.getX();
+        final int y = blockposition.getY();
+        final int z = blockposition.getZ();
         if (captureTreeGeneration) {
-            Iterator<BlockState> it = capturedBlockStates.iterator();
-            while (it.hasNext()) {
-                BlockState previous = it.next();
-                if (previous.getX() == blockposition.getX() && previous.getY() == blockposition.getY() && previous.getZ() == blockposition.getZ()) {
-                    return CraftMagicNumbers.getBlock(previous.getTypeId()).fromLegacyData(previous.getRawData());
-                }
+            final IBlockData previous = getCapturedBlockType(x, y, z);
+            if (previous != null) {
+                return previous;
             }
         }
         // CraftBukkit end
-        if (this.E(blockposition)) {
-            return Blocks.AIR.getBlockData();
-        } else {
-            Chunk chunk = this.getChunkAtWorldCoords(blockposition);
-
-            return chunk.getBlockData(blockposition);
+            return this.chunkProvider.getChunkAt(x >> 4, z >> 4).getBlockData(x, y, z);
+        // Paper end
         }
     }
+	
+	// Paper start
+    private IBlockData getCapturedBlockType(int x, int y, int z) {
+        Iterator<BlockState> it = capturedBlockStates.iterator();
+        while (it.hasNext()) {
+            BlockState previous = it.next();
+            if (previous.getX() == x && previous.getY() == y && previous.getZ() == z) {
+                return CraftMagicNumbers.getBlock(previous.getTypeId()).fromLegacyData(previous.getRawData());
+            }
+         }
+       return null;
+	}
+	// Paper end
 
     public boolean B() {
         return this.J < 4;
@@ -1028,6 +1037,7 @@ public abstract class World implements IBlockAccess {
     public boolean addEntity(Entity entity, SpawnReason spawnReason) { // Changed signature, added SpawnReason
         org.spigotmc.AsyncCatcher.catchOp( "entity add"); // Spigot
         if (entity == null) return false;
+		if (entity.valid) { MinecraftServer.LOGGER.error("Attempted Double World add on " + entity, new Throwable()); return true; } // Paper
         // CraftBukkit end
         int i = MathHelper.floor(entity.locX / 16.0D);
         int j = MathHelper.floor(entity.locZ / 16.0D);
@@ -2055,7 +2065,7 @@ public abstract class World implements IBlockAccess {
     public Map<BlockPosition, TileEntity> capturedTileEntities = Maps.newHashMap();
     @Nullable
     public TileEntity getTileEntity(BlockPosition blockposition) {
-        if (this.E(blockposition)) {
+        if (blockposition.isInvalidYLocation()) { // Paper
             return null;
         } else {
             // CraftBukkit start
@@ -2096,7 +2106,7 @@ public abstract class World implements IBlockAccess {
     }
 
     public void setTileEntity(BlockPosition blockposition, @Nullable TileEntity tileentity) {
-        if (!this.E(blockposition)) {
+        if (!blockposition.isInvalidYLocation()) { // Paper
             if (tileentity != null && !tileentity.x()) {
             // CraftBukkit start
             if (captureBlockStates) {
@@ -2159,7 +2169,7 @@ public abstract class World implements IBlockAccess {
     }
 
     public boolean d(BlockPosition blockposition, boolean flag) {
-        if (this.E(blockposition)) {
+        if (blockposition.isInvalidYLocation()) { // Paper
             return false;
         } else {
             Chunk chunk = this.chunkProvider.getLoadedChunkAt(blockposition.getX() >> 4, blockposition.getZ() >> 4);
-- 
2.8.2.windows.1

